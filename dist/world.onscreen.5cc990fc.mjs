var Lr = Object.defineProperty;
var Nr = (c, e, t) => e in c ? Lr(c, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : c[e] = t;
var _t = (c, e, t) => (Nr(c, typeof e != "symbol" ? e + "" : e, t), t), ps = (c, e, t) => {
  if (!e.has(c))
    throw TypeError("Cannot " + t);
};
var K = (c, e, t) => (ps(c, e, "read from private field"), t ? t.call(c) : e.get(c)), Je = (c, e, t) => {
  if (e.has(c))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(c) : e.set(c, t);
}, rt = (c, e, t, i) => (ps(c, e, "write to private field"), i ? i.call(c, t) : e.set(c, t), t), ui = (c, e, t, i) => ({
  set _(s) {
    rt(c, e, s, t);
  },
  get _() {
    return K(c, e, i);
  }
}), Xs = (c, e, t) => (ps(c, e, "access private method"), t);
import { d as dr } from "./dice-box.es.js";
class se {
  static WithinEpsilon(e, t, i = 1401298e-51) {
    return Math.abs(e - t) <= i;
  }
  static ToHex(e) {
    const t = e.toString(16);
    return e <= 15 ? ("0" + t).toUpperCase() : t.toUpperCase();
  }
  static Sign(e) {
    return e = +e, e === 0 || isNaN(e) ? e : e > 0 ? 1 : -1;
  }
  static Clamp(e, t = 0, i = 1) {
    return Math.min(i, Math.max(t, e));
  }
  static Log2(e) {
    return Math.log(e) * Math.LOG2E;
  }
  static ILog2(e) {
    if (Math.log2)
      return Math.floor(Math.log2(e));
    if (e < 0)
      return NaN;
    if (e === 0)
      return -1 / 0;
    let t = 0;
    if (e < 1) {
      for (; e < 1; )
        t++, e = e * 2;
      t = -t;
    } else if (e > 1)
      for (; e > 1; )
        t++, e = Math.floor(e / 2);
    return t;
  }
  static Repeat(e, t) {
    return e - Math.floor(e / t) * t;
  }
  static Normalize(e, t, i) {
    return (e - t) / (i - t);
  }
  static Denormalize(e, t, i) {
    return e * (i - t) + t;
  }
  static DeltaAngle(e, t) {
    let i = se.Repeat(t - e, 360);
    return i > 180 && (i -= 360), i;
  }
  static PingPong(e, t) {
    const i = se.Repeat(e, t * 2);
    return t - Math.abs(i - t);
  }
  static SmoothStep(e, t, i) {
    let s = se.Clamp(i);
    return s = -2 * s * s * s + 3 * s * s, t * s + e * (1 - s);
  }
  static MoveTowards(e, t, i) {
    let s = 0;
    return Math.abs(t - e) <= i ? s = t : s = e + se.Sign(t - e) * i, s;
  }
  static MoveTowardsAngle(e, t, i) {
    const s = se.DeltaAngle(e, t);
    let r = 0;
    return -i < s && s < i ? r = t : (t = e + s, r = se.MoveTowards(e, t, i)), r;
  }
  static Lerp(e, t, i) {
    return e + (t - e) * i;
  }
  static LerpAngle(e, t, i) {
    let s = se.Repeat(t - e, 360);
    return s > 180 && (s -= 360), e + s * se.Clamp(i);
  }
  static InverseLerp(e, t, i) {
    let s = 0;
    return e != t ? s = se.Clamp((i - e) / (t - e)) : s = 0, s;
  }
  static Hermite(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, h = -2 * a + 3 * n, l = a - 2 * n + r, u = a - n;
    return e * o + i * h + t * l + s * u;
  }
  static Hermite1stDerivative(e, t, i, s, r) {
    const n = r * r;
    return (n - r) * 6 * e + (3 * n - 4 * r + 1) * t + (-n + r) * 6 * i + (3 * n - 2 * r) * s;
  }
  static RandomRange(e, t) {
    return e === t ? e : Math.random() * (t - e) + e;
  }
  static RangeToPercent(e, t, i) {
    return (e - t) / (i - t);
  }
  static PercentToRange(e, t, i) {
    return (i - t) * e + t;
  }
  static NormalizeRadians(e) {
    return e -= se.TwoPi * Math.floor((e + Math.PI) / se.TwoPi), e;
  }
  static HCF(e, t) {
    const i = e % t;
    return i === 0 ? t : se.HCF(t, i);
  }
}
se.TwoPi = Math.PI * 2;
const gi = 1 / 2.2, pi = 2.2, Re = 1e-3;
class Me {
  static BuildArray(e, t) {
    const i = [];
    for (let s = 0; s < e; ++s)
      i.push(t());
    return i;
  }
  static BuildTuple(e, t) {
    return Me.BuildArray(e, t);
  }
  static _ProxySet(e, t, i, s) {
    return e.notifyObservers({ target: t, previousLength: t.length }), Reflect.set(t, i, s);
  }
  static _ProxyPushOrUnshift(e, t, i, ...s) {
    return t.notifyObservers({ target: i, previousLength: i.length }), e === "push" ? Array.prototype.push.apply(i, s) : Array.prototype.unshift.apply(i, s);
  }
  static _ProxyDelete(e, t, i) {
    return e.notifyObservers({ target: t, previousLength: t.length }), Reflect.deleteProperty(t, i);
  }
  static _ProxyPopOrShift(e, t, i) {
    const s = e === "pop" ? Array.prototype.pop.apply(i) : Array.prototype.shift.apply(i);
    return t.notifyObservers({ target: i, previousLength: i.length }), s;
  }
  static _ProxySplice(e, t, i, s, ...r) {
    const n = Array.prototype.splice.apply(t, [i, s, r]);
    return e.notifyObservers({ target: t, previousLength: t.length }), n;
  }
  static MakeObservableArray(e, t) {
    let i;
    if (t && !Object.prototype.hasOwnProperty.call(t, "isObserved")) {
      const s = {
        set: (r, n, a) => Me._ProxySet(e, r, n, a),
        push: (r, ...n) => Me._ProxyPushOrUnshift("push", e, r, ...n),
        unshift: (r, ...n) => Me._ProxyPushOrUnshift("unshift", e, r, ...n),
        delete: (r, n) => Me._ProxyDelete(e, r, n),
        pop: (r) => Me._ProxyPopOrShift("pop", e, r),
        shift: (r) => Me._ProxyPopOrShift("shift", e, r),
        splice: (r, n, a, ...o) => Me._ProxySplice(e, r, n, a, ...o),
        isObserved: !0
      };
      i = new Proxy(t, s);
    } else
      i = t;
    return e.notifyObservers({ target: i }), i;
  }
}
const _r = {};
function it(c, e) {
  _r[c] = e;
}
function oi(c) {
  return _r[c];
}
class Ue {
  static SetMatrixPrecision(e) {
    if (Ue.MatrixTrackPrecisionChange = !1, e && !Ue.MatrixUse64Bits && Ue.MatrixTrackedMatrices)
      for (let t = 0; t < Ue.MatrixTrackedMatrices.length; ++t) {
        const i = Ue.MatrixTrackedMatrices[t], s = i._m;
        i._m = new Array(16);
        for (let r = 0; r < 16; ++r)
          i._m[r] = s[r];
      }
    Ue.MatrixUse64Bits = e, Ue.MatrixCurrentType = Ue.MatrixUse64Bits ? Array : Float32Array, Ue.MatrixTrackedMatrices = null;
  }
}
Ue.MatrixUse64Bits = !1;
Ue.MatrixTrackPrecisionChange = !0;
Ue.MatrixCurrentType = Float32Array;
Ue.MatrixTrackedMatrices = [];
class _e {
  static get LastCreatedEngine() {
    return this.Instances.length === 0 ? null : this.Instances[this.Instances.length - 1];
  }
  static get LastCreatedScene() {
    return this._LastCreatedScene;
  }
}
_e.Instances = new Array();
_e._LastCreatedScene = null;
_e.UseFallbackTexture = !0;
_e.FallbackTexture = "";
const tt = (c) => parseInt(c.toString().replace(/\W/g, ""));
class ee {
  constructor(e = 0, t = 0) {
    this.x = e, this.y = t;
  }
  toString() {
    return `{X: ${this.x} Y: ${this.y}}`;
  }
  getClassName() {
    return "Vector2";
  }
  getHashCode() {
    const e = tt(this.x), t = tt(this.y);
    let i = e;
    return i = i * 397 ^ t, i;
  }
  toArray(e, t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, this;
  }
  fromArray(e, t = 0) {
    return ee.FromArrayToRef(e, t, this), this;
  }
  asArray() {
    const e = new Array();
    return this.toArray(e, 0), e;
  }
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  copyFromFloats(e, t) {
    return this.x = e, this.y = t, this;
  }
  set(e, t) {
    return this.copyFromFloats(e, t);
  }
  add(e) {
    return new ee(this.x + e.x, this.y + e.y);
  }
  addToRef(e, t) {
    return t.x = this.x + e.x, t.y = this.y + e.y, this;
  }
  addInPlace(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addVector3(e) {
    return new ee(this.x + e.x, this.y + e.y);
  }
  subtract(e) {
    return new ee(this.x - e.x, this.y - e.y);
  }
  subtractToRef(e, t) {
    return t.x = this.x - e.x, t.y = this.y - e.y, this;
  }
  subtractInPlace(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  multiplyInPlace(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiply(e) {
    return new ee(this.x * e.x, this.y * e.y);
  }
  multiplyToRef(e, t) {
    return t.x = this.x * e.x, t.y = this.y * e.y, this;
  }
  multiplyByFloats(e, t) {
    return new ee(this.x * e, this.y * t);
  }
  divide(e) {
    return new ee(this.x / e.x, this.y / e.y);
  }
  divideToRef(e, t) {
    return t.x = this.x / e.x, t.y = this.y / e.y, this;
  }
  divideInPlace(e) {
    return this.divideToRef(e, this);
  }
  negate() {
    return new ee(-this.x, -this.y);
  }
  negateInPlace() {
    return this.x *= -1, this.y *= -1, this;
  }
  negateToRef(e) {
    return e.copyFromFloats(this.x * -1, this.y * -1);
  }
  scaleInPlace(e) {
    return this.x *= e, this.y *= e, this;
  }
  scale(e) {
    const t = new ee(0, 0);
    return this.scaleToRef(e, t), t;
  }
  scaleToRef(e, t) {
    return t.x = this.x * e, t.y = this.y * e, this;
  }
  scaleAndAddToRef(e, t) {
    return t.x += this.x * e, t.y += this.y * e, this;
  }
  equals(e) {
    return e && this.x === e.x && this.y === e.y;
  }
  equalsWithEpsilon(e, t = Re) {
    return e && se.WithinEpsilon(this.x, e.x, t) && se.WithinEpsilon(this.y, e.y, t);
  }
  floor() {
    return new ee(Math.floor(this.x), Math.floor(this.y));
  }
  fract() {
    return new ee(this.x - Math.floor(this.x), this.y - Math.floor(this.y));
  }
  rotateToRef(e, t) {
    const i = Math.cos(e), s = Math.sin(e);
    return t.x = i * this.x - s * this.y, t.y = s * this.x + i * this.y, this;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  lengthSquared() {
    return this.x * this.x + this.y * this.y;
  }
  normalize() {
    return ee.NormalizeToRef(this, this), this;
  }
  clone() {
    return new ee(this.x, this.y);
  }
  static Zero() {
    return new ee(0, 0);
  }
  static One() {
    return new ee(1, 1);
  }
  static get ZeroReadOnly() {
    return ee._ZeroReadOnly;
  }
  static FromArray(e, t = 0) {
    return new ee(e[t], e[t + 1]);
  }
  static FromArrayToRef(e, t, i) {
    i.x = e[t], i.y = e[t + 1];
  }
  static CatmullRom(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 0.5 * (2 * t.x + (-e.x + i.x) * r + (2 * e.x - 5 * t.x + 4 * i.x - s.x) * n + (-e.x + 3 * t.x - 3 * i.x + s.x) * a), h = 0.5 * (2 * t.y + (-e.y + i.y) * r + (2 * e.y - 5 * t.y + 4 * i.y - s.y) * n + (-e.y + 3 * t.y - 3 * i.y + s.y) * a);
    return new ee(o, h);
  }
  static Clamp(e, t, i) {
    let s = e.x;
    s = s > i.x ? i.x : s, s = s < t.x ? t.x : s;
    let r = e.y;
    return r = r > i.y ? i.y : r, r = r < t.y ? t.y : r, new ee(s, r);
  }
  static Hermite(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, h = -2 * a + 3 * n, l = a - 2 * n + r, u = a - n, f = e.x * o + i.x * h + t.x * l + s.x * u, d = e.y * o + i.y * h + t.y * l + s.y * u;
    return new ee(f, d);
  }
  static Hermite1stDerivative(e, t, i, s, r) {
    const n = ee.Zero();
    return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n;
  }
  static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
    const a = r * r;
    n.x = (a - r) * 6 * e.x + (3 * a - 4 * r + 1) * t.x + (-a + r) * 6 * i.x + (3 * a - 2 * r) * s.x, n.y = (a - r) * 6 * e.y + (3 * a - 4 * r + 1) * t.y + (-a + r) * 6 * i.y + (3 * a - 2 * r) * s.y;
  }
  static Lerp(e, t, i) {
    const s = e.x + (t.x - e.x) * i, r = e.y + (t.y - e.y) * i;
    return new ee(s, r);
  }
  static Dot(e, t) {
    return e.x * t.x + e.y * t.y;
  }
  static Normalize(e) {
    const t = ee.Zero();
    return this.NormalizeToRef(e, t), t;
  }
  static NormalizeToRef(e, t) {
    const i = e.length();
    i !== 0 && (t.x = e.x / i, t.y = e.y / i);
  }
  static Minimize(e, t) {
    const i = e.x < t.x ? e.x : t.x, s = e.y < t.y ? e.y : t.y;
    return new ee(i, s);
  }
  static Maximize(e, t) {
    const i = e.x > t.x ? e.x : t.x, s = e.y > t.y ? e.y : t.y;
    return new ee(i, s);
  }
  static Transform(e, t) {
    const i = ee.Zero();
    return ee.TransformToRef(e, t, i), i;
  }
  static TransformToRef(e, t, i) {
    const s = t.m, r = e.x * s[0] + e.y * s[4] + s[12], n = e.x * s[1] + e.y * s[5] + s[13];
    i.x = r, i.y = n;
  }
  static PointInTriangle(e, t, i, s) {
    const r = 0.5 * (-i.y * s.x + t.y * (-i.x + s.x) + t.x * (i.y - s.y) + i.x * s.y), n = r < 0 ? -1 : 1, a = (t.y * s.x - t.x * s.y + (s.y - t.y) * e.x + (t.x - s.x) * e.y) * n, o = (t.x * i.y - t.y * i.x + (t.y - i.y) * e.x + (i.x - t.x) * e.y) * n;
    return a > 0 && o > 0 && a + o < 2 * r * n;
  }
  static Distance(e, t) {
    return Math.sqrt(ee.DistanceSquared(e, t));
  }
  static DistanceSquared(e, t) {
    const i = e.x - t.x, s = e.y - t.y;
    return i * i + s * s;
  }
  static Center(e, t) {
    return ee.CenterToRef(e, t, ee.Zero());
  }
  static CenterToRef(e, t, i) {
    return i.copyFromFloats((e.x + t.x) / 2, (e.y + t.y) / 2);
  }
  static DistanceOfPointFromSegment(e, t, i) {
    const s = ee.DistanceSquared(t, i);
    if (s === 0)
      return ee.Distance(e, t);
    const r = i.subtract(t), n = Math.max(0, Math.min(1, ee.Dot(e.subtract(t), r) / s)), a = t.add(r.multiplyByFloats(n, n));
    return ee.Distance(e, a);
  }
}
ee._ZeroReadOnly = ee.Zero();
class g {
  constructor(e = 0, t = 0, i = 0) {
    this._isDirty = !0, this._x = e, this._y = t, this._z = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._isDirty = !0;
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._isDirty = !0;
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._isDirty = !0;
  }
  toString() {
    return `{X: ${this._x} Y: ${this._y} Z: ${this._z}}`;
  }
  getClassName() {
    return "Vector3";
  }
  getHashCode() {
    const e = tt(this._x), t = tt(this._y), i = tt(this._z);
    let s = e;
    return s = s * 397 ^ t, s = s * 397 ^ i, s;
  }
  asArray() {
    const e = [];
    return this.toArray(e, 0), e;
  }
  toArray(e, t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, this;
  }
  fromArray(e, t = 0) {
    return g.FromArrayToRef(e, t, this), this;
  }
  toQuaternion() {
    return z.RotationYawPitchRoll(this._y, this._x, this._z);
  }
  addInPlace(e) {
    return this.addInPlaceFromFloats(e._x, e._y, e._z);
  }
  addInPlaceFromFloats(e, t, i) {
    return this.x += e, this.y += t, this.z += i, this;
  }
  add(e) {
    return new g(this._x + e._x, this._y + e._y, this._z + e._z);
  }
  addToRef(e, t) {
    return t.copyFromFloats(this._x + e._x, this._y + e._y, this._z + e._z);
  }
  subtractInPlace(e) {
    return this.x -= e._x, this.y -= e._y, this.z -= e._z, this;
  }
  subtract(e) {
    return new g(this._x - e._x, this._y - e._y, this._z - e._z);
  }
  subtractToRef(e, t) {
    return this.subtractFromFloatsToRef(e._x, e._y, e._z, t);
  }
  subtractFromFloats(e, t, i) {
    return new g(this._x - e, this._y - t, this._z - i);
  }
  subtractFromFloatsToRef(e, t, i, s) {
    return s.copyFromFloats(this._x - e, this._y - t, this._z - i);
  }
  negate() {
    return new g(-this._x, -this._y, -this._z);
  }
  negateInPlace() {
    return this.x *= -1, this.y *= -1, this.z *= -1, this;
  }
  negateToRef(e) {
    return e.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);
  }
  scaleInPlace(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  scale(e) {
    return new g(this._x * e, this._y * e, this._z * e);
  }
  scaleToRef(e, t) {
    return t.copyFromFloats(this._x * e, this._y * e, this._z * e);
  }
  applyRotationQuaternionToRef(e, t) {
    const i = e.w * this.x + e.y * this.z - e.z * this.y, s = e.w * this.y + e.z * this.x - e.x * this.z, r = e.w * this.z + e.x * this.y - e.y * this.x, n = -e.x * this.x - e.y * this.y - e.z * this.z;
    return t.x = i * e.w + n * -e.x + s * -e.z - r * -e.y, t.y = s * e.w + n * -e.y + r * -e.x - i * -e.z, t.z = r * e.w + n * -e.z + i * -e.y - s * -e.x, t;
  }
  applyRotationQuaternionInPlace(e) {
    return this.applyRotationQuaternionToRef(e, this);
  }
  applyRotationQuaternion(e) {
    return this.applyRotationQuaternionToRef(e, g.Zero());
  }
  scaleAndAddToRef(e, t) {
    return t.addInPlaceFromFloats(this._x * e, this._y * e, this._z * e);
  }
  projectOnPlane(e, t) {
    const i = g.Zero();
    return this.projectOnPlaneToRef(e, t, i), i;
  }
  projectOnPlaneToRef(e, t, i) {
    const s = e.normal, r = e.d, n = X.Vector3[0];
    this.subtractToRef(t, n), n.normalize();
    const a = g.Dot(n, s);
    if (Math.abs(a) < Math.pow(10, -10))
      i.setAll(1 / 0);
    else {
      const o = -(g.Dot(t, s) + r) / a, h = n.scaleInPlace(o);
      t.addToRef(h, i);
    }
  }
  equals(e) {
    return e && this._x === e._x && this._y === e._y && this._z === e._z;
  }
  equalsWithEpsilon(e, t = Re) {
    return e && se.WithinEpsilon(this._x, e._x, t) && se.WithinEpsilon(this._y, e._y, t) && se.WithinEpsilon(this._z, e._z, t);
  }
  equalsToFloats(e, t, i) {
    return this._x === e && this._y === t && this._z === i;
  }
  multiplyInPlace(e) {
    return this.x *= e._x, this.y *= e._y, this.z *= e._z, this;
  }
  multiply(e) {
    return this.multiplyByFloats(e._x, e._y, e._z);
  }
  multiplyToRef(e, t) {
    return t.copyFromFloats(this._x * e._x, this._y * e._y, this._z * e._z);
  }
  multiplyByFloats(e, t, i) {
    return new g(this._x * e, this._y * t, this._z * i);
  }
  divide(e) {
    return new g(this._x / e._x, this._y / e._y, this._z / e._z);
  }
  divideToRef(e, t) {
    return t.copyFromFloats(this._x / e._x, this._y / e._y, this._z / e._z);
  }
  divideInPlace(e) {
    return this.divideToRef(e, this);
  }
  minimizeInPlace(e) {
    return this.minimizeInPlaceFromFloats(e._x, e._y, e._z);
  }
  maximizeInPlace(e) {
    return this.maximizeInPlaceFromFloats(e._x, e._y, e._z);
  }
  minimizeInPlaceFromFloats(e, t, i) {
    return e < this._x && (this.x = e), t < this._y && (this.y = t), i < this._z && (this.z = i), this;
  }
  maximizeInPlaceFromFloats(e, t, i) {
    return e > this._x && (this.x = e), t > this._y && (this.y = t), i > this._z && (this.z = i), this;
  }
  isNonUniformWithinEpsilon(e) {
    const t = Math.abs(this._x), i = Math.abs(this._y);
    if (!se.WithinEpsilon(t, i, e))
      return !0;
    const s = Math.abs(this._z);
    return !se.WithinEpsilon(t, s, e) || !se.WithinEpsilon(i, s, e);
  }
  get isNonUniform() {
    const e = Math.abs(this._x), t = Math.abs(this._y);
    if (e !== t)
      return !0;
    const i = Math.abs(this._z);
    return e !== i;
  }
  floor() {
    return new g(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));
  }
  fract() {
    return new g(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
  }
  lengthSquared() {
    return this._x * this._x + this._y * this._y + this._z * this._z;
  }
  get hasAZeroComponent() {
    return this._x * this._y * this._z === 0;
  }
  normalize() {
    return this.normalizeFromLength(this.length());
  }
  reorderInPlace(e) {
    return e = e.toLowerCase(), e === "xyz" ? this : (X.Vector3[0].copyFrom(this), ["x", "y", "z"].forEach((t, i) => {
      this[t] = X.Vector3[0][e[i]];
    }), this);
  }
  rotateByQuaternionToRef(e, t) {
    return e.toRotationMatrix(X.Matrix[0]), g.TransformCoordinatesToRef(this, X.Matrix[0], t), t;
  }
  rotateByQuaternionAroundPointToRef(e, t, i) {
    return this.subtractToRef(t, X.Vector3[0]), X.Vector3[0].rotateByQuaternionToRef(e, X.Vector3[0]), t.addToRef(X.Vector3[0], i), i;
  }
  cross(e) {
    return g.Cross(this, e);
  }
  normalizeFromLength(e) {
    return e === 0 || e === 1 ? this : this.scaleInPlace(1 / e);
  }
  normalizeToNew() {
    const e = new g(0, 0, 0);
    return this.normalizeToRef(e), e;
  }
  normalizeToRef(e) {
    const t = this.length();
    return t === 0 || t === 1 ? e.copyFromFloats(this._x, this._y, this._z) : this.scaleToRef(1 / t, e);
  }
  clone() {
    return new g(this._x, this._y, this._z);
  }
  copyFrom(e) {
    return this.copyFromFloats(e._x, e._y, e._z);
  }
  copyFromFloats(e, t, i) {
    return this.x = e, this.y = t, this.z = i, this;
  }
  set(e, t, i) {
    return this.copyFromFloats(e, t, i);
  }
  setAll(e) {
    return this.x = this.y = this.z = e, this;
  }
  static GetClipFactor(e, t, i, s) {
    const r = g.Dot(e, i) - s, n = g.Dot(t, i) - s;
    return r / (r - n);
  }
  static GetAngleBetweenVectors(e, t, i) {
    const s = e.normalizeToRef(X.Vector3[1]), r = t.normalizeToRef(X.Vector3[2]);
    let n = g.Dot(s, r);
    n = se.Clamp(n, -1, 1);
    const a = Math.acos(n), o = X.Vector3[3];
    return g.CrossToRef(s, r, o), g.Dot(o, i) > 0 ? isNaN(a) ? 0 : a : isNaN(a) ? -Math.PI : -Math.acos(n);
  }
  static GetAngleBetweenVectorsOnPlane(e, t, i) {
    X.Vector3[0].copyFrom(e);
    const s = X.Vector3[0];
    X.Vector3[1].copyFrom(t);
    const r = X.Vector3[1];
    X.Vector3[2].copyFrom(i);
    const n = X.Vector3[2], a = X.Vector3[3], o = X.Vector3[4];
    s.normalize(), r.normalize(), n.normalize(), g.CrossToRef(n, s, a), g.CrossToRef(a, n, o);
    const h = Math.atan2(g.Dot(r, a), g.Dot(r, o));
    return se.NormalizeRadians(h);
  }
  static SlerpToRef(e, t, i, s) {
    i = se.Clamp(i, 0, 1);
    const r = X.Vector3[0], n = X.Vector3[1];
    r.copyFrom(e);
    const a = r.length();
    r.normalizeFromLength(a), n.copyFrom(t);
    const o = n.length();
    n.normalizeFromLength(o);
    const h = g.Dot(r, n);
    let l, u;
    if (h < 1 - Re) {
      const f = Math.acos(h), d = 1 / Math.sin(f);
      l = Math.sin((1 - i) * f) * d, u = Math.sin(i * f) * d;
    } else
      l = 1 - i, u = i;
    r.scaleInPlace(l), n.scaleInPlace(u), s.copyFrom(r).addInPlace(n), s.scaleInPlace(se.Lerp(a, o, i));
  }
  static SmoothToRef(e, t, i, s, r) {
    g.SlerpToRef(e, t, s === 0 ? 1 : i / s, r);
  }
  static FromArray(e, t = 0) {
    return new g(e[t], e[t + 1], e[t + 2]);
  }
  static FromFloatArray(e, t) {
    return g.FromArray(e, t);
  }
  static FromArrayToRef(e, t, i) {
    i.x = e[t], i.y = e[t + 1], i.z = e[t + 2];
  }
  static FromFloatArrayToRef(e, t, i) {
    return g.FromArrayToRef(e, t, i);
  }
  static FromFloatsToRef(e, t, i, s) {
    s.copyFromFloats(e, t, i);
  }
  static Zero() {
    return new g(0, 0, 0);
  }
  static One() {
    return new g(1, 1, 1);
  }
  static Up() {
    return new g(0, 1, 0);
  }
  static get UpReadOnly() {
    return g._UpReadOnly;
  }
  static get DownReadOnly() {
    return g._DownReadOnly;
  }
  static get RightReadOnly() {
    return g._RightReadOnly;
  }
  static get LeftReadOnly() {
    return g._LeftReadOnly;
  }
  static get LeftHandedForwardReadOnly() {
    return g._LeftHandedForwardReadOnly;
  }
  static get RightHandedForwardReadOnly() {
    return g._RightHandedForwardReadOnly;
  }
  static get ZeroReadOnly() {
    return g._ZeroReadOnly;
  }
  static Down() {
    return new g(0, -1, 0);
  }
  static Forward(e = !1) {
    return new g(0, 0, e ? -1 : 1);
  }
  static Backward(e = !1) {
    return new g(0, 0, e ? 1 : -1);
  }
  static Right() {
    return new g(1, 0, 0);
  }
  static Left() {
    return new g(-1, 0, 0);
  }
  static TransformCoordinates(e, t) {
    const i = g.Zero();
    return g.TransformCoordinatesToRef(e, t, i), i;
  }
  static TransformCoordinatesToRef(e, t, i) {
    g.TransformCoordinatesFromFloatsToRef(e._x, e._y, e._z, t, i);
  }
  static TransformCoordinatesFromFloatsToRef(e, t, i, s, r) {
    const n = s.m, a = e * n[0] + t * n[4] + i * n[8] + n[12], o = e * n[1] + t * n[5] + i * n[9] + n[13], h = e * n[2] + t * n[6] + i * n[10] + n[14], l = 1 / (e * n[3] + t * n[7] + i * n[11] + n[15]);
    r.x = a * l, r.y = o * l, r.z = h * l;
  }
  static TransformNormal(e, t) {
    const i = g.Zero();
    return g.TransformNormalToRef(e, t, i), i;
  }
  static TransformNormalToRef(e, t, i) {
    this.TransformNormalFromFloatsToRef(e._x, e._y, e._z, t, i);
  }
  static TransformNormalFromFloatsToRef(e, t, i, s, r) {
    const n = s.m;
    r.x = e * n[0] + t * n[4] + i * n[8], r.y = e * n[1] + t * n[5] + i * n[9], r.z = e * n[2] + t * n[6] + i * n[10];
  }
  static CatmullRom(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 0.5 * (2 * t._x + (-e._x + i._x) * r + (2 * e._x - 5 * t._x + 4 * i._x - s._x) * n + (-e._x + 3 * t._x - 3 * i._x + s._x) * a), h = 0.5 * (2 * t._y + (-e._y + i._y) * r + (2 * e._y - 5 * t._y + 4 * i._y - s._y) * n + (-e._y + 3 * t._y - 3 * i._y + s._y) * a), l = 0.5 * (2 * t._z + (-e._z + i._z) * r + (2 * e._z - 5 * t._z + 4 * i._z - s._z) * n + (-e._z + 3 * t._z - 3 * i._z + s._z) * a);
    return new g(o, h, l);
  }
  static Clamp(e, t, i) {
    const s = new g();
    return g.ClampToRef(e, t, i, s), s;
  }
  static ClampToRef(e, t, i, s) {
    let r = e._x;
    r = r > i._x ? i._x : r, r = r < t._x ? t._x : r;
    let n = e._y;
    n = n > i._y ? i._y : n, n = n < t._y ? t._y : n;
    let a = e._z;
    a = a > i._z ? i._z : a, a = a < t._z ? t._z : a, s.copyFromFloats(r, n, a);
  }
  static CheckExtends(e, t, i) {
    t.minimizeInPlace(e), i.maximizeInPlace(e);
  }
  static Hermite(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, h = -2 * a + 3 * n, l = a - 2 * n + r, u = a - n, f = e._x * o + i._x * h + t._x * l + s._x * u, d = e._y * o + i._y * h + t._y * l + s._y * u, _ = e._z * o + i._z * h + t._z * l + s._z * u;
    return new g(f, d, _);
  }
  static Hermite1stDerivative(e, t, i, s, r) {
    const n = g.Zero();
    return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n;
  }
  static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
    const a = r * r;
    n.x = (a - r) * 6 * e.x + (3 * a - 4 * r + 1) * t.x + (-a + r) * 6 * i.x + (3 * a - 2 * r) * s.x, n.y = (a - r) * 6 * e.y + (3 * a - 4 * r + 1) * t.y + (-a + r) * 6 * i.y + (3 * a - 2 * r) * s.y, n.z = (a - r) * 6 * e.z + (3 * a - 4 * r + 1) * t.z + (-a + r) * 6 * i.z + (3 * a - 2 * r) * s.z;
  }
  static Lerp(e, t, i) {
    const s = new g(0, 0, 0);
    return g.LerpToRef(e, t, i, s), s;
  }
  static LerpToRef(e, t, i, s) {
    s.x = e._x + (t._x - e._x) * i, s.y = e._y + (t._y - e._y) * i, s.z = e._z + (t._z - e._z) * i;
  }
  static Dot(e, t) {
    return e._x * t._x + e._y * t._y + e._z * t._z;
  }
  static Cross(e, t) {
    const i = g.Zero();
    return g.CrossToRef(e, t, i), i;
  }
  static CrossToRef(e, t, i) {
    const s = e._y * t._z - e._z * t._y, r = e._z * t._x - e._x * t._z, n = e._x * t._y - e._y * t._x;
    i.copyFromFloats(s, r, n);
  }
  static Normalize(e) {
    const t = g.Zero();
    return g.NormalizeToRef(e, t), t;
  }
  static NormalizeToRef(e, t) {
    e.normalizeToRef(t);
  }
  static Project(e, t, i, s) {
    const r = new g();
    return g.ProjectToRef(e, t, i, s, r), r;
  }
  static ProjectToRef(e, t, i, s, r) {
    const n = s.width, a = s.height, o = s.x, h = s.y, l = X.Matrix[1];
    x.FromValuesToRef(n / 2, 0, 0, 0, 0, -a / 2, 0, 0, 0, 0, 0.5, 0, o + n / 2, a / 2 + h, 0.5, 1, l);
    const u = X.Matrix[0];
    return t.multiplyToRef(i, u), u.multiplyToRef(l, u), g.TransformCoordinatesToRef(e, u, r), r;
  }
  static _UnprojectFromInvertedMatrixToRef(e, t, i) {
    g.TransformCoordinatesToRef(e, t, i);
    const s = t.m, r = e._x * s[3] + e._y * s[7] + e._z * s[11] + s[15];
    se.WithinEpsilon(r, 1) && i.scaleInPlace(1 / r);
  }
  static UnprojectFromTransform(e, t, i, s, r) {
    return this.Unproject(e, t, i, s, r, x.IdentityReadOnly);
  }
  static Unproject(e, t, i, s, r, n) {
    const a = g.Zero();
    return g.UnprojectToRef(e, t, i, s, r, n, a), a;
  }
  static UnprojectToRef(e, t, i, s, r, n, a) {
    g.UnprojectFloatsToRef(e._x, e._y, e._z, t, i, s, r, n, a);
  }
  static UnprojectFloatsToRef(e, t, i, s, r, n, a, o, h) {
    var f;
    const l = X.Matrix[0];
    n.multiplyToRef(a, l), l.multiplyToRef(o, l), l.invert();
    const u = X.Vector3[0];
    u.x = e / s * 2 - 1, u.y = -(t / r * 2 - 1), (f = _e.LastCreatedEngine) != null && f.isNDCHalfZRange ? u.z = i : u.z = 2 * i - 1, g._UnprojectFromInvertedMatrixToRef(u, l, h);
  }
  static Minimize(e, t) {
    const i = e.clone();
    return i.minimizeInPlace(t), i;
  }
  static Maximize(e, t) {
    const i = e.clone();
    return i.maximizeInPlace(t), i;
  }
  static Distance(e, t) {
    return Math.sqrt(g.DistanceSquared(e, t));
  }
  static DistanceSquared(e, t) {
    const i = e._x - t._x, s = e._y - t._y, r = e._z - t._z;
    return i * i + s * s + r * r;
  }
  static ProjectOnTriangleToRef(e, t, i, s, r) {
    const n = X.Vector3[0], a = X.Vector3[1], o = X.Vector3[2], h = X.Vector3[3], l = X.Vector3[4];
    i.subtractToRef(t, n), s.subtractToRef(t, a), s.subtractToRef(i, o);
    const u = n.length(), f = a.length(), d = o.length();
    if (u < Re || f < Re || d < Re)
      return r.copyFrom(t), g.Distance(e, t);
    e.subtractToRef(t, l), g.CrossToRef(n, a, h);
    const _ = h.length();
    if (_ < Re)
      return r.copyFrom(t), g.Distance(e, t);
    h.normalizeFromLength(_);
    let E = l.length();
    if (E < Re)
      return r.copyFrom(t), 0;
    l.normalizeFromLength(E);
    const m = g.Dot(h, l), T = X.Vector3[5], b = X.Vector3[6];
    T.copyFrom(h).scaleInPlace(-E * m), b.copyFrom(e).addInPlace(T);
    const R = X.Vector3[4], y = X.Vector3[5], P = X.Vector3[7], v = X.Vector3[8];
    R.copyFrom(n).scaleInPlace(1 / u), v.copyFrom(a).scaleInPlace(1 / f), R.addInPlace(v).scaleInPlace(-1), y.copyFrom(n).scaleInPlace(-1 / u), v.copyFrom(o).scaleInPlace(1 / d), y.addInPlace(v).scaleInPlace(-1), P.copyFrom(o).scaleInPlace(-1 / d), v.copyFrom(a).scaleInPlace(-1 / f), P.addInPlace(v).scaleInPlace(-1);
    const A = X.Vector3[9];
    let L;
    A.copyFrom(b).subtractInPlace(t), g.CrossToRef(R, A, v), L = g.Dot(v, h);
    const Q = L;
    A.copyFrom(b).subtractInPlace(i), g.CrossToRef(y, A, v), L = g.Dot(v, h);
    const ae = L;
    A.copyFrom(b).subtractInPlace(s), g.CrossToRef(P, A, v), L = g.Dot(v, h);
    const be = L, fe = X.Vector3[10];
    let ue, ie;
    Q > 0 && ae < 0 ? (fe.copyFrom(n), ue = t, ie = i) : ae > 0 && be < 0 ? (fe.copyFrom(o), ue = i, ie = s) : (fe.copyFrom(a).scaleInPlace(-1), ue = s, ie = t);
    const ye = X.Vector3[9], Ce = X.Vector3[4];
    if (ue.subtractToRef(b, v), ie.subtractToRef(b, ye), g.CrossToRef(v, ye, Ce), !(g.Dot(Ce, h) < 0))
      return r.copyFrom(b), Math.abs(E * m);
    const ke = X.Vector3[5];
    g.CrossToRef(fe, Ce, ke), ke.normalize();
    const Ve = X.Vector3[9];
    Ve.copyFrom(ue).subtractInPlace(b);
    const ot = Ve.length();
    if (ot < Re)
      return r.copyFrom(ue), g.Distance(e, ue);
    Ve.normalizeFromLength(ot);
    const st = g.Dot(ke, Ve), Mt = X.Vector3[7];
    Mt.copyFrom(b).addInPlace(ke.scaleInPlace(ot * st)), v.copyFrom(Mt).subtractInPlace(ue), E = fe.length(), fe.normalizeFromLength(E);
    let Xt = g.Dot(v, fe) / Math.max(E, Re);
    return Xt = se.Clamp(Xt, 0, 1), Mt.copyFrom(ue).addInPlace(fe.scaleInPlace(Xt * E)), r.copyFrom(Mt), g.Distance(e, Mt);
  }
  static Center(e, t) {
    return g.CenterToRef(e, t, g.Zero());
  }
  static CenterToRef(e, t, i) {
    return i.copyFromFloats((e._x + t._x) / 2, (e._y + t._y) / 2, (e._z + t._z) / 2);
  }
  static RotationFromAxis(e, t, i) {
    const s = g.Zero();
    return g.RotationFromAxisToRef(e, t, i, s), s;
  }
  static RotationFromAxisToRef(e, t, i, s) {
    const r = X.Quaternion[0];
    z.RotationQuaternionFromAxisToRef(e, t, i, r), r.toEulerAnglesToRef(s);
  }
}
g._UpReadOnly = g.Up();
g._DownReadOnly = g.Down();
g._LeftHandedForwardReadOnly = g.Forward(!1);
g._RightHandedForwardReadOnly = g.Forward(!0);
g._RightReadOnly = g.Right();
g._LeftReadOnly = g.Left();
g._ZeroReadOnly = g.Zero();
class Ee {
  constructor(e, t, i, s) {
    this.x = e, this.y = t, this.z = i, this.w = s;
  }
  toString() {
    return `{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`;
  }
  getClassName() {
    return "Vector4";
  }
  getHashCode() {
    const e = tt(this.x), t = tt(this.y), i = tt(this.z), s = tt(this.w);
    let r = e;
    return r = r * 397 ^ t, r = r * 397 ^ i, r = r * 397 ^ s, r;
  }
  asArray() {
    const e = new Array();
    return this.toArray(e, 0), e;
  }
  toArray(e, t) {
    return t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, this;
  }
  fromArray(e, t = 0) {
    return Ee.FromArrayToRef(e, t, this), this;
  }
  addInPlace(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  add(e) {
    return new Ee(this.x + e.x, this.y + e.y, this.z + e.z, this.w + e.w);
  }
  addToRef(e, t) {
    return t.x = this.x + e.x, t.y = this.y + e.y, t.z = this.z + e.z, t.w = this.w + e.w, this;
  }
  subtractInPlace(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subtract(e) {
    return new Ee(this.x - e.x, this.y - e.y, this.z - e.z, this.w - e.w);
  }
  subtractToRef(e, t) {
    return t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z, t.w = this.w - e.w, this;
  }
  subtractFromFloats(e, t, i, s) {
    return new Ee(this.x - e, this.y - t, this.z - i, this.w - s);
  }
  subtractFromFloatsToRef(e, t, i, s, r) {
    return r.x = this.x - e, r.y = this.y - t, r.z = this.z - i, r.w = this.w - s, this;
  }
  negate() {
    return new Ee(-this.x, -this.y, -this.z, -this.w);
  }
  negateInPlace() {
    return this.x *= -1, this.y *= -1, this.z *= -1, this.w *= -1, this;
  }
  negateToRef(e) {
    return e.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);
  }
  scaleInPlace(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  scale(e) {
    return new Ee(this.x * e, this.y * e, this.z * e, this.w * e);
  }
  scaleToRef(e, t) {
    return t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e, this;
  }
  scaleAndAddToRef(e, t) {
    return t.x += this.x * e, t.y += this.y * e, t.z += this.z * e, t.w += this.w * e, this;
  }
  equals(e) {
    return e && this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w;
  }
  equalsWithEpsilon(e, t = Re) {
    return e && se.WithinEpsilon(this.x, e.x, t) && se.WithinEpsilon(this.y, e.y, t) && se.WithinEpsilon(this.z, e.z, t) && se.WithinEpsilon(this.w, e.w, t);
  }
  equalsToFloats(e, t, i, s) {
    return this.x === e && this.y === t && this.z === i && this.w === s;
  }
  multiplyInPlace(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiply(e) {
    return new Ee(this.x * e.x, this.y * e.y, this.z * e.z, this.w * e.w);
  }
  multiplyToRef(e, t) {
    return t.x = this.x * e.x, t.y = this.y * e.y, t.z = this.z * e.z, t.w = this.w * e.w, this;
  }
  multiplyByFloats(e, t, i, s) {
    return new Ee(this.x * e, this.y * t, this.z * i, this.w * s);
  }
  divide(e) {
    return new Ee(this.x / e.x, this.y / e.y, this.z / e.z, this.w / e.w);
  }
  divideToRef(e, t) {
    return t.x = this.x / e.x, t.y = this.y / e.y, t.z = this.z / e.z, t.w = this.w / e.w, this;
  }
  divideInPlace(e) {
    return this.divideToRef(e, this);
  }
  minimizeInPlace(e) {
    return e.x < this.x && (this.x = e.x), e.y < this.y && (this.y = e.y), e.z < this.z && (this.z = e.z), e.w < this.w && (this.w = e.w), this;
  }
  maximizeInPlace(e) {
    return e.x > this.x && (this.x = e.x), e.y > this.y && (this.y = e.y), e.z > this.z && (this.z = e.z), e.w > this.w && (this.w = e.w), this;
  }
  floor() {
    return new Ee(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));
  }
  fract() {
    return new Ee(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  lengthSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  normalize() {
    const e = this.length();
    return e === 0 ? this : this.scaleInPlace(1 / e);
  }
  toVector3() {
    return new g(this.x, this.y, this.z);
  }
  clone() {
    return new Ee(this.x, this.y, this.z, this.w);
  }
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;
  }
  copyFromFloats(e, t, i, s) {
    return this.x = e, this.y = t, this.z = i, this.w = s, this;
  }
  set(e, t, i, s) {
    return this.copyFromFloats(e, t, i, s);
  }
  setAll(e) {
    return this.x = this.y = this.z = this.w = e, this;
  }
  static FromArray(e, t) {
    return t || (t = 0), new Ee(e[t], e[t + 1], e[t + 2], e[t + 3]);
  }
  static FromArrayToRef(e, t, i) {
    i.x = e[t], i.y = e[t + 1], i.z = e[t + 2], i.w = e[t + 3];
  }
  static FromFloatArrayToRef(e, t, i) {
    Ee.FromArrayToRef(e, t, i);
  }
  static FromFloatsToRef(e, t, i, s, r) {
    r.x = e, r.y = t, r.z = i, r.w = s;
  }
  static Zero() {
    return new Ee(0, 0, 0, 0);
  }
  static One() {
    return new Ee(1, 1, 1, 1);
  }
  static get ZeroReadOnly() {
    return Ee._ZeroReadOnly;
  }
  static Normalize(e) {
    const t = Ee.Zero();
    return Ee.NormalizeToRef(e, t), t;
  }
  static NormalizeToRef(e, t) {
    t.copyFrom(e), t.normalize();
  }
  static Minimize(e, t) {
    const i = e.clone();
    return i.minimizeInPlace(t), i;
  }
  static Maximize(e, t) {
    const i = e.clone();
    return i.maximizeInPlace(t), i;
  }
  static Distance(e, t) {
    return Math.sqrt(Ee.DistanceSquared(e, t));
  }
  static DistanceSquared(e, t) {
    const i = e.x - t.x, s = e.y - t.y, r = e.z - t.z, n = e.w - t.w;
    return i * i + s * s + r * r + n * n;
  }
  static Center(e, t) {
    return Ee.CenterToRef(e, t, Ee.Zero());
  }
  static CenterToRef(e, t, i) {
    return i.copyFromFloats((e.x + t.x) / 2, (e.y + t.y) / 2, (e.z + t.z) / 2, (e.w + t.w) / 2);
  }
  static TransformCoordinates(e, t) {
    const i = Ee.Zero();
    return Ee.TransformCoordinatesToRef(e, t, i), i;
  }
  static TransformCoordinatesToRef(e, t, i) {
    Ee.TransformCoordinatesFromFloatsToRef(e._x, e._y, e._z, t, i);
  }
  static TransformCoordinatesFromFloatsToRef(e, t, i, s, r) {
    const n = s.m, a = e * n[0] + t * n[4] + i * n[8] + n[12], o = e * n[1] + t * n[5] + i * n[9] + n[13], h = e * n[2] + t * n[6] + i * n[10] + n[14], l = e * n[3] + t * n[7] + i * n[11] + n[15];
    r.x = a, r.y = o, r.z = h, r.w = l;
  }
  static TransformNormal(e, t) {
    const i = Ee.Zero();
    return Ee.TransformNormalToRef(e, t, i), i;
  }
  static TransformNormalToRef(e, t, i) {
    const s = t.m, r = e.x * s[0] + e.y * s[4] + e.z * s[8], n = e.x * s[1] + e.y * s[5] + e.z * s[9], a = e.x * s[2] + e.y * s[6] + e.z * s[10];
    i.x = r, i.y = n, i.z = a, i.w = e.w;
  }
  static TransformNormalFromFloatsToRef(e, t, i, s, r, n) {
    const a = r.m;
    n.x = e * a[0] + t * a[4] + i * a[8], n.y = e * a[1] + t * a[5] + i * a[9], n.z = e * a[2] + t * a[6] + i * a[10], n.w = s;
  }
  static FromVector3(e, t = 0) {
    return new Ee(e._x, e._y, e._z, t);
  }
}
Ee._ZeroReadOnly = Ee.Zero();
class z {
  constructor(e = 0, t = 0, i = 0, s = 1) {
    this._isDirty = !0, this._x = e, this._y = t, this._z = i, this._w = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._isDirty = !0;
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._isDirty = !0;
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._isDirty = !0;
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._isDirty = !0;
  }
  toString() {
    return `{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`;
  }
  getClassName() {
    return "Quaternion";
  }
  getHashCode() {
    const e = tt(this._x), t = tt(this._y), i = tt(this._z), s = tt(this._w);
    let r = e;
    return r = r * 397 ^ t, r = r * 397 ^ i, r = r * 397 ^ s, r;
  }
  asArray() {
    return [this._x, this._y, this._z, this._w];
  }
  toArray(e, t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, this;
  }
  equals(e) {
    return e && this._x === e._x && this._y === e._y && this._z === e._z && this._w === e._w;
  }
  equalsWithEpsilon(e, t = Re) {
    return e && se.WithinEpsilon(this._x, e._x, t) && se.WithinEpsilon(this._y, e._y, t) && se.WithinEpsilon(this._z, e._z, t) && se.WithinEpsilon(this._w, e._w, t);
  }
  clone() {
    return new z(this._x, this._y, this._z, this._w);
  }
  copyFrom(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this.w = e._w, this;
  }
  copyFromFloats(e, t, i, s) {
    return this.x = e, this.y = t, this.z = i, this.w = s, this;
  }
  set(e, t, i, s) {
    return this.copyFromFloats(e, t, i, s);
  }
  add(e) {
    return new z(this._x + e._x, this._y + e._y, this._z + e._z, this._w + e._w);
  }
  addInPlace(e) {
    return this._x += e._x, this._y += e._y, this._z += e._z, this._w += e._w, this;
  }
  subtract(e) {
    return new z(this._x - e._x, this._y - e._y, this._z - e._z, this._w - e._w);
  }
  subtractInPlace(e) {
    return this._x -= e._x, this._y -= e._y, this._z -= e._z, this._w -= e._w, this;
  }
  scale(e) {
    return new z(this._x * e, this._y * e, this._z * e, this._w * e);
  }
  scaleToRef(e, t) {
    return t.x = this._x * e, t.y = this._y * e, t.z = this._z * e, t.w = this._w * e, this;
  }
  scaleInPlace(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  scaleAndAddToRef(e, t) {
    return t.x += this._x * e, t.y += this._y * e, t.z += this._z * e, t.w += this._w * e, this;
  }
  multiply(e) {
    const t = new z(0, 0, 0, 1);
    return this.multiplyToRef(e, t), t;
  }
  multiplyToRef(e, t) {
    const i = this._x * e._w + this._y * e._z - this._z * e._y + this._w * e._x, s = -this._x * e._z + this._y * e._w + this._z * e._x + this._w * e._y, r = this._x * e._y - this._y * e._x + this._z * e._w + this._w * e._z, n = -this._x * e._x - this._y * e._y - this._z * e._z + this._w * e._w;
    return t.copyFromFloats(i, s, r, n), this;
  }
  multiplyInPlace(e) {
    return this.multiplyToRef(e, this), this;
  }
  conjugateToRef(e) {
    return e.copyFromFloats(-this._x, -this._y, -this._z, this._w), this;
  }
  conjugateInPlace() {
    return this.x *= -1, this.y *= -1, this.z *= -1, this;
  }
  conjugate() {
    return new z(-this._x, -this._y, -this._z, this._w);
  }
  invert() {
    const e = this.conjugate(), t = this.lengthSquared();
    return t == 0 || t == 1 || e.scaleInPlace(1 / t), e;
  }
  invertInPlace() {
    this.conjugateInPlace();
    const e = this.lengthSquared();
    return e == 0 || e == 1 ? this : (this.scaleInPlace(1 / e), this);
  }
  lengthSquared() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this.lengthSquared());
  }
  normalize() {
    const e = this.length();
    if (e === 0)
      return this;
    const t = 1 / e;
    return this.scaleInPlace(t), this;
  }
  normalizeToNew() {
    const e = this.length();
    if (e === 0)
      return this.clone();
    const t = 1 / e;
    return this.scale(t);
  }
  toEulerAngles() {
    const e = g.Zero();
    return this.toEulerAnglesToRef(e), e;
  }
  toEulerAnglesToRef(e) {
    const t = this._z, i = this._x, s = this._y, r = this._w, n = s * t - i * r, a = 0.4999999;
    if (n < -a)
      e.y = 2 * Math.atan2(s, r), e.x = Math.PI / 2, e.z = 0;
    else if (n > a)
      e.y = 2 * Math.atan2(s, r), e.x = -Math.PI / 2, e.z = 0;
    else {
      const o = r * r, h = t * t, l = i * i, u = s * s;
      e.z = Math.atan2(2 * (i * s + t * r), -h - l + u + o), e.x = Math.asin(-2 * n), e.y = Math.atan2(2 * (t * i + s * r), h - l - u + o);
    }
    return this;
  }
  toRotationMatrix(e) {
    return x.FromQuaternionToRef(this, e), this;
  }
  fromRotationMatrix(e) {
    return z.FromRotationMatrixToRef(e, this), this;
  }
  static FromRotationMatrix(e) {
    const t = new z();
    return z.FromRotationMatrixToRef(e, t), t;
  }
  static FromRotationMatrixToRef(e, t) {
    const i = e.m, s = i[0], r = i[4], n = i[8], a = i[1], o = i[5], h = i[9], l = i[2], u = i[6], f = i[10], d = s + o + f;
    let _;
    d > 0 ? (_ = 0.5 / Math.sqrt(d + 1), t.w = 0.25 / _, t.x = (u - h) * _, t.y = (n - l) * _, t.z = (a - r) * _) : s > o && s > f ? (_ = 2 * Math.sqrt(1 + s - o - f), t.w = (u - h) / _, t.x = 0.25 * _, t.y = (r + a) / _, t.z = (n + l) / _) : o > f ? (_ = 2 * Math.sqrt(1 + o - s - f), t.w = (n - l) / _, t.x = (r + a) / _, t.y = 0.25 * _, t.z = (h + u) / _) : (_ = 2 * Math.sqrt(1 + f - s - o), t.w = (a - r) / _, t.x = (n + l) / _, t.y = (h + u) / _, t.z = 0.25 * _);
  }
  static Dot(e, t) {
    return e._x * t._x + e._y * t._y + e._z * t._z + e._w * t._w;
  }
  static AreClose(e, t) {
    return z.Dot(e, t) >= 0;
  }
  static SmoothToRef(e, t, i, s, r) {
    let n = s === 0 ? 1 : i / s;
    n = se.Clamp(n, 0, 1), z.SlerpToRef(e, t, n, r);
  }
  static Zero() {
    return new z(0, 0, 0, 0);
  }
  static Inverse(e) {
    return new z(-e._x, -e._y, -e._z, e._w);
  }
  static InverseToRef(e, t) {
    return t.set(-e._x, -e._y, -e._z, e._w), t;
  }
  static Identity() {
    return new z(0, 0, 0, 1);
  }
  static IsIdentity(e) {
    return e && e._x === 0 && e._y === 0 && e._z === 0 && e._w === 1;
  }
  static RotationAxis(e, t) {
    return z.RotationAxisToRef(e, t, new z());
  }
  static RotationAxisToRef(e, t, i) {
    const s = Math.sin(t / 2);
    return e.normalize(), i.w = Math.cos(t / 2), i.x = e._x * s, i.y = e._y * s, i.z = e._z * s, i;
  }
  static FromArray(e, t) {
    return t || (t = 0), new z(e[t], e[t + 1], e[t + 2], e[t + 3]);
  }
  static FromArrayToRef(e, t, i) {
    i.x = e[t], i.y = e[t + 1], i.z = e[t + 2], i.w = e[t + 3];
  }
  static FromEulerAngles(e, t, i) {
    const s = new z();
    return z.RotationYawPitchRollToRef(t, e, i, s), s;
  }
  static FromEulerAnglesToRef(e, t, i, s) {
    return z.RotationYawPitchRollToRef(t, e, i, s), s;
  }
  static FromEulerVector(e) {
    const t = new z();
    return z.RotationYawPitchRollToRef(e._y, e._x, e._z, t), t;
  }
  static FromEulerVectorToRef(e, t) {
    return z.RotationYawPitchRollToRef(e._y, e._x, e._z, t), t;
  }
  static FromUnitVectorsToRef(e, t, i) {
    const s = g.Dot(e, t) + 1;
    return s < Re ? Math.abs(e.x) > Math.abs(e.z) ? i.set(-e.y, e.x, 0, 0) : i.set(0, -e.z, e.y, 0) : (g.CrossToRef(e, t, D.Vector3[0]), i.set(D.Vector3[0].x, D.Vector3[0].y, D.Vector3[0].z, s)), i.normalize();
  }
  static RotationYawPitchRoll(e, t, i) {
    const s = new z();
    return z.RotationYawPitchRollToRef(e, t, i, s), s;
  }
  static RotationYawPitchRollToRef(e, t, i, s) {
    const r = i * 0.5, n = t * 0.5, a = e * 0.5, o = Math.sin(r), h = Math.cos(r), l = Math.sin(n), u = Math.cos(n), f = Math.sin(a), d = Math.cos(a);
    s.x = d * l * h + f * u * o, s.y = f * u * h - d * l * o, s.z = d * u * o - f * l * h, s.w = d * u * h + f * l * o;
  }
  static RotationAlphaBetaGamma(e, t, i) {
    const s = new z();
    return z.RotationAlphaBetaGammaToRef(e, t, i, s), s;
  }
  static RotationAlphaBetaGammaToRef(e, t, i, s) {
    const r = (i + e) * 0.5, n = (i - e) * 0.5, a = t * 0.5;
    s.x = Math.cos(n) * Math.sin(a), s.y = Math.sin(n) * Math.sin(a), s.z = Math.sin(r) * Math.cos(a), s.w = Math.cos(r) * Math.cos(a);
  }
  static RotationQuaternionFromAxis(e, t, i) {
    const s = new z(0, 0, 0, 0);
    return z.RotationQuaternionFromAxisToRef(e, t, i, s), s;
  }
  static RotationQuaternionFromAxisToRef(e, t, i, s) {
    const r = X.Matrix[0];
    x.FromXYZAxesToRef(e.normalize(), t.normalize(), i.normalize(), r), z.FromRotationMatrixToRef(r, s);
  }
  static FromLookDirectionLH(e, t) {
    const i = new z();
    return z.FromLookDirectionLHToRef(e, t, i), i;
  }
  static FromLookDirectionLHToRef(e, t, i) {
    const s = X.Matrix[0];
    x.LookDirectionLHToRef(e, t, s), z.FromRotationMatrixToRef(s, i);
  }
  static FromLookDirectionRH(e, t) {
    const i = new z();
    return z.FromLookDirectionRHToRef(e, t, i), i;
  }
  static FromLookDirectionRHToRef(e, t, i) {
    const s = X.Matrix[0];
    return x.LookDirectionRHToRef(e, t, s), z.FromRotationMatrixToRef(s, i);
  }
  static Slerp(e, t, i) {
    const s = z.Identity();
    return z.SlerpToRef(e, t, i, s), s;
  }
  static SlerpToRef(e, t, i, s) {
    let r, n, a = e._x * t._x + e._y * t._y + e._z * t._z + e._w * t._w, o = !1;
    if (a < 0 && (o = !0, a = -a), a > 0.999999)
      n = 1 - i, r = o ? -i : i;
    else {
      const h = Math.acos(a), l = 1 / Math.sin(h);
      n = Math.sin((1 - i) * h) * l, r = o ? -Math.sin(i * h) * l : Math.sin(i * h) * l;
    }
    s.x = n * e._x + r * t._x, s.y = n * e._y + r * t._y, s.z = n * e._z + r * t._z, s.w = n * e._w + r * t._w;
  }
  static Hermite(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, h = -2 * a + 3 * n, l = a - 2 * n + r, u = a - n, f = e._x * o + i._x * h + t._x * l + s._x * u, d = e._y * o + i._y * h + t._y * l + s._y * u, _ = e._z * o + i._z * h + t._z * l + s._z * u, E = e._w * o + i._w * h + t._w * l + s._w * u;
    return new z(f, d, _, E);
  }
  static Hermite1stDerivative(e, t, i, s, r) {
    const n = z.Zero();
    return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n;
  }
  static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
    const a = r * r;
    n.x = (a - r) * 6 * e.x + (3 * a - 4 * r + 1) * t.x + (-a + r) * 6 * i.x + (3 * a - 2 * r) * s.x, n.y = (a - r) * 6 * e.y + (3 * a - 4 * r + 1) * t.y + (-a + r) * 6 * i.y + (3 * a - 2 * r) * s.y, n.z = (a - r) * 6 * e.z + (3 * a - 4 * r + 1) * t.z + (-a + r) * 6 * i.z + (3 * a - 2 * r) * s.z, n.w = (a - r) * 6 * e.w + (3 * a - 4 * r + 1) * t.w + (-a + r) * 6 * i.w + (3 * a - 2 * r) * s.w;
  }
}
class x {
  constructor() {
    this._isIdentity = !1, this._isIdentityDirty = !0, this._isIdentity3x2 = !0, this._isIdentity3x2Dirty = !0, this.updateFlag = -1, Ue.MatrixTrackPrecisionChange && Ue.MatrixTrackedMatrices.push(this), this._m = new Ue.MatrixCurrentType(16), this.markAsUpdated();
  }
  static get Use64Bits() {
    return Ue.MatrixUse64Bits;
  }
  get m() {
    return this._m;
  }
  markAsUpdated() {
    this.updateFlag = x._UpdateFlagSeed++, this._isIdentity = !1, this._isIdentity3x2 = !1, this._isIdentityDirty = !0, this._isIdentity3x2Dirty = !0;
  }
  _updateIdentityStatus(e, t = !1, i = !1, s = !0) {
    this._isIdentity = e, this._isIdentity3x2 = e || i, this._isIdentityDirty = this._isIdentity ? !1 : t, this._isIdentity3x2Dirty = this._isIdentity3x2 ? !1 : s;
  }
  isIdentity() {
    if (this._isIdentityDirty) {
      this._isIdentityDirty = !1;
      const e = this._m;
      this._isIdentity = e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 0 && e[4] === 0 && e[5] === 1 && e[6] === 0 && e[7] === 0 && e[8] === 0 && e[9] === 0 && e[10] === 1 && e[11] === 0 && e[12] === 0 && e[13] === 0 && e[14] === 0 && e[15] === 1;
    }
    return this._isIdentity;
  }
  isIdentityAs3x2() {
    return this._isIdentity3x2Dirty && (this._isIdentity3x2Dirty = !1, this._m[0] !== 1 || this._m[5] !== 1 || this._m[15] !== 1 ? this._isIdentity3x2 = !1 : this._m[1] !== 0 || this._m[2] !== 0 || this._m[3] !== 0 || this._m[4] !== 0 || this._m[6] !== 0 || this._m[7] !== 0 || this._m[8] !== 0 || this._m[9] !== 0 || this._m[10] !== 0 || this._m[11] !== 0 || this._m[12] !== 0 || this._m[13] !== 0 || this._m[14] !== 0 ? this._isIdentity3x2 = !1 : this._isIdentity3x2 = !0), this._isIdentity3x2;
  }
  determinant() {
    if (this._isIdentity === !0)
      return 1;
    const e = this._m, t = e[0], i = e[1], s = e[2], r = e[3], n = e[4], a = e[5], o = e[6], h = e[7], l = e[8], u = e[9], f = e[10], d = e[11], _ = e[12], E = e[13], m = e[14], T = e[15], b = f * T - m * d, R = u * T - E * d, y = u * m - E * f, P = l * T - _ * d, v = l * m - f * _, A = l * E - _ * u, L = +(a * b - o * R + h * y), Q = -(n * b - o * P + h * v), ae = +(n * R - a * P + h * A), be = -(n * y - a * v + o * A);
    return t * L + i * Q + s * ae + r * be;
  }
  toArray() {
    return this._m;
  }
  asArray() {
    return this._m;
  }
  invert() {
    return this.invertToRef(this), this;
  }
  reset() {
    return x.FromValuesToRef(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this), this._updateIdentityStatus(!1), this;
  }
  add(e) {
    const t = new x();
    return this.addToRef(e, t), t;
  }
  addToRef(e, t) {
    const i = this._m, s = t._m, r = e.m;
    for (let n = 0; n < 16; n++)
      s[n] = i[n] + r[n];
    return t.markAsUpdated(), this;
  }
  addToSelf(e) {
    const t = this._m, i = e.m;
    for (let s = 0; s < 16; s++)
      t[s] += i[s];
    return this.markAsUpdated(), this;
  }
  invertToRef(e) {
    if (this._isIdentity === !0)
      return x.IdentityToRef(e), this;
    const t = this._m, i = t[0], s = t[1], r = t[2], n = t[3], a = t[4], o = t[5], h = t[6], l = t[7], u = t[8], f = t[9], d = t[10], _ = t[11], E = t[12], m = t[13], T = t[14], b = t[15], R = d * b - T * _, y = f * b - m * _, P = f * T - m * d, v = u * b - E * _, A = u * T - d * E, L = u * m - E * f, Q = +(o * R - h * y + l * P), ae = -(a * R - h * v + l * A), be = +(a * y - o * v + l * L), fe = -(a * P - o * A + h * L), ue = i * Q + s * ae + r * be + n * fe;
    if (ue === 0)
      return e.copyFrom(this), this;
    const ie = 1 / ue, ye = h * b - T * l, Ce = o * b - m * l, He = o * T - m * h, ke = a * b - E * l, Ve = a * T - E * h, ot = a * m - E * o, st = h * _ - d * l, Mt = o * _ - f * l, Xt = o * d - f * h, Bi = a * _ - u * l, Ui = a * d - u * h, ki = a * f - u * o, cs = -(s * R - r * y + n * P), us = +(i * R - r * v + n * A), fs = -(i * y - s * v + n * L), ds = +(i * P - s * A + r * L), _s = +(s * ye - r * Ce + n * He), gs = -(i * ye - r * ke + n * Ve), Pt = +(i * Ce - s * ke + n * ot), Dt = -(i * He - s * Ve + r * ot), Ft = -(s * st - r * Mt + n * Xt), wt = +(i * st - r * Bi + n * Ui), wr = -(i * Mt - s * Bi + n * ki), Or = +(i * Xt - s * Ui + r * ki);
    return x.FromValuesToRef(Q * ie, cs * ie, _s * ie, Ft * ie, ae * ie, us * ie, gs * ie, wt * ie, be * ie, fs * ie, Pt * ie, wr * ie, fe * ie, ds * ie, Dt * ie, Or * ie, e), this;
  }
  addAtIndex(e, t) {
    return this._m[e] += t, this.markAsUpdated(), this;
  }
  multiplyAtIndex(e, t) {
    return this._m[e] *= t, this.markAsUpdated(), this;
  }
  setTranslationFromFloats(e, t, i) {
    return this._m[12] = e, this._m[13] = t, this._m[14] = i, this.markAsUpdated(), this;
  }
  addTranslationFromFloats(e, t, i) {
    return this._m[12] += e, this._m[13] += t, this._m[14] += i, this.markAsUpdated(), this;
  }
  setTranslation(e) {
    return this.setTranslationFromFloats(e._x, e._y, e._z);
  }
  getTranslation() {
    return new g(this._m[12], this._m[13], this._m[14]);
  }
  getTranslationToRef(e) {
    return e.x = this._m[12], e.y = this._m[13], e.z = this._m[14], this;
  }
  removeRotationAndScaling() {
    const e = this.m;
    return x.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e[12], e[13], e[14], e[15], this), this._updateIdentityStatus(e[12] === 0 && e[13] === 0 && e[14] === 0 && e[15] === 1), this;
  }
  multiply(e) {
    const t = new x();
    return this.multiplyToRef(e, t), t;
  }
  copyFrom(e) {
    e.copyToArray(this._m);
    const t = e;
    return this.updateFlag = t.updateFlag, this._updateIdentityStatus(t._isIdentity, t._isIdentityDirty, t._isIdentity3x2, t._isIdentity3x2Dirty), this;
  }
  copyToArray(e, t = 0) {
    const i = this._m;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], this;
  }
  multiplyToRef(e, t) {
    return this._isIdentity ? (t.copyFrom(e), this) : e._isIdentity ? (t.copyFrom(this), this) : (this.multiplyToArray(e, t._m, 0), t.markAsUpdated(), this);
  }
  multiplyToArray(e, t, i) {
    const s = this._m, r = e.m, n = s[0], a = s[1], o = s[2], h = s[3], l = s[4], u = s[5], f = s[6], d = s[7], _ = s[8], E = s[9], m = s[10], T = s[11], b = s[12], R = s[13], y = s[14], P = s[15], v = r[0], A = r[1], L = r[2], Q = r[3], ae = r[4], be = r[5], fe = r[6], ue = r[7], ie = r[8], ye = r[9], Ce = r[10], He = r[11], ke = r[12], Ve = r[13], ot = r[14], st = r[15];
    return t[i] = n * v + a * ae + o * ie + h * ke, t[i + 1] = n * A + a * be + o * ye + h * Ve, t[i + 2] = n * L + a * fe + o * Ce + h * ot, t[i + 3] = n * Q + a * ue + o * He + h * st, t[i + 4] = l * v + u * ae + f * ie + d * ke, t[i + 5] = l * A + u * be + f * ye + d * Ve, t[i + 6] = l * L + u * fe + f * Ce + d * ot, t[i + 7] = l * Q + u * ue + f * He + d * st, t[i + 8] = _ * v + E * ae + m * ie + T * ke, t[i + 9] = _ * A + E * be + m * ye + T * Ve, t[i + 10] = _ * L + E * fe + m * Ce + T * ot, t[i + 11] = _ * Q + E * ue + m * He + T * st, t[i + 12] = b * v + R * ae + y * ie + P * ke, t[i + 13] = b * A + R * be + y * ye + P * Ve, t[i + 14] = b * L + R * fe + y * Ce + P * ot, t[i + 15] = b * Q + R * ue + y * He + P * st, this;
  }
  equals(e) {
    const t = e;
    if (!t)
      return !1;
    if ((this._isIdentity || t._isIdentity) && !this._isIdentityDirty && !t._isIdentityDirty)
      return this._isIdentity && t._isIdentity;
    const i = this.m, s = t.m;
    return i[0] === s[0] && i[1] === s[1] && i[2] === s[2] && i[3] === s[3] && i[4] === s[4] && i[5] === s[5] && i[6] === s[6] && i[7] === s[7] && i[8] === s[8] && i[9] === s[9] && i[10] === s[10] && i[11] === s[11] && i[12] === s[12] && i[13] === s[13] && i[14] === s[14] && i[15] === s[15];
  }
  clone() {
    const e = new x();
    return e.copyFrom(this), e;
  }
  getClassName() {
    return "Matrix";
  }
  getHashCode() {
    let e = tt(this._m[0]);
    for (let t = 1; t < 16; t++)
      e = e * 397 ^ tt(this._m[t]);
    return e;
  }
  decomposeToTransformNode(e) {
    return e.rotationQuaternion = e.rotationQuaternion || new z(), this.decompose(e.scaling, e.rotationQuaternion, e.position);
  }
  decompose(e, t, i, s) {
    if (this._isIdentity)
      return i && i.setAll(0), e && e.setAll(1), t && t.copyFromFloats(0, 0, 0, 1), !0;
    const r = this._m;
    if (i && i.copyFromFloats(r[12], r[13], r[14]), e = e || X.Vector3[0], e.x = Math.sqrt(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]), e.y = Math.sqrt(r[4] * r[4] + r[5] * r[5] + r[6] * r[6]), e.z = Math.sqrt(r[8] * r[8] + r[9] * r[9] + r[10] * r[10]), s) {
      const n = s.scaling.x < 0 ? -1 : 1, a = s.scaling.y < 0 ? -1 : 1, o = s.scaling.z < 0 ? -1 : 1;
      e.x *= n, e.y *= a, e.z *= o;
    } else
      this.determinant() <= 0 && (e.y *= -1);
    if (e._x === 0 || e._y === 0 || e._z === 0)
      return t && t.copyFromFloats(0, 0, 0, 1), !1;
    if (t) {
      const n = 1 / e._x, a = 1 / e._y, o = 1 / e._z;
      x.FromValuesToRef(r[0] * n, r[1] * n, r[2] * n, 0, r[4] * a, r[5] * a, r[6] * a, 0, r[8] * o, r[9] * o, r[10] * o, 0, 0, 0, 0, 1, X.Matrix[0]), z.FromRotationMatrixToRef(X.Matrix[0], t);
    }
    return !0;
  }
  getRow(e) {
    if (e < 0 || e > 3)
      return null;
    const t = e * 4;
    return new Ee(this._m[t + 0], this._m[t + 1], this._m[t + 2], this._m[t + 3]);
  }
  getRowToRef(e, t) {
    if (e >= 0 && e < 3) {
      const i = e * 4;
      t.x = this._m[i + 0], t.y = this._m[i + 1], t.z = this._m[i + 2], t.w = this._m[i + 3];
    }
    return this;
  }
  setRow(e, t) {
    return this.setRowFromFloats(e, t.x, t.y, t.z, t.w);
  }
  transpose() {
    return x.Transpose(this);
  }
  transposeToRef(e) {
    return x.TransposeToRef(this, e), this;
  }
  setRowFromFloats(e, t, i, s, r) {
    if (e < 0 || e > 3)
      return this;
    const n = e * 4;
    return this._m[n + 0] = t, this._m[n + 1] = i, this._m[n + 2] = s, this._m[n + 3] = r, this.markAsUpdated(), this;
  }
  scale(e) {
    const t = new x();
    return this.scaleToRef(e, t), t;
  }
  scaleToRef(e, t) {
    for (let i = 0; i < 16; i++)
      t._m[i] = this._m[i] * e;
    return t.markAsUpdated(), this;
  }
  scaleAndAddToRef(e, t) {
    for (let i = 0; i < 16; i++)
      t._m[i] += this._m[i] * e;
    return t.markAsUpdated(), this;
  }
  toNormalMatrix(e) {
    const t = X.Matrix[0];
    this.invertToRef(t), t.transposeToRef(e);
    const i = e._m;
    x.FromValuesToRef(i[0], i[1], i[2], 0, i[4], i[5], i[6], 0, i[8], i[9], i[10], 0, 0, 0, 0, 1, e);
  }
  getRotationMatrix() {
    const e = new x();
    return this.getRotationMatrixToRef(e), e;
  }
  getRotationMatrixToRef(e) {
    const t = X.Vector3[0];
    if (!this.decompose(t))
      return x.IdentityToRef(e), this;
    const i = this._m, s = 1 / t._x, r = 1 / t._y, n = 1 / t._z;
    return x.FromValuesToRef(i[0] * s, i[1] * s, i[2] * s, 0, i[4] * r, i[5] * r, i[6] * r, 0, i[8] * n, i[9] * n, i[10] * n, 0, 0, 0, 0, 1, e), this;
  }
  toggleModelMatrixHandInPlace() {
    const e = this._m;
    e[2] *= -1, e[6] *= -1, e[8] *= -1, e[9] *= -1, e[14] *= -1, this.markAsUpdated();
  }
  toggleProjectionMatrixHandInPlace() {
    const e = this._m;
    e[8] *= -1, e[9] *= -1, e[10] *= -1, e[11] *= -1, this.markAsUpdated();
  }
  static FromArray(e, t = 0) {
    const i = new x();
    return x.FromArrayToRef(e, t, i), i;
  }
  static FromArrayToRef(e, t, i) {
    for (let s = 0; s < 16; s++)
      i._m[s] = e[s + t];
    i.markAsUpdated();
  }
  static FromFloat32ArrayToRefScaled(e, t, i, s) {
    for (let r = 0; r < 16; r++)
      s._m[r] = e[r + t] * i;
    s.markAsUpdated();
  }
  static get IdentityReadOnly() {
    return x._IdentityReadOnly;
  }
  static FromValuesToRef(e, t, i, s, r, n, a, o, h, l, u, f, d, _, E, m, T) {
    const b = T._m;
    b[0] = e, b[1] = t, b[2] = i, b[3] = s, b[4] = r, b[5] = n, b[6] = a, b[7] = o, b[8] = h, b[9] = l, b[10] = u, b[11] = f, b[12] = d, b[13] = _, b[14] = E, b[15] = m, T.markAsUpdated();
  }
  static FromValues(e, t, i, s, r, n, a, o, h, l, u, f, d, _, E, m) {
    const T = new x(), b = T._m;
    return b[0] = e, b[1] = t, b[2] = i, b[3] = s, b[4] = r, b[5] = n, b[6] = a, b[7] = o, b[8] = h, b[9] = l, b[10] = u, b[11] = f, b[12] = d, b[13] = _, b[14] = E, b[15] = m, T.markAsUpdated(), T;
  }
  static Compose(e, t, i) {
    const s = new x();
    return x.ComposeToRef(e, t, i, s), s;
  }
  static ComposeToRef(e, t, i, s) {
    const r = s._m, n = t._x, a = t._y, o = t._z, h = t._w, l = n + n, u = a + a, f = o + o, d = n * l, _ = n * u, E = n * f, m = a * u, T = a * f, b = o * f, R = h * l, y = h * u, P = h * f, v = e._x, A = e._y, L = e._z;
    r[0] = (1 - (m + b)) * v, r[1] = (_ + P) * v, r[2] = (E - y) * v, r[3] = 0, r[4] = (_ - P) * A, r[5] = (1 - (d + b)) * A, r[6] = (T + R) * A, r[7] = 0, r[8] = (E + y) * L, r[9] = (T - R) * L, r[10] = (1 - (d + m)) * L, r[11] = 0, r[12] = i._x, r[13] = i._y, r[14] = i._z, r[15] = 1, s.markAsUpdated();
  }
  static Identity() {
    const e = x.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return e._updateIdentityStatus(!0), e;
  }
  static IdentityToRef(e) {
    x.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, e), e._updateIdentityStatus(!0);
  }
  static Zero() {
    const e = x.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    return e._updateIdentityStatus(!1), e;
  }
  static RotationX(e) {
    const t = new x();
    return x.RotationXToRef(e, t), t;
  }
  static Invert(e) {
    const t = new x();
    return e.invertToRef(t), t;
  }
  static RotationXToRef(e, t) {
    const i = Math.sin(e), s = Math.cos(e);
    x.FromValuesToRef(1, 0, 0, 0, 0, s, i, 0, 0, -i, s, 0, 0, 0, 0, 1, t), t._updateIdentityStatus(s === 1 && i === 0);
  }
  static RotationY(e) {
    const t = new x();
    return x.RotationYToRef(e, t), t;
  }
  static RotationYToRef(e, t) {
    const i = Math.sin(e), s = Math.cos(e);
    x.FromValuesToRef(s, 0, -i, 0, 0, 1, 0, 0, i, 0, s, 0, 0, 0, 0, 1, t), t._updateIdentityStatus(s === 1 && i === 0);
  }
  static RotationZ(e) {
    const t = new x();
    return x.RotationZToRef(e, t), t;
  }
  static RotationZToRef(e, t) {
    const i = Math.sin(e), s = Math.cos(e);
    x.FromValuesToRef(s, i, 0, 0, -i, s, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, t), t._updateIdentityStatus(s === 1 && i === 0);
  }
  static RotationAxis(e, t) {
    const i = new x();
    return x.RotationAxisToRef(e, t, i), i;
  }
  static RotationAxisToRef(e, t, i) {
    const s = Math.sin(-t), r = Math.cos(-t), n = 1 - r;
    e.normalize();
    const a = i._m;
    a[0] = e._x * e._x * n + r, a[1] = e._x * e._y * n - e._z * s, a[2] = e._x * e._z * n + e._y * s, a[3] = 0, a[4] = e._y * e._x * n + e._z * s, a[5] = e._y * e._y * n + r, a[6] = e._y * e._z * n - e._x * s, a[7] = 0, a[8] = e._z * e._x * n - e._y * s, a[9] = e._z * e._y * n + e._x * s, a[10] = e._z * e._z * n + r, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, i.markAsUpdated();
  }
  static RotationAlignToRef(e, t, i) {
    const s = g.Dot(t, e), r = i._m;
    if (s < -1 + Re)
      r[0] = -1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0;
    else {
      const n = g.Cross(t, e), a = 1 / (1 + s);
      r[0] = n._x * n._x * a + s, r[1] = n._y * n._x * a - n._z, r[2] = n._z * n._x * a + n._y, r[3] = 0, r[4] = n._x * n._y * a + n._z, r[5] = n._y * n._y * a + s, r[6] = n._z * n._y * a - n._x, r[7] = 0, r[8] = n._x * n._z * a - n._y, r[9] = n._y * n._z * a + n._x, r[10] = n._z * n._z * a + s, r[11] = 0;
    }
    r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, i.markAsUpdated();
  }
  static RotationYawPitchRoll(e, t, i) {
    const s = new x();
    return x.RotationYawPitchRollToRef(e, t, i, s), s;
  }
  static RotationYawPitchRollToRef(e, t, i, s) {
    z.RotationYawPitchRollToRef(e, t, i, X.Quaternion[0]), X.Quaternion[0].toRotationMatrix(s);
  }
  static Scaling(e, t, i) {
    const s = new x();
    return x.ScalingToRef(e, t, i, s), s;
  }
  static ScalingToRef(e, t, i, s) {
    x.FromValuesToRef(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1, s), s._updateIdentityStatus(e === 1 && t === 1 && i === 1);
  }
  static Translation(e, t, i) {
    const s = new x();
    return x.TranslationToRef(e, t, i, s), s;
  }
  static TranslationToRef(e, t, i, s) {
    x.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, t, i, 1, s), s._updateIdentityStatus(e === 0 && t === 0 && i === 0);
  }
  static Lerp(e, t, i) {
    const s = new x();
    return x.LerpToRef(e, t, i, s), s;
  }
  static LerpToRef(e, t, i, s) {
    const r = s._m, n = e.m, a = t.m;
    for (let o = 0; o < 16; o++)
      r[o] = n[o] * (1 - i) + a[o] * i;
    s.markAsUpdated();
  }
  static DecomposeLerp(e, t, i) {
    const s = new x();
    return x.DecomposeLerpToRef(e, t, i, s), s;
  }
  static DecomposeLerpToRef(e, t, i, s) {
    const r = X.Vector3[0], n = X.Quaternion[0], a = X.Vector3[1];
    e.decompose(r, n, a);
    const o = X.Vector3[2], h = X.Quaternion[1], l = X.Vector3[3];
    t.decompose(o, h, l);
    const u = X.Vector3[4];
    g.LerpToRef(r, o, i, u);
    const f = X.Quaternion[2];
    z.SlerpToRef(n, h, i, f);
    const d = X.Vector3[5];
    g.LerpToRef(a, l, i, d), x.ComposeToRef(u, f, d, s);
  }
  static LookAtLH(e, t, i) {
    const s = new x();
    return x.LookAtLHToRef(e, t, i, s), s;
  }
  static LookAtLHToRef(e, t, i, s) {
    const r = X.Vector3[0], n = X.Vector3[1], a = X.Vector3[2];
    t.subtractToRef(e, a), a.normalize(), g.CrossToRef(i, a, r);
    const o = r.lengthSquared();
    o === 0 ? r.x = 1 : r.normalizeFromLength(Math.sqrt(o)), g.CrossToRef(a, r, n), n.normalize();
    const h = -g.Dot(r, e), l = -g.Dot(n, e), u = -g.Dot(a, e);
    x.FromValuesToRef(r._x, n._x, a._x, 0, r._y, n._y, a._y, 0, r._z, n._z, a._z, 0, h, l, u, 1, s);
  }
  static LookAtRH(e, t, i) {
    const s = new x();
    return x.LookAtRHToRef(e, t, i, s), s;
  }
  static LookAtRHToRef(e, t, i, s) {
    const r = X.Vector3[0], n = X.Vector3[1], a = X.Vector3[2];
    e.subtractToRef(t, a), a.normalize(), g.CrossToRef(i, a, r);
    const o = r.lengthSquared();
    o === 0 ? r.x = 1 : r.normalizeFromLength(Math.sqrt(o)), g.CrossToRef(a, r, n), n.normalize();
    const h = -g.Dot(r, e), l = -g.Dot(n, e), u = -g.Dot(a, e);
    x.FromValuesToRef(r._x, n._x, a._x, 0, r._y, n._y, a._y, 0, r._z, n._z, a._z, 0, h, l, u, 1, s);
  }
  static LookDirectionLH(e, t) {
    const i = new x();
    return x.LookDirectionLHToRef(e, t, i), i;
  }
  static LookDirectionLHToRef(e, t, i) {
    const s = X.Vector3[0];
    s.copyFrom(e), s.scaleInPlace(-1);
    const r = X.Vector3[1];
    g.CrossToRef(t, s, r), x.FromValuesToRef(r._x, r._y, r._z, 0, t._x, t._y, t._z, 0, s._x, s._y, s._z, 0, 0, 0, 0, 1, i);
  }
  static LookDirectionRH(e, t) {
    const i = new x();
    return x.LookDirectionRHToRef(e, t, i), i;
  }
  static LookDirectionRHToRef(e, t, i) {
    const s = X.Vector3[2];
    g.CrossToRef(t, e, s), x.FromValuesToRef(s._x, s._y, s._z, 0, t._x, t._y, t._z, 0, e._x, e._y, e._z, 0, 0, 0, 0, 1, i);
  }
  static OrthoLH(e, t, i, s, r) {
    const n = new x();
    return x.OrthoLHToRef(e, t, i, s, n, r), n;
  }
  static OrthoLHToRef(e, t, i, s, r, n) {
    const a = i, o = s, h = 2 / e, l = 2 / t, u = 2 / (o - a), f = -(o + a) / (o - a);
    x.FromValuesToRef(h, 0, 0, 0, 0, l, 0, 0, 0, 0, u, 0, 0, 0, f, 1, r), n && r.multiplyToRef(Ht, r), r._updateIdentityStatus(h === 1 && l === 1 && u === 1 && f === 0);
  }
  static OrthoOffCenterLH(e, t, i, s, r, n, a) {
    const o = new x();
    return x.OrthoOffCenterLHToRef(e, t, i, s, r, n, o, a), o;
  }
  static OrthoOffCenterLHToRef(e, t, i, s, r, n, a, o) {
    const h = r, l = n, u = 2 / (t - e), f = 2 / (s - i), d = 2 / (l - h), _ = -(l + h) / (l - h), E = (e + t) / (e - t), m = (s + i) / (i - s);
    x.FromValuesToRef(u, 0, 0, 0, 0, f, 0, 0, 0, 0, d, 0, E, m, _, 1, a), o && a.multiplyToRef(Ht, a), a.markAsUpdated();
  }
  static OrthoOffCenterRH(e, t, i, s, r, n, a) {
    const o = new x();
    return x.OrthoOffCenterRHToRef(e, t, i, s, r, n, o, a), o;
  }
  static OrthoOffCenterRHToRef(e, t, i, s, r, n, a, o) {
    x.OrthoOffCenterLHToRef(e, t, i, s, r, n, a, o), a._m[10] *= -1;
  }
  static PerspectiveLH(e, t, i, s, r, n = 0) {
    const a = new x(), o = i, h = s, l = 2 * o / e, u = 2 * o / t, f = (h + o) / (h - o), d = -2 * h * o / (h - o), _ = Math.tan(n);
    return x.FromValuesToRef(l, 0, 0, 0, 0, u, 0, _, 0, 0, f, 1, 0, 0, d, 0, a), r && a.multiplyToRef(Ht, a), a._updateIdentityStatus(!1), a;
  }
  static PerspectiveFovLH(e, t, i, s, r, n = 0, a = !1) {
    const o = new x();
    return x.PerspectiveFovLHToRef(e, t, i, s, o, !0, r, n, a), o;
  }
  static PerspectiveFovLHToRef(e, t, i, s, r, n = !0, a, o = 0, h = !1) {
    const l = i, u = s, f = 1 / Math.tan(e * 0.5), d = n ? f / t : f, _ = n ? f : f * t, E = h && l === 0 ? -1 : u !== 0 ? (u + l) / (u - l) : 1, m = h && l === 0 ? 2 * u : u !== 0 ? -2 * u * l / (u - l) : -2 * l, T = Math.tan(o);
    x.FromValuesToRef(d, 0, 0, 0, 0, _, 0, T, 0, 0, E, 1, 0, 0, m, 0, r), a && r.multiplyToRef(Ht, r), r._updateIdentityStatus(!1);
  }
  static PerspectiveFovReverseLHToRef(e, t, i, s, r, n = !0, a, o = 0) {
    const h = 1 / Math.tan(e * 0.5), l = n ? h / t : h, u = n ? h : h * t, f = Math.tan(o);
    x.FromValuesToRef(l, 0, 0, 0, 0, u, 0, f, 0, 0, -i, 1, 0, 0, 1, 0, r), a && r.multiplyToRef(Ht, r), r._updateIdentityStatus(!1);
  }
  static PerspectiveFovRH(e, t, i, s, r, n = 0, a = !1) {
    const o = new x();
    return x.PerspectiveFovRHToRef(e, t, i, s, o, !0, r, n, a), o;
  }
  static PerspectiveFovRHToRef(e, t, i, s, r, n = !0, a, o = 0, h = !1) {
    const l = i, u = s, f = 1 / Math.tan(e * 0.5), d = n ? f / t : f, _ = n ? f : f * t, E = h && l === 0 ? 1 : u !== 0 ? -(u + l) / (u - l) : -1, m = h && l === 0 ? 2 * u : u !== 0 ? -2 * u * l / (u - l) : -2 * l, T = Math.tan(o);
    x.FromValuesToRef(d, 0, 0, 0, 0, _, 0, T, 0, 0, E, -1, 0, 0, m, 0, r), a && r.multiplyToRef(Ht, r), r._updateIdentityStatus(!1);
  }
  static PerspectiveFovReverseRHToRef(e, t, i, s, r, n = !0, a, o = 0) {
    const h = 1 / Math.tan(e * 0.5), l = n ? h / t : h, u = n ? h : h * t, f = Math.tan(o);
    x.FromValuesToRef(l, 0, 0, 0, 0, u, 0, f, 0, 0, -i, -1, 0, 0, -1, 0, r), a && r.multiplyToRef(Ht, r), r._updateIdentityStatus(!1);
  }
  static PerspectiveFovWebVRToRef(e, t, i, s, r = !1, n, a = 0) {
    const o = r ? -1 : 1, h = Math.tan(e.upDegrees * Math.PI / 180), l = Math.tan(e.downDegrees * Math.PI / 180), u = Math.tan(e.leftDegrees * Math.PI / 180), f = Math.tan(e.rightDegrees * Math.PI / 180), d = 2 / (u + f), _ = 2 / (h + l), E = Math.tan(a), m = s._m;
    m[0] = d, m[1] = m[2] = m[3] = m[4] = 0, m[5] = _, m[6] = 0, m[7] = E, m[8] = (u - f) * d * 0.5, m[9] = -((h - l) * _ * 0.5), m[10] = -i / (t - i), m[11] = 1 * o, m[12] = m[13] = m[15] = 0, m[14] = -(2 * i * t) / (i - t), n && s.multiplyToRef(Ht, s), s.markAsUpdated();
  }
  static GetFinalMatrix(e, t, i, s, r, n) {
    const a = e.width, o = e.height, h = e.x, l = e.y, u = x.FromValues(a / 2, 0, 0, 0, 0, -o / 2, 0, 0, 0, 0, n - r, 0, h + a / 2, o / 2 + l, r, 1), f = X.Matrix[0];
    return t.multiplyToRef(i, f), f.multiplyToRef(s, f), f.multiply(u);
  }
  static GetAsMatrix2x2(e) {
    const t = e.m, i = [t[0], t[1], t[4], t[5]];
    return Ue.MatrixUse64Bits ? i : new Float32Array(i);
  }
  static GetAsMatrix3x3(e) {
    const t = e.m, i = [t[0], t[1], t[2], t[4], t[5], t[6], t[8], t[9], t[10]];
    return Ue.MatrixUse64Bits ? i : new Float32Array(i);
  }
  static Transpose(e) {
    const t = new x();
    return x.TransposeToRef(e, t), t;
  }
  static TransposeToRef(e, t) {
    const i = t._m, s = e.m;
    i[0] = s[0], i[1] = s[4], i[2] = s[8], i[3] = s[12], i[4] = s[1], i[5] = s[5], i[6] = s[9], i[7] = s[13], i[8] = s[2], i[9] = s[6], i[10] = s[10], i[11] = s[14], i[12] = s[3], i[13] = s[7], i[14] = s[11], i[15] = s[15], t.markAsUpdated(), t._updateIdentityStatus(e._isIdentity, e._isIdentityDirty);
  }
  static Reflection(e) {
    const t = new x();
    return x.ReflectionToRef(e, t), t;
  }
  static ReflectionToRef(e, t) {
    e.normalize();
    const i = e.normal.x, s = e.normal.y, r = e.normal.z, n = -2 * i, a = -2 * s, o = -2 * r;
    x.FromValuesToRef(n * i + 1, a * i, o * i, 0, n * s, a * s + 1, o * s, 0, n * r, a * r, o * r + 1, 0, n * e.d, a * e.d, o * e.d, 1, t);
  }
  static FromXYZAxesToRef(e, t, i, s) {
    x.FromValuesToRef(e._x, e._y, e._z, 0, t._x, t._y, t._z, 0, i._x, i._y, i._z, 0, 0, 0, 0, 1, s);
  }
  static FromQuaternionToRef(e, t) {
    const i = e._x * e._x, s = e._y * e._y, r = e._z * e._z, n = e._x * e._y, a = e._z * e._w, o = e._z * e._x, h = e._y * e._w, l = e._y * e._z, u = e._x * e._w;
    t._m[0] = 1 - 2 * (s + r), t._m[1] = 2 * (n + a), t._m[2] = 2 * (o - h), t._m[3] = 0, t._m[4] = 2 * (n - a), t._m[5] = 1 - 2 * (r + i), t._m[6] = 2 * (l + u), t._m[7] = 0, t._m[8] = 2 * (o + h), t._m[9] = 2 * (l - u), t._m[10] = 1 - 2 * (s + i), t._m[11] = 0, t._m[12] = 0, t._m[13] = 0, t._m[14] = 0, t._m[15] = 1, t.markAsUpdated();
  }
}
x._UpdateFlagSeed = 0;
x._IdentityReadOnly = x.Identity();
class X {
}
X.Vector3 = Me.BuildTuple(11, g.Zero);
X.Matrix = Me.BuildTuple(2, x.Identity);
X.Quaternion = Me.BuildTuple(3, z.Zero);
class D {
}
D.Vector2 = Me.BuildTuple(3, ee.Zero);
D.Vector3 = Me.BuildTuple(13, g.Zero);
D.Vector4 = Me.BuildTuple(3, Ee.Zero);
D.Quaternion = Me.BuildTuple(2, z.Zero);
D.Matrix = Me.BuildTuple(8, x.Identity);
it("BABYLON.Vector2", ee);
it("BABYLON.Vector3", g);
it("BABYLON.Vector4", Ee);
it("BABYLON.Matrix", x);
const Ht = x.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);
class Br {
  constructor(e, t = !1, i, s) {
    this.initialize(e, t, i, s);
  }
  initialize(e, t = !1, i, s) {
    return this.mask = e, this.skipNextObservers = t, this.target = i, this.currentTarget = s, this;
  }
}
class Ur {
  constructor(e, t, i = null) {
    this.callback = e, this.mask = t, this.scope = i, this._willBeUnregistered = !1, this.unregisterOnNextCall = !1;
  }
}
class F {
  constructor(e) {
    this._observers = new Array(), this._eventState = new Br(0), e && (this._onObserverAdded = e);
  }
  static FromPromise(e, t) {
    const i = new F();
    return e.then((s) => {
      i.notifyObservers(s);
    }).catch((s) => {
      if (t)
        t.notifyObservers(s);
      else
        throw s;
    }), i;
  }
  get observers() {
    return this._observers;
  }
  add(e, t = -1, i = !1, s = null, r = !1) {
    if (!e)
      return null;
    const n = new Ur(e, t, s);
    return n.unregisterOnNextCall = r, i ? this._observers.unshift(n) : this._observers.push(n), this._onObserverAdded && this._onObserverAdded(n), n;
  }
  addOnce(e) {
    return this.add(e, void 0, void 0, void 0, !0);
  }
  remove(e) {
    return e && this._observers.indexOf(e) !== -1 ? (this._deferUnregister(e), !0) : !1;
  }
  removeCallback(e, t) {
    for (let i = 0; i < this._observers.length; i++) {
      const s = this._observers[i];
      if (!s._willBeUnregistered && s.callback === e && (!t || t === s.scope))
        return this._deferUnregister(s), !0;
    }
    return !1;
  }
  _deferUnregister(e) {
    e.unregisterOnNextCall = !1, e._willBeUnregistered = !0, setTimeout(() => {
      this._remove(e);
    }, 0);
  }
  _remove(e) {
    if (!e)
      return !1;
    const t = this._observers.indexOf(e);
    return t !== -1 ? (this._observers.splice(t, 1), !0) : !1;
  }
  makeObserverTopPriority(e) {
    this._remove(e), this._observers.unshift(e);
  }
  makeObserverBottomPriority(e) {
    this._remove(e), this._observers.push(e);
  }
  notifyObservers(e, t = -1, i, s, r) {
    if (!this._observers.length)
      return !0;
    const n = this._eventState;
    n.mask = t, n.target = i, n.currentTarget = s, n.skipNextObservers = !1, n.lastReturnValue = e, n.userInfo = r;
    for (const a of this._observers)
      if (!a._willBeUnregistered && (a.mask & t && (a.scope ? n.lastReturnValue = a.callback.apply(a.scope, [e, n]) : n.lastReturnValue = a.callback(e, n), a.unregisterOnNextCall && this._deferUnregister(a)), n.skipNextObservers))
        return !1;
    return !0;
  }
  notifyObserver(e, t, i = -1) {
    if (e._willBeUnregistered)
      return;
    const s = this._eventState;
    s.mask = i, s.skipNextObservers = !1, e.callback(t, s), e.unregisterOnNextCall && this._deferUnregister(e);
  }
  hasObservers() {
    return this._observers.length > 0;
  }
  clear() {
    this._observers = new Array(), this._onObserverAdded = null;
  }
  clone() {
    const e = new F();
    return e._observers = this._observers.slice(0), e;
  }
  hasSpecificMask(e = -1) {
    for (const t of this._observers)
      if (t.mask & e || t.mask === e)
        return !0;
    return !1;
  }
}
class kr {
  constructor() {
    this.samplingMode = -1, this._useMipMaps = !0, this._cachedWrapU = null, this._cachedWrapV = null, this._cachedWrapR = null, this._cachedAnisotropicFilteringLevel = null, this._comparisonFunction = 0;
  }
  get wrapU() {
    return this._cachedWrapU;
  }
  set wrapU(e) {
    this._cachedWrapU = e;
  }
  get wrapV() {
    return this._cachedWrapV;
  }
  set wrapV(e) {
    this._cachedWrapV = e;
  }
  get wrapR() {
    return this._cachedWrapR;
  }
  set wrapR(e) {
    this._cachedWrapR = e;
  }
  get anisotropicFilteringLevel() {
    return this._cachedAnisotropicFilteringLevel;
  }
  set anisotropicFilteringLevel(e) {
    this._cachedAnisotropicFilteringLevel = e;
  }
  get comparisonFunction() {
    return this._comparisonFunction;
  }
  set comparisonFunction(e) {
    this._comparisonFunction = e;
  }
  get useMipMaps() {
    return this._useMipMaps;
  }
  set useMipMaps(e) {
    this._useMipMaps = e;
  }
  setParameters(e = 1, t = 1, i = 1, s = 1, r = 2, n = 0) {
    return this._cachedWrapU = e, this._cachedWrapV = t, this._cachedWrapR = i, this._cachedAnisotropicFilteringLevel = s, this.samplingMode = r, this._comparisonFunction = n, this;
  }
  compareSampler(e) {
    return this._cachedWrapU === e._cachedWrapU && this._cachedWrapV === e._cachedWrapV && this._cachedWrapR === e._cachedWrapR && this._cachedAnisotropicFilteringLevel === e._cachedAnisotropicFilteringLevel && this.samplingMode === e.samplingMode && this._comparisonFunction === e._comparisonFunction && this._useMipMaps === e._useMipMaps;
  }
}
var Le;
(function(c) {
  c[c.Unknown = 0] = "Unknown", c[c.Url = 1] = "Url", c[c.Temp = 2] = "Temp", c[c.Raw = 3] = "Raw", c[c.Dynamic = 4] = "Dynamic", c[c.RenderTarget = 5] = "RenderTarget", c[c.MultiRenderTarget = 6] = "MultiRenderTarget", c[c.Cube = 7] = "Cube", c[c.CubeRaw = 8] = "CubeRaw", c[c.CubePrefiltered = 9] = "CubePrefiltered", c[c.Raw3D = 10] = "Raw3D", c[c.Raw2DArray = 11] = "Raw2DArray", c[c.DepthStencil = 12] = "DepthStencil", c[c.CubeRawRGBD = 13] = "CubeRawRGBD", c[c.Depth = 14] = "Depth";
})(Le || (Le = {}));
class kt extends kr {
  constructor(e, t, i = !1) {
    super(), this.isReady = !1, this.isCube = !1, this.is3D = !1, this.is2DArray = !1, this.isMultiview = !1, this.url = "", this.generateMipMaps = !1, this.samples = 0, this.type = -1, this.format = -1, this.onLoadedObservable = new F(), this.onErrorObservable = new F(), this.onRebuildCallback = null, this.width = 0, this.height = 0, this.depth = 0, this.baseWidth = 0, this.baseHeight = 0, this.baseDepth = 0, this.invertY = !1, this._invertVScale = !1, this._associatedChannel = -1, this._source = Le.Unknown, this._buffer = null, this._bufferView = null, this._bufferViewArray = null, this._bufferViewArrayArray = null, this._size = 0, this._extension = "", this._files = null, this._workingCanvas = null, this._workingContext = null, this._cachedCoordinatesMode = null, this._isDisabled = !1, this._compression = null, this._sphericalPolynomial = null, this._sphericalPolynomialPromise = null, this._sphericalPolynomialComputed = !1, this._lodGenerationScale = 0, this._lodGenerationOffset = 0, this._useSRGBBuffer = !1, this._lodTextureHigh = null, this._lodTextureMid = null, this._lodTextureLow = null, this._isRGBD = !1, this._linearSpecularLOD = !1, this._irradianceTexture = null, this._hardwareTexture = null, this._maxLodLevel = null, this._references = 1, this._gammaSpace = null, this._engine = e, this._source = t, this._uniqueId = kt._Counter++, i || (this._hardwareTexture = e._createHardwareTexture());
  }
  get useMipMaps() {
    return this.generateMipMaps;
  }
  set useMipMaps(e) {
    this.generateMipMaps = e;
  }
  get uniqueId() {
    return this._uniqueId;
  }
  getEngine() {
    return this._engine;
  }
  get source() {
    return this._source;
  }
  incrementReferences() {
    this._references++;
  }
  updateSize(e, t, i = 1) {
    this._engine.updateTextureDimensions(this, e, t, i), this.width = e, this.height = t, this.depth = i, this.baseWidth = e, this.baseHeight = t, this.baseDepth = i, this._size = e * t * i;
  }
  _rebuild() {
    var t;
    if (this.isReady = !1, this._cachedCoordinatesMode = null, this._cachedWrapU = null, this._cachedWrapV = null, this._cachedWrapR = null, this._cachedAnisotropicFilteringLevel = null, this.onRebuildCallback) {
      const i = this.onRebuildCallback(this), s = (r) => {
        r._swapAndDie(this, !1), this.isReady = i.isReady;
      };
      i.isAsync ? i.proxy.then(s) : s(i.proxy);
      return;
    }
    let e;
    switch (this.source) {
      case Le.Temp:
        break;
      case Le.Url:
        e = this._engine.createTexture((t = this._originalUrl) != null ? t : this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, () => {
          e._swapAndDie(this, !1), this.isReady = !0;
        }, null, this._buffer, void 0, this.format, this._extension, void 0, void 0, void 0, this._useSRGBBuffer);
        return;
      case Le.Raw:
        e = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type, void 0, this._useSRGBBuffer), e._swapAndDie(this, !1), this.isReady = !0;
        break;
      case Le.Raw3D:
        e = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type), e._swapAndDie(this, !1), this.isReady = !0;
        break;
      case Le.Raw2DArray:
        e = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type), e._swapAndDie(this, !1), this.isReady = !0;
        break;
      case Le.Dynamic:
        e = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode), e._swapAndDie(this, !1), this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas(), this.invertY, void 0, void 0, !0);
        break;
      case Le.Cube:
        e = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, () => {
          e._swapAndDie(this, !1), this.isReady = !0;
        }, null, this.format, this._extension, !1, 0, 0, null, void 0, this._useSRGBBuffer);
        return;
      case Le.CubeRaw:
        e = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression), e._swapAndDie(this, !1), this.isReady = !0;
        break;
      case Le.CubeRawRGBD:
        return;
      case Le.CubePrefiltered:
        e = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, (i) => {
          i && i._swapAndDie(this, !1), this.isReady = !0;
        }, null, this.format, this._extension), e._sphericalPolynomial = this._sphericalPolynomial;
        return;
    }
  }
  _swapAndDie(e, t = !0) {
    var r;
    (r = this._hardwareTexture) == null || r.setUsage(e._source, this.generateMipMaps, this.isCube, this.width, this.height), e._hardwareTexture = this._hardwareTexture, t && (e._isRGBD = this._isRGBD), this._lodTextureHigh && (e._lodTextureHigh && e._lodTextureHigh.dispose(), e._lodTextureHigh = this._lodTextureHigh), this._lodTextureMid && (e._lodTextureMid && e._lodTextureMid.dispose(), e._lodTextureMid = this._lodTextureMid), this._lodTextureLow && (e._lodTextureLow && e._lodTextureLow.dispose(), e._lodTextureLow = this._lodTextureLow), this._irradianceTexture && (e._irradianceTexture && e._irradianceTexture.dispose(), e._irradianceTexture = this._irradianceTexture);
    const i = this._engine.getLoadedTexturesCache();
    let s = i.indexOf(this);
    s !== -1 && i.splice(s, 1), s = i.indexOf(e), s === -1 && i.push(e);
  }
  dispose() {
    this._references--, this.onLoadedObservable.clear(), this.onErrorObservable.clear(), this._references === 0 && (this._engine._releaseTexture(this), this._hardwareTexture = null);
  }
}
kt._Counter = 0;
function Ne() {
  return typeof window < "u";
}
function gr() {
  return typeof navigator < "u";
}
function Hi() {
  return typeof document < "u";
}
function Fs(c) {
  let e = "", t = c.firstChild;
  for (; t; )
    t.nodeType === 3 && (e += t.textContent), t = t.nextSibling;
  return e;
}
const ys = {
  IsWindowObjectExist: Ne,
  IsNavigatorAvailable: gr,
  IsDocumentAvailable: Hi,
  GetDOMTextContent: Fs
};
function q(c) {
  return `${c} needs to be imported before as it contains a side-effect required by your code.`;
}
class w {
  static _CheckLimit(e, t) {
    let i = w._LogLimitOutputs[e];
    return i ? i.current++ : (i = { limit: t, current: 1 }, w._LogLimitOutputs[e] = i), i.current <= i.limit;
  }
  static _GenerateLimitMessage(e, t = 1) {
    var r;
    const i = w._LogLimitOutputs[e];
    if (!i || !w.MessageLimitReached)
      return;
    const s = this._Levels[t];
    i.current === i.limit && w[s.name](w.MessageLimitReached.replace(/%LIMIT%/g, "" + i.limit).replace(/%TYPE%/g, (r = s.name) != null ? r : ""));
  }
  static _AddLogEntry(e) {
    w._LogCache = e + w._LogCache, w.OnNewCacheEntry && w.OnNewCacheEntry(e);
  }
  static _FormatMessage(e) {
    const t = (s) => s < 10 ? "0" + s : "" + s, i = new Date();
    return "[" + t(i.getHours()) + ":" + t(i.getMinutes()) + ":" + t(i.getSeconds()) + "]: " + e;
  }
  static _LogDisabled(e, t) {
  }
  static _LogEnabled(e = 1, t, i) {
    if (i !== void 0 && !w._CheckLimit(t, i))
      return;
    const s = w._FormatMessage(t), r = this._Levels[e];
    r.logFunc && r.logFunc("BJS - " + s);
    const n = `<div style='color:${r.color}'>${s}</div><br>`;
    w._AddLogEntry(n), w._GenerateLimitMessage(t, e);
  }
  static get LogCache() {
    return w._LogCache;
  }
  static ClearLogCache() {
    w._LogCache = "", w._LogLimitOutputs = {}, w.errorsCount = 0;
  }
  static set LogLevels(e) {
    w.Log = w._LogDisabled, w.Warn = w._LogDisabled, w.Error = w._LogDisabled, [w.MessageLogLevel, w.WarningLogLevel, w.ErrorLogLevel].forEach((t) => {
      if ((e & t) === t) {
        const i = this._Levels[t];
        w[i.name] = w._LogEnabled.bind(w, t);
      }
    });
  }
}
w.NoneLogLevel = 0;
w.MessageLogLevel = 1;
w.WarningLogLevel = 2;
w.ErrorLogLevel = 4;
w.AllLogLevel = 7;
w.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.";
w._LogCache = "";
w._LogLimitOutputs = {};
w._Levels = [
  {},
  { color: "white", logFunc: console.log, name: "Log" },
  { color: "orange", logFunc: console.warn, name: "Warn" },
  {},
  { color: "red", logFunc: console.error, name: "Error" }
];
w.errorsCount = 0;
w.Log = w._LogEnabled.bind(w, w.MessageLogLevel);
w.Warn = w._LogEnabled.bind(w, w.WarningLogLevel);
w.Error = w._LogEnabled.bind(w, w.ErrorLogLevel);
class Mi {
  constructor() {
    this.children = [];
  }
  isValid(e) {
    return !0;
  }
  process(e, t) {
    let i = "";
    if (this.line) {
      let s = this.line;
      const r = t.processor;
      r && (r.lineProcessor && (s = r.lineProcessor(s, t.isFragment, t.processingContext)), r.attributeProcessor && this.line.startsWith("attribute") ? s = r.attributeProcessor(this.line, e, t.processingContext) : r.varyingProcessor && this.line.startsWith("varying") ? s = r.varyingProcessor(this.line, t.isFragment, e, t.processingContext) : r.uniformProcessor && r.uniformRegexp && r.uniformRegexp.test(this.line) ? t.lookForClosingBracketForUniformBuffer || (s = r.uniformProcessor(this.line, t.isFragment, e, t.processingContext)) : r.uniformBufferProcessor && r.uniformBufferRegexp && r.uniformBufferRegexp.test(this.line) ? t.lookForClosingBracketForUniformBuffer || (s = r.uniformBufferProcessor(this.line, t.isFragment, t.processingContext), t.lookForClosingBracketForUniformBuffer = !0) : r.textureProcessor && r.textureRegexp && r.textureRegexp.test(this.line) ? s = r.textureProcessor(this.line, t.isFragment, e, t.processingContext) : (r.uniformProcessor || r.uniformBufferProcessor) && this.line.startsWith("uniform") && !t.lookForClosingBracketForUniformBuffer && (/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line) ? r.uniformProcessor && (s = r.uniformProcessor(this.line, t.isFragment, e, t.processingContext)) : r.uniformBufferProcessor && (s = r.uniformBufferProcessor(this.line, t.isFragment, t.processingContext), t.lookForClosingBracketForUniformBuffer = !0)), t.lookForClosingBracketForUniformBuffer && this.line.indexOf("}") !== -1 && (t.lookForClosingBracketForUniformBuffer = !1, r.endOfUniformBufferProcessor && (s = r.endOfUniformBufferProcessor(this.line, t.isFragment, t.processingContext)))), i += s + `\r
`;
    }
    return this.children.forEach((s) => {
      i += s.process(e, t);
    }), this.additionalDefineKey && (e[this.additionalDefineKey] = this.additionalDefineValue || "true"), i;
  }
}
class Vr {
  constructor() {
    this._lines = [];
  }
  get currentLine() {
    return this._lines[this.lineIndex];
  }
  get canRead() {
    return this.lineIndex < this._lines.length - 1;
  }
  set lines(e) {
    this._lines.length = 0;
    for (const t of e) {
      if (t[0] === "#") {
        this._lines.push(t);
        continue;
      }
      if (t.trim().startsWith("//")) {
        this._lines.push(t);
        continue;
      }
      const i = t.split(";");
      for (let s = 0; s < i.length; s++) {
        let r = i[s];
        r = r.trim(), r && this._lines.push(r + (s !== i.length - 1 ? ";" : ""));
      }
    }
  }
}
class ms extends Mi {
  process(e, t) {
    for (let i = 0; i < this.children.length; i++) {
      const s = this.children[i];
      if (s.isValid(e))
        return s.process(e, t);
    }
    return "";
  }
}
class Wr extends Mi {
  isValid(e) {
    return this.testExpression.isTrue(e);
  }
}
class $e {
  isTrue(e) {
    return !0;
  }
  static postfixToInfix(e) {
    const t = [];
    for (const i of e)
      if ($e._OperatorPriority[i] === void 0)
        t.push(i);
      else {
        const s = t[t.length - 1], r = t[t.length - 2];
        t.length -= 2, t.push(`(${r}${i}${s})`);
      }
    return t[t.length - 1];
  }
  static infixToPostfix(e) {
    const t = [];
    let i = -1;
    const s = () => {
      h = h.trim(), h !== "" && (t.push(h), h = "");
    }, r = (l) => {
      i < $e._Stack.length - 1 && ($e._Stack[++i] = l);
    }, n = () => $e._Stack[i], a = () => i === -1 ? "!!INVALID EXPRESSION!!" : $e._Stack[i--];
    let o = 0, h = "";
    for (; o < e.length; ) {
      const l = e.charAt(o), u = o < e.length - 1 ? e.substr(o, 2) : "";
      if (l === "(")
        h = "", r(l);
      else if (l === ")") {
        for (s(); i !== -1 && n() !== "("; )
          t.push(a());
        a();
      } else if ($e._OperatorPriority[u] > 1) {
        for (s(); i !== -1 && $e._OperatorPriority[n()] >= $e._OperatorPriority[u]; )
          t.push(a());
        r(u), o++;
      } else
        h += l;
      o++;
    }
    for (s(); i !== -1; )
      n() === "(" ? a() : t.push(a());
    return t;
  }
}
$e._OperatorPriority = {
  ")": 0,
  "(": 1,
  "||": 2,
  "&&": 3
};
$e._Stack = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
class Vi extends $e {
  constructor(e, t = !1) {
    super(), this.define = e, this.not = t;
  }
  isTrue(e) {
    let t = e[this.define] !== void 0;
    return this.not && (t = !t), t;
  }
}
class zr extends $e {
  isTrue(e) {
    return this.leftOperand.isTrue(e) || this.rightOperand.isTrue(e);
  }
}
class Gr extends $e {
  isTrue(e) {
    return this.leftOperand.isTrue(e) && this.rightOperand.isTrue(e);
  }
}
class Xr extends $e {
  constructor(e, t, i) {
    super(), this.define = e, this.operand = t, this.testValue = i;
  }
  isTrue(e) {
    let t = e[this.define];
    t === void 0 && (t = this.define);
    let i = !1;
    const s = parseInt(t), r = parseInt(this.testValue);
    switch (this.operand) {
      case ">":
        i = s > r;
        break;
      case "<":
        i = s < r;
        break;
      case "<=":
        i = s <= r;
        break;
      case ">=":
        i = s >= r;
        break;
      case "==":
        i = s === r;
        break;
    }
    return i;
  }
}
var Ze;
(function(c) {
  c[c.GLSL = 0] = "GLSL", c[c.WGSL = 1] = "WGSL";
})(Ze || (Ze = {}));
const Hr = /defined\s*?\((.+?)\)/g, Es = /defined\s*?\[(.+?)\]/g, Hs = /#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g;
class ii {
  static Initialize(e) {
    e.processor && e.processor.initializeShaders && e.processor.initializeShaders(e.processingContext);
  }
  static Process(e, t, i, s) {
    var r;
    (r = t.processor) != null && r.preProcessShaderCode && (e = t.processor.preProcessShaderCode(e, t.isFragment)), this._ProcessIncludes(e, t, (n) => {
      t.processCodeAfterIncludes && (n = t.processCodeAfterIncludes(t.isFragment ? "fragment" : "vertex", n));
      const a = this._ProcessShaderConversion(n, t, s);
      i(a);
    });
  }
  static PreProcess(e, t, i, s) {
    var r;
    (r = t.processor) != null && r.preProcessShaderCode && (e = t.processor.preProcessShaderCode(e, t.isFragment)), this._ProcessIncludes(e, t, (n) => {
      t.processCodeAfterIncludes && (n = t.processCodeAfterIncludes(t.isFragment ? "fragment" : "vertex", n));
      const a = this._ApplyPreProcessing(n, t, s);
      i(a);
    });
  }
  static Finalize(e, t, i) {
    return !i.processor || !i.processor.finalizeShaders ? { vertexCode: e, fragmentCode: t } : i.processor.finalizeShaders(e, t, i.processingContext);
  }
  static _ProcessPrecision(e, t) {
    var s;
    if ((s = t.processor) != null && s.noPrecision)
      return e;
    const i = t.shouldUseHighPrecisionShader;
    return e.indexOf("precision highp float") === -1 ? i ? e = `precision highp float;
` + e : e = `precision mediump float;
` + e : i || (e = e.replace("precision highp float", "precision mediump float")), e;
  }
  static _ExtractOperation(e) {
    const i = /defined\((.+)\)/.exec(e);
    if (i && i.length)
      return new Vi(i[1].trim(), e[0] === "!");
    const s = ["==", ">=", "<=", "<", ">"];
    let r = "", n = 0;
    for (r of s)
      if (n = e.indexOf(r), n > -1)
        break;
    if (n === -1)
      return new Vi(e);
    const a = e.substring(0, n).trim(), o = e.substring(n + r.length).trim();
    return new Xr(a, r, o);
  }
  static _BuildSubExpression(e) {
    e = e.replace(Hr, "defined[$1]");
    const t = $e.infixToPostfix(e), i = [];
    for (const r of t)
      if (r !== "||" && r !== "&&")
        i.push(r);
      else if (i.length >= 2) {
        let n = i[i.length - 1], a = i[i.length - 2];
        i.length -= 2;
        const o = r == "&&" ? new Gr() : new zr();
        typeof n == "string" && (n = n.replace(Es, "defined($1)")), typeof a == "string" && (a = a.replace(Es, "defined($1)")), o.leftOperand = typeof a == "string" ? this._ExtractOperation(a) : a, o.rightOperand = typeof n == "string" ? this._ExtractOperation(n) : n, i.push(o);
      }
    let s = i[i.length - 1];
    return typeof s == "string" && (s = s.replace(Es, "defined($1)")), typeof s == "string" ? this._ExtractOperation(s) : s;
  }
  static _BuildExpression(e, t) {
    const i = new Wr(), s = e.substring(0, t);
    let r = e.substring(t);
    return r = r.substring(0, (r.indexOf("//") + 1 || r.length + 1) - 1).trim(), s === "#ifdef" ? i.testExpression = new Vi(r) : s === "#ifndef" ? i.testExpression = new Vi(r, !0) : i.testExpression = this._BuildSubExpression(r), i;
  }
  static _MoveCursorWithinIf(e, t, i) {
    let s = e.currentLine;
    for (; this._MoveCursor(e, i); ) {
      s = e.currentLine;
      const r = s.substring(0, 5).toLowerCase();
      if (r === "#else") {
        const n = new Mi();
        t.children.push(n), this._MoveCursor(e, n);
        return;
      } else if (r === "#elif") {
        const n = this._BuildExpression(s, 5);
        t.children.push(n), i = n;
      }
    }
  }
  static _MoveCursor(e, t) {
    for (; e.canRead; ) {
      e.lineIndex++;
      const i = e.currentLine, r = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/.exec(i);
      if (r && r.length)
        switch (r[0]) {
          case "#ifdef": {
            const a = new ms();
            t.children.push(a);
            const o = this._BuildExpression(i, 6);
            a.children.push(o), this._MoveCursorWithinIf(e, a, o);
            break;
          }
          case "#else":
          case "#elif":
            return !0;
          case "#endif":
            return !1;
          case "#ifndef": {
            const a = new ms();
            t.children.push(a);
            const o = this._BuildExpression(i, 7);
            a.children.push(o), this._MoveCursorWithinIf(e, a, o);
            break;
          }
          case "#if": {
            const a = new ms(), o = this._BuildExpression(i, 3);
            t.children.push(a), a.children.push(o), this._MoveCursorWithinIf(e, a, o);
            break;
          }
        }
      else {
        const n = new Mi();
        if (n.line = i, t.children.push(n), i[0] === "#" && i[1] === "d") {
          const a = i.replace(";", "").split(" ");
          n.additionalDefineKey = a[1], a.length === 3 && (n.additionalDefineValue = a[2]);
        }
      }
    }
    return !1;
  }
  static _EvaluatePreProcessors(e, t, i) {
    const s = new Mi(), r = new Vr();
    return r.lineIndex = -1, r.lines = e.split(`
`), this._MoveCursor(r, s), s.process(t, i);
  }
  static _PreparePreProcessors(e, t) {
    var r;
    const i = e.defines, s = {};
    for (const n of i) {
      const o = n.replace("#define", "").replace(";", "").trim().split(" ");
      s[o[0]] = o.length > 1 ? o[1] : "";
    }
    return ((r = e.processor) == null ? void 0 : r.shaderLanguage) === Ze.GLSL && (s.GL_ES = "true"), s.__VERSION__ = e.version, s[e.platformName] = "true", t._getGlobalDefines(s), s;
  }
  static _ProcessShaderConversion(e, t, i) {
    let s = this._ProcessPrecision(e, t);
    if (!t.processor)
      return s;
    if (t.processor.shaderLanguage === Ze.GLSL && s.indexOf("#version 3") !== -1)
      return s.replace("#version 300 es", "");
    const r = t.defines, n = this._PreparePreProcessors(t, i);
    return t.processor.preProcessor && (s = t.processor.preProcessor(s, r, t.isFragment, t.processingContext)), s = this._EvaluatePreProcessors(s, n, t), t.processor.postProcessor && (s = t.processor.postProcessor(s, r, t.isFragment, t.processingContext, i)), i._features.needShaderCodeInlining && (s = i.inlineShaderCode(s)), s;
  }
  static _ApplyPreProcessing(e, t, i) {
    var a, o;
    let s = e;
    const r = t.defines, n = this._PreparePreProcessors(t, i);
    return (a = t.processor) != null && a.preProcessor && (s = t.processor.preProcessor(s, r, t.isFragment, t.processingContext)), s = this._EvaluatePreProcessors(s, n, t), (o = t.processor) != null && o.postProcessor && (s = t.processor.postProcessor(s, r, t.isFragment, t.processingContext, i)), i._features.needShaderCodeInlining && (s = i.inlineShaderCode(s)), s;
  }
  static _ProcessIncludes(e, t, i) {
    let s = Hs.exec(e), r = new String(e), n = !1;
    for (; s != null; ) {
      let a = s[1];
      if (a.indexOf("__decl__") !== -1 && (a = a.replace(/__decl__/, ""), t.supportsUniformBuffers && (a = a.replace(/Vertex/, "Ubo"), a = a.replace(/Fragment/, "Ubo")), a = a + "Declaration"), t.includesShadersStore[a]) {
        let o = t.includesShadersStore[a];
        if (s[2]) {
          const h = s[3].split(",");
          for (let l = 0; l < h.length; l += 2) {
            const u = new RegExp(h[l], "g"), f = h[l + 1];
            o = o.replace(u, f);
          }
        }
        if (s[4]) {
          const h = s[5];
          if (h.indexOf("..") !== -1) {
            const l = h.split(".."), u = parseInt(l[0]);
            let f = parseInt(l[1]), d = o.slice(0);
            o = "", isNaN(f) && (f = t.indexParameters[l[1]]);
            for (let _ = u; _ < f; _++)
              t.supportsUniformBuffers || (d = d.replace(/light\{X\}.(\w*)/g, (E, m) => m + "{X}")), o += d.replace(/\{X\}/g, _.toString()) + `
`;
          } else
            t.supportsUniformBuffers || (o = o.replace(/light\{X\}.(\w*)/g, (l, u) => u + "{X}")), o = o.replace(/\{X\}/g, h);
        }
        r = r.replace(s[0], o), n = n || o.indexOf("#include<") >= 0 || o.indexOf("#include <") >= 0;
      } else {
        const o = t.shadersRepository + "ShadersInclude/" + a + ".fx";
        ii._FileToolsLoadFile(o, (h) => {
          t.includesShadersStore[a] = h, this._ProcessIncludes(r, t, i);
        });
        return;
      }
      s = Hs.exec(e);
    }
    n ? this._ProcessIncludes(r.toString(), t, i) : i(r);
  }
  static _FileToolsLoadFile(e, t, i, s, r, n) {
    throw q("FileTools");
  }
}
class N {
  static GetShadersRepository(e = Ze.GLSL) {
    return e === Ze.GLSL ? N.ShadersRepository : N.ShadersRepositoryWGSL;
  }
  static GetShadersStore(e = Ze.GLSL) {
    return e === Ze.GLSL ? N.ShadersStore : N.ShadersStoreWGSL;
  }
  static GetIncludesShadersStore(e = Ze.GLSL) {
    return e === Ze.GLSL ? N.IncludesShadersStore : N.IncludesShadersStoreWGSL;
  }
}
N.ShadersRepository = "src/Shaders/";
N.ShadersStore = {};
N.IncludesShadersStore = {};
N.ShadersRepositoryWGSL = "src/ShadersWGSL/";
N.ShadersStoreWGSL = {};
N.IncludesShadersStoreWGSL = {};
class De {
  constructor(e, t, i, s = null, r, n = null, a = null, o = null, h = null, l, u = "", f = Ze.GLSL) {
    var P, v, A;
    this.name = null, this.defines = "", this.onCompiled = null, this.onError = null, this.onBind = null, this.uniqueId = 0, this.onCompileObservable = new F(), this.onErrorObservable = new F(), this._onBindObservable = null, this._wasPreviouslyReady = !1, this._wasPreviouslyUsingInstances = null, this._isDisposed = !1, this._bonesComputationForcedToCPU = !1, this._uniformBuffersNames = {}, this._multiTarget = !1, this._samplers = {}, this._isReady = !1, this._compilationError = "", this._allFallbacksProcessed = !1, this._uniforms = {}, this._key = "", this._fallbacks = null, this._vertexSourceCodeOverride = "", this._fragmentSourceCodeOverride = "", this._transformFeedbackVaryings = null, this._pipelineContext = null, this._vertexSourceCode = "", this._fragmentSourceCode = "", this._rawVertexSourceCode = "", this._rawFragmentSourceCode = "", this.name = e, this._key = u;
    let d, _ = null;
    if (t.attributes) {
      const L = t;
      if (this._engine = i, this._attributesNames = L.attributes, this._uniformsNames = L.uniformsNames.concat(L.samplers), this._samplerList = L.samplers.slice(), this.defines = L.defines, this.onError = L.onError, this.onCompiled = L.onCompiled, this._fallbacks = L.fallbacks, this._indexParameters = L.indexParameters, this._transformFeedbackVaryings = L.transformFeedbackVaryings || null, this._multiTarget = !!L.multiTarget, this._shaderLanguage = (P = L.shaderLanguage) != null ? P : Ze.GLSL, L.uniformBuffersNames) {
        this._uniformBuffersNamesList = L.uniformBuffersNames.slice();
        for (let Q = 0; Q < L.uniformBuffersNames.length; Q++)
          this._uniformBuffersNames[L.uniformBuffersNames[Q]] = Q;
      }
      _ = (v = L.processFinalCode) != null ? v : null, d = (A = L.processCodeAfterIncludes) != null ? A : void 0;
    } else
      this._engine = r, this.defines = n == null ? "" : n, this._uniformsNames = i.concat(s), this._samplerList = s ? s.slice() : [], this._attributesNames = t, this._uniformBuffersNamesList = [], this._shaderLanguage = f, this.onError = h, this.onCompiled = o, this._indexParameters = l, this._fallbacks = a;
    this._attributeLocationByName = {}, this.uniqueId = De._UniqueIdSeed++;
    let E, m;
    const T = Ne() ? this._engine.getHostDocument() : null;
    e.vertexSource ? E = "source:" + e.vertexSource : e.vertexElement ? (E = T ? T.getElementById(e.vertexElement) : null, E || (E = e.vertexElement)) : E = e.vertex || e, e.fragmentSource ? m = "source:" + e.fragmentSource : e.fragmentElement ? (m = T ? T.getElementById(e.fragmentElement) : null, m || (m = e.fragmentElement)) : m = e.fragment || e, this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);
    const b = {
      defines: this.defines.split(`
`),
      indexParameters: this._indexParameters,
      isFragment: !1,
      shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
      processor: this._engine._getShaderProcessor(this._shaderLanguage),
      supportsUniformBuffers: this._engine.supportsUniformBuffers,
      shadersRepository: N.GetShadersRepository(this._shaderLanguage),
      includesShadersStore: N.GetIncludesShadersStore(this._shaderLanguage),
      version: (this._engine.version * 100).toString(),
      platformName: this._engine.shaderPlatformName,
      processingContext: this._processingContext,
      isNDCHalfZRange: this._engine.isNDCHalfZRange,
      useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
      processCodeAfterIncludes: d
    }, R = [void 0, void 0], y = () => {
      if (R[0] && R[1]) {
        b.isFragment = !0;
        const [L, Q] = R;
        ii.Process(Q, b, (ae) => {
          _ && (ae = _("fragment", ae));
          const be = ii.Finalize(L, ae, b);
          this._useFinalCode(be.vertexCode, be.fragmentCode, e);
        }, this._engine);
      }
    };
    this._loadShader(E, "Vertex", "", (L) => {
      ii.Initialize(b), ii.Process(L, b, (Q) => {
        this._rawVertexSourceCode = L, _ && (Q = _("vertex", Q)), R[0] = Q, y();
      }, this._engine);
    }), this._loadShader(m, "Fragment", "Pixel", (L) => {
      this._rawFragmentSourceCode = L, R[1] = L, y();
    });
  }
  static get ShadersRepository() {
    return N.ShadersRepository;
  }
  static set ShadersRepository(e) {
    N.ShadersRepository = e;
  }
  get onBindObservable() {
    return this._onBindObservable || (this._onBindObservable = new F()), this._onBindObservable;
  }
  _useFinalCode(e, t, i) {
    if (i) {
      const s = i.vertexElement || i.vertex || i.spectorName || i, r = i.fragmentElement || i.fragment || i.spectorName || i;
      this._vertexSourceCode = (this._shaderLanguage === Ze.WGSL ? "//" : "") + "#define SHADER_NAME vertex:" + s + `
` + e, this._fragmentSourceCode = (this._shaderLanguage === Ze.WGSL ? "//" : "") + "#define SHADER_NAME fragment:" + r + `
` + t;
    } else
      this._vertexSourceCode = e, this._fragmentSourceCode = t;
    this._prepareEffect();
  }
  get key() {
    return this._key;
  }
  isReady() {
    try {
      return this._isReadyInternal();
    } catch {
      return !1;
    }
  }
  _isReadyInternal() {
    return this._isReady ? !0 : this._pipelineContext ? this._pipelineContext.isReady : !1;
  }
  getEngine() {
    return this._engine;
  }
  getPipelineContext() {
    return this._pipelineContext;
  }
  getAttributesNames() {
    return this._attributesNames;
  }
  getAttributeLocation(e) {
    return this._attributes[e];
  }
  getAttributeLocationByName(e) {
    return this._attributeLocationByName[e];
  }
  getAttributesCount() {
    return this._attributes.length;
  }
  getUniformIndex(e) {
    return this._uniformsNames.indexOf(e);
  }
  getUniform(e) {
    return this._uniforms[e];
  }
  getSamplers() {
    return this._samplerList;
  }
  getUniformNames() {
    return this._uniformsNames;
  }
  getUniformBuffersNames() {
    return this._uniformBuffersNamesList;
  }
  getIndexParameters() {
    return this._indexParameters;
  }
  getCompilationError() {
    return this._compilationError;
  }
  allFallbacksProcessed() {
    return this._allFallbacksProcessed;
  }
  executeWhenCompiled(e) {
    if (this.isReady()) {
      e(this);
      return;
    }
    this.onCompileObservable.add((t) => {
      e(t);
    }), (!this._pipelineContext || this._pipelineContext.isAsync) && setTimeout(() => {
      this._checkIsReady(null);
    }, 16);
  }
  _checkIsReady(e) {
    try {
      if (this._isReadyInternal())
        return;
    } catch (t) {
      this._processCompilationErrors(t, e);
      return;
    }
    this._isDisposed || setTimeout(() => {
      this._checkIsReady(e);
    }, 16);
  }
  _loadShader(e, t, i, s) {
    if (typeof HTMLElement < "u" && e instanceof HTMLElement) {
      const a = Fs(e);
      s(a);
      return;
    }
    if (e.substr(0, 7) === "source:") {
      s(e.substr(7));
      return;
    }
    if (e.substr(0, 7) === "base64:") {
      const a = window.atob(e.substr(7));
      s(a);
      return;
    }
    const r = N.GetShadersStore(this._shaderLanguage);
    if (r[e + t + "Shader"]) {
      s(r[e + t + "Shader"]);
      return;
    }
    if (i && r[e + i + "Shader"]) {
      s(r[e + i + "Shader"]);
      return;
    }
    let n;
    e[0] === "." || e[0] === "/" || e.indexOf("http") > -1 ? n = e : n = N.GetShadersRepository(this._shaderLanguage) + e, this._engine._loadFile(n + "." + t.toLowerCase() + ".fx", s);
  }
  get vertexSourceCode() {
    var e, t;
    return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : (t = (e = this._pipelineContext) == null ? void 0 : e._getVertexShaderCode()) != null ? t : this._vertexSourceCode;
  }
  get fragmentSourceCode() {
    var e, t;
    return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : (t = (e = this._pipelineContext) == null ? void 0 : e._getFragmentShaderCode()) != null ? t : this._fragmentSourceCode;
  }
  get rawVertexSourceCode() {
    return this._rawVertexSourceCode;
  }
  get rawFragmentSourceCode() {
    return this._rawFragmentSourceCode;
  }
  _rebuildProgram(e, t, i, s) {
    this._isReady = !1, this._vertexSourceCodeOverride = e, this._fragmentSourceCodeOverride = t, this.onError = (r, n) => {
      s && s(n);
    }, this.onCompiled = () => {
      const r = this.getEngine().scenes;
      if (r)
        for (let n = 0; n < r.length; n++)
          r[n].markAllMaterialsAsDirty(63);
      this._pipelineContext._handlesSpectorRebuildCallback(i);
    }, this._fallbacks = null, this._prepareEffect();
  }
  _prepareEffect() {
    const e = this._attributesNames, t = this.defines, i = this._pipelineContext;
    this._isReady = !1;
    try {
      const s = this._engine;
      this._pipelineContext = s.createPipelineContext(this._processingContext), this._pipelineContext._name = this._key;
      const r = this._rebuildProgram.bind(this);
      this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? s._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, !0, this._rawVertexSourceCode, this._rawFragmentSourceCode, r, null, this._transformFeedbackVaryings, this._key) : s._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, !1, this._rawVertexSourceCode, this._rawFragmentSourceCode, r, t, this._transformFeedbackVaryings, this._key), s._executeWhenRenderingStateIsCompiled(this._pipelineContext, () => {
        if (this._attributes = [], this._pipelineContext._fillEffectInformation(this, this._uniformBuffersNames, this._uniformsNames, this._uniforms, this._samplerList, this._samplers, e, this._attributes), e)
          for (let n = 0; n < e.length; n++) {
            const a = e[n];
            this._attributeLocationByName[a] = this._attributes[n];
          }
        s.bindSamplers(this), this._compilationError = "", this._isReady = !0, this.onCompiled && this.onCompiled(this), this.onCompileObservable.notifyObservers(this), this.onCompileObservable.clear(), this._fallbacks && this._fallbacks.unBindMesh(), i && this.getEngine()._deletePipelineContext(i);
      }), this._pipelineContext.isAsync && this._checkIsReady(i);
    } catch (s) {
      this._processCompilationErrors(s, i);
    }
  }
  _getShaderCodeAndErrorLine(e, t, i) {
    const s = i ? /FRAGMENT SHADER ERROR: 0:(\d+?):/ : /VERTEX SHADER ERROR: 0:(\d+?):/;
    let r = null;
    if (t && e) {
      const n = t.match(s);
      if (n && n.length === 2) {
        const a = parseInt(n[1]), o = e.split(`
`, -1);
        o.length >= a && (r = `Offending line [${a}] in ${i ? "fragment" : "vertex"} code: ${o[a - 1]}`);
      }
    }
    return [e, r];
  }
  _processCompilationErrors(e, t = null) {
    var r, n, a;
    this._compilationError = e.message;
    const i = this._attributesNames, s = this._fallbacks;
    if (w.Error("Unable to compile effect:"), w.Error("Uniforms: " + this._uniformsNames.map(function(o) {
      return " " + o;
    })), w.Error("Attributes: " + i.map(function(o) {
      return " " + o;
    })), w.Error(`Defines:\r
` + this.defines), De.LogShaderCodeOnCompilationError) {
      let o = null, h = null, l = null;
      (r = this._pipelineContext) != null && r._getVertexShaderCode() && ([l, o] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, !1), l && (w.Error("Vertex code:"), w.Error(l))), (n = this._pipelineContext) != null && n._getFragmentShaderCode() && ([l, h] = this._getShaderCodeAndErrorLine((a = this._pipelineContext) == null ? void 0 : a._getFragmentShaderCode(), this._compilationError, !0), l && (w.Error("Fragment code:"), w.Error(l))), o && w.Error(o), h && w.Error(h);
    }
    w.Error("Error: " + this._compilationError), t && (this._pipelineContext = t, this._isReady = !0, this.onError && this.onError(this, this._compilationError), this.onErrorObservable.notifyObservers(this)), s ? (this._pipelineContext = null, s.hasMoreFallbacks ? (this._allFallbacksProcessed = !1, w.Error("Trying next fallback."), this.defines = s.reduce(this.defines, this), this._prepareEffect()) : (this._allFallbacksProcessed = !0, this.onError && this.onError(this, this._compilationError), this.onErrorObservable.notifyObservers(this), this.onErrorObservable.clear(), this._fallbacks && this._fallbacks.unBindMesh())) : this._allFallbacksProcessed = !0;
  }
  get isSupported() {
    return this._compilationError === "";
  }
  _bindTexture(e, t) {
    this._engine._bindTexture(this._samplers[e], t, e);
  }
  setTexture(e, t) {
    this._engine.setTexture(this._samplers[e], this._uniforms[e], t, e);
  }
  setDepthStencilTexture(e, t) {
    this._engine.setDepthStencilTexture(this._samplers[e], this._uniforms[e], t, e);
  }
  setTextureArray(e, t) {
    const i = e + "Ex";
    if (this._samplerList.indexOf(i + "0") === -1) {
      const s = this._samplerList.indexOf(e);
      for (let n = 1; n < t.length; n++) {
        const a = i + (n - 1).toString();
        this._samplerList.splice(s + n, 0, a);
      }
      let r = 0;
      for (const n of this._samplerList)
        this._samplers[n] = r, r += 1;
    }
    this._engine.setTextureArray(this._samplers[e], this._uniforms[e], t, e);
  }
  setTextureFromPostProcess(e, t) {
    this._engine.setTextureFromPostProcess(this._samplers[e], t, e);
  }
  setTextureFromPostProcessOutput(e, t) {
    this._engine.setTextureFromPostProcessOutput(this._samplers[e], t, e);
  }
  bindUniformBuffer(e, t) {
    const i = this._uniformBuffersNames[t];
    i === void 0 || De._BaseCache[i] === e && this._engine._features.useUBOBindingCache || (De._BaseCache[i] = e, this._engine.bindUniformBufferBase(e, i, t));
  }
  bindUniformBlock(e, t) {
    this._engine.bindUniformBlock(this._pipelineContext, e, t);
  }
  setInt(e, t) {
    return this._pipelineContext.setInt(e, t), this;
  }
  setInt2(e, t, i) {
    return this._pipelineContext.setInt2(e, t, i), this;
  }
  setInt3(e, t, i, s) {
    return this._pipelineContext.setInt3(e, t, i, s), this;
  }
  setInt4(e, t, i, s, r) {
    return this._pipelineContext.setInt4(e, t, i, s, r), this;
  }
  setIntArray(e, t) {
    return this._pipelineContext.setIntArray(e, t), this;
  }
  setIntArray2(e, t) {
    return this._pipelineContext.setIntArray2(e, t), this;
  }
  setIntArray3(e, t) {
    return this._pipelineContext.setIntArray3(e, t), this;
  }
  setIntArray4(e, t) {
    return this._pipelineContext.setIntArray4(e, t), this;
  }
  setFloatArray(e, t) {
    return this._pipelineContext.setArray(e, t), this;
  }
  setFloatArray2(e, t) {
    return this._pipelineContext.setArray2(e, t), this;
  }
  setFloatArray3(e, t) {
    return this._pipelineContext.setArray3(e, t), this;
  }
  setFloatArray4(e, t) {
    return this._pipelineContext.setArray4(e, t), this;
  }
  setArray(e, t) {
    return this._pipelineContext.setArray(e, t), this;
  }
  setArray2(e, t) {
    return this._pipelineContext.setArray2(e, t), this;
  }
  setArray3(e, t) {
    return this._pipelineContext.setArray3(e, t), this;
  }
  setArray4(e, t) {
    return this._pipelineContext.setArray4(e, t), this;
  }
  setMatrices(e, t) {
    return this._pipelineContext.setMatrices(e, t), this;
  }
  setMatrix(e, t) {
    return this._pipelineContext.setMatrix(e, t), this;
  }
  setMatrix3x3(e, t) {
    return this._pipelineContext.setMatrix3x3(e, t), this;
  }
  setMatrix2x2(e, t) {
    return this._pipelineContext.setMatrix2x2(e, t), this;
  }
  setFloat(e, t) {
    return this._pipelineContext.setFloat(e, t), this;
  }
  setBool(e, t) {
    return this._pipelineContext.setInt(e, t ? 1 : 0), this;
  }
  setVector2(e, t) {
    return this._pipelineContext.setVector2(e, t), this;
  }
  setFloat2(e, t, i) {
    return this._pipelineContext.setFloat2(e, t, i), this;
  }
  setVector3(e, t) {
    return this._pipelineContext.setVector3(e, t), this;
  }
  setFloat3(e, t, i, s) {
    return this._pipelineContext.setFloat3(e, t, i, s), this;
  }
  setVector4(e, t) {
    return this._pipelineContext.setVector4(e, t), this;
  }
  setQuaternion(e, t) {
    return this._pipelineContext.setQuaternion(e, t), this;
  }
  setFloat4(e, t, i, s, r) {
    return this._pipelineContext.setFloat4(e, t, i, s, r), this;
  }
  setColor3(e, t) {
    return this._pipelineContext.setColor3(e, t), this;
  }
  setColor4(e, t, i) {
    return this._pipelineContext.setColor4(e, t, i), this;
  }
  setDirectColor4(e, t) {
    return this._pipelineContext.setDirectColor4(e, t), this;
  }
  dispose() {
    this._pipelineContext && this._pipelineContext.dispose(), this._engine._releaseEffect(this), this._isDisposed = !0;
  }
  static RegisterShader(e, t, i, s = Ze.GLSL) {
    t && (N.GetShadersStore(s)[`${e}PixelShader`] = t), i && (N.GetShadersStore(s)[`${e}VertexShader`] = i);
  }
  static ResetCache() {
    De._BaseCache = {};
  }
}
De.LogShaderCodeOnCompilationError = !0;
De._UniqueIdSeed = 0;
De._BaseCache = {};
De.ShadersStore = N.ShadersStore;
De.IncludesShadersStore = N.IncludesShadersStore;
class Kr {
  constructor(e = !0) {
    this._isDepthTestDirty = !1, this._isDepthMaskDirty = !1, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !1, this._isFrontFaceDirty = !1, e && this.reset();
  }
  get isDirty() {
    return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty;
  }
  get zOffset() {
    return this._zOffset;
  }
  set zOffset(e) {
    this._zOffset !== e && (this._zOffset = e, this._isZOffsetDirty = !0);
  }
  get zOffsetUnits() {
    return this._zOffsetUnits;
  }
  set zOffsetUnits(e) {
    this._zOffsetUnits !== e && (this._zOffsetUnits = e, this._isZOffsetDirty = !0);
  }
  get cullFace() {
    return this._cullFace;
  }
  set cullFace(e) {
    this._cullFace !== e && (this._cullFace = e, this._isCullFaceDirty = !0);
  }
  get cull() {
    return this._cull;
  }
  set cull(e) {
    this._cull !== e && (this._cull = e, this._isCullDirty = !0);
  }
  get depthFunc() {
    return this._depthFunc;
  }
  set depthFunc(e) {
    this._depthFunc !== e && (this._depthFunc = e, this._isDepthFuncDirty = !0);
  }
  get depthMask() {
    return this._depthMask;
  }
  set depthMask(e) {
    this._depthMask !== e && (this._depthMask = e, this._isDepthMaskDirty = !0);
  }
  get depthTest() {
    return this._depthTest;
  }
  set depthTest(e) {
    this._depthTest !== e && (this._depthTest = e, this._isDepthTestDirty = !0);
  }
  get frontFace() {
    return this._frontFace;
  }
  set frontFace(e) {
    this._frontFace !== e && (this._frontFace = e, this._isFrontFaceDirty = !0);
  }
  reset() {
    this._depthMask = !0, this._depthTest = !0, this._depthFunc = null, this._cullFace = null, this._cull = null, this._zOffset = 0, this._zOffsetUnits = 0, this._frontFace = null, this._isDepthTestDirty = !0, this._isDepthMaskDirty = !0, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !0, this._isFrontFaceDirty = !1;
  }
  apply(e) {
    !this.isDirty || (this._isCullDirty && (this.cull ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), this._isCullDirty = !1), this._isCullFaceDirty && (e.cullFace(this.cullFace), this._isCullFaceDirty = !1), this._isDepthMaskDirty && (e.depthMask(this.depthMask), this._isDepthMaskDirty = !1), this._isDepthTestDirty && (this.depthTest ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this._isDepthTestDirty = !1), this._isDepthFuncDirty && (e.depthFunc(this.depthFunc), this._isDepthFuncDirty = !1), this._isZOffsetDirty && (this.zOffset || this.zOffsetUnits ? (e.enable(e.POLYGON_OFFSET_FILL), e.polygonOffset(this.zOffset, this.zOffsetUnits)) : e.disable(e.POLYGON_OFFSET_FILL), this._isZOffsetDirty = !1), this._isFrontFaceDirty && (e.frontFace(this.frontFace), this._isFrontFaceDirty = !1));
  }
}
class Ut {
  constructor() {
    this.reset();
  }
  reset() {
    this.enabled = !1, this.mask = 255, this.func = Ut.ALWAYS, this.funcRef = 1, this.funcMask = 255, this.opStencilFail = Ut.KEEP, this.opDepthFail = Ut.KEEP, this.opStencilDepthPass = Ut.REPLACE;
  }
  get stencilFunc() {
    return this.func;
  }
  set stencilFunc(e) {
    this.func = e;
  }
  get stencilFuncRef() {
    return this.funcRef;
  }
  set stencilFuncRef(e) {
    this.funcRef = e;
  }
  get stencilFuncMask() {
    return this.funcMask;
  }
  set stencilFuncMask(e) {
    this.funcMask = e;
  }
  get stencilOpStencilFail() {
    return this.opStencilFail;
  }
  set stencilOpStencilFail(e) {
    this.opStencilFail = e;
  }
  get stencilOpDepthFail() {
    return this.opDepthFail;
  }
  set stencilOpDepthFail(e) {
    this.opDepthFail = e;
  }
  get stencilOpStencilDepthPass() {
    return this.opStencilDepthPass;
  }
  set stencilOpStencilDepthPass(e) {
    this.opStencilDepthPass = e;
  }
  get stencilMask() {
    return this.mask;
  }
  set stencilMask(e) {
    this.mask = e;
  }
  get stencilTest() {
    return this.enabled;
  }
  set stencilTest(e) {
    this.enabled = e;
  }
}
Ut.ALWAYS = 519;
Ut.KEEP = 7680;
Ut.REPLACE = 7681;
class Yr {
  constructor() {
    this._blendFunctionParameters = new Array(4), this._blendEquationParameters = new Array(2), this._blendConstants = new Array(4), this._isBlendConstantsDirty = !1, this._alphaBlend = !1, this._isAlphaBlendDirty = !1, this._isBlendFunctionParametersDirty = !1, this._isBlendEquationParametersDirty = !1, this.reset();
  }
  get isDirty() {
    return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty;
  }
  get alphaBlend() {
    return this._alphaBlend;
  }
  set alphaBlend(e) {
    this._alphaBlend !== e && (this._alphaBlend = e, this._isAlphaBlendDirty = !0);
  }
  setAlphaBlendConstants(e, t, i, s) {
    this._blendConstants[0] === e && this._blendConstants[1] === t && this._blendConstants[2] === i && this._blendConstants[3] === s || (this._blendConstants[0] = e, this._blendConstants[1] = t, this._blendConstants[2] = i, this._blendConstants[3] = s, this._isBlendConstantsDirty = !0);
  }
  setAlphaBlendFunctionParameters(e, t, i, s) {
    this._blendFunctionParameters[0] === e && this._blendFunctionParameters[1] === t && this._blendFunctionParameters[2] === i && this._blendFunctionParameters[3] === s || (this._blendFunctionParameters[0] = e, this._blendFunctionParameters[1] = t, this._blendFunctionParameters[2] = i, this._blendFunctionParameters[3] = s, this._isBlendFunctionParametersDirty = !0);
  }
  setAlphaEquationParameters(e, t) {
    this._blendEquationParameters[0] === e && this._blendEquationParameters[1] === t || (this._blendEquationParameters[0] = e, this._blendEquationParameters[1] = t, this._isBlendEquationParametersDirty = !0);
  }
  reset() {
    this._alphaBlend = !1, this._blendFunctionParameters[0] = null, this._blendFunctionParameters[1] = null, this._blendFunctionParameters[2] = null, this._blendFunctionParameters[3] = null, this._blendEquationParameters[0] = null, this._blendEquationParameters[1] = null, this._blendConstants[0] = null, this._blendConstants[1] = null, this._blendConstants[2] = null, this._blendConstants[3] = null, this._isAlphaBlendDirty = !0, this._isBlendFunctionParametersDirty = !1, this._isBlendEquationParametersDirty = !1, this._isBlendConstantsDirty = !1;
  }
  apply(e) {
    !this.isDirty || (this._isAlphaBlendDirty && (this._alphaBlend ? e.enable(e.BLEND) : e.disable(e.BLEND), this._isAlphaBlendDirty = !1), this._isBlendFunctionParametersDirty && (e.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]), this._isBlendFunctionParametersDirty = !1), this._isBlendEquationParametersDirty && (e.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]), this._isBlendEquationParametersDirty = !1), this._isBlendConstantsDirty && (e.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]), this._isBlendConstantsDirty = !1));
  }
}
class Zr {
  constructor() {
    this.shaderLanguage = Ze.GLSL;
  }
  postProcessor(e, t, i, s, r) {
    if (!r.getCaps().drawBuffersExtension) {
      const n = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;
      e = e.replace(n, "");
    }
    return e;
  }
}
class qr {
  constructor() {
    this.shaderLanguage = Ze.GLSL;
  }
  attributeProcessor(e) {
    return e.replace("attribute", "in");
  }
  varyingProcessor(e, t) {
    return e.replace("varying", t ? "in" : "out");
  }
  postProcessor(e, t, i) {
    const s = e.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1, r = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
    if (e = e.replace(r, ""), e = e.replace(/texture2D\s*\(/g, "texture("), i)
      e = e.replace(/texture2DLodEXT\s*\(/g, "textureLod("), e = e.replace(/textureCubeLodEXT\s*\(/g, "textureLod("), e = e.replace(/textureCube\s*\(/g, "texture("), e = e.replace(/gl_FragDepthEXT/g, "gl_FragDepth"), e = e.replace(/gl_FragColor/g, "glFragColor"), e = e.replace(/gl_FragData/g, "glFragData"), e = e.replace(/void\s+?main\s*\(/g, (s ? "" : `out vec4 glFragColor;
`) + "void main(");
    else if (t.indexOf("#define MULTIVIEW") !== -1)
      return `#extension GL_OVR_multiview2 : require
layout (num_views = 2) in;
` + e;
    return e;
  }
}
class wi {
  constructor() {
    this.references = 0, this.capacity = 0, this.is32Bits = !1, this.uniqueId = wi._Counter++;
  }
  get underlyingResource() {
    return null;
  }
}
wi._Counter = 0;
class yi extends wi {
  constructor(e) {
    super(), this._buffer = e;
  }
  get underlyingResource() {
    return this._buffer;
  }
}
class jr {
  constructor() {
    this._valueCache = {}, this.vertexCompilationError = null, this.fragmentCompilationError = null, this.programLinkError = null, this.programValidationError = null;
  }
  get isAsync() {
    return this.isParallelCompiled;
  }
  get isReady() {
    return this.program ? this.isParallelCompiled ? this.engine._isRenderingStateCompiled(this) : !0 : !1;
  }
  _handlesSpectorRebuildCallback(e) {
    e && this.program && e(this.program);
  }
  _fillEffectInformation(e, t, i, s, r, n, a, o) {
    const h = this.engine;
    if (h.supportsUniformBuffers)
      for (const f in t)
        e.bindUniformBlock(f, t[f]);
    this.engine.getUniforms(this, i).forEach((f, d) => {
      s[i[d]] = f;
    }), this._uniforms = s;
    let u;
    for (u = 0; u < r.length; u++)
      e.getUniform(r[u]) == null && (r.splice(u, 1), u--);
    r.forEach((f, d) => {
      n[f] = d;
    });
    for (const f of h.getAttributes(this, a))
      o.push(f);
  }
  dispose() {
    this._uniforms = {};
  }
  _cacheMatrix(e, t) {
    const i = this._valueCache[e], s = t.updateFlag;
    return i !== void 0 && i === s ? !1 : (this._valueCache[e] = s, !0);
  }
  _cacheFloat2(e, t, i) {
    let s = this._valueCache[e];
    if (!s || s.length !== 2)
      return s = [t, i], this._valueCache[e] = s, !0;
    let r = !1;
    return s[0] !== t && (s[0] = t, r = !0), s[1] !== i && (s[1] = i, r = !0), r;
  }
  _cacheFloat3(e, t, i, s) {
    let r = this._valueCache[e];
    if (!r || r.length !== 3)
      return r = [t, i, s], this._valueCache[e] = r, !0;
    let n = !1;
    return r[0] !== t && (r[0] = t, n = !0), r[1] !== i && (r[1] = i, n = !0), r[2] !== s && (r[2] = s, n = !0), n;
  }
  _cacheFloat4(e, t, i, s, r) {
    let n = this._valueCache[e];
    if (!n || n.length !== 4)
      return n = [t, i, s, r], this._valueCache[e] = n, !0;
    let a = !1;
    return n[0] !== t && (n[0] = t, a = !0), n[1] !== i && (n[1] = i, a = !0), n[2] !== s && (n[2] = s, a = !0), n[3] !== r && (n[3] = r, a = !0), a;
  }
  setInt(e, t) {
    const i = this._valueCache[e];
    i !== void 0 && i === t || this.engine.setInt(this._uniforms[e], t) && (this._valueCache[e] = t);
  }
  setInt2(e, t, i) {
    this._cacheFloat2(e, t, i) && (this.engine.setInt2(this._uniforms[e], t, i) || (this._valueCache[e] = null));
  }
  setInt3(e, t, i, s) {
    this._cacheFloat3(e, t, i, s) && (this.engine.setInt3(this._uniforms[e], t, i, s) || (this._valueCache[e] = null));
  }
  setInt4(e, t, i, s, r) {
    this._cacheFloat4(e, t, i, s, r) && (this.engine.setInt4(this._uniforms[e], t, i, s, r) || (this._valueCache[e] = null));
  }
  setIntArray(e, t) {
    this._valueCache[e] = null, this.engine.setIntArray(this._uniforms[e], t);
  }
  setIntArray2(e, t) {
    this._valueCache[e] = null, this.engine.setIntArray2(this._uniforms[e], t);
  }
  setIntArray3(e, t) {
    this._valueCache[e] = null, this.engine.setIntArray3(this._uniforms[e], t);
  }
  setIntArray4(e, t) {
    this._valueCache[e] = null, this.engine.setIntArray4(this._uniforms[e], t);
  }
  setArray(e, t) {
    this._valueCache[e] = null, this.engine.setArray(this._uniforms[e], t);
  }
  setArray2(e, t) {
    this._valueCache[e] = null, this.engine.setArray2(this._uniforms[e], t);
  }
  setArray3(e, t) {
    this._valueCache[e] = null, this.engine.setArray3(this._uniforms[e], t);
  }
  setArray4(e, t) {
    this._valueCache[e] = null, this.engine.setArray4(this._uniforms[e], t);
  }
  setMatrices(e, t) {
    !t || (this._valueCache[e] = null, this.engine.setMatrices(this._uniforms[e], t));
  }
  setMatrix(e, t) {
    this._cacheMatrix(e, t) && (this.engine.setMatrices(this._uniforms[e], t.toArray()) || (this._valueCache[e] = null));
  }
  setMatrix3x3(e, t) {
    this._valueCache[e] = null, this.engine.setMatrix3x3(this._uniforms[e], t);
  }
  setMatrix2x2(e, t) {
    this._valueCache[e] = null, this.engine.setMatrix2x2(this._uniforms[e], t);
  }
  setFloat(e, t) {
    const i = this._valueCache[e];
    i !== void 0 && i === t || this.engine.setFloat(this._uniforms[e], t) && (this._valueCache[e] = t);
  }
  setVector2(e, t) {
    this._cacheFloat2(e, t.x, t.y) && (this.engine.setFloat2(this._uniforms[e], t.x, t.y) || (this._valueCache[e] = null));
  }
  setFloat2(e, t, i) {
    this._cacheFloat2(e, t, i) && (this.engine.setFloat2(this._uniforms[e], t, i) || (this._valueCache[e] = null));
  }
  setVector3(e, t) {
    this._cacheFloat3(e, t.x, t.y, t.z) && (this.engine.setFloat3(this._uniforms[e], t.x, t.y, t.z) || (this._valueCache[e] = null));
  }
  setFloat3(e, t, i, s) {
    this._cacheFloat3(e, t, i, s) && (this.engine.setFloat3(this._uniforms[e], t, i, s) || (this._valueCache[e] = null));
  }
  setVector4(e, t) {
    this._cacheFloat4(e, t.x, t.y, t.z, t.w) && (this.engine.setFloat4(this._uniforms[e], t.x, t.y, t.z, t.w) || (this._valueCache[e] = null));
  }
  setQuaternion(e, t) {
    this._cacheFloat4(e, t.x, t.y, t.z, t.w) && (this.engine.setFloat4(this._uniforms[e], t.x, t.y, t.z, t.w) || (this._valueCache[e] = null));
  }
  setFloat4(e, t, i, s, r) {
    this._cacheFloat4(e, t, i, s, r) && (this.engine.setFloat4(this._uniforms[e], t, i, s, r) || (this._valueCache[e] = null));
  }
  setColor3(e, t) {
    this._cacheFloat3(e, t.r, t.g, t.b) && (this.engine.setFloat3(this._uniforms[e], t.r, t.g, t.b) || (this._valueCache[e] = null));
  }
  setColor4(e, t, i) {
    this._cacheFloat4(e, t.r, t.g, t.b, i) && (this.engine.setFloat4(this._uniforms[e], t.r, t.g, t.b, i) || (this._valueCache[e] = null));
  }
  setDirectColor4(e, t) {
    this._cacheFloat4(e, t.r, t.g, t.b, t.a) && (this.engine.setFloat4(this._uniforms[e], t.r, t.g, t.b, t.a) || (this._valueCache[e] = null));
  }
  _getVertexShaderCode() {
    return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null;
  }
  _getFragmentShaderCode() {
    return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null;
  }
}
class pr {
  constructor(e = null, t) {
    if (this._MSAARenderBuffer = null, this._context = t, !e && (e = t.createTexture(), !e))
      throw new Error("Unable to create webGL texture");
    this.set(e);
  }
  get underlyingResource() {
    return this._webGLTexture;
  }
  setUsage() {
  }
  set(e) {
    this._webGLTexture = e;
  }
  reset() {
    this._webGLTexture = null, this._MSAARenderBuffer = null;
  }
  release() {
    this._MSAARenderBuffer && (this._context.deleteRenderbuffer(this._MSAARenderBuffer), this._MSAARenderBuffer = null), this._webGLTexture && this._context.deleteTexture(this._webGLTexture), this.reset();
  }
}
class Oi {
  constructor(e, t = !0) {
    this.effect = null, this.defines = null, this.drawContext = e.createDrawContext(), t && (this.materialContext = e.createMaterialContext());
  }
  static IsWrapper(e) {
    return e.getPipelineContext === void 0;
  }
  static GetEffect(e) {
    return e.getPipelineContext === void 0 ? e.effect : e;
  }
  setEffect(e, t, i = !0) {
    var s;
    this.effect = e, t !== void 0 && (this.defines = t), i && ((s = this.drawContext) == null || s.reset());
  }
  dispose() {
    var e;
    (e = this.drawContext) == null || e.dispose();
  }
}
class Qr {
  constructor(e = !0) {
    this._isStencilTestDirty = !1, this._isStencilMaskDirty = !1, this._isStencilFuncDirty = !1, this._isStencilOpDirty = !1, this.useStencilGlobalOnly = !1, e && this.reset();
  }
  get isDirty() {
    return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;
  }
  get func() {
    return this._func;
  }
  set func(e) {
    this._func !== e && (this._func = e, this._isStencilFuncDirty = !0);
  }
  get funcRef() {
    return this._funcRef;
  }
  set funcRef(e) {
    this._funcRef !== e && (this._funcRef = e, this._isStencilFuncDirty = !0);
  }
  get funcMask() {
    return this._funcMask;
  }
  set funcMask(e) {
    this._funcMask !== e && (this._funcMask = e, this._isStencilFuncDirty = !0);
  }
  get opStencilFail() {
    return this._opStencilFail;
  }
  set opStencilFail(e) {
    this._opStencilFail !== e && (this._opStencilFail = e, this._isStencilOpDirty = !0);
  }
  get opDepthFail() {
    return this._opDepthFail;
  }
  set opDepthFail(e) {
    this._opDepthFail !== e && (this._opDepthFail = e, this._isStencilOpDirty = !0);
  }
  get opStencilDepthPass() {
    return this._opStencilDepthPass;
  }
  set opStencilDepthPass(e) {
    this._opStencilDepthPass !== e && (this._opStencilDepthPass = e, this._isStencilOpDirty = !0);
  }
  get mask() {
    return this._mask;
  }
  set mask(e) {
    this._mask !== e && (this._mask = e, this._isStencilMaskDirty = !0);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled !== e && (this._enabled = e, this._isStencilTestDirty = !0);
  }
  reset() {
    var e;
    this.stencilMaterial = void 0, (e = this.stencilGlobal) == null || e.reset(), this._isStencilTestDirty = !0, this._isStencilMaskDirty = !0, this._isStencilFuncDirty = !0, this._isStencilOpDirty = !0;
  }
  apply(e) {
    var i;
    if (!e)
      return;
    const t = !this.useStencilGlobalOnly && !!((i = this.stencilMaterial) != null && i.enabled);
    this.enabled = t ? this.stencilMaterial.enabled : this.stencilGlobal.enabled, this.func = t ? this.stencilMaterial.func : this.stencilGlobal.func, this.funcRef = t ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef, this.funcMask = t ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask, this.opStencilFail = t ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail, this.opDepthFail = t ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail, this.opStencilDepthPass = t ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass, this.mask = t ? this.stencilMaterial.mask : this.stencilGlobal.mask, this.isDirty && (this._isStencilTestDirty && (this.enabled ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this._isStencilTestDirty = !1), this._isStencilMaskDirty && (e.stencilMask(this.mask), this._isStencilMaskDirty = !1), this._isStencilFuncDirty && (e.stencilFunc(this.func, this.funcRef, this.funcMask), this._isStencilFuncDirty = !1), this._isStencilOpDirty && (e.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass), this._isStencilOpDirty = !1));
  }
}
class $r {
}
class le {
  constructor(e, t, i, s) {
    this._name = "WebGL", this.forcePOTTextures = !1, this.isFullscreen = !1, this.cullBackFaces = null, this.renderEvenInBackground = !0, this.preventCacheWipeBetweenFrames = !1, this.validateShaderPrograms = !1, this._useReverseDepthBuffer = !1, this.isNDCHalfZRange = !1, this.hasOriginBottomLeft = !0, this.disableUniformBuffers = !1, this.onDisposeObservable = new F(), this._frameId = 0, this._uniformBuffers = new Array(), this._storageBuffers = new Array(), this._webGLVersion = 1, this._windowIsBackground = !1, this._highPrecisionShadersAllowed = !0, this._badOS = !1, this._badDesktopOS = !1, this._renderingQueueLaunched = !1, this._activeRenderLoops = new Array(), this.onContextLostObservable = new F(), this.onContextRestoredObservable = new F(), this._contextWasLost = !1, this._doNotHandleContextLost = !1, this.disableVertexArrayObjects = !1, this._colorWrite = !0, this._colorWriteChanged = !0, this._depthCullingState = new Kr(), this._stencilStateComposer = new Qr(), this._stencilState = new Ut(), this._alphaState = new Yr(), this._alphaMode = 1, this._alphaEquation = 0, this._internalTexturesCache = new Array(), this._renderTargetWrapperCache = new Array(), this._activeChannel = 0, this._currentTextureChannel = -1, this._boundTexturesCache = {}, this._compiledEffects = {}, this._vertexAttribArraysEnabled = [], this._uintIndicesCurrentlySet = !1, this._currentBoundBuffer = new Array(), this._currentFramebuffer = null, this._dummyFramebuffer = null, this._currentBufferPointers = new Array(), this._currentInstanceLocations = new Array(), this._currentInstanceBuffers = new Array(), this._vaoRecordInProgress = !1, this._mustWipeVertexAttributes = !1, this._nextFreeTextureSlots = new Array(), this._maxSimultaneousTextures = 0, this._maxMSAASamplesOverride = null, this._activeRequests = new Array(), this.adaptToDeviceRatio = !1, this._lastDevicePixelRatio = 1, this._transformTextureUrl = null, this.hostInformation = {
      isMobile: !1
    }, this.premultipliedAlpha = !0, this.onBeforeTextureInitObservable = new F(), this._isWebGPU = !1, this._snapshotRenderingMode = 0, this._useExactSrgbConversions = !1, this._viewportCached = { x: 0, y: 0, z: 0, w: 0 }, this._unpackFlipYCached = null, this.enableUnpackFlipYCached = !0, this._boundUniforms = {};
    let r = null;
    if (i = i || {}, this._creationOptions = i, this.adaptToDeviceRatio = s != null ? s : !1, this._stencilStateComposer.stencilGlobal = this._stencilState, Ue.SetMatrixPrecision(!!i.useHighPrecisionMatrix), !e)
      return;
    if (s = s || i.adaptToDeviceRatio || !1, e.getContext) {
      if (r = e, this._renderingCanvas = r, t !== void 0 && (i.antialias = t), i.deterministicLockstep === void 0 && (i.deterministicLockstep = !1), i.lockstepMaxSteps === void 0 && (i.lockstepMaxSteps = 4), i.timeStep === void 0 && (i.timeStep = 1 / 60), i.preserveDrawingBuffer === void 0 && (i.preserveDrawingBuffer = !1), i.audioEngine === void 0 && (i.audioEngine = !0), i.audioEngineOptions !== void 0 && i.audioEngineOptions.audioContext !== void 0 && (this._audioContext = i.audioEngineOptions.audioContext), i.audioEngineOptions !== void 0 && i.audioEngineOptions.audioDestination !== void 0 && (this._audioDestination = i.audioEngineOptions.audioDestination), i.stencil === void 0 && (i.stencil = !0), i.premultipliedAlpha === !1 && (this.premultipliedAlpha = !1), i.xrCompatible === void 0 && (i.xrCompatible = !0), i.useExactSrgbConversions !== void 0 && (this._useExactSrgbConversions = i.useExactSrgbConversions), this._doNotHandleContextLost = !!i.doNotHandleContextLost, navigator && navigator.userAgent) {
        this._checkForMobile = () => {
          const l = navigator.userAgent;
          this.hostInformation.isMobile = l.indexOf("Mobile") !== -1 || l.indexOf("Mac") !== -1 && Hi() && "ontouchend" in document;
        }, this._checkForMobile(), Ne() && window.addEventListener("resize", this._checkForMobile);
        const h = navigator.userAgent;
        for (const l of le.ExceptionList) {
          const u = l.key, f = l.targets;
          if (new RegExp(u).test(h)) {
            if (l.capture && l.captureConstraint) {
              const _ = l.capture, E = l.captureConstraint, T = new RegExp(_).exec(h);
              if (T && T.length > 0 && parseInt(T[T.length - 1]) >= E)
                continue;
            }
            for (const _ of f)
              switch (_) {
                case "uniformBuffer":
                  this.disableUniformBuffers = !0;
                  break;
                case "vao":
                  this.disableVertexArrayObjects = !0;
                  break;
                case "antialias":
                  i.antialias = !1;
                  break;
                case "maxMSAASamples":
                  this._maxMSAASamplesOverride = 1;
                  break;
              }
          }
        }
      }
      if (this._doNotHandleContextLost || (this._onContextLost = (h) => {
        h.preventDefault(), this._contextWasLost = !0, w.Warn("WebGL context lost."), this.onContextLostObservable.notifyObservers(this);
      }, this._onContextRestored = () => {
        this._restoreEngineAfterContextLost(this._initGLContext.bind(this));
      }, r.addEventListener("webglcontextlost", this._onContextLost, !1), r.addEventListener("webglcontextrestored", this._onContextRestored, !1), i.powerPreference = "high-performance"), this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), this._badDesktopOS && (i.xrCompatible = !1), !i.disableWebGL2Support)
        try {
          this._gl = r.getContext("webgl2", i) || r.getContext("experimental-webgl2", i), this._gl && (this._webGLVersion = 2, this._shaderPlatformName = "WEBGL2", this._gl.deleteQuery || (this._webGLVersion = 1, this._shaderPlatformName = "WEBGL1"));
        } catch {
        }
      if (!this._gl) {
        if (!r)
          throw new Error("The provided canvas is null or undefined.");
        try {
          this._gl = r.getContext("webgl", i) || r.getContext("experimental-webgl", i);
        } catch {
          throw new Error("WebGL not supported");
        }
      }
      if (!this._gl)
        throw new Error("WebGL not supported");
    } else {
      this._gl = e, this._renderingCanvas = this._gl.canvas, this._gl.renderbufferStorageMultisample ? (this._webGLVersion = 2, this._shaderPlatformName = "WEBGL2") : this._shaderPlatformName = "WEBGL1";
      const h = this._gl.getContextAttributes();
      h && (i.stencil = h.stencil);
    }
    this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE), i.useHighPrecisionFloats !== void 0 && (this._highPrecisionShadersAllowed = i.useHighPrecisionFloats);
    const n = Ne() && window.devicePixelRatio || 1, a = i.limitDeviceRatio || n;
    this._hardwareScalingLevel = s ? 1 / Math.min(a, n) : 1, this._lastDevicePixelRatio = n, this.resize(), this._isStencilEnable = !!i.stencil, this._initGLContext(), this._initFeatures();
    for (let h = 0; h < this._caps.maxVertexAttribs; h++)
      this._currentBufferPointers[h] = new $r();
    this._shaderProcessor = this.webGLVersion > 1 ? new qr() : new Zr(), this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);
    const o = `Babylon.js v${le.Version}`;
    console.log(o + ` - ${this.description}`), this._renderingCanvas && this._renderingCanvas.setAttribute && this._renderingCanvas.setAttribute("data-engine", o);
  }
  static get NpmPackage() {
    return "babylonjs@5.23.0";
  }
  static get Version() {
    return "5.23.0";
  }
  get description() {
    let e = this.name + this.webGLVersion;
    return this._caps.parallelShaderCompile && (e += " - Parallel shader compilation"), e;
  }
  get name() {
    return this._name;
  }
  set name(e) {
    this._name = e;
  }
  get version() {
    return this._webGLVersion;
  }
  static get ShadersRepository() {
    return De.ShadersRepository;
  }
  static set ShadersRepository(e) {
    De.ShadersRepository = e;
  }
  _getShaderProcessor(e) {
    return this._shaderProcessor;
  }
  get useReverseDepthBuffer() {
    return this._useReverseDepthBuffer;
  }
  set useReverseDepthBuffer(e) {
    e !== this._useReverseDepthBuffer && (this._useReverseDepthBuffer = e, e ? this._depthCullingState.depthFunc = 518 : this._depthCullingState.depthFunc = 515);
  }
  get frameId() {
    return this._frameId;
  }
  get supportsUniformBuffers() {
    return this.webGLVersion > 1 && !this.disableUniformBuffers;
  }
  getCreationOptions() {
    return this._creationOptions;
  }
  get _shouldUseHighPrecisionShader() {
    return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);
  }
  get needPOTTextures() {
    return this._webGLVersion < 2 || this.forcePOTTextures;
  }
  get activeRenderLoops() {
    return this._activeRenderLoops;
  }
  get doNotHandleContextLost() {
    return this._doNotHandleContextLost;
  }
  set doNotHandleContextLost(e) {
    this._doNotHandleContextLost = e;
  }
  get _supportsHardwareTextureRescaling() {
    return !1;
  }
  set framebufferDimensionsObject(e) {
    this._framebufferDimensionsObject = e;
  }
  get currentViewport() {
    return this._cachedViewport;
  }
  get emptyTexture() {
    return this._emptyTexture || (this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, !1, !1, 1)), this._emptyTexture;
  }
  get emptyTexture3D() {
    return this._emptyTexture3D || (this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, !1, !1, 1)), this._emptyTexture3D;
  }
  get emptyTexture2DArray() {
    return this._emptyTexture2DArray || (this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, !1, !1, 1)), this._emptyTexture2DArray;
  }
  get emptyCubeTexture() {
    if (!this._emptyCubeTexture) {
      const e = new Uint8Array(4), t = [e, e, e, e, e, e];
      this._emptyCubeTexture = this.createRawCubeTexture(t, 1, 5, 0, !1, !1, 1);
    }
    return this._emptyCubeTexture;
  }
  get isWebGPU() {
    return this._isWebGPU;
  }
  get shaderPlatformName() {
    return this._shaderPlatformName;
  }
  get snapshotRendering() {
    return !1;
  }
  set snapshotRendering(e) {
  }
  get snapshotRenderingMode() {
    return this._snapshotRenderingMode;
  }
  set snapshotRenderingMode(e) {
    this._snapshotRenderingMode = e;
  }
  get useExactSrgbConversions() {
    return this._useExactSrgbConversions;
  }
  snapshotRenderingReset() {
    this.snapshotRendering = !1;
  }
  static _CreateCanvas(e, t) {
    if (typeof document > "u")
      return new OffscreenCanvas(e, t);
    const i = document.createElement("canvas");
    return i.width = e, i.height = t, i;
  }
  createCanvas(e, t) {
    return le._CreateCanvas(e, t);
  }
  createCanvasImage() {
    return document.createElement("img");
  }
  _restoreEngineAfterContextLost(e) {
    setTimeout(async () => {
      var n;
      this._dummyFramebuffer = null;
      const t = this._depthCullingState.depthTest, i = this._depthCullingState.depthFunc, s = this._depthCullingState.depthMask, r = this._stencilState.stencilTest;
      await e(), this._rebuildEffects(), (n = this._rebuildComputeEffects) == null || n.call(this), this._rebuildInternalTextures(), this._rebuildRenderTargetWrappers(), this._rebuildBuffers(), this.wipeCaches(!0), this._depthCullingState.depthTest = t, this._depthCullingState.depthFunc = i, this._depthCullingState.depthMask = s, this._stencilState.stencilTest = r, w.Warn(this.name + " context successfully restored."), this.onContextRestoredObservable.notifyObservers(this), this._contextWasLost = !1;
    }, 0);
  }
  _sharedInit(e, t, i) {
    this._renderingCanvas = e;
  }
  _getShaderProcessingContext(e) {
    return null;
  }
  _rebuildInternalTextures() {
    const e = this._internalTexturesCache.slice();
    for (const t of e)
      t._rebuild();
  }
  _rebuildRenderTargetWrappers() {
    const e = this._renderTargetWrapperCache.slice();
    for (const t of e)
      t._rebuild();
  }
  _rebuildEffects() {
    for (const e in this._compiledEffects) {
      const t = this._compiledEffects[e];
      t._pipelineContext = null, t._wasPreviouslyReady = !1, t._prepareEffect();
    }
    De.ResetCache();
  }
  areAllEffectsReady() {
    for (const e in this._compiledEffects)
      if (!this._compiledEffects[e].isReady())
        return !1;
    return !0;
  }
  _rebuildBuffers() {
    for (const e of this._uniformBuffers)
      e._rebuild();
    for (const e of this._storageBuffers)
      e._rebuild();
  }
  _initGLContext() {
    var t;
    this._caps = {
      maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),
      maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),
      maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,
      maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),
      maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),
      maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),
      maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),
      maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),
      maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),
      parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile") || void 0,
      standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension("OES_standard_derivatives") !== null,
      maxAnisotropy: 1,
      astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
      bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
      s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
      s3tc_srgb: this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),
      pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
      etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"),
      textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),
      uintIndices: this._webGLVersion > 1 || this._gl.getExtension("OES_element_index_uint") !== null,
      fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension("EXT_frag_depth") !== null,
      highPrecisionShaderSupported: !1,
      timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"),
      supportOcclusionQuery: this._webGLVersion > 1,
      canUseTimestampForTimerQuery: !1,
      drawBuffersExtension: !1,
      maxMSAASamples: 1,
      colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float")),
      textureFloat: !!(this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float")),
      textureHalfFloat: !!(this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float")),
      textureHalfFloatRender: !1,
      textureFloatLinearFiltering: !1,
      textureFloatRender: !1,
      textureHalfFloatLinearFiltering: !1,
      vertexArrayObject: !1,
      instancedArrays: !1,
      textureLOD: !!(this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod")),
      blendMinMax: !1,
      multiview: this._gl.getExtension("OVR_multiview2"),
      oculusMultiview: this._gl.getExtension("OCULUS_multiview"),
      depthTextureExtension: !1,
      canUseGLInstanceID: this._webGLVersion > 1,
      canUseGLVertexID: this._webGLVersion > 1,
      supportComputeShaders: !1,
      supportSRGBBuffers: !1,
      supportTransformFeedbacks: this._webGLVersion > 1,
      textureMaxLevel: this._webGLVersion > 1,
      texture2DArrayMaxLayerCount: this._webGLVersion > 1 ? 256 : 128
    }, this._glVersion = this._gl.getParameter(this._gl.VERSION);
    const e = this._gl.getExtension("WEBGL_debug_renderer_info");
    if (e != null && (this._glRenderer = this._gl.getParameter(e.UNMASKED_RENDERER_WEBGL), this._glVendor = this._gl.getParameter(e.UNMASKED_VENDOR_WEBGL)), this._glVendor || (this._glVendor = this._gl.getParameter(this._gl.VENDOR) || "Unknown vendor"), this._glRenderer || (this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || "Unknown renderer"), this._gl.HALF_FLOAT_OES !== 36193 && (this._gl.HALF_FLOAT_OES = 36193), this._gl.RGBA16F !== 34842 && (this._gl.RGBA16F = 34842), this._gl.RGBA32F !== 34836 && (this._gl.RGBA32F = 34836), this._gl.DEPTH24_STENCIL8 !== 35056 && (this._gl.DEPTH24_STENCIL8 = 35056), this._caps.timerQuery && (this._webGLVersion === 1 && (this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery)), this._caps.canUseTimestampForTimerQuery = ((t = this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT)) != null ? t : 0) > 0), this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, this._caps.textureFloatLinearFiltering = !!(this._caps.textureFloat && this._gl.getExtension("OES_texture_float_linear")), this._caps.textureFloatRender = !!(this._caps.textureFloat && this._canRenderToFloatFramebuffer()), this._caps.textureHalfFloatLinearFiltering = !!(this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear")), this._caps.astc && (this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR), this._caps.bptc && (this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT), this._caps.s3tc_srgb && (this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT, this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT), this._caps.etc2 && (this._gl.COMPRESSED_SRGB8_ETC2 = this._caps.etc2.COMPRESSED_SRGB8_ETC2, this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC), this._webGLVersion > 1 && this._gl.HALF_FLOAT_OES !== 5131 && (this._gl.HALF_FLOAT_OES = 5131), this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer(), this._webGLVersion > 1)
      this._caps.drawBuffersExtension = !0, this._caps.maxMSAASamples = this._maxMSAASamplesOverride !== null ? this._maxMSAASamplesOverride : this._gl.getParameter(this._gl.MAX_SAMPLES);
    else {
      const i = this._gl.getExtension("WEBGL_draw_buffers");
      if (i !== null) {
        this._caps.drawBuffersExtension = !0, this._gl.drawBuffers = i.drawBuffersWEBGL.bind(i), this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;
        for (let s = 0; s < 16; s++)
          this._gl["COLOR_ATTACHMENT" + s + "_WEBGL"] = i["COLOR_ATTACHMENT" + s + "_WEBGL"];
      }
    }
    if (this._webGLVersion > 1)
      this._caps.depthTextureExtension = !0;
    else {
      const i = this._gl.getExtension("WEBGL_depth_texture");
      i != null && (this._caps.depthTextureExtension = !0, this._gl.UNSIGNED_INT_24_8 = i.UNSIGNED_INT_24_8_WEBGL);
    }
    if (this.disableVertexArrayObjects)
      this._caps.vertexArrayObject = !1;
    else if (this._webGLVersion > 1)
      this._caps.vertexArrayObject = !0;
    else {
      const i = this._gl.getExtension("OES_vertex_array_object");
      i != null && (this._caps.vertexArrayObject = !0, this._gl.createVertexArray = i.createVertexArrayOES.bind(i), this._gl.bindVertexArray = i.bindVertexArrayOES.bind(i), this._gl.deleteVertexArray = i.deleteVertexArrayOES.bind(i));
    }
    if (this._webGLVersion > 1)
      this._caps.instancedArrays = !0;
    else {
      const i = this._gl.getExtension("ANGLE_instanced_arrays");
      i != null ? (this._caps.instancedArrays = !0, this._gl.drawArraysInstanced = i.drawArraysInstancedANGLE.bind(i), this._gl.drawElementsInstanced = i.drawElementsInstancedANGLE.bind(i), this._gl.vertexAttribDivisor = i.vertexAttribDivisorANGLE.bind(i)) : this._caps.instancedArrays = !1;
    }
    if (this._gl.getShaderPrecisionFormat) {
      const i = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT), s = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
      i && s && (this._caps.highPrecisionShaderSupported = i.precision !== 0 && s.precision !== 0);
    }
    if (this._webGLVersion > 1)
      this._caps.blendMinMax = !0;
    else {
      const i = this._gl.getExtension("EXT_blend_minmax");
      i != null && (this._caps.blendMinMax = !0, this._gl.MAX = i.MAX_EXT, this._gl.MIN = i.MIN_EXT);
    }
    if (!this._caps.supportSRGBBuffers) {
      if (this._webGLVersion > 1)
        this._caps.supportSRGBBuffers = !0;
      else {
        const i = this._gl.getExtension("EXT_sRGB");
        i != null && (this._caps.supportSRGBBuffers = !0, this._gl.SRGB = i.SRGB_EXT, this._gl.SRGB8 = i.SRGB_ALPHA_EXT, this._gl.SRGB8_ALPHA8 = i.SRGB_ALPHA_EXT);
      }
      this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && !!(this._creationOptions && this._creationOptions.forceSRGBBufferSupportState);
    }
    this._depthCullingState.depthTest = !0, this._depthCullingState.depthFunc = this._gl.LEQUAL, this._depthCullingState.depthMask = !0, this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;
    for (let i = 0; i < this._maxSimultaneousTextures; i++)
      this._nextFreeTextureSlots.push(i);
  }
  _initFeatures() {
    this._features = {
      forceBitmapOverHTMLImageElement: !1,
      supportRenderAndCopyToLodForFloatTextures: this._webGLVersion !== 1,
      supportDepthStencilTexture: this._webGLVersion !== 1,
      supportShadowSamplers: this._webGLVersion !== 1,
      uniformBufferHardCheckMatrix: !1,
      allowTexturePrefiltering: this._webGLVersion !== 1,
      trackUbosInFrame: !1,
      checkUbosContentBeforeUpload: !1,
      supportCSM: this._webGLVersion !== 1,
      basisNeedsPOT: this._webGLVersion === 1,
      support3DTextures: this._webGLVersion !== 1,
      needTypeSuffixInShaderConstants: this._webGLVersion !== 1,
      supportMSAA: this._webGLVersion !== 1,
      supportSSAO2: this._webGLVersion !== 1,
      supportExtendedTextureFormats: this._webGLVersion !== 1,
      supportSwitchCaseInShader: this._webGLVersion !== 1,
      supportSyncTextureRead: !0,
      needsInvertingBitmap: !0,
      useUBOBindingCache: !0,
      needShaderCodeInlining: !1,
      needToAlwaysBindUniformBuffers: !1,
      supportRenderPasses: !1,
      supportSpriteInstancing: !0,
      _collectUbosUpdatedInFrame: !1
    };
  }
  get webGLVersion() {
    return this._webGLVersion;
  }
  getClassName() {
    return "ThinEngine";
  }
  get isStencilEnable() {
    return this._isStencilEnable;
  }
  _prepareWorkingCanvas() {
    if (this._workingCanvas)
      return;
    this._workingCanvas = this.createCanvas(1, 1);
    const e = this._workingCanvas.getContext("2d");
    e && (this._workingContext = e);
  }
  resetTextureCache() {
    for (const e in this._boundTexturesCache)
      !Object.prototype.hasOwnProperty.call(this._boundTexturesCache, e) || (this._boundTexturesCache[e] = null);
    this._currentTextureChannel = -1;
  }
  getInfo() {
    return this.getGlInfo();
  }
  getGlInfo() {
    return {
      vendor: this._glVendor,
      renderer: this._glRenderer,
      version: this._glVersion
    };
  }
  setHardwareScalingLevel(e) {
    this._hardwareScalingLevel = e, this.resize();
  }
  getHardwareScalingLevel() {
    return this._hardwareScalingLevel;
  }
  getLoadedTexturesCache() {
    return this._internalTexturesCache;
  }
  getCaps() {
    return this._caps;
  }
  stopRenderLoop(e) {
    if (!e) {
      this._activeRenderLoops = [];
      return;
    }
    const t = this._activeRenderLoops.indexOf(e);
    t >= 0 && this._activeRenderLoops.splice(t, 1);
  }
  _renderLoop() {
    if (!this._contextWasLost) {
      let e = !0;
      if (!this.renderEvenInBackground && this._windowIsBackground && (e = !1), e) {
        this.beginFrame();
        for (let t = 0; t < this._activeRenderLoops.length; t++) {
          const i = this._activeRenderLoops[t];
          i();
        }
        this.endFrame();
      }
    }
    this._activeRenderLoops.length > 0 ? this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow()) : this._renderingQueueLaunched = !1;
  }
  getRenderingCanvas() {
    return this._renderingCanvas;
  }
  getAudioContext() {
    return this._audioContext;
  }
  getAudioDestination() {
    return this._audioDestination;
  }
  getHostWindow() {
    return Ne() ? this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView ? this._renderingCanvas.ownerDocument.defaultView : window : null;
  }
  getRenderWidth(e = !1) {
    return !e && this._currentRenderTarget ? this._currentRenderTarget.width : this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth;
  }
  getRenderHeight(e = !1) {
    return !e && this._currentRenderTarget ? this._currentRenderTarget.height : this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight;
  }
  _queueNewFrame(e, t) {
    return le.QueueNewFrame(e, t);
  }
  runRenderLoop(e) {
    this._activeRenderLoops.indexOf(e) === -1 && (this._activeRenderLoops.push(e), this._renderingQueueLaunched || (this._renderingQueueLaunched = !0, this._boundRenderFunction = this._renderLoop.bind(this), this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow())));
  }
  clear(e, t, i, s = !1) {
    const r = this.stencilStateComposer.useStencilGlobalOnly;
    this.stencilStateComposer.useStencilGlobalOnly = !0, this.applyStates(), this.stencilStateComposer.useStencilGlobalOnly = r;
    let n = 0;
    t && e && (this._gl.clearColor(e.r, e.g, e.b, e.a !== void 0 ? e.a : 1), n |= this._gl.COLOR_BUFFER_BIT), i && (this.useReverseDepthBuffer ? (this._depthCullingState.depthFunc = this._gl.GEQUAL, this._gl.clearDepth(0)) : this._gl.clearDepth(1), n |= this._gl.DEPTH_BUFFER_BIT), s && (this._gl.clearStencil(0), n |= this._gl.STENCIL_BUFFER_BIT), this._gl.clear(n);
  }
  _viewport(e, t, i, s) {
    (e !== this._viewportCached.x || t !== this._viewportCached.y || i !== this._viewportCached.z || s !== this._viewportCached.w) && (this._viewportCached.x = e, this._viewportCached.y = t, this._viewportCached.z = i, this._viewportCached.w = s, this._gl.viewport(e, t, i, s));
  }
  setViewport(e, t, i) {
    const s = t || this.getRenderWidth(), r = i || this.getRenderHeight(), n = e.x || 0, a = e.y || 0;
    this._cachedViewport = e, this._viewport(n * s, a * r, s * e.width, r * e.height);
  }
  beginFrame() {
  }
  endFrame() {
    this._badOS && this.flushFramebuffer(), this._frameId++;
  }
  resize(e = !1) {
    let t, i;
    if (this.adaptToDeviceRatio) {
      const s = Ne() && window.devicePixelRatio || 1, r = this._lastDevicePixelRatio / s;
      this._lastDevicePixelRatio = s, this._hardwareScalingLevel *= r;
    }
    Ne() ? (t = this._renderingCanvas ? this._renderingCanvas.clientWidth || this._renderingCanvas.width : window.innerWidth, i = this._renderingCanvas ? this._renderingCanvas.clientHeight || this._renderingCanvas.height : window.innerHeight) : (t = this._renderingCanvas ? this._renderingCanvas.width : 100, i = this._renderingCanvas ? this._renderingCanvas.height : 100), this.setSize(t / this._hardwareScalingLevel, i / this._hardwareScalingLevel, e);
  }
  setSize(e, t, i = !1) {
    return !this._renderingCanvas || (e = e | 0, t = t | 0, !i && this._renderingCanvas.width === e && this._renderingCanvas.height === t) ? !1 : (this._renderingCanvas.width = e, this._renderingCanvas.height = t, !0);
  }
  bindFramebuffer(e, t = 0, i, s, r, n = 0, a = 0) {
    var u, f, d, _, E;
    const o = e;
    this._currentRenderTarget && this.unBindFramebuffer(this._currentRenderTarget), this._currentRenderTarget = e, this._bindUnboundFramebuffer(o._MSAAFramebuffer ? o._MSAAFramebuffer : o._framebuffer);
    const h = this._gl;
    e.is2DArray ? h.framebufferTextureLayer(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, (u = e.texture._hardwareTexture) == null ? void 0 : u.underlyingResource, n, a) : e.isCube && h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_CUBE_MAP_POSITIVE_X + t, (f = e.texture._hardwareTexture) == null ? void 0 : f.underlyingResource, n);
    const l = e._depthStencilTexture;
    if (l) {
      const m = e._depthStencilTextureWithStencil ? h.DEPTH_STENCIL_ATTACHMENT : h.DEPTH_ATTACHMENT;
      e.is2DArray ? h.framebufferTextureLayer(h.FRAMEBUFFER, m, (d = l._hardwareTexture) == null ? void 0 : d.underlyingResource, n, a) : e.isCube ? h.framebufferTexture2D(h.FRAMEBUFFER, m, h.TEXTURE_CUBE_MAP_POSITIVE_X + t, (_ = l._hardwareTexture) == null ? void 0 : _.underlyingResource, n) : h.framebufferTexture2D(h.FRAMEBUFFER, m, h.TEXTURE_2D, (E = l._hardwareTexture) == null ? void 0 : E.underlyingResource, n);
    }
    this._cachedViewport && !r ? this.setViewport(this._cachedViewport, i, s) : (i || (i = e.width, n && (i = i / Math.pow(2, n))), s || (s = e.height, n && (s = s / Math.pow(2, n))), this._viewport(0, 0, i, s)), this.wipeCaches();
  }
  setState(e, t = 0, i, s = !1, r, n, a = 0) {
    var l, u;
    (this._depthCullingState.cull !== e || i) && (this._depthCullingState.cull = e);
    const o = (u = (l = this.cullBackFaces) != null ? l : r) == null || u ? this._gl.BACK : this._gl.FRONT;
    (this._depthCullingState.cullFace !== o || i) && (this._depthCullingState.cullFace = o), this.setZOffset(t), this.setZOffsetUnits(a);
    const h = s ? this._gl.CW : this._gl.CCW;
    (this._depthCullingState.frontFace !== h || i) && (this._depthCullingState.frontFace = h), this._stencilStateComposer.stencilMaterial = n;
  }
  getDepthBuffer() {
    return this._depthCullingState.depthTest;
  }
  setDepthBuffer(e) {
    this._depthCullingState.depthTest = e;
  }
  setZOffset(e) {
    this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -e : e;
  }
  getZOffset() {
    const e = this._depthCullingState.zOffset;
    return this.useReverseDepthBuffer ? -e : e;
  }
  setZOffsetUnits(e) {
    this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -e : e;
  }
  getZOffsetUnits() {
    const e = this._depthCullingState.zOffsetUnits;
    return this.useReverseDepthBuffer ? -e : e;
  }
  _bindUnboundFramebuffer(e) {
    this._currentFramebuffer !== e && (this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, e), this._currentFramebuffer = e);
  }
  _currentFrameBufferIsDefaultFrameBuffer() {
    return this._currentFramebuffer === null;
  }
  generateMipmaps(e) {
    this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0), this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  }
  unBindFramebuffer(e, t = !1, i) {
    var n;
    const s = e;
    this._currentRenderTarget = null;
    const r = this._gl;
    if (s._MSAAFramebuffer) {
      if (e.isMulti) {
        this.unBindMultiColorAttachmentFramebuffer(e, t, i);
        return;
      }
      r.bindFramebuffer(r.READ_FRAMEBUFFER, s._MSAAFramebuffer), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, s._framebuffer), r.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, r.COLOR_BUFFER_BIT, r.NEAREST);
    }
    ((n = e.texture) == null ? void 0 : n.generateMipMaps) && !t && !e.isCube && this.generateMipmaps(e.texture), i && (s._MSAAFramebuffer && this._bindUnboundFramebuffer(s._framebuffer), i()), this._bindUnboundFramebuffer(null);
  }
  flushFramebuffer() {
    this._gl.flush();
  }
  restoreDefaultFramebuffer() {
    this._currentRenderTarget ? this.unBindFramebuffer(this._currentRenderTarget) : this._bindUnboundFramebuffer(null), this._cachedViewport && this.setViewport(this._cachedViewport), this.wipeCaches();
  }
  _resetVertexBufferBinding() {
    this.bindArrayBuffer(null), this._cachedVertexBuffers = null;
  }
  createVertexBuffer(e) {
    return this._createVertexBuffer(e, this._gl.STATIC_DRAW);
  }
  _createVertexBuffer(e, t) {
    const i = this._gl.createBuffer();
    if (!i)
      throw new Error("Unable to create vertex buffer");
    const s = new yi(i);
    return this.bindArrayBuffer(s), e instanceof Array ? this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(e), t) : this._gl.bufferData(this._gl.ARRAY_BUFFER, e, t), this._resetVertexBufferBinding(), s.references = 1, s;
  }
  createDynamicVertexBuffer(e) {
    return this._createVertexBuffer(e, this._gl.DYNAMIC_DRAW);
  }
  _resetIndexBufferBinding() {
    this.bindIndexBuffer(null), this._cachedIndexBuffer = null;
  }
  createIndexBuffer(e, t) {
    const i = this._gl.createBuffer(), s = new yi(i);
    if (!i)
      throw new Error("Unable to create index buffer");
    this.bindIndexBuffer(s);
    const r = this._normalizeIndexData(e);
    return this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, r, t ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW), this._resetIndexBufferBinding(), s.references = 1, s.is32Bits = r.BYTES_PER_ELEMENT === 4, s;
  }
  _normalizeIndexData(e) {
    if (e.BYTES_PER_ELEMENT === 2)
      return e;
    if (this._caps.uintIndices) {
      if (e instanceof Uint32Array)
        return e;
      for (let i = 0; i < e.length; i++)
        if (e[i] >= 65535)
          return new Uint32Array(e);
      return new Uint16Array(e);
    }
    return new Uint16Array(e);
  }
  bindArrayBuffer(e) {
    this._vaoRecordInProgress || this._unbindVertexArrayObject(), this._bindBuffer(e, this._gl.ARRAY_BUFFER);
  }
  bindUniformBlock(e, t, i) {
    const s = e.program, r = this._gl.getUniformBlockIndex(s, t);
    this._gl.uniformBlockBinding(s, r, i);
  }
  bindIndexBuffer(e) {
    this._vaoRecordInProgress || this._unbindVertexArrayObject(), this._bindBuffer(e, this._gl.ELEMENT_ARRAY_BUFFER);
  }
  _bindBuffer(e, t) {
    (this._vaoRecordInProgress || this._currentBoundBuffer[t] !== e) && (this._gl.bindBuffer(t, e ? e.underlyingResource : null), this._currentBoundBuffer[t] = e);
  }
  updateArrayBuffer(e) {
    this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, e);
  }
  _vertexAttribPointer(e, t, i, s, r, n, a) {
    const o = this._currentBufferPointers[t];
    if (!o)
      return;
    let h = !1;
    o.active ? (o.buffer !== e && (o.buffer = e, h = !0), o.size !== i && (o.size = i, h = !0), o.type !== s && (o.type = s, h = !0), o.normalized !== r && (o.normalized = r, h = !0), o.stride !== n && (o.stride = n, h = !0), o.offset !== a && (o.offset = a, h = !0)) : (h = !0, o.active = !0, o.index = t, o.size = i, o.type = s, o.normalized = r, o.stride = n, o.offset = a, o.buffer = e), (h || this._vaoRecordInProgress) && (this.bindArrayBuffer(e), s === this._gl.UNSIGNED_INT || s === this._gl.INT ? this._gl.vertexAttribIPointer(t, i, s, n, a) : this._gl.vertexAttribPointer(t, i, s, r, n, a));
  }
  _bindIndexBufferWithCache(e) {
    e != null && this._cachedIndexBuffer !== e && (this._cachedIndexBuffer = e, this.bindIndexBuffer(e), this._uintIndicesCurrentlySet = e.is32Bits);
  }
  _bindVertexBuffersAttributes(e, t, i) {
    const s = t.getAttributesNames();
    this._vaoRecordInProgress || this._unbindVertexArrayObject(), this.unbindAllAttributes();
    for (let r = 0; r < s.length; r++) {
      const n = t.getAttributeLocation(r);
      if (n >= 0) {
        const a = s[r];
        let o = null;
        if (i && (o = i[a]), o || (o = e[a]), !o)
          continue;
        this._gl.enableVertexAttribArray(n), this._vaoRecordInProgress || (this._vertexAttribArraysEnabled[n] = !0);
        const h = o.getBuffer();
        h && (this._vertexAttribPointer(h, n, o.getSize(), o.type, o.normalized, o.byteStride, o.byteOffset), o.getIsInstanced() && (this._gl.vertexAttribDivisor(n, o.getInstanceDivisor()), this._vaoRecordInProgress || (this._currentInstanceLocations.push(n), this._currentInstanceBuffers.push(h))));
      }
    }
  }
  recordVertexArrayObject(e, t, i, s) {
    const r = this._gl.createVertexArray();
    if (!r)
      throw new Error("Unable to create VAO");
    return this._vaoRecordInProgress = !0, this._gl.bindVertexArray(r), this._mustWipeVertexAttributes = !0, this._bindVertexBuffersAttributes(e, i, s), this.bindIndexBuffer(t), this._vaoRecordInProgress = !1, this._gl.bindVertexArray(null), r;
  }
  bindVertexArrayObject(e, t) {
    this._cachedVertexArrayObject !== e && (this._cachedVertexArrayObject = e, this._gl.bindVertexArray(e), this._cachedVertexBuffers = null, this._cachedIndexBuffer = null, this._uintIndicesCurrentlySet = t != null && t.is32Bits, this._mustWipeVertexAttributes = !0);
  }
  bindBuffersDirectly(e, t, i, s, r) {
    if (this._cachedVertexBuffers !== e || this._cachedEffectForVertexBuffers !== r) {
      this._cachedVertexBuffers = e, this._cachedEffectForVertexBuffers = r;
      const n = r.getAttributesCount();
      this._unbindVertexArrayObject(), this.unbindAllAttributes();
      let a = 0;
      for (let o = 0; o < n; o++)
        if (o < i.length) {
          const h = r.getAttributeLocation(o);
          h >= 0 && (this._gl.enableVertexAttribArray(h), this._vertexAttribArraysEnabled[h] = !0, this._vertexAttribPointer(e, h, i[o], this._gl.FLOAT, !1, s, a)), a += i[o] * 4;
        }
    }
    this._bindIndexBufferWithCache(t);
  }
  _unbindVertexArrayObject() {
    !this._cachedVertexArrayObject || (this._cachedVertexArrayObject = null, this._gl.bindVertexArray(null));
  }
  bindBuffers(e, t, i, s) {
    (this._cachedVertexBuffers !== e || this._cachedEffectForVertexBuffers !== i) && (this._cachedVertexBuffers = e, this._cachedEffectForVertexBuffers = i, this._bindVertexBuffersAttributes(e, i, s)), this._bindIndexBufferWithCache(t);
  }
  unbindInstanceAttributes() {
    let e;
    for (let t = 0, i = this._currentInstanceLocations.length; t < i; t++) {
      const s = this._currentInstanceBuffers[t];
      e != s && s.references && (e = s, this.bindArrayBuffer(s));
      const r = this._currentInstanceLocations[t];
      this._gl.vertexAttribDivisor(r, 0);
    }
    this._currentInstanceBuffers.length = 0, this._currentInstanceLocations.length = 0;
  }
  releaseVertexArrayObject(e) {
    this._gl.deleteVertexArray(e);
  }
  _releaseBuffer(e) {
    return e.references--, e.references === 0 ? (this._deleteBuffer(e), !0) : !1;
  }
  _deleteBuffer(e) {
    this._gl.deleteBuffer(e.underlyingResource);
  }
  updateAndBindInstancesBuffer(e, t, i) {
    if (this.bindArrayBuffer(e), t && this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, t), i[0].index !== void 0)
      this.bindInstancesBuffer(e, i, !0);
    else
      for (let s = 0; s < 4; s++) {
        const r = i[s];
        this._vertexAttribArraysEnabled[r] || (this._gl.enableVertexAttribArray(r), this._vertexAttribArraysEnabled[r] = !0), this._vertexAttribPointer(e, r, 4, this._gl.FLOAT, !1, 64, s * 16), this._gl.vertexAttribDivisor(r, 1), this._currentInstanceLocations.push(r), this._currentInstanceBuffers.push(e);
      }
  }
  bindInstancesBuffer(e, t, i = !0) {
    this.bindArrayBuffer(e);
    let s = 0;
    if (i)
      for (let r = 0; r < t.length; r++)
        s += t[r].attributeSize * 4;
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      n.index === void 0 && (n.index = this._currentEffect.getAttributeLocationByName(n.attributeName)), !(n.index < 0) && (this._vertexAttribArraysEnabled[n.index] || (this._gl.enableVertexAttribArray(n.index), this._vertexAttribArraysEnabled[n.index] = !0), this._vertexAttribPointer(e, n.index, n.attributeSize, n.attributeType || this._gl.FLOAT, n.normalized || !1, s, n.offset), this._gl.vertexAttribDivisor(n.index, n.divisor === void 0 ? 1 : n.divisor), this._currentInstanceLocations.push(n.index), this._currentInstanceBuffers.push(e));
    }
  }
  disableInstanceAttributeByName(e) {
    if (!this._currentEffect)
      return;
    const t = this._currentEffect.getAttributeLocationByName(e);
    this.disableInstanceAttribute(t);
  }
  disableInstanceAttribute(e) {
    let t = !1, i;
    for (; (i = this._currentInstanceLocations.indexOf(e)) !== -1; )
      this._currentInstanceLocations.splice(i, 1), this._currentInstanceBuffers.splice(i, 1), t = !0, i = this._currentInstanceLocations.indexOf(e);
    t && (this._gl.vertexAttribDivisor(e, 0), this.disableAttributeByIndex(e));
  }
  disableAttributeByIndex(e) {
    this._gl.disableVertexAttribArray(e), this._vertexAttribArraysEnabled[e] = !1, this._currentBufferPointers[e].active = !1;
  }
  draw(e, t, i, s) {
    this.drawElementsType(e ? 0 : 1, t, i, s);
  }
  drawPointClouds(e, t, i) {
    this.drawArraysType(2, e, t, i);
  }
  drawUnIndexed(e, t, i, s) {
    this.drawArraysType(e ? 0 : 1, t, i, s);
  }
  drawElementsType(e, t, i, s) {
    this.applyStates(), this._reportDrawCall();
    const r = this._drawMode(e), n = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT, a = this._uintIndicesCurrentlySet ? 4 : 2;
    s ? this._gl.drawElementsInstanced(r, i, n, t * a, s) : this._gl.drawElements(r, i, n, t * a);
  }
  drawArraysType(e, t, i, s) {
    this.applyStates(), this._reportDrawCall();
    const r = this._drawMode(e);
    s ? this._gl.drawArraysInstanced(r, t, i, s) : this._gl.drawArrays(r, t, i);
  }
  _drawMode(e) {
    switch (e) {
      case 0:
        return this._gl.TRIANGLES;
      case 2:
        return this._gl.POINTS;
      case 1:
        return this._gl.LINES;
      case 3:
        return this._gl.POINTS;
      case 4:
        return this._gl.LINES;
      case 5:
        return this._gl.LINE_LOOP;
      case 6:
        return this._gl.LINE_STRIP;
      case 7:
        return this._gl.TRIANGLE_STRIP;
      case 8:
        return this._gl.TRIANGLE_FAN;
      default:
        return this._gl.TRIANGLES;
    }
  }
  _reportDrawCall() {
  }
  _releaseEffect(e) {
    if (this._compiledEffects[e._key]) {
      delete this._compiledEffects[e._key];
      const t = e.getPipelineContext();
      t && this._deletePipelineContext(t);
    }
  }
  _deletePipelineContext(e) {
    const t = e;
    t && t.program && (t.program.__SPECTOR_rebuildProgram = null, this._gl.deleteProgram(t.program));
  }
  _getGlobalDefines(e) {
    if (e) {
      this.isNDCHalfZRange ? e.IS_NDC_HALF_ZRANGE = "" : delete e.IS_NDC_HALF_ZRANGE, this.useReverseDepthBuffer ? e.USE_REVERSE_DEPTHBUFFER = "" : delete e.USE_REVERSE_DEPTHBUFFER, this.useExactSrgbConversions ? e.USE_EXACT_SRGB_CONVERSIONS = "" : delete e.USE_EXACT_SRGB_CONVERSIONS;
      return;
    } else {
      let t = "";
      return this.isNDCHalfZRange && (t += "#define IS_NDC_HALF_ZRANGE"), this.useReverseDepthBuffer && (t && (t += `
`), t += "#define USE_REVERSE_DEPTHBUFFER"), this.useExactSrgbConversions && (t && (t += `
`), t += "#define USE_EXACT_SRGB_CONVERSIONS"), t;
    }
  }
  createEffect(e, t, i, s, r, n, a, o, h, l = Ze.GLSL) {
    var T;
    const u = e.vertexElement || e.vertex || e.vertexToken || e.vertexSource || e, f = e.fragmentElement || e.fragment || e.fragmentToken || e.fragmentSource || e, d = this._getGlobalDefines();
    let _ = (T = r != null ? r : t.defines) != null ? T : "";
    d && (_ += d);
    const E = u + "+" + f + "@" + _;
    if (this._compiledEffects[E]) {
      const b = this._compiledEffects[E];
      return a && b.isReady() && a(b), b;
    }
    const m = new De(e, t, i, s, this, r, n, a, o, h, E, l);
    return this._compiledEffects[E] = m, m;
  }
  static _ConcatenateShader(e, t, i = "") {
    return i + (t ? t + `
` : "") + e;
  }
  _compileShader(e, t, i, s) {
    return this._compileRawShader(le._ConcatenateShader(e, i, s), t);
  }
  _compileRawShader(e, t) {
    const i = this._gl, s = i.createShader(t === "vertex" ? i.VERTEX_SHADER : i.FRAGMENT_SHADER);
    if (!s) {
      let r = i.NO_ERROR, n = i.NO_ERROR;
      for (; (n = i.getError()) !== i.NO_ERROR; )
        r = n;
      throw new Error(`Something went wrong while creating a gl ${t} shader object. gl error=${r}, gl isContextLost=${i.isContextLost()}, _contextWasLost=${this._contextWasLost}`);
    }
    return i.shaderSource(s, e), i.compileShader(s), s;
  }
  _getShaderSource(e) {
    return this._gl.getShaderSource(e);
  }
  createRawShaderProgram(e, t, i, s, r = null) {
    s = s || this._gl;
    const n = this._compileRawShader(t, "vertex"), a = this._compileRawShader(i, "fragment");
    return this._createShaderProgram(e, n, a, s, r);
  }
  createShaderProgram(e, t, i, s, r, n = null) {
    r = r || this._gl;
    const a = this._webGLVersion > 1 ? `#version 300 es
#define WEBGL2 
` : "", o = this._compileShader(t, "vertex", s, a), h = this._compileShader(i, "fragment", s, a);
    return this._createShaderProgram(e, o, h, r, n);
  }
  inlineShaderCode(e) {
    return e;
  }
  createPipelineContext(e) {
    const t = new jr();
    return t.engine = this, this._caps.parallelShaderCompile && (t.isParallelCompiled = !0), t;
  }
  createMaterialContext() {
  }
  createDrawContext() {
  }
  _createShaderProgram(e, t, i, s, r = null) {
    const n = s.createProgram();
    if (e.program = n, !n)
      throw new Error("Unable to create program");
    return s.attachShader(n, t), s.attachShader(n, i), s.linkProgram(n), e.context = s, e.vertexShader = t, e.fragmentShader = i, e.isParallelCompiled || this._finalizePipelineContext(e), n;
  }
  _finalizePipelineContext(e) {
    const t = e.context, i = e.vertexShader, s = e.fragmentShader, r = e.program;
    if (!t.getProgramParameter(r, t.LINK_STATUS)) {
      if (!this._gl.getShaderParameter(i, this._gl.COMPILE_STATUS)) {
        const o = this._gl.getShaderInfoLog(i);
        if (o)
          throw e.vertexCompilationError = o, new Error("VERTEX SHADER " + o);
      }
      if (!this._gl.getShaderParameter(s, this._gl.COMPILE_STATUS)) {
        const o = this._gl.getShaderInfoLog(s);
        if (o)
          throw e.fragmentCompilationError = o, new Error("FRAGMENT SHADER " + o);
      }
      const a = t.getProgramInfoLog(r);
      if (a)
        throw e.programLinkError = a, new Error(a);
    }
    if (this.validateShaderPrograms && (t.validateProgram(r), !t.getProgramParameter(r, t.VALIDATE_STATUS))) {
      const o = t.getProgramInfoLog(r);
      if (o)
        throw e.programValidationError = o, new Error(o);
    }
    t.deleteShader(i), t.deleteShader(s), e.vertexShader = void 0, e.fragmentShader = void 0, e.onCompiled && (e.onCompiled(), e.onCompiled = void 0);
  }
  _preparePipelineContext(e, t, i, s, r, n, a, o, h, l) {
    const u = e;
    s ? u.program = this.createRawShaderProgram(u, t, i, void 0, h) : u.program = this.createShaderProgram(u, t, i, o, void 0, h), u.program.__SPECTOR_rebuildProgram = a;
  }
  _isRenderingStateCompiled(e) {
    const t = e;
    return this._gl.getProgramParameter(t.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR) ? (this._finalizePipelineContext(t), !0) : !1;
  }
  _executeWhenRenderingStateIsCompiled(e, t) {
    const i = e;
    if (!i.isParallelCompiled) {
      t();
      return;
    }
    const s = i.onCompiled;
    s ? i.onCompiled = () => {
      s(), t();
    } : i.onCompiled = t;
  }
  getUniforms(e, t) {
    const i = new Array(), s = e;
    for (let r = 0; r < t.length; r++)
      i.push(this._gl.getUniformLocation(s.program, t[r]));
    return i;
  }
  getAttributes(e, t) {
    const i = [], s = e;
    for (let r = 0; r < t.length; r++)
      try {
        i.push(this._gl.getAttribLocation(s.program, t[r]));
      } catch {
        i.push(-1);
      }
    return i;
  }
  enableEffect(e) {
    e = e !== null && Oi.IsWrapper(e) ? e.effect : e, !(!e || e === this._currentEffect) && (this._stencilStateComposer.stencilMaterial = void 0, e = e, this.bindSamplers(e), this._currentEffect = e, e.onBind && e.onBind(e), e._onBindObservable && e._onBindObservable.notifyObservers(e));
  }
  setInt(e, t) {
    return e ? (this._gl.uniform1i(e, t), !0) : !1;
  }
  setInt2(e, t, i) {
    return e ? (this._gl.uniform2i(e, t, i), !0) : !1;
  }
  setInt3(e, t, i, s) {
    return e ? (this._gl.uniform3i(e, t, i, s), !0) : !1;
  }
  setInt4(e, t, i, s, r) {
    return e ? (this._gl.uniform4i(e, t, i, s, r), !0) : !1;
  }
  setIntArray(e, t) {
    return e ? (this._gl.uniform1iv(e, t), !0) : !1;
  }
  setIntArray2(e, t) {
    return !e || t.length % 2 !== 0 ? !1 : (this._gl.uniform2iv(e, t), !0);
  }
  setIntArray3(e, t) {
    return !e || t.length % 3 !== 0 ? !1 : (this._gl.uniform3iv(e, t), !0);
  }
  setIntArray4(e, t) {
    return !e || t.length % 4 !== 0 ? !1 : (this._gl.uniform4iv(e, t), !0);
  }
  setArray(e, t) {
    return !e || t.length < 1 ? !1 : (this._gl.uniform1fv(e, t), !0);
  }
  setArray2(e, t) {
    return !e || t.length % 2 !== 0 ? !1 : (this._gl.uniform2fv(e, t), !0);
  }
  setArray3(e, t) {
    return !e || t.length % 3 !== 0 ? !1 : (this._gl.uniform3fv(e, t), !0);
  }
  setArray4(e, t) {
    return !e || t.length % 4 !== 0 ? !1 : (this._gl.uniform4fv(e, t), !0);
  }
  setMatrices(e, t) {
    return e ? (this._gl.uniformMatrix4fv(e, !1, t), !0) : !1;
  }
  setMatrix3x3(e, t) {
    return e ? (this._gl.uniformMatrix3fv(e, !1, t), !0) : !1;
  }
  setMatrix2x2(e, t) {
    return e ? (this._gl.uniformMatrix2fv(e, !1, t), !0) : !1;
  }
  setFloat(e, t) {
    return e ? (this._gl.uniform1f(e, t), !0) : !1;
  }
  setFloat2(e, t, i) {
    return e ? (this._gl.uniform2f(e, t, i), !0) : !1;
  }
  setFloat3(e, t, i, s) {
    return e ? (this._gl.uniform3f(e, t, i, s), !0) : !1;
  }
  setFloat4(e, t, i, s, r) {
    return e ? (this._gl.uniform4f(e, t, i, s, r), !0) : !1;
  }
  applyStates() {
    if (this._depthCullingState.apply(this._gl), this._stencilStateComposer.apply(this._gl), this._alphaState.apply(this._gl), this._colorWriteChanged) {
      this._colorWriteChanged = !1;
      const e = this._colorWrite;
      this._gl.colorMask(e, e, e, e);
    }
  }
  setColorWrite(e) {
    e !== this._colorWrite && (this._colorWriteChanged = !0, this._colorWrite = e);
  }
  getColorWrite() {
    return this._colorWrite;
  }
  get depthCullingState() {
    return this._depthCullingState;
  }
  get alphaState() {
    return this._alphaState;
  }
  get stencilState() {
    return this._stencilState;
  }
  get stencilStateComposer() {
    return this._stencilStateComposer;
  }
  clearInternalTexturesCache() {
    this._internalTexturesCache.length = 0;
  }
  wipeCaches(e) {
    this.preventCacheWipeBetweenFrames && !e || (this._currentEffect = null, this._viewportCached.x = 0, this._viewportCached.y = 0, this._viewportCached.z = 0, this._viewportCached.w = 0, this._unbindVertexArrayObject(), e && (this._currentProgram = null, this.resetTextureCache(), this._stencilStateComposer.reset(), this._depthCullingState.reset(), this._depthCullingState.depthFunc = this._gl.LEQUAL, this._alphaState.reset(), this._alphaMode = 1, this._alphaEquation = 0, this._colorWrite = !0, this._colorWriteChanged = !0, this._unpackFlipYCached = null, this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE), this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0), this._mustWipeVertexAttributes = !0, this.unbindAllAttributes()), this._resetVertexBufferBinding(), this._cachedIndexBuffer = null, this._cachedEffectForVertexBuffers = null, this.bindIndexBuffer(null));
  }
  _getSamplingParameters(e, t) {
    const i = this._gl;
    let s = i.NEAREST, r = i.NEAREST;
    switch (e) {
      case 11:
        s = i.LINEAR, t ? r = i.LINEAR_MIPMAP_NEAREST : r = i.LINEAR;
        break;
      case 3:
        s = i.LINEAR, t ? r = i.LINEAR_MIPMAP_LINEAR : r = i.LINEAR;
        break;
      case 8:
        s = i.NEAREST, t ? r = i.NEAREST_MIPMAP_LINEAR : r = i.NEAREST;
        break;
      case 4:
        s = i.NEAREST, t ? r = i.NEAREST_MIPMAP_NEAREST : r = i.NEAREST;
        break;
      case 5:
        s = i.NEAREST, t ? r = i.LINEAR_MIPMAP_NEAREST : r = i.LINEAR;
        break;
      case 6:
        s = i.NEAREST, t ? r = i.LINEAR_MIPMAP_LINEAR : r = i.LINEAR;
        break;
      case 7:
        s = i.NEAREST, r = i.LINEAR;
        break;
      case 1:
        s = i.NEAREST, r = i.NEAREST;
        break;
      case 9:
        s = i.LINEAR, t ? r = i.NEAREST_MIPMAP_NEAREST : r = i.NEAREST;
        break;
      case 10:
        s = i.LINEAR, t ? r = i.NEAREST_MIPMAP_LINEAR : r = i.NEAREST;
        break;
      case 2:
        s = i.LINEAR, r = i.LINEAR;
        break;
      case 12:
        s = i.LINEAR, r = i.NEAREST;
        break;
    }
    return {
      min: r,
      mag: s
    };
  }
  _createTexture() {
    const e = this._gl.createTexture();
    if (!e)
      throw new Error("Unable to create texture");
    return e;
  }
  _createHardwareTexture() {
    return new pr(this._createTexture(), this._gl);
  }
  _createInternalTexture(e, t, i = !0, s = Le.Unknown) {
    const r = {};
    t !== void 0 && typeof t == "object" ? (r.generateMipMaps = t.generateMipMaps, r.type = t.type === void 0 ? 0 : t.type, r.samplingMode = t.samplingMode === void 0 ? 3 : t.samplingMode, r.format = t.format === void 0 ? 5 : t.format, r.useSRGBBuffer = t.useSRGBBuffer === void 0 ? !1 : t.useSRGBBuffer) : (r.generateMipMaps = t, r.type = 0, r.samplingMode = 3, r.format = 5, r.useSRGBBuffer = !1), r.useSRGBBuffer = r.useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU), (r.type === 1 && !this._caps.textureFloatLinearFiltering || r.type === 2 && !this._caps.textureHalfFloatLinearFiltering) && (r.samplingMode = 1), r.type === 1 && !this._caps.textureFloat && (r.type = 0, w.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE"));
    const n = this._gl, a = new kt(this, s);
    a._useSRGBBuffer = !!r.useSRGBBuffer;
    const o = e.width || e, h = e.height || e, l = e.layers || 0, u = this._getSamplingParameters(r.samplingMode, !!r.generateMipMaps), f = l !== 0 ? n.TEXTURE_2D_ARRAY : n.TEXTURE_2D, d = this._getRGBABufferInternalSizedFormat(r.type, r.format, r.useSRGBBuffer), _ = this._getInternalFormat(r.format), E = this._getWebGLTextureType(r.type);
    return this._bindTextureDirectly(f, a), l !== 0 ? (a.is2DArray = !0, n.texImage3D(f, 0, d, o, h, l, 0, _, E, null)) : n.texImage2D(f, 0, d, o, h, 0, _, E, null), n.texParameteri(f, n.TEXTURE_MAG_FILTER, u.mag), n.texParameteri(f, n.TEXTURE_MIN_FILTER, u.min), n.texParameteri(f, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(f, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), r.generateMipMaps && this._gl.generateMipmap(f), this._bindTextureDirectly(f, null), a.baseWidth = o, a.baseHeight = h, a.width = o, a.height = h, a.depth = l, a.isReady = !0, a.samples = 1, a.generateMipMaps = !!r.generateMipMaps, a.samplingMode = r.samplingMode, a.type = r.type, a.format = r.format, this._internalTexturesCache.push(a), a;
  }
  _getUseSRGBBuffer(e, t) {
    return e && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || t);
  }
  _createTextureBase(e, t, i, s, r = 3, n = null, a = null, o, h, l = null, u = null, f = null, d = null, _, E, m) {
    e = e || "";
    const T = e.substr(0, 5) === "data:", b = e.substr(0, 5) === "blob:", R = T && e.indexOf(";base64,") !== -1, y = u || new kt(this, Le.Url), P = e;
    this._transformTextureUrl && !R && !u && !l && (e = this._transformTextureUrl(e)), P !== e && (y._originalUrl = P);
    const v = e.lastIndexOf(".");
    let A = d || (v > -1 ? e.substring(v).toLowerCase() : ""), L = null;
    A.indexOf("?") > -1 && (A = A.split("?")[0]);
    for (const fe of le._TextureLoaders)
      if (fe.canLoad(A, _)) {
        L = fe;
        break;
      }
    s && s.addPendingData(y), y.url = e, y.generateMipMaps = !t, y.samplingMode = r, y.invertY = i, y._useSRGBBuffer = this._getUseSRGBBuffer(!!m, t), this._doNotHandleContextLost || (y._buffer = l);
    let ae = null;
    n && !u && (ae = y.onLoadedObservable.add(n)), u || this._internalTexturesCache.push(y);
    const be = (fe, ue) => {
      s && s.removePendingData(y), e === P ? (ae && y.onLoadedObservable.remove(ae), _e.UseFallbackTexture && this._createTextureBase(_e.FallbackTexture, t, y.invertY, s, r, null, a, o, h, l, y), fe = (fe || "Unknown error") + (_e.UseFallbackTexture ? " - Fallback texture was used" : ""), y.onErrorObservable.notifyObservers({ message: fe, exception: ue }), a && a(fe, ue)) : (w.Warn(`Failed to load ${e}, falling back to ${P}`), this._createTextureBase(P, t, y.invertY, s, r, n, a, o, h, l, y, f, d, _, E, m));
    };
    if (L) {
      const fe = (ue) => {
        L.loadData(ue, y, (ie, ye, Ce, He, ke, Ve) => {
          Ve ? be("TextureLoader failed to load data") : o(y, A, s, { width: ie, height: ye }, y.invertY, !Ce, He, () => (ke(), !1), r);
        }, E);
      };
      l ? l instanceof ArrayBuffer ? fe(new Uint8Array(l)) : ArrayBuffer.isView(l) ? fe(l) : a && a("Unable to load: only ArrayBuffer or ArrayBufferView is supported", null) : this._loadFile(e, (ue) => fe(new Uint8Array(ue)), void 0, s ? s.offlineProvider : void 0, !0, (ue, ie) => {
        be("Unable to load " + (ue && ue.responseURL, ie));
      });
    } else {
      const fe = (ue) => {
        b && !this._doNotHandleContextLost && (y._buffer = ue), o(y, A, s, ue, y.invertY, t, !1, h, r);
      };
      !T || R ? l && (typeof l.decoding == "string" || l.close) ? fe(l) : le._FileToolsLoadImage(e, fe, be, s ? s.offlineProvider : null, _, y.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0) : typeof l == "string" || l instanceof ArrayBuffer || ArrayBuffer.isView(l) || l instanceof Blob ? le._FileToolsLoadImage(l, fe, be, s ? s.offlineProvider : null, _, y.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0) : l && fe(l);
    }
    return y;
  }
  createTexture(e, t, i, s, r = 3, n = null, a = null, o = null, h = null, l = null, u = null, f, d, _, E) {
    return this._createTextureBase(e, t, i, s, r, n, a, this._prepareWebGLTexture.bind(this), (m, T, b, R, y, P) => {
      const v = this._gl, A = b.width === m && b.height === T, L = l ? this._getInternalFormat(l, y._useSRGBBuffer) : R === ".jpg" && !y._useSRGBBuffer ? v.RGB : y._useSRGBBuffer ? v.SRGB8_ALPHA8 : v.RGBA;
      let Q = l ? this._getInternalFormat(l) : R === ".jpg" && !y._useSRGBBuffer ? v.RGB : v.RGBA;
      if (y._useSRGBBuffer && this.webGLVersion === 1 && (Q = L), A)
        return v.texImage2D(v.TEXTURE_2D, 0, L, Q, v.UNSIGNED_BYTE, b), !1;
      const ae = this._caps.maxTextureSize;
      if (b.width > ae || b.height > ae || !this._supportsHardwareTextureRescaling)
        return this._prepareWorkingCanvas(), !this._workingCanvas || !this._workingContext || (this._workingCanvas.width = m, this._workingCanvas.height = T, this._workingContext.drawImage(b, 0, 0, b.width, b.height, 0, 0, m, T), v.texImage2D(v.TEXTURE_2D, 0, L, Q, v.UNSIGNED_BYTE, this._workingCanvas), y.width = m, y.height = T), !1;
      {
        const be = new kt(this, Le.Temp);
        this._bindTextureDirectly(v.TEXTURE_2D, be, !0), v.texImage2D(v.TEXTURE_2D, 0, L, Q, v.UNSIGNED_BYTE, b), this._rescaleTexture(be, y, s, L, () => {
          this._releaseTexture(be), this._bindTextureDirectly(v.TEXTURE_2D, y, !0), P();
        });
      }
      return !0;
    }, o, h, l, u, f, d, E);
  }
  static _FileToolsLoadImage(e, t, i, s, r, n) {
    throw q("FileTools");
  }
  _rescaleTexture(e, t, i, s, r) {
  }
  createRawTexture(e, t, i, s, r, n, a, o = null, h = 0, l = 0, u = !1) {
    throw q("Engine.RawTexture");
  }
  createRawCubeTexture(e, t, i, s, r, n, a, o = null) {
    throw q("Engine.RawTexture");
  }
  createRawTexture3D(e, t, i, s, r, n, a, o, h = null, l = 0) {
    throw q("Engine.RawTexture");
  }
  createRawTexture2DArray(e, t, i, s, r, n, a, o, h = null, l = 0) {
    throw q("Engine.RawTexture");
  }
  _unpackFlipY(e) {
    this._unpackFlipYCached !== e && (this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, e ? 1 : 0), this.enableUnpackFlipYCached && (this._unpackFlipYCached = e));
  }
  _getUnpackAlignement() {
    return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);
  }
  _getTextureTarget(e) {
    return e.isCube ? this._gl.TEXTURE_CUBE_MAP : e.is3D ? this._gl.TEXTURE_3D : e.is2DArray || e.isMultiview ? this._gl.TEXTURE_2D_ARRAY : this._gl.TEXTURE_2D;
  }
  updateTextureSamplingMode(e, t, i = !1) {
    const s = this._getTextureTarget(t), r = this._getSamplingParameters(e, t.generateMipMaps || i);
    this._setTextureParameterInteger(s, this._gl.TEXTURE_MAG_FILTER, r.mag, t), this._setTextureParameterInteger(s, this._gl.TEXTURE_MIN_FILTER, r.min), i && (t.generateMipMaps = !0, this._gl.generateMipmap(s)), this._bindTextureDirectly(s, null), t.samplingMode = e;
  }
  updateTextureDimensions(e, t, i, s = 1) {
  }
  updateTextureWrappingMode(e, t, i = null, s = null) {
    const r = this._getTextureTarget(e);
    t !== null && (this._setTextureParameterInteger(r, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t), e), e._cachedWrapU = t), i !== null && (this._setTextureParameterInteger(r, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(i), e), e._cachedWrapV = i), (e.is2DArray || e.is3D) && s !== null && (this._setTextureParameterInteger(r, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(s), e), e._cachedWrapR = s), this._bindTextureDirectly(r, null);
  }
  _setupDepthStencilTexture(e, t, i, s, r, n = 1) {
    const a = t.width || t, o = t.height || t, h = t.layers || 0;
    e.baseWidth = a, e.baseHeight = o, e.width = a, e.height = o, e.is2DArray = h > 0, e.depth = h, e.isReady = !0, e.samples = n, e.generateMipMaps = !1, e.samplingMode = s ? 2 : 1, e.type = 0, e._comparisonFunction = r;
    const l = this._gl, u = this._getTextureTarget(e), f = this._getSamplingParameters(e.samplingMode, !1);
    l.texParameteri(u, l.TEXTURE_MAG_FILTER, f.mag), l.texParameteri(u, l.TEXTURE_MIN_FILTER, f.min), l.texParameteri(u, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(u, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), this.webGLVersion > 1 && (r === 0 ? (l.texParameteri(u, l.TEXTURE_COMPARE_FUNC, 515), l.texParameteri(u, l.TEXTURE_COMPARE_MODE, l.NONE)) : (l.texParameteri(u, l.TEXTURE_COMPARE_FUNC, r), l.texParameteri(u, l.TEXTURE_COMPARE_MODE, l.COMPARE_REF_TO_TEXTURE)));
  }
  _uploadCompressedDataToTextureDirectly(e, t, i, s, r, n = 0, a = 0) {
    const o = this._gl;
    let h = o.TEXTURE_2D;
    if (e.isCube && (h = o.TEXTURE_CUBE_MAP_POSITIVE_X + n), e._useSRGBBuffer)
      switch (t) {
        case 37492:
        case 36196:
          this._caps.etc2 ? t = o.COMPRESSED_SRGB8_ETC2 : e._useSRGBBuffer = !1;
          break;
        case 37496:
          this._caps.etc2 ? t = o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : e._useSRGBBuffer = !1;
          break;
        case 36492:
          t = o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
          break;
        case 37808:
          t = o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
          break;
        case 33776:
          this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_S3TC_DXT1_EXT : e._useSRGBBuffer = !1;
          break;
        case 33777:
          this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT : e._useSRGBBuffer = !1;
          break;
        case 33779:
          this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT : e._useSRGBBuffer = !1;
          break;
        default:
          e._useSRGBBuffer = !1;
          break;
      }
    this._gl.compressedTexImage2D(h, a, t, i, s, 0, r);
  }
  _uploadDataToTextureDirectly(e, t, i = 0, s = 0, r, n = !1) {
    const a = this._gl, o = this._getWebGLTextureType(e.type), h = this._getInternalFormat(e.format), l = r === void 0 ? this._getRGBABufferInternalSizedFormat(e.type, e.format, e._useSRGBBuffer) : this._getInternalFormat(r, e._useSRGBBuffer);
    this._unpackFlipY(e.invertY);
    let u = a.TEXTURE_2D;
    e.isCube && (u = a.TEXTURE_CUBE_MAP_POSITIVE_X + i);
    const f = Math.round(Math.log(e.width) * Math.LOG2E), d = Math.round(Math.log(e.height) * Math.LOG2E), _ = n ? e.width : Math.pow(2, Math.max(f - s, 0)), E = n ? e.height : Math.pow(2, Math.max(d - s, 0));
    a.texImage2D(u, s, l, _, E, 0, h, o, t);
  }
  updateTextureData(e, t, i, s, r, n, a = 0, o = 0, h = !1) {
    const l = this._gl, u = this._getWebGLTextureType(e.type), f = this._getInternalFormat(e.format);
    this._unpackFlipY(e.invertY);
    let d = l.TEXTURE_2D;
    e.isCube && (d = l.TEXTURE_CUBE_MAP_POSITIVE_X + a), this._bindTextureDirectly(d, e, !0), l.texSubImage2D(d, o, i, s, r, n, f, u, t), h && this._gl.generateMipmap(d), this._bindTextureDirectly(d, null);
  }
  _uploadArrayBufferViewToTexture(e, t, i = 0, s = 0) {
    const r = this._gl, n = e.isCube ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D;
    this._bindTextureDirectly(n, e, !0), this._uploadDataToTextureDirectly(e, t, i, s), this._bindTextureDirectly(n, null, !0);
  }
  _prepareWebGLTextureContinuation(e, t, i, s, r) {
    const n = this._gl;
    if (!n)
      return;
    const a = this._getSamplingParameters(r, !i);
    n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, a.mag), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, a.min), !i && !s && n.generateMipmap(n.TEXTURE_2D), this._bindTextureDirectly(n.TEXTURE_2D, null), t && t.removePendingData(e), e.onLoadedObservable.notifyObservers(e), e.onLoadedObservable.clear();
  }
  _prepareWebGLTexture(e, t, i, s, r, n, a, o, h = 3) {
    const l = this.getCaps().maxTextureSize, u = Math.min(l, this.needPOTTextures ? le.GetExponentOfTwo(s.width, l) : s.width), f = Math.min(l, this.needPOTTextures ? le.GetExponentOfTwo(s.height, l) : s.height), d = this._gl;
    if (!!d) {
      if (!e._hardwareTexture) {
        i && i.removePendingData(e);
        return;
      }
      this._bindTextureDirectly(d.TEXTURE_2D, e, !0), this._unpackFlipY(r === void 0 ? !0 : !!r), e.baseWidth = s.width, e.baseHeight = s.height, e.width = u, e.height = f, e.isReady = !0, !o(u, f, s, t, e, () => {
        this._prepareWebGLTextureContinuation(e, i, n, a, h);
      }) && this._prepareWebGLTextureContinuation(e, i, n, a, h);
    }
  }
  _setupFramebufferDepthAttachments(e, t, i, s, r = 1) {
    const n = this._gl;
    if (e && t)
      return this._createRenderBuffer(i, s, r, n.DEPTH_STENCIL, n.DEPTH24_STENCIL8, n.DEPTH_STENCIL_ATTACHMENT);
    if (t) {
      let a = n.DEPTH_COMPONENT16;
      return this._webGLVersion > 1 && (a = n.DEPTH_COMPONENT32F), this._createRenderBuffer(i, s, r, a, a, n.DEPTH_ATTACHMENT);
    }
    return e ? this._createRenderBuffer(i, s, r, n.STENCIL_INDEX8, n.STENCIL_INDEX8, n.STENCIL_ATTACHMENT) : null;
  }
  _createRenderBuffer(e, t, i, s, r, n, a = !0) {
    const o = this._gl, h = o.createRenderbuffer();
    return o.bindRenderbuffer(o.RENDERBUFFER, h), i > 1 && o.renderbufferStorageMultisample ? o.renderbufferStorageMultisample(o.RENDERBUFFER, i, r, e, t) : o.renderbufferStorage(o.RENDERBUFFER, s, e, t), o.framebufferRenderbuffer(o.FRAMEBUFFER, n, o.RENDERBUFFER, h), a && o.bindRenderbuffer(o.RENDERBUFFER, null), h;
  }
  _releaseTexture(e) {
    var i;
    this._deleteTexture((i = e._hardwareTexture) == null ? void 0 : i.underlyingResource), this.unbindAllTextures();
    const t = this._internalTexturesCache.indexOf(e);
    t !== -1 && this._internalTexturesCache.splice(t, 1), e._lodTextureHigh && e._lodTextureHigh.dispose(), e._lodTextureMid && e._lodTextureMid.dispose(), e._lodTextureLow && e._lodTextureLow.dispose(), e._irradianceTexture && e._irradianceTexture.dispose();
  }
  _releaseRenderTargetWrapper(e) {
    const t = this._renderTargetWrapperCache.indexOf(e);
    t !== -1 && this._renderTargetWrapperCache.splice(t, 1);
  }
  _deleteTexture(e) {
    e && this._gl.deleteTexture(e);
  }
  _setProgram(e) {
    this._currentProgram !== e && (this._gl.useProgram(e), this._currentProgram = e);
  }
  bindSamplers(e) {
    const t = e.getPipelineContext();
    this._setProgram(t.program);
    const i = e.getSamplers();
    for (let s = 0; s < i.length; s++) {
      const r = e.getUniform(i[s]);
      r && (this._boundUniforms[s] = r);
    }
    this._currentEffect = null;
  }
  _activateCurrentTexture() {
    this._currentTextureChannel !== this._activeChannel && (this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel), this._currentTextureChannel = this._activeChannel);
  }
  _bindTextureDirectly(e, t, i = !1, s = !1) {
    var o, h;
    let r = !1;
    const n = t && t._associatedChannel > -1;
    if (i && n && (this._activeChannel = t._associatedChannel), this._boundTexturesCache[this._activeChannel] !== t || s) {
      if (this._activateCurrentTexture(), t && t.isMultiview)
        throw console.error(e, t), "_bindTextureDirectly called with a multiview texture!";
      this._gl.bindTexture(e, (h = (o = t == null ? void 0 : t._hardwareTexture) == null ? void 0 : o.underlyingResource) != null ? h : null), this._boundTexturesCache[this._activeChannel] = t, t && (t._associatedChannel = this._activeChannel);
    } else
      i && (r = !0, this._activateCurrentTexture());
    return n && !i && this._bindSamplerUniformToChannel(t._associatedChannel, this._activeChannel), r;
  }
  _bindTexture(e, t, i) {
    if (e === void 0)
      return;
    t && (t._associatedChannel = e), this._activeChannel = e;
    const s = t ? this._getTextureTarget(t) : this._gl.TEXTURE_2D;
    this._bindTextureDirectly(s, t);
  }
  unbindAllTextures() {
    for (let e = 0; e < this._maxSimultaneousTextures; e++)
      this._activeChannel = e, this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), this.webGLVersion > 1 && (this._bindTextureDirectly(this._gl.TEXTURE_3D, null), this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null));
  }
  setTexture(e, t, i, s) {
    e !== void 0 && (t && (this._boundUniforms[e] = t), this._setTexture(e, i));
  }
  _bindSamplerUniformToChannel(e, t) {
    const i = this._boundUniforms[e];
    !i || i._currentState === t || (this._gl.uniform1i(i, t), i._currentState = t);
  }
  _getTextureWrapMode(e) {
    switch (e) {
      case 1:
        return this._gl.REPEAT;
      case 0:
        return this._gl.CLAMP_TO_EDGE;
      case 2:
        return this._gl.MIRRORED_REPEAT;
    }
    return this._gl.REPEAT;
  }
  _setTexture(e, t, i = !1, s = !1, r = "") {
    if (!t)
      return this._boundTexturesCache[e] != null && (this._activeChannel = e, this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), this.webGLVersion > 1 && (this._bindTextureDirectly(this._gl.TEXTURE_3D, null), this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null))), !1;
    if (t.video)
      this._activeChannel = e, t.update();
    else if (t.delayLoadState === 4)
      return t.delayLoad(), !1;
    let n;
    s ? n = t.depthStencilTexture : t.isReady() ? n = t.getInternalTexture() : t.isCube ? n = this.emptyCubeTexture : t.is3D ? n = this.emptyTexture3D : t.is2DArray ? n = this.emptyTexture2DArray : n = this.emptyTexture, !i && n && (n._associatedChannel = e);
    let a = !0;
    this._boundTexturesCache[e] === n && (i || this._bindSamplerUniformToChannel(n._associatedChannel, e), a = !1), this._activeChannel = e;
    const o = this._getTextureTarget(n);
    if (a && this._bindTextureDirectly(o, n, i), n && !n.isMultiview) {
      if (n.isCube && n._cachedCoordinatesMode !== t.coordinatesMode) {
        n._cachedCoordinatesMode = t.coordinatesMode;
        const h = t.coordinatesMode !== 3 && t.coordinatesMode !== 5 ? 1 : 0;
        t.wrapU = h, t.wrapV = h;
      }
      n._cachedWrapU !== t.wrapU && (n._cachedWrapU = t.wrapU, this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t.wrapU), n)), n._cachedWrapV !== t.wrapV && (n._cachedWrapV = t.wrapV, this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(t.wrapV), n)), n.is3D && n._cachedWrapR !== t.wrapR && (n._cachedWrapR = t.wrapR, this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(t.wrapR), n)), this._setAnisotropicLevel(o, n, t.anisotropicFilteringLevel);
    }
    return !0;
  }
  setTextureArray(e, t, i, s) {
    if (!(e === void 0 || !t)) {
      (!this._textureUnits || this._textureUnits.length !== i.length) && (this._textureUnits = new Int32Array(i.length));
      for (let r = 0; r < i.length; r++) {
        const n = i[r].getInternalTexture();
        n ? (this._textureUnits[r] = e + r, n._associatedChannel = e + r) : this._textureUnits[r] = -1;
      }
      this._gl.uniform1iv(t, this._textureUnits);
      for (let r = 0; r < i.length; r++)
        this._setTexture(this._textureUnits[r], i[r], !0);
    }
  }
  _setAnisotropicLevel(e, t, i) {
    const s = this._caps.textureAnisotropicFilterExtension;
    t.samplingMode !== 11 && t.samplingMode !== 3 && t.samplingMode !== 2 && (i = 1), s && t._cachedAnisotropicFilteringLevel !== i && (this._setTextureParameterFloat(e, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i, this._caps.maxAnisotropy), t), t._cachedAnisotropicFilteringLevel = i);
  }
  _setTextureParameterFloat(e, t, i, s) {
    this._bindTextureDirectly(e, s, !0, !0), this._gl.texParameterf(e, t, i);
  }
  _setTextureParameterInteger(e, t, i, s) {
    s && this._bindTextureDirectly(e, s, !0, !0), this._gl.texParameteri(e, t, i);
  }
  unbindAllAttributes() {
    if (this._mustWipeVertexAttributes) {
      this._mustWipeVertexAttributes = !1;
      for (let e = 0; e < this._caps.maxVertexAttribs; e++)
        this.disableAttributeByIndex(e);
      return;
    }
    for (let e = 0, t = this._vertexAttribArraysEnabled.length; e < t; e++)
      e >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[e] || this.disableAttributeByIndex(e);
  }
  releaseEffects() {
    for (const e in this._compiledEffects) {
      const t = this._compiledEffects[e].getPipelineContext();
      this._deletePipelineContext(t);
    }
    this._compiledEffects = {};
  }
  dispose() {
    var e;
    this.stopRenderLoop(), this.onBeforeTextureInitObservable && this.onBeforeTextureInitObservable.clear(), this._emptyTexture && (this._releaseTexture(this._emptyTexture), this._emptyTexture = null), this._emptyCubeTexture && (this._releaseTexture(this._emptyCubeTexture), this._emptyCubeTexture = null), this._dummyFramebuffer && this._gl.deleteFramebuffer(this._dummyFramebuffer), this.releaseEffects(), (e = this.releaseComputeEffects) == null || e.call(this), this.unbindAllAttributes(), this._boundUniforms = {}, Ne() && this._renderingCanvas && (this._doNotHandleContextLost || (this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost), this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored)), window.removeEventListener("resize", this._checkForMobile)), this._workingCanvas = null, this._workingContext = null, this._currentBufferPointers.length = 0, this._renderingCanvas = null, this._currentProgram = null, this._boundRenderFunction = null, De.ResetCache();
    for (const t of this._activeRequests)
      t.abort();
    this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear();
  }
  attachContextLostEvent(e) {
    this._renderingCanvas && this._renderingCanvas.addEventListener("webglcontextlost", e, !1);
  }
  attachContextRestoredEvent(e) {
    this._renderingCanvas && this._renderingCanvas.addEventListener("webglcontextrestored", e, !1);
  }
  getError() {
    return this._gl.getError();
  }
  _canRenderToFloatFramebuffer() {
    return this._webGLVersion > 1 ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(1);
  }
  _canRenderToHalfFloatFramebuffer() {
    return this._webGLVersion > 1 ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(2);
  }
  _canRenderToFramebuffer(e) {
    const t = this._gl;
    for (; t.getError() !== t.NO_ERROR; )
      ;
    let i = !0;
    const s = t.createTexture();
    t.bindTexture(t.TEXTURE_2D, s), t.texImage2D(t.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(e), 1, 1, 0, t.RGBA, this._getWebGLTextureType(e), null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST);
    const r = t.createFramebuffer();
    t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, s, 0);
    const n = t.checkFramebufferStatus(t.FRAMEBUFFER);
    if (i = i && n === t.FRAMEBUFFER_COMPLETE, i = i && t.getError() === t.NO_ERROR, i && (t.clear(t.COLOR_BUFFER_BIT), i = i && t.getError() === t.NO_ERROR), i) {
      t.bindFramebuffer(t.FRAMEBUFFER, null);
      const a = t.RGBA, o = t.UNSIGNED_BYTE, h = new Uint8Array(4);
      t.readPixels(0, 0, 1, 1, a, o, h), i = i && t.getError() === t.NO_ERROR;
    }
    for (t.deleteTexture(s), t.deleteFramebuffer(r), t.bindFramebuffer(t.FRAMEBUFFER, null); !i && t.getError() !== t.NO_ERROR; )
      ;
    return i;
  }
  _getWebGLTextureType(e) {
    if (this._webGLVersion === 1) {
      switch (e) {
        case 1:
          return this._gl.FLOAT;
        case 2:
          return this._gl.HALF_FLOAT_OES;
        case 0:
          return this._gl.UNSIGNED_BYTE;
        case 8:
          return this._gl.UNSIGNED_SHORT_4_4_4_4;
        case 9:
          return this._gl.UNSIGNED_SHORT_5_5_5_1;
        case 10:
          return this._gl.UNSIGNED_SHORT_5_6_5;
      }
      return this._gl.UNSIGNED_BYTE;
    }
    switch (e) {
      case 3:
        return this._gl.BYTE;
      case 0:
        return this._gl.UNSIGNED_BYTE;
      case 4:
        return this._gl.SHORT;
      case 5:
        return this._gl.UNSIGNED_SHORT;
      case 6:
        return this._gl.INT;
      case 7:
        return this._gl.UNSIGNED_INT;
      case 1:
        return this._gl.FLOAT;
      case 2:
        return this._gl.HALF_FLOAT;
      case 8:
        return this._gl.UNSIGNED_SHORT_4_4_4_4;
      case 9:
        return this._gl.UNSIGNED_SHORT_5_5_5_1;
      case 10:
        return this._gl.UNSIGNED_SHORT_5_6_5;
      case 11:
        return this._gl.UNSIGNED_INT_2_10_10_10_REV;
      case 12:
        return this._gl.UNSIGNED_INT_24_8;
      case 13:
        return this._gl.UNSIGNED_INT_10F_11F_11F_REV;
      case 14:
        return this._gl.UNSIGNED_INT_5_9_9_9_REV;
      case 15:
        return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
    }
    return this._gl.UNSIGNED_BYTE;
  }
  _getInternalFormat(e, t = !1) {
    let i = t ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
    switch (e) {
      case 0:
        i = this._gl.ALPHA;
        break;
      case 1:
        i = this._gl.LUMINANCE;
        break;
      case 2:
        i = this._gl.LUMINANCE_ALPHA;
        break;
      case 6:
        i = this._gl.RED;
        break;
      case 7:
        i = this._gl.RG;
        break;
      case 4:
        i = t ? this._gl.SRGB : this._gl.RGB;
        break;
      case 5:
        i = t ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
        break;
    }
    if (this._webGLVersion > 1)
      switch (e) {
        case 8:
          i = this._gl.RED_INTEGER;
          break;
        case 9:
          i = this._gl.RG_INTEGER;
          break;
        case 10:
          i = this._gl.RGB_INTEGER;
          break;
        case 11:
          i = this._gl.RGBA_INTEGER;
          break;
      }
    return i;
  }
  _getRGBABufferInternalSizedFormat(e, t, i = !1) {
    if (this._webGLVersion === 1) {
      if (t !== void 0)
        switch (t) {
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          case 4:
            return i ? this._gl.SRGB : this._gl.RGB;
        }
      return this._gl.RGBA;
    }
    switch (e) {
      case 3:
        switch (t) {
          case 6:
            return this._gl.R8_SNORM;
          case 7:
            return this._gl.RG8_SNORM;
          case 4:
            return this._gl.RGB8_SNORM;
          case 8:
            return this._gl.R8I;
          case 9:
            return this._gl.RG8I;
          case 10:
            return this._gl.RGB8I;
          case 11:
            return this._gl.RGBA8I;
          default:
            return this._gl.RGBA8_SNORM;
        }
      case 0:
        switch (t) {
          case 6:
            return this._gl.R8;
          case 7:
            return this._gl.RG8;
          case 4:
            return i ? this._gl.SRGB8 : this._gl.RGB8;
          case 5:
            return i ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
          case 8:
            return this._gl.R8UI;
          case 9:
            return this._gl.RG8UI;
          case 10:
            return this._gl.RGB8UI;
          case 11:
            return this._gl.RGBA8UI;
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          default:
            return this._gl.RGBA8;
        }
      case 4:
        switch (t) {
          case 8:
            return this._gl.R16I;
          case 9:
            return this._gl.RG16I;
          case 10:
            return this._gl.RGB16I;
          case 11:
            return this._gl.RGBA16I;
          default:
            return this._gl.RGBA16I;
        }
      case 5:
        switch (t) {
          case 8:
            return this._gl.R16UI;
          case 9:
            return this._gl.RG16UI;
          case 10:
            return this._gl.RGB16UI;
          case 11:
            return this._gl.RGBA16UI;
          default:
            return this._gl.RGBA16UI;
        }
      case 6:
        switch (t) {
          case 8:
            return this._gl.R32I;
          case 9:
            return this._gl.RG32I;
          case 10:
            return this._gl.RGB32I;
          case 11:
            return this._gl.RGBA32I;
          default:
            return this._gl.RGBA32I;
        }
      case 7:
        switch (t) {
          case 8:
            return this._gl.R32UI;
          case 9:
            return this._gl.RG32UI;
          case 10:
            return this._gl.RGB32UI;
          case 11:
            return this._gl.RGBA32UI;
          default:
            return this._gl.RGBA32UI;
        }
      case 1:
        switch (t) {
          case 6:
            return this._gl.R32F;
          case 7:
            return this._gl.RG32F;
          case 4:
            return this._gl.RGB32F;
          case 5:
            return this._gl.RGBA32F;
          default:
            return this._gl.RGBA32F;
        }
      case 2:
        switch (t) {
          case 6:
            return this._gl.R16F;
          case 7:
            return this._gl.RG16F;
          case 4:
            return this._gl.RGB16F;
          case 5:
            return this._gl.RGBA16F;
          default:
            return this._gl.RGBA16F;
        }
      case 10:
        return this._gl.RGB565;
      case 13:
        return this._gl.R11F_G11F_B10F;
      case 14:
        return this._gl.RGB9_E5;
      case 8:
        return this._gl.RGBA4;
      case 9:
        return this._gl.RGB5_A1;
      case 11:
        switch (t) {
          case 5:
            return this._gl.RGB10_A2;
          case 11:
            return this._gl.RGB10_A2UI;
          default:
            return this._gl.RGB10_A2;
        }
    }
    return i ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
  }
  _getRGBAMultiSampleBufferFormat(e) {
    return e === 1 ? this._gl.RGBA32F : e === 2 ? this._gl.RGBA16F : this._gl.RGBA8;
  }
  _loadFile(e, t, i, s, r, n) {
    const a = le._FileToolsLoadFile(e, t, i, s, r, n);
    return this._activeRequests.push(a), a.onCompleteObservable.add((o) => {
      this._activeRequests.splice(this._activeRequests.indexOf(o), 1);
    }), a;
  }
  static _FileToolsLoadFile(e, t, i, s, r, n) {
    throw q("FileTools");
  }
  readPixels(e, t, i, s, r = !0, n = !0) {
    const a = r ? 4 : 3, o = r ? this._gl.RGBA : this._gl.RGB, h = new Uint8Array(s * i * a);
    return n && this.flushFramebuffer(), this._gl.readPixels(e, t, i, s, o, this._gl.UNSIGNED_BYTE, h), Promise.resolve(h);
  }
  static get IsSupportedAsync() {
    return Promise.resolve(this.isSupported());
  }
  static get IsSupported() {
    return this.isSupported();
  }
  static isSupported() {
    if (this._HasMajorPerformanceCaveat !== null)
      return !this._HasMajorPerformanceCaveat;
    if (this._IsSupported === null)
      try {
        const e = this._CreateCanvas(1, 1), t = e.getContext("webgl") || e.getContext("experimental-webgl");
        this._IsSupported = t != null && !!window.WebGLRenderingContext;
      } catch {
        this._IsSupported = !1;
      }
    return this._IsSupported;
  }
  static get HasMajorPerformanceCaveat() {
    if (this._HasMajorPerformanceCaveat === null)
      try {
        const e = this._CreateCanvas(1, 1), t = e.getContext("webgl", { failIfMajorPerformanceCaveat: !0 }) || e.getContext("experimental-webgl", { failIfMajorPerformanceCaveat: !0 });
        this._HasMajorPerformanceCaveat = !t;
      } catch {
        this._HasMajorPerformanceCaveat = !1;
      }
    return this._HasMajorPerformanceCaveat;
  }
  static CeilingPOT(e) {
    return e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, e++, e;
  }
  static FloorPOT(e) {
    return e = e | e >> 1, e = e | e >> 2, e = e | e >> 4, e = e | e >> 8, e = e | e >> 16, e - (e >> 1);
  }
  static NearestPOT(e) {
    const t = le.CeilingPOT(e), i = le.FloorPOT(e);
    return t - e > e - i ? i : t;
  }
  static GetExponentOfTwo(e, t, i = 2) {
    let s;
    switch (i) {
      case 1:
        s = le.FloorPOT(e);
        break;
      case 2:
        s = le.NearestPOT(e);
        break;
      case 3:
      default:
        s = le.CeilingPOT(e);
        break;
    }
    return Math.min(s, t);
  }
  static QueueNewFrame(e, t) {
    return Ne() ? (t || (t = window), t.requestPostAnimationFrame ? t.requestPostAnimationFrame(e) : t.requestAnimationFrame ? t.requestAnimationFrame(e) : t.msRequestAnimationFrame ? t.msRequestAnimationFrame(e) : t.webkitRequestAnimationFrame ? t.webkitRequestAnimationFrame(e) : t.mozRequestAnimationFrame ? t.mozRequestAnimationFrame(e) : t.oRequestAnimationFrame ? t.oRequestAnimationFrame(e) : window.setTimeout(e, 16)) : typeof requestAnimationFrame < "u" ? requestAnimationFrame(e) : setTimeout(e, 16);
  }
  getHostDocument() {
    return this._renderingCanvas && this._renderingCanvas.ownerDocument ? this._renderingCanvas.ownerDocument : Hi() ? document : null;
  }
}
le.ExceptionList = [
  { key: "Chrome/63.0", capture: "63\\.0\\.3239\\.(\\d+)", captureConstraint: 108, targets: ["uniformBuffer"] },
  { key: "Firefox/58", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
  { key: "Firefox/59", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
  { key: "Chrome/72.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Chrome/73.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Chrome/74.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Mac OS.+Chrome/71", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Mac OS.+Chrome/72", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Mac OS.+Chrome", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
  { key: ".*AppleWebKit.*(15.4).*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] },
  { key: ".*(15.4).*AppleWebKit.*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] }
];
le._TextureLoaders = [];
le.CollisionsEpsilon = 1e-3;
le._IsSupported = null;
le._HasMajorPerformanceCaveat = null;
class mi {
  static get Now() {
    return ys.IsWindowObjectExist() && window.performance && window.performance.now ? window.performance.now() : Date.now();
  }
}
class Jr {
  constructor(e = 30) {
    this._enabled = !0, this._rollingFrameTime = new en(e);
  }
  sampleFrame(e = mi.Now) {
    if (!!this._enabled) {
      if (this._lastFrameTimeMs != null) {
        const t = e - this._lastFrameTimeMs;
        this._rollingFrameTime.add(t);
      }
      this._lastFrameTimeMs = e;
    }
  }
  get averageFrameTime() {
    return this._rollingFrameTime.average;
  }
  get averageFrameTimeVariance() {
    return this._rollingFrameTime.variance;
  }
  get instantaneousFrameTime() {
    return this._rollingFrameTime.history(0);
  }
  get averageFPS() {
    return 1e3 / this._rollingFrameTime.average;
  }
  get instantaneousFPS() {
    const e = this._rollingFrameTime.history(0);
    return e === 0 ? 0 : 1e3 / e;
  }
  get isSaturated() {
    return this._rollingFrameTime.isSaturated();
  }
  enable() {
    this._enabled = !0;
  }
  disable() {
    this._enabled = !1, this._lastFrameTimeMs = null;
  }
  get isEnabled() {
    return this._enabled;
  }
  reset() {
    this._lastFrameTimeMs = null, this._rollingFrameTime.reset();
  }
}
class en {
  constructor(e) {
    this._samples = new Array(e), this.reset();
  }
  add(e) {
    let t;
    if (this.isSaturated()) {
      const i = this._samples[this._pos];
      t = i - this.average, this.average -= t / (this._sampleCount - 1), this._m2 -= t * (i - this.average);
    } else
      this._sampleCount++;
    t = e - this.average, this.average += t / this._sampleCount, this._m2 += t * (e - this.average), this.variance = this._m2 / (this._sampleCount - 1), this._samples[this._pos] = e, this._pos++, this._pos %= this._samples.length;
  }
  history(e) {
    if (e >= this._sampleCount || e >= this._samples.length)
      return 0;
    const t = this._wrapPosition(this._pos - 1);
    return this._samples[this._wrapPosition(t - e)];
  }
  isSaturated() {
    return this._sampleCount >= this._samples.length;
  }
  reset() {
    this.average = 0, this.variance = 0, this._sampleCount = 0, this._pos = 0, this._m2 = 0;
  }
  _wrapPosition(e) {
    const t = this._samples.length;
    return (e % t + t) % t;
  }
}
class yt {
  constructor() {
    this._startMonitoringTime = 0, this._min = 0, this._max = 0, this._average = 0, this._lastSecAverage = 0, this._current = 0, this._totalValueCount = 0, this._totalAccumulated = 0, this._lastSecAccumulated = 0, this._lastSecTime = 0, this._lastSecValueCount = 0;
  }
  get min() {
    return this._min;
  }
  get max() {
    return this._max;
  }
  get average() {
    return this._average;
  }
  get lastSecAverage() {
    return this._lastSecAverage;
  }
  get current() {
    return this._current;
  }
  get total() {
    return this._totalAccumulated;
  }
  get count() {
    return this._totalValueCount;
  }
  fetchNewFrame() {
    this._totalValueCount++, this._current = 0, this._lastSecValueCount++;
  }
  addCount(e, t) {
    !yt.Enabled || (this._current += e, t && this._fetchResult());
  }
  beginMonitoring() {
    !yt.Enabled || (this._startMonitoringTime = mi.Now);
  }
  endMonitoring(e = !0) {
    if (!yt.Enabled)
      return;
    e && this.fetchNewFrame();
    const t = mi.Now;
    this._current = t - this._startMonitoringTime, e && this._fetchResult();
  }
  _fetchResult() {
    this._totalAccumulated += this._current, this._lastSecAccumulated += this._current, this._min = Math.min(this._min, this._current), this._max = Math.max(this._max, this._current), this._average = this._totalAccumulated / this._totalValueCount;
    const e = mi.Now;
    e - this._lastSecTime > 1e3 && (this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount, this._lastSecTime = e, this._lastSecAccumulated = 0, this._lastSecValueCount = 0);
  }
}
yt.Enabled = !0;
le.prototype.setAlphaConstants = function(c, e, t, i) {
  this._alphaState.setAlphaBlendConstants(c, e, t, i);
};
le.prototype.setAlphaMode = function(c, e = !1) {
  if (this._alphaMode !== c) {
    switch (c) {
      case 0:
        this._alphaState.alphaBlend = !1;
        break;
      case 7:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 8:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 2:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 6:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 1:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 3:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 4:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 5:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 9:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 10:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 11:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 12:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO), this._alphaState.alphaBlend = !0;
        break;
      case 13:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 14:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 15:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO), this._alphaState.alphaBlend = !0;
        break;
      case 16:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 17:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
    }
    e || (this.depthCullingState.depthMask = c === 0), this._alphaMode = c;
  }
};
le.prototype.getAlphaMode = function() {
  return this._alphaMode;
};
le.prototype.setAlphaEquation = function(c) {
  if (this._alphaEquation !== c) {
    switch (c) {
      case 0:
        this._alphaState.setAlphaEquationParameters(32774, 32774);
        break;
      case 1:
        this._alphaState.setAlphaEquationParameters(32778, 32778);
        break;
      case 2:
        this._alphaState.setAlphaEquationParameters(32779, 32779);
        break;
      case 3:
        this._alphaState.setAlphaEquationParameters(32776, 32776);
        break;
      case 4:
        this._alphaState.setAlphaEquationParameters(32775, 32775);
        break;
      case 5:
        this._alphaState.setAlphaEquationParameters(32775, 32774);
        break;
    }
    this._alphaEquation = c;
  }
};
le.prototype.getAlphaEquation = function() {
  return this._alphaEquation;
};
function tn(c, e, t = !1, i) {
  switch (c) {
    case 3: {
      const r = e instanceof ArrayBuffer ? new Int8Array(e) : new Int8Array(e);
      return i && r.set(new Int8Array(i)), r;
    }
    case 0: {
      const r = e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e);
      return i && r.set(new Uint8Array(i)), r;
    }
    case 4: {
      const r = e instanceof ArrayBuffer ? new Int16Array(e) : new Int16Array(t ? e / 2 : e);
      return i && r.set(new Int16Array(i)), r;
    }
    case 5:
    case 8:
    case 9:
    case 10:
    case 2: {
      const r = e instanceof ArrayBuffer ? new Uint16Array(e) : new Uint16Array(t ? e / 2 : e);
      return i && r.set(new Uint16Array(i)), r;
    }
    case 6: {
      const r = e instanceof ArrayBuffer ? new Int32Array(e) : new Int32Array(t ? e / 4 : e);
      return i && r.set(new Int32Array(i)), r;
    }
    case 7:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15: {
      const r = e instanceof ArrayBuffer ? new Uint32Array(e) : new Uint32Array(t ? e / 4 : e);
      return i && r.set(new Uint32Array(i)), r;
    }
    case 1: {
      const r = e instanceof ArrayBuffer ? new Float32Array(e) : new Float32Array(t ? e / 4 : e);
      return i && r.set(new Float32Array(i)), r;
    }
  }
  const s = e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e);
  return i && s.set(new Uint8Array(i)), s;
}
le.prototype._readTexturePixelsSync = function(c, e, t, i = -1, s = 0, r = null, n = !0, a = !1, o = 0, h = 0) {
  var f, d;
  const l = this._gl;
  if (!l)
    throw new Error("Engine does not have gl rendering context.");
  if (!this._dummyFramebuffer) {
    const _ = l.createFramebuffer();
    if (!_)
      throw new Error("Unable to create dummy framebuffer");
    this._dummyFramebuffer = _;
  }
  l.bindFramebuffer(l.FRAMEBUFFER, this._dummyFramebuffer), i > -1 ? l.framebufferTexture2D(l.FRAMEBUFFER, l.COLOR_ATTACHMENT0, l.TEXTURE_CUBE_MAP_POSITIVE_X + i, (f = c._hardwareTexture) == null ? void 0 : f.underlyingResource, s) : l.framebufferTexture2D(l.FRAMEBUFFER, l.COLOR_ATTACHMENT0, l.TEXTURE_2D, (d = c._hardwareTexture) == null ? void 0 : d.underlyingResource, s);
  let u = c.type !== void 0 ? this._getWebGLTextureType(c.type) : l.UNSIGNED_BYTE;
  if (a)
    r || (r = tn(c.type, 4 * e * t));
  else
    switch (u) {
      case l.UNSIGNED_BYTE:
        r || (r = new Uint8Array(4 * e * t)), u = l.UNSIGNED_BYTE;
        break;
      default:
        r || (r = new Float32Array(4 * e * t)), u = l.FLOAT;
        break;
    }
  return n && this.flushFramebuffer(), l.readPixels(o, h, e, t, l.RGBA, u, r), l.bindFramebuffer(l.FRAMEBUFFER, this._currentFramebuffer), r;
};
le.prototype._readTexturePixels = function(c, e, t, i = -1, s = 0, r = null, n = !0, a = !1, o = 0, h = 0) {
  return Promise.resolve(this._readTexturePixelsSync(c, e, t, i, s, r, n, a, o, h));
};
le.prototype.updateDynamicIndexBuffer = function(c, e, t = 0) {
  this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null, this.bindIndexBuffer(c);
  let i;
  c.is32Bits ? i = e instanceof Uint32Array ? e : new Uint32Array(e) : i = e instanceof Uint16Array ? e : new Uint16Array(e), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, i, this._gl.DYNAMIC_DRAW), this._resetIndexBufferBinding();
};
le.prototype.updateDynamicVertexBuffer = function(c, e, t, i) {
  this.bindArrayBuffer(c), t === void 0 && (t = 0);
  const s = e.byteLength || e.length;
  i === void 0 || i >= s && t === 0 ? e instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, t, new Float32Array(e)) : this._gl.bufferSubData(this._gl.ARRAY_BUFFER, t, e) : e instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(e).subarray(t, t + i)) : (e instanceof ArrayBuffer ? e = new Uint8Array(e, t, i) : e = new Uint8Array(e.buffer, e.byteOffset + t, i), this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, e)), this._resetVertexBufferBinding();
};
class C extends le {
  constructor(e, t, i, s = !1) {
    if (super(e, t, i, s), this.enableOfflineSupport = !1, this.disableManifestCheck = !1, this.disableContextMenu = !0, this.scenes = new Array(), this._virtualScenes = new Array(), this.onNewSceneAddedObservable = new F(), this.postProcesses = new Array(), this.isPointerLock = !1, this.onResizeObservable = new F(), this.onCanvasBlurObservable = new F(), this.onCanvasFocusObservable = new F(), this.onCanvasPointerOutObservable = new F(), this.onBeginFrameObservable = new F(), this.customAnimationFrameRequester = null, this.onEndFrameObservable = new F(), this.onBeforeShaderCompilationObservable = new F(), this.onAfterShaderCompilationObservable = new F(), this._deterministicLockstep = !1, this._lockstepMaxSteps = 4, this._timeStep = 1 / 60, this._fps = 60, this._deltaTime = 0, this._drawCalls = new yt(), this.canvasTabIndex = 1, this.disablePerformanceMonitorInBackground = !1, this._performanceMonitor = new Jr(), this._compatibilityMode = !0, this.currentRenderPassId = 0, this._renderPassNames = ["main"], C.Instances.push(this), !!e) {
      if (this._features.supportRenderPasses = !0, i = this._creationOptions, e.getContext) {
        const r = e;
        if (this._sharedInit(r, !!i.doNotHandleTouchAction, i.audioEngine), Ne()) {
          const n = document;
          this._onFullscreenChange = () => {
            n.fullscreen !== void 0 ? this.isFullscreen = n.fullscreen : n.mozFullScreen !== void 0 ? this.isFullscreen = n.mozFullScreen : n.webkitIsFullScreen !== void 0 ? this.isFullscreen = n.webkitIsFullScreen : n.msIsFullScreen !== void 0 && (this.isFullscreen = n.msIsFullScreen), this.isFullscreen && this._pointerLockRequested && r && C._RequestPointerlock(r);
          }, document.addEventListener("fullscreenchange", this._onFullscreenChange, !1), document.addEventListener("mozfullscreenchange", this._onFullscreenChange, !1), document.addEventListener("webkitfullscreenchange", this._onFullscreenChange, !1), document.addEventListener("msfullscreenchange", this._onFullscreenChange, !1), this._onPointerLockChange = () => {
            this.isPointerLock = n.mozPointerLockElement === r || n.webkitPointerLockElement === r || n.msPointerLockElement === r || n.pointerLockElement === r;
          }, document.addEventListener("pointerlockchange", this._onPointerLockChange, !1), document.addEventListener("mspointerlockchange", this._onPointerLockChange, !1), document.addEventListener("mozpointerlockchange", this._onPointerLockChange, !1), document.addEventListener("webkitpointerlockchange", this._onPointerLockChange, !1), !C.audioEngine && i.audioEngine && C.AudioEngineFactory && (C.audioEngine = C.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination()));
        }
        this._connectVREvents(), this.enableOfflineSupport = C.OfflineProviderFactory !== void 0, this._deterministicLockstep = !!i.deterministicLockstep, this._lockstepMaxSteps = i.lockstepMaxSteps || 0, this._timeStep = i.timeStep || 1 / 60;
      }
      this._prepareVRComponent(), i.autoEnableWebVR && this.initWebVR();
    }
  }
  static get NpmPackage() {
    return le.NpmPackage;
  }
  static get Version() {
    return le.Version;
  }
  static get Instances() {
    return _e.Instances;
  }
  static get LastCreatedEngine() {
    return _e.LastCreatedEngine;
  }
  static get LastCreatedScene() {
    return _e.LastCreatedScene;
  }
  _createImageBitmapFromSource(e, t) {
    return new Promise((s, r) => {
      const n = new Image();
      n.onload = () => {
        n.decode().then(() => {
          this.createImageBitmap(n, t).then((a) => {
            s(a);
          });
        });
      }, n.onerror = () => {
        r(`Error loading image ${n.src}`);
      }, n.src = e;
    });
  }
  createImageBitmap(e, t) {
    return createImageBitmap(e, t);
  }
  resizeImageBitmap(e, t, i) {
    const r = this.createCanvas(t, i).getContext("2d");
    if (!r)
      throw new Error("Unable to get 2d context for resizeImageBitmap");
    return r.drawImage(e, 0, 0), r.getImageData(0, 0, t, i).data;
  }
  static MarkAllMaterialsAsDirty(e, t) {
    for (let i = 0; i < C.Instances.length; i++) {
      const s = C.Instances[i];
      for (let r = 0; r < s.scenes.length; r++)
        s.scenes[r].markAllMaterialsAsDirty(e, t);
    }
  }
  static DefaultLoadingScreenFactory(e) {
    throw q("LoadingScreen");
  }
  get _supportsHardwareTextureRescaling() {
    return !!C._RescalePostProcessFactory;
  }
  get performanceMonitor() {
    return this._performanceMonitor;
  }
  get compatibilityMode() {
    return this._compatibilityMode;
  }
  set compatibilityMode(e) {
    this._compatibilityMode = !0;
  }
  getInputElement() {
    return this._renderingCanvas;
  }
  _sharedInit(e, t, i) {
    if (super._sharedInit(e, t, i), this._onCanvasFocus = () => {
      this.onCanvasFocusObservable.notifyObservers(this);
    }, this._onCanvasBlur = () => {
      this.onCanvasBlurObservable.notifyObservers(this);
    }, this._onCanvasContextMenu = (s) => {
      this.disableContextMenu && s.preventDefault();
    }, e.addEventListener("focus", this._onCanvasFocus), e.addEventListener("blur", this._onCanvasBlur), e.addEventListener("contextmenu", this._onCanvasContextMenu), this._onBlur = () => {
      this.disablePerformanceMonitorInBackground && this._performanceMonitor.disable(), this._windowIsBackground = !0;
    }, this._onFocus = () => {
      this.disablePerformanceMonitorInBackground && this._performanceMonitor.enable(), this._windowIsBackground = !1;
    }, this._onCanvasPointerOut = (s) => {
      document.elementFromPoint(s.clientX, s.clientY) !== e && this.onCanvasPointerOutObservable.notifyObservers(s);
    }, Ne()) {
      const s = this.getHostWindow();
      s && (s.addEventListener("blur", this._onBlur), s.addEventListener("focus", this._onFocus));
    }
    e.addEventListener("pointerout", this._onCanvasPointerOut), t || this._disableTouchAction(), !C.audioEngine && i && C.AudioEngineFactory && (C.audioEngine = C.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination()));
  }
  getAspectRatio(e, t = !1) {
    const i = e.viewport;
    return this.getRenderWidth(t) * i.width / (this.getRenderHeight(t) * i.height);
  }
  getScreenAspectRatio() {
    return this.getRenderWidth(!0) / this.getRenderHeight(!0);
  }
  getRenderingCanvasClientRect() {
    return this._renderingCanvas ? this._renderingCanvas.getBoundingClientRect() : null;
  }
  getInputElementClientRect() {
    return this._renderingCanvas ? this.getInputElement().getBoundingClientRect() : null;
  }
  isDeterministicLockStep() {
    return this._deterministicLockstep;
  }
  getLockstepMaxSteps() {
    return this._lockstepMaxSteps;
  }
  getTimeStep() {
    return this._timeStep * 1e3;
  }
  generateMipMapsForCubemap(e, t = !0) {
    if (e.generateMipMaps) {
      const i = this._gl;
      this._bindTextureDirectly(i.TEXTURE_CUBE_MAP, e, !0), i.generateMipmap(i.TEXTURE_CUBE_MAP), t && this._bindTextureDirectly(i.TEXTURE_CUBE_MAP, null);
    }
  }
  getDepthWrite() {
    return this._depthCullingState.depthMask;
  }
  setDepthWrite(e) {
    this._depthCullingState.depthMask = e;
  }
  getStencilBuffer() {
    return this._stencilState.stencilTest;
  }
  setStencilBuffer(e) {
    this._stencilState.stencilTest = e;
  }
  getStencilMask() {
    return this._stencilState.stencilMask;
  }
  setStencilMask(e) {
    this._stencilState.stencilMask = e;
  }
  getStencilFunction() {
    return this._stencilState.stencilFunc;
  }
  getStencilFunctionReference() {
    return this._stencilState.stencilFuncRef;
  }
  getStencilFunctionMask() {
    return this._stencilState.stencilFuncMask;
  }
  setStencilFunction(e) {
    this._stencilState.stencilFunc = e;
  }
  setStencilFunctionReference(e) {
    this._stencilState.stencilFuncRef = e;
  }
  setStencilFunctionMask(e) {
    this._stencilState.stencilFuncMask = e;
  }
  getStencilOperationFail() {
    return this._stencilState.stencilOpStencilFail;
  }
  getStencilOperationDepthFail() {
    return this._stencilState.stencilOpDepthFail;
  }
  getStencilOperationPass() {
    return this._stencilState.stencilOpStencilDepthPass;
  }
  setStencilOperationFail(e) {
    this._stencilState.stencilOpStencilFail = e;
  }
  setStencilOperationDepthFail(e) {
    this._stencilState.stencilOpDepthFail = e;
  }
  setStencilOperationPass(e) {
    this._stencilState.stencilOpStencilDepthPass = e;
  }
  setDitheringState(e) {
    e ? this._gl.enable(this._gl.DITHER) : this._gl.disable(this._gl.DITHER);
  }
  setRasterizerState(e) {
    e ? this._gl.disable(this._gl.RASTERIZER_DISCARD) : this._gl.enable(this._gl.RASTERIZER_DISCARD);
  }
  getDepthFunction() {
    return this._depthCullingState.depthFunc;
  }
  setDepthFunction(e) {
    this._depthCullingState.depthFunc = e;
  }
  setDepthFunctionToGreater() {
    this.setDepthFunction(516);
  }
  setDepthFunctionToGreaterOrEqual() {
    this.setDepthFunction(518);
  }
  setDepthFunctionToLess() {
    this.setDepthFunction(513);
  }
  setDepthFunctionToLessOrEqual() {
    this.setDepthFunction(515);
  }
  cacheStencilState() {
    this._cachedStencilBuffer = this.getStencilBuffer(), this._cachedStencilFunction = this.getStencilFunction(), this._cachedStencilMask = this.getStencilMask(), this._cachedStencilOperationPass = this.getStencilOperationPass(), this._cachedStencilOperationFail = this.getStencilOperationFail(), this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail(), this._cachedStencilReference = this.getStencilFunctionReference();
  }
  restoreStencilState() {
    this.setStencilFunction(this._cachedStencilFunction), this.setStencilMask(this._cachedStencilMask), this.setStencilBuffer(this._cachedStencilBuffer), this.setStencilOperationPass(this._cachedStencilOperationPass), this.setStencilOperationFail(this._cachedStencilOperationFail), this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail), this.setStencilFunctionReference(this._cachedStencilReference);
  }
  setDirectViewport(e, t, i, s) {
    const r = this._cachedViewport;
    return this._cachedViewport = null, this._viewport(e, t, i, s), r;
  }
  scissorClear(e, t, i, s, r) {
    this.enableScissor(e, t, i, s), this.clear(r, !0, !0, !0), this.disableScissor();
  }
  enableScissor(e, t, i, s) {
    const r = this._gl;
    r.enable(r.SCISSOR_TEST), r.scissor(e, t, i, s);
  }
  disableScissor() {
    const e = this._gl;
    e.disable(e.SCISSOR_TEST);
  }
  _reportDrawCall(e = 1) {
    this._drawCalls.addCount(e, !1);
  }
  initWebVR() {
    throw q("WebVRCamera");
  }
  _prepareVRComponent() {
  }
  _connectVREvents(e, t) {
  }
  _submitVRFrame() {
  }
  disableVR() {
  }
  isVRPresenting() {
    return !1;
  }
  _requestVRFrame() {
  }
  _loadFileAsync(e, t, i) {
    return new Promise((s, r) => {
      this._loadFile(e, (n) => {
        s(n);
      }, void 0, t, i, (n, a) => {
        r(a);
      });
    });
  }
  getVertexShaderSource(e) {
    const t = this._gl.getAttachedShaders(e);
    return t ? this._gl.getShaderSource(t[0]) : null;
  }
  getFragmentShaderSource(e) {
    const t = this._gl.getAttachedShaders(e);
    return t ? this._gl.getShaderSource(t[1]) : null;
  }
  setDepthStencilTexture(e, t, i, s) {
    e !== void 0 && (t && (this._boundUniforms[e] = t), !i || !i.depthStencilTexture ? this._setTexture(e, null, void 0, void 0, s) : this._setTexture(e, i, !1, !0, s));
  }
  setTextureFromPostProcess(e, t, i) {
    var r;
    let s = null;
    t && (t._textures.data[t._currentRenderTextureInd] ? s = t._textures.data[t._currentRenderTextureInd] : t._forcedOutputTexture && (s = t._forcedOutputTexture)), this._bindTexture(e, (r = s == null ? void 0 : s.texture) != null ? r : null, i);
  }
  setTextureFromPostProcessOutput(e, t, i) {
    var s, r;
    this._bindTexture(e, (r = (s = t == null ? void 0 : t._outputTexture) == null ? void 0 : s.texture) != null ? r : null, i);
  }
  _rebuildBuffers() {
    for (const e of this.scenes)
      e.resetCachedMaterial(), e._rebuildGeometries(), e._rebuildTextures();
    for (const e of this._virtualScenes)
      e.resetCachedMaterial(), e._rebuildGeometries(), e._rebuildTextures();
    super._rebuildBuffers();
  }
  _renderFrame() {
    for (let e = 0; e < this._activeRenderLoops.length; e++) {
      const t = this._activeRenderLoops[e];
      t();
    }
  }
  _renderLoop() {
    if (!this._contextWasLost) {
      let e = !0;
      !this.renderEvenInBackground && this._windowIsBackground && (e = !1), e && (this.beginFrame(), this._renderViews() || this._renderFrame(), this.endFrame());
    }
    this._activeRenderLoops.length > 0 ? this.customAnimationFrameRequester ? (this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester), this._frameHandler = this.customAnimationFrameRequester.requestID) : this.isVRPresenting() ? this._requestVRFrame() : this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow()) : this._renderingQueueLaunched = !1;
  }
  _renderViews() {
    return !1;
  }
  switchFullscreen(e) {
    this.isFullscreen ? this.exitFullscreen() : this.enterFullscreen(e);
  }
  enterFullscreen(e) {
    this.isFullscreen || (this._pointerLockRequested = e, this._renderingCanvas && C._RequestFullscreen(this._renderingCanvas));
  }
  exitFullscreen() {
    this.isFullscreen && C._ExitFullscreen();
  }
  enterPointerlock() {
    this._renderingCanvas && C._RequestPointerlock(this._renderingCanvas);
  }
  exitPointerlock() {
    C._ExitPointerlock();
  }
  beginFrame() {
    this._measureFps(), this.onBeginFrameObservable.notifyObservers(this), super.beginFrame();
  }
  endFrame() {
    super.endFrame(), this._submitVRFrame(), this.onEndFrameObservable.notifyObservers(this);
  }
  resize(e = !1) {
    this.isVRPresenting() || super.resize(e);
  }
  setSize(e, t, i = !1) {
    if (!this._renderingCanvas || !super.setSize(e, t, i))
      return !1;
    if (this.scenes) {
      for (let s = 0; s < this.scenes.length; s++) {
        const r = this.scenes[s];
        for (let n = 0; n < r.cameras.length; n++) {
          const a = r.cameras[n];
          a._currentRenderId = 0;
        }
      }
      this.onResizeObservable.hasObservers() && this.onResizeObservable.notifyObservers(this);
    }
    return !0;
  }
  _deletePipelineContext(e) {
    const t = e;
    t && t.program && t.transformFeedback && (this.deleteTransformFeedback(t.transformFeedback), t.transformFeedback = null), super._deletePipelineContext(e);
  }
  createShaderProgram(e, t, i, s, r, n = null) {
    r = r || this._gl, this.onBeforeShaderCompilationObservable.notifyObservers(this);
    const a = super.createShaderProgram(e, t, i, s, r, n);
    return this.onAfterShaderCompilationObservable.notifyObservers(this), a;
  }
  _createShaderProgram(e, t, i, s, r = null) {
    const n = s.createProgram();
    if (e.program = n, !n)
      throw new Error("Unable to create program");
    if (s.attachShader(n, t), s.attachShader(n, i), this.webGLVersion > 1 && r) {
      const a = this.createTransformFeedback();
      this.bindTransformFeedback(a), this.setTranformFeedbackVaryings(n, r), e.transformFeedback = a;
    }
    return s.linkProgram(n), this.webGLVersion > 1 && r && this.bindTransformFeedback(null), e.context = s, e.vertexShader = t, e.fragmentShader = i, e.isParallelCompiled || this._finalizePipelineContext(e), n;
  }
  _releaseTexture(e) {
    super._releaseTexture(e);
  }
  _releaseRenderTargetWrapper(e) {
    super._releaseRenderTargetWrapper(e), this.scenes.forEach((t) => {
      t.postProcesses.forEach((i) => {
        i._outputTexture === e && (i._outputTexture = null);
      }), t.cameras.forEach((i) => {
        i._postProcesses.forEach((s) => {
          s && s._outputTexture === e && (s._outputTexture = null);
        });
      });
    });
  }
  getRenderPassNames() {
    return this._renderPassNames;
  }
  getCurrentRenderPassName() {
    return this._renderPassNames[this.currentRenderPassId];
  }
  createRenderPassId(e) {
    const t = ++C._RenderPassIdCounter;
    return this._renderPassNames[t] = e != null ? e : "NONAME", t;
  }
  releaseRenderPassId(e) {
    this._renderPassNames[e] = void 0;
    for (let t = 0; t < this.scenes.length; ++t) {
      const i = this.scenes[t];
      for (let s = 0; s < i.meshes.length; ++s) {
        const r = i.meshes[s];
        if (r.subMeshes)
          for (let n = 0; n < r.subMeshes.length; ++n)
            r.subMeshes[n]._removeDrawWrapper(e);
      }
    }
  }
  _rescaleTexture(e, t, i, s, r) {
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
    const n = this.createRenderTargetTexture({
      width: t.width,
      height: t.height
    }, {
      generateMipMaps: !1,
      type: 0,
      samplingMode: 2,
      generateDepthBuffer: !1,
      generateStencilBuffer: !1
    });
    !this._rescalePostProcess && C._RescalePostProcessFactory && (this._rescalePostProcess = C._RescalePostProcessFactory(this)), this._rescalePostProcess.externalTextureSamplerBinding = !0, this._rescalePostProcess.getEffect().executeWhenCompiled(() => {
      this._rescalePostProcess.onApply = function(o) {
        o._bindTexture("textureSampler", e);
      };
      let a = i;
      a || (a = this.scenes[this.scenes.length - 1]), a.postProcessManager.directRender([this._rescalePostProcess], n, !0), this._bindTextureDirectly(this._gl.TEXTURE_2D, t, !0), this._gl.copyTexImage2D(this._gl.TEXTURE_2D, 0, s, 0, 0, t.width, t.height, 0), this.unBindFramebuffer(n), n.dispose(), r && r();
    });
  }
  getFps() {
    return this._fps;
  }
  getDeltaTime() {
    return this._deltaTime;
  }
  _measureFps() {
    this._performanceMonitor.sampleFrame(), this._fps = this._performanceMonitor.averageFPS, this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
  }
  wrapWebGLTexture(e) {
    const t = new pr(e, this._gl), i = new kt(this, Le.Unknown, !0);
    return i._hardwareTexture = t, i.isReady = !0, i;
  }
  _uploadImageToTexture(e, t, i = 0, s = 0) {
    const r = this._gl, n = this._getWebGLTextureType(e.type), a = this._getInternalFormat(e.format), o = this._getRGBABufferInternalSizedFormat(e.type, a), h = e.isCube ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D;
    this._bindTextureDirectly(h, e, !0), this._unpackFlipY(e.invertY);
    let l = r.TEXTURE_2D;
    e.isCube && (l = r.TEXTURE_CUBE_MAP_POSITIVE_X + i), r.texImage2D(l, s, o, a, n, t), this._bindTextureDirectly(h, null, !0);
  }
  updateTextureComparisonFunction(e, t) {
    if (this.webGLVersion === 1) {
      w.Error("WebGL 1 does not support texture comparison.");
      return;
    }
    const i = this._gl;
    e.isCube ? (this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, e, !0), t === 0 ? (i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_FUNC, 515), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_MODE, i.NONE)) : (i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_FUNC, t), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE)), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null)) : (this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0), t === 0 ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_FUNC, 515), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_MODE, i.NONE)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_FUNC, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE)), this._bindTextureDirectly(this._gl.TEXTURE_2D, null)), e._comparisonFunction = t;
  }
  createInstancesBuffer(e) {
    const t = this._gl.createBuffer();
    if (!t)
      throw new Error("Unable to create instance buffer");
    const i = new yi(t);
    return i.capacity = e, this.bindArrayBuffer(i), this._gl.bufferData(this._gl.ARRAY_BUFFER, e, this._gl.DYNAMIC_DRAW), i.references = 1, i;
  }
  deleteInstancesBuffer(e) {
    this._gl.deleteBuffer(e);
  }
  _clientWaitAsync(e, t = 0, i = 10) {
    const s = this._gl;
    return new Promise((r, n) => {
      const a = () => {
        const o = s.clientWaitSync(e, t, 0);
        if (o == s.WAIT_FAILED) {
          n();
          return;
        }
        if (o == s.TIMEOUT_EXPIRED) {
          setTimeout(a, i);
          return;
        }
        r();
      };
      a();
    });
  }
  _readPixelsAsync(e, t, i, s, r, n, a) {
    if (this._webGLVersion < 2)
      throw new Error("_readPixelsAsync only work on WebGL2+");
    const o = this._gl, h = o.createBuffer();
    o.bindBuffer(o.PIXEL_PACK_BUFFER, h), o.bufferData(o.PIXEL_PACK_BUFFER, a.byteLength, o.STREAM_READ), o.readPixels(e, t, i, s, r, n, 0), o.bindBuffer(o.PIXEL_PACK_BUFFER, null);
    const l = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
    return l ? (o.flush(), this._clientWaitAsync(l, 0, 10).then(() => (o.deleteSync(l), o.bindBuffer(o.PIXEL_PACK_BUFFER, h), o.getBufferSubData(o.PIXEL_PACK_BUFFER, 0, a), o.bindBuffer(o.PIXEL_PACK_BUFFER, null), o.deleteBuffer(h), a))) : null;
  }
  dispose() {
    for (this.hideLoadingUI(), this.onNewSceneAddedObservable.clear(); this.postProcesses.length; )
      this.postProcesses[0].dispose();
    for (this._rescalePostProcess && this._rescalePostProcess.dispose(); this.scenes.length; )
      this.scenes[0].dispose();
    for (; this._virtualScenes.length; )
      this._virtualScenes[0].dispose();
    C.Instances.length === 1 && C.audioEngine && (C.audioEngine.dispose(), C.audioEngine = null), this.disableVR(), Ne() && (window.removeEventListener("blur", this._onBlur), window.removeEventListener("focus", this._onFocus), this._renderingCanvas && (this._renderingCanvas.removeEventListener("focus", this._onCanvasFocus), this._renderingCanvas.removeEventListener("blur", this._onCanvasBlur), this._renderingCanvas.removeEventListener("pointerout", this._onCanvasPointerOut), this._renderingCanvas.removeEventListener("contextmenu", this._onCanvasContextMenu)), Hi() && (document.removeEventListener("fullscreenchange", this._onFullscreenChange), document.removeEventListener("mozfullscreenchange", this._onFullscreenChange), document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange), document.removeEventListener("msfullscreenchange", this._onFullscreenChange), document.removeEventListener("pointerlockchange", this._onPointerLockChange), document.removeEventListener("mspointerlockchange", this._onPointerLockChange), document.removeEventListener("mozpointerlockchange", this._onPointerLockChange), document.removeEventListener("webkitpointerlockchange", this._onPointerLockChange))), super.dispose();
    const e = C.Instances.indexOf(this);
    e >= 0 && C.Instances.splice(e, 1), this.onResizeObservable.clear(), this.onCanvasBlurObservable.clear(), this.onCanvasFocusObservable.clear(), this.onCanvasPointerOutObservable.clear(), this.onBeginFrameObservable.clear(), this.onEndFrameObservable.clear();
  }
  _disableTouchAction() {
    !this._renderingCanvas || !this._renderingCanvas.setAttribute || (this._renderingCanvas.setAttribute("touch-action", "none"), this._renderingCanvas.style.touchAction = "none", this._renderingCanvas.style.msTouchAction = "none", this._renderingCanvas.style.webkitTapHighlightColor = "transparent");
  }
  displayLoadingUI() {
    if (!Ne())
      return;
    const e = this.loadingScreen;
    e && e.displayLoadingUI();
  }
  hideLoadingUI() {
    if (!Ne())
      return;
    const e = this._loadingScreen;
    e && e.hideLoadingUI();
  }
  get loadingScreen() {
    return !this._loadingScreen && this._renderingCanvas && (this._loadingScreen = C.DefaultLoadingScreenFactory(this._renderingCanvas)), this._loadingScreen;
  }
  set loadingScreen(e) {
    this._loadingScreen = e;
  }
  set loadingUIText(e) {
    this.loadingScreen.loadingUIText = e;
  }
  set loadingUIBackgroundColor(e) {
    this.loadingScreen.loadingUIBackgroundColor = e;
  }
  createVideoElement(e) {
    return document.createElement("video");
  }
  static _RequestPointerlock(e) {
    e.requestPointerLock = e.requestPointerLock || e.msRequestPointerLock || e.mozRequestPointerLock || e.webkitRequestPointerLock, e.requestPointerLock && (e.requestPointerLock(), e.focus());
  }
  static _ExitPointerlock() {
    const e = document;
    document.exitPointerLock = document.exitPointerLock || e.msExitPointerLock || e.mozExitPointerLock || e.webkitExitPointerLock, document.exitPointerLock && document.exitPointerLock();
  }
  static _RequestFullscreen(e) {
    const t = e.requestFullscreen || e.msRequestFullscreen || e.webkitRequestFullscreen || e.mozRequestFullScreen;
    !t || t.call(e);
  }
  static _ExitFullscreen() {
    const e = document;
    document.exitFullscreen ? document.exitFullscreen() : e.mozCancelFullScreen ? e.mozCancelFullScreen() : e.webkitCancelFullScreen ? e.webkitCancelFullScreen() : e.msCancelFullScreen && e.msCancelFullScreen();
  }
  getFontOffset(e) {
    const t = document.createElement("span");
    t.innerHTML = "Hg", t.setAttribute("style", `font: ${e} !important`);
    const i = document.createElement("div");
    i.style.display = "inline-block", i.style.width = "1px", i.style.height = "0px", i.style.verticalAlign = "bottom";
    const s = document.createElement("div");
    s.style.whiteSpace = "nowrap", s.appendChild(t), s.appendChild(i), document.body.appendChild(s);
    let r = 0, n = 0;
    try {
      n = i.getBoundingClientRect().top - t.getBoundingClientRect().top, i.style.verticalAlign = "baseline", r = i.getBoundingClientRect().top - t.getBoundingClientRect().top;
    } finally {
      document.body.removeChild(s);
    }
    return { ascent: r, height: n, descent: n - r };
  }
}
C.ALPHA_DISABLE = 0;
C.ALPHA_ADD = 1;
C.ALPHA_COMBINE = 2;
C.ALPHA_SUBTRACT = 3;
C.ALPHA_MULTIPLY = 4;
C.ALPHA_MAXIMIZED = 5;
C.ALPHA_ONEONE = 6;
C.ALPHA_PREMULTIPLIED = 7;
C.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
C.ALPHA_INTERPOLATE = 9;
C.ALPHA_SCREENMODE = 10;
C.DELAYLOADSTATE_NONE = 0;
C.DELAYLOADSTATE_LOADED = 1;
C.DELAYLOADSTATE_LOADING = 2;
C.DELAYLOADSTATE_NOTLOADED = 4;
C.NEVER = 512;
C.ALWAYS = 519;
C.LESS = 513;
C.EQUAL = 514;
C.LEQUAL = 515;
C.GREATER = 516;
C.GEQUAL = 518;
C.NOTEQUAL = 517;
C.KEEP = 7680;
C.REPLACE = 7681;
C.INCR = 7682;
C.DECR = 7683;
C.INVERT = 5386;
C.INCR_WRAP = 34055;
C.DECR_WRAP = 34056;
C.TEXTURE_CLAMP_ADDRESSMODE = 0;
C.TEXTURE_WRAP_ADDRESSMODE = 1;
C.TEXTURE_MIRROR_ADDRESSMODE = 2;
C.TEXTUREFORMAT_ALPHA = 0;
C.TEXTUREFORMAT_LUMINANCE = 1;
C.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
C.TEXTUREFORMAT_RGB = 4;
C.TEXTUREFORMAT_RGBA = 5;
C.TEXTUREFORMAT_RED = 6;
C.TEXTUREFORMAT_R = 6;
C.TEXTUREFORMAT_RG = 7;
C.TEXTUREFORMAT_RED_INTEGER = 8;
C.TEXTUREFORMAT_R_INTEGER = 8;
C.TEXTUREFORMAT_RG_INTEGER = 9;
C.TEXTUREFORMAT_RGB_INTEGER = 10;
C.TEXTUREFORMAT_RGBA_INTEGER = 11;
C.TEXTURETYPE_UNSIGNED_BYTE = 0;
C.TEXTURETYPE_UNSIGNED_INT = 0;
C.TEXTURETYPE_FLOAT = 1;
C.TEXTURETYPE_HALF_FLOAT = 2;
C.TEXTURETYPE_BYTE = 3;
C.TEXTURETYPE_SHORT = 4;
C.TEXTURETYPE_UNSIGNED_SHORT = 5;
C.TEXTURETYPE_INT = 6;
C.TEXTURETYPE_UNSIGNED_INTEGER = 7;
C.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
C.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
C.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
C.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
C.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
C.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
C.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
C.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
C.TEXTURE_NEAREST_SAMPLINGMODE = 1;
C.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
C.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
C.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
C.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
C.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
C.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
C.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
C.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
C.TEXTURE_NEAREST_LINEAR = 7;
C.TEXTURE_NEAREST_NEAREST = 1;
C.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
C.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
C.TEXTURE_LINEAR_LINEAR = 2;
C.TEXTURE_LINEAR_NEAREST = 12;
C.TEXTURE_EXPLICIT_MODE = 0;
C.TEXTURE_SPHERICAL_MODE = 1;
C.TEXTURE_PLANAR_MODE = 2;
C.TEXTURE_CUBIC_MODE = 3;
C.TEXTURE_PROJECTION_MODE = 4;
C.TEXTURE_SKYBOX_MODE = 5;
C.TEXTURE_INVCUBIC_MODE = 6;
C.TEXTURE_EQUIRECTANGULAR_MODE = 7;
C.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
C.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
C.SCALEMODE_FLOOR = 1;
C.SCALEMODE_NEAREST = 2;
C.SCALEMODE_CEILING = 3;
C._RescalePostProcessFactory = null;
C._RenderPassIdCounter = 0;
le.prototype._debugPushGroup = function(c, e) {
};
le.prototype._debugPopGroup = function(c) {
};
le.prototype._debugInsertMarker = function(c, e) {
};
le.prototype._debugFlushPendingCommands = function() {
};
function sn(c) {
  return new C(c, !0, {
    preserveDrawingBuffer: !0,
    stencil: !0
  });
}
class te {
  constructor(e = 0, t = 0, i = 0) {
    this.r = e, this.g = t, this.b = i;
  }
  toString() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}";
  }
  getClassName() {
    return "Color3";
  }
  getHashCode() {
    let e = this.r * 255 | 0;
    return e = e * 397 ^ (this.g * 255 | 0), e = e * 397 ^ (this.b * 255 | 0), e;
  }
  toArray(e, t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, this;
  }
  fromArray(e, t = 0) {
    return te.FromArrayToRef(e, t, this), this;
  }
  toColor4(e = 1) {
    return new ge(this.r, this.g, this.b, e);
  }
  asArray() {
    return [this.r, this.g, this.b];
  }
  toLuminance() {
    return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
  }
  multiply(e) {
    return new te(this.r * e.r, this.g * e.g, this.b * e.b);
  }
  multiplyToRef(e, t) {
    return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, this;
  }
  equals(e) {
    return e && this.r === e.r && this.g === e.g && this.b === e.b;
  }
  equalsFloats(e, t, i) {
    return this.r === e && this.g === t && this.b === i;
  }
  scale(e) {
    return new te(this.r * e, this.g * e, this.b * e);
  }
  scaleInPlace(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  scaleToRef(e, t) {
    return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, this;
  }
  scaleAndAddToRef(e, t) {
    return t.r += this.r * e, t.g += this.g * e, t.b += this.b * e, this;
  }
  clampToRef(e = 0, t = 1, i) {
    return i.r = se.Clamp(this.r, e, t), i.g = se.Clamp(this.g, e, t), i.b = se.Clamp(this.b, e, t), this;
  }
  add(e) {
    return new te(this.r + e.r, this.g + e.g, this.b + e.b);
  }
  addToRef(e, t) {
    return t.r = this.r + e.r, t.g = this.g + e.g, t.b = this.b + e.b, this;
  }
  subtract(e) {
    return new te(this.r - e.r, this.g - e.g, this.b - e.b);
  }
  subtractToRef(e, t) {
    return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, this;
  }
  clone() {
    return new te(this.r, this.g, this.b);
  }
  copyFrom(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copyFromFloats(e, t, i) {
    return this.r = e, this.g = t, this.b = i, this;
  }
  set(e, t, i) {
    return this.copyFromFloats(e, t, i);
  }
  toHexString() {
    const e = Math.round(this.r * 255), t = Math.round(this.g * 255), i = Math.round(this.b * 255);
    return "#" + se.ToHex(e) + se.ToHex(t) + se.ToHex(i);
  }
  toLinearSpace() {
    const e = new te();
    return this.toLinearSpaceToRef(e), e;
  }
  toHSV() {
    const e = new te();
    return this.toHSVToRef(e), e;
  }
  toHSVToRef(e) {
    const t = this.r, i = this.g, s = this.b, r = Math.max(t, i, s), n = Math.min(t, i, s);
    let a = 0, o = 0;
    const h = r, l = r - n;
    r !== 0 && (o = l / r), r != n && (r == t ? (a = (i - s) / l, i < s && (a += 6)) : r == i ? a = (s - t) / l + 2 : r == s && (a = (t - i) / l + 4), a *= 60), e.r = a, e.g = o, e.b = h;
  }
  toLinearSpaceToRef(e) {
    return e.r = Math.pow(this.r, pi), e.g = Math.pow(this.g, pi), e.b = Math.pow(this.b, pi), this;
  }
  toGammaSpace() {
    const e = new te();
    return this.toGammaSpaceToRef(e), e;
  }
  toGammaSpaceToRef(e) {
    return e.r = Math.pow(this.r, gi), e.g = Math.pow(this.g, gi), e.b = Math.pow(this.b, gi), this;
  }
  static HSVtoRGBToRef(e, t, i, s) {
    const r = i * t, n = e / 60, a = r * (1 - Math.abs(n % 2 - 1));
    let o = 0, h = 0, l = 0;
    n >= 0 && n <= 1 ? (o = r, h = a) : n >= 1 && n <= 2 ? (o = a, h = r) : n >= 2 && n <= 3 ? (h = r, l = a) : n >= 3 && n <= 4 ? (h = a, l = r) : n >= 4 && n <= 5 ? (o = a, l = r) : n >= 5 && n <= 6 && (o = r, l = a);
    const u = i - r;
    s.set(o + u, h + u, l + u);
  }
  static FromHSV(e, t, i) {
    const s = new te(0, 0, 0);
    return te.HSVtoRGBToRef(e, t, i, s), s;
  }
  static FromHexString(e) {
    if (e.substring(0, 1) !== "#" || e.length !== 7)
      return new te(0, 0, 0);
    const t = parseInt(e.substring(1, 3), 16), i = parseInt(e.substring(3, 5), 16), s = parseInt(e.substring(5, 7), 16);
    return te.FromInts(t, i, s);
  }
  static FromArray(e, t = 0) {
    return new te(e[t], e[t + 1], e[t + 2]);
  }
  static FromArrayToRef(e, t = 0, i) {
    i.r = e[t], i.g = e[t + 1], i.b = e[t + 2];
  }
  static FromInts(e, t, i) {
    return new te(e / 255, t / 255, i / 255);
  }
  static Lerp(e, t, i) {
    const s = new te(0, 0, 0);
    return te.LerpToRef(e, t, i, s), s;
  }
  static LerpToRef(e, t, i, s) {
    s.r = e.r + (t.r - e.r) * i, s.g = e.g + (t.g - e.g) * i, s.b = e.b + (t.b - e.b) * i;
  }
  static Hermite(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, h = -2 * a + 3 * n, l = a - 2 * n + r, u = a - n, f = e.r * o + i.r * h + t.r * l + s.r * u, d = e.g * o + i.g * h + t.g * l + s.g * u, _ = e.b * o + i.b * h + t.b * l + s.b * u;
    return new te(f, d, _);
  }
  static Hermite1stDerivative(e, t, i, s, r) {
    const n = te.Black();
    return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n;
  }
  static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
    const a = r * r;
    n.r = (a - r) * 6 * e.r + (3 * a - 4 * r + 1) * t.r + (-a + r) * 6 * i.r + (3 * a - 2 * r) * s.r, n.g = (a - r) * 6 * e.g + (3 * a - 4 * r + 1) * t.g + (-a + r) * 6 * i.g + (3 * a - 2 * r) * s.g, n.b = (a - r) * 6 * e.b + (3 * a - 4 * r + 1) * t.b + (-a + r) * 6 * i.b + (3 * a - 2 * r) * s.b;
  }
  static Red() {
    return new te(1, 0, 0);
  }
  static Green() {
    return new te(0, 1, 0);
  }
  static Blue() {
    return new te(0, 0, 1);
  }
  static Black() {
    return new te(0, 0, 0);
  }
  static get BlackReadOnly() {
    return te._BlackReadOnly;
  }
  static White() {
    return new te(1, 1, 1);
  }
  static Purple() {
    return new te(0.5, 0, 0.5);
  }
  static Magenta() {
    return new te(1, 0, 1);
  }
  static Yellow() {
    return new te(1, 1, 0);
  }
  static Gray() {
    return new te(0.5, 0.5, 0.5);
  }
  static Teal() {
    return new te(0, 1, 1);
  }
  static Random() {
    return new te(Math.random(), Math.random(), Math.random());
  }
}
te._BlackReadOnly = te.Black();
class ge {
  constructor(e = 0, t = 0, i = 0, s = 1) {
    this.r = e, this.g = t, this.b = i, this.a = s;
  }
  addInPlace(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this.a += e.a, this;
  }
  asArray() {
    return [this.r, this.g, this.b, this.a];
  }
  toArray(e, t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e[t + 3] = this.a, this;
  }
  fromArray(e, t = 0) {
    return ge.FromArrayToRef(e, t, this), this;
  }
  equals(e) {
    return e && this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
  add(e) {
    return new ge(this.r + e.r, this.g + e.g, this.b + e.b, this.a + e.a);
  }
  subtract(e) {
    return new ge(this.r - e.r, this.g - e.g, this.b - e.b, this.a - e.a);
  }
  subtractToRef(e, t) {
    return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, t.a = this.a - e.a, this;
  }
  scale(e) {
    return new ge(this.r * e, this.g * e, this.b * e, this.a * e);
  }
  scaleInPlace(e) {
    return this.r *= e, this.g *= e, this.b *= e, this.a *= e, this;
  }
  scaleToRef(e, t) {
    return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, t.a = this.a * e, this;
  }
  scaleAndAddToRef(e, t) {
    return t.r += this.r * e, t.g += this.g * e, t.b += this.b * e, t.a += this.a * e, this;
  }
  clampToRef(e = 0, t = 1, i) {
    return i.r = se.Clamp(this.r, e, t), i.g = se.Clamp(this.g, e, t), i.b = se.Clamp(this.b, e, t), i.a = se.Clamp(this.a, e, t), this;
  }
  multiply(e) {
    return new ge(this.r * e.r, this.g * e.g, this.b * e.b, this.a * e.a);
  }
  multiplyToRef(e, t) {
    return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, t.a = this.a * e.a, t;
  }
  toString() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}";
  }
  getClassName() {
    return "Color4";
  }
  getHashCode() {
    let e = this.r * 255 | 0;
    return e = e * 397 ^ (this.g * 255 | 0), e = e * 397 ^ (this.b * 255 | 0), e = e * 397 ^ (this.a * 255 | 0), e;
  }
  clone() {
    return new ge(this.r, this.g, this.b, this.a);
  }
  copyFrom(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this;
  }
  copyFromFloats(e, t, i, s) {
    return this.r = e, this.g = t, this.b = i, this.a = s, this;
  }
  set(e, t, i, s) {
    return this.copyFromFloats(e, t, i, s);
  }
  toHexString(e = !1) {
    const t = Math.round(this.r * 255), i = Math.round(this.g * 255), s = Math.round(this.b * 255);
    if (e)
      return "#" + se.ToHex(t) + se.ToHex(i) + se.ToHex(s);
    const r = Math.round(this.a * 255);
    return "#" + se.ToHex(t) + se.ToHex(i) + se.ToHex(s) + se.ToHex(r);
  }
  toLinearSpace() {
    const e = new ge();
    return this.toLinearSpaceToRef(e), e;
  }
  toLinearSpaceToRef(e) {
    return e.r = Math.pow(this.r, pi), e.g = Math.pow(this.g, pi), e.b = Math.pow(this.b, pi), e.a = this.a, this;
  }
  toGammaSpace() {
    const e = new ge();
    return this.toGammaSpaceToRef(e), e;
  }
  toGammaSpaceToRef(e) {
    return e.r = Math.pow(this.r, gi), e.g = Math.pow(this.g, gi), e.b = Math.pow(this.b, gi), e.a = this.a, this;
  }
  static FromHexString(e) {
    if (e.substring(0, 1) !== "#" || e.length !== 9 && e.length !== 7)
      return new ge(0, 0, 0, 0);
    const t = parseInt(e.substring(1, 3), 16), i = parseInt(e.substring(3, 5), 16), s = parseInt(e.substring(5, 7), 16), r = e.length === 9 ? parseInt(e.substring(7, 9), 16) : 255;
    return ge.FromInts(t, i, s, r);
  }
  static Lerp(e, t, i) {
    const s = new ge(0, 0, 0, 0);
    return ge.LerpToRef(e, t, i, s), s;
  }
  static LerpToRef(e, t, i, s) {
    s.r = e.r + (t.r - e.r) * i, s.g = e.g + (t.g - e.g) * i, s.b = e.b + (t.b - e.b) * i, s.a = e.a + (t.a - e.a) * i;
  }
  static Hermite(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, h = -2 * a + 3 * n, l = a - 2 * n + r, u = a - n, f = e.r * o + i.r * h + t.r * l + s.r * u, d = e.g * o + i.g * h + t.g * l + s.g * u, _ = e.b * o + i.b * h + t.b * l + s.b * u, E = e.a * o + i.a * h + t.a * l + s.a * u;
    return new ge(f, d, _, E);
  }
  static Hermite1stDerivative(e, t, i, s, r) {
    const n = new ge();
    return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n;
  }
  static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
    const a = r * r;
    n.r = (a - r) * 6 * e.r + (3 * a - 4 * r + 1) * t.r + (-a + r) * 6 * i.r + (3 * a - 2 * r) * s.r, n.g = (a - r) * 6 * e.g + (3 * a - 4 * r + 1) * t.g + (-a + r) * 6 * i.g + (3 * a - 2 * r) * s.g, n.b = (a - r) * 6 * e.b + (3 * a - 4 * r + 1) * t.b + (-a + r) * 6 * i.b + (3 * a - 2 * r) * s.b, n.a = (a - r) * 6 * e.a + (3 * a - 4 * r + 1) * t.a + (-a + r) * 6 * i.a + (3 * a - 2 * r) * s.a;
  }
  static FromColor3(e, t = 1) {
    return new ge(e.r, e.g, e.b, t);
  }
  static FromArray(e, t = 0) {
    return new ge(e[t], e[t + 1], e[t + 2], e[t + 3]);
  }
  static FromArrayToRef(e, t = 0, i) {
    i.r = e[t], i.g = e[t + 1], i.b = e[t + 2], i.a = e[t + 3];
  }
  static FromInts(e, t, i, s) {
    return new ge(e / 255, t / 255, i / 255, s / 255);
  }
  static CheckColors4(e, t) {
    if (e.length === t * 3) {
      const i = [];
      for (let s = 0; s < e.length; s += 3) {
        const r = s / 3 * 4;
        i[r] = e[s], i[r + 1] = e[s + 1], i[r + 2] = e[s + 2], i[r + 3] = 1;
      }
      return i;
    }
    return e;
  }
}
class _i {
}
_i.Color3 = Me.BuildArray(3, te.Black);
_i.Color4 = Me.BuildArray(3, () => new ge(0, 0, 0, 0));
it("BABYLON.Color3", te);
it("BABYLON.Color4", ge);
const Ks = (c, e) => !c || c.getClassName && c.getClassName() === "Mesh" ? null : c.getClassName && c.getClassName() === "SubMesh" ? c.clone(e) : c.clone ? c.clone() : null;
function rn(c) {
  const e = [];
  do
    Object.getOwnPropertyNames(c).forEach(function(t) {
      e.indexOf(t) === -1 && e.push(t);
    });
  while (c = Object.getPrototypeOf(c));
  return e;
}
class ws {
  static DeepCopy(e, t, i, s) {
    const r = rn(e);
    for (const n of r) {
      if (n[0] === "_" && (!s || s.indexOf(n) === -1) || n.endsWith("Observable") || i && i.indexOf(n) !== -1)
        continue;
      const a = e[n], o = typeof a;
      if (o !== "function")
        try {
          if (o === "object")
            if (a instanceof Array) {
              if (t[n] = [], a.length > 0)
                if (typeof a[0] == "object")
                  for (let h = 0; h < a.length; h++) {
                    const l = Ks(a[h], t);
                    t[n].indexOf(l) === -1 && t[n].push(l);
                  }
                else
                  t[n] = a.slice(0);
            } else
              t[n] = Ks(a, t);
          else
            t[n] = a;
        } catch (h) {
          w.Warn(h.message);
        }
    }
  }
}
function nn() {
  return typeof _native < "u" && _native.XMLHttpRequest ? new _native.XMLHttpRequest() : new XMLHttpRequest();
}
class ut {
  constructor() {
    this._xhr = nn(), this._requestURL = "";
  }
  _injectCustomRequestHeaders() {
    if (!this._shouldSkipRequestModifications(this._requestURL))
      for (const e in ut.CustomRequestHeaders) {
        const t = ut.CustomRequestHeaders[e];
        t && this._xhr.setRequestHeader(e, t);
      }
  }
  _shouldSkipRequestModifications(e) {
    return ut.SkipRequestModificationForBabylonCDN && (e.includes("preview.babylonjs.com") || e.includes("cdn.babylonjs.com"));
  }
  get onprogress() {
    return this._xhr.onprogress;
  }
  set onprogress(e) {
    this._xhr.onprogress = e;
  }
  get readyState() {
    return this._xhr.readyState;
  }
  get status() {
    return this._xhr.status;
  }
  get statusText() {
    return this._xhr.statusText;
  }
  get response() {
    return this._xhr.response;
  }
  get responseURL() {
    return this._xhr.responseURL;
  }
  get responseText() {
    return this._xhr.responseText;
  }
  get responseType() {
    return this._xhr.responseType;
  }
  set responseType(e) {
    this._xhr.responseType = e;
  }
  get timeout() {
    return this._xhr.timeout;
  }
  set timeout(e) {
    this._xhr.timeout = e;
  }
  addEventListener(e, t, i) {
    this._xhr.addEventListener(e, t, i);
  }
  removeEventListener(e, t, i) {
    this._xhr.removeEventListener(e, t, i);
  }
  abort() {
    this._xhr.abort();
  }
  send(e) {
    ut.CustomRequestHeaders && this._injectCustomRequestHeaders(), this._xhr.send(e);
  }
  open(e, t) {
    for (const i of ut.CustomRequestModifiers) {
      if (this._shouldSkipRequestModifications(t))
        return;
      i(this._xhr, t);
    }
    return t = t.replace("file:http:", "http:"), t = t.replace("file:https:", "https:"), this._requestURL = t, this._xhr.open(e, t, !0);
  }
  setRequestHeader(e, t) {
    this._xhr.setRequestHeader(e, t);
  }
  getResponseHeader(e) {
    return this._xhr.getResponseHeader(e);
  }
}
ut.CustomRequestHeaders = {};
ut.CustomRequestModifiers = new Array();
ut.SkipRequestModificationForBabylonCDN = !0;
class Ai {
}
Ai.FilesToLoad = {};
class an {
  static ExponentialBackoff(e = 3, t = 500) {
    return (i, s, r) => s.status !== 0 || r >= e || i.indexOf("file:") !== -1 ? -1 : Math.pow(2, r) * t;
  }
}
class Si extends Error {
}
Si._setPrototypeOf = Object.setPrototypeOf || ((c, e) => (c.__proto__ = e, c));
const si = {
  MeshInvalidPositionsError: 0,
  UnsupportedTextureError: 1e3,
  GLTFLoaderUnexpectedMagicError: 2e3,
  SceneLoaderError: 3e3,
  LoadFileError: 4e3,
  RequestFileError: 4001,
  ReadFileError: 4002
};
class Vt extends Si {
  constructor(e, t, i) {
    super(e), this.errorCode = t, this.innerError = i, this.name = "RuntimeError", Si._setPrototypeOf(this, Vt.prototype);
  }
}
const mr = (c) => {
  const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let t = "", i, s, r, n, a, o, h, l = 0;
  const u = ArrayBuffer.isView(c) ? new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : new Uint8Array(c);
  for (; l < u.length; )
    i = u[l++], s = l < u.length ? u[l++] : Number.NaN, r = l < u.length ? u[l++] : Number.NaN, n = i >> 2, a = (i & 3) << 4 | s >> 4, o = (s & 15) << 2 | r >> 6, h = r & 63, isNaN(s) ? o = h = 64 : isNaN(r) && (h = 64), t += e.charAt(n) + e.charAt(a) + e.charAt(o) + e.charAt(h);
  return t;
}, Er = (c) => atob(c), on = (c) => {
  const e = Er(c), t = e.length, i = new Uint8Array(new ArrayBuffer(t));
  for (let s = 0; s < t; s++)
    i[s] = e.charCodeAt(s);
  return i.buffer;
};
class Ki {
  static SetImmediate(e) {
    Ne() && window.setImmediate ? window.setImmediate(e) : setTimeout(e, 1);
  }
}
const Tr = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);
class Yi extends Vt {
  constructor(e, t) {
    super(e, si.LoadFileError), this.name = "LoadFileError", Si._setPrototypeOf(this, Yi.prototype), t instanceof ut ? this.request = t : this.file = t;
  }
}
class Zi extends Vt {
  constructor(e, t) {
    super(e, si.RequestFileError), this.request = t, this.name = "RequestFileError", Si._setPrototypeOf(this, Zi.prototype);
  }
}
class Os extends Vt {
  constructor(e, t) {
    super(e, si.ReadFileError), this.file = t, this.name = "ReadFileError", Si._setPrototypeOf(this, Os.prototype);
  }
}
const Ke = {
  DefaultRetryStrategy: an.ExponentialBackoff(),
  BaseUrl: "",
  CorsBehavior: "anonymous",
  PreprocessUrl: (c) => c
}, Sr = (c) => (c = c.replace(/#/gm, "%23"), c), Ls = (c, e) => {
  if (!(c && c.indexOf("data:") === 0) && Ke.CorsBehavior)
    if (typeof Ke.CorsBehavior == "string" || Ke.CorsBehavior instanceof String)
      e.crossOrigin = Ke.CorsBehavior;
    else {
      const t = Ke.CorsBehavior(c);
      t && (e.crossOrigin = t);
    }
}, Ns = (c, e, t, i, s = "", r) => {
  var E;
  let n, a = !1;
  c instanceof ArrayBuffer || ArrayBuffer.isView(c) ? typeof Blob < "u" && typeof URL < "u" ? (n = URL.createObjectURL(new Blob([c], { type: s })), a = !0) : n = `data:${s};base64,` + mr(c) : c instanceof Blob ? (n = URL.createObjectURL(c), a = !0) : (n = Sr(c), n = Ke.PreprocessUrl(c));
  const o = _e.LastCreatedEngine, h = (m) => {
    if (t) {
      const T = n || c.toString();
      t(`Error while trying to load image: ${T.indexOf("http") === 0 || T.length <= 128 ? T : T.slice(0, 128) + "..."}`, m);
    }
  };
  if (typeof Image > "u" || ((E = o == null ? void 0 : o._features.forceBitmapOverHTMLImageElement) != null ? E : !1))
    return qt(n, (m) => {
      o.createImageBitmap(new Blob([m], { type: s }), { premultiplyAlpha: "none", ...r }).then((T) => {
        e(T), a && URL.revokeObjectURL(n);
      }).catch((T) => {
        t && t("Error while trying to load image: " + c, T);
      });
    }, void 0, i || void 0, !0, (m, T) => {
      h(T);
    }), null;
  const l = new Image();
  Ls(n, l);
  const u = () => {
    l.removeEventListener("load", u), l.removeEventListener("error", f), e(l), a && l.src && URL.revokeObjectURL(l.src);
  }, f = (m) => {
    l.removeEventListener("load", u), l.removeEventListener("error", f), h(m), a && l.src && URL.revokeObjectURL(l.src);
  };
  l.addEventListener("load", u), l.addEventListener("error", f);
  const d = () => {
    qt(n, (m, T, b) => {
      const R = !s && b ? b : s, y = new Blob([m], { type: R }), P = URL.createObjectURL(y);
      a = !0, l.src = P;
    }, void 0, i || void 0, !0, (m, T) => {
      h(T);
    });
  }, _ = () => {
    i && i.loadImage(n, l);
  };
  if (n.substr(0, 5) !== "blob:" && n.substr(0, 5) !== "data:" && i && i.enableTexturesOffline)
    i.open(_, d);
  else {
    if (n.indexOf("file:") !== -1) {
      const m = decodeURIComponent(n.substring(5).toLowerCase());
      if (Ai.FilesToLoad[m] && typeof URL < "u") {
        try {
          let T;
          try {
            T = URL.createObjectURL(Ai.FilesToLoad[m]);
          } catch {
            T = URL.createObjectURL(Ai.FilesToLoad[m]);
          }
          l.src = T, a = !0;
        } catch {
          l.src = "";
        }
        return l;
      }
    }
    d();
  }
  return l;
}, Ci = (c, e, t, i, s) => {
  const r = new FileReader(), n = {
    onCompleteObservable: new F(),
    abort: () => r.abort()
  };
  return r.onloadend = () => n.onCompleteObservable.notifyObservers(n), s && (r.onerror = () => {
    s(new Os(`Unable to read ${c.name}`, c));
  }), r.onload = (a) => {
    e(a.target.result);
  }, t && (r.onprogress = t), i ? r.readAsArrayBuffer(c) : r.readAsText(c), n;
}, qt = (c, e, t, i, s, r, n) => {
  if (c.name)
    return Ci(c, e, t, s, r ? (l) => {
      r(void 0, l);
    } : void 0);
  const a = c;
  if (a.indexOf("file:") !== -1) {
    let l = decodeURIComponent(a.substring(5).toLowerCase());
    l.indexOf("./") === 0 && (l = l.substring(2));
    const u = Ai.FilesToLoad[l];
    if (u)
      return Ci(u, e, t, s, r ? (f) => r(void 0, new Yi(f.message, f.file)) : void 0);
  }
  const { match: o, type: h } = hn(a);
  if (o) {
    const l = {
      onCompleteObservable: new F(),
      abort: () => () => {
      }
    };
    try {
      const u = s ? ks(a) : xr(a);
      e(u, void 0, h);
    } catch (u) {
      r ? r(void 0, u) : w.Error(u.message || "Failed to parse the Data URL");
    }
    return Ki.SetImmediate(() => {
      l.onCompleteObservable.notifyObservers(l);
    }), l;
  }
  return Bs(a, (l, u) => {
    e(l, u == null ? void 0 : u.responseURL, u == null ? void 0 : u.getResponseHeader("content-type"));
  }, t, i, s, r ? (l) => {
    r(l.request, new Yi(l.message, l.request));
  } : void 0, n);
}, Bs = (c, e, t, i, s, r, n) => {
  c = Sr(c), c = Ke.PreprocessUrl(c);
  const a = Ke.BaseUrl + c;
  let o = !1;
  const h = {
    onCompleteObservable: new F(),
    abort: () => o = !0
  }, l = () => {
    let u = new ut(), f = null, d;
    const _ = () => {
      !u || (t && u.removeEventListener("progress", t), d && u.removeEventListener("readystatechange", d), u.removeEventListener("loadend", E));
    };
    let E = () => {
      _(), h.onCompleteObservable.notifyObservers(h), h.onCompleteObservable.clear(), t = void 0, d = null, E = null, r = void 0, n = void 0, e = void 0;
    };
    h.abort = () => {
      o = !0, E && E(), u && u.readyState !== (XMLHttpRequest.DONE || 4) && u.abort(), f !== null && (clearTimeout(f), f = null), u = null;
    };
    const m = (b) => {
      const R = b.message || "Unknown error";
      r && u ? r(new Zi(R, u)) : w.Error(R);
    }, T = (b) => {
      if (!!u) {
        if (u.open("GET", a), n)
          try {
            n(u);
          } catch (R) {
            m(R);
            return;
          }
        s && (u.responseType = "arraybuffer"), t && u.addEventListener("progress", t), E && u.addEventListener("loadend", E), d = () => {
          if (!(o || !u) && u.readyState === (XMLHttpRequest.DONE || 4)) {
            if (d && u.removeEventListener("readystatechange", d), u.status >= 200 && u.status < 300 || u.status === 0 && (!Ne() || br())) {
              try {
                e && e(s ? u.response : u.responseText, u);
              } catch (P) {
                m(P);
              }
              return;
            }
            const R = Ke.DefaultRetryStrategy;
            if (R) {
              const P = R(a, u, b);
              if (P !== -1) {
                _(), u = new ut(), f = setTimeout(() => T(b + 1), P);
                return;
              }
            }
            const y = new Zi("Error status: " + u.status + " " + u.statusText + " - Unable to load " + a, u);
            r && r(y);
          }
        }, u.addEventListener("readystatechange", d), u.send();
      }
    };
    T(0);
  };
  if (i && i.enableSceneOffline) {
    const u = (d) => {
      d && d.status > 400 ? r && r(d) : l();
    }, f = () => {
      i && i.loadFile(Ke.BaseUrl + c, (d) => {
        !o && e && e(d), h.onCompleteObservable.notifyObservers(h);
      }, t ? (d) => {
        !o && t && t(d);
      } : void 0, u, s);
    };
    i.open(f, u);
  } else
    l();
  return h;
}, br = () => typeof location < "u" && location.protocol === "file:", Us = (c) => Tr.test(c), hn = (c) => {
  const e = Tr.exec(c);
  if (e === null || e.length === 0)
    return { match: !1, type: "" };
  {
    const t = e[0].replace("data:", "").replace("base64,", "");
    return { match: !0, type: t };
  }
};
function ks(c) {
  return on(c.split(",")[1]);
}
const xr = (c) => Er(c.split(",")[1]), ln = () => {
  le._FileToolsLoadImage = Ns, le._FileToolsLoadFile = qt, ii._FileToolsLoadFile = qt;
};
ln();
let xi;
const cn = (c, e, t, i, s, r, n, a, o, h) => {
  xi = {
    DecodeBase64UrlToBinary: c,
    DecodeBase64UrlToString: e,
    DefaultRetryStrategy: t.DefaultRetryStrategy,
    BaseUrl: t.BaseUrl,
    CorsBehavior: t.CorsBehavior,
    PreprocessUrl: t.PreprocessUrl,
    IsBase64DataUrl: i,
    IsFileURL: s,
    LoadFile: r,
    LoadImage: n,
    ReadFile: a,
    RequestFile: o,
    SetCorsBehavior: h
  }, Object.defineProperty(xi, "DefaultRetryStrategy", {
    get: function() {
      return t.DefaultRetryStrategy;
    },
    set: function(l) {
      t.DefaultRetryStrategy = l;
    }
  }), Object.defineProperty(xi, "BaseUrl", {
    get: function() {
      return t.BaseUrl;
    },
    set: function(l) {
      t.BaseUrl = l;
    }
  }), Object.defineProperty(xi, "PreprocessUrl", {
    get: function() {
      return t.PreprocessUrl;
    },
    set: function(l) {
      t.PreprocessUrl = l;
    }
  }), Object.defineProperty(xi, "CorsBehavior", {
    get: function() {
      return t.CorsBehavior;
    },
    set: function(l) {
      t.CorsBehavior = l;
    }
  });
};
cn(ks, xr, Ke, Us, br, qt, Ns, Ci, Bs, Ls);
class Ri {
  static Instantiate(e) {
    if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[e])
      return this.RegisteredExternalClasses[e];
    const t = oi(e);
    if (t)
      return t;
    w.Warn(e + " not found, you may have missed an import.");
    const i = e.split(".");
    let s = window || this;
    for (let r = 0, n = i.length; r < n; r++)
      s = s[i[r]];
    return typeof s != "function" ? null : s;
  }
}
Ri.RegisteredExternalClasses = {};
function vr() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const e = Math.random() * 16 | 0;
    return (c === "x" ? e : e & 3 | 8).toString(16);
  });
}
class U {
  static get BaseUrl() {
    return Ke.BaseUrl;
  }
  static set BaseUrl(e) {
    Ke.BaseUrl = e;
  }
  static get DefaultRetryStrategy() {
    return Ke.DefaultRetryStrategy;
  }
  static set DefaultRetryStrategy(e) {
    Ke.DefaultRetryStrategy = e;
  }
  static get CorsBehavior() {
    return Ke.CorsBehavior;
  }
  static set CorsBehavior(e) {
    Ke.CorsBehavior = e;
  }
  static get UseFallbackTexture() {
    return _e.UseFallbackTexture;
  }
  static set UseFallbackTexture(e) {
    _e.UseFallbackTexture = e;
  }
  static get RegisteredExternalClasses() {
    return Ri.RegisteredExternalClasses;
  }
  static set RegisteredExternalClasses(e) {
    Ri.RegisteredExternalClasses = e;
  }
  static get fallbackTexture() {
    return _e.FallbackTexture;
  }
  static set fallbackTexture(e) {
    _e.FallbackTexture = e;
  }
  static FetchToRef(e, t, i, s, r, n) {
    const a = Math.abs(e) * i % i | 0, o = Math.abs(t) * s % s | 0, h = (a + o * i) * 4;
    n.r = r[h] / 255, n.g = r[h + 1] / 255, n.b = r[h + 2] / 255, n.a = r[h + 3] / 255;
  }
  static Mix(e, t, i) {
    return e * (1 - i) + t * i;
  }
  static Instantiate(e) {
    return Ri.Instantiate(e);
  }
  static SetImmediate(e) {
    Ki.SetImmediate(e);
  }
  static IsExponentOfTwo(e) {
    let t = 1;
    do
      t *= 2;
    while (t < e);
    return t === e;
  }
  static FloatRound(e) {
    return Math.fround ? Math.fround(e) : (U._TmpFloatArray[0] = e, U._TmpFloatArray[0]);
  }
  static GetFilename(e) {
    const t = e.lastIndexOf("/");
    return t < 0 ? e : e.substring(t + 1);
  }
  static GetFolderPath(e, t = !1) {
    const i = e.lastIndexOf("/");
    return i < 0 ? t ? e : "" : e.substring(0, i + 1);
  }
  static ToDegrees(e) {
    return e * 180 / Math.PI;
  }
  static ToRadians(e) {
    return e * Math.PI / 180;
  }
  static MakeArray(e, t) {
    return t !== !0 && (e === void 0 || e == null) ? null : Array.isArray(e) ? e : [e];
  }
  static GetPointerPrefix(e) {
    let t = "pointer";
    return Ne() && !window.PointerEvent && (t = "mouse"), e._badDesktopOS && !e._badOS && !(document && "ontouchend" in document) && (t = "mouse"), t;
  }
  static SetCorsBehavior(e, t) {
    Ls(e, t);
  }
  static SetReferrerPolicyBehavior(e, t) {
    t.referrerPolicy = e;
  }
  static CleanUrl(e) {
    return e = e.replace(/#/gm, "%23"), e;
  }
  static get PreprocessUrl() {
    return Ke.PreprocessUrl;
  }
  static set PreprocessUrl(e) {
    Ke.PreprocessUrl = e;
  }
  static LoadImage(e, t, i, s, r, n) {
    return Ns(e, t, i, s, r, n);
  }
  static LoadFile(e, t, i, s, r, n) {
    return qt(e, t, i, s, r, n);
  }
  static LoadFileAsync(e, t = !0) {
    return new Promise((i, s) => {
      qt(e, (r) => {
        i(r);
      }, void 0, void 0, t, (r, n) => {
        s(n);
      });
    });
  }
  static LoadScript(e, t, i, s) {
    if (typeof self.importScripts == "function") {
      try {
        self.importScripts(e), t();
      } catch (a) {
        i == null || i(`Unable to load script '${e}' in worker`, a);
      }
      return;
    } else if (!Ne()) {
      i == null || i(`Cannot load script '${e}' outside of a window or a worker`);
      return;
    }
    const r = document.getElementsByTagName("head")[0], n = document.createElement("script");
    n.setAttribute("type", "text/javascript"), n.setAttribute("src", e), s && (n.id = s), n.onload = () => {
      t && t();
    }, n.onerror = (a) => {
      i && i(`Unable to load script '${e}'`, a);
    }, r.appendChild(n);
  }
  static LoadScriptAsync(e) {
    return new Promise((t, i) => {
      this.LoadScript(e, () => {
        t();
      }, (s, r) => {
        i(r);
      });
    });
  }
  static ReadFileAsDataURL(e, t, i) {
    const s = new FileReader(), r = {
      onCompleteObservable: new F(),
      abort: () => s.abort()
    };
    return s.onloadend = () => {
      r.onCompleteObservable.notifyObservers(r);
    }, s.onload = (n) => {
      t(n.target.result);
    }, s.onprogress = i, s.readAsDataURL(e), r;
  }
  static ReadFile(e, t, i, s, r) {
    return Ci(e, t, i, s, r);
  }
  static FileAsURL(e) {
    const t = new Blob([e]);
    return (window.URL || window.webkitURL).createObjectURL(t);
  }
  static Format(e, t = 2) {
    return e.toFixed(t);
  }
  static DeepCopy(e, t, i, s) {
    ws.DeepCopy(e, t, i, s);
  }
  static IsEmpty(e) {
    for (const t in e)
      if (Object.prototype.hasOwnProperty.call(e, t))
        return !1;
    return !0;
  }
  static RegisterTopRootEvents(e, t) {
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      e.addEventListener(s.name, s.handler, !1);
      try {
        window.parent && window.parent.addEventListener(s.name, s.handler, !1);
      } catch {
      }
    }
  }
  static UnregisterTopRootEvents(e, t) {
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      e.removeEventListener(s.name, s.handler);
      try {
        e.parent && e.parent.removeEventListener(s.name, s.handler);
      } catch {
      }
    }
  }
  static async DumpFramebuffer(e, t, i, s, r = "image/png", n) {
    const a = await i.readPixels(0, 0, e, t), o = new Uint8Array(a.buffer);
    U.DumpData(e, t, o, s, r, n, !0);
  }
  static DumpData(e, t, i, s, r = "image/png", n, a = !1, o = !1, h) {
    U._ScreenshotCanvas || (U._ScreenshotCanvas = document.createElement("canvas")), U._ScreenshotCanvas.width = e, U._ScreenshotCanvas.height = t;
    const l = U._ScreenshotCanvas.getContext("2d");
    if (l) {
      if (i instanceof Float32Array) {
        const _ = new Uint8Array(i.length);
        let E = i.length;
        for (; E--; ) {
          const m = i[E];
          _[E] = m < 0 ? 0 : m > 1 ? 1 : Math.round(m * 255);
        }
        i = _;
      }
      const u = l.createImageData(e, t);
      u.data.set(i), l.putImageData(u, 0, 0);
      let d = U._ScreenshotCanvas;
      if (a) {
        const _ = document.createElement("canvas");
        _.width = e, _.height = t;
        const E = _.getContext("2d");
        if (!E)
          return;
        E.translate(0, t), E.scale(1, -1), E.drawImage(U._ScreenshotCanvas, 0, 0), d = _;
      }
      o ? U.ToBlob(d, (_) => {
        const E = new FileReader();
        E.onload = (m) => {
          const T = m.target.result;
          s && s(T);
        }, E.readAsArrayBuffer(_);
      }, r, h) : U.EncodeScreenshotCanvasData(s, r, n, d, h);
    }
  }
  static DumpDataAsync(e, t, i, s = "image/png", r, n = !1, a = !1, o) {
    return new Promise((h) => {
      U.DumpData(e, t, i, (l) => h(l), s, r, n, a, o);
    });
  }
  static ToBlob(e, t, i = "image/png", s) {
    e.toBlob || (e.toBlob = function(r, n, a) {
      setTimeout(() => {
        const o = atob(this.toDataURL(n, a).split(",")[1]), h = o.length, l = new Uint8Array(h);
        for (let u = 0; u < h; u++)
          l[u] = o.charCodeAt(u);
        r(new Blob([l]));
      });
    }), e.toBlob(function(r) {
      t(r);
    }, i, s);
  }
  static DownloadBlob(e, t) {
    if ("download" in document.createElement("a")) {
      if (!t) {
        const i = new Date(), s = (i.getFullYear() + "-" + (i.getMonth() + 1)).slice(2) + "-" + i.getDate() + "_" + i.getHours() + "-" + ("0" + i.getMinutes()).slice(-2);
        t = "screenshot_" + s + ".png";
      }
      U.Download(e, t);
    } else if (e && typeof URL < "u") {
      const i = URL.createObjectURL(e), s = window.open("");
      if (!s)
        return;
      const r = s.document.createElement("img");
      r.onload = function() {
        URL.revokeObjectURL(i);
      }, r.src = i, s.document.body.appendChild(r);
    }
  }
  static EncodeScreenshotCanvasData(e, t = "image/png", i, s, r) {
    if (e) {
      const n = (s != null ? s : U._ScreenshotCanvas).toDataURL(t, r);
      e(n);
    } else
      this.ToBlob(s != null ? s : U._ScreenshotCanvas, function(n) {
        n && U.DownloadBlob(n, i);
      }, t, r);
  }
  static Download(e, t) {
    if (navigator && navigator.msSaveBlob) {
      navigator.msSaveBlob(e, t);
      return;
    }
    if (typeof URL > "u")
      return;
    const i = window.URL.createObjectURL(e), s = document.createElement("a");
    document.body.appendChild(s), s.style.display = "none", s.href = i, s.download = t, s.addEventListener("click", () => {
      s.parentElement && s.parentElement.removeChild(s);
    }), s.click(), window.URL.revokeObjectURL(i);
  }
  static BackCompatCameraNoPreventDefault(e) {
    return typeof e[0] == "boolean" ? e[0] : typeof e[1] == "boolean" ? e[1] : !1;
  }
  static CreateScreenshot(e, t, i, s, r = "image/png") {
    throw q("ScreenshotTools");
  }
  static CreateScreenshotAsync(e, t, i, s = "image/png") {
    throw q("ScreenshotTools");
  }
  static CreateScreenshotUsingRenderTarget(e, t, i, s, r = "image/png", n = 1, a = !1, o) {
    throw q("ScreenshotTools");
  }
  static CreateScreenshotUsingRenderTargetAsync(e, t, i, s = "image/png", r = 1, n = !1, a) {
    throw q("ScreenshotTools");
  }
  static RandomId() {
    return vr();
  }
  static IsBase64(e) {
    return Us(e);
  }
  static DecodeBase64(e) {
    return ks(e);
  }
  static get errorsCount() {
    return w.errorsCount;
  }
  static Log(e) {
    w.Log(e);
  }
  static Warn(e) {
    w.Warn(e);
  }
  static Error(e) {
    w.Error(e);
  }
  static get LogCache() {
    return w.LogCache;
  }
  static ClearLogCache() {
    w.ClearLogCache();
  }
  static set LogLevels(e) {
    w.LogLevels = e;
  }
  static set PerformanceLogLevel(e) {
    if ((e & U.PerformanceUserMarkLogLevel) === U.PerformanceUserMarkLogLevel) {
      U.StartPerformanceCounter = U._StartUserMark, U.EndPerformanceCounter = U._EndUserMark;
      return;
    }
    if ((e & U.PerformanceConsoleLogLevel) === U.PerformanceConsoleLogLevel) {
      U.StartPerformanceCounter = U._StartPerformanceConsole, U.EndPerformanceCounter = U._EndPerformanceConsole;
      return;
    }
    U.StartPerformanceCounter = U._StartPerformanceCounterDisabled, U.EndPerformanceCounter = U._EndPerformanceCounterDisabled;
  }
  static _StartPerformanceCounterDisabled(e, t) {
  }
  static _EndPerformanceCounterDisabled(e, t) {
  }
  static _StartUserMark(e, t = !0) {
    if (!U._Performance) {
      if (!Ne())
        return;
      U._Performance = window.performance;
    }
    !t || !U._Performance.mark || U._Performance.mark(e + "-Begin");
  }
  static _EndUserMark(e, t = !0) {
    !t || !U._Performance.mark || (U._Performance.mark(e + "-End"), U._Performance.measure(e, e + "-Begin", e + "-End"));
  }
  static _StartPerformanceConsole(e, t = !0) {
    !t || (U._StartUserMark(e, t), console.time && console.time(e));
  }
  static _EndPerformanceConsole(e, t = !0) {
    !t || (U._EndUserMark(e, t), console.timeEnd(e));
  }
  static get Now() {
    return mi.Now;
  }
  static GetClassName(e, t = !1) {
    let i = null;
    return !t && e.getClassName ? i = e.getClassName() : (e instanceof Object && (i = (t ? e : Object.getPrototypeOf(e)).constructor.__bjsclassName__), i || (i = typeof e)), i;
  }
  static First(e, t) {
    for (const i of e)
      if (t(i))
        return i;
    return null;
  }
  static getFullClassName(e, t = !1) {
    let i = null, s = null;
    if (!t && e.getClassName)
      i = e.getClassName();
    else {
      if (e instanceof Object) {
        const r = t ? e : Object.getPrototypeOf(e);
        i = r.constructor.__bjsclassName__, s = r.constructor.__bjsmoduleName__;
      }
      i || (i = typeof e);
    }
    return i ? (s != null ? s + "." : "") + i : null;
  }
  static DelayAsync(e) {
    return new Promise((t) => {
      setTimeout(() => {
        t();
      }, e);
    });
  }
  static IsSafari() {
    return gr() ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1;
  }
}
U.UseCustomRequestHeaders = !1;
U.CustomRequestHeaders = ut.CustomRequestHeaders;
U._TmpFloatArray = new Float32Array(1);
U.GetDOMTextContent = Fs;
U.GetAbsoluteUrl = typeof document == "object" ? (c) => {
  const e = document.createElement("a");
  return e.href = c, e.href;
} : typeof URL == "function" && typeof location == "object" ? (c) => new URL(c, location.origin).href : () => {
  throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.");
};
U.NoneLogLevel = w.NoneLogLevel;
U.MessageLogLevel = w.MessageLogLevel;
U.WarningLogLevel = w.WarningLogLevel;
U.ErrorLogLevel = w.ErrorLogLevel;
U.AllLogLevel = w.AllLogLevel;
U.IsWindowObjectExist = Ne;
U.PerformanceNoneLogLevel = 0;
U.PerformanceUserMarkLogLevel = 1;
U.PerformanceConsoleLogLevel = 2;
U.StartPerformanceCounter = U._StartPerformanceCounterDisabled;
U.EndPerformanceCounter = U._EndPerformanceCounterDisabled;
class qi {
  constructor(e, t, i, s = 0) {
    this.iterations = e, this.index = s - 1, this._done = !1, this._fn = t, this._successCallback = i;
  }
  executeNext() {
    this._done || (this.index + 1 < this.iterations ? (++this.index, this._fn(this)) : this.breakLoop());
  }
  breakLoop() {
    this._done = !0, this._successCallback();
  }
  static Run(e, t, i, s = 0) {
    const r = new qi(e, t, i, s);
    return r.executeNext(), r;
  }
  static SyncAsyncForLoop(e, t, i, s, r, n = 0) {
    return qi.Run(Math.ceil(e / t), (a) => {
      r && r() ? a.breakLoop() : setTimeout(() => {
        for (let o = 0; o < t; ++o) {
          const h = a.index * t + o;
          if (h >= e)
            break;
          if (i(h), r && r()) {
            a.breakLoop();
            break;
          }
        }
        a.executeNext();
      }, n);
    }, s);
  }
}
_e.FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";
class Qe {
  constructor(e) {
    this.length = 0, this.data = new Array(e), this._id = Qe._GlobalId++;
  }
  push(e) {
    this.data[this.length++] = e, this.length > this.data.length && (this.data.length *= 2);
  }
  forEach(e) {
    for (let t = 0; t < this.length; t++)
      e(this.data[t]);
  }
  sort(e) {
    this.data.sort(e);
  }
  reset() {
    this.length = 0;
  }
  dispose() {
    this.reset(), this.data && (this.data.length = 0);
  }
  concat(e) {
    if (e.length !== 0) {
      this.length + e.length > this.data.length && (this.data.length = (this.length + e.length) * 2);
      for (let t = 0; t < e.length; t++)
        this.data[this.length++] = (e.data || e)[t];
    }
  }
  indexOf(e) {
    const t = this.data.indexOf(e);
    return t >= this.length ? -1 : t;
  }
  contains(e) {
    return this.indexOf(e) !== -1;
  }
}
Qe._GlobalId = 0;
class Jt extends Qe {
  constructor() {
    super(...arguments), this._duplicateId = 0;
  }
  push(e) {
    super.push(e), e.__smartArrayFlags || (e.__smartArrayFlags = {}), e.__smartArrayFlags[this._id] = this._duplicateId;
  }
  pushNoDuplicate(e) {
    return e.__smartArrayFlags && e.__smartArrayFlags[this._id] === this._duplicateId ? !1 : (this.push(e), !0);
  }
  reset() {
    super.reset(), this._duplicateId++;
  }
  concatWithNoDuplicate(e) {
    if (e.length !== 0) {
      this.length + e.length > this.data.length && (this.data.length = (this.length + e.length) * 2);
      for (let t = 0; t < e.length; t++) {
        const i = (e.data || e)[t];
        this.pushNoDuplicate(i);
      }
    }
  }
}
class Ys {
  constructor() {
    this._count = 0, this._data = {};
  }
  copyFrom(e) {
    this.clear(), e.forEach((t, i) => this.add(t, i));
  }
  get(e) {
    const t = this._data[e];
    if (t !== void 0)
      return t;
  }
  getOrAddWithFactory(e, t) {
    let i = this.get(e);
    return i !== void 0 || (i = t(e), i && this.add(e, i)), i;
  }
  getOrAdd(e, t) {
    const i = this.get(e);
    return i !== void 0 ? i : (this.add(e, t), t);
  }
  contains(e) {
    return this._data[e] !== void 0;
  }
  add(e, t) {
    return this._data[e] !== void 0 ? !1 : (this._data[e] = t, ++this._count, !0);
  }
  set(e, t) {
    return this._data[e] === void 0 ? !1 : (this._data[e] = t, !0);
  }
  getAndRemove(e) {
    const t = this.get(e);
    return t !== void 0 ? (delete this._data[e], --this._count, t) : null;
  }
  remove(e) {
    return this.contains(e) ? (delete this._data[e], --this._count, !0) : !1;
  }
  clear() {
    this._data = {}, this._count = 0;
  }
  get count() {
    return this._count;
  }
  forEach(e) {
    for (const t in this._data) {
      const i = this._data[t];
      e(t, i);
    }
  }
  first(e) {
    for (const t in this._data) {
      const i = this._data[t], s = e(t, i);
      if (s)
        return s;
    }
    return null;
  }
}
class ti {
  static Eval(e, t) {
    return e.match(/\([^()]*\)/g) ? e = e.replace(/\([^()]*\)/g, (i) => (i = i.slice(1, i.length - 1), ti._HandleParenthesisContent(i, t))) : e = ti._HandleParenthesisContent(e, t), e === "true" ? !0 : e === "false" ? !1 : ti.Eval(e, t);
  }
  static _HandleParenthesisContent(e, t) {
    t = t || ((r) => r === "true");
    let i;
    const s = e.split("||");
    for (const r in s)
      if (Object.prototype.hasOwnProperty.call(s, r)) {
        let n = ti._SimplifyNegation(s[r].trim());
        const a = n.split("&&");
        if (a.length > 1)
          for (let o = 0; o < a.length; ++o) {
            const h = ti._SimplifyNegation(a[o].trim());
            if (h !== "true" && h !== "false" ? h[0] === "!" ? i = !t(h.substring(1)) : i = t(h) : i = h === "true", !i) {
              n = "false";
              break;
            }
          }
        if (i || n === "true") {
          i = !0;
          break;
        }
        n !== "true" && n !== "false" ? n[0] === "!" ? i = !t(n.substring(1)) : i = t(n) : i = n === "true";
      }
    return i ? "true" : "false";
  }
  static _SimplifyNegation(e) {
    return e = e.replace(/^[\s!]+/, (t) => (t = t.replace(/[\s]/g, () => ""), t.length % 2 ? "!" : "")), e = e.trim(), e === "!true" ? e = "false" : e === "!false" && (e = "true"), e;
  }
}
class pe {
  static EnableFor(e) {
    e._tags = e._tags || {}, e.hasTags = () => pe.HasTags(e), e.addTags = (t) => pe.AddTagsTo(e, t), e.removeTags = (t) => pe.RemoveTagsFrom(e, t), e.matchesTagsQuery = (t) => pe.MatchesQuery(e, t);
  }
  static DisableFor(e) {
    delete e._tags, delete e.hasTags, delete e.addTags, delete e.removeTags, delete e.matchesTagsQuery;
  }
  static HasTags(e) {
    if (!e._tags)
      return !1;
    const t = e._tags;
    for (const i in t)
      if (Object.prototype.hasOwnProperty.call(t, i))
        return !0;
    return !1;
  }
  static GetTags(e, t = !0) {
    if (!e._tags)
      return null;
    if (t) {
      const i = [];
      for (const s in e._tags)
        Object.prototype.hasOwnProperty.call(e._tags, s) && e._tags[s] === !0 && i.push(s);
      return i.join(" ");
    } else
      return e._tags;
  }
  static AddTagsTo(e, t) {
    if (!t || typeof t != "string")
      return;
    t.split(" ").forEach(function(s) {
      pe._AddTagTo(e, s);
    });
  }
  static _AddTagTo(e, t) {
    t = t.trim(), !(t === "" || t === "true" || t === "false") && (t.match(/[\s]/) || t.match(/^([!]|([|]|[&]){2})/) || (pe.EnableFor(e), e._tags[t] = !0));
  }
  static RemoveTagsFrom(e, t) {
    if (!pe.HasTags(e))
      return;
    const i = t.split(" ");
    for (const s in i)
      pe._RemoveTagFrom(e, i[s]);
  }
  static _RemoveTagFrom(e, t) {
    delete e._tags[t];
  }
  static MatchesQuery(e, t) {
    return t === void 0 ? !0 : t === "" ? pe.HasTags(e) : ti.Eval(t, (i) => pe.HasTags(e) && e._tags[i]);
  }
}
class rs {
  constructor() {
    this.rootNodes = new Array(), this.cameras = new Array(), this.lights = new Array(), this.meshes = new Array(), this.skeletons = new Array(), this.particleSystems = new Array(), this.animations = [], this.animationGroups = new Array(), this.multiMaterials = new Array(), this.materials = new Array(), this.morphTargetManagers = new Array(), this.geometries = new Array(), this.transformNodes = new Array(), this.actionManagers = new Array(), this.textures = new Array(), this._environmentTexture = null, this.postProcesses = new Array();
  }
  static AddParser(e, t) {
    this._BabylonFileParsers[e] = t;
  }
  static GetParser(e) {
    return this._BabylonFileParsers[e] ? this._BabylonFileParsers[e] : null;
  }
  static AddIndividualParser(e, t) {
    this._IndividualBabylonFileParsers[e] = t;
  }
  static GetIndividualParser(e) {
    return this._IndividualBabylonFileParsers[e] ? this._IndividualBabylonFileParsers[e] : null;
  }
  static Parse(e, t, i, s) {
    for (const r in this._BabylonFileParsers)
      Object.prototype.hasOwnProperty.call(this._BabylonFileParsers, r) && this._BabylonFileParsers[r](e, t, i, s);
  }
  get environmentTexture() {
    return this._environmentTexture;
  }
  set environmentTexture(e) {
    this._environmentTexture = e;
  }
  getNodes() {
    let e = new Array();
    return e = e.concat(this.meshes), e = e.concat(this.lights), e = e.concat(this.cameras), e = e.concat(this.transformNodes), this.skeletons.forEach((t) => e = e.concat(t.bones)), e;
  }
}
rs._BabylonFileParsers = {};
rs._IndividualBabylonFileParsers = {};
function S(c, e, t, i) {
  var s = arguments.length, r = s < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(c, e, t, i);
  else
    for (var a = c.length - 1; a >= 0; a--)
      (n = c[a]) && (r = (s < 3 ? n(r) : s > 3 ? n(e, t, r) : n(e, t)) || r);
  return s > 3 && r && Object.defineProperty(e, t, r), r;
}
const Xi = {}, Wi = {}, Zs = function(c, e, t) {
  const i = c();
  pe && pe.AddTagsTo(i, e.tags);
  const s = Cs(i);
  for (const r in s) {
    const n = s[r], a = e[r], o = n.type;
    if (a != null && (r !== "uniqueId" || ne.AllowLoadingUniqueId))
      switch (o) {
        case 0:
        case 6:
        case 11:
          i[r] = a;
          break;
        case 1:
          i[r] = t || a.isRenderTarget ? a : a.clone();
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 7:
        case 10:
        case 12:
          i[r] = t ? a : a.clone();
          break;
      }
  }
  return i;
};
function un(c) {
  const e = c.getClassName();
  return Xi[e] || (Xi[e] = {}), Xi[e];
}
function Cs(c) {
  const e = c.getClassName();
  if (Wi[e])
    return Wi[e];
  Wi[e] = {};
  const t = Wi[e];
  let i = c, s = e;
  for (; s; ) {
    const r = Xi[s];
    for (const o in r)
      t[o] = r[o];
    let n, a = !1;
    do {
      if (n = Object.getPrototypeOf(i), !n.getClassName) {
        a = !0;
        break;
      }
      if (n.getClassName() !== s)
        break;
      i = n;
    } while (n);
    if (a)
      break;
    s = n.getClassName(), i = n;
  }
  return t;
}
function Ct(c, e) {
  return (t, i) => {
    const s = un(t);
    s[i] || (s[i] = { type: c, sourceName: e });
  };
}
function fn(c, e = null) {
  return (t, i) => {
    const s = e || "_" + i;
    Object.defineProperty(t, i, {
      get: function() {
        return this[s];
      },
      set: function(r) {
        typeof this.equals == "function" && this.equals(r) || this[s] !== r && (this[s] = r, t[c].apply(this));
      },
      enumerable: !0,
      configurable: !0
    });
  };
}
function xe(c, e = null) {
  return fn(c, e);
}
function M(c) {
  return Ct(0, c);
}
function Et(c) {
  return Ct(1, c);
}
function li(c) {
  return Ct(2, c);
}
function Li(c) {
  return Ct(3, c);
}
function dn(c) {
  return Ct(4, c);
}
function Wt(c) {
  return Ct(5, c);
}
function _n(c) {
  return Ct(6, c);
}
function gn(c) {
  return Ct(7, c);
}
function Mr(c) {
  return Ct(8, c);
}
function pn(c) {
  return Ct(10, c);
}
class ne {
  static AppendSerializedAnimations(e, t) {
    if (e.animations) {
      t.animations = [];
      for (let i = 0; i < e.animations.length; i++) {
        const s = e.animations[i];
        t.animations.push(s.serialize());
      }
    }
  }
  static Serialize(e, t) {
    t || (t = {}), pe && (t.tags = pe.GetTags(e));
    const i = Cs(e);
    for (const s in i) {
      const r = i[s], n = r.sourceName || s, a = r.type, o = e[s];
      if (o != null && (s !== "uniqueId" || ne.AllowLoadingUniqueId))
        switch (a) {
          case 0:
            t[n] = o;
            break;
          case 1:
            t[n] = o.serialize();
            break;
          case 2:
            t[n] = o.asArray();
            break;
          case 3:
            t[n] = o.serialize();
            break;
          case 4:
            t[n] = o.asArray();
            break;
          case 5:
            t[n] = o.asArray();
            break;
          case 6:
            t[n] = o.id;
            break;
          case 7:
            t[n] = o.serialize();
            break;
          case 8:
            t[n] = o.asArray();
            break;
          case 9:
            t[n] = o.serialize();
            break;
          case 10:
            t[n] = o.asArray();
            break;
          case 11:
            t[n] = o.id;
            break;
          case 12:
            t[n] = o.asArray();
            break;
        }
    }
    return t;
  }
  static Parse(e, t, i, s = null) {
    const r = e();
    s || (s = ""), pe && pe.AddTagsTo(r, t.tags);
    const n = Cs(r);
    for (const a in n) {
      const o = n[a], h = t[o.sourceName || a], l = o.type;
      if (h != null && (a !== "uniqueId" || ne.AllowLoadingUniqueId)) {
        const u = r;
        switch (l) {
          case 0:
            u[a] = h;
            break;
          case 1:
            i && (u[a] = ne._TextureParser(h, i, s));
            break;
          case 2:
            u[a] = te.FromArray(h);
            break;
          case 3:
            u[a] = ne._FresnelParametersParser(h);
            break;
          case 4:
            u[a] = ee.FromArray(h);
            break;
          case 5:
            u[a] = g.FromArray(h);
            break;
          case 6:
            i && (u[a] = i.getLastMeshById(h));
            break;
          case 7:
            u[a] = ne._ColorCurvesParser(h);
            break;
          case 8:
            u[a] = ge.FromArray(h);
            break;
          case 9:
            u[a] = ne._ImageProcessingConfigurationParser(h);
            break;
          case 10:
            u[a] = z.FromArray(h);
            break;
          case 11:
            i && (u[a] = i.getCameraById(h));
            break;
          case 12:
            u[a] = x.FromArray(h);
            break;
        }
      }
    }
    return r;
  }
  static Clone(e, t) {
    return Zs(e, t, !1);
  }
  static Instanciate(e, t) {
    return Zs(e, t, !0);
  }
}
ne.AllowLoadingUniqueId = !1;
ne._ImageProcessingConfigurationParser = (c) => {
  throw q("ImageProcessingConfiguration");
};
ne._FresnelParametersParser = (c) => {
  throw q("FresnelParameters");
};
ne._ColorCurvesParser = (c) => {
  throw q("ColorCurves");
};
ne._TextureParser = (c, e, t) => {
  throw q("Texture");
};
function jt(c, e, t, i) {
  const s = t.value;
  t.value = (...r) => {
    let n = s;
    if (typeof _native < "u" && _native[e]) {
      const a = _native[e];
      i ? n = (...o) => i(...o) ? a(...o) : s(...o) : n = a;
    }
    return c[e] = n, n(...r);
  };
}
jt.filter = function(c) {
  return (e, t, i) => jt(e, t, i, c);
};
class Vs {
  constructor(e) {
    if (this._keys = [], this._isDirty = !0, this._areLightsDirty = !0, this._areLightsDisposed = !1, this._areAttributesDirty = !0, this._areTexturesDirty = !0, this._areFresnelDirty = !0, this._areMiscDirty = !0, this._arePrePassDirty = !0, this._areImageProcessingDirty = !0, this._normals = !1, this._uvs = !1, this._needNormals = !1, this._needUVs = !1, this._externalProperties = e, e)
      for (const t in e)
        Object.prototype.hasOwnProperty.call(e, t) && this._setDefaultValue(t);
  }
  get isDirty() {
    return this._isDirty;
  }
  markAsProcessed() {
    this._isDirty = !1, this._areAttributesDirty = !1, this._areTexturesDirty = !1, this._areFresnelDirty = !1, this._areLightsDirty = !1, this._areLightsDisposed = !1, this._areMiscDirty = !1, this._arePrePassDirty = !1, this._areImageProcessingDirty = !1;
  }
  markAsUnprocessed() {
    this._isDirty = !0;
  }
  markAllAsDirty() {
    this._areTexturesDirty = !0, this._areAttributesDirty = !0, this._areLightsDirty = !0, this._areFresnelDirty = !0, this._areMiscDirty = !0, this._areImageProcessingDirty = !0, this._isDirty = !0;
  }
  markAsImageProcessingDirty() {
    this._areImageProcessingDirty = !0, this._isDirty = !0;
  }
  markAsLightDirty(e = !1) {
    this._areLightsDirty = !0, this._areLightsDisposed = this._areLightsDisposed || e, this._isDirty = !0;
  }
  markAsAttributesDirty() {
    this._areAttributesDirty = !0, this._isDirty = !0;
  }
  markAsTexturesDirty() {
    this._areTexturesDirty = !0, this._isDirty = !0;
  }
  markAsFresnelDirty() {
    this._areFresnelDirty = !0, this._isDirty = !0;
  }
  markAsMiscDirty() {
    this._areMiscDirty = !0, this._isDirty = !0;
  }
  markAsPrePassDirty() {
    this._arePrePassDirty = !0, this._isDirty = !0;
  }
  rebuild() {
    this._keys.length = 0;
    for (const e of Object.keys(this))
      e[0] !== "_" && this._keys.push(e);
    if (this._externalProperties)
      for (const e in this._externalProperties)
        this._keys.indexOf(e) === -1 && this._keys.push(e);
  }
  isEqual(e) {
    if (this._keys.length !== e._keys.length)
      return !1;
    for (let t = 0; t < this._keys.length; t++) {
      const i = this._keys[t];
      if (this[i] !== e[i])
        return !1;
    }
    return !0;
  }
  cloneTo(e) {
    this._keys.length !== e._keys.length && (e._keys = this._keys.slice(0));
    for (let t = 0; t < this._keys.length; t++) {
      const i = this._keys[t];
      e[i] = this[i];
    }
  }
  reset() {
    this._keys.forEach((e) => this._setDefaultValue(e));
  }
  _setDefaultValue(e) {
    var s, r, n, a, o;
    const t = (n = (r = (s = this._externalProperties) == null ? void 0 : s[e]) == null ? void 0 : r.type) != null ? n : typeof this[e], i = (o = (a = this._externalProperties) == null ? void 0 : a[e]) == null ? void 0 : o.default;
    switch (t) {
      case "number":
        this[e] = i != null ? i : 0;
        break;
      case "string":
        this[e] = i != null ? i : "";
        break;
      default:
        this[e] = i != null ? i : !1;
        break;
    }
  }
  toString() {
    let e = "";
    for (let t = 0; t < this._keys.length; t++) {
      const i = this._keys[t], s = this[i];
      switch (typeof s) {
        case "number":
        case "string":
          e += "#define " + i + " " + s + `
`;
          break;
        default:
          s && (e += "#define " + i + `
`);
          break;
      }
    }
    return e;
  }
}
class ve {
  constructor() {
    this._dirty = !0, this._tempColor = new ge(0, 0, 0, 0), this._globalCurve = new ge(0, 0, 0, 0), this._highlightsCurve = new ge(0, 0, 0, 0), this._midtonesCurve = new ge(0, 0, 0, 0), this._shadowsCurve = new ge(0, 0, 0, 0), this._positiveCurve = new ge(0, 0, 0, 0), this._negativeCurve = new ge(0, 0, 0, 0), this._globalHue = 30, this._globalDensity = 0, this._globalSaturation = 0, this._globalExposure = 0, this._highlightsHue = 30, this._highlightsDensity = 0, this._highlightsSaturation = 0, this._highlightsExposure = 0, this._midtonesHue = 30, this._midtonesDensity = 0, this._midtonesSaturation = 0, this._midtonesExposure = 0, this._shadowsHue = 30, this._shadowsDensity = 0, this._shadowsSaturation = 0, this._shadowsExposure = 0;
  }
  get globalHue() {
    return this._globalHue;
  }
  set globalHue(e) {
    this._globalHue = e, this._dirty = !0;
  }
  get globalDensity() {
    return this._globalDensity;
  }
  set globalDensity(e) {
    this._globalDensity = e, this._dirty = !0;
  }
  get globalSaturation() {
    return this._globalSaturation;
  }
  set globalSaturation(e) {
    this._globalSaturation = e, this._dirty = !0;
  }
  get globalExposure() {
    return this._globalExposure;
  }
  set globalExposure(e) {
    this._globalExposure = e, this._dirty = !0;
  }
  get highlightsHue() {
    return this._highlightsHue;
  }
  set highlightsHue(e) {
    this._highlightsHue = e, this._dirty = !0;
  }
  get highlightsDensity() {
    return this._highlightsDensity;
  }
  set highlightsDensity(e) {
    this._highlightsDensity = e, this._dirty = !0;
  }
  get highlightsSaturation() {
    return this._highlightsSaturation;
  }
  set highlightsSaturation(e) {
    this._highlightsSaturation = e, this._dirty = !0;
  }
  get highlightsExposure() {
    return this._highlightsExposure;
  }
  set highlightsExposure(e) {
    this._highlightsExposure = e, this._dirty = !0;
  }
  get midtonesHue() {
    return this._midtonesHue;
  }
  set midtonesHue(e) {
    this._midtonesHue = e, this._dirty = !0;
  }
  get midtonesDensity() {
    return this._midtonesDensity;
  }
  set midtonesDensity(e) {
    this._midtonesDensity = e, this._dirty = !0;
  }
  get midtonesSaturation() {
    return this._midtonesSaturation;
  }
  set midtonesSaturation(e) {
    this._midtonesSaturation = e, this._dirty = !0;
  }
  get midtonesExposure() {
    return this._midtonesExposure;
  }
  set midtonesExposure(e) {
    this._midtonesExposure = e, this._dirty = !0;
  }
  get shadowsHue() {
    return this._shadowsHue;
  }
  set shadowsHue(e) {
    this._shadowsHue = e, this._dirty = !0;
  }
  get shadowsDensity() {
    return this._shadowsDensity;
  }
  set shadowsDensity(e) {
    this._shadowsDensity = e, this._dirty = !0;
  }
  get shadowsSaturation() {
    return this._shadowsSaturation;
  }
  set shadowsSaturation(e) {
    this._shadowsSaturation = e, this._dirty = !0;
  }
  get shadowsExposure() {
    return this._shadowsExposure;
  }
  set shadowsExposure(e) {
    this._shadowsExposure = e, this._dirty = !0;
  }
  getClassName() {
    return "ColorCurves";
  }
  static Bind(e, t, i = "vCameraColorCurvePositive", s = "vCameraColorCurveNeutral", r = "vCameraColorCurveNegative") {
    e._dirty && (e._dirty = !1, e._getColorGradingDataToRef(e._globalHue, e._globalDensity, e._globalSaturation, e._globalExposure, e._globalCurve), e._getColorGradingDataToRef(e._highlightsHue, e._highlightsDensity, e._highlightsSaturation, e._highlightsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._highlightsCurve), e._getColorGradingDataToRef(e._midtonesHue, e._midtonesDensity, e._midtonesSaturation, e._midtonesExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._midtonesCurve), e._getColorGradingDataToRef(e._shadowsHue, e._shadowsDensity, e._shadowsSaturation, e._shadowsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._shadowsCurve), e._highlightsCurve.subtractToRef(e._midtonesCurve, e._positiveCurve), e._midtonesCurve.subtractToRef(e._shadowsCurve, e._negativeCurve)), t && (t.setFloat4(i, e._positiveCurve.r, e._positiveCurve.g, e._positiveCurve.b, e._positiveCurve.a), t.setFloat4(s, e._midtonesCurve.r, e._midtonesCurve.g, e._midtonesCurve.b, e._midtonesCurve.a), t.setFloat4(r, e._negativeCurve.r, e._negativeCurve.g, e._negativeCurve.b, e._negativeCurve.a));
  }
  static PrepareUniforms(e) {
    e.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative");
  }
  _getColorGradingDataToRef(e, t, i, s, r) {
    e != null && (e = ve._Clamp(e, 0, 360), t = ve._Clamp(t, -100, 100), i = ve._Clamp(i, -100, 100), s = ve._Clamp(s, -100, 100), t = ve._ApplyColorGradingSliderNonlinear(t), t *= 0.5, s = ve._ApplyColorGradingSliderNonlinear(s), t < 0 && (t *= -1, e = (e + 180) % 360), ve._FromHSBToRef(e, t, 50 + 0.25 * s, r), r.scaleToRef(2, r), r.a = 1 + 0.01 * i);
  }
  static _ApplyColorGradingSliderNonlinear(e) {
    e /= 100;
    let t = Math.abs(e);
    return t = Math.pow(t, 2), e < 0 && (t *= -1), t *= 100, t;
  }
  static _FromHSBToRef(e, t, i, s) {
    let r = ve._Clamp(e, 0, 360);
    const n = ve._Clamp(t / 100, 0, 1), a = ve._Clamp(i / 100, 0, 1);
    if (n === 0)
      s.r = a, s.g = a, s.b = a;
    else {
      r /= 60;
      const o = Math.floor(r), h = r - o, l = a * (1 - n), u = a * (1 - n * h), f = a * (1 - n * (1 - h));
      switch (o) {
        case 0:
          s.r = a, s.g = f, s.b = l;
          break;
        case 1:
          s.r = u, s.g = a, s.b = l;
          break;
        case 2:
          s.r = l, s.g = a, s.b = f;
          break;
        case 3:
          s.r = l, s.g = u, s.b = a;
          break;
        case 4:
          s.r = f, s.g = l, s.b = a;
          break;
        default:
          s.r = a, s.g = l, s.b = u;
          break;
      }
    }
    s.a = 1;
  }
  static _Clamp(e, t, i) {
    return Math.min(Math.max(e, t), i);
  }
  clone() {
    return ne.Clone(() => new ve(), this);
  }
  serialize() {
    return ne.Serialize(this);
  }
  static Parse(e) {
    return ne.Parse(() => new ve(), e, null, null);
  }
}
S([
  M()
], ve.prototype, "_globalHue", void 0);
S([
  M()
], ve.prototype, "_globalDensity", void 0);
S([
  M()
], ve.prototype, "_globalSaturation", void 0);
S([
  M()
], ve.prototype, "_globalExposure", void 0);
S([
  M()
], ve.prototype, "_highlightsHue", void 0);
S([
  M()
], ve.prototype, "_highlightsDensity", void 0);
S([
  M()
], ve.prototype, "_highlightsSaturation", void 0);
S([
  M()
], ve.prototype, "_highlightsExposure", void 0);
S([
  M()
], ve.prototype, "_midtonesHue", void 0);
S([
  M()
], ve.prototype, "_midtonesDensity", void 0);
S([
  M()
], ve.prototype, "_midtonesSaturation", void 0);
S([
  M()
], ve.prototype, "_midtonesExposure", void 0);
ne._ColorCurvesParser = ve.Parse;
class me {
  constructor() {
    this.colorCurves = new ve(), this._colorCurvesEnabled = !1, this._colorGradingEnabled = !1, this._colorGradingWithGreenDepth = !0, this._colorGradingBGR = !0, this._exposure = 1, this._toneMappingEnabled = !1, this._toneMappingType = me.TONEMAPPING_STANDARD, this._contrast = 1, this.vignetteStretch = 0, this.vignetteCentreX = 0, this.vignetteCentreY = 0, this.vignetteWeight = 1.5, this.vignetteColor = new ge(0, 0, 0, 0), this.vignetteCameraFov = 0.5, this._vignetteBlendMode = me.VIGNETTEMODE_MULTIPLY, this._vignetteEnabled = !1, this._ditheringEnabled = !1, this._ditheringIntensity = 1 / 255, this._skipFinalColorClamp = !1, this._applyByPostProcess = !1, this._isEnabled = !0, this.onUpdateParameters = new F();
  }
  get colorCurvesEnabled() {
    return this._colorCurvesEnabled;
  }
  set colorCurvesEnabled(e) {
    this._colorCurvesEnabled !== e && (this._colorCurvesEnabled = e, this._updateParameters());
  }
  get colorGradingTexture() {
    return this._colorGradingTexture;
  }
  set colorGradingTexture(e) {
    this._colorGradingTexture !== e && (this._colorGradingTexture = e, this._updateParameters());
  }
  get colorGradingEnabled() {
    return this._colorGradingEnabled;
  }
  set colorGradingEnabled(e) {
    this._colorGradingEnabled !== e && (this._colorGradingEnabled = e, this._updateParameters());
  }
  get colorGradingWithGreenDepth() {
    return this._colorGradingWithGreenDepth;
  }
  set colorGradingWithGreenDepth(e) {
    this._colorGradingWithGreenDepth !== e && (this._colorGradingWithGreenDepth = e, this._updateParameters());
  }
  get colorGradingBGR() {
    return this._colorGradingBGR;
  }
  set colorGradingBGR(e) {
    this._colorGradingBGR !== e && (this._colorGradingBGR = e, this._updateParameters());
  }
  get exposure() {
    return this._exposure;
  }
  set exposure(e) {
    this._exposure !== e && (this._exposure = e, this._updateParameters());
  }
  get toneMappingEnabled() {
    return this._toneMappingEnabled;
  }
  set toneMappingEnabled(e) {
    this._toneMappingEnabled !== e && (this._toneMappingEnabled = e, this._updateParameters());
  }
  get toneMappingType() {
    return this._toneMappingType;
  }
  set toneMappingType(e) {
    this._toneMappingType !== e && (this._toneMappingType = e, this._updateParameters());
  }
  get contrast() {
    return this._contrast;
  }
  set contrast(e) {
    this._contrast !== e && (this._contrast = e, this._updateParameters());
  }
  get vignetteBlendMode() {
    return this._vignetteBlendMode;
  }
  set vignetteBlendMode(e) {
    this._vignetteBlendMode !== e && (this._vignetteBlendMode = e, this._updateParameters());
  }
  get vignetteEnabled() {
    return this._vignetteEnabled;
  }
  set vignetteEnabled(e) {
    this._vignetteEnabled !== e && (this._vignetteEnabled = e, this._updateParameters());
  }
  get ditheringEnabled() {
    return this._ditheringEnabled;
  }
  set ditheringEnabled(e) {
    this._ditheringEnabled !== e && (this._ditheringEnabled = e, this._updateParameters());
  }
  get ditheringIntensity() {
    return this._ditheringIntensity;
  }
  set ditheringIntensity(e) {
    this._ditheringIntensity !== e && (this._ditheringIntensity = e, this._updateParameters());
  }
  get skipFinalColorClamp() {
    return this._skipFinalColorClamp;
  }
  set skipFinalColorClamp(e) {
    this._skipFinalColorClamp !== e && (this._skipFinalColorClamp = e, this._updateParameters());
  }
  get applyByPostProcess() {
    return this._applyByPostProcess;
  }
  set applyByPostProcess(e) {
    this._applyByPostProcess !== e && (this._applyByPostProcess = e, this._updateParameters());
  }
  get isEnabled() {
    return this._isEnabled;
  }
  set isEnabled(e) {
    this._isEnabled !== e && (this._isEnabled = e, this._updateParameters());
  }
  _updateParameters() {
    this.onUpdateParameters.notifyObservers(this);
  }
  getClassName() {
    return "ImageProcessingConfiguration";
  }
  static PrepareUniforms(e, t) {
    t.EXPOSURE && e.push("exposureLinear"), t.CONTRAST && e.push("contrast"), t.COLORGRADING && e.push("colorTransformSettings"), (t.VIGNETTE || t.DITHER) && e.push("vInverseScreenSize"), t.VIGNETTE && (e.push("vignetteSettings1"), e.push("vignetteSettings2")), t.COLORCURVES && ve.PrepareUniforms(e), t.DITHER && e.push("ditherIntensity");
  }
  static PrepareSamplers(e, t) {
    t.COLORGRADING && e.push("txColorTransform");
  }
  prepareDefines(e, t = !1) {
    if (t !== this.applyByPostProcess || !this._isEnabled) {
      e.VIGNETTE = !1, e.TONEMAPPING = !1, e.TONEMAPPING_ACES = !1, e.CONTRAST = !1, e.EXPOSURE = !1, e.COLORCURVES = !1, e.COLORGRADING = !1, e.COLORGRADING3D = !1, e.DITHER = !1, e.IMAGEPROCESSING = !1, e.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp, e.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;
      return;
    }
    switch (e.VIGNETTE = this.vignetteEnabled, e.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === me._VIGNETTEMODE_MULTIPLY, e.VIGNETTEBLENDMODEOPAQUE = !e.VIGNETTEBLENDMODEMULTIPLY, e.TONEMAPPING = this.toneMappingEnabled, this._toneMappingType) {
      case me.TONEMAPPING_ACES:
        e.TONEMAPPING_ACES = !0;
        break;
      default:
        e.TONEMAPPING_ACES = !1;
        break;
    }
    e.CONTRAST = this.contrast !== 1, e.EXPOSURE = this.exposure !== 1, e.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves, e.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture, e.COLORGRADING ? e.COLORGRADING3D = this.colorGradingTexture.is3D : e.COLORGRADING3D = !1, e.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth, e.SAMPLER3DBGRMAP = this.colorGradingBGR, e.DITHER = this._ditheringEnabled, e.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess, e.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp, e.IMAGEPROCESSING = e.VIGNETTE || e.TONEMAPPING || e.CONTRAST || e.EXPOSURE || e.COLORCURVES || e.COLORGRADING || e.DITHER;
  }
  isReady() {
    return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();
  }
  bind(e, t) {
    if (this._colorCurvesEnabled && this.colorCurves && ve.Bind(this.colorCurves, e), this._vignetteEnabled || this._ditheringEnabled) {
      const i = 1 / e.getEngine().getRenderWidth(), s = 1 / e.getEngine().getRenderHeight();
      if (e.setFloat2("vInverseScreenSize", i, s), this._ditheringEnabled && e.setFloat("ditherIntensity", 0.5 * this._ditheringIntensity), this._vignetteEnabled) {
        const r = t != null ? t : s / i;
        let n = Math.tan(this.vignetteCameraFov * 0.5), a = n * r;
        const o = Math.sqrt(a * n);
        a = U.Mix(a, o, this.vignetteStretch), n = U.Mix(n, o, this.vignetteStretch), e.setFloat4("vignetteSettings1", a, n, -a * this.vignetteCentreX, -n * this.vignetteCentreY);
        const h = -2 * this.vignetteWeight;
        e.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, h);
      }
    }
    if (e.setFloat("exposureLinear", this.exposure), e.setFloat("contrast", this.contrast), this.colorGradingTexture) {
      e.setTexture("txColorTransform", this.colorGradingTexture);
      const i = this.colorGradingTexture.getSize().height;
      e.setFloat4(
        "colorTransformSettings",
        (i - 1) / i,
        0.5 / i,
        i,
        this.colorGradingTexture.level
      );
    }
  }
  clone() {
    return ne.Clone(() => new me(), this);
  }
  serialize() {
    return ne.Serialize(this);
  }
  static Parse(e) {
    return ne.Parse(() => new me(), e, null, null);
  }
  static get VIGNETTEMODE_MULTIPLY() {
    return this._VIGNETTEMODE_MULTIPLY;
  }
  static get VIGNETTEMODE_OPAQUE() {
    return this._VIGNETTEMODE_OPAQUE;
  }
}
me.TONEMAPPING_STANDARD = 0;
me.TONEMAPPING_ACES = 1;
me._VIGNETTEMODE_MULTIPLY = 0;
me._VIGNETTEMODE_OPAQUE = 1;
S([
  gn()
], me.prototype, "colorCurves", void 0);
S([
  M()
], me.prototype, "_colorCurvesEnabled", void 0);
S([
  Et("colorGradingTexture")
], me.prototype, "_colorGradingTexture", void 0);
S([
  M()
], me.prototype, "_colorGradingEnabled", void 0);
S([
  M()
], me.prototype, "_colorGradingWithGreenDepth", void 0);
S([
  M()
], me.prototype, "_colorGradingBGR", void 0);
S([
  M()
], me.prototype, "_exposure", void 0);
S([
  M()
], me.prototype, "_toneMappingEnabled", void 0);
S([
  M()
], me.prototype, "_toneMappingType", void 0);
S([
  M()
], me.prototype, "_contrast", void 0);
S([
  M()
], me.prototype, "vignetteStretch", void 0);
S([
  M()
], me.prototype, "vignetteCentreX", void 0);
S([
  M()
], me.prototype, "vignetteCentreY", void 0);
S([
  M()
], me.prototype, "vignetteWeight", void 0);
S([
  Mr()
], me.prototype, "vignetteColor", void 0);
S([
  M()
], me.prototype, "vignetteCameraFov", void 0);
S([
  M()
], me.prototype, "_vignetteBlendMode", void 0);
S([
  M()
], me.prototype, "_vignetteEnabled", void 0);
S([
  M()
], me.prototype, "_ditheringEnabled", void 0);
S([
  M()
], me.prototype, "_ditheringIntensity", void 0);
S([
  M()
], me.prototype, "_skipFinalColorClamp", void 0);
S([
  M()
], me.prototype, "_applyByPostProcess", void 0);
S([
  M()
], me.prototype, "_isEnabled", void 0);
ne._ImageProcessingConfigurationParser = me.Parse;
le.prototype.createUniformBuffer = function(c) {
  const e = this._gl.createBuffer();
  if (!e)
    throw new Error("Unable to create uniform buffer");
  const t = new yi(e);
  return this.bindUniformBuffer(t), c instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, c, this._gl.STATIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(c), this._gl.STATIC_DRAW), this.bindUniformBuffer(null), t.references = 1, t;
};
le.prototype.createDynamicUniformBuffer = function(c) {
  const e = this._gl.createBuffer();
  if (!e)
    throw new Error("Unable to create dynamic uniform buffer");
  const t = new yi(e);
  return this.bindUniformBuffer(t), c instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, c, this._gl.DYNAMIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(c), this._gl.DYNAMIC_DRAW), this.bindUniformBuffer(null), t.references = 1, t;
};
le.prototype.updateUniformBuffer = function(c, e, t, i) {
  this.bindUniformBuffer(c), t === void 0 && (t = 0), i === void 0 ? e instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, t, e) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, t, new Float32Array(e)) : e instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, e.subarray(t, t + i)) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(e).subarray(t, t + i)), this.bindUniformBuffer(null);
};
le.prototype.bindUniformBuffer = function(c) {
  this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, c ? c.underlyingResource : null);
};
le.prototype.bindUniformBufferBase = function(c, e, t) {
  this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, e, c ? c.underlyingResource : null);
};
le.prototype.bindUniformBlock = function(c, e, t) {
  const i = c.program, s = this._gl.getUniformBlockIndex(i, e);
  s !== 4294967295 && this._gl.uniformBlockBinding(i, s, t);
};
class G {
  constructor(e, t, i, s, r = !1) {
    this._valueCache = {}, this._engine = e, this._noUBO = !e.supportsUniformBuffers || r, this._dynamic = i, this._name = s != null ? s : "no-name", this._data = t || [], this._uniformLocations = {}, this._uniformSizes = {}, this._uniformArraySizes = {}, this._uniformLocationPointer = 0, this._needSync = !1, this._engine._features.trackUbosInFrame && (this._buffers = [], this._bufferIndex = -1, this._createBufferOnWrite = !1, this._currentFrameId = 0), this._noUBO ? (this.updateMatrix3x3 = this._updateMatrix3x3ForEffect, this.updateMatrix2x2 = this._updateMatrix2x2ForEffect, this.updateFloat = this._updateFloatForEffect, this.updateFloat2 = this._updateFloat2ForEffect, this.updateFloat3 = this._updateFloat3ForEffect, this.updateFloat4 = this._updateFloat4ForEffect, this.updateFloatArray = this._updateFloatArrayForEffect, this.updateArray = this._updateArrayForEffect, this.updateIntArray = this._updateIntArrayForEffect, this.updateMatrix = this._updateMatrixForEffect, this.updateMatrices = this._updateMatricesForEffect, this.updateVector3 = this._updateVector3ForEffect, this.updateVector4 = this._updateVector4ForEffect, this.updateColor3 = this._updateColor3ForEffect, this.updateColor4 = this._updateColor4ForEffect, this.updateDirectColor4 = this._updateDirectColor4ForEffect, this.updateInt = this._updateIntForEffect, this.updateInt2 = this._updateInt2ForEffect, this.updateInt3 = this._updateInt3ForEffect, this.updateInt4 = this._updateInt4ForEffect) : (this._engine._uniformBuffers.push(this), this.updateMatrix3x3 = this._updateMatrix3x3ForUniform, this.updateMatrix2x2 = this._updateMatrix2x2ForUniform, this.updateFloat = this._updateFloatForUniform, this.updateFloat2 = this._updateFloat2ForUniform, this.updateFloat3 = this._updateFloat3ForUniform, this.updateFloat4 = this._updateFloat4ForUniform, this.updateFloatArray = this._updateFloatArrayForUniform, this.updateArray = this._updateArrayForUniform, this.updateIntArray = this._updateIntArrayForUniform, this.updateMatrix = this._updateMatrixForUniform, this.updateMatrices = this._updateMatricesForUniform, this.updateVector3 = this._updateVector3ForUniform, this.updateVector4 = this._updateVector4ForUniform, this.updateColor3 = this._updateColor3ForUniform, this.updateColor4 = this._updateColor4ForUniform, this.updateDirectColor4 = this._updateDirectColor4ForUniform, this.updateInt = this._updateIntForUniform, this.updateInt2 = this._updateInt2ForUniform, this.updateInt3 = this._updateInt3ForUniform, this.updateInt4 = this._updateInt4ForUniform);
  }
  get useUbo() {
    return !this._noUBO;
  }
  get isSync() {
    return !this._needSync;
  }
  isDynamic() {
    return this._dynamic !== void 0;
  }
  getData() {
    return this._bufferData;
  }
  getBuffer() {
    return this._buffer;
  }
  _fillAlignment(e) {
    let t;
    if (e <= 2 ? t = e : t = 4, this._uniformLocationPointer % t !== 0) {
      const i = this._uniformLocationPointer;
      this._uniformLocationPointer += t - this._uniformLocationPointer % t;
      const s = this._uniformLocationPointer - i;
      for (let r = 0; r < s; r++)
        this._data.push(0);
    }
  }
  addUniform(e, t, i = 0) {
    if (this._noUBO || this._uniformLocations[e] !== void 0)
      return;
    let s;
    if (i > 0) {
      if (t instanceof Array)
        throw "addUniform should not be use with Array in UBO: " + e;
      if (this._fillAlignment(4), this._uniformArraySizes[e] = { strideSize: t, arraySize: i }, t == 16)
        t = t * i;
      else {
        const n = (4 - t) * i;
        t = t * i + n;
      }
      s = [];
      for (let r = 0; r < t; r++)
        s.push(0);
    } else {
      if (t instanceof Array)
        s = t, t = s.length;
      else {
        t = t, s = [];
        for (let r = 0; r < t; r++)
          s.push(0);
      }
      this._fillAlignment(t);
    }
    this._uniformSizes[e] = t, this._uniformLocations[e] = this._uniformLocationPointer, this._uniformLocationPointer += t;
    for (let r = 0; r < t; r++)
      this._data.push(s[r]);
    this._needSync = !0;
  }
  addMatrix(e, t) {
    this.addUniform(e, Array.prototype.slice.call(t.toArray()));
  }
  addFloat2(e, t, i) {
    const s = [t, i];
    this.addUniform(e, s);
  }
  addFloat3(e, t, i, s) {
    const r = [t, i, s];
    this.addUniform(e, r);
  }
  addColor3(e, t) {
    const i = [t.r, t.g, t.b];
    this.addUniform(e, i);
  }
  addColor4(e, t, i) {
    const s = [t.r, t.g, t.b, i];
    this.addUniform(e, s);
  }
  addVector3(e, t) {
    const i = [t.x, t.y, t.z];
    this.addUniform(e, i);
  }
  addMatrix3x3(e) {
    this.addUniform(e, 12);
  }
  addMatrix2x2(e) {
    this.addUniform(e, 8);
  }
  create() {
    this._noUBO || this._buffer || (this._fillAlignment(4), this._bufferData = new Float32Array(this._data), this._rebuild(), this._needSync = !0);
  }
  _rebuild() {
    this._noUBO || !this._bufferData || (this._dynamic ? this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData) : this._buffer = this._engine.createUniformBuffer(this._bufferData), this._engine._features.trackUbosInFrame && (this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : void 0]), this._bufferIndex = this._buffers.length - 1, this._createBufferOnWrite = !1));
  }
  get _numBuffers() {
    return this._buffers.length;
  }
  get _indexBuffer() {
    return this._bufferIndex;
  }
  get name() {
    return this._name;
  }
  _buffersEqual(e, t) {
    for (let i = 0; i < e.length; ++i)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  _copyBuffer(e, t) {
    for (let i = 0; i < e.length; ++i)
      t[i] = e[i];
  }
  update() {
    if (!this._noUBO) {
      if (this.bindUniformBuffer(), !this._buffer) {
        this.create();
        return;
      }
      if (!this._dynamic && !this._needSync) {
        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
        return;
      }
      if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1])
        if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) {
          this._needSync = !1, this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
          return;
        } else
          this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]);
      this._engine.updateUniformBuffer(this._buffer, this._bufferData), this._engine._features._collectUbosUpdatedInFrame && (G._UpdatedUbosInFrame[this._name] || (G._UpdatedUbosInFrame[this._name] = 0), G._UpdatedUbosInFrame[this._name]++), this._needSync = !1, this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
    }
  }
  _createNewBuffer() {
    this._bufferIndex + 1 < this._buffers.length ? (this._bufferIndex++, this._buffer = this._buffers[this._bufferIndex][0], this._createBufferOnWrite = !1, this._needSync = !0) : this._rebuild();
  }
  _checkNewFrame() {
    this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId && (this._currentFrameId = this._engine.frameId, this._createBufferOnWrite = !1, this._buffers && this._buffers.length > 0 ? (this._needSync = this._bufferIndex !== 0, this._bufferIndex = 0, this._buffer = this._buffers[this._bufferIndex][0]) : this._bufferIndex = -1);
  }
  updateUniform(e, t, i) {
    this._checkNewFrame();
    let s = this._uniformLocations[e];
    if (s === void 0) {
      if (this._buffer) {
        w.Error("Cannot add an uniform after UBO has been created.");
        return;
      }
      this.addUniform(e, i), s = this._uniformLocations[e];
    }
    if (this._buffer || this.create(), this._dynamic)
      for (let r = 0; r < i; r++)
        this._bufferData[s + r] = t[r];
    else {
      let r = !1;
      for (let n = 0; n < i; n++)
        (i === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[s + n] !== U.FloatRound(t[n])) && (r = !0, this._createBufferOnWrite && this._createNewBuffer(), this._bufferData[s + n] = t[n]);
      this._needSync = this._needSync || r;
    }
  }
  updateUniformArray(e, t, i) {
    this._checkNewFrame();
    const s = this._uniformLocations[e];
    if (s === void 0) {
      w.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform.");
      return;
    }
    this._buffer || this.create();
    const r = this._uniformArraySizes[e];
    if (this._dynamic)
      for (let n = 0; n < i; n++)
        this._bufferData[s + n] = t[n];
    else {
      let n = !1, a = 0, o = 0;
      for (let h = 0; h < i; h++)
        if (this._bufferData[s + o * 4 + a] !== U.FloatRound(t[h]) && (n = !0, this._createBufferOnWrite && this._createNewBuffer(), this._bufferData[s + o * 4 + a] = t[h]), a++, a === r.strideSize) {
          for (; a < 4; a++)
            this._bufferData[s + o * 4 + a] = 0;
          a = 0, o++;
        }
      this._needSync = this._needSync || n;
    }
  }
  _cacheMatrix(e, t) {
    this._checkNewFrame();
    const i = this._valueCache[e], s = t.updateFlag;
    return i !== void 0 && i === s ? !1 : (this._valueCache[e] = s, !0);
  }
  _updateMatrix3x3ForUniform(e, t) {
    for (let i = 0; i < 3; i++)
      G._TempBuffer[i * 4] = t[i * 3], G._TempBuffer[i * 4 + 1] = t[i * 3 + 1], G._TempBuffer[i * 4 + 2] = t[i * 3 + 2], G._TempBuffer[i * 4 + 3] = 0;
    this.updateUniform(e, G._TempBuffer, 12);
  }
  _updateMatrix3x3ForEffect(e, t) {
    this._currentEffect.setMatrix3x3(e, t);
  }
  _updateMatrix2x2ForEffect(e, t) {
    this._currentEffect.setMatrix2x2(e, t);
  }
  _updateMatrix2x2ForUniform(e, t) {
    for (let i = 0; i < 2; i++)
      G._TempBuffer[i * 4] = t[i * 2], G._TempBuffer[i * 4 + 1] = t[i * 2 + 1], G._TempBuffer[i * 4 + 2] = 0, G._TempBuffer[i * 4 + 3] = 0;
    this.updateUniform(e, G._TempBuffer, 8);
  }
  _updateFloatForEffect(e, t) {
    this._currentEffect.setFloat(e, t);
  }
  _updateFloatForUniform(e, t) {
    G._TempBuffer[0] = t, this.updateUniform(e, G._TempBuffer, 1);
  }
  _updateFloat2ForEffect(e, t, i, s = "") {
    this._currentEffect.setFloat2(e + s, t, i);
  }
  _updateFloat2ForUniform(e, t, i) {
    G._TempBuffer[0] = t, G._TempBuffer[1] = i, this.updateUniform(e, G._TempBuffer, 2);
  }
  _updateFloat3ForEffect(e, t, i, s, r = "") {
    this._currentEffect.setFloat3(e + r, t, i, s);
  }
  _updateFloat3ForUniform(e, t, i, s) {
    G._TempBuffer[0] = t, G._TempBuffer[1] = i, G._TempBuffer[2] = s, this.updateUniform(e, G._TempBuffer, 3);
  }
  _updateFloat4ForEffect(e, t, i, s, r, n = "") {
    this._currentEffect.setFloat4(e + n, t, i, s, r);
  }
  _updateFloat4ForUniform(e, t, i, s, r) {
    G._TempBuffer[0] = t, G._TempBuffer[1] = i, G._TempBuffer[2] = s, G._TempBuffer[3] = r, this.updateUniform(e, G._TempBuffer, 4);
  }
  _updateFloatArrayForEffect(e, t) {
    this._currentEffect.setFloatArray(e, t);
  }
  _updateFloatArrayForUniform(e, t) {
    this.updateUniformArray(e, t, t.length);
  }
  _updateArrayForEffect(e, t) {
    this._currentEffect.setArray(e, t);
  }
  _updateArrayForUniform(e, t) {
    this.updateUniformArray(e, t, t.length);
  }
  _updateIntArrayForEffect(e, t) {
    this._currentEffect.setIntArray(e, t);
  }
  _updateIntArrayForUniform(e, t) {
    G._TempBufferInt32View.set(t), this.updateUniformArray(e, G._TempBuffer, t.length);
  }
  _updateMatrixForEffect(e, t) {
    this._currentEffect.setMatrix(e, t);
  }
  _updateMatrixForUniform(e, t) {
    this._cacheMatrix(e, t) && this.updateUniform(e, t.toArray(), 16);
  }
  _updateMatricesForEffect(e, t) {
    this._currentEffect.setMatrices(e, t);
  }
  _updateMatricesForUniform(e, t) {
    this.updateUniform(e, t, t.length);
  }
  _updateVector3ForEffect(e, t) {
    this._currentEffect.setVector3(e, t);
  }
  _updateVector3ForUniform(e, t) {
    G._TempBuffer[0] = t.x, G._TempBuffer[1] = t.y, G._TempBuffer[2] = t.z, this.updateUniform(e, G._TempBuffer, 3);
  }
  _updateVector4ForEffect(e, t) {
    this._currentEffect.setVector4(e, t);
  }
  _updateVector4ForUniform(e, t) {
    G._TempBuffer[0] = t.x, G._TempBuffer[1] = t.y, G._TempBuffer[2] = t.z, G._TempBuffer[3] = t.w, this.updateUniform(e, G._TempBuffer, 4);
  }
  _updateColor3ForEffect(e, t, i = "") {
    this._currentEffect.setColor3(e + i, t);
  }
  _updateColor3ForUniform(e, t) {
    G._TempBuffer[0] = t.r, G._TempBuffer[1] = t.g, G._TempBuffer[2] = t.b, this.updateUniform(e, G._TempBuffer, 3);
  }
  _updateColor4ForEffect(e, t, i, s = "") {
    this._currentEffect.setColor4(e + s, t, i);
  }
  _updateDirectColor4ForEffect(e, t, i = "") {
    this._currentEffect.setDirectColor4(e + i, t);
  }
  _updateColor4ForUniform(e, t, i) {
    G._TempBuffer[0] = t.r, G._TempBuffer[1] = t.g, G._TempBuffer[2] = t.b, G._TempBuffer[3] = i, this.updateUniform(e, G._TempBuffer, 4);
  }
  _updateDirectColor4ForUniform(e, t) {
    G._TempBuffer[0] = t.r, G._TempBuffer[1] = t.g, G._TempBuffer[2] = t.b, G._TempBuffer[3] = t.a, this.updateUniform(e, G._TempBuffer, 4);
  }
  _updateIntForEffect(e, t, i = "") {
    this._currentEffect.setInt(e + i, t);
  }
  _updateIntForUniform(e, t) {
    G._TempBufferInt32View[0] = t, this.updateUniform(e, G._TempBuffer, 1);
  }
  _updateInt2ForEffect(e, t, i, s = "") {
    this._currentEffect.setInt2(e + s, t, i);
  }
  _updateInt2ForUniform(e, t, i) {
    G._TempBufferInt32View[0] = t, G._TempBufferInt32View[1] = i, this.updateUniform(e, G._TempBuffer, 2);
  }
  _updateInt3ForEffect(e, t, i, s, r = "") {
    this._currentEffect.setInt3(e + r, t, i, s);
  }
  _updateInt3ForUniform(e, t, i, s) {
    G._TempBufferInt32View[0] = t, G._TempBufferInt32View[1] = i, G._TempBufferInt32View[2] = s, this.updateUniform(e, G._TempBuffer, 3);
  }
  _updateInt4ForEffect(e, t, i, s, r, n = "") {
    this._currentEffect.setInt4(e + n, t, i, s, r);
  }
  _updateInt4ForUniform(e, t, i, s, r) {
    G._TempBufferInt32View[0] = t, G._TempBufferInt32View[1] = i, G._TempBufferInt32View[2] = s, G._TempBufferInt32View[3] = r, this.updateUniform(e, G._TempBuffer, 4);
  }
  setTexture(e, t) {
    this._currentEffect.setTexture(e, t);
  }
  updateUniformDirectly(e, t) {
    this.updateUniform(e, t, t.length), this.update();
  }
  bindToEffect(e, t) {
    this._currentEffect = e, this._currentEffectName = t;
  }
  bindUniformBuffer() {
    !this._noUBO && this._buffer && this._currentEffect && this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);
  }
  unbindEffect() {
    this._currentEffect = void 0, this._currentEffectName = void 0;
  }
  setDataBuffer(e) {
    if (!this._buffers)
      return this._buffer === e;
    for (let t = 0; t < this._buffers.length; ++t)
      if (this._buffers[t][0] === e)
        return this._bufferIndex = t, this._buffer = e, this._createBufferOnWrite = !1, this._currentEffect = void 0, !0;
    return !1;
  }
  dispose() {
    if (this._noUBO)
      return;
    const e = this._engine._uniformBuffers, t = e.indexOf(this);
    if (t !== -1 && (e[t] = e[e.length - 1], e.pop()), this._engine._features.trackUbosInFrame && this._buffers)
      for (let i = 0; i < this._buffers.length; ++i) {
        const s = this._buffers[i][0];
        this._engine._releaseBuffer(s);
      }
    else
      this._buffer && this._engine._releaseBuffer(this._buffer) && (this._buffer = null);
  }
}
G._UpdatedUbosInFrame = {};
G._MAX_UNIFORM_SIZE = 256;
G._TempBuffer = new Float32Array(G._MAX_UNIFORM_SIZE);
G._TempBufferInt32View = new Uint32Array(G._TempBuffer.buffer);
class ji {
  constructor(e, t, i, s = 0, r = !1, n = !1, a = !1, o) {
    this._isAlreadyOwned = !1, e.getScene ? this._engine = e.getScene().getEngine() : this._engine = e, this._updatable = i, this._instanced = n, this._divisor = o || 1, t instanceof wi ? (this._data = null, this._buffer = t) : (this._data = t, this._buffer = null), this.byteStride = a ? s : s * Float32Array.BYTES_PER_ELEMENT, r || this.create();
  }
  createVertexBuffer(e, t, i, s, r, n = !1, a) {
    const o = n ? t : t * Float32Array.BYTES_PER_ELEMENT, h = s ? n ? s : s * Float32Array.BYTES_PER_ELEMENT : this.byteStride;
    return new p(this._engine, this, e, this._updatable, !0, h, r === void 0 ? this._instanced : r, o, i, void 0, void 0, !0, this._divisor || a);
  }
  isUpdatable() {
    return this._updatable;
  }
  getData() {
    return this._data;
  }
  getBuffer() {
    return this._buffer;
  }
  getStrideSize() {
    return this.byteStride / Float32Array.BYTES_PER_ELEMENT;
  }
  create(e = null) {
    !e && this._buffer || (e = e || this._data, e && (this._buffer ? this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e), this._data = e) : this._updatable ? (this._buffer = this._engine.createDynamicVertexBuffer(e), this._data = e) : this._buffer = this._engine.createVertexBuffer(e)));
  }
  _rebuild() {
    this._buffer = null, this.create(this._data);
  }
  update(e) {
    this.create(e);
  }
  updateDirectly(e, t, i, s = !1) {
    !this._buffer || this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e, s ? t : t * Float32Array.BYTES_PER_ELEMENT, i ? i * this.byteStride : void 0), t === 0 && i === void 0 ? this._data = e : this._data = null);
  }
  _increaseReferences() {
    if (!!this._buffer) {
      if (!this._isAlreadyOwned) {
        this._isAlreadyOwned = !0;
        return;
      }
      this._buffer.references++;
    }
  }
  dispose() {
    !this._buffer || this._engine._releaseBuffer(this._buffer) && (this._buffer = null, this._data = null);
  }
}
class p {
  constructor(e, t, i, s, r, n, a, o, h, l, u = !1, f = !1, d = 1, _ = !1) {
    if (t instanceof ji ? (this._buffer = t, this._ownsBuffer = _) : (this._buffer = new ji(e, t, s, n, r, a, f), this._ownsBuffer = !0), this.uniqueId = p._Counter++, this._kind = i, l == null) {
      const m = this.getData();
      this.type = p.FLOAT, m instanceof Int8Array ? this.type = p.BYTE : m instanceof Uint8Array ? this.type = p.UNSIGNED_BYTE : m instanceof Int16Array ? this.type = p.SHORT : m instanceof Uint16Array ? this.type = p.UNSIGNED_SHORT : m instanceof Int32Array ? this.type = p.INT : m instanceof Uint32Array && (this.type = p.UNSIGNED_INT);
    } else
      this.type = l;
    const E = p.GetTypeByteLength(this.type);
    f ? (this._size = h || (n ? n / E : p.DeduceStride(i)), this.byteStride = n || this._buffer.byteStride || this._size * E, this.byteOffset = o || 0) : (this._size = h || n || p.DeduceStride(i), this.byteStride = n ? n * E : this._buffer.byteStride || this._size * E, this.byteOffset = (o || 0) * E), this.normalized = u, this._instanced = a !== void 0 ? a : !1, this._instanceDivisor = a ? d : 0, this._computeHashCode();
  }
  get instanceDivisor() {
    return this._instanceDivisor;
  }
  set instanceDivisor(e) {
    this._instanceDivisor = e, e == 0 ? this._instanced = !1 : this._instanced = !0, this._computeHashCode();
  }
  _computeHashCode() {
    this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + (this.byteStride << 12);
  }
  _rebuild() {
    !this._buffer || this._buffer._rebuild();
  }
  getKind() {
    return this._kind;
  }
  isUpdatable() {
    return this._buffer.isUpdatable();
  }
  getData() {
    return this._buffer.getData();
  }
  getFloatData(e, t) {
    const i = this.getData();
    if (!i)
      return null;
    const s = this.getSize() * p.GetTypeByteLength(this.type), r = e * this.getSize();
    if (this.type !== p.FLOAT || this.byteStride !== s) {
      const n = new Float32Array(r);
      return this.forEach(r, (a, o) => n[o] = a), n;
    }
    if (!(i instanceof Array || i instanceof Float32Array) || this.byteOffset !== 0 || i.length !== r)
      if (i instanceof Array) {
        const n = this.byteOffset / 4;
        return i.slice(n, n + r);
      } else {
        if (i instanceof ArrayBuffer)
          return new Float32Array(i, this.byteOffset, r);
        {
          let n = i.byteOffset + this.byteOffset;
          if (t) {
            const o = new Float32Array(r), h = new Float32Array(i.buffer, n, r);
            return o.set(h), o;
          }
          const a = n % 4;
          return a && (n = Math.max(0, n - a)), new Float32Array(i.buffer, n, r);
        }
      }
    return t ? i.slice() : i;
  }
  getBuffer() {
    return this._buffer.getBuffer();
  }
  getStrideSize() {
    return this.byteStride / p.GetTypeByteLength(this.type);
  }
  getOffset() {
    return this.byteOffset / p.GetTypeByteLength(this.type);
  }
  getSize(e = !1) {
    return e ? this._size * p.GetTypeByteLength(this.type) : this._size;
  }
  getIsInstanced() {
    return this._instanced;
  }
  getInstanceDivisor() {
    return this._instanceDivisor;
  }
  create(e) {
    this._buffer.create(e);
  }
  update(e) {
    this._buffer.update(e);
  }
  updateDirectly(e, t, i = !1) {
    this._buffer.updateDirectly(e, t, void 0, i);
  }
  dispose() {
    this._ownsBuffer && this._buffer.dispose();
  }
  forEach(e, t) {
    p.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, e, this.normalized, t);
  }
  static DeduceStride(e) {
    switch (e) {
      case p.UVKind:
      case p.UV2Kind:
      case p.UV3Kind:
      case p.UV4Kind:
      case p.UV5Kind:
      case p.UV6Kind:
        return 2;
      case p.NormalKind:
      case p.PositionKind:
        return 3;
      case p.ColorKind:
      case p.MatricesIndicesKind:
      case p.MatricesIndicesExtraKind:
      case p.MatricesWeightsKind:
      case p.MatricesWeightsExtraKind:
      case p.TangentKind:
        return 4;
      default:
        throw new Error("Invalid kind '" + e + "'");
    }
  }
  static GetTypeByteLength(e) {
    switch (e) {
      case p.BYTE:
      case p.UNSIGNED_BYTE:
        return 1;
      case p.SHORT:
      case p.UNSIGNED_SHORT:
        return 2;
      case p.INT:
      case p.UNSIGNED_INT:
      case p.FLOAT:
        return 4;
      default:
        throw new Error(`Invalid type '${e}'`);
    }
  }
  static ForEach(e, t, i, s, r, n, a, o) {
    if (e instanceof Array) {
      let h = t / 4;
      const l = i / 4;
      for (let u = 0; u < n; u += s) {
        for (let f = 0; f < s; f++)
          o(e[h + f], u + f);
        h += l;
      }
    } else {
      const h = e instanceof ArrayBuffer ? new DataView(e) : new DataView(e.buffer, e.byteOffset, e.byteLength), l = p.GetTypeByteLength(r);
      for (let u = 0; u < n; u += s) {
        let f = t;
        for (let d = 0; d < s; d++) {
          const _ = p._GetFloatValue(h, r, f, a);
          o(_, u + d), f += l;
        }
        t += i;
      }
    }
  }
  static _GetFloatValue(e, t, i, s) {
    switch (t) {
      case p.BYTE: {
        let r = e.getInt8(i);
        return s && (r = Math.max(r / 127, -1)), r;
      }
      case p.UNSIGNED_BYTE: {
        let r = e.getUint8(i);
        return s && (r = r / 255), r;
      }
      case p.SHORT: {
        let r = e.getInt16(i, !0);
        return s && (r = Math.max(r / 32767, -1)), r;
      }
      case p.UNSIGNED_SHORT: {
        let r = e.getUint16(i, !0);
        return s && (r = r / 65535), r;
      }
      case p.INT:
        return e.getInt32(i, !0);
      case p.UNSIGNED_INT:
        return e.getUint32(i, !0);
      case p.FLOAT:
        return e.getFloat32(i, !0);
      default:
        throw new Error(`Invalid component type ${t}`);
    }
  }
}
p._Counter = 0;
p.BYTE = 5120;
p.UNSIGNED_BYTE = 5121;
p.SHORT = 5122;
p.UNSIGNED_SHORT = 5123;
p.INT = 5124;
p.UNSIGNED_INT = 5125;
p.FLOAT = 5126;
p.PositionKind = "position";
p.NormalKind = "normal";
p.TangentKind = "tangent";
p.UVKind = "uv";
p.UV2Kind = "uv2";
p.UV3Kind = "uv3";
p.UV4Kind = "uv4";
p.UV5Kind = "uv5";
p.UV6Kind = "uv6";
p.ColorKind = "color";
p.ColorInstanceKind = "instanceColor";
p.MatricesIndicesKind = "matricesIndices";
p.MatricesWeightsKind = "matricesWeights";
p.MatricesIndicesExtraKind = "matricesIndicesExtra";
p.MatricesWeightsExtraKind = "matricesWeightsExtra";
class vt {
  constructor() {
    this._pickingUnavailable = !1, this.hit = !1, this.distance = 0, this.pickedPoint = null, this.pickedMesh = null, this.bu = 0, this.bv = 0, this.faceId = -1, this.subMeshFaceId = -1, this.subMeshId = 0, this.pickedSprite = null, this.thinInstanceIndex = -1, this.ray = null, this.originMesh = null, this.aimTransform = null, this.gripTransform = null;
  }
  getNormal(e = !1, t = !0) {
    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(p.NormalKind))
      return null;
    const i = this.pickedMesh.getIndices();
    if (!i)
      return null;
    let s;
    if (t) {
      const r = this.pickedMesh.getVerticesData(p.NormalKind);
      let n = g.FromArray(r, i[this.faceId * 3] * 3), a = g.FromArray(r, i[this.faceId * 3 + 1] * 3), o = g.FromArray(r, i[this.faceId * 3 + 2] * 3);
      n = n.scale(this.bu), a = a.scale(this.bv), o = o.scale(1 - this.bu - this.bv), s = new g(n.x + a.x + o.x, n.y + a.y + o.y, n.z + a.z + o.z);
    } else {
      const r = this.pickedMesh.getVerticesData(p.PositionKind), n = g.FromArray(r, i[this.faceId * 3] * 3), a = g.FromArray(r, i[this.faceId * 3 + 1] * 3), o = g.FromArray(r, i[this.faceId * 3 + 2] * 3), h = n.subtract(a), l = o.subtract(a);
      s = g.Cross(h, l);
    }
    if (e) {
      let r = this.pickedMesh.getWorldMatrix();
      this.pickedMesh.nonUniformScaling && (D.Matrix[0].copyFrom(r), r = D.Matrix[0], r.setTranslationFromFloats(0, 0, 0), r.invert(), r.transposeToRef(D.Matrix[1]), r = D.Matrix[1]), s = g.TransformNormal(s, r);
    }
    return s.normalize(), s;
  }
  getTextureCoordinates() {
    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(p.UVKind))
      return null;
    const e = this.pickedMesh.getIndices();
    if (!e)
      return null;
    const t = this.pickedMesh.getVerticesData(p.UVKind);
    if (!t)
      return null;
    let i = ee.FromArray(t, e[this.faceId * 3] * 2), s = ee.FromArray(t, e[this.faceId * 3 + 1] * 2), r = ee.FromArray(t, e[this.faceId * 3 + 2] * 2);
    return i = i.scale(this.bu), s = s.scale(this.bv), r = r.scale(1 - this.bu - this.bv), new ee(i.x + s.x + r.x, i.y + s.y + r.y);
  }
}
class ze {
  constructor(e, t, i, s, r, n) {
    this.source = e, this.pointerX = t, this.pointerY = i, this.meshUnderPointer = s, this.sourceEvent = r, this.additionalData = n;
  }
  static CreateNew(e, t, i) {
    const s = e.getScene();
    return new ze(e, s.pointerX, s.pointerY, s.meshUnderPointer || e, t, i);
  }
  static CreateNewFromSprite(e, t, i, s) {
    return new ze(e, t.pointerX, t.pointerY, t.meshUnderPointer, i, s);
  }
  static CreateNewFromScene(e, t) {
    return new ze(null, e.pointerX, e.pointerY, e.meshUnderPointer, t);
  }
  static CreateNewFromPrimitive(e, t, i, s) {
    return new ze(e, t.x, t.y, null, i, s);
  }
}
class Qi {
  constructor(e) {
    this._vertexBuffers = {}, this._scene = e;
  }
  _prepareBuffers() {
    if (this._vertexBuffers[p.PositionKind])
      return;
    const e = [];
    e.push(1, 1), e.push(-1, 1), e.push(-1, -1), e.push(1, -1), this._vertexBuffers[p.PositionKind] = new p(this._scene.getEngine(), e, p.PositionKind, !1, !1, 2), this._buildIndexBuffer();
  }
  _buildIndexBuffer() {
    const e = [];
    e.push(0), e.push(1), e.push(2), e.push(0), e.push(2), e.push(3), this._indexBuffer = this._scene.getEngine().createIndexBuffer(e);
  }
  _rebuild() {
    const e = this._vertexBuffers[p.PositionKind];
    !e || (e._rebuild(), this._buildIndexBuffer());
  }
  _prepareFrame(e = null, t = null) {
    const i = this._scene.activeCamera;
    return !i || (t = t || i._postProcesses.filter((s) => s != null), !t || t.length === 0 || !this._scene.postProcessesEnabled) ? !1 : (t[0].activate(i, e, t != null), !0);
  }
  directRender(e, t = null, i = !1, s = 0, r = 0, n = !1) {
    var o;
    const a = this._scene.getEngine();
    for (let h = 0; h < e.length; h++) {
      h < e.length - 1 ? e[h + 1].activate(this._scene.activeCamera, t == null ? void 0 : t.texture) : (t ? a.bindFramebuffer(t, s, void 0, void 0, i, r) : n || a.restoreDefaultFramebuffer(), (o = a._debugInsertMarker) == null || o.call(a, `post process ${e[h].name} output`));
      const l = e[h], u = l.apply();
      u && (l.onBeforeRenderObservable.notifyObservers(u), this._prepareBuffers(), a.bindBuffers(this._vertexBuffers, this._indexBuffer, u), a.drawElementsType(0, 0, 6), l.onAfterRenderObservable.notifyObservers(u));
    }
    a.setDepthBuffer(!0), a.setDepthWrite(!0);
  }
  _finalizeFrame(e, t, i, s, r = !1) {
    var o;
    const n = this._scene.activeCamera;
    if (!n || (s = s || n._postProcesses.filter((h) => h != null), s.length === 0 || !this._scene.postProcessesEnabled))
      return;
    const a = this._scene.getEngine();
    for (let h = 0, l = s.length; h < l; h++) {
      const u = s[h];
      if (h < l - 1 ? u._outputTexture = s[h + 1].activate(n, t == null ? void 0 : t.texture) : (t ? (a.bindFramebuffer(t, i, void 0, void 0, r), u._outputTexture = t) : (a.restoreDefaultFramebuffer(), u._outputTexture = null), (o = a._debugInsertMarker) == null || o.call(a, `post process ${s[h].name} output`)), e)
        break;
      const f = u.apply();
      f && (u.onBeforeRenderObservable.notifyObservers(f), this._prepareBuffers(), a.bindBuffers(this._vertexBuffers, this._indexBuffer, f), a.drawElementsType(0, 0, 6), u.onAfterRenderObservable.notifyObservers(f));
    }
    a.setDepthBuffer(!0), a.setDepthWrite(!0), a.setAlphaMode(0);
  }
  dispose() {
    const e = this._vertexBuffers[p.PositionKind];
    e && (e.dispose(), this._vertexBuffers[p.PositionKind] = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null);
  }
}
class Tt {
  constructor(e, t, i = null, s = null, r = null) {
    this.index = e, this._opaqueSubMeshes = new Qe(256), this._transparentSubMeshes = new Qe(256), this._alphaTestSubMeshes = new Qe(256), this._depthOnlySubMeshes = new Qe(256), this._particleSystems = new Qe(256), this._spriteManagers = new Qe(256), this._empty = !0, this._edgesRenderers = new Jt(16), this._scene = t, this.opaqueSortCompareFn = i, this.alphaTestSortCompareFn = s, this.transparentSortCompareFn = r;
  }
  set opaqueSortCompareFn(e) {
    e ? this._opaqueSortCompareFn = e : this._opaqueSortCompareFn = Tt.PainterSortCompare, this._renderOpaque = this._renderOpaqueSorted;
  }
  set alphaTestSortCompareFn(e) {
    e ? this._alphaTestSortCompareFn = e : this._alphaTestSortCompareFn = Tt.PainterSortCompare, this._renderAlphaTest = this._renderAlphaTestSorted;
  }
  set transparentSortCompareFn(e) {
    e ? this._transparentSortCompareFn = e : this._transparentSortCompareFn = Tt.defaultTransparentSortCompare, this._renderTransparent = this._renderTransparentSorted;
  }
  render(e, t, i, s) {
    if (e) {
      e(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);
      return;
    }
    const r = this._scene.getEngine();
    this._depthOnlySubMeshes.length !== 0 && (r.setColorWrite(!1), this._renderAlphaTest(this._depthOnlySubMeshes), r.setColorWrite(!0)), this._opaqueSubMeshes.length !== 0 && this._renderOpaque(this._opaqueSubMeshes), this._alphaTestSubMeshes.length !== 0 && this._renderAlphaTest(this._alphaTestSubMeshes);
    const n = r.getStencilBuffer();
    if (r.setStencilBuffer(!1), t && this._renderSprites(), i && this._renderParticles(s), this.onBeforeTransparentRendering && this.onBeforeTransparentRendering(), this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {
      if (r.setStencilBuffer(n), this._scene.useOrderIndependentTransparency) {
        const a = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);
        a.length && this._renderTransparent(a);
      } else
        this._renderTransparent(this._transparentSubMeshes);
      r.setAlphaMode(0);
    }
    if (r.setStencilBuffer(!1), this._edgesRenderers.length) {
      for (let a = 0; a < this._edgesRenderers.length; a++)
        this._edgesRenderers.data[a].render();
      r.setAlphaMode(0);
    }
    r.setStencilBuffer(n);
  }
  _renderOpaqueSorted(e) {
    return Tt._RenderSorted(e, this._opaqueSortCompareFn, this._scene.activeCamera, !1);
  }
  _renderAlphaTestSorted(e) {
    return Tt._RenderSorted(e, this._alphaTestSortCompareFn, this._scene.activeCamera, !1);
  }
  _renderTransparentSorted(e) {
    return Tt._RenderSorted(e, this._transparentSortCompareFn, this._scene.activeCamera, !0);
  }
  static _RenderSorted(e, t, i, s) {
    let r = 0, n;
    const a = i ? i.globalPosition : Tt._ZeroVector;
    if (s)
      for (; r < e.length; r++)
        n = e.data[r], n._alphaIndex = n.getMesh().alphaIndex, n._distanceToCamera = g.Distance(n.getBoundingInfo().boundingSphere.centerWorld, a);
    const o = e.length === e.data.length ? e.data : e.data.slice(0, e.length);
    t && o.sort(t);
    const h = o[0].getMesh().getScene();
    for (r = 0; r < o.length; r++)
      if (n = o[r], !(h._activeMeshesFrozenButKeepClipping && !n.isInFrustum(h._frustumPlanes))) {
        if (s) {
          const l = n.getMaterial();
          if (l && l.needDepthPrePass) {
            const u = l.getScene().getEngine();
            u.setColorWrite(!1), u.setAlphaMode(0), n.render(!1), u.setColorWrite(!0);
          }
        }
        n.render(s);
      }
  }
  static defaultTransparentSortCompare(e, t) {
    return e._alphaIndex > t._alphaIndex ? 1 : e._alphaIndex < t._alphaIndex ? -1 : Tt.backToFrontSortCompare(e, t);
  }
  static backToFrontSortCompare(e, t) {
    return e._distanceToCamera < t._distanceToCamera ? 1 : e._distanceToCamera > t._distanceToCamera ? -1 : 0;
  }
  static frontToBackSortCompare(e, t) {
    return e._distanceToCamera < t._distanceToCamera ? -1 : e._distanceToCamera > t._distanceToCamera ? 1 : 0;
  }
  static PainterSortCompare(e, t) {
    const i = e.getMesh(), s = t.getMesh();
    return i.material && s.material ? i.material.uniqueId - s.material.uniqueId : i.uniqueId - s.uniqueId;
  }
  prepare() {
    this._opaqueSubMeshes.reset(), this._transparentSubMeshes.reset(), this._alphaTestSubMeshes.reset(), this._depthOnlySubMeshes.reset(), this._particleSystems.reset(), this._spriteManagers.reset(), this._edgesRenderers.reset(), this._empty = !0;
  }
  dispose() {
    this._opaqueSubMeshes.dispose(), this._transparentSubMeshes.dispose(), this._alphaTestSubMeshes.dispose(), this._depthOnlySubMeshes.dispose(), this._particleSystems.dispose(), this._spriteManagers.dispose(), this._edgesRenderers.dispose();
  }
  dispatch(e, t, i) {
    t === void 0 && (t = e.getMesh()), i === void 0 && (i = e.getMaterial()), i != null && (i.needAlphaBlendingForMesh(t) ? this._transparentSubMeshes.push(e) : i.needAlphaTesting() ? (i.needDepthPrePass && this._depthOnlySubMeshes.push(e), this._alphaTestSubMeshes.push(e)) : (i.needDepthPrePass && this._depthOnlySubMeshes.push(e), this._opaqueSubMeshes.push(e)), t._renderingGroup = this, t._edgesRenderer && t._edgesRenderer.isEnabled && this._edgesRenderers.pushNoDuplicate(t._edgesRenderer), this._empty = !1);
  }
  dispatchSprites(e) {
    this._spriteManagers.push(e), this._empty = !1;
  }
  dispatchParticles(e) {
    this._particleSystems.push(e), this._empty = !1;
  }
  _renderParticles(e) {
    if (this._particleSystems.length === 0)
      return;
    const t = this._scene.activeCamera;
    this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);
    for (let i = 0; i < this._particleSystems.length; i++) {
      const s = this._particleSystems.data[i];
      if ((t && t.layerMask & s.layerMask) === 0)
        continue;
      const r = s.emitter;
      (!r.position || !e || e.indexOf(r) !== -1) && this._scene._activeParticles.addCount(s.render(), !1);
    }
    this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);
  }
  _renderSprites() {
    if (!this._scene.spritesEnabled || this._spriteManagers.length === 0)
      return;
    const e = this._scene.activeCamera;
    this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);
    for (let t = 0; t < this._spriteManagers.length; t++) {
      const i = this._spriteManagers.data[t];
      (e && e.layerMask & i.layerMask) !== 0 && i.render();
    }
    this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);
  }
}
Tt._ZeroVector = g.Zero();
class mn {
}
class Ye {
  constructor(e) {
    this._useSceneAutoClearSetup = !1, this._renderingGroups = new Array(), this._autoClearDepthStencil = {}, this._customOpaqueSortCompareFn = {}, this._customAlphaTestSortCompareFn = {}, this._customTransparentSortCompareFn = {}, this._renderingGroupInfo = new mn(), this._scene = e;
    for (let t = Ye.MIN_RENDERINGGROUPS; t < Ye.MAX_RENDERINGGROUPS; t++)
      this._autoClearDepthStencil[t] = { autoClear: !0, depth: !0, stencil: !0 };
  }
  _clearDepthStencilBuffer(e = !0, t = !0) {
    this._depthStencilBufferAlreadyCleaned || (this._scene.getEngine().clear(null, !1, e, t), this._depthStencilBufferAlreadyCleaned = !0);
  }
  render(e, t, i, s) {
    const r = this._renderingGroupInfo;
    if (r.scene = this._scene, r.camera = this._scene.activeCamera, this._scene.spriteManagers && s)
      for (let n = 0; n < this._scene.spriteManagers.length; n++) {
        const a = this._scene.spriteManagers[n];
        this.dispatchSprites(a);
      }
    for (let n = Ye.MIN_RENDERINGGROUPS; n < Ye.MAX_RENDERINGGROUPS; n++) {
      this._depthStencilBufferAlreadyCleaned = n === Ye.MIN_RENDERINGGROUPS;
      const a = this._renderingGroups[n];
      if (!a || a._empty)
        continue;
      const o = Math.pow(2, n);
      if (r.renderingGroupId = n, this._scene.onBeforeRenderingGroupObservable.notifyObservers(r, o), Ye.AUTOCLEAR) {
        const h = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(n) : this._autoClearDepthStencil[n];
        h && h.autoClear && this._clearDepthStencilBuffer(h.depth, h.stencil);
      }
      for (const h of this._scene._beforeRenderingGroupDrawStage)
        h.action(n);
      a.render(e, s, i, t);
      for (const h of this._scene._afterRenderingGroupDrawStage)
        h.action(n);
      this._scene.onAfterRenderingGroupObservable.notifyObservers(r, o);
    }
  }
  reset() {
    for (let e = Ye.MIN_RENDERINGGROUPS; e < Ye.MAX_RENDERINGGROUPS; e++) {
      const t = this._renderingGroups[e];
      t && t.prepare();
    }
  }
  dispose() {
    this.freeRenderingGroups(), this._renderingGroups.length = 0, this._renderingGroupInfo = null;
  }
  freeRenderingGroups() {
    for (let e = Ye.MIN_RENDERINGGROUPS; e < Ye.MAX_RENDERINGGROUPS; e++) {
      const t = this._renderingGroups[e];
      t && t.dispose();
    }
  }
  _prepareRenderingGroup(e) {
    this._renderingGroups[e] === void 0 && (this._renderingGroups[e] = new Tt(e, this._scene, this._customOpaqueSortCompareFn[e], this._customAlphaTestSortCompareFn[e], this._customTransparentSortCompareFn[e]));
  }
  dispatchSprites(e) {
    const t = e.renderingGroupId || 0;
    this._prepareRenderingGroup(t), this._renderingGroups[t].dispatchSprites(e);
  }
  dispatchParticles(e) {
    const t = e.renderingGroupId || 0;
    this._prepareRenderingGroup(t), this._renderingGroups[t].dispatchParticles(e);
  }
  dispatch(e, t, i) {
    t === void 0 && (t = e.getMesh());
    const s = t.renderingGroupId || 0;
    this._prepareRenderingGroup(s), this._renderingGroups[s].dispatch(e, t, i);
  }
  setRenderingOrder(e, t = null, i = null, s = null) {
    if (this._customOpaqueSortCompareFn[e] = t, this._customAlphaTestSortCompareFn[e] = i, this._customTransparentSortCompareFn[e] = s, this._renderingGroups[e]) {
      const r = this._renderingGroups[e];
      r.opaqueSortCompareFn = this._customOpaqueSortCompareFn[e], r.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[e], r.transparentSortCompareFn = this._customTransparentSortCompareFn[e];
    }
  }
  setRenderingAutoClearDepthStencil(e, t, i = !0, s = !0) {
    this._autoClearDepthStencil[e] = {
      autoClear: t,
      depth: i,
      stencil: s
    };
  }
  getAutoClearDepthStencilSetup(e) {
    return this._autoClearDepthStencil[e];
  }
}
Ye.MAX_RENDERINGGROUPS = 4;
Ye.MIN_RENDERINGGROUPS = 0;
Ye.AUTOCLEAR = !0;
class j {
}
j.NAME_EFFECTLAYER = "EffectLayer";
j.NAME_LAYER = "Layer";
j.NAME_LENSFLARESYSTEM = "LensFlareSystem";
j.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer";
j.NAME_PARTICLESYSTEM = "ParticleSystem";
j.NAME_GAMEPAD = "Gamepad";
j.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue";
j.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer";
j.NAME_PREPASSRENDERER = "PrePassRenderer";
j.NAME_DEPTHRENDERER = "DepthRenderer";
j.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer";
j.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager";
j.NAME_SPRITE = "Sprite";
j.NAME_SUBSURFACE = "SubSurface";
j.NAME_OUTLINERENDERER = "Outline";
j.NAME_PROCEDURALTEXTURE = "ProceduralTexture";
j.NAME_SHADOWGENERATOR = "ShadowGenerator";
j.NAME_OCTREE = "Octree";
j.NAME_PHYSICSENGINE = "PhysicsEngine";
j.NAME_AUDIO = "Audio";
j.STEP_ISREADYFORMESH_EFFECTLAYER = 0;
j.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;
j.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;
j.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;
j.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;
j.STEP_BEFORECAMERADRAW_PREPASS = 0;
j.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;
j.STEP_BEFORECAMERADRAW_LAYER = 2;
j.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;
j.STEP_BEFORERENDERTARGETDRAW_LAYER = 1;
j.STEP_BEFORERENDERINGMESH_PREPASS = 0;
j.STEP_BEFORERENDERINGMESH_OUTLINE = 1;
j.STEP_AFTERRENDERINGMESH_PREPASS = 0;
j.STEP_AFTERRENDERINGMESH_OUTLINE = 1;
j.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;
j.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;
j.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;
j.STEP_BEFORECAMERAUPDATE_GAMEPAD = 1;
j.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;
j.STEP_BEFORECLEAR_PREPASS = 1;
j.STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0;
j.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;
j.STEP_AFTERRENDERTARGETDRAW_LAYER = 1;
j.STEP_AFTERCAMERADRAW_PREPASS = 0;
j.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;
j.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;
j.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;
j.STEP_AFTERCAMERADRAW_LAYER = 4;
j.STEP_AFTERRENDER_AUDIO = 0;
j.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;
j.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;
j.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;
j.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;
j.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;
j.STEP_POINTERMOVE_SPRITE = 0;
j.STEP_POINTERDOWN_SPRITE = 0;
j.STEP_POINTERUP_SPRITE = 0;
class Pe extends Array {
  constructor(e) {
    super(...e);
  }
  static Create() {
    return Object.create(Pe.prototype);
  }
  registerStep(e, t, i) {
    let s = 0, r = Number.MAX_VALUE;
    for (; s < this.length && (r = this[s].index, !(e < r)); s++)
      ;
    this.splice(s, 0, { index: e, component: t, action: i.bind(t) });
  }
  clear() {
    this.length = 0;
  }
}
class Se {
}
Se.POINTERDOWN = 1;
Se.POINTERUP = 2;
Se.POINTERMOVE = 4;
Se.POINTERWHEEL = 8;
Se.POINTERPICK = 16;
Se.POINTERTAP = 32;
Se.POINTERDOUBLETAP = 64;
class Ar {
  constructor(e, t) {
    this.type = e, this.event = t;
  }
}
class En extends Ar {
  constructor(e, t, i, s) {
    super(e, t), this.ray = null, this.skipOnPointerObservable = !1, this.localPosition = new ee(i, s);
  }
}
class vi extends Ar {
  constructor(e, t, i) {
    super(e, t), this.pickInfo = i;
  }
}
class lt {
  constructor() {
    this.hoverCursor = "", this.actions = new Array(), this.isRecursive = !1;
  }
  static get HasTriggers() {
    for (const e in lt.Triggers)
      if (Object.prototype.hasOwnProperty.call(lt.Triggers, e))
        return !0;
    return !1;
  }
  static get HasPickTriggers() {
    for (const e in lt.Triggers)
      if (Object.prototype.hasOwnProperty.call(lt.Triggers, e)) {
        const t = parseInt(e);
        if (t >= 1 && t <= 7)
          return !0;
      }
    return !1;
  }
  static HasSpecificTrigger(e) {
    for (const t in lt.Triggers)
      if (Object.prototype.hasOwnProperty.call(lt.Triggers, t) && parseInt(t) === e)
        return !0;
    return !1;
  }
}
lt.Triggers = {};
class $i {
}
$i.KEYDOWN = 1;
$i.KEYUP = 2;
class Is {
  constructor(e, t) {
    this.type = e, this.event = t;
  }
}
class qs extends Is {
  constructor(e, t) {
    super(e, t), this.type = e, this.event = t, this.skipOnKeyboardObservable = !1;
  }
  get skipOnPointerObservable() {
    return this.skipOnKeyboardObservable;
  }
  set skipOnPointerObservable(e) {
    this.skipOnKeyboardObservable = e;
  }
}
var V;
(function(c) {
  c[c.Generic = 0] = "Generic", c[c.Keyboard = 1] = "Keyboard", c[c.Mouse = 2] = "Mouse", c[c.Touch = 3] = "Touch", c[c.DualShock = 4] = "DualShock", c[c.Xbox = 5] = "Xbox", c[c.Switch = 6] = "Switch", c[c.DualSense = 7] = "DualSense";
})(V || (V = {}));
var H;
(function(c) {
  c[c.Horizontal = 0] = "Horizontal", c[c.Vertical = 1] = "Vertical", c[c.LeftClick = 2] = "LeftClick", c[c.MiddleClick = 3] = "MiddleClick", c[c.RightClick = 4] = "RightClick", c[c.BrowserBack = 5] = "BrowserBack", c[c.BrowserForward = 6] = "BrowserForward", c[c.MouseWheelX = 7] = "MouseWheelX", c[c.MouseWheelY = 8] = "MouseWheelY", c[c.MouseWheelZ = 9] = "MouseWheelZ", c[c.Move = 12] = "Move";
})(H || (H = {}));
var Ji;
(function(c) {
  c[c.Horizontal = 0] = "Horizontal", c[c.Vertical = 1] = "Vertical", c[c.LeftClick = 2] = "LeftClick", c[c.MiddleClick = 3] = "MiddleClick", c[c.RightClick = 4] = "RightClick", c[c.BrowserBack = 5] = "BrowserBack", c[c.BrowserForward = 6] = "BrowserForward", c[c.MouseWheelX = 7] = "MouseWheelX", c[c.MouseWheelY = 8] = "MouseWheelY", c[c.MouseWheelZ = 9] = "MouseWheelZ", c[c.DeltaHorizontal = 10] = "DeltaHorizontal", c[c.DeltaVertical = 11] = "DeltaVertical";
})(Ji || (Ji = {}));
var js;
(function(c) {
  c[c.Cross = 0] = "Cross", c[c.Circle = 1] = "Circle", c[c.Square = 2] = "Square", c[c.Triangle = 3] = "Triangle", c[c.L1 = 4] = "L1", c[c.R1 = 5] = "R1", c[c.L2 = 6] = "L2", c[c.R2 = 7] = "R2", c[c.Share = 8] = "Share", c[c.Options = 9] = "Options", c[c.L3 = 10] = "L3", c[c.R3 = 11] = "R3", c[c.DPadUp = 12] = "DPadUp", c[c.DPadDown = 13] = "DPadDown", c[c.DPadLeft = 14] = "DPadLeft", c[c.DPadRight = 15] = "DPadRight", c[c.Home = 16] = "Home", c[c.TouchPad = 17] = "TouchPad", c[c.LStickXAxis = 18] = "LStickXAxis", c[c.LStickYAxis = 19] = "LStickYAxis", c[c.RStickXAxis = 20] = "RStickXAxis", c[c.RStickYAxis = 21] = "RStickYAxis";
})(js || (js = {}));
var Qs;
(function(c) {
  c[c.Cross = 0] = "Cross", c[c.Circle = 1] = "Circle", c[c.Square = 2] = "Square", c[c.Triangle = 3] = "Triangle", c[c.L1 = 4] = "L1", c[c.R1 = 5] = "R1", c[c.L2 = 6] = "L2", c[c.R2 = 7] = "R2", c[c.Create = 8] = "Create", c[c.Options = 9] = "Options", c[c.L3 = 10] = "L3", c[c.R3 = 11] = "R3", c[c.DPadUp = 12] = "DPadUp", c[c.DPadDown = 13] = "DPadDown", c[c.DPadLeft = 14] = "DPadLeft", c[c.DPadRight = 15] = "DPadRight", c[c.Home = 16] = "Home", c[c.TouchPad = 17] = "TouchPad", c[c.LStickXAxis = 18] = "LStickXAxis", c[c.LStickYAxis = 19] = "LStickYAxis", c[c.RStickXAxis = 20] = "RStickXAxis", c[c.RStickYAxis = 21] = "RStickYAxis";
})(Qs || (Qs = {}));
var $s;
(function(c) {
  c[c.A = 0] = "A", c[c.B = 1] = "B", c[c.X = 2] = "X", c[c.Y = 3] = "Y", c[c.LB = 4] = "LB", c[c.RB = 5] = "RB", c[c.LT = 6] = "LT", c[c.RT = 7] = "RT", c[c.Back = 8] = "Back", c[c.Start = 9] = "Start", c[c.LS = 10] = "LS", c[c.RS = 11] = "RS", c[c.DPadUp = 12] = "DPadUp", c[c.DPadDown = 13] = "DPadDown", c[c.DPadLeft = 14] = "DPadLeft", c[c.DPadRight = 15] = "DPadRight", c[c.Home = 16] = "Home", c[c.LStickXAxis = 17] = "LStickXAxis", c[c.LStickYAxis = 18] = "LStickYAxis", c[c.RStickXAxis = 19] = "RStickXAxis", c[c.RStickYAxis = 20] = "RStickYAxis";
})($s || ($s = {}));
var Js;
(function(c) {
  c[c.B = 0] = "B", c[c.A = 1] = "A", c[c.Y = 2] = "Y", c[c.X = 3] = "X", c[c.L = 4] = "L", c[c.R = 5] = "R", c[c.ZL = 6] = "ZL", c[c.ZR = 7] = "ZR", c[c.Minus = 8] = "Minus", c[c.Plus = 9] = "Plus", c[c.LS = 10] = "LS", c[c.RS = 11] = "RS", c[c.DPadUp = 12] = "DPadUp", c[c.DPadDown = 13] = "DPadDown", c[c.DPadLeft = 14] = "DPadLeft", c[c.DPadRight = 15] = "DPadRight", c[c.Home = 16] = "Home", c[c.Capture = 17] = "Capture", c[c.LStickXAxis = 18] = "LStickXAxis", c[c.LStickYAxis = 19] = "LStickYAxis", c[c.RStickXAxis = 20] = "RStickXAxis", c[c.RStickYAxis = 21] = "RStickYAxis";
})(Js || (Js = {}));
var er;
(function(c) {
  c[c.PointerMove = 0] = "PointerMove", c[c.PointerDown = 1] = "PointerDown", c[c.PointerUp = 2] = "PointerUp";
})(er || (er = {}));
class ns {
}
ns.DOM_DELTA_PIXEL = 0;
ns.DOM_DELTA_LINE = 1;
ns.DOM_DELTA_PAGE = 2;
class ei {
  static CreateDeviceEvent(e, t, i, s, r, n) {
    switch (e) {
      case V.Keyboard:
        return this._CreateKeyboardEvent(i, s, r, n);
      case V.Mouse:
        if (i === H.MouseWheelX || i === H.MouseWheelY || i === H.MouseWheelZ)
          return this._CreateWheelEvent(e, t, i, s, r, n);
      case V.Touch:
        return this._CreatePointerEvent(e, t, i, s, r, n);
      default:
        throw `Unable to generate event for device ${V[e]}`;
    }
  }
  static _CreatePointerEvent(e, t, i, s, r, n) {
    const a = this._CreateMouseEvent(e, t, i, s, r, n);
    return e === V.Mouse ? (a.deviceType = V.Mouse, a.pointerId = 1, a.pointerType = "mouse") : (a.deviceType = V.Touch, a.pointerId = t, a.pointerType = "touch"), i === H.Move ? a.type = "pointermove" : i >= H.LeftClick && i <= H.RightClick && (a.type = s === 1 ? "pointerdown" : "pointerup", a.button = i - 2), a;
  }
  static _CreateWheelEvent(e, t, i, s, r, n) {
    const a = this._CreateMouseEvent(e, t, i, s, r, n);
    switch (a.type = "wheel", a.deltaMode = ns.DOM_DELTA_PIXEL, a.deltaX = 0, a.deltaY = 0, a.deltaZ = 0, i) {
      case H.MouseWheelX:
        a.deltaX = s;
        break;
      case H.MouseWheelY:
        a.deltaY = s;
        break;
      case H.MouseWheelZ:
        a.deltaZ = s;
        break;
    }
    return a;
  }
  static _CreateMouseEvent(e, t, i, s, r, n) {
    const a = this._CreateEvent(n), o = r.pollInput(e, t, H.Horizontal), h = r.pollInput(e, t, H.Vertical);
    return n ? (a.movementX = 0, a.movementY = 0, a.offsetX = a.movementX - n.getBoundingClientRect().x, a.offsetY = a.movementY - n.getBoundingClientRect().y) : (a.movementX = r.pollInput(e, t, Ji.DeltaHorizontal), a.movementY = r.pollInput(e, t, Ji.DeltaVertical), a.offsetX = 0, a.offsetY = 0), this._CheckNonCharacterKeys(a, r), a.clientX = o, a.clientY = h, a.x = o, a.y = h, a.deviceType = e, a.deviceSlot = t, a.inputIndex = i, a;
  }
  static _CreateKeyboardEvent(e, t, i, s) {
    const r = this._CreateEvent(s);
    return this._CheckNonCharacterKeys(r, i), r.deviceType = V.Keyboard, r.deviceSlot = 0, r.inputIndex = e, r.type = t === 1 ? "keydown" : "keyup", r.key = String.fromCharCode(e), r.keyCode = e, r;
  }
  static _CheckNonCharacterKeys(e, t) {
    const i = t.isDeviceAvailable(V.Keyboard), s = i && t.pollInput(V.Keyboard, 0, 18) === 1, r = i && t.pollInput(V.Keyboard, 0, 17) === 1, n = i && (t.pollInput(V.Keyboard, 0, 91) === 1 || t.pollInput(V.Keyboard, 0, 92) === 1 || t.pollInput(V.Keyboard, 0, 93) === 1), a = i && t.pollInput(V.Keyboard, 0, 16) === 1;
    e.altKey = s, e.ctrlKey = r, e.metaKey = n, e.shiftKey = a;
  }
  static _CreateEvent(e) {
    const t = {};
    return t.preventDefault = () => {
    }, t.target = e, t;
  }
}
class Tn {
  constructor(e, t, i) {
    this._nativeInput = _native.DeviceInputSystem ? new _native.DeviceInputSystem(e, t, (s, r, n, a) => {
      const o = ei.CreateDeviceEvent(s, r, n, a, this);
      i(s, r, o);
    }) : this._createDummyNativeInput();
  }
  pollInput(e, t, i) {
    return this._nativeInput.pollInput(e, t, i);
  }
  isDeviceAvailable(e) {
    return e === V.Mouse || e === V.Touch;
  }
  dispose() {
    this._nativeInput.dispose();
  }
  _createDummyNativeInput() {
    return {
      pollInput: () => 0,
      isDeviceAvailable: () => !1,
      dispose: () => {
      }
    };
  }
}
const tr = 255, ir = Object.keys(H).length / 2;
class Sn {
  constructor(e, t, i, s) {
    this._inputs = [], this._keyboardActive = !1, this._pointerActive = !1, this._usingSafari = U.IsSafari(), this._usingMacOS = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform), this._keyboardDownEvent = (r) => {
    }, this._keyboardUpEvent = (r) => {
    }, this._keyboardBlurEvent = (r) => {
    }, this._pointerMoveEvent = (r) => {
    }, this._pointerDownEvent = (r) => {
    }, this._pointerUpEvent = (r) => {
    }, this._pointerCancelEvent = (r) => {
    }, this._pointerWheelEvent = (r) => {
    }, this._pointerBlurEvent = (r) => {
    }, this._eventsAttached = !1, this._mouseId = -1, this._isUsingFirefox = ys.IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1, this._maxTouchPoints = 0, this._pointerInputClearObserver = null, this._gamepadConnectedEvent = (r) => {
    }, this._gamepadDisconnectedEvent = (r) => {
    }, this._eventPrefix = U.GetPointerPrefix(e), this._engine = e, this._onDeviceConnected = t, this._onDeviceDisconnected = i, this._onInputChanged = s, this._enableEvents(), this._usingMacOS && (this._metaKeys = []), this._engine._onEngineViewChanged || (this._engine._onEngineViewChanged = () => {
      this._enableEvents();
    });
  }
  pollInput(e, t, i) {
    const s = this._inputs[e][t];
    if (!s)
      throw `Unable to find device ${V[e]}`;
    e >= V.DualShock && e <= V.DualSense && this._updateDevice(e, t, i);
    const r = s[i];
    if (r === void 0)
      throw `Unable to find input ${i} for device ${V[e]} in slot ${t}`;
    return i === H.Move && U.Warn("Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data."), r;
  }
  isDeviceAvailable(e) {
    return this._inputs[e] !== void 0;
  }
  dispose() {
    this._onDeviceConnected = () => {
    }, this._onDeviceDisconnected = () => {
    }, this._onInputChanged = () => {
    }, delete this._engine._onEngineViewChanged, this._elementToAttachTo && this._disableEvents();
  }
  _enableEvents() {
    const e = this == null ? void 0 : this._engine.getInputElement();
    if (e && (!this._eventsAttached || this._elementToAttachTo !== e)) {
      if (this._disableEvents(), this._inputs) {
        for (const t of this._inputs)
          if (t)
            for (const i in t) {
              const s = +i, r = t[s];
              if (r)
                for (let n = 0; n < r.length; n++)
                  r[n] = 0;
            }
      }
      this._elementToAttachTo = e, this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex, this._handleKeyActions(), this._handlePointerActions(), this._handleGamepadActions(), this._eventsAttached = !0, this._checkForConnectedDevices();
    }
  }
  _disableEvents() {
    this._elementToAttachTo && (this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent), this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent), this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent), this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent), this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent), window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent), window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent)), this._pointerInputClearObserver && this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver), this._eventsAttached = !1;
  }
  _checkForConnectedDevices() {
    if (navigator.getGamepads) {
      const e = navigator.getGamepads();
      for (const t of e)
        t && this._addGamePad(t);
    }
    typeof matchMedia == "function" && matchMedia("(pointer:fine)").matches && this._addPointerDevice(V.Mouse, 0, 0, 0);
  }
  _addGamePad(e) {
    const t = this._getGamepadDeviceType(e.id), i = e.index;
    this._gamepads = this._gamepads || new Array(e.index + 1), this._registerDevice(t, i, e.buttons.length + e.axes.length), this._gamepads[i] = t;
  }
  _addPointerDevice(e, t, i, s) {
    this._pointerActive || (this._pointerActive = !0), this._registerDevice(e, t, ir);
    const r = this._inputs[e][t];
    r[0] = i, r[1] = s;
  }
  _registerDevice(e, t, i) {
    if (t === void 0)
      throw `Unable to register device ${V[e]} to undefined slot.`;
    if (this._inputs[e] || (this._inputs[e] = {}), !this._inputs[e][t]) {
      const s = new Array(i);
      s.fill(0), this._inputs[e][t] = s, this._onDeviceConnected(e, t);
    }
  }
  _unregisterDevice(e, t) {
    this._inputs[e][t] && (delete this._inputs[e][t], this._onDeviceDisconnected(e, t));
  }
  _handleKeyActions() {
    this._keyboardDownEvent = (e) => {
      this._keyboardActive || (this._keyboardActive = !0, this._registerDevice(V.Keyboard, 0, tr));
      const t = this._inputs[V.Keyboard][0];
      if (t) {
        t[e.keyCode] = 1;
        const i = e;
        i.inputIndex = e.keyCode, this._usingMacOS && e.metaKey && e.key !== "Meta" && (this._metaKeys.includes(e.keyCode) || this._metaKeys.push(e.keyCode)), this._onInputChanged(V.Keyboard, 0, i);
      }
    }, this._keyboardUpEvent = (e) => {
      this._keyboardActive || (this._keyboardActive = !0, this._registerDevice(V.Keyboard, 0, tr));
      const t = this._inputs[V.Keyboard][0];
      if (t) {
        t[e.keyCode] = 0;
        const i = e;
        if (i.inputIndex = e.keyCode, this._usingMacOS && e.key === "Meta" && this._metaKeys.length > 0) {
          for (const s of this._metaKeys) {
            const r = ei.CreateDeviceEvent(V.Keyboard, 0, s, 0, this, this._elementToAttachTo);
            t[s] = 0, this._onInputChanged(V.Keyboard, 0, r);
          }
          this._metaKeys.splice(0, this._metaKeys.length);
        }
        this._onInputChanged(V.Keyboard, 0, i);
      }
    }, this._keyboardBlurEvent = () => {
      if (this._keyboardActive) {
        const e = this._inputs[V.Keyboard][0];
        for (let t = 0; t < e.length; t++)
          if (e[t] !== 0) {
            e[t] = 0;
            const i = ei.CreateDeviceEvent(V.Keyboard, 0, t, 0, this, this._elementToAttachTo);
            this._onInputChanged(V.Keyboard, 0, i);
          }
        this._usingMacOS && this._metaKeys.splice(0, this._metaKeys.length);
      }
    }, this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent), this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent), this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent);
  }
  _handlePointerActions() {
    this._maxTouchPoints = ys.IsNavigatorAvailable() && navigator.maxTouchPoints || 2, this._activeTouchIds || (this._activeTouchIds = new Array(this._maxTouchPoints));
    for (let i = 0; i < this._maxTouchPoints; i++)
      this._activeTouchIds[i] = -1;
    this._pointerMoveEvent = (i) => {
      const s = this._getPointerType(i), r = s === V.Mouse ? 0 : this._activeTouchIds.indexOf(i.pointerId);
      this._inputs[s] || (this._inputs[s] = {}), this._inputs[s][r] || this._addPointerDevice(s, r, i.clientX, i.clientY);
      const n = this._inputs[s][r];
      if (n) {
        const a = i;
        a.inputIndex = H.Move, i.movementX === void 0 && (i.movementX = i.mozMovementX || i.webkitMovementX || i.msMovementX || i.clientX - n[H.Horizontal]), i.movementY === void 0 && (i.movementY = i.mozMovementY || i.webkitMovementY || i.msMovementY || i.clientY - n[H.Vertical]), n[H.Horizontal] = i.clientX, n[H.Vertical] = i.clientY, this._onInputChanged(s, r, a), !this._usingSafari && i.button !== -1 && (a.inputIndex = i.button + 2, n[i.button + 2] = n[i.button + 2] ? 0 : 1, this._onInputChanged(s, r, a));
      }
    }, this._pointerDownEvent = (i) => {
      const s = this._getPointerType(i);
      let r = s === V.Mouse ? 0 : i.pointerId;
      if (s === V.Touch) {
        const a = this._activeTouchIds.indexOf(-1);
        if (a >= 0)
          r = a, this._activeTouchIds[a] = i.pointerId;
        else {
          U.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);
          return;
        }
      }
      this._inputs[s] || (this._inputs[s] = {}), this._inputs[s][r] ? s === V.Touch && this._onDeviceConnected(s, r) : this._addPointerDevice(s, r, i.clientX, i.clientY);
      const n = this._inputs[s][r];
      if (n) {
        const a = n[H.Horizontal], o = n[H.Vertical];
        if (s === V.Mouse) {
          if (this._mouseId === -1 && (i.pointerId === void 0 ? this._mouseId = this._isUsingFirefox ? 0 : 1 : this._mouseId = i.pointerId), !document.pointerLockElement)
            try {
              this._elementToAttachTo.setPointerCapture(this._mouseId);
            } catch {
            }
        } else if (i.pointerId && !document.pointerLockElement)
          try {
            this._elementToAttachTo.setPointerCapture(i.pointerId);
          } catch {
          }
        n[H.Horizontal] = i.clientX, n[H.Vertical] = i.clientY, n[i.button + 2] = 1;
        const h = i;
        h.inputIndex = i.button + 2, this._onInputChanged(s, r, h), (a !== i.clientX || o !== i.clientY) && (h.inputIndex = H.Move, i.movementX === void 0 && (i.movementX = i.mozMovementX || i.webkitMovementX || i.msMovementX || i.clientX - n[H.Horizontal]), i.movementY === void 0 && (i.movementY = i.mozMovementY || i.webkitMovementY || i.msMovementY || i.clientY - n[H.Vertical]), this._onInputChanged(s, r, h));
      }
    }, this._pointerUpEvent = (i) => {
      var a, o, h, l, u;
      const s = this._getPointerType(i), r = s === V.Mouse ? 0 : this._activeTouchIds.indexOf(i.pointerId);
      if (s === V.Touch) {
        if (r === -1)
          return;
        this._activeTouchIds[r] = -1;
      }
      const n = (a = this._inputs[s]) == null ? void 0 : a[r];
      if (n && n[i.button + 2] !== 0) {
        const f = n[H.Horizontal], d = n[H.Vertical];
        n[H.Horizontal] = i.clientX, n[H.Vertical] = i.clientY, n[i.button + 2] = 0;
        const _ = i;
        (f !== i.clientX || d !== i.clientY) && (_.inputIndex = H.Move, i.movementX === void 0 && (i.movementX = i.mozMovementX || i.webkitMovementX || i.msMovementX || i.clientX - n[H.Horizontal]), i.movementY === void 0 && (i.movementY = i.mozMovementY || i.webkitMovementY || i.msMovementY || i.clientY - n[H.Vertical]), this._onInputChanged(s, r, _)), _.inputIndex = i.button + 2, s === V.Mouse && this._mouseId >= 0 && ((h = (o = this._elementToAttachTo).hasPointerCapture) == null ? void 0 : h.call(o, this._mouseId)) ? this._elementToAttachTo.releasePointerCapture(this._mouseId) : i.pointerId && ((u = (l = this._elementToAttachTo).hasPointerCapture) == null ? void 0 : u.call(l, i.pointerId)) && this._elementToAttachTo.releasePointerCapture(i.pointerId), this._onInputChanged(s, r, _), s === V.Touch && this._onDeviceDisconnected(s, r);
      }
    }, this._pointerCancelEvent = (i) => {
      var s, r, n, a;
      if (i.pointerType === "mouse") {
        const o = this._inputs[V.Mouse][0];
        this._mouseId >= 0 && ((r = (s = this._elementToAttachTo).hasPointerCapture) == null ? void 0 : r.call(s, this._mouseId)) && this._elementToAttachTo.releasePointerCapture(this._mouseId);
        for (let h = H.LeftClick; h <= H.BrowserForward; h++)
          if (o[h] === 1) {
            o[h] = 0;
            const l = ei.CreateDeviceEvent(V.Mouse, 0, h, 0, this, this._elementToAttachTo);
            this._onInputChanged(V.Mouse, 0, l);
          }
      } else {
        const o = this._activeTouchIds.indexOf(i.pointerId);
        (a = (n = this._elementToAttachTo).hasPointerCapture) != null && a.call(n, i.pointerId) && this._elementToAttachTo.releasePointerCapture(i.pointerId), this._inputs[V.Touch][o][H.LeftClick] = 0;
        const h = ei.CreateDeviceEvent(V.Touch, o, H.LeftClick, 0, this, this._elementToAttachTo);
        this._onInputChanged(V.Touch, o, h), this._activeTouchIds[o] = -1, this._onDeviceDisconnected(V.Touch, o);
      }
    }, this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
    let e = !1;
    const t = function() {
    };
    try {
      const i = Object.defineProperty({}, "passive", {
        get: function() {
          e = !0;
        }
      });
      this._elementToAttachTo.addEventListener("test", t, i), this._elementToAttachTo.removeEventListener("test", t, i);
    } catch {
    }
    this._pointerBlurEvent = () => {
      var i, s, r, n, a;
      if (this.isDeviceAvailable(V.Mouse)) {
        const o = this._inputs[V.Mouse][0];
        this._mouseId >= 0 && ((s = (i = this._elementToAttachTo).hasPointerCapture) == null ? void 0 : s.call(i, this._mouseId)) && this._elementToAttachTo.releasePointerCapture(this._mouseId);
        for (let h = H.LeftClick; h <= H.BrowserForward; h++)
          if (o[h] === 1) {
            o[h] = 0;
            const l = ei.CreateDeviceEvent(V.Mouse, 0, h, 0, this, this._elementToAttachTo);
            this._onInputChanged(V.Mouse, 0, l);
          }
      }
      if (this.isDeviceAvailable(V.Touch)) {
        const o = this._inputs[V.Touch];
        for (let h = 0; h < this._activeTouchIds.length; h++) {
          const l = this._activeTouchIds[h];
          if ((n = (r = this._elementToAttachTo).hasPointerCapture) != null && n.call(r, l) && this._elementToAttachTo.releasePointerCapture(l), l !== -1 && ((a = o[h]) == null ? void 0 : a[H.LeftClick]) === 1) {
            o[h][H.LeftClick] = 0;
            const u = ei.CreateDeviceEvent(V.Touch, h, H.LeftClick, 0, this, this._elementToAttachTo);
            this._onInputChanged(V.Touch, h, u), this._activeTouchIds[h] = -1, this._onDeviceDisconnected(V.Touch, h);
          }
        }
      }
    }, this._pointerWheelEvent = (i) => {
      const s = V.Mouse, r = 0;
      this._inputs[s] || (this._inputs[s] = []), this._inputs[s][r] || (this._pointerActive = !0, this._registerDevice(s, r, ir));
      const n = this._inputs[s][r];
      if (n) {
        n[H.MouseWheelX] = i.deltaX || 0, n[H.MouseWheelY] = i.deltaY || i.wheelDelta || 0, n[H.MouseWheelZ] = i.deltaZ || 0;
        const a = i;
        n[H.MouseWheelX] !== 0 && (a.inputIndex = H.MouseWheelX, this._onInputChanged(s, r, a)), n[H.MouseWheelY] !== 0 && (a.inputIndex = H.MouseWheelY, this._onInputChanged(s, r, a)), n[H.MouseWheelZ] !== 0 && (a.inputIndex = H.MouseWheelZ, this._onInputChanged(s, r, a));
      }
    }, this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent), this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent), this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, e ? { passive: !1 } : !1), this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(() => {
      if (this.isDeviceAvailable(V.Mouse)) {
        const i = this._inputs[V.Mouse][0];
        i[H.MouseWheelX] = 0, i[H.MouseWheelY] = 0, i[H.MouseWheelZ] = 0;
      }
    });
  }
  _handleGamepadActions() {
    this._gamepadConnectedEvent = (e) => {
      this._addGamePad(e.gamepad);
    }, this._gamepadDisconnectedEvent = (e) => {
      if (this._gamepads) {
        const t = this._getGamepadDeviceType(e.gamepad.id), i = e.gamepad.index;
        this._unregisterDevice(t, i), delete this._gamepads[i];
      }
    }, window.addEventListener("gamepadconnected", this._gamepadConnectedEvent), window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
  }
  _updateDevice(e, t, i) {
    const s = navigator.getGamepads()[t];
    if (s && e === this._gamepads[t]) {
      const r = this._inputs[e][t];
      i >= s.buttons.length ? r[i] = s.axes[i - s.buttons.length].valueOf() : r[i] = s.buttons[i].value;
    }
  }
  _getGamepadDeviceType(e) {
    return e.indexOf("054c") !== -1 ? e.indexOf("0ce6") !== -1 ? V.DualSense : V.DualShock : e.indexOf("Xbox One") !== -1 || e.search("Xbox 360") !== -1 || e.search("xinput") !== -1 ? V.Xbox : e.indexOf("057e") !== -1 ? V.Switch : V.Generic;
  }
  _getPointerType(e) {
    let t = V.Mouse;
    return (e.pointerType === "touch" || e.pointerType === "pen" || e.touches) && (t = V.Touch), t;
  }
}
class sr {
  constructor(e, t, i = 0) {
    this.deviceType = t, this.deviceSlot = i, this.onInputChangedObservable = new F(), this._deviceInputSystem = e;
  }
  getInput(e) {
    return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, e);
  }
}
class bn {
  constructor(e) {
    this._registeredManagers = new Array(), this._refCount = 0, this.registerManager = (n) => {
      for (let a = 0; a < this._devices.length; a++) {
        const o = this._devices[a];
        for (const h in o) {
          const l = +h;
          n._addDevice(new sr(this._deviceInputSystem, a, l));
        }
      }
      this._registeredManagers.push(n);
    }, this.unregisterManager = (n) => {
      const a = this._registeredManagers.indexOf(n);
      a > -1 && this._registeredManagers.splice(a, 1);
    };
    const t = Object.keys(V).length / 2;
    this._devices = new Array(t);
    const i = (n, a) => {
      this._devices[n] || (this._devices[n] = new Array()), this._devices[n][a] || (this._devices[n][a] = a);
      for (const o of this._registeredManagers) {
        const h = new sr(this._deviceInputSystem, n, a);
        o._addDevice(h);
      }
    }, s = (n, a) => {
      var o;
      (o = this._devices[n]) != null && o[a] && delete this._devices[n][a];
      for (const h of this._registeredManagers)
        h._removeDevice(n, a);
    }, r = (n, a, o) => {
      if (o)
        for (const h of this._registeredManagers)
          h._onInputChanged(n, a, o);
    };
    typeof _native < "u" ? this._deviceInputSystem = new Tn(i, s, r) : this._deviceInputSystem = new Sn(e, i, s, r);
  }
  dispose() {
    this._deviceInputSystem.dispose();
  }
}
class xn {
  constructor(e) {
    const t = Object.keys(V).length / 2;
    this._devices = new Array(t), this._firstDevice = new Array(t), this._engine = e, this._engine._deviceSourceManager || (this._engine._deviceSourceManager = new bn(e)), this._engine._deviceSourceManager._refCount++, this.onDeviceConnectedObservable = new F((i) => {
      for (const s of this._devices)
        if (s)
          for (const r of s)
            r && this.onDeviceConnectedObservable.notifyObserver(i, r);
    }), this.onDeviceDisconnectedObservable = new F(), this._engine._deviceSourceManager.registerManager(this), this._onDisposeObserver = e.onDisposeObservable.add(() => {
      this.dispose();
    });
  }
  getDeviceSource(e, t) {
    if (t === void 0) {
      if (this._firstDevice[e] === void 0)
        return null;
      t = this._firstDevice[e];
    }
    return !this._devices[e] || this._devices[e][t] === void 0 ? null : this._devices[e][t];
  }
  getDeviceSources(e) {
    return this._devices[e] ? this._devices[e].filter((t) => !!t) : [];
  }
  dispose() {
    this.onDeviceConnectedObservable.clear(), this.onDeviceDisconnectedObservable.clear(), this._engine._deviceSourceManager && (this._engine._deviceSourceManager.unregisterManager(this), --this._engine._deviceSourceManager._refCount < 1 && (this._engine._deviceSourceManager.dispose(), delete this._engine._deviceSourceManager)), this._engine.onDisposeObservable.remove(this._onDisposeObserver);
  }
  _addDevice(e) {
    this._devices[e.deviceType] || (this._devices[e.deviceType] = new Array()), this._devices[e.deviceType][e.deviceSlot] || (this._devices[e.deviceType][e.deviceSlot] = e, this._updateFirstDevices(e.deviceType)), this.onDeviceConnectedObservable.notifyObservers(e);
  }
  _removeDevice(e, t) {
    var s, r;
    const i = (s = this._devices[e]) == null ? void 0 : s[t];
    this.onDeviceDisconnectedObservable.notifyObservers(i), (r = this._devices[e]) != null && r[t] && delete this._devices[e][t], this._updateFirstDevices(e);
  }
  _onInputChanged(e, t, i) {
    var s, r;
    (r = (s = this._devices[e]) == null ? void 0 : s[t]) == null || r.onInputChangedObservable.notifyObservers(i);
  }
  _updateFirstDevices(e) {
    switch (e) {
      case V.Keyboard:
      case V.Mouse:
        this._firstDevice[e] = 0;
        break;
      case V.Touch:
      case V.DualSense:
      case V.DualShock:
      case V.Xbox:
      case V.Switch:
      case V.Generic: {
        delete this._firstDevice[e];
        const t = this._devices[e];
        if (t) {
          for (let i = 0; i < t.length; i++)
            if (t[i]) {
              this._firstDevice[e] = i;
              break;
            }
        }
        break;
      }
    }
  }
}
class rr {
  constructor() {
    this._singleClick = !1, this._doubleClick = !1, this._hasSwiped = !1, this._ignore = !1;
  }
  get singleClick() {
    return this._singleClick;
  }
  get doubleClick() {
    return this._doubleClick;
  }
  get hasSwiped() {
    return this._hasSwiped;
  }
  get ignore() {
    return this._ignore;
  }
  set singleClick(e) {
    this._singleClick = e;
  }
  set doubleClick(e) {
    this._doubleClick = e;
  }
  set hasSwiped(e) {
    this._hasSwiped = e;
  }
  set ignore(e) {
    this._ignore = e;
  }
}
class Ie {
  constructor(e) {
    this._alreadyAttached = !1, this._meshPickProceed = !1, this._currentPickResult = null, this._previousPickResult = null, this._totalPointersPressed = 0, this._doubleClickOccured = !1, this._pointerX = 0, this._pointerY = 0, this._startingPointerPosition = new ee(0, 0), this._previousStartingPointerPosition = new ee(0, 0), this._startingPointerTime = 0, this._previousStartingPointerTime = 0, this._pointerCaptures = {}, this._meshUnderPointerId = {}, this._deviceSourceManager = null, this._scene = e || _e.LastCreatedScene, this._scene;
  }
  get meshUnderPointer() {
    return this._pointerOverMesh;
  }
  getMeshUnderPointerByPointerId(e) {
    return this._meshUnderPointerId[e] || null;
  }
  get unTranslatedPointer() {
    return new ee(this._unTranslatedPointerX, this._unTranslatedPointerY);
  }
  get pointerX() {
    return this._pointerX;
  }
  set pointerX(e) {
    this._pointerX = e;
  }
  get pointerY() {
    return this._pointerY;
  }
  set pointerY(e) {
    this._pointerY = e;
  }
  _updatePointerPosition(e) {
    const t = this._scene.getEngine().getInputElementClientRect();
    !t || (this._pointerX = e.clientX - t.left, this._pointerY = e.clientY - t.top, this._unTranslatedPointerX = this._pointerX, this._unTranslatedPointerY = this._pointerY);
  }
  _processPointerMove(e, t) {
    const i = this._scene, s = i.getEngine(), r = s.getInputElement();
    r && (r.tabIndex = s.canvasTabIndex, i.doNotHandleCursors || (r.style.cursor = i.defaultCursor));
    const n = !!(e && e.hit && e.pickedMesh);
    if (n) {
      if (i.setPointerOverMesh(e.pickedMesh, t.pointerId, e), !i.doNotHandleCursors && r && this._pointerOverMesh) {
        const a = this._pointerOverMesh._getActionManagerForTrigger();
        a && a.hasPointerTriggers && (r.style.cursor = a.hoverCursor || i.hoverCursor);
      }
    } else
      i.setPointerOverMesh(null, t.pointerId, e);
    for (const a of i._pointerMoveStage)
      e = a.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, n, r);
    if (e) {
      const a = t.inputIndex >= H.MouseWheelX && t.inputIndex <= H.MouseWheelZ ? Se.POINTERWHEEL : Se.POINTERMOVE;
      if (i.onPointerMove && i.onPointerMove(t, e, a), i.onPointerObservable.hasObservers()) {
        const o = new vi(a, t, e);
        this._setRayOnPointerInfo(o), i.onPointerObservable.notifyObservers(o, a);
      }
    }
  }
  _setRayOnPointerInfo(e) {
    const t = this._scene;
    e.pickInfo && !e.pickInfo._pickingUnavailable && (e.pickInfo.ray || (e.pickInfo.ray = t.createPickingRay(e.event.offsetX, e.event.offsetY, x.Identity(), t.activeCamera)));
  }
  _checkPrePointerObservable(e, t, i) {
    const s = this._scene, r = new En(i, t, this._unTranslatedPointerX, this._unTranslatedPointerY);
    return e && (r.ray = e.ray, e.originMesh && (r.nearInteractionPickingInfo = e)), s.onPrePointerObservable.notifyObservers(r, i), !!r.skipOnPointerObservable;
  }
  simulatePointerMove(e, t) {
    const i = new PointerEvent("pointermove", t);
    i.inputIndex = H.Move, !this._checkPrePointerObservable(e, i, Se.POINTERMOVE) && this._processPointerMove(e, i);
  }
  simulatePointerDown(e, t) {
    const i = new PointerEvent("pointerdown", t);
    i.inputIndex = i.button + 2, !this._checkPrePointerObservable(e, i, Se.POINTERDOWN) && this._processPointerDown(e, i);
  }
  _processPointerDown(e, t) {
    const i = this._scene;
    if (e && e.hit && e.pickedMesh) {
      this._pickedDownMesh = e.pickedMesh;
      const s = e.pickedMesh._getActionManagerForTrigger();
      if (s) {
        if (s.hasPickTriggers)
          switch (s.processTrigger(5, ze.CreateNew(e.pickedMesh, t)), t.button) {
            case 0:
              s.processTrigger(2, ze.CreateNew(e.pickedMesh, t));
              break;
            case 1:
              s.processTrigger(4, ze.CreateNew(e.pickedMesh, t));
              break;
            case 2:
              s.processTrigger(3, ze.CreateNew(e.pickedMesh, t));
              break;
          }
        s.hasSpecificTrigger(8) && window.setTimeout(() => {
          const r = i.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, (n) => n.isPickable && n.isVisible && n.isReady() && n.actionManager && n.actionManager.hasSpecificTrigger(8) && n === this._pickedDownMesh, !1, i.cameraToUseForPointers);
          r && r.hit && r.pickedMesh && s && this._totalPointersPressed !== 0 && Date.now() - this._startingPointerTime > Ie.LongPressDelay && !this._isPointerSwiping() && (this._startingPointerTime = 0, s.processTrigger(8, ze.CreateNew(r.pickedMesh, t)));
        }, Ie.LongPressDelay);
      }
    } else
      for (const s of i._pointerDownStage)
        e = s.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, t, !1);
    if (e) {
      const s = Se.POINTERDOWN;
      if (i.onPointerDown && i.onPointerDown(t, e, s), i.onPointerObservable.hasObservers()) {
        const r = new vi(s, t, e);
        this._setRayOnPointerInfo(r), i.onPointerObservable.notifyObservers(r, s);
      }
    }
  }
  _isPointerSwiping() {
    return Math.abs(this._startingPointerPosition.x - this._pointerX) > Ie.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > Ie.DragMovementThreshold;
  }
  simulatePointerUp(e, t, i) {
    const s = new PointerEvent("pointerup", t);
    s.inputIndex = H.Move;
    const r = new rr();
    i ? r.doubleClick = !0 : r.singleClick = !0, !this._checkPrePointerObservable(e, s, Se.POINTERUP) && this._processPointerUp(e, s, r);
  }
  _processPointerUp(e, t, i) {
    const s = this._scene;
    if (e && e.hit && e.pickedMesh) {
      if (this._pickedUpMesh = e.pickedMesh, this._pickedDownMesh === this._pickedUpMesh && (s.onPointerPick && s.onPointerPick(t, e), i.singleClick && !i.ignore && s.onPointerObservable.hasObservers())) {
        const a = Se.POINTERPICK, o = new vi(a, t, e);
        this._setRayOnPointerInfo(o), s.onPointerObservable.notifyObservers(o, a);
      }
      const n = e.pickedMesh._getActionManagerForTrigger();
      if (n && !i.ignore) {
        n.processTrigger(7, ze.CreateNew(e.pickedMesh, t, e)), !i.hasSwiped && i.singleClick && n.processTrigger(1, ze.CreateNew(e.pickedMesh, t, e));
        const a = e.pickedMesh._getActionManagerForTrigger(6);
        i.doubleClick && a && a.processTrigger(6, ze.CreateNew(e.pickedMesh, t, e));
      }
    } else if (!i.ignore)
      for (const n of s._pointerUpStage)
        e = n.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, t, i.doubleClick);
    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {
      const n = this._pickedDownMesh._getActionManagerForTrigger(16);
      n && n.processTrigger(16, ze.CreateNew(this._pickedDownMesh, t));
    }
    let r = 0;
    if (s.onPointerObservable.hasObservers()) {
      if (!i.ignore && !i.hasSwiped && (i.singleClick && s.onPointerObservable.hasSpecificMask(Se.POINTERTAP) ? r = Se.POINTERTAP : i.doubleClick && s.onPointerObservable.hasSpecificMask(Se.POINTERDOUBLETAP) && (r = Se.POINTERDOUBLETAP), r)) {
        const n = new vi(r, t, e);
        this._setRayOnPointerInfo(n), s.onPointerObservable.notifyObservers(n, r);
      }
      if (!i.ignore) {
        r = Se.POINTERUP;
        const n = new vi(r, t, e);
        this._setRayOnPointerInfo(n), s.onPointerObservable.notifyObservers(n, r);
      }
    }
    s.onPointerUp && !i.ignore && s.onPointerUp(t, e, r);
  }
  isPointerCaptured(e = 0) {
    return this._pointerCaptures[e];
  }
  attachControl(e = !0, t = !0, i = !0, s = null) {
    const r = this._scene, n = r.getEngine();
    s || (s = n.getInputElement()), this._alreadyAttached && this.detachControl(), s && (this._alreadyAttachedTo = s), this._deviceSourceManager = new xn(n), this._initActionManager = (a) => {
      if (!this._meshPickProceed) {
        const o = r.skipPointerUpPicking ? null : r.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, r.pointerUpPredicate, !1, r.cameraToUseForPointers);
        this._currentPickResult = o, o && (a = o.hit && o.pickedMesh ? o.pickedMesh._getActionManagerForTrigger() : null), this._meshPickProceed = !0;
      }
      return a;
    }, this._delayedSimpleClick = (a, o, h) => {
      (Date.now() - this._previousStartingPointerTime > Ie.DoubleClickDelay && !this._doubleClickOccured || a !== this._previousButtonPressed) && (this._doubleClickOccured = !1, o.singleClick = !0, o.ignore = !1, h(o, this._currentPickResult));
    }, this._initClickEvent = (a, o, h, l) => {
      const u = new rr();
      this._currentPickResult = null;
      let f = null, d = a.hasSpecificMask(Se.POINTERPICK) || o.hasSpecificMask(Se.POINTERPICK) || a.hasSpecificMask(Se.POINTERTAP) || o.hasSpecificMask(Se.POINTERTAP) || a.hasSpecificMask(Se.POINTERDOUBLETAP) || o.hasSpecificMask(Se.POINTERDOUBLETAP);
      !d && lt && (f = this._initActionManager(f, u), f && (d = f.hasPickTriggers));
      let _ = !1;
      if (d) {
        const E = h.button;
        if (u.hasSwiped = this._isPointerSwiping(), !u.hasSwiped) {
          let m = !Ie.ExclusiveDoubleClickMode;
          m || (m = !a.hasSpecificMask(Se.POINTERDOUBLETAP) && !o.hasSpecificMask(Se.POINTERDOUBLETAP), m && !lt.HasSpecificTrigger(6) && (f = this._initActionManager(f, u), f && (m = !f.hasSpecificTrigger(6)))), m ? (Date.now() - this._previousStartingPointerTime > Ie.DoubleClickDelay || E !== this._previousButtonPressed) && (u.singleClick = !0, l(u, this._currentPickResult), _ = !0) : (this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout, this._delayedSimpleClickTimeout = window.setTimeout(this._delayedSimpleClick.bind(this, E, u, l), Ie.DoubleClickDelay));
          let T = a.hasSpecificMask(Se.POINTERDOUBLETAP) || o.hasSpecificMask(Se.POINTERDOUBLETAP);
          !T && lt.HasSpecificTrigger(6) && (f = this._initActionManager(f, u), f && (T = f.hasSpecificTrigger(6))), T && (E === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < Ie.DoubleClickDelay && !this._doubleClickOccured ? (!u.hasSwiped && !this._isPointerSwiping() ? (this._previousStartingPointerTime = 0, this._doubleClickOccured = !0, u.doubleClick = !0, u.ignore = !1, Ie.ExclusiveDoubleClickMode && this._previousDelayedSimpleClickTimeout && clearTimeout(this._previousDelayedSimpleClickTimeout), this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout, l(u, this._currentPickResult)) : (this._doubleClickOccured = !1, this._previousStartingPointerTime = this._startingPointerTime, this._previousStartingPointerPosition.x = this._startingPointerPosition.x, this._previousStartingPointerPosition.y = this._startingPointerPosition.y, this._previousButtonPressed = E, Ie.ExclusiveDoubleClickMode ? (this._previousDelayedSimpleClickTimeout && clearTimeout(this._previousDelayedSimpleClickTimeout), this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout, l(u, this._previousPickResult)) : l(u, this._currentPickResult)), _ = !0) : (this._doubleClickOccured = !1, this._previousStartingPointerTime = this._startingPointerTime, this._previousStartingPointerPosition.x = this._startingPointerPosition.x, this._previousStartingPointerPosition.y = this._startingPointerPosition.y, this._previousButtonPressed = E));
        }
      }
      _ || l(u, this._currentPickResult);
    }, this._onPointerMove = (a) => {
      if (a.pointerId === void 0 && (a.pointerId = 0), this._updatePointerPosition(a), this._checkPrePointerObservable(null, a, a.inputIndex >= H.MouseWheelX && a.inputIndex <= H.MouseWheelZ ? Se.POINTERWHEEL : Se.POINTERMOVE) || !r.cameraToUseForPointers && !r.activeCamera)
        return;
      if (r.skipPointerMovePicking) {
        this._processPointerMove(new vt(), a);
        return;
      }
      r.pointerMovePredicate || (r.pointerMovePredicate = (h) => h.isPickable && h.isVisible && h.isReady() && h.isEnabled() && (h.enablePointerMoveEvents || r.constantlyUpdateMeshUnderPointer || h._getActionManagerForTrigger() !== null) && (!r.cameraToUseForPointers || (r.cameraToUseForPointers.layerMask & h.layerMask) !== 0));
      const o = r.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, r.pointerMovePredicate, !1, r.cameraToUseForPointers, r.pointerMoveTrianglePredicate);
      this._processPointerMove(o, a);
    }, this._onPointerDown = (a) => {
      if (this._totalPointersPressed++, this._pickedDownMesh = null, this._meshPickProceed = !1, a.pointerId === void 0 && (a.pointerId = 0), this._updatePointerPosition(a), r.preventDefaultOnPointerDown && s && (a.preventDefault(), s.focus()), this._startingPointerPosition.x = this._pointerX, this._startingPointerPosition.y = this._pointerY, this._startingPointerTime = Date.now(), this._checkPrePointerObservable(null, a, Se.POINTERDOWN) || !r.cameraToUseForPointers && !r.activeCamera)
        return;
      this._pointerCaptures[a.pointerId] = !0, r.pointerDownPredicate || (r.pointerDownPredicate = (h) => h.isPickable && h.isVisible && h.isReady() && h.isEnabled() && (!r.cameraToUseForPointers || (r.cameraToUseForPointers.layerMask & h.layerMask) !== 0)), this._pickedDownMesh = null;
      let o;
      r.skipPointerDownPicking ? o = new vt() : o = r.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, r.pointerDownPredicate, !1, r.cameraToUseForPointers), this._processPointerDown(o, a);
    }, this._onPointerUp = (a) => {
      this._totalPointersPressed !== 0 && (this._totalPointersPressed--, this._pickedUpMesh = null, this._meshPickProceed = !1, a.pointerId === void 0 && (a.pointerId = 0), this._updatePointerPosition(a), r.preventDefaultOnPointerUp && s && (a.preventDefault(), s.focus()), this._initClickEvent(r.onPrePointerObservable, r.onPointerObservable, a, (o, h) => {
        r.onPrePointerObservable.hasObservers() && !o.ignore && (!o.hasSwiped && (o.singleClick && r.onPrePointerObservable.hasSpecificMask(Se.POINTERTAP) && this._checkPrePointerObservable(null, a, Se.POINTERTAP) || o.doubleClick && r.onPrePointerObservable.hasSpecificMask(Se.POINTERDOUBLETAP) && this._checkPrePointerObservable(null, a, Se.POINTERDOUBLETAP)) || this._checkPrePointerObservable(null, a, Se.POINTERUP)) || (this._pointerCaptures[a.pointerId] = !1, !(!r.cameraToUseForPointers && !r.activeCamera) && (r.pointerUpPredicate || (r.pointerUpPredicate = (l) => l.isPickable && l.isVisible && l.isReady() && l.isEnabled() && (!r.cameraToUseForPointers || (r.cameraToUseForPointers.layerMask & l.layerMask) !== 0)), !this._meshPickProceed && (lt && lt.HasTriggers || r.onPointerObservable.hasObservers()) && this._initActionManager(null, o), h || (h = this._currentPickResult), this._processPointerUp(h, a, o), this._previousPickResult = this._currentPickResult));
      }));
    }, this._onKeyDown = (a) => {
      const o = $i.KEYDOWN;
      if (r.onPreKeyboardObservable.hasObservers()) {
        const h = new qs(o, a);
        if (r.onPreKeyboardObservable.notifyObservers(h, o), h.skipOnKeyboardObservable)
          return;
      }
      if (r.onKeyboardObservable.hasObservers()) {
        const h = new Is(o, a);
        r.onKeyboardObservable.notifyObservers(h, o);
      }
      r.actionManager && r.actionManager.processTrigger(14, ze.CreateNewFromScene(r, a));
    }, this._onKeyUp = (a) => {
      const o = $i.KEYUP;
      if (r.onPreKeyboardObservable.hasObservers()) {
        const h = new qs(o, a);
        if (r.onPreKeyboardObservable.notifyObservers(h, o), h.skipOnKeyboardObservable)
          return;
      }
      if (r.onKeyboardObservable.hasObservers()) {
        const h = new Is(o, a);
        r.onKeyboardObservable.notifyObservers(h, o);
      }
      r.actionManager && r.actionManager.processTrigger(15, ze.CreateNewFromScene(r, a));
    }, this._deviceSourceManager.onDeviceConnectedObservable.add((a) => {
      a.deviceType === V.Mouse ? a.onInputChangedObservable.add((o) => {
        o.inputIndex === H.LeftClick || o.inputIndex === H.MiddleClick || o.inputIndex === H.RightClick || o.inputIndex === H.BrowserBack || o.inputIndex === H.BrowserForward ? t && a.getInput(o.inputIndex) === 1 ? this._onPointerDown(o) : e && a.getInput(o.inputIndex) === 0 && this._onPointerUp(o) : i && (o.inputIndex === H.Move ? this._onPointerMove(o) : (o.inputIndex === H.MouseWheelX || o.inputIndex === H.MouseWheelY || o.inputIndex === H.MouseWheelZ) && this._onPointerMove(o));
      }) : a.deviceType === V.Touch ? a.onInputChangedObservable.add((o) => {
        o.inputIndex === H.LeftClick && (t && a.getInput(o.inputIndex) === 1 ? this._onPointerDown(o) : e && a.getInput(o.inputIndex) === 0 && this._onPointerUp(o)), i && o.inputIndex === H.Move && this._onPointerMove(o);
      }) : a.deviceType === V.Keyboard && a.onInputChangedObservable.add((o) => {
        o.type === "keydown" ? this._onKeyDown(o) : o.type === "keyup" && this._onKeyUp(o);
      });
    }), this._alreadyAttached = !0;
  }
  detachControl() {
    this._alreadyAttached && (this._deviceSourceManager.dispose(), this._deviceSourceManager = null, this._alreadyAttachedTo && !this._scene.doNotHandleCursors && (this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor), this._alreadyAttached = !1, this._alreadyAttachedTo = null);
  }
  setPointerOverMesh(e, t = 0, i) {
    if (this._meshUnderPointerId[t] === e)
      return;
    const s = this._meshUnderPointerId[t];
    let r;
    s && (r = s._getActionManagerForTrigger(10), r && r.processTrigger(10, ze.CreateNew(s, void 0, { pointerId: t }))), e ? (this._meshUnderPointerId[t] = e, this._pointerOverMesh = e, r = e._getActionManagerForTrigger(9), r && r.processTrigger(9, ze.CreateNew(e, void 0, { pointerId: t, pickResult: i }))) : (delete this._meshUnderPointerId[t], this._pointerOverMesh = null);
  }
  getPointerOverMesh() {
    return this._pointerOverMesh;
  }
  _invalidateMesh(e) {
    this._pointerOverMesh === e && (this._pointerOverMesh = null), this._pickedDownMesh === e && (this._pickedDownMesh = null), this._pickedUpMesh === e && (this._pickedUpMesh = null);
    for (const t in this._meshUnderPointerId)
      this._meshUnderPointerId[t] === e && delete this._meshUnderPointerId[t];
  }
}
Ie.DragMovementThreshold = 10;
Ie.LongPressDelay = 500;
Ie.DoubleClickDelay = 300;
Ie.ExclusiveDoubleClickMode = !1;
class xt {
  constructor(e, t, i, s) {
    this.normal = new g(e, t, i), this.d = s;
  }
  asArray() {
    return [this.normal.x, this.normal.y, this.normal.z, this.d];
  }
  clone() {
    return new xt(this.normal.x, this.normal.y, this.normal.z, this.d);
  }
  getClassName() {
    return "Plane";
  }
  getHashCode() {
    let e = this.normal.getHashCode();
    return e = e * 397 ^ (this.d | 0), e;
  }
  normalize() {
    const e = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);
    let t = 0;
    return e !== 0 && (t = 1 / e), this.normal.x *= t, this.normal.y *= t, this.normal.z *= t, this.d *= t, this;
  }
  transform(e) {
    const t = xt._TmpMatrix;
    e.invertToRef(t);
    const i = t.m, s = this.normal.x, r = this.normal.y, n = this.normal.z, a = this.d, o = s * i[0] + r * i[1] + n * i[2] + a * i[3], h = s * i[4] + r * i[5] + n * i[6] + a * i[7], l = s * i[8] + r * i[9] + n * i[10] + a * i[11], u = s * i[12] + r * i[13] + n * i[14] + a * i[15];
    return new xt(o, h, l, u);
  }
  dotCoordinate(e) {
    return this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z + this.d;
  }
  copyFromPoints(e, t, i) {
    const s = t.x - e.x, r = t.y - e.y, n = t.z - e.z, a = i.x - e.x, o = i.y - e.y, h = i.z - e.z, l = r * h - n * o, u = n * a - s * h, f = s * o - r * a, d = Math.sqrt(l * l + u * u + f * f);
    let _;
    return d !== 0 ? _ = 1 / d : _ = 0, this.normal.x = l * _, this.normal.y = u * _, this.normal.z = f * _, this.d = -(this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z), this;
  }
  isFrontFacingTo(e, t) {
    return g.Dot(this.normal, e) <= t;
  }
  signedDistanceTo(e) {
    return g.Dot(e, this.normal) + this.d;
  }
  static FromArray(e) {
    return new xt(e[0], e[1], e[2], e[3]);
  }
  static FromPoints(e, t, i) {
    const s = new xt(0, 0, 0, 0);
    return s.copyFromPoints(e, t, i), s;
  }
  static FromPositionAndNormal(e, t) {
    const i = new xt(0, 0, 0, 0);
    return t.normalize(), i.normal = t, i.d = -(t.x * e.x + t.y * e.y + t.z * e.z), i;
  }
  static SignedDistanceToPlaneFromPositionAndNormal(e, t, i) {
    const s = -(t.x * e.x + t.y * e.y + t.z * e.z);
    return g.Dot(i, t) + s;
  }
}
xt._TmpMatrix = x.Identity();
class pt {
  static GetPlanes(e) {
    const t = [];
    for (let i = 0; i < 6; i++)
      t.push(new xt(0, 0, 0, 0));
    return pt.GetPlanesToRef(e, t), t;
  }
  static GetNearPlaneToRef(e, t) {
    const i = e.m;
    t.normal.x = i[3] + i[2], t.normal.y = i[7] + i[6], t.normal.z = i[11] + i[10], t.d = i[15] + i[14], t.normalize();
  }
  static GetFarPlaneToRef(e, t) {
    const i = e.m;
    t.normal.x = i[3] - i[2], t.normal.y = i[7] - i[6], t.normal.z = i[11] - i[10], t.d = i[15] - i[14], t.normalize();
  }
  static GetLeftPlaneToRef(e, t) {
    const i = e.m;
    t.normal.x = i[3] + i[0], t.normal.y = i[7] + i[4], t.normal.z = i[11] + i[8], t.d = i[15] + i[12], t.normalize();
  }
  static GetRightPlaneToRef(e, t) {
    const i = e.m;
    t.normal.x = i[3] - i[0], t.normal.y = i[7] - i[4], t.normal.z = i[11] - i[8], t.d = i[15] - i[12], t.normalize();
  }
  static GetTopPlaneToRef(e, t) {
    const i = e.m;
    t.normal.x = i[3] - i[1], t.normal.y = i[7] - i[5], t.normal.z = i[11] - i[9], t.d = i[15] - i[13], t.normalize();
  }
  static GetBottomPlaneToRef(e, t) {
    const i = e.m;
    t.normal.x = i[3] + i[1], t.normal.y = i[7] + i[5], t.normal.z = i[11] + i[9], t.d = i[15] + i[13], t.normalize();
  }
  static GetPlanesToRef(e, t) {
    pt.GetNearPlaneToRef(e, t[0]), pt.GetFarPlaneToRef(e, t[1]), pt.GetLeftPlaneToRef(e, t[2]), pt.GetRightPlaneToRef(e, t[3]), pt.GetTopPlaneToRef(e, t[4]), pt.GetBottomPlaneToRef(e, t[5]);
  }
}
class Rr {
  static get UniqueId() {
    const e = this._UniqueIdCounter;
    return this._UniqueIdCounter++, e;
  }
}
Rr._UniqueIdCounter = 1;
class Te {
  static CompareLightsPriority(e, t) {
    return e.shadowEnabled !== t.shadowEnabled ? (t.shadowEnabled ? 1 : 0) - (e.shadowEnabled ? 1 : 0) : t.renderPriority - e.renderPriority;
  }
}
Te.FALLOFF_DEFAULT = 0;
Te.FALLOFF_PHYSICAL = 1;
Te.FALLOFF_GLTF = 2;
Te.FALLOFF_STANDARD = 3;
Te.LIGHTMAP_DEFAULT = 0;
Te.LIGHTMAP_SPECULAR = 1;
Te.LIGHTMAP_SHADOWSONLY = 2;
Te.INTENSITYMODE_AUTOMATIC = 0;
Te.INTENSITYMODE_LUMINOUSPOWER = 1;
Te.INTENSITYMODE_LUMINOUSINTENSITY = 2;
Te.INTENSITYMODE_ILLUMINANCE = 3;
Te.INTENSITYMODE_LUMINANCE = 4;
Te.LIGHTTYPEID_POINTLIGHT = 0;
Te.LIGHTTYPEID_DIRECTIONALLIGHT = 1;
Te.LIGHTTYPEID_SPOTLIGHT = 2;
Te.LIGHTTYPEID_HEMISPHERICLIGHT = 3;
class es {
  constructor(e, t) {
    es.IsAvailable && (this._observer = new window.ComputePressureObserver(e, t));
  }
  static get IsAvailable() {
    var e, t;
    return Ne() && "ComputePressureObserver" in window && ((t = (e = window.ComputePressureObserver) == null ? void 0 : e.supportedSources) == null ? void 0 : t.includes("cpu"));
  }
  observe(e) {
    var t, i;
    (t = this._observer) != null && t.observe && ((i = this._observer) == null || i.observe(e).catch(() => {
    }));
  }
  unobserve(e) {
    var t, i;
    try {
      (t = this._observer) != null && t.unobserve && ((i = this._observer) == null || i.unobserve(e));
    } catch {
    }
  }
}
var ri;
(function(c) {
  c[c.BackwardCompatible = 0] = "BackwardCompatible", c[c.Intermediate = 1] = "Intermediate", c[c.Aggressive = 2] = "Aggressive";
})(ri || (ri = {}));
class re extends rs {
  constructor(e, t) {
    super(), this._inputManager = new Ie(this), this.cameraToUseForPointers = null, this._isScene = !0, this._blockEntityCollection = !1, this.autoClear = !0, this.autoClearDepthAndStencil = !0, this.clearColor = new ge(0.2, 0.2, 0.3, 1), this.ambientColor = new te(0, 0, 0), this.environmentIntensity = 1, this._performancePriority = ri.BackwardCompatible, this._forceWireframe = !1, this._skipFrustumClipping = !1, this._forcePointsCloud = !1, this.animationsEnabled = !0, this._animationPropertiesOverride = null, this.useConstantAnimationDeltaTime = !1, this.constantlyUpdateMeshUnderPointer = !1, this.hoverCursor = "pointer", this.defaultCursor = "", this.doNotHandleCursors = !1, this.preventDefaultOnPointerDown = !0, this.preventDefaultOnPointerUp = !0, this.metadata = null, this.reservedDataStore = null, this.disableOfflineSupportExceptionRules = new Array(), this.onDisposeObservable = new F(), this._onDisposeObserver = null, this.onBeforeRenderObservable = new F(), this._onBeforeRenderObserver = null, this.onAfterRenderObservable = new F(), this.onAfterRenderCameraObservable = new F(), this._onAfterRenderObserver = null, this.onBeforeAnimationsObservable = new F(), this.onAfterAnimationsObservable = new F(), this.onBeforeDrawPhaseObservable = new F(), this.onAfterDrawPhaseObservable = new F(), this.onReadyObservable = new F(), this.onBeforeCameraRenderObservable = new F(), this._onBeforeCameraRenderObserver = null, this.onAfterCameraRenderObservable = new F(), this._onAfterCameraRenderObserver = null, this.onBeforeActiveMeshesEvaluationObservable = new F(), this.onAfterActiveMeshesEvaluationObservable = new F(), this.onBeforeParticlesRenderingObservable = new F(), this.onAfterParticlesRenderingObservable = new F(), this.onDataLoadedObservable = new F(), this.onNewCameraAddedObservable = new F(), this.onCameraRemovedObservable = new F(), this.onNewLightAddedObservable = new F(), this.onLightRemovedObservable = new F(), this.onNewGeometryAddedObservable = new F(), this.onGeometryRemovedObservable = new F(), this.onNewTransformNodeAddedObservable = new F(), this.onTransformNodeRemovedObservable = new F(), this.onNewMeshAddedObservable = new F(), this.onMeshRemovedObservable = new F(), this.onNewSkeletonAddedObservable = new F(), this.onSkeletonRemovedObservable = new F(), this.onNewMaterialAddedObservable = new F(), this.onNewMultiMaterialAddedObservable = new F(), this.onMaterialRemovedObservable = new F(), this.onMultiMaterialRemovedObservable = new F(), this.onNewTextureAddedObservable = new F(), this.onTextureRemovedObservable = new F(), this.onBeforeRenderTargetsRenderObservable = new F(), this.onAfterRenderTargetsRenderObservable = new F(), this.onBeforeStepObservable = new F(), this.onAfterStepObservable = new F(), this.onActiveCameraChanged = new F(), this.onActiveCamerasChanged = new F(), this.onBeforeRenderingGroupObservable = new F(), this.onAfterRenderingGroupObservable = new F(), this.onMeshImportedObservable = new F(), this.onAnimationFileImportedObservable = new F(), this._registeredForLateAnimationBindings = new Jt(256), this.skipPointerMovePicking = !1, this.skipPointerDownPicking = !1, this.skipPointerUpPicking = !1, this.onPrePointerObservable = new F(), this.onPointerObservable = new F(), this.onPreKeyboardObservable = new F(), this.onKeyboardObservable = new F(), this._useRightHandedSystem = !1, this._timeAccumulator = 0, this._currentStepId = 0, this._currentInternalStep = 0, this._fogEnabled = !0, this._fogMode = re.FOGMODE_NONE, this.fogColor = new te(0.2, 0.2, 0.3), this.fogDensity = 0.1, this.fogStart = 0, this.fogEnd = 1e3, this.needsPreviousWorldMatrices = !1, this._shadowsEnabled = !0, this._lightsEnabled = !0, this._activeCameras = Me.MakeObservableArray(this.onActiveCamerasChanged, []), this._texturesEnabled = !0, this.physicsEnabled = !0, this.particlesEnabled = !0, this.spritesEnabled = !0, this._skeletonsEnabled = !0, this.lensFlaresEnabled = !0, this.collisionsEnabled = !0, this.gravity = new g(0, -9.807, 0), this.postProcessesEnabled = !0, this.renderTargetsEnabled = !0, this.dumpNextRenderTargets = !1, this.customRenderTargets = new Array(), this.importedMeshesFiles = new Array(), this.probesEnabled = !0, this._meshesForIntersections = new Jt(256), this.proceduralTexturesEnabled = !0, this._totalVertices = new yt(), this._activeIndices = new yt(), this._activeParticles = new yt(), this._activeBones = new yt(), this._animationTime = 0, this.animationTimeScale = 1, this._renderId = 0, this._frameId = 0, this._executeWhenReadyTimeoutId = null, this._intermediateRendering = !1, this._defaultFrameBufferCleared = !1, this._viewUpdateFlag = -1, this._projectionUpdateFlag = -1, this._toBeDisposed = new Array(256), this._activeRequests = new Array(), this._pendingData = new Array(), this._isDisposed = !1, this.dispatchAllSubMeshesOfActiveMeshes = !1, this._activeMeshes = new Qe(256), this._processedMaterials = new Qe(256), this._renderTargets = new Jt(256), this._materialsRenderTargets = new Jt(256), this._activeParticleSystems = new Qe(256), this._activeSkeletons = new Jt(32), this._softwareSkinnedMeshes = new Jt(32), this._activeAnimatables = new Array(), this._transformMatrix = x.Zero(), this.requireLightSorting = !1, this._components = [], this._serializableComponents = [], this._transientComponents = [], this._beforeCameraUpdateStage = Pe.Create(), this._beforeClearStage = Pe.Create(), this._beforeRenderTargetClearStage = Pe.Create(), this._gatherRenderTargetsStage = Pe.Create(), this._gatherActiveCameraRenderTargetsStage = Pe.Create(), this._isReadyForMeshStage = Pe.Create(), this._beforeEvaluateActiveMeshStage = Pe.Create(), this._evaluateSubMeshStage = Pe.Create(), this._preActiveMeshStage = Pe.Create(), this._cameraDrawRenderTargetStage = Pe.Create(), this._beforeCameraDrawStage = Pe.Create(), this._beforeRenderTargetDrawStage = Pe.Create(), this._beforeRenderingGroupDrawStage = Pe.Create(), this._beforeRenderingMeshStage = Pe.Create(), this._afterRenderingMeshStage = Pe.Create(), this._afterRenderingGroupDrawStage = Pe.Create(), this._afterCameraDrawStage = Pe.Create(), this._afterRenderTargetDrawStage = Pe.Create(), this._afterRenderStage = Pe.Create(), this._pointerMoveStage = Pe.Create(), this._pointerDownStage = Pe.Create(), this._pointerUpStage = Pe.Create(), this._geometriesByUniqueId = null, this._defaultMeshCandidates = {
      data: [],
      length: 0
    }, this._defaultSubMeshCandidates = {
      data: [],
      length: 0
    }, this._preventFreeActiveMeshesAndRenderingGroups = !1, this._activeMeshesFrozen = !1, this._activeMeshesFrozenButKeepClipping = !1, this._skipEvaluateActiveMeshesCompletely = !1, this._allowPostProcessClearColor = !0, this.getDeterministicFrameTime = () => this._engine.getTimeStep(), this._blockMaterialDirtyMechanism = !1, this._perfCollector = null, this.onComputePressureChanged = new F();
    const i = {
      useGeometryUniqueIdsMap: !0,
      useMaterialMeshMap: !0,
      useClonedMeshMap: !0,
      virtual: !1,
      ...t
    };
    this._engine = e || _e.LastCreatedEngine, i.virtual ? this._engine._virtualScenes.push(this) : (_e._LastCreatedScene = this, this._engine.scenes.push(this)), this._uid = null, this._renderingManager = new Ye(this), Qi && (this.postProcessManager = new Qi(this)), Ne() && this.attachControl(), this._createUbo(), me && (this._imageProcessingConfiguration = new me()), this.setDefaultCandidateProviders(), i.useGeometryUniqueIdsMap && (this._geometriesByUniqueId = {}), this.useMaterialMeshMap = i.useMaterialMeshMap, this.useClonedMeshMap = i.useClonedMeshMap, (!t || !t.virtual) && this._engine.onNewSceneAddedObservable.notifyObservers(this), es.IsAvailable && (this._computePressureObserver = new es((s) => {
      this.onComputePressureChanged.notifyObservers(s);
    }, {
      cpuUtilizationThresholds: [0.25, 0.5, 0.75, 0.9],
      cpuSpeedThresholds: [0.5]
    }), this._computePressureObserver.observe("cpu"));
  }
  static DefaultMaterialFactory(e) {
    throw q("StandardMaterial");
  }
  static CollisionCoordinatorFactory() {
    throw q("DefaultCollisionCoordinator");
  }
  get environmentTexture() {
    return this._environmentTexture;
  }
  set environmentTexture(e) {
    this._environmentTexture !== e && (this._environmentTexture = e, this.markAllMaterialsAsDirty(1));
  }
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  get performancePriority() {
    return this._performancePriority;
  }
  set performancePriority(e) {
    if (e !== this._performancePriority)
      switch (this._performancePriority = e, e) {
        case ri.Aggressive:
          this.skipFrustumClipping = !0;
        case ri.Intermediate:
          this.skipPointerMovePicking = !0, this.autoClear = !1;
          break;
      }
  }
  set forceWireframe(e) {
    this._forceWireframe !== e && (this._forceWireframe = e, this.markAllMaterialsAsDirty(16));
  }
  get forceWireframe() {
    return this._forceWireframe;
  }
  set skipFrustumClipping(e) {
    this._skipFrustumClipping !== e && (this._skipFrustumClipping = e);
  }
  get skipFrustumClipping() {
    return this._skipFrustumClipping;
  }
  set forcePointsCloud(e) {
    this._forcePointsCloud !== e && (this._forcePointsCloud = e, this.markAllMaterialsAsDirty(16));
  }
  get forcePointsCloud() {
    return this._forcePointsCloud;
  }
  get animationPropertiesOverride() {
    return this._animationPropertiesOverride;
  }
  set animationPropertiesOverride(e) {
    this._animationPropertiesOverride = e;
  }
  set onDispose(e) {
    this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);
  }
  set beforeRender(e) {
    this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), e && (this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e));
  }
  set afterRender(e) {
    this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), e && (this._onAfterRenderObserver = this.onAfterRenderObservable.add(e));
  }
  set beforeCameraRender(e) {
    this._onBeforeCameraRenderObserver && this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver), this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(e);
  }
  set afterCameraRender(e) {
    this._onAfterCameraRenderObserver && this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver), this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(e);
  }
  get unTranslatedPointer() {
    return this._inputManager.unTranslatedPointer;
  }
  static get DragMovementThreshold() {
    return Ie.DragMovementThreshold;
  }
  static set DragMovementThreshold(e) {
    Ie.DragMovementThreshold = e;
  }
  static get LongPressDelay() {
    return Ie.LongPressDelay;
  }
  static set LongPressDelay(e) {
    Ie.LongPressDelay = e;
  }
  static get DoubleClickDelay() {
    return Ie.DoubleClickDelay;
  }
  static set DoubleClickDelay(e) {
    Ie.DoubleClickDelay = e;
  }
  static get ExclusiveDoubleClickMode() {
    return Ie.ExclusiveDoubleClickMode;
  }
  static set ExclusiveDoubleClickMode(e) {
    Ie.ExclusiveDoubleClickMode = e;
  }
  bindEyePosition(e, t = "vEyePosition", i = !1) {
    var n;
    const s = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : (n = this.activeCamera.globalPosition) != null ? n : this.activeCamera.devicePosition, r = this.useRightHandedSystem === (this._mirroredCameraPosition != null);
    return D.Vector4[0].set(s.x, s.y, s.z, r ? -1 : 1), e && (i ? e.setFloat3(t, D.Vector4[0].x, D.Vector4[0].y, D.Vector4[0].z) : e.setVector4(t, D.Vector4[0])), D.Vector4[0];
  }
  finalizeSceneUbo() {
    const e = this.getSceneUniformBuffer(), t = this.bindEyePosition(null);
    return e.updateFloat4("vEyePosition", t.x, t.y, t.z, t.w), e.update(), e;
  }
  set useRightHandedSystem(e) {
    this._useRightHandedSystem !== e && (this._useRightHandedSystem = e, this.markAllMaterialsAsDirty(16));
  }
  get useRightHandedSystem() {
    return this._useRightHandedSystem;
  }
  setStepId(e) {
    this._currentStepId = e;
  }
  getStepId() {
    return this._currentStepId;
  }
  getInternalStep() {
    return this._currentInternalStep;
  }
  set fogEnabled(e) {
    this._fogEnabled !== e && (this._fogEnabled = e, this.markAllMaterialsAsDirty(16));
  }
  get fogEnabled() {
    return this._fogEnabled;
  }
  set fogMode(e) {
    this._fogMode !== e && (this._fogMode = e, this.markAllMaterialsAsDirty(16));
  }
  get fogMode() {
    return this._fogMode;
  }
  get prePass() {
    return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;
  }
  set shadowsEnabled(e) {
    this._shadowsEnabled !== e && (this._shadowsEnabled = e, this.markAllMaterialsAsDirty(2));
  }
  get shadowsEnabled() {
    return this._shadowsEnabled;
  }
  set lightsEnabled(e) {
    this._lightsEnabled !== e && (this._lightsEnabled = e, this.markAllMaterialsAsDirty(2));
  }
  get lightsEnabled() {
    return this._lightsEnabled;
  }
  get activeCameras() {
    return this._activeCameras;
  }
  set activeCameras(e) {
    this._activeCameras = Me.MakeObservableArray(this.onActiveCamerasChanged, e);
  }
  get activeCamera() {
    return this._activeCamera;
  }
  set activeCamera(e) {
    e !== this._activeCamera && (this._activeCamera = e, this.onActiveCameraChanged.notifyObservers(this));
  }
  get defaultMaterial() {
    return this._defaultMaterial || (this._defaultMaterial = re.DefaultMaterialFactory(this)), this._defaultMaterial;
  }
  set defaultMaterial(e) {
    this._defaultMaterial = e;
  }
  set texturesEnabled(e) {
    this._texturesEnabled !== e && (this._texturesEnabled = e, this.markAllMaterialsAsDirty(1));
  }
  get texturesEnabled() {
    return this._texturesEnabled;
  }
  set skeletonsEnabled(e) {
    this._skeletonsEnabled !== e && (this._skeletonsEnabled = e, this.markAllMaterialsAsDirty(8));
  }
  get skeletonsEnabled() {
    return this._skeletonsEnabled;
  }
  get collisionCoordinator() {
    return this._collisionCoordinator || (this._collisionCoordinator = re.CollisionCoordinatorFactory(), this._collisionCoordinator.init(this)), this._collisionCoordinator;
  }
  get frustumPlanes() {
    return this._frustumPlanes;
  }
  _registerTransientComponents() {
    if (this._transientComponents.length > 0) {
      for (const e of this._transientComponents)
        e.register();
      this._transientComponents.length = 0;
    }
  }
  _addComponent(e) {
    this._components.push(e), this._transientComponents.push(e);
    const t = e;
    t.addFromContainer && t.serialize && this._serializableComponents.push(t);
  }
  _getComponent(e) {
    for (const t of this._components)
      if (t.name === e)
        return t;
    return null;
  }
  getClassName() {
    return "Scene";
  }
  _getDefaultMeshCandidates() {
    return this._defaultMeshCandidates.data = this.meshes, this._defaultMeshCandidates.length = this.meshes.length, this._defaultMeshCandidates;
  }
  _getDefaultSubMeshCandidates(e) {
    return this._defaultSubMeshCandidates.data = e.subMeshes, this._defaultSubMeshCandidates.length = e.subMeshes.length, this._defaultSubMeshCandidates;
  }
  setDefaultCandidateProviders() {
    this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this), this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this), this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this), this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
  }
  get meshUnderPointer() {
    return this._inputManager.meshUnderPointer;
  }
  get pointerX() {
    return this._inputManager.pointerX;
  }
  set pointerX(e) {
    this._inputManager.pointerX = e;
  }
  get pointerY() {
    return this._inputManager.pointerY;
  }
  set pointerY(e) {
    this._inputManager.pointerY = e;
  }
  getCachedMaterial() {
    return this._cachedMaterial;
  }
  getCachedEffect() {
    return this._cachedEffect;
  }
  getCachedVisibility() {
    return this._cachedVisibility;
  }
  isCachedMaterialInvalid(e, t, i = 1) {
    return this._cachedEffect !== t || this._cachedMaterial !== e || this._cachedVisibility !== i;
  }
  getEngine() {
    return this._engine;
  }
  getTotalVertices() {
    return this._totalVertices.current;
  }
  get totalVerticesPerfCounter() {
    return this._totalVertices;
  }
  getActiveIndices() {
    return this._activeIndices.current;
  }
  get totalActiveIndicesPerfCounter() {
    return this._activeIndices;
  }
  getActiveParticles() {
    return this._activeParticles.current;
  }
  get activeParticlesPerfCounter() {
    return this._activeParticles;
  }
  getActiveBones() {
    return this._activeBones.current;
  }
  get activeBonesPerfCounter() {
    return this._activeBones;
  }
  getActiveMeshes() {
    return this._activeMeshes;
  }
  getAnimationRatio() {
    return this._animationRatio !== void 0 ? this._animationRatio : 1;
  }
  getRenderId() {
    return this._renderId;
  }
  getFrameId() {
    return this._frameId;
  }
  incrementRenderId() {
    this._renderId++;
  }
  _createUbo() {
    this.setSceneUniformBuffer(this.createSceneUniformBuffer());
  }
  simulatePointerMove(e, t) {
    return this._inputManager.simulatePointerMove(e, t), this;
  }
  simulatePointerDown(e, t) {
    return this._inputManager.simulatePointerDown(e, t), this;
  }
  simulatePointerUp(e, t, i) {
    return this._inputManager.simulatePointerUp(e, t, i), this;
  }
  isPointerCaptured(e = 0) {
    return this._inputManager.isPointerCaptured(e);
  }
  attachControl(e = !0, t = !0, i = !0) {
    this._inputManager.attachControl(e, t, i);
  }
  detachControl() {
    this._inputManager.detachControl();
  }
  isReady(e = !0) {
    if (this._isDisposed)
      return !1;
    let t;
    const i = this.getEngine();
    let s = !0;
    for (this._pendingData.length > 0 && (s = !1), e && (this._processedMaterials.reset(), this._materialsRenderTargets.reset()), t = 0; t < this.meshes.length; t++) {
      const r = this.meshes[t];
      if (!r.subMeshes || r.subMeshes.length === 0)
        continue;
      if (!r.isReady(!0)) {
        s = !1;
        continue;
      }
      const n = r.hasThinInstances || r.getClassName() === "InstancedMesh" || r.getClassName() === "InstancedLinesMesh" || i.getCaps().instancedArrays && r.instances.length > 0;
      for (const o of this._isReadyForMeshStage)
        o.action(r, n) || (s = !1);
      if (!e)
        continue;
      const a = r.material || this.defaultMaterial;
      if (a)
        if (a._storeEffectOnSubMeshes)
          for (const o of r.subMeshes) {
            const h = o.getMaterial();
            h && h.hasRenderTargetTextures && h.getRenderTargetTextures != null && this._processedMaterials.indexOf(h) === -1 && (this._processedMaterials.push(h), this._materialsRenderTargets.concatWithNoDuplicate(h.getRenderTargetTextures()));
          }
        else
          a.hasRenderTargetTextures && a.getRenderTargetTextures != null && this._processedMaterials.indexOf(a) === -1 && (this._processedMaterials.push(a), this._materialsRenderTargets.concatWithNoDuplicate(a.getRenderTargetTextures()));
    }
    if (!s || !i.areAllEffectsReady())
      return !1;
    if (e) {
      for (t = 0; t < this._materialsRenderTargets.length; ++t)
        if (!this._materialsRenderTargets.data[t].isReadyForRendering())
          return !1;
    }
    for (t = 0; t < this.geometries.length; t++)
      if (this.geometries[t].delayLoadState === 2)
        return !1;
    if (this.activeCameras && this.activeCameras.length > 0) {
      for (const r of this.activeCameras)
        if (!r.isReady(!0))
          return !1;
    } else if (this.activeCamera && !this.activeCamera.isReady(!0))
      return !1;
    for (const r of this.particleSystems)
      if (!r.isReady())
        return !1;
    return !0;
  }
  resetCachedMaterial() {
    this._cachedMaterial = null, this._cachedEffect = null, this._cachedVisibility = null;
  }
  registerBeforeRender(e) {
    this.onBeforeRenderObservable.add(e);
  }
  unregisterBeforeRender(e) {
    this.onBeforeRenderObservable.removeCallback(e);
  }
  registerAfterRender(e) {
    this.onAfterRenderObservable.add(e);
  }
  unregisterAfterRender(e) {
    this.onAfterRenderObservable.removeCallback(e);
  }
  _executeOnceBeforeRender(e) {
    const t = () => {
      e(), setTimeout(() => {
        this.unregisterBeforeRender(t);
      });
    };
    this.registerBeforeRender(t);
  }
  executeOnceBeforeRender(e, t) {
    t !== void 0 ? setTimeout(() => {
      this._executeOnceBeforeRender(e);
    }, t) : this._executeOnceBeforeRender(e);
  }
  addPendingData(e) {
    this._pendingData.push(e);
  }
  removePendingData(e) {
    const t = this.isLoading, i = this._pendingData.indexOf(e);
    i !== -1 && this._pendingData.splice(i, 1), t && !this.isLoading && this.onDataLoadedObservable.notifyObservers(this);
  }
  getWaitingItemsCount() {
    return this._pendingData.length;
  }
  get isLoading() {
    return this._pendingData.length > 0;
  }
  executeWhenReady(e, t = !1) {
    this.onReadyObservable.add(e), this._executeWhenReadyTimeoutId === null && this._checkIsReady(t);
  }
  whenReadyAsync(e = !1) {
    return new Promise((t) => {
      this.executeWhenReady(() => {
        t();
      }, e);
    });
  }
  _checkIsReady(e = !1) {
    if (this._registerTransientComponents(), this.isReady(e)) {
      this.onReadyObservable.notifyObservers(this), this.onReadyObservable.clear(), this._executeWhenReadyTimeoutId = null;
      return;
    }
    if (this._isDisposed) {
      this.onReadyObservable.clear(), this._executeWhenReadyTimeoutId = null;
      return;
    }
    this._executeWhenReadyTimeoutId = setTimeout(() => {
      this.incrementRenderId(), this._checkIsReady(e);
    }, 100);
  }
  get animatables() {
    return this._activeAnimatables;
  }
  resetLastAnimationTimeFrame() {
    this._animationTimeLast = mi.Now;
  }
  getViewMatrix() {
    return this._viewMatrix;
  }
  getProjectionMatrix() {
    return this._projectionMatrix;
  }
  getTransformMatrix() {
    return this._transformMatrix;
  }
  setTransformMatrix(e, t, i, s) {
    !i && !s && this._multiviewSceneUbo && (this._multiviewSceneUbo.dispose(), this._multiviewSceneUbo = null), !(this._viewUpdateFlag === e.updateFlag && this._projectionUpdateFlag === t.updateFlag) && (this._viewUpdateFlag = e.updateFlag, this._projectionUpdateFlag = t.updateFlag, this._viewMatrix = e, this._projectionMatrix = t, this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._frustumPlanes ? pt.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = pt.GetPlanes(this._transformMatrix), this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo ? this._updateMultiviewUbo(i, s) : this._sceneUbo.useUbo && (this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix), this._sceneUbo.updateMatrix("view", this._viewMatrix), this._sceneUbo.updateMatrix("projection", this._projectionMatrix)));
  }
  getSceneUniformBuffer() {
    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;
  }
  createSceneUniformBuffer(e) {
    const t = new G(this._engine, void 0, !1, e != null ? e : "scene");
    return t.addUniform("viewProjection", 16), t.addUniform("view", 16), t.addUniform("projection", 16), t.addUniform("vEyePosition", 4), t;
  }
  setSceneUniformBuffer(e) {
    this._sceneUbo = e, this._viewUpdateFlag = -1, this._projectionUpdateFlag = -1;
  }
  getUniqueId() {
    return Rr.UniqueId;
  }
  addMesh(e, t = !1) {
    this._blockEntityCollection || (this.meshes.push(e), e._resyncLightSources(), e.parent || e._addToSceneRootNodes(), this.onNewMeshAddedObservable.notifyObservers(e), t && e.getChildMeshes().forEach((i) => {
      this.addMesh(i);
    }));
  }
  removeMesh(e, t = !1) {
    const i = this.meshes.indexOf(e);
    return i !== -1 && (this.meshes[i] = this.meshes[this.meshes.length - 1], this.meshes.pop(), e.parent || e._removeFromSceneRootNodes()), this._inputManager._invalidateMesh(e), this.onMeshRemovedObservable.notifyObservers(e), t && e.getChildMeshes().forEach((s) => {
      this.removeMesh(s);
    }), i;
  }
  addTransformNode(e) {
    this._blockEntityCollection || e.getScene() === this && e._indexInSceneTransformNodesArray !== -1 || (e._indexInSceneTransformNodesArray = this.transformNodes.length, this.transformNodes.push(e), e.parent || e._addToSceneRootNodes(), this.onNewTransformNodeAddedObservable.notifyObservers(e));
  }
  removeTransformNode(e) {
    const t = e._indexInSceneTransformNodesArray;
    if (t !== -1) {
      if (t !== this.transformNodes.length - 1) {
        const i = this.transformNodes[this.transformNodes.length - 1];
        this.transformNodes[t] = i, i._indexInSceneTransformNodesArray = t;
      }
      e._indexInSceneTransformNodesArray = -1, this.transformNodes.pop(), e.parent || e._removeFromSceneRootNodes();
    }
    return this.onTransformNodeRemovedObservable.notifyObservers(e), t;
  }
  removeSkeleton(e) {
    const t = this.skeletons.indexOf(e);
    return t !== -1 && (this.skeletons.splice(t, 1), this.onSkeletonRemovedObservable.notifyObservers(e), this._executeActiveContainerCleanup(this._activeSkeletons)), t;
  }
  removeMorphTargetManager(e) {
    const t = this.morphTargetManagers.indexOf(e);
    return t !== -1 && this.morphTargetManagers.splice(t, 1), t;
  }
  removeLight(e) {
    const t = this.lights.indexOf(e);
    if (t !== -1) {
      for (const i of this.meshes)
        i._removeLightSource(e, !1);
      this.lights.splice(t, 1), this.sortLightsByPriority(), e.parent || e._removeFromSceneRootNodes();
    }
    return this.onLightRemovedObservable.notifyObservers(e), t;
  }
  removeCamera(e) {
    const t = this.cameras.indexOf(e);
    if (t !== -1 && (this.cameras.splice(t, 1), e.parent || e._removeFromSceneRootNodes()), this.activeCameras) {
      const i = this.activeCameras.indexOf(e);
      i !== -1 && this.activeCameras.splice(i, 1);
    }
    return this.activeCamera === e && (this.cameras.length > 0 ? this.activeCamera = this.cameras[0] : this.activeCamera = null), this.onCameraRemovedObservable.notifyObservers(e), t;
  }
  removeParticleSystem(e) {
    const t = this.particleSystems.indexOf(e);
    return t !== -1 && (this.particleSystems.splice(t, 1), this._executeActiveContainerCleanup(this._activeParticleSystems)), t;
  }
  removeAnimation(e) {
    const t = this.animations.indexOf(e);
    return t !== -1 && this.animations.splice(t, 1), t;
  }
  stopAnimation(e, t, i) {
  }
  removeAnimationGroup(e) {
    const t = this.animationGroups.indexOf(e);
    return t !== -1 && this.animationGroups.splice(t, 1), t;
  }
  removeMultiMaterial(e) {
    const t = this.multiMaterials.indexOf(e);
    return t !== -1 && this.multiMaterials.splice(t, 1), this.onMultiMaterialRemovedObservable.notifyObservers(e), t;
  }
  removeMaterial(e) {
    const t = e._indexInSceneMaterialArray;
    if (t !== -1 && t < this.materials.length) {
      if (t !== this.materials.length - 1) {
        const i = this.materials[this.materials.length - 1];
        this.materials[t] = i, i._indexInSceneMaterialArray = t;
      }
      e._indexInSceneMaterialArray = -1, this.materials.pop();
    }
    return this.onMaterialRemovedObservable.notifyObservers(e), t;
  }
  removeActionManager(e) {
    const t = this.actionManagers.indexOf(e);
    return t !== -1 && this.actionManagers.splice(t, 1), t;
  }
  removeTexture(e) {
    const t = this.textures.indexOf(e);
    return t !== -1 && this.textures.splice(t, 1), this.onTextureRemovedObservable.notifyObservers(e), t;
  }
  addLight(e) {
    if (!this._blockEntityCollection) {
      this.lights.push(e), this.sortLightsByPriority(), e.parent || e._addToSceneRootNodes();
      for (const t of this.meshes)
        t.lightSources.indexOf(e) === -1 && (t.lightSources.push(e), t._resyncLightSources());
      this.onNewLightAddedObservable.notifyObservers(e);
    }
  }
  sortLightsByPriority() {
    this.requireLightSorting && this.lights.sort(Te.CompareLightsPriority);
  }
  addCamera(e) {
    this._blockEntityCollection || (this.cameras.push(e), this.onNewCameraAddedObservable.notifyObservers(e), e.parent || e._addToSceneRootNodes());
  }
  addSkeleton(e) {
    this._blockEntityCollection || (this.skeletons.push(e), this.onNewSkeletonAddedObservable.notifyObservers(e));
  }
  addParticleSystem(e) {
    this._blockEntityCollection || this.particleSystems.push(e);
  }
  addAnimation(e) {
    this._blockEntityCollection || this.animations.push(e);
  }
  addAnimationGroup(e) {
    this._blockEntityCollection || this.animationGroups.push(e);
  }
  addMultiMaterial(e) {
    this._blockEntityCollection || (this.multiMaterials.push(e), this.onNewMultiMaterialAddedObservable.notifyObservers(e));
  }
  addMaterial(e) {
    this._blockEntityCollection || e.getScene() === this && e._indexInSceneMaterialArray !== -1 || (e._indexInSceneMaterialArray = this.materials.length, this.materials.push(e), this.onNewMaterialAddedObservable.notifyObservers(e));
  }
  addMorphTargetManager(e) {
    this._blockEntityCollection || this.morphTargetManagers.push(e);
  }
  addGeometry(e) {
    this._blockEntityCollection || (this._geometriesByUniqueId && (this._geometriesByUniqueId[e.uniqueId] = this.geometries.length), this.geometries.push(e));
  }
  addActionManager(e) {
    this.actionManagers.push(e);
  }
  addTexture(e) {
    this._blockEntityCollection || (this.textures.push(e), this.onNewTextureAddedObservable.notifyObservers(e));
  }
  switchActiveCamera(e, t = !0) {
    !this._engine.getInputElement() || (this.activeCamera && this.activeCamera.detachControl(), this.activeCamera = e, t && e.attachControl());
  }
  setActiveCameraById(e) {
    const t = this.getCameraById(e);
    return t ? (this.activeCamera = t, t) : null;
  }
  setActiveCameraByName(e) {
    const t = this.getCameraByName(e);
    return t ? (this.activeCamera = t, t) : null;
  }
  getAnimationGroupByName(e) {
    for (let t = 0; t < this.animationGroups.length; t++)
      if (this.animationGroups[t].name === e)
        return this.animationGroups[t];
    return null;
  }
  getMaterialByUniqueID(e) {
    for (let t = 0; t < this.materials.length; t++)
      if (this.materials[t].uniqueId === e)
        return this.materials[t];
    return null;
  }
  getMaterialById(e) {
    for (let t = 0; t < this.materials.length; t++)
      if (this.materials[t].id === e)
        return this.materials[t];
    return null;
  }
  getLastMaterialById(e, t = !1) {
    for (let i = this.materials.length - 1; i >= 0; i--)
      if (this.materials[i].id === e)
        return this.materials[i];
    if (t) {
      for (let i = this.multiMaterials.length - 1; i >= 0; i--)
        if (this.multiMaterials[i].id === e)
          return this.multiMaterials[i];
    }
    return null;
  }
  getMaterialByName(e) {
    for (let t = 0; t < this.materials.length; t++)
      if (this.materials[t].name === e)
        return this.materials[t];
    return null;
  }
  getTextureByUniqueId(e) {
    for (let t = 0; t < this.textures.length; t++)
      if (this.textures[t].uniqueId === e)
        return this.textures[t];
    return null;
  }
  getTextureByName(e) {
    for (let t = 0; t < this.textures.length; t++)
      if (this.textures[t].name === e)
        return this.textures[t];
    return null;
  }
  getCameraById(e) {
    for (let t = 0; t < this.cameras.length; t++)
      if (this.cameras[t].id === e)
        return this.cameras[t];
    return null;
  }
  getCameraByUniqueId(e) {
    for (let t = 0; t < this.cameras.length; t++)
      if (this.cameras[t].uniqueId === e)
        return this.cameras[t];
    return null;
  }
  getCameraByName(e) {
    for (let t = 0; t < this.cameras.length; t++)
      if (this.cameras[t].name === e)
        return this.cameras[t];
    return null;
  }
  getBoneById(e) {
    for (let t = 0; t < this.skeletons.length; t++) {
      const i = this.skeletons[t];
      for (let s = 0; s < i.bones.length; s++)
        if (i.bones[s].id === e)
          return i.bones[s];
    }
    return null;
  }
  getBoneByName(e) {
    for (let t = 0; t < this.skeletons.length; t++) {
      const i = this.skeletons[t];
      for (let s = 0; s < i.bones.length; s++)
        if (i.bones[s].name === e)
          return i.bones[s];
    }
    return null;
  }
  getLightByName(e) {
    for (let t = 0; t < this.lights.length; t++)
      if (this.lights[t].name === e)
        return this.lights[t];
    return null;
  }
  getLightById(e) {
    for (let t = 0; t < this.lights.length; t++)
      if (this.lights[t].id === e)
        return this.lights[t];
    return null;
  }
  getLightByUniqueId(e) {
    for (let t = 0; t < this.lights.length; t++)
      if (this.lights[t].uniqueId === e)
        return this.lights[t];
    return null;
  }
  getParticleSystemById(e) {
    for (let t = 0; t < this.particleSystems.length; t++)
      if (this.particleSystems[t].id === e)
        return this.particleSystems[t];
    return null;
  }
  getGeometryById(e) {
    for (let t = 0; t < this.geometries.length; t++)
      if (this.geometries[t].id === e)
        return this.geometries[t];
    return null;
  }
  _getGeometryByUniqueId(e) {
    if (this._geometriesByUniqueId) {
      const t = this._geometriesByUniqueId[e];
      if (t !== void 0)
        return this.geometries[t];
    } else
      for (let t = 0; t < this.geometries.length; t++)
        if (this.geometries[t].uniqueId === e)
          return this.geometries[t];
    return null;
  }
  pushGeometry(e, t) {
    return !t && this._getGeometryByUniqueId(e.uniqueId) ? !1 : (this.addGeometry(e), this.onNewGeometryAddedObservable.notifyObservers(e), !0);
  }
  removeGeometry(e) {
    let t;
    if (this._geometriesByUniqueId) {
      if (t = this._geometriesByUniqueId[e.uniqueId], t === void 0)
        return !1;
    } else if (t = this.geometries.indexOf(e), t < 0)
      return !1;
    if (t !== this.geometries.length - 1) {
      const i = this.geometries[this.geometries.length - 1];
      i && (this.geometries[t] = i, this._geometriesByUniqueId && (this._geometriesByUniqueId[i.uniqueId] = t));
    }
    return this._geometriesByUniqueId && (this._geometriesByUniqueId[e.uniqueId] = void 0), this.geometries.pop(), this.onGeometryRemovedObservable.notifyObservers(e), !0;
  }
  getGeometries() {
    return this.geometries;
  }
  getMeshById(e) {
    for (let t = 0; t < this.meshes.length; t++)
      if (this.meshes[t].id === e)
        return this.meshes[t];
    return null;
  }
  getMeshesById(e) {
    return this.meshes.filter(function(t) {
      return t.id === e;
    });
  }
  getTransformNodeById(e) {
    for (let t = 0; t < this.transformNodes.length; t++)
      if (this.transformNodes[t].id === e)
        return this.transformNodes[t];
    return null;
  }
  getTransformNodeByUniqueId(e) {
    for (let t = 0; t < this.transformNodes.length; t++)
      if (this.transformNodes[t].uniqueId === e)
        return this.transformNodes[t];
    return null;
  }
  getTransformNodesById(e) {
    return this.transformNodes.filter(function(t) {
      return t.id === e;
    });
  }
  getMeshByUniqueId(e) {
    for (let t = 0; t < this.meshes.length; t++)
      if (this.meshes[t].uniqueId === e)
        return this.meshes[t];
    return null;
  }
  getLastMeshById(e) {
    for (let t = this.meshes.length - 1; t >= 0; t--)
      if (this.meshes[t].id === e)
        return this.meshes[t];
    return null;
  }
  getLastEntryById(e) {
    let t;
    for (t = this.meshes.length - 1; t >= 0; t--)
      if (this.meshes[t].id === e)
        return this.meshes[t];
    for (t = this.transformNodes.length - 1; t >= 0; t--)
      if (this.transformNodes[t].id === e)
        return this.transformNodes[t];
    for (t = this.cameras.length - 1; t >= 0; t--)
      if (this.cameras[t].id === e)
        return this.cameras[t];
    for (t = this.lights.length - 1; t >= 0; t--)
      if (this.lights[t].id === e)
        return this.lights[t];
    return null;
  }
  getNodeById(e) {
    const t = this.getMeshById(e);
    if (t)
      return t;
    const i = this.getTransformNodeById(e);
    if (i)
      return i;
    const s = this.getLightById(e);
    if (s)
      return s;
    const r = this.getCameraById(e);
    if (r)
      return r;
    const n = this.getBoneById(e);
    return n || null;
  }
  getNodeByName(e) {
    const t = this.getMeshByName(e);
    if (t)
      return t;
    const i = this.getTransformNodeByName(e);
    if (i)
      return i;
    const s = this.getLightByName(e);
    if (s)
      return s;
    const r = this.getCameraByName(e);
    if (r)
      return r;
    const n = this.getBoneByName(e);
    return n || null;
  }
  getMeshByName(e) {
    for (let t = 0; t < this.meshes.length; t++)
      if (this.meshes[t].name === e)
        return this.meshes[t];
    return null;
  }
  getTransformNodeByName(e) {
    for (let t = 0; t < this.transformNodes.length; t++)
      if (this.transformNodes[t].name === e)
        return this.transformNodes[t];
    return null;
  }
  getLastSkeletonById(e) {
    for (let t = this.skeletons.length - 1; t >= 0; t--)
      if (this.skeletons[t].id === e)
        return this.skeletons[t];
    return null;
  }
  getSkeletonByUniqueId(e) {
    for (let t = 0; t < this.skeletons.length; t++)
      if (this.skeletons[t].uniqueId === e)
        return this.skeletons[t];
    return null;
  }
  getSkeletonById(e) {
    for (let t = 0; t < this.skeletons.length; t++)
      if (this.skeletons[t].id === e)
        return this.skeletons[t];
    return null;
  }
  getSkeletonByName(e) {
    for (let t = 0; t < this.skeletons.length; t++)
      if (this.skeletons[t].name === e)
        return this.skeletons[t];
    return null;
  }
  getMorphTargetManagerById(e) {
    for (let t = 0; t < this.morphTargetManagers.length; t++)
      if (this.morphTargetManagers[t].uniqueId === e)
        return this.morphTargetManagers[t];
    return null;
  }
  getMorphTargetById(e) {
    for (let t = 0; t < this.morphTargetManagers.length; ++t) {
      const i = this.morphTargetManagers[t];
      for (let s = 0; s < i.numTargets; ++s) {
        const r = i.getTarget(s);
        if (r.id === e)
          return r;
      }
    }
    return null;
  }
  getMorphTargetByName(e) {
    for (let t = 0; t < this.morphTargetManagers.length; ++t) {
      const i = this.morphTargetManagers[t];
      for (let s = 0; s < i.numTargets; ++s) {
        const r = i.getTarget(s);
        if (r.name === e)
          return r;
      }
    }
    return null;
  }
  getPostProcessByName(e) {
    for (let t = 0; t < this.postProcesses.length; ++t) {
      const i = this.postProcesses[t];
      if (i.name === e)
        return i;
    }
    return null;
  }
  isActiveMesh(e) {
    return this._activeMeshes.indexOf(e) !== -1;
  }
  get uid() {
    return this._uid || (this._uid = U.RandomId()), this._uid;
  }
  addExternalData(e, t) {
    return this._externalData || (this._externalData = new Ys()), this._externalData.add(e, t);
  }
  getExternalData(e) {
    return this._externalData ? this._externalData.get(e) : null;
  }
  getOrAddExternalDataWithFactory(e, t) {
    return this._externalData || (this._externalData = new Ys()), this._externalData.getOrAddWithFactory(e, t);
  }
  removeExternalData(e) {
    return this._externalData.remove(e);
  }
  _evaluateSubMesh(e, t, i) {
    if (i.hasInstances || i.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || t.alwaysSelectAsActiveMesh || t.subMeshes.length === 1 || e.isInFrustum(this._frustumPlanes)) {
      for (const r of this._evaluateSubMeshStage)
        r.action(t, e);
      const s = e.getMaterial();
      s != null && (s.hasRenderTargetTextures && s.getRenderTargetTextures != null && this._processedMaterials.indexOf(s) === -1 && (this._processedMaterials.push(s), this._materialsRenderTargets.concatWithNoDuplicate(s.getRenderTargetTextures())), this._renderingManager.dispatch(e, t, s));
    }
  }
  freeProcessedMaterials() {
    this._processedMaterials.dispose();
  }
  get blockfreeActiveMeshesAndRenderingGroups() {
    return this._preventFreeActiveMeshesAndRenderingGroups;
  }
  set blockfreeActiveMeshesAndRenderingGroups(e) {
    this._preventFreeActiveMeshesAndRenderingGroups !== e && (e && (this.freeActiveMeshes(), this.freeRenderingGroups()), this._preventFreeActiveMeshesAndRenderingGroups = e);
  }
  freeActiveMeshes() {
    if (!this.blockfreeActiveMeshesAndRenderingGroups && (this._activeMeshes.dispose(), this.activeCamera && this.activeCamera._activeMeshes && this.activeCamera._activeMeshes.dispose(), this.activeCameras))
      for (let e = 0; e < this.activeCameras.length; e++) {
        const t = this.activeCameras[e];
        t && t._activeMeshes && t._activeMeshes.dispose();
      }
  }
  freeRenderingGroups() {
    if (!this.blockfreeActiveMeshesAndRenderingGroups && (this._renderingManager && this._renderingManager.freeRenderingGroups(), this.textures))
      for (let e = 0; e < this.textures.length; e++) {
        const t = this.textures[e];
        t && t.renderList && t.freeRenderingGroups();
      }
  }
  _isInIntermediateRendering() {
    return this._intermediateRendering;
  }
  freezeActiveMeshes(e = !1, t, i, s = !0, r = !1) {
    return this.executeWhenReady(() => {
      if (!this.activeCamera) {
        i && i("No active camera found");
        return;
      }
      if (this._frustumPlanes || this.updateTransformMatrix(), this._evaluateActiveMeshes(), this._activeMeshesFrozen = !0, this._activeMeshesFrozenButKeepClipping = r, this._skipEvaluateActiveMeshesCompletely = e, s)
        for (let n = 0; n < this._activeMeshes.length; n++)
          this._activeMeshes.data[n]._freeze();
      t && t();
    }), this;
  }
  unfreezeActiveMeshes() {
    for (let e = 0; e < this.meshes.length; e++) {
      const t = this.meshes[e];
      t._internalAbstractMeshDataInfo && (t._internalAbstractMeshDataInfo._isActive = !1);
    }
    for (let e = 0; e < this._activeMeshes.length; e++)
      this._activeMeshes.data[e]._unFreeze();
    return this._activeMeshesFrozen = !1, this;
  }
  _executeActiveContainerCleanup(e) {
    !(this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) && this._activeMeshesFrozen && this._activeMeshes.length || this.onBeforeRenderObservable.addOnce(() => e.dispose());
  }
  _evaluateActiveMeshes() {
    var i;
    if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {
      this._activeMeshes.length > 0 && ((i = this.activeCamera) == null || i._activeMeshes.reset(), this._activeMeshes.reset(), this._renderingManager.reset(), this._processedMaterials.reset(), this._activeParticleSystems.reset(), this._activeSkeletons.reset(), this._softwareSkinnedMeshes.reset());
      return;
    }
    if (this._activeMeshesFrozen && this._activeMeshes.length) {
      if (!this._skipEvaluateActiveMeshesCompletely) {
        const s = this._activeMeshes.length;
        for (let r = 0; r < s; r++)
          this._activeMeshes.data[r].computeWorldMatrix();
      }
      if (this._activeParticleSystems) {
        const s = this._activeParticleSystems.length;
        for (let r = 0; r < s; r++)
          this._activeParticleSystems.data[r].animate();
      }
      return;
    }
    if (!this.activeCamera)
      return;
    this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this), this.activeCamera._activeMeshes.reset(), this._activeMeshes.reset(), this._renderingManager.reset(), this._processedMaterials.reset(), this._activeParticleSystems.reset(), this._activeSkeletons.reset(), this._softwareSkinnedMeshes.reset(), this._materialsRenderTargets.reset();
    for (const s of this._beforeEvaluateActiveMeshStage)
      s.action();
    const e = this.getActiveMeshCandidates(), t = e.length;
    for (let s = 0; s < t; s++) {
      const r = e.data[s];
      if (r._internalAbstractMeshDataInfo._currentLODIsUpToDate = !1, r.isBlocked || (this._totalVertices.addCount(r.getTotalVertices(), !1), !r.isReady() || !r.isEnabled() || r.scaling.hasAZeroComponent))
        continue;
      r.computeWorldMatrix(), r.actionManager && r.actionManager.hasSpecificTriggers2(12, 13) && this._meshesForIntersections.pushNoDuplicate(r);
      let n = this.customLODSelector ? this.customLODSelector(r, this.activeCamera) : r.getLOD(this.activeCamera);
      if (r._internalAbstractMeshDataInfo._currentLOD = n, r._internalAbstractMeshDataInfo._currentLODIsUpToDate = !0, n != null && (n !== r && n.billboardMode !== 0 && n.computeWorldMatrix(), r._preActivate(), r.isVisible && r.visibility > 0 && (r.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || r.alwaysSelectAsActiveMesh || r.isInFrustum(this._frustumPlanes)))) {
        this._activeMeshes.push(r), this.activeCamera._activeMeshes.push(r), n !== r && n._activate(this._renderId, !1);
        for (const a of this._preActiveMeshStage)
          a.action(r);
        r._activate(this._renderId, !1) && (r.isAnInstance ? r._internalAbstractMeshDataInfo._actAsRegularMesh && (n = r) : n._internalAbstractMeshDataInfo._onlyForInstances = !1, n._internalAbstractMeshDataInfo._isActive = !0, this._activeMesh(r, n)), r._postActivate();
      }
    }
    if (this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this), this.particlesEnabled) {
      this.onBeforeParticlesRenderingObservable.notifyObservers(this);
      for (let s = 0; s < this.particleSystems.length; s++) {
        const r = this.particleSystems[s];
        if (!r.isStarted() || !r.emitter)
          continue;
        const n = r.emitter;
        (!n.position || n.isEnabled()) && (this._activeParticleSystems.push(r), r.animate(), this._renderingManager.dispatchParticles(r));
      }
      this.onAfterParticlesRenderingObservable.notifyObservers(this);
    }
  }
  _activeMesh(e, t) {
    if (this._skeletonsEnabled && t.skeleton !== null && t.skeleton !== void 0 && (this._activeSkeletons.pushNoDuplicate(t.skeleton) && (t.skeleton.prepare(), this._activeBones.addCount(t.skeleton.bones.length, !1)), t.computeBonesUsingShaders || this._softwareSkinnedMeshes.pushNoDuplicate(t)), t && t.subMeshes && t.subMeshes.length > 0) {
      const i = this.getActiveSubMeshCandidates(t), s = i.length;
      for (let r = 0; r < s; r++) {
        const n = i.data[r];
        this._evaluateSubMesh(n, t, e);
      }
    }
  }
  updateTransformMatrix(e) {
    if (!!this.activeCamera)
      if (this.activeCamera._renderingMultiview) {
        const t = this.activeCamera._rigCameras[0], i = this.activeCamera._rigCameras[1];
        this.setTransformMatrix(t.getViewMatrix(), t.getProjectionMatrix(e), i.getViewMatrix(), i.getProjectionMatrix(e));
      } else
        this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(e));
  }
  _bindFrameBuffer(e, t = !0) {
    e && e._multiviewTexture ? e._multiviewTexture._bindFrameBuffer() : e && e.outputRenderTarget ? e.outputRenderTarget._bindFrameBuffer() : this._engine._currentFrameBufferIsDefaultFrameBuffer() || this._engine.restoreDefaultFramebuffer(), t && this._clearFrameBuffer(e);
  }
  _clearFrameBuffer(e) {
    if (!(e && e._multiviewTexture))
      if (e && e.outputRenderTarget) {
        const t = e.outputRenderTarget;
        t.onClearObservable.hasObservers() ? t.onClearObservable.notifyObservers(this._engine) : t.skipInitialClear || (this.autoClear && this._engine.clear(t.clearColor || this.clearColor, !t._cleared, !0, !0), t._cleared = !0);
      } else
        this._defaultFrameBufferCleared ? this._engine.clear(null, !1, !0, !0) : (this._defaultFrameBufferCleared = !0, this._clear());
  }
  _renderForCamera(e, t, i = !0) {
    var n, a, o;
    if (e && e._skipRendering)
      return;
    const s = this._engine;
    if (this._activeCamera = e, !this.activeCamera)
      throw new Error("Active camera not set");
    if (s.setViewport(this.activeCamera.viewport), this.resetCachedMaterial(), this._renderId++, !this.prePass && i) {
      let h = !0;
      e._renderingMultiview && e.outputRenderTarget && (h = e.outputRenderTarget.skipInitialClear, this.autoClear && (e.outputRenderTarget.skipInitialClear = !1)), this._bindFrameBuffer(this._activeCamera), e._renderingMultiview && e.outputRenderTarget && (e.outputRenderTarget.skipInitialClear = h);
    }
    this.updateTransformMatrix(), this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera), this._evaluateActiveMeshes();
    for (let h = 0; h < this._softwareSkinnedMeshes.length; h++) {
      const l = this._softwareSkinnedMeshes.data[h];
      l.applySkeleton(l.skeleton);
    }
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this), this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets), e.customRenderTargets && e.customRenderTargets.length > 0 && this._renderTargets.concatWithNoDuplicate(e.customRenderTargets), t && t.customRenderTargets && t.customRenderTargets.length > 0 && this._renderTargets.concatWithNoDuplicate(t.customRenderTargets), this.environmentTexture && this.environmentTexture.isRenderTarget && this._renderTargets.pushNoDuplicate(this.environmentTexture);
    for (const h of this._gatherActiveCameraRenderTargetsStage)
      h.action(this._renderTargets);
    let r = !1;
    if (this.renderTargetsEnabled) {
      if (this._intermediateRendering = !0, this._renderTargets.length > 0) {
        U.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
        for (let h = 0; h < this._renderTargets.length; h++) {
          const l = this._renderTargets.data[h];
          if (l._shouldRender()) {
            this._renderId++;
            const u = l.activeCamera && l.activeCamera !== this.activeCamera;
            l.render(u, this.dumpNextRenderTargets), r = !0;
          }
        }
        U.EndPerformanceCounter("Render targets", this._renderTargets.length > 0), this._renderId++;
      }
      for (const h of this._cameraDrawRenderTargetStage)
        r = h.action(this.activeCamera) || r;
      this._intermediateRendering = !1;
    }
    this._engine.currentRenderPassId = (o = (a = (n = e.outputRenderTarget) == null ? void 0 : n.renderPassId) != null ? a : e.renderPassId) != null ? o : 0, r && !this.prePass && this._bindFrameBuffer(this._activeCamera, !1), this.onAfterRenderTargetsRenderObservable.notifyObservers(this), this.postProcessManager && !e._multiviewTexture && !this.prePass && this.postProcessManager._prepareFrame();
    for (const h of this._beforeCameraDrawStage)
      h.action(this.activeCamera);
    this.onBeforeDrawPhaseObservable.notifyObservers(this), s.snapshotRendering && s.snapshotRenderingMode === 1 && this.finalizeSceneUbo(), this._renderingManager.render(null, null, !0, !0), this.onAfterDrawPhaseObservable.notifyObservers(this);
    for (const h of this._afterCameraDrawStage)
      h.action(this.activeCamera);
    if (this.postProcessManager && !e._multiviewTexture) {
      const h = e.outputRenderTarget ? e.outputRenderTarget.renderTarget : void 0;
      this.postProcessManager._finalizeFrame(e.isIntermediate, h);
    }
    this._renderTargets.reset(), this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);
  }
  _processSubCameras(e, t = !0) {
    if (e.cameraRigMode === 0 || e._renderingMultiview) {
      e._renderingMultiview && !this._multiviewSceneUbo && this._createMultiviewUbo(), this._renderForCamera(e, void 0, t), this.onAfterRenderCameraObservable.notifyObservers(e);
      return;
    }
    if (e._useMultiviewToSingleView)
      this._renderMultiviewToSingleView(e);
    else {
      this.onBeforeCameraRenderObservable.notifyObservers(e);
      for (let i = 0; i < e._rigCameras.length; i++)
        this._renderForCamera(e._rigCameras[i], e);
    }
    this._activeCamera = e, this.updateTransformMatrix(), this.onAfterRenderCameraObservable.notifyObservers(e);
  }
  _checkIntersections() {
    for (let e = 0; e < this._meshesForIntersections.length; e++) {
      const t = this._meshesForIntersections.data[e];
      if (!!t.actionManager)
        for (let i = 0; t.actionManager && i < t.actionManager.actions.length; i++) {
          const s = t.actionManager.actions[i];
          if (s.trigger === 12 || s.trigger === 13) {
            const r = s.getTriggerParameter(), n = r.mesh ? r.mesh : r, a = n.intersectsMesh(t, r.usePreciseIntersection), o = t._intersectionsInProgress.indexOf(n);
            a && o === -1 ? s.trigger === 12 ? (s._executeCurrent(ze.CreateNew(t, void 0, n)), t._intersectionsInProgress.push(n)) : s.trigger === 13 && t._intersectionsInProgress.push(n) : !a && o > -1 && (s.trigger === 13 && s._executeCurrent(ze.CreateNew(t, void 0, n)), (!t.actionManager.hasSpecificTrigger(13, (h) => {
              const l = h.mesh ? h.mesh : h;
              return n === l;
            }) || s.trigger === 13) && t._intersectionsInProgress.splice(o, 1));
          }
        }
    }
  }
  _advancePhysicsEngineStep(e) {
  }
  _animate() {
  }
  animate() {
    if (this._engine.isDeterministicLockStep()) {
      let e = Math.max(re.MinDeltaTime, Math.min(this._engine.getDeltaTime(), re.MaxDeltaTime)) + this._timeAccumulator;
      const t = this._engine.getTimeStep(), i = 1e3 / t / 1e3;
      let s = 0;
      const r = this._engine.getLockstepMaxSteps();
      let n = Math.floor(e / t);
      for (n = Math.min(n, r); e > 0 && s < n; )
        this.onBeforeStepObservable.notifyObservers(this), this._animationRatio = t * i, this._animate(), this.onAfterAnimationsObservable.notifyObservers(this), this.physicsEnabled && this._advancePhysicsEngineStep(t), this.onAfterStepObservable.notifyObservers(this), this._currentStepId++, s++, e -= t;
      this._timeAccumulator = e < 0 ? 0 : e;
    } else {
      const e = this.useConstantAnimationDeltaTime ? 16 : Math.max(re.MinDeltaTime, Math.min(this._engine.getDeltaTime(), re.MaxDeltaTime));
      this._animationRatio = e * (60 / 1e3), this._animate(), this.onAfterAnimationsObservable.notifyObservers(this), this.physicsEnabled && this._advancePhysicsEngineStep(e);
    }
  }
  _clear() {
    (this.autoClearDepthAndStencil || this.autoClear) && this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);
  }
  _checkCameraRenderTarget(e) {
    var t;
    if ((e == null ? void 0 : e.outputRenderTarget) && !(e != null && e.isRigCamera) && (e.outputRenderTarget._cleared = !1), (t = e == null ? void 0 : e.rigCameras) != null && t.length)
      for (let i = 0; i < e.rigCameras.length; ++i) {
        const s = e.rigCameras[i].outputRenderTarget;
        s && (s._cleared = !1);
      }
  }
  resetDrawCache(e) {
    if (!!this.meshes)
      for (const t of this.meshes)
        t.resetDrawCache(e);
  }
  render(e = !0, t = !1) {
    var n, a, o;
    if (this.isDisposed)
      return;
    this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null && this._checkIsReady(), this._frameId++, this._defaultFrameBufferCleared = !1, this._checkCameraRenderTarget(this.activeCamera), (n = this.activeCameras) != null && n.length && this.activeCameras.forEach(this._checkCameraRenderTarget), this._registerTransientComponents(), this._activeParticles.fetchNewFrame(), this._totalVertices.fetchNewFrame(), this._activeIndices.fetchNewFrame(), this._activeBones.fetchNewFrame(), this._meshesForIntersections.reset(), this.resetCachedMaterial(), this.onBeforeAnimationsObservable.notifyObservers(this), this.actionManager && this.actionManager.processTrigger(11), t || this.animate();
    for (const h of this._beforeCameraUpdateStage)
      h.action();
    if (e) {
      if (this.activeCameras && this.activeCameras.length > 0)
        for (let h = 0; h < this.activeCameras.length; h++) {
          const l = this.activeCameras[h];
          if (l.update(), l.cameraRigMode !== 0)
            for (let u = 0; u < l._rigCameras.length; u++)
              l._rigCameras[u].update();
        }
      else if (this.activeCamera && (this.activeCamera.update(), this.activeCamera.cameraRigMode !== 0))
        for (let h = 0; h < this.activeCamera._rigCameras.length; h++)
          this.activeCamera._rigCameras[h].update();
    }
    this.onBeforeRenderObservable.notifyObservers(this);
    const i = this.getEngine();
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
    const s = (a = this.activeCameras) != null && a.length ? this.activeCameras[0] : this.activeCamera;
    if (this.renderTargetsEnabled) {
      U.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0), this._intermediateRendering = !0;
      for (let h = 0; h < this.customRenderTargets.length; h++) {
        const l = this.customRenderTargets[h];
        if (l._shouldRender()) {
          if (this._renderId++, this.activeCamera = l.activeCamera || this.activeCamera, !this.activeCamera)
            throw new Error("Active camera not set");
          i.setViewport(this.activeCamera.viewport), this.updateTransformMatrix(), l.render(s !== this.activeCamera, this.dumpNextRenderTargets);
        }
      }
      U.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0), this._intermediateRendering = !1, this._renderId++;
    }
    this._engine.currentRenderPassId = (o = s == null ? void 0 : s.renderPassId) != null ? o : 0, this.activeCamera = s, this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass && this._bindFrameBuffer(this._activeCamera, !1), this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
    for (const h of this._beforeClearStage)
      h.action();
    this._clearFrameBuffer(this.activeCamera);
    for (const h of this._gatherRenderTargetsStage)
      h.action(this._renderTargets);
    const r = this._activeCamera;
    if (this.activeCameras && this.activeCameras.length > 0)
      for (let h = 0; h < this.activeCameras.length; h++)
        this._processSubCameras(this.activeCameras[h], h > 0);
    else {
      if (!this.activeCamera)
        throw new Error("No camera defined");
      this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);
    }
    this._activeCamera = r, this._checkIntersections();
    for (const h of this._afterRenderStage)
      h.action();
    if (this.afterRender && this.afterRender(), this.onAfterRenderObservable.notifyObservers(this), this._toBeDisposed.length) {
      for (let h = 0; h < this._toBeDisposed.length; h++) {
        const l = this._toBeDisposed[h];
        l && l.dispose();
      }
      this._toBeDisposed.length = 0;
    }
    this.dumpNextRenderTargets && (this.dumpNextRenderTargets = !1), this._activeBones.addCount(0, !0), this._activeIndices.addCount(0, !0), this._activeParticles.addCount(0, !0), this._engine.restoreDefaultFramebuffer();
  }
  freezeMaterials() {
    for (let e = 0; e < this.materials.length; e++)
      this.materials[e].freeze();
  }
  unfreezeMaterials() {
    for (let e = 0; e < this.materials.length; e++)
      this.materials[e].unfreeze();
  }
  dispose() {
    var s;
    if (this.isDisposed)
      return;
    this.beforeRender = null, this.afterRender = null, this.metadata = null, this.skeletons.length = 0, this.morphTargetManagers.length = 0, this._transientComponents.length = 0, this._isReadyForMeshStage.clear(), this._beforeEvaluateActiveMeshStage.clear(), this._evaluateSubMeshStage.clear(), this._preActiveMeshStage.clear(), this._cameraDrawRenderTargetStage.clear(), this._beforeCameraDrawStage.clear(), this._beforeRenderTargetDrawStage.clear(), this._beforeRenderingGroupDrawStage.clear(), this._beforeRenderingMeshStage.clear(), this._afterRenderingMeshStage.clear(), this._afterRenderingGroupDrawStage.clear(), this._afterCameraDrawStage.clear(), this._afterRenderTargetDrawStage.clear(), this._afterRenderStage.clear(), this._beforeCameraUpdateStage.clear(), this._beforeClearStage.clear(), this._gatherRenderTargetsStage.clear(), this._gatherActiveCameraRenderTargetsStage.clear(), this._pointerMoveStage.clear(), this._pointerDownStage.clear(), this._pointerUpStage.clear(), this.importedMeshesFiles = new Array(), this.stopAllAnimations && this.stopAllAnimations(), this.resetCachedMaterial(), this.activeCamera && (this.activeCamera._activeMeshes.dispose(), this.activeCamera = null), this._activeMeshes.dispose(), this._renderingManager.dispose(), this._processedMaterials.dispose(), this._activeParticleSystems.dispose(), this._activeSkeletons.dispose(), this._softwareSkinnedMeshes.dispose(), this._renderTargets.dispose(), this._materialsRenderTargets.dispose(), this._registeredForLateAnimationBindings.dispose(), this._meshesForIntersections.dispose(), this._toBeDisposed.length = 0;
    const e = this._activeRequests.slice();
    for (const r of e)
      r.abort();
    if (this._activeRequests.length = 0, this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onBeforeRenderObservable.clear(), this.onAfterRenderObservable.clear(), this.onBeforeRenderTargetsRenderObservable.clear(), this.onAfterRenderTargetsRenderObservable.clear(), this.onAfterStepObservable.clear(), this.onBeforeStepObservable.clear(), this.onBeforeActiveMeshesEvaluationObservable.clear(), this.onAfterActiveMeshesEvaluationObservable.clear(), this.onBeforeParticlesRenderingObservable.clear(), this.onAfterParticlesRenderingObservable.clear(), this.onBeforeDrawPhaseObservable.clear(), this.onAfterDrawPhaseObservable.clear(), this.onBeforeAnimationsObservable.clear(), this.onAfterAnimationsObservable.clear(), this.onDataLoadedObservable.clear(), this.onBeforeRenderingGroupObservable.clear(), this.onAfterRenderingGroupObservable.clear(), this.onMeshImportedObservable.clear(), this.onBeforeCameraRenderObservable.clear(), this.onAfterCameraRenderObservable.clear(), this.onReadyObservable.clear(), this.onNewCameraAddedObservable.clear(), this.onCameraRemovedObservable.clear(), this.onNewLightAddedObservable.clear(), this.onLightRemovedObservable.clear(), this.onNewGeometryAddedObservable.clear(), this.onGeometryRemovedObservable.clear(), this.onNewTransformNodeAddedObservable.clear(), this.onTransformNodeRemovedObservable.clear(), this.onNewMeshAddedObservable.clear(), this.onMeshRemovedObservable.clear(), this.onNewSkeletonAddedObservable.clear(), this.onSkeletonRemovedObservable.clear(), this.onNewMaterialAddedObservable.clear(), this.onNewMultiMaterialAddedObservable.clear(), this.onMaterialRemovedObservable.clear(), this.onMultiMaterialRemovedObservable.clear(), this.onNewTextureAddedObservable.clear(), this.onTextureRemovedObservable.clear(), this.onPrePointerObservable.clear(), this.onPointerObservable.clear(), this.onPreKeyboardObservable.clear(), this.onKeyboardObservable.clear(), this.onActiveCameraChanged.clear(), this.onComputePressureChanged.clear(), (s = this._computePressureObserver) == null || s.unobserve("cpu"), this._computePressureObserver = void 0, this.detachControl(), this._engine.getInputElement())
      for (let r = 0; r < this.cameras.length; r++)
        this.cameras[r].detachControl();
    this._disposeList(this.animationGroups), this._disposeList(this.lights), this._disposeList(this.meshes, (r) => r.dispose(!0)), this._disposeList(this.transformNodes, (r) => r.dispose(!0)), this._disposeList(this.cameras), this._defaultMaterial && this._defaultMaterial.dispose(), this._disposeList(this.multiMaterials), this._disposeList(this.materials), this._disposeList(this.particleSystems), this._disposeList(this.postProcesses), this._disposeList(this.textures), this._disposeList(this.morphTargetManagers), this._sceneUbo.dispose(), this._multiviewSceneUbo && this._multiviewSceneUbo.dispose(), this.postProcessManager.dispose(), this._disposeList(this._components);
    let i = this._engine.scenes.indexOf(this);
    i > -1 && this._engine.scenes.splice(i, 1), _e._LastCreatedScene === this && (this._engine.scenes.length > 0 ? _e._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1] : _e._LastCreatedScene = null), i = this._engine._virtualScenes.indexOf(this), i > -1 && this._engine._virtualScenes.splice(i, 1), this._engine.wipeCaches(!0), this._isDisposed = !0;
  }
  _disposeList(e, t) {
    const i = e.slice(0);
    t = t != null ? t : (s) => s.dispose();
    for (const s of i)
      t(s);
    e.length = 0;
  }
  get isDisposed() {
    return this._isDisposed;
  }
  clearCachedVertexData() {
    for (let e = 0; e < this.meshes.length; e++) {
      const i = this.meshes[e].geometry;
      i && i.clearCachedData();
    }
  }
  cleanCachedTextureBuffer() {
    for (const e of this.textures)
      e._buffer && (e._buffer = null);
  }
  getWorldExtends(e) {
    const t = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), i = new g(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    return e = e || (() => !0), this.meshes.filter(e).forEach((s) => {
      if (s.computeWorldMatrix(!0), !s.subMeshes || s.subMeshes.length === 0 || s.infiniteDistance)
        return;
      const r = s.getBoundingInfo(), n = r.boundingBox.minimumWorld, a = r.boundingBox.maximumWorld;
      g.CheckExtends(n, t, i), g.CheckExtends(a, t, i);
    }), {
      min: t,
      max: i
    };
  }
  createPickingRay(e, t, i, s, r = !1) {
    throw q("Ray");
  }
  createPickingRayToRef(e, t, i, s, r, n = !1, a = !1) {
    throw q("Ray");
  }
  createPickingRayInCameraSpace(e, t, i) {
    throw q("Ray");
  }
  createPickingRayInCameraSpaceToRef(e, t, i, s) {
    throw q("Ray");
  }
  pick(e, t, i, s, r, n) {
    const a = new vt();
    return a._pickingUnavailable = !0, a;
  }
  pickWithBoundingInfo(e, t, i, s, r) {
    const n = new vt();
    return n._pickingUnavailable = !0, n;
  }
  pickWithRay(e, t, i, s) {
    throw q("Ray");
  }
  multiPick(e, t, i, s, r) {
    throw q("Ray");
  }
  multiPickWithRay(e, t, i) {
    throw q("Ray");
  }
  setPointerOverMesh(e, t, i) {
    this._inputManager.setPointerOverMesh(e, t, i);
  }
  getPointerOverMesh() {
    return this._inputManager.getPointerOverMesh();
  }
  _rebuildGeometries() {
    for (const e of this.geometries)
      e._rebuild();
    for (const e of this.meshes)
      e._rebuild();
    this.postProcessManager && this.postProcessManager._rebuild();
    for (const e of this._components)
      e.rebuild();
    for (const e of this.particleSystems)
      e.rebuild();
    if (this.spriteManagers)
      for (const e of this.spriteManagers)
        e.rebuild();
  }
  _rebuildTextures() {
    for (const e of this.textures)
      e._rebuild();
    this.markAllMaterialsAsDirty(1);
  }
  _getByTags(e, t, i) {
    if (t === void 0)
      return e;
    const s = [];
    i = i || ((r) => {
    });
    for (const r in e) {
      const n = e[r];
      pe && pe.MatchesQuery(n, t) && (s.push(n), i(n));
    }
    return s;
  }
  getMeshesByTags(e, t) {
    return this._getByTags(this.meshes, e, t);
  }
  getCamerasByTags(e, t) {
    return this._getByTags(this.cameras, e, t);
  }
  getLightsByTags(e, t) {
    return this._getByTags(this.lights, e, t);
  }
  getMaterialByTags(e, t) {
    return this._getByTags(this.materials, e, t).concat(this._getByTags(this.multiMaterials, e, t));
  }
  getTransformNodesByTags(e, t) {
    return this._getByTags(this.transformNodes, e, t);
  }
  setRenderingOrder(e, t = null, i = null, s = null) {
    this._renderingManager.setRenderingOrder(e, t, i, s);
  }
  setRenderingAutoClearDepthStencil(e, t, i = !0, s = !0) {
    this._renderingManager.setRenderingAutoClearDepthStencil(e, t, i, s);
  }
  getAutoClearDepthStencilSetup(e) {
    return this._renderingManager.getAutoClearDepthStencilSetup(e);
  }
  get blockMaterialDirtyMechanism() {
    return this._blockMaterialDirtyMechanism;
  }
  set blockMaterialDirtyMechanism(e) {
    this._blockMaterialDirtyMechanism !== e && (this._blockMaterialDirtyMechanism = e, e || this.markAllMaterialsAsDirty(63));
  }
  markAllMaterialsAsDirty(e, t) {
    if (!this._blockMaterialDirtyMechanism)
      for (const i of this.materials)
        t && !t(i) || i.markAsDirty(e);
  }
  _loadFile(e, t, i, s, r, n, a) {
    const o = qt(e, t, i, s ? this.offlineProvider : void 0, r, n, a);
    return this._activeRequests.push(o), o.onCompleteObservable.add((h) => {
      this._activeRequests.splice(this._activeRequests.indexOf(h), 1);
    }), o;
  }
  _loadFileAsync(e, t, i, s, r) {
    return new Promise((n, a) => {
      this._loadFile(e, (o) => {
        n(o);
      }, t, i, s, (o, h) => {
        a(h);
      }, r);
    });
  }
  _requestFile(e, t, i, s, r, n, a) {
    const o = Bs(e, t, i, s ? this.offlineProvider : void 0, r, n, a);
    return this._activeRequests.push(o), o.onCompleteObservable.add((h) => {
      this._activeRequests.splice(this._activeRequests.indexOf(h), 1);
    }), o;
  }
  _requestFileAsync(e, t, i, s, r) {
    return new Promise((n, a) => {
      this._requestFile(e, (o) => {
        n(o);
      }, t, i, s, (o) => {
        a(o);
      }, r);
    });
  }
  _readFile(e, t, i, s, r) {
    const n = Ci(e, t, i, s, r);
    return this._activeRequests.push(n), n.onCompleteObservable.add((a) => {
      this._activeRequests.splice(this._activeRequests.indexOf(a), 1);
    }), n;
  }
  _readFileAsync(e, t, i) {
    return new Promise((s, r) => {
      this._readFile(e, (n) => {
        s(n);
      }, t, i, (n) => {
        r(n);
      });
    });
  }
  getPerfCollector() {
    throw q("performanceViewerSceneExtension");
  }
}
re.FOGMODE_NONE = 0;
re.FOGMODE_EXP = 1;
re.FOGMODE_EXP2 = 2;
re.FOGMODE_LINEAR = 3;
re.MinDeltaTime = 1;
re.MaxDeltaTime = 1e3;
re.prototype.setActiveCameraByID = function(c) {
  return this.setActiveCameraById(c);
};
re.prototype.getLastMaterialByID = function(c) {
  return this.getLastMaterialById(c);
};
re.prototype.getMaterialByID = function(c) {
  return this.getMaterialById(c);
};
re.prototype.getTextureByUniqueID = function(c) {
  return this.getTextureByUniqueId(c);
};
re.prototype.getCameraByID = function(c) {
  return this.getCameraById(c);
};
re.prototype.getCameraByUniqueID = function(c) {
  return this.getCameraByUniqueId(c);
};
re.prototype.getBoneByID = function(c) {
  return this.getBoneById(c);
};
re.prototype.getLightByID = function(c) {
  return this.getLightById(c);
};
re.prototype.getLightByUniqueID = function(c) {
  return this.getLightByUniqueId(c);
};
re.prototype.getParticleSystemByID = function(c) {
  return this.getParticleSystemById(c);
};
re.prototype.getGeometryByID = function(c) {
  return this.getGeometryById(c);
};
re.prototype.getMeshByID = function(c) {
  return this.getMeshById(c);
};
re.prototype.getMeshesByID = function(c) {
  return this.getMeshesById(c);
};
re.prototype.getTransformNodeByID = function(c) {
  return this.getTransformNodeById(c);
};
re.prototype.getTransformNodeByUniqueID = function(c) {
  return this.getTransformNodeByUniqueId(c);
};
re.prototype.getTransformNodesByID = function(c) {
  return this.getTransformNodesById(c);
};
re.prototype.getMeshByUniqueID = function(c) {
  return this.getMeshByUniqueId(c);
};
re.prototype.getLastMeshByID = function(c) {
  return this.getLastMeshById(c);
};
re.prototype.getLastEntryByID = function(c) {
  return this.getLastEntryById(c);
};
re.prototype.getNodeByID = function(c) {
  return this.getNodeById(c);
};
re.prototype.getLastSkeletonByID = function(c) {
  return this.getLastSkeletonById(c);
};
function Ps(c, e, t) {
  try {
    const i = c.next();
    i.done ? e(i) : i.value ? i.value.then(() => {
      i.value = void 0, e(i);
    }, t) : e(i);
  } catch (i) {
    t(i);
  }
}
function vn(c = 25) {
  let e;
  return (t, i, s) => {
    const r = performance.now();
    e === void 0 || r - e > c ? (e = r, setTimeout(() => {
      Ps(t, i, s);
    }, 0)) : Ps(t, i, s);
  };
}
function yr(c, e, t, i, s) {
  const r = () => {
    let n;
    const a = (o) => {
      o.done ? t(o.value) : n === void 0 ? n = !0 : r();
    };
    do
      n = void 0, !s || !s.aborted ? e(c, a, i) : i(new Error("Aborted")), n === void 0 && (n = !1);
    while (n);
  };
  r();
}
function Ws(c, e) {
  let t;
  return yr(c, Ps, (i) => t = i, (i) => {
    throw i;
  }, e), t;
}
function Mn(c, e, t) {
  return new Promise((i, s) => {
    yr(c, e, i, s, t);
  });
}
function An(c, e) {
  return (...t) => Ws(c(...t), e);
}
class Rn {
  constructor() {
    this._doNotSerialize = !1, this._isDisposed = !1, this._sceneRootNodesIndex = -1, this._isEnabled = !0, this._isParentEnabled = !0, this._isReady = !0, this._onEnabledStateChangedObservable = new F(), this._onClonedObservable = new F();
  }
}
class Xe {
  constructor(e, t = null) {
    this._isDirty = !1, this._nodeDataStorage = new Rn(), this.state = "", this.metadata = null, this.reservedDataStore = null, this._parentContainer = null, this.animations = new Array(), this._ranges = {}, this.onReady = null, this._currentRenderId = -1, this._parentUpdateId = -1, this._childUpdateId = -1, this._waitingParentId = null, this._waitingParentInstanceIndex = null, this._waitingParsedUniqueId = null, this._cache = {}, this._parentNode = null, this._children = null, this._worldMatrix = x.Identity(), this._worldMatrixDeterminant = 0, this._worldMatrixDeterminantIsDirty = !0, this._animationPropertiesOverride = null, this._isNode = !0, this.onDisposeObservable = new F(), this._onDisposeObserver = null, this._behaviors = new Array(), this.name = e, this.id = e, this._scene = t || _e.LastCreatedScene, this.uniqueId = this._scene.getUniqueId(), this._initCache();
  }
  static AddNodeConstructor(e, t) {
    this._NodeConstructors[e] = t;
  }
  static Construct(e, t, i, s) {
    const r = this._NodeConstructors[e];
    return r ? r(t, i, s) : null;
  }
  get doNotSerialize() {
    return this._nodeDataStorage._doNotSerialize ? !0 : this._parentNode ? this._parentNode.doNotSerialize : !1;
  }
  set doNotSerialize(e) {
    this._nodeDataStorage._doNotSerialize = e;
  }
  isDisposed() {
    return this._nodeDataStorage._isDisposed;
  }
  set parent(e) {
    if (this._parentNode === e)
      return;
    const t = this._parentNode;
    if (this._parentNode && this._parentNode._children !== void 0 && this._parentNode._children !== null) {
      const i = this._parentNode._children.indexOf(this);
      i !== -1 && this._parentNode._children.splice(i, 1), !e && !this._nodeDataStorage._isDisposed && this._addToSceneRootNodes();
    }
    this._parentNode = e, this._parentNode && ((this._parentNode._children === void 0 || this._parentNode._children === null) && (this._parentNode._children = new Array()), this._parentNode._children.push(this), t || this._removeFromSceneRootNodes()), this._syncParentEnabledState();
  }
  get parent() {
    return this._parentNode;
  }
  _serializeAsParent(e) {
    e.parentId = this.uniqueId;
  }
  _addToSceneRootNodes() {
    this._nodeDataStorage._sceneRootNodesIndex === -1 && (this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length, this._scene.rootNodes.push(this));
  }
  _removeFromSceneRootNodes() {
    if (this._nodeDataStorage._sceneRootNodesIndex !== -1) {
      const e = this._scene.rootNodes, t = e.length - 1;
      e[this._nodeDataStorage._sceneRootNodesIndex] = e[t], e[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex, this._scene.rootNodes.pop(), this._nodeDataStorage._sceneRootNodesIndex = -1;
    }
  }
  get animationPropertiesOverride() {
    return this._animationPropertiesOverride ? this._animationPropertiesOverride : this._scene.animationPropertiesOverride;
  }
  set animationPropertiesOverride(e) {
    this._animationPropertiesOverride = e;
  }
  getClassName() {
    return "Node";
  }
  set onDispose(e) {
    this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);
  }
  get onEnabledStateChangedObservable() {
    return this._nodeDataStorage._onEnabledStateChangedObservable;
  }
  get onClonedObservable() {
    return this._nodeDataStorage._onClonedObservable;
  }
  getScene() {
    return this._scene;
  }
  getEngine() {
    return this._scene.getEngine();
  }
  addBehavior(e, t = !1) {
    return this._behaviors.indexOf(e) !== -1 ? this : (e.init(), this._scene.isLoading && !t ? this._scene.onDataLoadedObservable.addOnce(() => {
      e.attach(this);
    }) : e.attach(this), this._behaviors.push(e), this);
  }
  removeBehavior(e) {
    const t = this._behaviors.indexOf(e);
    return t === -1 ? this : (this._behaviors[t].detach(), this._behaviors.splice(t, 1), this);
  }
  get behaviors() {
    return this._behaviors;
  }
  getBehaviorByName(e) {
    for (const t of this._behaviors)
      if (t.name === e)
        return t;
    return null;
  }
  getWorldMatrix() {
    return this._currentRenderId !== this._scene.getRenderId() && this.computeWorldMatrix(), this._worldMatrix;
  }
  _getWorldMatrixDeterminant() {
    return this._worldMatrixDeterminantIsDirty && (this._worldMatrixDeterminantIsDirty = !1, this._worldMatrixDeterminant = this._worldMatrix.determinant()), this._worldMatrixDeterminant;
  }
  get worldMatrixFromCache() {
    return this._worldMatrix;
  }
  _initCache() {
    this._cache = {}, this._cache.parent = void 0;
  }
  updateCache(e) {
    !e && this.isSynchronized() || (this._cache.parent = this.parent, this._updateCache());
  }
  _getActionManagerForTrigger(e, t = !0) {
    return this.parent ? this.parent._getActionManagerForTrigger(e, !1) : null;
  }
  _updateCache(e) {
  }
  _isSynchronized() {
    return !0;
  }
  _markSyncedWithParent() {
    this._parentNode && (this._parentUpdateId = this._parentNode._childUpdateId);
  }
  isSynchronizedWithParent() {
    return this._parentNode ? this._parentNode._isDirty || this._parentUpdateId !== this._parentNode._childUpdateId ? !1 : this._parentNode.isSynchronized() : !0;
  }
  isSynchronized() {
    return this._cache.parent !== this._parentNode ? (this._cache.parent = this._parentNode, !1) : this._parentNode && !this.isSynchronizedWithParent() ? !1 : this._isSynchronized();
  }
  isReady(e = !1) {
    return this._nodeDataStorage._isReady;
  }
  markAsDirty(e) {
    return this._currentRenderId = Number.MAX_VALUE, this._isDirty = !0, this;
  }
  isEnabled(e = !0) {
    return e === !1 ? this._nodeDataStorage._isEnabled : this._nodeDataStorage._isEnabled ? this._nodeDataStorage._isParentEnabled : !1;
  }
  _syncParentEnabledState() {
    this._nodeDataStorage._isParentEnabled = this._parentNode ? this._parentNode.isEnabled() : !0, this._children && this._children.forEach((e) => {
      e._syncParentEnabledState();
    });
  }
  setEnabled(e) {
    this._nodeDataStorage._isEnabled !== e && (this._nodeDataStorage._isEnabled = e, this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(e), this._syncParentEnabledState());
  }
  isDescendantOf(e) {
    return this.parent ? this.parent === e ? !0 : this.parent.isDescendantOf(e) : !1;
  }
  _getDescendants(e, t = !1, i) {
    if (!!this._children)
      for (let s = 0; s < this._children.length; s++) {
        const r = this._children[s];
        (!i || i(r)) && e.push(r), t || r._getDescendants(e, !1, i);
      }
  }
  getDescendants(e, t) {
    const i = new Array();
    return this._getDescendants(i, e, t), i;
  }
  getChildMeshes(e, t) {
    const i = [];
    return this._getDescendants(i, e, (s) => (!t || t(s)) && s.cullingStrategy !== void 0), i;
  }
  getChildren(e, t = !0) {
    return this.getDescendants(t, e);
  }
  _setReady(e) {
    if (e !== this._nodeDataStorage._isReady) {
      if (!e) {
        this._nodeDataStorage._isReady = !1;
        return;
      }
      this.onReady && this.onReady(this), this._nodeDataStorage._isReady = !0;
    }
  }
  getAnimationByName(e) {
    for (let t = 0; t < this.animations.length; t++) {
      const i = this.animations[t];
      if (i.name === e)
        return i;
    }
    return null;
  }
  createAnimationRange(e, t, i) {
    if (!this._ranges[e]) {
      this._ranges[e] = Xe._AnimationRangeFactory(e, t, i);
      for (let s = 0, r = this.animations.length; s < r; s++)
        this.animations[s] && this.animations[s].createRange(e, t, i);
    }
  }
  deleteAnimationRange(e, t = !0) {
    for (let i = 0, s = this.animations.length; i < s; i++)
      this.animations[i] && this.animations[i].deleteRange(e, t);
    this._ranges[e] = null;
  }
  getAnimationRange(e) {
    return this._ranges[e] || null;
  }
  getAnimationRanges() {
    const e = [];
    let t;
    for (t in this._ranges)
      e.push(this._ranges[t]);
    return e;
  }
  beginAnimation(e, t, i, s) {
    const r = this.getAnimationRange(e);
    return r ? this._scene.beginAnimation(this, r.from, r.to, t, i, s) : null;
  }
  serializeAnimationRanges() {
    const e = [];
    for (const t in this._ranges) {
      const i = this._ranges[t];
      if (!i)
        continue;
      const s = {};
      s.name = t, s.from = i.from, s.to = i.to, e.push(s);
    }
    return e;
  }
  computeWorldMatrix(e) {
    return this._worldMatrix || (this._worldMatrix = x.Identity()), this._worldMatrix;
  }
  dispose(e, t = !1) {
    if (this._nodeDataStorage._isDisposed = !0, !e) {
      const i = this.getDescendants(!0);
      for (const s of i)
        s.dispose(e, t);
    }
    this.parent ? this.parent = null : this._removeFromSceneRootNodes(), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onEnabledStateChangedObservable.clear(), this.onClonedObservable.clear();
    for (const i of this._behaviors)
      i.detach();
    this._behaviors.length = 0, this.metadata = null;
  }
  static ParseAnimationRanges(e, t, i) {
    if (t.ranges)
      for (let s = 0; s < t.ranges.length; s++) {
        const r = t.ranges[s];
        e.createAnimationRange(r.name, r.from, r.to);
      }
  }
  getHierarchyBoundingVectors(e = !0, t = null) {
    this.getScene().incrementRenderId(), this.computeWorldMatrix(!0);
    let i, s;
    const r = this;
    if (r.getBoundingInfo && r.subMeshes) {
      const n = r.getBoundingInfo();
      i = n.boundingBox.minimumWorld.clone(), s = n.boundingBox.maximumWorld.clone();
    } else
      i = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), s = new g(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    if (e) {
      const n = this.getDescendants(!1);
      for (const a of n) {
        const o = a;
        if (o.computeWorldMatrix(!0), t && !t(o) || !o.getBoundingInfo || o.getTotalVertices() === 0)
          continue;
        const l = o.getBoundingInfo().boundingBox, u = l.minimumWorld, f = l.maximumWorld;
        g.CheckExtends(u, i, s), g.CheckExtends(f, i, s);
      }
    }
    return {
      min: i,
      max: s
    };
  }
}
Xe._AnimationRangeFactory = (c, e, t) => {
  throw q("AnimationRange");
};
Xe._NodeConstructors = {};
S([
  M()
], Xe.prototype, "name", void 0);
S([
  M()
], Xe.prototype, "id", void 0);
S([
  M()
], Xe.prototype, "uniqueId", void 0);
S([
  M()
], Xe.prototype, "state", void 0);
S([
  M()
], Xe.prototype, "metadata", void 0);
class Z {
  constructor() {
    this._applyTo = An(this._applyToCoroutine.bind(this));
  }
  set(e, t) {
    switch (e.length || w.Warn(`Setting vertex data kind '${t}' with an empty array`), t) {
      case p.PositionKind:
        this.positions = e;
        break;
      case p.NormalKind:
        this.normals = e;
        break;
      case p.TangentKind:
        this.tangents = e;
        break;
      case p.UVKind:
        this.uvs = e;
        break;
      case p.UV2Kind:
        this.uvs2 = e;
        break;
      case p.UV3Kind:
        this.uvs3 = e;
        break;
      case p.UV4Kind:
        this.uvs4 = e;
        break;
      case p.UV5Kind:
        this.uvs5 = e;
        break;
      case p.UV6Kind:
        this.uvs6 = e;
        break;
      case p.ColorKind:
        this.colors = e;
        break;
      case p.MatricesIndicesKind:
        this.matricesIndices = e;
        break;
      case p.MatricesWeightsKind:
        this.matricesWeights = e;
        break;
      case p.MatricesIndicesExtraKind:
        this.matricesIndicesExtra = e;
        break;
      case p.MatricesWeightsExtraKind:
        this.matricesWeightsExtra = e;
        break;
    }
  }
  applyToMesh(e, t) {
    return this._applyTo(e, t, !1), this;
  }
  applyToGeometry(e, t) {
    return this._applyTo(e, t, !1), this;
  }
  updateMesh(e) {
    return this._update(e), this;
  }
  updateGeometry(e) {
    return this._update(e), this;
  }
  *_applyToCoroutine(e, t = !1, i) {
    return this.positions && (e.setVerticesData(p.PositionKind, this.positions, t), i && (yield)), this.normals && (e.setVerticesData(p.NormalKind, this.normals, t), i && (yield)), this.tangents && (e.setVerticesData(p.TangentKind, this.tangents, t), i && (yield)), this.uvs && (e.setVerticesData(p.UVKind, this.uvs, t), i && (yield)), this.uvs2 && (e.setVerticesData(p.UV2Kind, this.uvs2, t), i && (yield)), this.uvs3 && (e.setVerticesData(p.UV3Kind, this.uvs3, t), i && (yield)), this.uvs4 && (e.setVerticesData(p.UV4Kind, this.uvs4, t), i && (yield)), this.uvs5 && (e.setVerticesData(p.UV5Kind, this.uvs5, t), i && (yield)), this.uvs6 && (e.setVerticesData(p.UV6Kind, this.uvs6, t), i && (yield)), this.colors && (e.setVerticesData(p.ColorKind, this.colors, t), i && (yield)), this.matricesIndices && (e.setVerticesData(p.MatricesIndicesKind, this.matricesIndices, t), i && (yield)), this.matricesWeights && (e.setVerticesData(p.MatricesWeightsKind, this.matricesWeights, t), i && (yield)), this.matricesIndicesExtra && (e.setVerticesData(p.MatricesIndicesExtraKind, this.matricesIndicesExtra, t), i && (yield)), this.matricesWeightsExtra && (e.setVerticesData(p.MatricesWeightsExtraKind, this.matricesWeightsExtra, t), i && (yield)), this.indices ? (e.setIndices(this.indices, null, t), i && (yield)) : e.setIndices([], null), this;
  }
  _update(e, t, i) {
    return this.positions && e.updateVerticesData(p.PositionKind, this.positions, t, i), this.normals && e.updateVerticesData(p.NormalKind, this.normals, t, i), this.tangents && e.updateVerticesData(p.TangentKind, this.tangents, t, i), this.uvs && e.updateVerticesData(p.UVKind, this.uvs, t, i), this.uvs2 && e.updateVerticesData(p.UV2Kind, this.uvs2, t, i), this.uvs3 && e.updateVerticesData(p.UV3Kind, this.uvs3, t, i), this.uvs4 && e.updateVerticesData(p.UV4Kind, this.uvs4, t, i), this.uvs5 && e.updateVerticesData(p.UV5Kind, this.uvs5, t, i), this.uvs6 && e.updateVerticesData(p.UV6Kind, this.uvs6, t, i), this.colors && e.updateVerticesData(p.ColorKind, this.colors, t, i), this.matricesIndices && e.updateVerticesData(p.MatricesIndicesKind, this.matricesIndices, t, i), this.matricesWeights && e.updateVerticesData(p.MatricesWeightsKind, this.matricesWeights, t, i), this.matricesIndicesExtra && e.updateVerticesData(p.MatricesIndicesExtraKind, this.matricesIndicesExtra, t, i), this.matricesWeightsExtra && e.updateVerticesData(p.MatricesWeightsExtraKind, this.matricesWeightsExtra, t, i), this.indices && e.setIndices(this.indices, null), this;
  }
  static _TransformVector3Coordinates(e, t, i = 0, s = e.length) {
    const r = D.Vector3[0], n = D.Vector3[1];
    for (let a = i; a < i + s; a += 3)
      g.FromArrayToRef(e, a, r), g.TransformCoordinatesToRef(r, t, n), e[a] = n.x, e[a + 1] = n.y, e[a + 2] = n.z;
  }
  static _TransformVector3Normals(e, t, i = 0, s = e.length) {
    const r = D.Vector3[0], n = D.Vector3[1];
    for (let a = i; a < i + s; a += 3)
      g.FromArrayToRef(e, a, r), g.TransformNormalToRef(r, t, n), e[a] = n.x, e[a + 1] = n.y, e[a + 2] = n.z;
  }
  static _TransformVector4Normals(e, t, i = 0, s = e.length) {
    const r = D.Vector4[0], n = D.Vector4[1];
    for (let a = i; a < i + s; a += 4)
      Ee.FromArrayToRef(e, a, r), Ee.TransformNormalToRef(r, t, n), e[a] = n.x, e[a + 1] = n.y, e[a + 2] = n.z, e[a + 3] = n.w;
  }
  static _FlipFaces(e, t = 0, i = e.length) {
    for (let s = t; s < t + i; s += 3) {
      const r = e[s + 1];
      e[s + 1] = e[s + 2], e[s + 2] = r;
    }
  }
  transform(e) {
    const t = e.determinant() < 0;
    return this.positions && Z._TransformVector3Coordinates(this.positions, e), this.normals && Z._TransformVector3Normals(this.normals, e), this.tangents && Z._TransformVector4Normals(this.tangents, e), t && this.indices && Z._FlipFaces(this.indices), this;
  }
  merge(e, t = !1, i = !1) {
    const s = Array.isArray(e) ? e.map((r) => [r, void 0]) : [[e, void 0]];
    return Ws(this._mergeCoroutine(void 0, s, t, !1, i));
  }
  *_mergeCoroutine(e, t, i = !1, s, r) {
    var l, u, f, d;
    this._validate();
    const n = t.map((_) => _[0]);
    for (const _ of n)
      if (_._validate(), !this.normals != !_.normals || !this.tangents != !_.tangents || !this.uvs != !_.uvs || !this.uvs2 != !_.uvs2 || !this.uvs3 != !_.uvs3 || !this.uvs4 != !_.uvs4 || !this.uvs5 != !_.uvs5 || !this.uvs6 != !_.uvs6 || !this.colors != !_.colors || !this.matricesIndices != !_.matricesIndices || !this.matricesWeights != !_.matricesWeights || !this.matricesIndicesExtra != !_.matricesIndicesExtra || !this.matricesWeightsExtra != !_.matricesWeightsExtra)
        throw new Error("Cannot merge vertex data that do not have the same set of attributes");
    const a = n.reduce((_, E) => {
      var m, T;
      return _ + ((T = (m = E.indices) == null ? void 0 : m.length) != null ? T : 0);
    }, (u = (l = this.indices) == null ? void 0 : l.length) != null ? u : 0);
    let h = r || n.some((_) => _.indices === this.indices) ? (f = this.indices) == null ? void 0 : f.slice() : this.indices;
    if (a > 0) {
      let _ = (d = h == null ? void 0 : h.length) != null ? d : 0;
      if (h || (h = new Array(a)), h.length !== a) {
        if (Array.isArray(h))
          h.length = a;
        else {
          const m = i || h instanceof Uint32Array ? new Uint32Array(a) : new Uint16Array(a);
          m.set(h), h = m;
        }
        e && e.determinant() < 0 && Z._FlipFaces(h, 0, _);
      }
      let E = this.positions ? this.positions.length / 3 : 0;
      for (const [m, T] of t)
        if (m.indices) {
          for (let b = 0; b < m.indices.length; b++)
            h[_ + b] = m.indices[b] + E;
          T && T.determinant() < 0 && Z._FlipFaces(h, _, m.indices.length), E += m.positions.length / 3, _ += m.indices.length, s && (yield);
        }
    }
    return this.indices = h, this.positions = Z._MergeElement(p.PositionKind, this.positions, e, t.map((_) => [_[0].positions, _[1]])), s && (yield), this.normals = Z._MergeElement(p.NormalKind, this.normals, e, t.map((_) => [_[0].normals, _[1]])), s && (yield), this.tangents = Z._MergeElement(p.TangentKind, this.tangents, e, t.map((_) => [_[0].tangents, _[1]])), s && (yield), this.uvs = Z._MergeElement(p.UVKind, this.uvs, e, t.map((_) => [_[0].uvs, _[1]])), s && (yield), this.uvs2 = Z._MergeElement(p.UV2Kind, this.uvs2, e, t.map((_) => [_[0].uvs2, _[1]])), s && (yield), this.uvs3 = Z._MergeElement(p.UV3Kind, this.uvs3, e, t.map((_) => [_[0].uvs3, _[1]])), s && (yield), this.uvs4 = Z._MergeElement(p.UV4Kind, this.uvs4, e, t.map((_) => [_[0].uvs4, _[1]])), s && (yield), this.uvs5 = Z._MergeElement(p.UV5Kind, this.uvs5, e, t.map((_) => [_[0].uvs5, _[1]])), s && (yield), this.uvs6 = Z._MergeElement(p.UV6Kind, this.uvs6, e, t.map((_) => [_[0].uvs6, _[1]])), s && (yield), this.colors = Z._MergeElement(p.ColorKind, this.colors, e, t.map((_) => [_[0].colors, _[1]])), s && (yield), this.matricesIndices = Z._MergeElement(p.MatricesIndicesKind, this.matricesIndices, e, t.map((_) => [_[0].matricesIndices, _[1]])), s && (yield), this.matricesWeights = Z._MergeElement(p.MatricesWeightsKind, this.matricesWeights, e, t.map((_) => [_[0].matricesWeights, _[1]])), s && (yield), this.matricesIndicesExtra = Z._MergeElement(p.MatricesIndicesExtraKind, this.matricesIndicesExtra, e, t.map((_) => [_[0].matricesIndicesExtra, _[1]])), s && (yield), this.matricesWeightsExtra = Z._MergeElement(p.MatricesWeightsExtraKind, this.matricesWeightsExtra, e, t.map((_) => [_[0].matricesWeightsExtra, _[1]])), this;
  }
  static _MergeElement(e, t, i, s) {
    const r = s.filter((o) => o[0] !== null && o[0] !== void 0);
    if (!t && r.length == 0)
      return t;
    if (!t)
      return this._MergeElement(e, r[0][0], r[0][1], r.slice(1));
    const n = r.reduce((o, h) => o + h[0].length, t.length), a = e === p.PositionKind ? Z._TransformVector3Coordinates : e === p.NormalKind ? Z._TransformVector3Normals : e === p.TangentKind ? Z._TransformVector4Normals : () => {
    };
    if (t instanceof Float32Array) {
      const o = new Float32Array(n);
      o.set(t), i && a(o, i, 0, t.length);
      let h = t.length;
      for (const [l, u] of r)
        o.set(l, h), u && a(o, u, h, l.length), h += l.length;
      return o;
    } else {
      const o = new Array(n);
      for (let l = 0; l < t.length; l++)
        o[l] = t[l];
      i && a(o, i, 0, t.length);
      let h = t.length;
      for (const [l, u] of r) {
        for (let f = 0; f < l.length; f++)
          o[h + f] = l[f];
        u && a(o, u, h, l.length), h += l.length;
      }
      return o;
    }
  }
  _validate() {
    if (!this.positions)
      throw new Vt("Positions are required", si.MeshInvalidPositionsError);
    const e = (s, r) => {
      const n = p.DeduceStride(s);
      if (r.length % n !== 0)
        throw new Error("The " + s + "s array count must be a multiple of " + n);
      return r.length / n;
    }, t = e(p.PositionKind, this.positions), i = (s, r) => {
      const n = e(s, r);
      if (n !== t)
        throw new Error("The " + s + "s element count (" + n + ") does not match the positions count (" + t + ")");
    };
    this.normals && i(p.NormalKind, this.normals), this.tangents && i(p.TangentKind, this.tangents), this.uvs && i(p.UVKind, this.uvs), this.uvs2 && i(p.UV2Kind, this.uvs2), this.uvs3 && i(p.UV3Kind, this.uvs3), this.uvs4 && i(p.UV4Kind, this.uvs4), this.uvs5 && i(p.UV5Kind, this.uvs5), this.uvs6 && i(p.UV6Kind, this.uvs6), this.colors && i(p.ColorKind, this.colors), this.matricesIndices && i(p.MatricesIndicesKind, this.matricesIndices), this.matricesWeights && i(p.MatricesWeightsKind, this.matricesWeights), this.matricesIndicesExtra && i(p.MatricesIndicesExtraKind, this.matricesIndicesExtra), this.matricesWeightsExtra && i(p.MatricesWeightsExtraKind, this.matricesWeightsExtra);
  }
  serialize() {
    const e = {};
    return this.positions && (e.positions = this.positions), this.normals && (e.normals = this.normals), this.tangents && (e.tangents = this.tangents), this.uvs && (e.uvs = this.uvs), this.uvs2 && (e.uvs2 = this.uvs2), this.uvs3 && (e.uvs3 = this.uvs3), this.uvs4 && (e.uvs4 = this.uvs4), this.uvs5 && (e.uvs5 = this.uvs5), this.uvs6 && (e.uvs6 = this.uvs6), this.colors && (e.colors = this.colors), this.matricesIndices && (e.matricesIndices = this.matricesIndices, e.matricesIndices._isExpanded = !0), this.matricesWeights && (e.matricesWeights = this.matricesWeights), this.matricesIndicesExtra && (e.matricesIndicesExtra = this.matricesIndicesExtra, e.matricesIndicesExtra._isExpanded = !0), this.matricesWeightsExtra && (e.matricesWeightsExtra = this.matricesWeightsExtra), e.indices = this.indices, e;
  }
  static ExtractFromMesh(e, t, i) {
    return Z._ExtractFrom(e, t, i);
  }
  static ExtractFromGeometry(e, t, i) {
    return Z._ExtractFrom(e, t, i);
  }
  static _ExtractFrom(e, t, i) {
    const s = new Z();
    return e.isVerticesDataPresent(p.PositionKind) && (s.positions = e.getVerticesData(p.PositionKind, t, i)), e.isVerticesDataPresent(p.NormalKind) && (s.normals = e.getVerticesData(p.NormalKind, t, i)), e.isVerticesDataPresent(p.TangentKind) && (s.tangents = e.getVerticesData(p.TangentKind, t, i)), e.isVerticesDataPresent(p.UVKind) && (s.uvs = e.getVerticesData(p.UVKind, t, i)), e.isVerticesDataPresent(p.UV2Kind) && (s.uvs2 = e.getVerticesData(p.UV2Kind, t, i)), e.isVerticesDataPresent(p.UV3Kind) && (s.uvs3 = e.getVerticesData(p.UV3Kind, t, i)), e.isVerticesDataPresent(p.UV4Kind) && (s.uvs4 = e.getVerticesData(p.UV4Kind, t, i)), e.isVerticesDataPresent(p.UV5Kind) && (s.uvs5 = e.getVerticesData(p.UV5Kind, t, i)), e.isVerticesDataPresent(p.UV6Kind) && (s.uvs6 = e.getVerticesData(p.UV6Kind, t, i)), e.isVerticesDataPresent(p.ColorKind) && (s.colors = e.getVerticesData(p.ColorKind, t, i)), e.isVerticesDataPresent(p.MatricesIndicesKind) && (s.matricesIndices = e.getVerticesData(p.MatricesIndicesKind, t, i)), e.isVerticesDataPresent(p.MatricesWeightsKind) && (s.matricesWeights = e.getVerticesData(p.MatricesWeightsKind, t, i)), e.isVerticesDataPresent(p.MatricesIndicesExtraKind) && (s.matricesIndicesExtra = e.getVerticesData(p.MatricesIndicesExtraKind, t, i)), e.isVerticesDataPresent(p.MatricesWeightsExtraKind) && (s.matricesWeightsExtra = e.getVerticesData(p.MatricesWeightsExtraKind, t, i)), s.indices = e.getIndices(t, i), s;
  }
  static CreateRibbon(e) {
    throw q("ribbonBuilder");
  }
  static CreateBox(e) {
    throw q("boxBuilder");
  }
  static CreateTiledBox(e) {
    throw q("tiledBoxBuilder");
  }
  static CreateTiledPlane(e) {
    throw q("tiledPlaneBuilder");
  }
  static CreateSphere(e) {
    throw q("sphereBuilder");
  }
  static CreateCylinder(e) {
    throw q("cylinderBuilder");
  }
  static CreateTorus(e) {
    throw q("torusBuilder");
  }
  static CreateLineSystem(e) {
    throw q("linesBuilder");
  }
  static CreateDashedLines(e) {
    throw q("linesBuilder");
  }
  static CreateGround(e) {
    throw q("groundBuilder");
  }
  static CreateTiledGround(e) {
    throw q("groundBuilder");
  }
  static CreateGroundFromHeightMap(e) {
    throw q("groundBuilder");
  }
  static CreatePlane(e) {
    throw q("planeBuilder");
  }
  static CreateDisc(e) {
    throw q("discBuilder");
  }
  static CreatePolygon(e, t, i, s, r, n, a) {
    throw q("polygonBuilder");
  }
  static CreateIcoSphere(e) {
    throw q("icoSphereBuilder");
  }
  static CreatePolyhedron(e) {
    throw q("polyhedronBuilder");
  }
  static CreateCapsule(e = {
    orientation: g.Up(),
    subdivisions: 2,
    tessellation: 16,
    height: 1,
    radius: 0.25,
    capSubdivisions: 6
  }) {
    throw q("capsuleBuilder");
  }
  static CreateTorusKnot(e) {
    throw q("torusKnotBuilder");
  }
  static ComputeNormals(e, t, i, s) {
    let r = 0, n = 0, a = 0, o = 0, h = 0, l = 0, u = 0, f = 0, d = 0, _ = 0, E = 0, m = 0, T = 0, b = 0, R = 0, y = 0, P = 0, v = 0, A = 0, L = 0, Q = !1, ae = !1, be = !1, fe = !1, ue = 1, ie = 0, ye = null;
    s && (Q = !!s.facetNormals, ae = !!s.facetPositions, be = !!s.facetPartitioning, ue = s.useRightHandedSystem === !0 ? -1 : 1, ie = s.ratio || 0, fe = !!s.depthSort, ye = s.distanceTo, fe && ye === void 0 && (ye = g.Zero()));
    let Ce = 0, He = 0, ke = 0, Ve = 0;
    for (be && s && s.bbSize && (Ce = s.subDiv.X * ie / s.bbSize.x, He = s.subDiv.Y * ie / s.bbSize.y, ke = s.subDiv.Z * ie / s.bbSize.z, Ve = s.subDiv.max * s.subDiv.max, s.facetPartitioning.length = 0), r = 0; r < e.length; r++)
      i[r] = 0;
    const ot = t.length / 3 | 0;
    for (r = 0; r < ot; r++) {
      if (m = t[r * 3] * 3, T = m + 1, b = m + 2, R = t[r * 3 + 1] * 3, y = R + 1, P = R + 2, v = t[r * 3 + 2] * 3, A = v + 1, L = v + 2, n = e[m] - e[R], a = e[T] - e[y], o = e[b] - e[P], h = e[v] - e[R], l = e[A] - e[y], u = e[L] - e[P], f = ue * (a * u - o * l), d = ue * (o * h - n * u), _ = ue * (n * l - a * h), E = Math.sqrt(f * f + d * d + _ * _), E = E === 0 ? 1 : E, f /= E, d /= E, _ /= E, Q && s && (s.facetNormals[r].x = f, s.facetNormals[r].y = d, s.facetNormals[r].z = _), ae && s && (s.facetPositions[r].x = (e[m] + e[R] + e[v]) / 3, s.facetPositions[r].y = (e[T] + e[y] + e[A]) / 3, s.facetPositions[r].z = (e[b] + e[P] + e[L]) / 3), be && s) {
        const st = Math.floor((s.facetPositions[r].x - s.bInfo.minimum.x * ie) * Ce), Mt = Math.floor((s.facetPositions[r].y - s.bInfo.minimum.y * ie) * He), Xt = Math.floor((s.facetPositions[r].z - s.bInfo.minimum.z * ie) * ke), Bi = Math.floor((e[m] - s.bInfo.minimum.x * ie) * Ce), Ui = Math.floor((e[T] - s.bInfo.minimum.y * ie) * He), ki = Math.floor((e[b] - s.bInfo.minimum.z * ie) * ke), cs = Math.floor((e[R] - s.bInfo.minimum.x * ie) * Ce), us = Math.floor((e[y] - s.bInfo.minimum.y * ie) * He), fs = Math.floor((e[P] - s.bInfo.minimum.z * ie) * ke), ds = Math.floor((e[v] - s.bInfo.minimum.x * ie) * Ce), _s = Math.floor((e[A] - s.bInfo.minimum.y * ie) * He), gs = Math.floor((e[L] - s.bInfo.minimum.z * ie) * ke), Pt = Bi + s.subDiv.max * Ui + Ve * ki, Dt = cs + s.subDiv.max * us + Ve * fs, Ft = ds + s.subDiv.max * _s + Ve * gs, wt = st + s.subDiv.max * Mt + Ve * Xt;
        s.facetPartitioning[wt] = s.facetPartitioning[wt] ? s.facetPartitioning[wt] : new Array(), s.facetPartitioning[Pt] = s.facetPartitioning[Pt] ? s.facetPartitioning[Pt] : new Array(), s.facetPartitioning[Dt] = s.facetPartitioning[Dt] ? s.facetPartitioning[Dt] : new Array(), s.facetPartitioning[Ft] = s.facetPartitioning[Ft] ? s.facetPartitioning[Ft] : new Array(), s.facetPartitioning[Pt].push(r), Dt != Pt && s.facetPartitioning[Dt].push(r), Ft == Dt || Ft == Pt || s.facetPartitioning[Ft].push(r), wt == Pt || wt == Dt || wt == Ft || s.facetPartitioning[wt].push(r);
      }
      if (fe && s && s.facetPositions) {
        const st = s.depthSortedFacets[r];
        st.ind = r * 3, st.sqDistance = g.DistanceSquared(s.facetPositions[r], ye);
      }
      i[m] += f, i[T] += d, i[b] += _, i[R] += f, i[y] += d, i[P] += _, i[v] += f, i[A] += d, i[L] += _;
    }
    for (r = 0; r < i.length / 3; r++)
      f = i[r * 3], d = i[r * 3 + 1], _ = i[r * 3 + 2], E = Math.sqrt(f * f + d * d + _ * _), E = E === 0 ? 1 : E, f /= E, d /= E, _ /= E, i[r * 3] = f, i[r * 3 + 1] = d, i[r * 3 + 2] = _;
  }
  static _ComputeSides(e, t, i, s, r, n, a) {
    const o = i.length, h = s.length;
    let l, u;
    switch (e = e || Z.DEFAULTSIDE, e) {
      case Z.FRONTSIDE:
        break;
      case Z.BACKSIDE:
        for (l = 0; l < o; l += 3) {
          const f = i[l];
          i[l] = i[l + 2], i[l + 2] = f;
        }
        for (u = 0; u < h; u++)
          s[u] = -s[u];
        break;
      case Z.DOUBLESIDE: {
        const f = t.length, d = f / 3;
        for (let m = 0; m < f; m++)
          t[f + m] = t[m];
        for (l = 0; l < o; l += 3)
          i[l + o] = i[l + 2] + d, i[l + 1 + o] = i[l + 1] + d, i[l + 2 + o] = i[l] + d;
        for (u = 0; u < h; u++)
          s[h + u] = -s[u];
        const _ = r.length;
        let E = 0;
        for (E = 0; E < _; E++)
          r[E + _] = r[E];
        for (n = n || new Ee(0, 0, 1, 1), a = a || new Ee(0, 0, 1, 1), E = 0, l = 0; l < _ / 2; l++)
          r[E] = n.x + (n.z - n.x) * r[E], r[E + 1] = n.y + (n.w - n.y) * r[E + 1], r[E + _] = a.x + (a.z - a.x) * r[E + _], r[E + _ + 1] = a.y + (a.w - a.y) * r[E + _ + 1], E += 2;
        break;
      }
    }
  }
  static ImportVertexData(e, t) {
    const i = new Z(), s = e.positions;
    s && i.set(s, p.PositionKind);
    const r = e.normals;
    r && i.set(r, p.NormalKind);
    const n = e.tangents;
    n && i.set(n, p.TangentKind);
    const a = e.uvs;
    a && i.set(a, p.UVKind);
    const o = e.uv2s;
    o && i.set(o, p.UV2Kind);
    const h = e.uv3s;
    h && i.set(h, p.UV3Kind);
    const l = e.uv4s;
    l && i.set(l, p.UV4Kind);
    const u = e.uv5s;
    u && i.set(u, p.UV5Kind);
    const f = e.uv6s;
    f && i.set(f, p.UV6Kind);
    const d = e.colors;
    d && i.set(ge.CheckColors4(d, s.length / 3), p.ColorKind);
    const _ = e.matricesIndices;
    _ && i.set(_, p.MatricesIndicesKind);
    const E = e.matricesWeights;
    E && i.set(E, p.MatricesWeightsKind);
    const m = e.indices;
    m && (i.indices = m), t.setAllVerticesData(i, e.updatable);
  }
}
Z.FRONTSIDE = 0;
Z.BACKSIDE = 1;
Z.DOUBLESIDE = 2;
Z.DEFAULTSIDE = 0;
S([
  jt.filter((...[c]) => !Array.isArray(c))
], Z, "_TransformVector3Coordinates", null);
S([
  jt.filter((...[c]) => !Array.isArray(c))
], Z, "_TransformVector3Normals", null);
S([
  jt.filter((...[c]) => !Array.isArray(c))
], Z, "_TransformVector4Normals", null);
S([
  jt.filter((...[c]) => !Array.isArray(c))
], Z, "_FlipFaces", null);
class Ds {
  constructor(e, t, i) {
    this.bu = e, this.bv = t, this.distance = i, this.faceId = 0, this.subMeshId = 0;
  }
}
class Bt {
  constructor(e, t, i) {
    this.vectors = Me.BuildArray(8, g.Zero), this.center = g.Zero(), this.centerWorld = g.Zero(), this.extendSize = g.Zero(), this.extendSizeWorld = g.Zero(), this.directions = Me.BuildArray(3, g.Zero), this.vectorsWorld = Me.BuildArray(8, g.Zero), this.minimumWorld = g.Zero(), this.maximumWorld = g.Zero(), this.minimum = g.Zero(), this.maximum = g.Zero(), this._drawWrapperFront = null, this._drawWrapperBack = null, this.reConstruct(e, t, i);
  }
  reConstruct(e, t, i) {
    const s = e.x, r = e.y, n = e.z, a = t.x, o = t.y, h = t.z, l = this.vectors;
    this.minimum.copyFromFloats(s, r, n), this.maximum.copyFromFloats(a, o, h), l[0].copyFromFloats(s, r, n), l[1].copyFromFloats(a, o, h), l[2].copyFromFloats(a, r, n), l[3].copyFromFloats(s, o, n), l[4].copyFromFloats(s, r, h), l[5].copyFromFloats(a, o, n), l[6].copyFromFloats(s, o, h), l[7].copyFromFloats(a, r, h), t.addToRef(e, this.center).scaleInPlace(0.5), t.subtractToRef(e, this.extendSize).scaleInPlace(0.5), this._worldMatrix = i || x.IdentityReadOnly, this._update(this._worldMatrix);
  }
  scale(e) {
    const t = Bt._TmpVector3, i = this.maximum.subtractToRef(this.minimum, t[0]), s = i.length();
    i.normalizeFromLength(s);
    const r = s * e, n = i.scaleInPlace(r * 0.5), a = this.center.subtractToRef(n, t[1]), o = this.center.addToRef(n, t[2]);
    return this.reConstruct(a, o, this._worldMatrix), this;
  }
  getWorldMatrix() {
    return this._worldMatrix;
  }
  _update(e) {
    const t = this.minimumWorld, i = this.maximumWorld, s = this.directions, r = this.vectorsWorld, n = this.vectors;
    if (e.isIdentity()) {
      t.copyFrom(this.minimum), i.copyFrom(this.maximum);
      for (let a = 0; a < 8; ++a)
        r[a].copyFrom(n[a]);
      this.extendSizeWorld.copyFrom(this.extendSize), this.centerWorld.copyFrom(this.center);
    } else {
      t.setAll(Number.MAX_VALUE), i.setAll(-Number.MAX_VALUE);
      for (let a = 0; a < 8; ++a) {
        const o = r[a];
        g.TransformCoordinatesToRef(n[a], e, o), t.minimizeInPlace(o), i.maximizeInPlace(o);
      }
      i.subtractToRef(t, this.extendSizeWorld).scaleInPlace(0.5), i.addToRef(t, this.centerWorld).scaleInPlace(0.5);
    }
    g.FromArrayToRef(e.m, 0, s[0]), g.FromArrayToRef(e.m, 4, s[1]), g.FromArrayToRef(e.m, 8, s[2]), this._worldMatrix = e;
  }
  isInFrustum(e) {
    return Bt.IsInFrustum(this.vectorsWorld, e);
  }
  isCompletelyInFrustum(e) {
    return Bt.IsCompletelyInFrustum(this.vectorsWorld, e);
  }
  intersectsPoint(e) {
    const t = this.minimumWorld, i = this.maximumWorld, s = t.x, r = t.y, n = t.z, a = i.x, o = i.y, h = i.z, l = e.x, u = e.y, f = e.z, d = -Re;
    return !(a - l < d || d > l - s || o - u < d || d > u - r || h - f < d || d > f - n);
  }
  intersectsSphere(e) {
    return Bt.IntersectsSphere(this.minimumWorld, this.maximumWorld, e.centerWorld, e.radiusWorld);
  }
  intersectsMinMax(e, t) {
    const i = this.minimumWorld, s = this.maximumWorld, r = i.x, n = i.y, a = i.z, o = s.x, h = s.y, l = s.z, u = e.x, f = e.y, d = e.z, _ = t.x, E = t.y, m = t.z;
    return !(o < u || r > _ || h < f || n > E || l < d || a > m);
  }
  dispose() {
    var e, t;
    (e = this._drawWrapperFront) == null || e.dispose(), (t = this._drawWrapperBack) == null || t.dispose();
  }
  static Intersects(e, t) {
    return e.intersectsMinMax(t.minimumWorld, t.maximumWorld);
  }
  static IntersectsSphere(e, t, i, s) {
    const r = Bt._TmpVector3[0];
    return g.ClampToRef(i, e, t, r), g.DistanceSquared(i, r) <= s * s;
  }
  static IsCompletelyInFrustum(e, t) {
    for (let i = 0; i < 6; ++i) {
      const s = t[i];
      for (let r = 0; r < 8; ++r)
        if (s.dotCoordinate(e[r]) < 0)
          return !1;
    }
    return !0;
  }
  static IsInFrustum(e, t) {
    for (let i = 0; i < 6; ++i) {
      let s = !0;
      const r = t[i];
      for (let n = 0; n < 8; ++n)
        if (r.dotCoordinate(e[n]) >= 0) {
          s = !1;
          break;
        }
      if (s)
        return !1;
    }
    return !0;
  }
}
Bt._TmpVector3 = Me.BuildArray(3, g.Zero);
class ni {
  constructor(e, t, i) {
    this.center = g.Zero(), this.centerWorld = g.Zero(), this.minimum = g.Zero(), this.maximum = g.Zero(), this.reConstruct(e, t, i);
  }
  reConstruct(e, t, i) {
    this.minimum.copyFrom(e), this.maximum.copyFrom(t);
    const s = g.Distance(e, t);
    t.addToRef(e, this.center).scaleInPlace(0.5), this.radius = s * 0.5, this._update(i || x.IdentityReadOnly);
  }
  scale(e) {
    const t = this.radius * e, i = ni._TmpVector3, s = i[0].setAll(t), r = this.center.subtractToRef(s, i[1]), n = this.center.addToRef(s, i[2]);
    return this.reConstruct(r, n, this._worldMatrix), this;
  }
  getWorldMatrix() {
    return this._worldMatrix;
  }
  _update(e) {
    if (e.isIdentity())
      this.centerWorld.copyFrom(this.center), this.radiusWorld = this.radius;
    else {
      g.TransformCoordinatesToRef(this.center, e, this.centerWorld);
      const t = ni._TmpVector3[0];
      g.TransformNormalFromFloatsToRef(1, 1, 1, e, t), this.radiusWorld = Math.max(Math.abs(t.x), Math.abs(t.y), Math.abs(t.z)) * this.radius;
    }
  }
  isInFrustum(e) {
    const t = this.centerWorld, i = this.radiusWorld;
    for (let s = 0; s < 6; s++)
      if (e[s].dotCoordinate(t) <= -i)
        return !1;
    return !0;
  }
  isCenterInFrustum(e) {
    const t = this.centerWorld;
    for (let i = 0; i < 6; i++)
      if (e[i].dotCoordinate(t) < 0)
        return !1;
    return !0;
  }
  intersectsPoint(e) {
    const t = g.DistanceSquared(this.centerWorld, e);
    return !(this.radiusWorld * this.radiusWorld < t);
  }
  static Intersects(e, t) {
    const i = g.DistanceSquared(e.centerWorld, t.centerWorld), s = e.radiusWorld + t.radiusWorld;
    return !(s * s < i);
  }
  static CreateFromCenterAndRadius(e, t, i) {
    this._TmpVector3[0].copyFrom(e), this._TmpVector3[1].copyFromFloats(0, 0, t), this._TmpVector3[2].copyFrom(e), this._TmpVector3[0].addInPlace(this._TmpVector3[1]), this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);
    const s = new ni(this._TmpVector3[0], this._TmpVector3[2]);
    return i ? s._worldMatrix = i : s._worldMatrix = x.Identity(), s;
  }
}
ni._TmpVector3 = Me.BuildArray(3, g.Zero);
const Ts = { min: 0, max: 0 }, Ss = { min: 0, max: 0 }, nr = (c, e, t) => {
  const i = g.Dot(e.centerWorld, c), s = Math.abs(g.Dot(e.directions[0], c)) * e.extendSize.x, r = Math.abs(g.Dot(e.directions[1], c)) * e.extendSize.y, n = Math.abs(g.Dot(e.directions[2], c)) * e.extendSize.z, a = s + r + n;
  t.min = i - a, t.max = i + a;
}, et = (c, e, t) => (nr(c, e, Ts), nr(c, t, Ss), !(Ts.min > Ss.max || Ss.min > Ts.max));
class ft {
  constructor(e, t, i) {
    this._isLocked = !1, this.boundingBox = new Bt(e, t, i), this.boundingSphere = new ni(e, t, i);
  }
  reConstruct(e, t, i) {
    this.boundingBox.reConstruct(e, t, i), this.boundingSphere.reConstruct(e, t, i);
  }
  get minimum() {
    return this.boundingBox.minimum;
  }
  get maximum() {
    return this.boundingBox.maximum;
  }
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(e) {
    this._isLocked = e;
  }
  update(e) {
    this._isLocked || (this.boundingBox._update(e), this.boundingSphere._update(e));
  }
  centerOn(e, t) {
    const i = ft._TmpVector3[0].copyFrom(e).subtractInPlace(t), s = ft._TmpVector3[1].copyFrom(e).addInPlace(t);
    return this.boundingBox.reConstruct(i, s, this.boundingBox.getWorldMatrix()), this.boundingSphere.reConstruct(i, s, this.boundingBox.getWorldMatrix()), this;
  }
  encapsulate(e) {
    const t = g.Minimize(this.minimum, e), i = g.Maximize(this.maximum, e);
    return this.reConstruct(t, i, this.boundingBox.getWorldMatrix()), this;
  }
  encapsulateBoundingInfo(e) {
    return this.encapsulate(e.boundingBox.centerWorld.subtract(e.boundingBox.extendSizeWorld)), this.encapsulate(e.boundingBox.centerWorld.add(e.boundingBox.extendSizeWorld)), this;
  }
  scale(e) {
    return this.boundingBox.scale(e), this.boundingSphere.scale(e), this;
  }
  isInFrustum(e, t = 0) {
    return (t === 2 || t === 3) && this.boundingSphere.isCenterInFrustum(e) ? !0 : this.boundingSphere.isInFrustum(e) ? t === 1 || t === 3 ? !0 : this.boundingBox.isInFrustum(e) : !1;
  }
  get diagonalLength() {
    const e = this.boundingBox;
    return e.maximumWorld.subtractToRef(e.minimumWorld, ft._TmpVector3[0]).length();
  }
  isCompletelyInFrustum(e) {
    return this.boundingBox.isCompletelyInFrustum(e);
  }
  _checkCollision(e) {
    return e._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);
  }
  intersectsPoint(e) {
    return !(!this.boundingSphere.centerWorld || !this.boundingSphere.intersectsPoint(e) || !this.boundingBox.intersectsPoint(e));
  }
  intersects(e, t) {
    if (!ni.Intersects(this.boundingSphere, e.boundingSphere) || !Bt.Intersects(this.boundingBox, e.boundingBox))
      return !1;
    if (!t)
      return !0;
    const i = this.boundingBox, s = e.boundingBox;
    return !(!et(i.directions[0], i, s) || !et(i.directions[1], i, s) || !et(i.directions[2], i, s) || !et(s.directions[0], i, s) || !et(s.directions[1], i, s) || !et(s.directions[2], i, s) || !et(g.Cross(i.directions[0], s.directions[0]), i, s) || !et(g.Cross(i.directions[0], s.directions[1]), i, s) || !et(g.Cross(i.directions[0], s.directions[2]), i, s) || !et(g.Cross(i.directions[1], s.directions[0]), i, s) || !et(g.Cross(i.directions[1], s.directions[1]), i, s) || !et(g.Cross(i.directions[1], s.directions[2]), i, s) || !et(g.Cross(i.directions[2], s.directions[0]), i, s) || !et(g.Cross(i.directions[2], s.directions[1]), i, s) || !et(g.Cross(i.directions[2], s.directions[2]), i, s));
  }
}
ft._TmpVector3 = Me.BuildArray(2, g.Zero);
class as {
  static extractMinAndMaxIndexed(e, t, i, s, r, n) {
    for (let a = i; a < i + s; a++) {
      const o = t[a] * 3, h = e[o], l = e[o + 1], u = e[o + 2];
      r.minimizeInPlaceFromFloats(h, l, u), n.maximizeInPlaceFromFloats(h, l, u);
    }
  }
  static extractMinAndMax(e, t, i, s, r, n) {
    for (let a = t, o = t * s; a < t + i; a++, o += s) {
      const h = e[o], l = e[o + 1], u = e[o + 2];
      r.minimizeInPlaceFromFloats(h, l, u), n.maximizeInPlaceFromFloats(h, l, u);
    }
  }
}
S([
  jt.filter((...[c, e]) => !Array.isArray(c) && !Array.isArray(e))
], as, "extractMinAndMaxIndexed", null);
S([
  jt.filter((...[c]) => !Array.isArray(c))
], as, "extractMinAndMax", null);
function yn(c, e, t, i, s = null) {
  const r = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n = new g(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  return as.extractMinAndMaxIndexed(c, e, t, i, r, n), s && (r.x -= r.x * s.x + s.y, r.y -= r.y * s.x + s.y, r.z -= r.z * s.x + s.y, n.x += n.x * s.x + s.y, n.y += n.y * s.x + s.y, n.z += n.z * s.x + s.y), {
    minimum: r,
    maximum: n
  };
}
function Cr(c, e, t, i = null, s) {
  const r = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n = new g(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  return s || (s = 3), as.extractMinAndMax(c, e, t, s, r, n), i && (r.x -= r.x * i.x + i.y, r.y -= r.y * i.x + i.y, r.z -= r.z * i.x + i.y, n.x += n.x * i.x + i.y, n.y += n.y * i.x + i.y, n.z += n.z * i.x + i.y), {
    minimum: r,
    maximum: n
  };
}
class mt {
  constructor(e, t, i, s, r, n, a, o = !0, h = !0) {
    this.materialIndex = e, this.verticesStart = t, this.verticesCount = i, this.indexStart = s, this.indexCount = r, this._mainDrawWrapperOverride = null, this._linesIndexCount = 0, this._linesIndexBuffer = null, this._lastColliderWorldVertices = null, this._lastColliderTransformMatrix = null, this._renderId = 0, this._alphaIndex = 0, this._distanceToCamera = 0, this._currentMaterial = null, this._mesh = n, this._renderingMesh = a || n, h && n.subMeshes.push(this), this._engine = this._mesh.getScene().getEngine(), this.resetDrawCache(), this._trianglePlanes = [], this._id = n.subMeshes.length - 1, o && (this.refreshBoundingInfo(), n.computeWorldMatrix(!0));
  }
  get materialDefines() {
    var e;
    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (e = this._getDrawWrapper()) == null ? void 0 : e.defines;
  }
  set materialDefines(e) {
    var i;
    const t = (i = this._mainDrawWrapperOverride) != null ? i : this._getDrawWrapper(void 0, !0);
    t.defines = e;
  }
  _getDrawWrapper(e, t = !1) {
    e = e != null ? e : this._engine.currentRenderPassId;
    let i = this._drawWrappers[e];
    return !i && t && (this._drawWrappers[e] = i = new Oi(this._mesh.getScene().getEngine())), i;
  }
  _removeDrawWrapper(e, t = !0) {
    var i;
    t && ((i = this._drawWrappers[e]) == null || i.dispose()), this._drawWrappers[e] = void 0;
  }
  get effect() {
    var e, t;
    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (t = (e = this._getDrawWrapper()) == null ? void 0 : e.effect) != null ? t : null;
  }
  get _drawWrapper() {
    var e;
    return (e = this._mainDrawWrapperOverride) != null ? e : this._getDrawWrapper(void 0, !0);
  }
  get _drawWrapperOverride() {
    return this._mainDrawWrapperOverride;
  }
  _setMainDrawWrapperOverride(e) {
    this._mainDrawWrapperOverride = e;
  }
  setEffect(e, t = null, i, s = !0) {
    const r = this._drawWrapper;
    r.setEffect(e, t, s), i !== void 0 && (r.materialContext = i), e || (r.defines = null, r.materialContext = void 0);
  }
  resetDrawCache(e) {
    if (this._drawWrappers)
      if (e !== void 0) {
        this._removeDrawWrapper(e);
        return;
      } else
        for (const t of this._drawWrappers)
          t == null || t.dispose();
    this._drawWrappers = [];
  }
  static AddToMesh(e, t, i, s, r, n, a, o = !0) {
    return new mt(e, t, i, s, r, n, a, o);
  }
  get IsGlobal() {
    return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();
  }
  getBoundingInfo() {
    return this.IsGlobal ? this._mesh.getBoundingInfo() : this._boundingInfo;
  }
  setBoundingInfo(e) {
    return this._boundingInfo = e, this;
  }
  getMesh() {
    return this._mesh;
  }
  getRenderingMesh() {
    return this._renderingMesh;
  }
  getReplacementMesh() {
    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
  }
  getEffectiveMesh() {
    const e = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
    return e || this._renderingMesh;
  }
  getMaterial(e = !0) {
    var i;
    const t = (i = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) != null ? i : this._renderingMesh.material;
    if (t) {
      if (this._isMultiMaterial(t)) {
        const s = t.getSubMaterial(this.materialIndex);
        return this._currentMaterial !== s && (this._currentMaterial = s, this.resetDrawCache()), s;
      }
    } else
      return e ? this._mesh.getScene().defaultMaterial : null;
    return t;
  }
  _isMultiMaterial(e) {
    return e.getSubMaterial !== void 0;
  }
  refreshBoundingInfo(e = null) {
    if (this._lastColliderWorldVertices = null, this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry)
      return this;
    if (e || (e = this._renderingMesh.getVerticesData(p.PositionKind)), !e)
      return this._boundingInfo = this._mesh.getBoundingInfo(), this;
    const t = this._renderingMesh.getIndices();
    let i;
    if (this.indexStart === 0 && this.indexCount === t.length) {
      const s = this._renderingMesh.getBoundingInfo();
      i = { minimum: s.minimum.clone(), maximum: s.maximum.clone() };
    } else
      i = yn(e, t, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);
    return this._boundingInfo ? this._boundingInfo.reConstruct(i.minimum, i.maximum) : this._boundingInfo = new ft(i.minimum, i.maximum), this;
  }
  _checkCollision(e) {
    return this.getBoundingInfo()._checkCollision(e);
  }
  updateBoundingInfo(e) {
    let t = this.getBoundingInfo();
    return t || (this.refreshBoundingInfo(), t = this.getBoundingInfo()), t && t.update(e), this;
  }
  isInFrustum(e) {
    const t = this.getBoundingInfo();
    return t ? t.isInFrustum(e, this._mesh.cullingStrategy) : !1;
  }
  isCompletelyInFrustum(e) {
    const t = this.getBoundingInfo();
    return t ? t.isCompletelyInFrustum(e) : !1;
  }
  render(e) {
    return this._renderingMesh.render(this, e, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : void 0), this;
  }
  _getLinesIndexBuffer(e, t) {
    if (!this._linesIndexBuffer) {
      const i = [];
      for (let s = this.indexStart; s < this.indexStart + this.indexCount; s += 3)
        i.push(e[s], e[s + 1], e[s + 1], e[s + 2], e[s + 2], e[s]);
      this._linesIndexBuffer = t.createIndexBuffer(i), this._linesIndexCount = i.length;
    }
    return this._linesIndexBuffer;
  }
  canIntersects(e) {
    const t = this.getBoundingInfo();
    return t ? e.intersectsBox(t.boundingBox) : !1;
  }
  intersects(e, t, i, s, r) {
    const n = this.getMaterial();
    if (!n)
      return null;
    let a = 3, o = !1;
    switch (n.fillMode) {
      case 3:
      case 5:
      case 6:
      case 8:
        return null;
      case 7:
        a = 1, o = !0;
        break;
    }
    return n.fillMode === 4 ? i.length ? this._intersectLines(e, t, i, this._mesh.intersectionThreshold, s) : this._intersectUnIndexedLines(e, t, i, this._mesh.intersectionThreshold, s) : !i.length && this._mesh._unIndexed ? this._intersectUnIndexedTriangles(e, t, i, s, r) : this._intersectTriangles(e, t, i, a, o, s, r);
  }
  _intersectLines(e, t, i, s, r) {
    let n = null;
    for (let a = this.indexStart; a < this.indexStart + this.indexCount; a += 2) {
      const o = t[i[a]], h = t[i[a + 1]], l = e.intersectionSegment(o, h, s);
      if (!(l < 0) && (r || !n || l < n.distance) && (n = new Ds(null, null, l), n.faceId = a / 2, r))
        break;
    }
    return n;
  }
  _intersectUnIndexedLines(e, t, i, s, r) {
    let n = null;
    for (let a = this.verticesStart; a < this.verticesStart + this.verticesCount; a += 2) {
      const o = t[a], h = t[a + 1], l = e.intersectionSegment(o, h, s);
      if (!(l < 0) && (r || !n || l < n.distance) && (n = new Ds(null, null, l), n.faceId = a / 2, r))
        break;
    }
    return n;
  }
  _intersectTriangles(e, t, i, s, r, n, a) {
    let o = null, h = -1;
    for (let l = this.indexStart; l < this.indexStart + this.indexCount - (3 - s); l += s) {
      h++;
      const u = i[l], f = i[l + 1], d = i[l + 2];
      if (r && d === 4294967295) {
        l += 2;
        continue;
      }
      const _ = t[u], E = t[f], m = t[d];
      if (!_ || !E || !m || a && !a(_, E, m, e))
        continue;
      const T = e.intersectsTriangle(_, E, m);
      if (T) {
        if (T.distance < 0)
          continue;
        if ((n || !o || T.distance < o.distance) && (o = T, o.faceId = h, n))
          break;
      }
    }
    return o;
  }
  _intersectUnIndexedTriangles(e, t, i, s, r) {
    let n = null;
    for (let a = this.verticesStart; a < this.verticesStart + this.verticesCount; a += 3) {
      const o = t[a], h = t[a + 1], l = t[a + 2];
      if (r && !r(o, h, l, e))
        continue;
      const u = e.intersectsTriangle(o, h, l);
      if (u) {
        if (u.distance < 0)
          continue;
        if ((s || !n || u.distance < n.distance) && (n = u, n.faceId = a / 3, s))
          break;
      }
    }
    return n;
  }
  _rebuild() {
    this._linesIndexBuffer && (this._linesIndexBuffer = null);
  }
  clone(e, t) {
    const i = new mt(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, e, t, !1);
    if (!this.IsGlobal) {
      const s = this.getBoundingInfo();
      if (!s)
        return i;
      i._boundingInfo = new ft(s.minimum, s.maximum);
    }
    return i;
  }
  dispose() {
    this._linesIndexBuffer && (this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer), this._linesIndexBuffer = null);
    const e = this._mesh.subMeshes.indexOf(this);
    this._mesh.subMeshes.splice(e, 1), this.resetDrawCache();
  }
  getClassName() {
    return "SubMesh";
  }
  static CreateFromIndices(e, t, i, s, r, n = !0) {
    let a = Number.MAX_VALUE, o = -Number.MAX_VALUE;
    const l = (r || s).getIndices();
    for (let u = t; u < t + i; u++) {
      const f = l[u];
      f < a && (a = f), f > o && (o = f);
    }
    return new mt(e, a, o - a + 1, t, i, s, r, n);
  }
}
class we {
  static get ForceFullSceneLoadingForIncremental() {
    return we._ForceFullSceneLoadingForIncremental;
  }
  static set ForceFullSceneLoadingForIncremental(e) {
    we._ForceFullSceneLoadingForIncremental = e;
  }
  static get ShowLoadingScreen() {
    return we._ShowLoadingScreen;
  }
  static set ShowLoadingScreen(e) {
    we._ShowLoadingScreen = e;
  }
  static get loggingLevel() {
    return we._LoggingLevel;
  }
  static set loggingLevel(e) {
    we._LoggingLevel = e;
  }
  static get CleanBoneMatrixWeights() {
    return we._CleanBoneMatrixWeights;
  }
  static set CleanBoneMatrixWeights(e) {
    we._CleanBoneMatrixWeights = e;
  }
}
we._ForceFullSceneLoadingForIncremental = !1;
we._ShowLoadingScreen = !0;
we._CleanBoneMatrixWeights = !1;
we._LoggingLevel = 0;
class ct {
}
ct.UseOpenGLOrientationForUV = !1;
class nt {
  constructor(e, t, i, s = !1, r = null) {
    this.delayLoadState = 0, this._totalVertices = 0, this._isDisposed = !1, this._indexBufferIsUpdatable = !1, this._positionsCache = [], this._parentContainer = null, this.useBoundingInfoFromGeometry = !1, this._scene = t || _e.LastCreatedScene, this._scene && (this.id = e, this.uniqueId = this._scene.getUniqueId(), this._engine = this._scene.getEngine(), this._meshes = [], this._vertexBuffers = {}, this._indices = [], this._updatable = s, i ? this.setAllVerticesData(i, s) : this._totalVertices = 0, this._engine.getCaps().vertexArrayObject && (this._vertexArrayObjects = {}), r && (this.applyToMesh(r), r.computeWorldMatrix(!0)));
  }
  get boundingBias() {
    return this._boundingBias;
  }
  set boundingBias(e) {
    this._boundingBias ? this._boundingBias.copyFrom(e) : this._boundingBias = e.clone(), this._updateBoundingInfo(!0, null);
  }
  static CreateGeometryForMesh(e) {
    const t = new nt(nt.RandomId(), e.getScene());
    return t.applyToMesh(e), t;
  }
  get meshes() {
    return this._meshes;
  }
  get extend() {
    return this._extend;
  }
  getScene() {
    return this._scene;
  }
  getEngine() {
    return this._engine;
  }
  isReady() {
    return this.delayLoadState === 1 || this.delayLoadState === 0;
  }
  get doNotSerialize() {
    for (let e = 0; e < this._meshes.length; e++)
      if (!this._meshes[e].doNotSerialize)
        return !1;
    return !0;
  }
  _rebuild() {
    this._vertexArrayObjects && (this._vertexArrayObjects = {}), this._meshes.length !== 0 && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable));
    for (const e in this._vertexBuffers)
      this._vertexBuffers[e]._rebuild();
  }
  setAllVerticesData(e, t) {
    e.applyToGeometry(this, t), this._notifyUpdate();
  }
  setVerticesData(e, t, i = !1, s) {
    i && Array.isArray(t) && (t = new Float32Array(t));
    const r = new p(this._engine, t, e, i, this._meshes.length === 0, s);
    this.setVerticesBuffer(r);
  }
  removeVerticesData(e) {
    this._vertexBuffers[e] && (this._vertexBuffers[e].dispose(), delete this._vertexBuffers[e]), this._vertexArrayObjects && this._disposeVertexArrayObjects();
  }
  setVerticesBuffer(e, t = null, i = !0) {
    const s = e.getKind();
    this._vertexBuffers[s] && i && this._vertexBuffers[s].dispose(), e._buffer && e._buffer._increaseReferences(), this._vertexBuffers[s] = e;
    const r = this._meshes, n = r.length;
    if (s === p.PositionKind) {
      const a = e.getData();
      t != null ? this._totalVertices = t : a != null && (this._totalVertices = a.length / (e.type === p.BYTE ? e.byteStride : e.byteStride / 4)), this._updateExtend(a), this._resetPointsArrayCache();
      for (let o = 0; o < n; o++) {
        const h = r[o];
        h.buildBoundingInfo(this._extend.minimum, this._extend.maximum), h._createGlobalSubMesh(h.isUnIndexed), h.computeWorldMatrix(!0), h.synchronizeInstances();
      }
    }
    this._notifyUpdate(s);
  }
  updateVerticesDataDirectly(e, t, i, s = !1) {
    const r = this.getVertexBuffer(e);
    !r || (r.updateDirectly(t, i, s), this._notifyUpdate(e));
  }
  updateVerticesData(e, t, i = !1) {
    const s = this.getVertexBuffer(e);
    !s || (s.update(t), e === p.PositionKind && this._updateBoundingInfo(i, t), this._notifyUpdate(e));
  }
  _updateBoundingInfo(e, t) {
    if (e && this._updateExtend(t), this._resetPointsArrayCache(), e) {
      const i = this._meshes;
      for (const s of i) {
        s.hasBoundingInfo ? s.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum) : s.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
        const r = s.subMeshes;
        for (const n of r)
          n.refreshBoundingInfo();
      }
    }
  }
  _bind(e, t, i, s) {
    if (!e)
      return;
    t === void 0 && (t = this._indexBuffer);
    const r = this.getVertexBuffers();
    if (!r)
      return;
    if (t != this._indexBuffer || !this._vertexArrayObjects && !s) {
      this._engine.bindBuffers(r, t, e, i);
      return;
    }
    const n = s || this._vertexArrayObjects;
    n[e.key] || (n[e.key] = this._engine.recordVertexArrayObject(r, t, e, i)), this._engine.bindVertexArrayObject(n[e.key], t);
  }
  getTotalVertices() {
    return this.isReady() ? this._totalVertices : 0;
  }
  getVerticesData(e, t, i) {
    const s = this.getVertexBuffer(e);
    return s ? s.getFloatData(this._totalVertices, i || t && this._meshes.length !== 1) : null;
  }
  isVertexBufferUpdatable(e) {
    const t = this._vertexBuffers[e];
    return t ? t.isUpdatable() : !1;
  }
  getVertexBuffer(e) {
    return this.isReady() ? this._vertexBuffers[e] : null;
  }
  getVertexBuffers() {
    return this.isReady() ? this._vertexBuffers : null;
  }
  isVerticesDataPresent(e) {
    return this._vertexBuffers ? this._vertexBuffers[e] !== void 0 : this._delayInfo ? this._delayInfo.indexOf(e) !== -1 : !1;
  }
  getVerticesDataKinds() {
    const e = [];
    let t;
    if (!this._vertexBuffers && this._delayInfo)
      for (t in this._delayInfo)
        e.push(t);
    else
      for (t in this._vertexBuffers)
        e.push(t);
    return e;
  }
  updateIndices(e, t, i = !1) {
    if (!!this._indexBuffer)
      if (!this._indexBufferIsUpdatable)
        this.setIndices(e, null, !0);
      else {
        const s = e.length !== this._indices.length;
        if (i || (this._indices = e.slice()), this._engine.updateDynamicIndexBuffer(this._indexBuffer, e, t), s)
          for (const r of this._meshes)
            r._createGlobalSubMesh(!0);
      }
  }
  setIndices(e, t = null, i = !1) {
    this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indices = e, this._indexBufferIsUpdatable = i, this._meshes.length !== 0 && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, i)), t != null && (this._totalVertices = t);
    for (const s of this._meshes)
      s._createGlobalSubMesh(!0), s.synchronizeInstances();
    this._notifyUpdate();
  }
  getTotalIndices() {
    return this.isReady() ? this._indices.length : 0;
  }
  getIndices(e, t) {
    if (!this.isReady())
      return null;
    const i = this._indices;
    return !t && (!e || this._meshes.length === 1) ? i : i.slice();
  }
  getIndexBuffer() {
    return this.isReady() ? this._indexBuffer : null;
  }
  _releaseVertexArrayObject(e = null) {
    !e || !this._vertexArrayObjects || this._vertexArrayObjects[e.key] && (this._engine.releaseVertexArrayObject(this._vertexArrayObjects[e.key]), delete this._vertexArrayObjects[e.key]);
  }
  releaseForMesh(e, t) {
    const i = this._meshes, s = i.indexOf(e);
    s !== -1 && (i.splice(s, 1), this._vertexArrayObjects && e._invalidateInstanceVertexArrayObject(), e._geometry = null, i.length === 0 && t && this.dispose());
  }
  applyToMesh(e) {
    if (e._geometry === this)
      return;
    const t = e._geometry;
    t && t.releaseForMesh(e), this._vertexArrayObjects && e._invalidateInstanceVertexArrayObject();
    const i = this._meshes;
    e._geometry = this, e._internalAbstractMeshDataInfo._positions = null, this._scene.pushGeometry(this), i.push(e), this.isReady() ? this._applyToMesh(e) : this._boundingInfo && e.setBoundingInfo(this._boundingInfo);
  }
  _updateExtend(e = null) {
    if (this.useBoundingInfoFromGeometry && this._boundingInfo)
      this._extend = {
        minimum: this._boundingInfo.minimum.clone(),
        maximum: this._boundingInfo.maximum.clone()
      };
    else {
      if (!e && (e = this.getVerticesData(p.PositionKind), !e))
        return;
      this._extend = Cr(e, 0, this._totalVertices, this.boundingBias, 3);
    }
  }
  _applyToMesh(e) {
    const t = this._meshes.length;
    for (const i in this._vertexBuffers)
      t === 1 && this._vertexBuffers[i].create(), i === p.PositionKind && (this._extend || this._updateExtend(), e.buildBoundingInfo(this._extend.minimum, this._extend.maximum), e._createGlobalSubMesh(e.isUnIndexed), e._updateBoundingInfo());
    t === 1 && this._indices && this._indices.length > 0 && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable)), e._syncGeometryWithMorphTargetManager(), e.synchronizeInstances();
  }
  _notifyUpdate(e) {
    this.onGeometryUpdated && this.onGeometryUpdated(this, e), this._vertexArrayObjects && this._disposeVertexArrayObjects();
    for (const t of this._meshes)
      t._markSubMeshesAsAttributesDirty();
  }
  load(e, t) {
    if (this.delayLoadState !== 2) {
      if (this.isReady()) {
        t && t();
        return;
      }
      this.delayLoadState = 2, this._queueLoad(e, t);
    }
  }
  _queueLoad(e, t) {
    !this.delayLoadingFile || (e.addPendingData(this), e._loadFile(this.delayLoadingFile, (i) => {
      if (!this._delayLoadingFunction)
        return;
      this._delayLoadingFunction(JSON.parse(i), this), this.delayLoadState = 1, this._delayInfo = [], e.removePendingData(this);
      const s = this._meshes, r = s.length;
      for (let n = 0; n < r; n++)
        this._applyToMesh(s[n]);
      t && t();
    }, void 0, !0));
  }
  toLeftHanded() {
    const e = this.getIndices(!1);
    if (e != null && e.length > 0) {
      for (let s = 0; s < e.length; s += 3) {
        const r = e[s + 0];
        e[s + 0] = e[s + 2], e[s + 2] = r;
      }
      this.setIndices(e);
    }
    const t = this.getVerticesData(p.PositionKind, !1);
    if (t != null && t.length > 0) {
      for (let s = 0; s < t.length; s += 3)
        t[s + 2] = -t[s + 2];
      this.setVerticesData(p.PositionKind, t, !1);
    }
    const i = this.getVerticesData(p.NormalKind, !1);
    if (i != null && i.length > 0) {
      for (let s = 0; s < i.length; s += 3)
        i[s + 2] = -i[s + 2];
      this.setVerticesData(p.NormalKind, i, !1);
    }
  }
  _resetPointsArrayCache() {
    this._positions = null;
  }
  _generatePointsArray() {
    if (this._positions)
      return !0;
    const e = this.getVerticesData(p.PositionKind);
    if (!e || e.length === 0)
      return !1;
    for (let t = this._positionsCache.length * 3, i = this._positionsCache.length; t < e.length; t += 3, ++i)
      this._positionsCache[i] = g.FromArray(e, t);
    for (let t = 0, i = 0; t < e.length; t += 3, ++i)
      this._positionsCache[i].set(e[0 + t], e[1 + t], e[2 + t]);
    return this._positionsCache.length = e.length / 3, this._positions = this._positionsCache, !0;
  }
  isDisposed() {
    return this._isDisposed;
  }
  _disposeVertexArrayObjects() {
    if (this._vertexArrayObjects) {
      for (const i in this._vertexArrayObjects)
        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[i]);
      this._vertexArrayObjects = {};
      const e = this._meshes, t = e.length;
      for (let i = 0; i < t; i++)
        e[i]._invalidateInstanceVertexArrayObject();
    }
  }
  dispose() {
    const e = this._meshes, t = e.length;
    let i;
    for (i = 0; i < t; i++)
      this.releaseForMesh(e[i]);
    this._meshes.length = 0, this._disposeVertexArrayObjects();
    for (const s in this._vertexBuffers)
      this._vertexBuffers[s].dispose();
    if (this._vertexBuffers = {}, this._totalVertices = 0, this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indexBuffer = null, this._indices = [], this.delayLoadState = 0, this.delayLoadingFile = null, this._delayLoadingFunction = null, this._delayInfo = [], this._boundingInfo = null, this._scene.removeGeometry(this), this._parentContainer) {
      const s = this._parentContainer.geometries.indexOf(this);
      s > -1 && this._parentContainer.geometries.splice(s, 1), this._parentContainer = null;
    }
    this._isDisposed = !0;
  }
  copy(e) {
    const t = new Z();
    t.indices = [];
    const i = this.getIndices();
    if (i)
      for (let o = 0; o < i.length; o++)
        t.indices.push(i[o]);
    let s = !1, r = !1, n;
    for (n in this._vertexBuffers) {
      const o = this.getVerticesData(n);
      if (o && (o instanceof Float32Array ? t.set(new Float32Array(o), n) : t.set(o.slice(0), n), !r)) {
        const h = this.getVertexBuffer(n);
        h && (s = h.isUpdatable(), r = !s);
      }
    }
    const a = new nt(e, this._scene, t, s);
    a.delayLoadState = this.delayLoadState, a.delayLoadingFile = this.delayLoadingFile, a._delayLoadingFunction = this._delayLoadingFunction;
    for (n in this._delayInfo)
      a._delayInfo = a._delayInfo || [], a._delayInfo.push(n);
    return a._boundingInfo = new ft(this._extend.minimum, this._extend.maximum), a;
  }
  serialize() {
    const e = {};
    return e.id = this.id, e.uniqueId = this.uniqueId, e.updatable = this._updatable, pe && pe.HasTags(this) && (e.tags = pe.GetTags(this)), e;
  }
  _toNumberArray(e) {
    return Array.isArray(e) ? e : Array.prototype.slice.call(e);
  }
  clearCachedData() {
    this._indices = [], this._resetPointsArrayCache();
    for (const e in this._vertexBuffers)
      !Object.prototype.hasOwnProperty.call(this._vertexBuffers, e) || (this._vertexBuffers[e]._buffer._data = null);
  }
  serializeVerticeData() {
    const e = this.serialize();
    return this.isVerticesDataPresent(p.PositionKind) && (e.positions = this._toNumberArray(this.getVerticesData(p.PositionKind)), this.isVertexBufferUpdatable(p.PositionKind) && (e.positions._updatable = !0)), this.isVerticesDataPresent(p.NormalKind) && (e.normals = this._toNumberArray(this.getVerticesData(p.NormalKind)), this.isVertexBufferUpdatable(p.NormalKind) && (e.normals._updatable = !0)), this.isVerticesDataPresent(p.TangentKind) && (e.tangents = this._toNumberArray(this.getVerticesData(p.TangentKind)), this.isVertexBufferUpdatable(p.TangentKind) && (e.tangents._updatable = !0)), this.isVerticesDataPresent(p.UVKind) && (e.uvs = this._toNumberArray(this.getVerticesData(p.UVKind)), this.isVertexBufferUpdatable(p.UVKind) && (e.uvs._updatable = !0)), this.isVerticesDataPresent(p.UV2Kind) && (e.uv2s = this._toNumberArray(this.getVerticesData(p.UV2Kind)), this.isVertexBufferUpdatable(p.UV2Kind) && (e.uv2s._updatable = !0)), this.isVerticesDataPresent(p.UV3Kind) && (e.uv3s = this._toNumberArray(this.getVerticesData(p.UV3Kind)), this.isVertexBufferUpdatable(p.UV3Kind) && (e.uv3s._updatable = !0)), this.isVerticesDataPresent(p.UV4Kind) && (e.uv4s = this._toNumberArray(this.getVerticesData(p.UV4Kind)), this.isVertexBufferUpdatable(p.UV4Kind) && (e.uv4s._updatable = !0)), this.isVerticesDataPresent(p.UV5Kind) && (e.uv5s = this._toNumberArray(this.getVerticesData(p.UV5Kind)), this.isVertexBufferUpdatable(p.UV5Kind) && (e.uv5s._updatable = !0)), this.isVerticesDataPresent(p.UV6Kind) && (e.uv6s = this._toNumberArray(this.getVerticesData(p.UV6Kind)), this.isVertexBufferUpdatable(p.UV6Kind) && (e.uv6s._updatable = !0)), this.isVerticesDataPresent(p.ColorKind) && (e.colors = this._toNumberArray(this.getVerticesData(p.ColorKind)), this.isVertexBufferUpdatable(p.ColorKind) && (e.colors._updatable = !0)), this.isVerticesDataPresent(p.MatricesIndicesKind) && (e.matricesIndices = this._toNumberArray(this.getVerticesData(p.MatricesIndicesKind)), e.matricesIndices._isExpanded = !0, this.isVertexBufferUpdatable(p.MatricesIndicesKind) && (e.matricesIndices._updatable = !0)), this.isVerticesDataPresent(p.MatricesWeightsKind) && (e.matricesWeights = this._toNumberArray(this.getVerticesData(p.MatricesWeightsKind)), this.isVertexBufferUpdatable(p.MatricesWeightsKind) && (e.matricesWeights._updatable = !0)), e.indices = this._toNumberArray(this.getIndices()), e;
  }
  static ExtractFromMesh(e, t) {
    const i = e._geometry;
    return i ? i.copy(t) : null;
  }
  static RandomId() {
    return U.RandomId();
  }
  static _GetGeometryByLoadedUniqueId(e, t) {
    for (let i = 0; i < t.geometries.length; i++)
      if (t.geometries[i]._loadedUniqueId === e)
        return t.geometries[i];
    return null;
  }
  static _ImportGeometry(e, t) {
    const i = t.getScene(), s = e.geometryUniqueId, r = e.geometryId;
    if (s || r) {
      const n = s ? this._GetGeometryByLoadedUniqueId(s, i) : i.getGeometryById(r);
      n && n.applyToMesh(t);
    } else if (e instanceof ArrayBuffer) {
      const n = t._binaryInfo;
      if (n.positionsAttrDesc && n.positionsAttrDesc.count > 0) {
        const a = new Float32Array(e, n.positionsAttrDesc.offset, n.positionsAttrDesc.count);
        t.setVerticesData(p.PositionKind, a, !1);
      }
      if (n.normalsAttrDesc && n.normalsAttrDesc.count > 0) {
        const a = new Float32Array(e, n.normalsAttrDesc.offset, n.normalsAttrDesc.count);
        t.setVerticesData(p.NormalKind, a, !1);
      }
      if (n.tangetsAttrDesc && n.tangetsAttrDesc.count > 0) {
        const a = new Float32Array(e, n.tangetsAttrDesc.offset, n.tangetsAttrDesc.count);
        t.setVerticesData(p.TangentKind, a, !1);
      }
      if (n.uvsAttrDesc && n.uvsAttrDesc.count > 0) {
        const a = new Float32Array(e, n.uvsAttrDesc.offset, n.uvsAttrDesc.count);
        if (ct.UseOpenGLOrientationForUV)
          for (let o = 1; o < a.length; o += 2)
            a[o] = 1 - a[o];
        t.setVerticesData(p.UVKind, a, !1);
      }
      if (n.uvs2AttrDesc && n.uvs2AttrDesc.count > 0) {
        const a = new Float32Array(e, n.uvs2AttrDesc.offset, n.uvs2AttrDesc.count);
        if (ct.UseOpenGLOrientationForUV)
          for (let o = 1; o < a.length; o += 2)
            a[o] = 1 - a[o];
        t.setVerticesData(p.UV2Kind, a, !1);
      }
      if (n.uvs3AttrDesc && n.uvs3AttrDesc.count > 0) {
        const a = new Float32Array(e, n.uvs3AttrDesc.offset, n.uvs3AttrDesc.count);
        if (ct.UseOpenGLOrientationForUV)
          for (let o = 1; o < a.length; o += 2)
            a[o] = 1 - a[o];
        t.setVerticesData(p.UV3Kind, a, !1);
      }
      if (n.uvs4AttrDesc && n.uvs4AttrDesc.count > 0) {
        const a = new Float32Array(e, n.uvs4AttrDesc.offset, n.uvs4AttrDesc.count);
        if (ct.UseOpenGLOrientationForUV)
          for (let o = 1; o < a.length; o += 2)
            a[o] = 1 - a[o];
        t.setVerticesData(p.UV4Kind, a, !1);
      }
      if (n.uvs5AttrDesc && n.uvs5AttrDesc.count > 0) {
        const a = new Float32Array(e, n.uvs5AttrDesc.offset, n.uvs5AttrDesc.count);
        if (ct.UseOpenGLOrientationForUV)
          for (let o = 1; o < a.length; o += 2)
            a[o] = 1 - a[o];
        t.setVerticesData(p.UV5Kind, a, !1);
      }
      if (n.uvs6AttrDesc && n.uvs6AttrDesc.count > 0) {
        const a = new Float32Array(e, n.uvs6AttrDesc.offset, n.uvs6AttrDesc.count);
        if (ct.UseOpenGLOrientationForUV)
          for (let o = 1; o < a.length; o += 2)
            a[o] = 1 - a[o];
        t.setVerticesData(p.UV6Kind, a, !1);
      }
      if (n.colorsAttrDesc && n.colorsAttrDesc.count > 0) {
        const a = new Float32Array(e, n.colorsAttrDesc.offset, n.colorsAttrDesc.count);
        t.setVerticesData(p.ColorKind, a, !1, n.colorsAttrDesc.stride);
      }
      if (n.matricesIndicesAttrDesc && n.matricesIndicesAttrDesc.count > 0) {
        const a = new Int32Array(e, n.matricesIndicesAttrDesc.offset, n.matricesIndicesAttrDesc.count), o = [];
        for (let h = 0; h < a.length; h++) {
          const l = a[h];
          o.push(l & 255), o.push((l & 65280) >> 8), o.push((l & 16711680) >> 16), o.push(l >> 24 & 255);
        }
        t.setVerticesData(p.MatricesIndicesKind, o, !1);
      }
      if (n.matricesIndicesExtraAttrDesc && n.matricesIndicesExtraAttrDesc.count > 0) {
        const a = new Int32Array(e, n.matricesIndicesExtraAttrDesc.offset, n.matricesIndicesExtraAttrDesc.count), o = [];
        for (let h = 0; h < a.length; h++) {
          const l = a[h];
          o.push(l & 255), o.push((l & 65280) >> 8), o.push((l & 16711680) >> 16), o.push(l >> 24 & 255);
        }
        t.setVerticesData(p.MatricesIndicesExtraKind, o, !1);
      }
      if (n.matricesWeightsAttrDesc && n.matricesWeightsAttrDesc.count > 0) {
        const a = new Float32Array(e, n.matricesWeightsAttrDesc.offset, n.matricesWeightsAttrDesc.count);
        t.setVerticesData(p.MatricesWeightsKind, a, !1);
      }
      if (n.indicesAttrDesc && n.indicesAttrDesc.count > 0) {
        const a = new Int32Array(e, n.indicesAttrDesc.offset, n.indicesAttrDesc.count);
        t.setIndices(a, null);
      }
      if (n.subMeshesAttrDesc && n.subMeshesAttrDesc.count > 0) {
        const a = new Int32Array(e, n.subMeshesAttrDesc.offset, n.subMeshesAttrDesc.count * 5);
        t.subMeshes = [];
        for (let o = 0; o < n.subMeshesAttrDesc.count; o++) {
          const h = a[o * 5 + 0], l = a[o * 5 + 1], u = a[o * 5 + 2], f = a[o * 5 + 3], d = a[o * 5 + 4];
          mt.AddToMesh(h, l, u, f, d, t);
        }
      }
    } else if (e.positions && e.normals && e.indices) {
      if (t.setVerticesData(p.PositionKind, e.positions, e.positions._updatable), t.setVerticesData(p.NormalKind, e.normals, e.normals._updatable), e.tangents && t.setVerticesData(p.TangentKind, e.tangents, e.tangents._updatable), e.uvs && t.setVerticesData(p.UVKind, e.uvs, e.uvs._updatable), e.uvs2 && t.setVerticesData(p.UV2Kind, e.uvs2, e.uvs2._updatable), e.uvs3 && t.setVerticesData(p.UV3Kind, e.uvs3, e.uvs3._updatable), e.uvs4 && t.setVerticesData(p.UV4Kind, e.uvs4, e.uvs4._updatable), e.uvs5 && t.setVerticesData(p.UV5Kind, e.uvs5, e.uvs5._updatable), e.uvs6 && t.setVerticesData(p.UV6Kind, e.uvs6, e.uvs6._updatable), e.colors && t.setVerticesData(p.ColorKind, ge.CheckColors4(e.colors, e.positions.length / 3), e.colors._updatable), e.matricesIndices)
        if (e.matricesIndices._isExpanded)
          delete e.matricesIndices._isExpanded, t.setVerticesData(p.MatricesIndicesKind, e.matricesIndices, e.matricesIndices._updatable);
        else {
          const n = [];
          for (let a = 0; a < e.matricesIndices.length; a++) {
            const o = e.matricesIndices[a];
            n.push(o & 255), n.push((o & 65280) >> 8), n.push((o & 16711680) >> 16), n.push(o >> 24 & 255);
          }
          t.setVerticesData(p.MatricesIndicesKind, n, e.matricesIndices._updatable);
        }
      if (e.matricesIndicesExtra)
        if (e.matricesIndicesExtra._isExpanded)
          delete e.matricesIndices._isExpanded, t.setVerticesData(p.MatricesIndicesExtraKind, e.matricesIndicesExtra, e.matricesIndicesExtra._updatable);
        else {
          const n = [];
          for (let a = 0; a < e.matricesIndicesExtra.length; a++) {
            const o = e.matricesIndicesExtra[a];
            n.push(o & 255), n.push((o & 65280) >> 8), n.push((o & 16711680) >> 16), n.push(o >> 24 & 255);
          }
          t.setVerticesData(p.MatricesIndicesExtraKind, n, e.matricesIndicesExtra._updatable);
        }
      e.matricesWeights && (nt._CleanMatricesWeights(e, t), t.setVerticesData(p.MatricesWeightsKind, e.matricesWeights, e.matricesWeights._updatable)), e.matricesWeightsExtra && t.setVerticesData(p.MatricesWeightsExtraKind, e.matricesWeightsExtra, e.matricesWeights._updatable), t.setIndices(e.indices, null);
    }
    if (e.subMeshes) {
      t.subMeshes = [];
      for (let n = 0; n < e.subMeshes.length; n++) {
        const a = e.subMeshes[n];
        mt.AddToMesh(a.materialIndex, a.verticesStart, a.verticesCount, a.indexStart, a.indexCount, t);
      }
    }
    t._shouldGenerateFlatShading && (t.convertToFlatShadedMesh(), t._shouldGenerateFlatShading = !1), t.computeWorldMatrix(!0), i.onMeshImportedObservable.notifyObservers(t);
  }
  static _CleanMatricesWeights(e, t) {
    if (!we.CleanBoneMatrixWeights)
      return;
    let s = 0;
    if (e.skeletonId > -1) {
      const u = t.getScene().getLastSkeletonById(e.skeletonId);
      if (!u)
        return;
      s = u.bones.length;
    } else
      return;
    const r = t.getVerticesData(p.MatricesIndicesKind), n = t.getVerticesData(p.MatricesIndicesExtraKind), a = e.matricesWeights, o = e.matricesWeightsExtra, h = e.numBoneInfluencer, l = a.length;
    for (let u = 0; u < l; u += 4) {
      let f = 0, d = -1;
      for (let _ = 0; _ < 4; _++) {
        const E = a[u + _];
        f += E, E < 1e-3 && d < 0 && (d = _);
      }
      if (o)
        for (let _ = 0; _ < 4; _++) {
          const E = o[u + _];
          f += E, E < 1e-3 && d < 0 && (d = _ + 4);
        }
      if ((d < 0 || d > h - 1) && (d = h - 1), f > 1e-3) {
        const _ = 1 / f;
        for (let E = 0; E < 4; E++)
          a[u + E] *= _;
        if (o)
          for (let E = 0; E < 4; E++)
            o[u + E] *= _;
      } else
        d >= 4 ? (o[u + d - 4] = 1 - f, n[u + d - 4] = s) : (a[u + d] = 1 - f, r[u + d] = s);
    }
    t.setVerticesData(p.MatricesIndicesKind, r), e.matricesWeightsExtra && t.setVerticesData(p.MatricesIndicesExtraKind, n);
  }
  static Parse(e, t, i) {
    const s = new nt(e.id, t, void 0, e.updatable);
    return s._loadedUniqueId = e.uniqueId, pe && pe.AddTagsTo(s, e.tags), e.delayLoadingFile ? (s.delayLoadState = 4, s.delayLoadingFile = i + e.delayLoadingFile, s._boundingInfo = new ft(g.FromArray(e.boundingBoxMinimum), g.FromArray(e.boundingBoxMaximum)), s._delayInfo = [], e.hasUVs && s._delayInfo.push(p.UVKind), e.hasUVs2 && s._delayInfo.push(p.UV2Kind), e.hasUVs3 && s._delayInfo.push(p.UV3Kind), e.hasUVs4 && s._delayInfo.push(p.UV4Kind), e.hasUVs5 && s._delayInfo.push(p.UV5Kind), e.hasUVs6 && s._delayInfo.push(p.UV6Kind), e.hasColors && s._delayInfo.push(p.ColorKind), e.hasMatricesIndices && s._delayInfo.push(p.MatricesIndicesKind), e.hasMatricesWeights && s._delayInfo.push(p.MatricesWeightsKind), s._delayLoadingFunction = Z.ImportVertexData) : Z.ImportVertexData(e, s), t.pushGeometry(s, !0), s;
  }
}
var Ot;
(function(c) {
  c[c.LOCAL = 0] = "LOCAL", c[c.WORLD = 1] = "WORLD", c[c.BONE = 2] = "BONE";
})(Ot || (Ot = {}));
class hi {
}
hi.X = new g(1, 0, 0);
hi.Y = new g(0, 1, 0);
hi.Z = new g(0, 0, 1);
var ar;
(function(c) {
  c[c.X = 0] = "X", c[c.Y = 1] = "Y", c[c.Z = 2] = "Z";
})(ar || (ar = {}));
class $ extends Xe {
  constructor(e, t = null, i = !0) {
    super(e, t), this._forward = new g(0, 0, 1), this._up = new g(0, 1, 0), this._right = new g(1, 0, 0), this._position = g.Zero(), this._rotation = g.Zero(), this._rotationQuaternion = null, this._scaling = g.One(), this._transformToBoneReferal = null, this._isAbsoluteSynced = !1, this._billboardMode = $.BILLBOARDMODE_NONE, this._preserveParentRotationForBillboard = !1, this.scalingDeterminant = 1, this._infiniteDistance = !1, this.ignoreNonUniformScaling = !1, this.reIntegrateRotationIntoRotationQuaternion = !1, this._poseMatrix = null, this._localMatrix = x.Zero(), this._usePivotMatrix = !1, this._absolutePosition = g.Zero(), this._absoluteScaling = g.Zero(), this._absoluteRotationQuaternion = z.Identity(), this._pivotMatrix = x.Identity(), this._postMultiplyPivotMatrix = !1, this._isWorldMatrixFrozen = !1, this._indexInSceneTransformNodesArray = -1, this.onAfterWorldMatrixUpdateObservable = new F(), this._nonUniformScaling = !1, i && this.getScene().addTransformNode(this);
  }
  get billboardMode() {
    return this._billboardMode;
  }
  set billboardMode(e) {
    this._billboardMode !== e && (this._billboardMode = e);
  }
  get preserveParentRotationForBillboard() {
    return this._preserveParentRotationForBillboard;
  }
  set preserveParentRotationForBillboard(e) {
    e !== this._preserveParentRotationForBillboard && (this._preserveParentRotationForBillboard = e);
  }
  get infiniteDistance() {
    return this._infiniteDistance;
  }
  set infiniteDistance(e) {
    this._infiniteDistance !== e && (this._infiniteDistance = e);
  }
  getClassName() {
    return "TransformNode";
  }
  get position() {
    return this._position;
  }
  set position(e) {
    this._position = e, this._isDirty = !0;
  }
  isUsingPivotMatrix() {
    return this._usePivotMatrix;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(e) {
    this._rotation = e, this._rotationQuaternion = null, this._isDirty = !0;
  }
  get scaling() {
    return this._scaling;
  }
  set scaling(e) {
    this._scaling = e, this._isDirty = !0;
  }
  get rotationQuaternion() {
    return this._rotationQuaternion;
  }
  set rotationQuaternion(e) {
    this._rotationQuaternion = e, e && this._rotation.setAll(0), this._isDirty = !0;
  }
  get forward() {
    return g.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1 : 1, this.getWorldMatrix(), this._forward), this._forward.normalize();
  }
  get up() {
    return g.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up), this._up.normalize();
  }
  get right() {
    return g.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1 : 1, 0, 0, this.getWorldMatrix(), this._right), this._right.normalize();
  }
  updatePoseMatrix(e) {
    return this._poseMatrix ? (this._poseMatrix.copyFrom(e), this) : (this._poseMatrix = e.clone(), this);
  }
  getPoseMatrix() {
    return this._poseMatrix || (this._poseMatrix = x.Identity()), this._poseMatrix;
  }
  _isSynchronized() {
    const e = this._cache;
    return !(this._billboardMode !== e.billboardMode || this._billboardMode !== $.BILLBOARDMODE_NONE || e.pivotMatrixUpdated || this._infiniteDistance || this._position._isDirty || this._scaling._isDirty || this._rotationQuaternion && this._rotationQuaternion._isDirty || this._rotation._isDirty);
  }
  _initCache() {
    super._initCache();
    const e = this._cache;
    e.localMatrixUpdated = !1, e.billboardMode = -1, e.infiniteDistance = !1;
  }
  get absolutePosition() {
    return this.getAbsolutePosition();
  }
  get absoluteScaling() {
    return this._syncAbsoluteScalingAndRotation(), this._absoluteScaling;
  }
  get absoluteRotationQuaternion() {
    return this._syncAbsoluteScalingAndRotation(), this._absoluteRotationQuaternion;
  }
  setPreTransformMatrix(e) {
    return this.setPivotMatrix(e, !1);
  }
  setPivotMatrix(e, t = !0) {
    return this._pivotMatrix.copyFrom(e), this._usePivotMatrix = !this._pivotMatrix.isIdentity(), this._cache.pivotMatrixUpdated = !0, this._postMultiplyPivotMatrix = t, this._postMultiplyPivotMatrix && (this._pivotMatrixInverse ? this._pivotMatrix.invertToRef(this._pivotMatrixInverse) : this._pivotMatrixInverse = x.Invert(this._pivotMatrix)), this;
  }
  getPivotMatrix() {
    return this._pivotMatrix;
  }
  instantiateHierarchy(e = null, t, i) {
    const s = this.clone("Clone of " + (this.name || this.id), e || this.parent, !0);
    s && i && i(this, s);
    for (const r of this.getChildTransformNodes(!0))
      r.instantiateHierarchy(s, t, i);
    return s;
  }
  freezeWorldMatrix(e = null, t = !1) {
    return e ? t ? (this._rotation.setAll(0), this._rotationQuaternion = this._rotationQuaternion || z.Identity(), e.decompose(this._scaling, this._rotationQuaternion, this._position), this.computeWorldMatrix(!0)) : (this._worldMatrix = e, this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]), this._afterComputeWorldMatrix()) : (this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0)), this._isDirty = !1, this._isWorldMatrixFrozen = !0, this;
  }
  unfreezeWorldMatrix() {
    return this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0), this;
  }
  get isWorldMatrixFrozen() {
    return this._isWorldMatrixFrozen;
  }
  getAbsolutePosition() {
    return this.computeWorldMatrix(), this._absolutePosition;
  }
  setAbsolutePosition(e) {
    if (!e)
      return this;
    let t, i, s;
    if (e.x === void 0) {
      if (arguments.length < 3)
        return this;
      t = arguments[0], i = arguments[1], s = arguments[2];
    } else
      t = e.x, i = e.y, s = e.z;
    if (this.parent) {
      const r = D.Matrix[0];
      this.parent.getWorldMatrix().invertToRef(r), g.TransformCoordinatesFromFloatsToRef(t, i, s, r, this.position);
    } else
      this.position.x = t, this.position.y = i, this.position.z = s;
    return this._absolutePosition.copyFrom(e), this;
  }
  setPositionWithLocalVector(e) {
    return this.computeWorldMatrix(), this.position = g.TransformNormal(e, this._localMatrix), this;
  }
  getPositionExpressedInLocalSpace() {
    this.computeWorldMatrix();
    const e = D.Matrix[0];
    return this._localMatrix.invertToRef(e), g.TransformNormal(this.position, e);
  }
  locallyTranslate(e) {
    return this.computeWorldMatrix(!0), this.position = g.TransformCoordinates(e, this._localMatrix), this;
  }
  lookAt(e, t = 0, i = 0, s = 0, r = Ot.LOCAL) {
    const n = $._LookAtVectorCache, a = r === Ot.LOCAL ? this.position : this.getAbsolutePosition();
    if (e.subtractToRef(a, n), this.setDirection(n, t, i, s), r === Ot.WORLD && this.parent)
      if (this.rotationQuaternion) {
        const o = D.Matrix[0];
        this.rotationQuaternion.toRotationMatrix(o);
        const h = D.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(h), h.invert(), o.multiplyToRef(h, o), this.rotationQuaternion.fromRotationMatrix(o);
      } else {
        const o = D.Quaternion[0];
        z.FromEulerVectorToRef(this.rotation, o);
        const h = D.Matrix[0];
        o.toRotationMatrix(h);
        const l = D.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(l), l.invert(), h.multiplyToRef(l, h), o.fromRotationMatrix(h), o.toEulerAnglesToRef(this.rotation);
      }
    return this;
  }
  getDirection(e) {
    const t = g.Zero();
    return this.getDirectionToRef(e, t), t;
  }
  getDirectionToRef(e, t) {
    return g.TransformNormalToRef(e, this.getWorldMatrix(), t), this;
  }
  setDirection(e, t = 0, i = 0, s = 0) {
    const r = -Math.atan2(e.z, e.x) + Math.PI / 2, n = Math.sqrt(e.x * e.x + e.z * e.z), a = -Math.atan2(e.y, n);
    return this.rotationQuaternion ? z.RotationYawPitchRollToRef(r + t, a + i, s, this.rotationQuaternion) : (this.rotation.x = a + i, this.rotation.y = r + t, this.rotation.z = s), this;
  }
  setPivotPoint(e, t = Ot.LOCAL) {
    this.getScene().getRenderId() == 0 && this.computeWorldMatrix(!0);
    const i = this.getWorldMatrix();
    if (t == Ot.WORLD) {
      const s = D.Matrix[0];
      i.invertToRef(s), e = g.TransformCoordinates(e, s);
    }
    return this.setPivotMatrix(x.Translation(-e.x, -e.y, -e.z), !0);
  }
  getPivotPoint() {
    const e = g.Zero();
    return this.getPivotPointToRef(e), e;
  }
  getPivotPointToRef(e) {
    return e.x = -this._pivotMatrix.m[12], e.y = -this._pivotMatrix.m[13], e.z = -this._pivotMatrix.m[14], this;
  }
  getAbsolutePivotPoint() {
    const e = g.Zero();
    return this.getAbsolutePivotPointToRef(e), e;
  }
  getAbsolutePivotPointToRef(e) {
    return this.getPivotPointToRef(e), g.TransformCoordinatesToRef(e, this.getWorldMatrix(), e), this;
  }
  markAsDirty(e) {
    if (this._isDirty)
      return this;
    if (this._children)
      for (const t of this._children)
        t.markAsDirty(e);
    return super.markAsDirty(e);
  }
  setParent(e, t = !1) {
    if (!e && !this.parent)
      return this;
    const i = D.Quaternion[0], s = D.Vector3[0], r = D.Vector3[1], n = D.Matrix[1];
    x.IdentityToRef(n);
    const a = D.Matrix[0];
    this.computeWorldMatrix(!0);
    let o = this.rotationQuaternion;
    return o || (o = $._TmpRotation, z.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, o)), x.ComposeToRef(this.scaling, o, this.position, a), this.parent && a.multiplyToRef(this.parent.computeWorldMatrix(!0), a), e && (e.computeWorldMatrix(!0).invertToRef(n), a.multiplyToRef(n, a)), a.decompose(r, i, s, t ? this : void 0), this.rotationQuaternion ? this.rotationQuaternion.copyFrom(i) : i.toEulerAnglesToRef(this.rotation), this.scaling.copyFrom(r), this.position.copyFrom(s), this.parent = e, this;
  }
  get nonUniformScaling() {
    return this._nonUniformScaling;
  }
  _updateNonUniformScalingState(e) {
    return this._nonUniformScaling === e ? !1 : (this._nonUniformScaling = e, !0);
  }
  attachToBone(e, t) {
    return this._currentParentWhenAttachingToBone = this.parent, this._transformToBoneReferal = t, this.parent = e, e.getSkeleton().prepare(), e.getWorldMatrix().determinant() < 0 && (this.scalingDeterminant *= -1), this;
  }
  detachFromBone(e = !1) {
    return this.parent ? (this.parent.getWorldMatrix().determinant() < 0 && (this.scalingDeterminant *= -1), this._transformToBoneReferal = null, e ? this.parent = this._currentParentWhenAttachingToBone : this.parent = null, this) : (e && (this.parent = this._currentParentWhenAttachingToBone), this);
  }
  rotate(e, t, i) {
    e.normalize(), this.rotationQuaternion || (this.rotationQuaternion = this.rotation.toQuaternion(), this.rotation.setAll(0));
    let s;
    if (!i || i === Ot.LOCAL)
      s = z.RotationAxisToRef(e, t, $._RotationAxisCache), this.rotationQuaternion.multiplyToRef(s, this.rotationQuaternion);
    else {
      if (this.parent) {
        const r = D.Matrix[0];
        this.parent.getWorldMatrix().invertToRef(r), e = g.TransformNormal(e, r);
      }
      s = z.RotationAxisToRef(e, t, $._RotationAxisCache), s.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    }
    return this;
  }
  rotateAround(e, t, i) {
    t.normalize(), this.rotationQuaternion || (this.rotationQuaternion = z.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z), this.rotation.setAll(0));
    const s = D.Vector3[0], r = D.Vector3[1], n = D.Vector3[2], a = D.Quaternion[0], o = D.Matrix[0], h = D.Matrix[1], l = D.Matrix[2], u = D.Matrix[3];
    return e.subtractToRef(this.position, s), x.TranslationToRef(s.x, s.y, s.z, o), x.TranslationToRef(-s.x, -s.y, -s.z, h), x.RotationAxisToRef(t, i, l), h.multiplyToRef(l, u), u.multiplyToRef(o, u), u.decompose(r, a, n), this.position.addInPlace(n), a.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion), this;
  }
  translate(e, t, i) {
    const s = e.scale(t);
    if (!i || i === Ot.LOCAL) {
      const r = this.getPositionExpressedInLocalSpace().add(s);
      this.setPositionWithLocalVector(r);
    } else
      this.setAbsolutePosition(this.getAbsolutePosition().add(s));
    return this;
  }
  addRotation(e, t, i) {
    let s;
    this.rotationQuaternion ? s = this.rotationQuaternion : (s = D.Quaternion[1], z.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, s));
    const r = D.Quaternion[0];
    return z.RotationYawPitchRollToRef(t, e, i, r), s.multiplyInPlace(r), this.rotationQuaternion || s.toEulerAnglesToRef(this.rotation), this;
  }
  _getEffectiveParent() {
    return this.parent;
  }
  computeWorldMatrix(e) {
    if (this._isWorldMatrixFrozen && !this._isDirty)
      return this._worldMatrix;
    const t = this.getScene().getRenderId();
    if (!this._isDirty && !e && (this._currentRenderId === t || this.isSynchronized()))
      return this._currentRenderId = t, this._worldMatrix;
    const i = this.getScene().activeCamera, s = (this._billboardMode & $.BILLBOARDMODE_USE_POSITION) !== 0, r = this._billboardMode !== $.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
    this._updateCache();
    const n = this._cache;
    n.pivotMatrixUpdated = !1, n.billboardMode = this.billboardMode, n.infiniteDistance = this.infiniteDistance, n.parent = this._parentNode, this._currentRenderId = t, this._childUpdateId += 1, this._isDirty = !1, this._position._isDirty = !1, this._rotation._isDirty = !1, this._scaling._isDirty = !1;
    const a = this._getEffectiveParent(), o = $._TmpScaling;
    let h = this._position;
    if (this._infiniteDistance && !this.parent && i) {
      const u = i.getWorldMatrix(), f = new g(u.m[12], u.m[13], u.m[14]);
      h = $._TmpTranslation, h.copyFromFloats(this._position.x + f.x, this._position.y + f.y, this._position.z + f.z);
    }
    o.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);
    let l;
    if (this._rotationQuaternion ? (this._rotationQuaternion._isDirty = !1, l = this._rotationQuaternion, this.reIntegrateRotationIntoRotationQuaternion && this.rotation.lengthSquared() && (this._rotationQuaternion.multiplyInPlace(z.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z)), this._rotation.copyFromFloats(0, 0, 0))) : (l = $._TmpRotation, z.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, l)), this._usePivotMatrix) {
      const u = D.Matrix[1];
      x.ScalingToRef(o.x, o.y, o.z, u);
      const f = D.Matrix[0];
      l.toRotationMatrix(f), this._pivotMatrix.multiplyToRef(u, D.Matrix[4]), D.Matrix[4].multiplyToRef(f, this._localMatrix), this._postMultiplyPivotMatrix && this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix), this._localMatrix.addTranslationFromFloats(h.x, h.y, h.z);
    } else
      x.ComposeToRef(o, l, h, this._localMatrix);
    if (a && a.getWorldMatrix) {
      if (e && a.computeWorldMatrix(e), r) {
        this._transformToBoneReferal ? a.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), D.Matrix[7]) : D.Matrix[7].copyFrom(a.getWorldMatrix());
        const u = D.Vector3[5], f = D.Vector3[6];
        D.Matrix[7].decompose(f, void 0, u), x.ScalingToRef(f.x, f.y, f.z, D.Matrix[7]), D.Matrix[7].setTranslation(u), this._localMatrix.multiplyToRef(D.Matrix[7], this._worldMatrix);
      } else
        this._transformToBoneReferal ? (this._localMatrix.multiplyToRef(a.getWorldMatrix(), D.Matrix[6]), D.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix)) : this._localMatrix.multiplyToRef(a.getWorldMatrix(), this._worldMatrix);
      this._markSyncedWithParent();
    } else
      this._worldMatrix.copyFrom(this._localMatrix);
    if (r && i && this.billboardMode && !s) {
      const u = D.Vector3[0];
      if (this._worldMatrix.getTranslationToRef(u), D.Matrix[1].copyFrom(i.getViewMatrix()), D.Matrix[1].setTranslationFromFloats(0, 0, 0), D.Matrix[1].invertToRef(D.Matrix[0]), (this.billboardMode & $.BILLBOARDMODE_ALL) !== $.BILLBOARDMODE_ALL) {
        D.Matrix[0].decompose(void 0, D.Quaternion[0], void 0);
        const f = D.Vector3[1];
        D.Quaternion[0].toEulerAnglesToRef(f), (this.billboardMode & $.BILLBOARDMODE_X) !== $.BILLBOARDMODE_X && (f.x = 0), (this.billboardMode & $.BILLBOARDMODE_Y) !== $.BILLBOARDMODE_Y && (f.y = 0), (this.billboardMode & $.BILLBOARDMODE_Z) !== $.BILLBOARDMODE_Z && (f.z = 0), x.RotationYawPitchRollToRef(f.y, f.x, f.z, D.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0), this._worldMatrix.multiplyToRef(D.Matrix[0], this._worldMatrix), this._worldMatrix.setTranslation(D.Vector3[0]);
    } else if (r && i && this.billboardMode && s) {
      const u = D.Vector3[0];
      this._worldMatrix.getTranslationToRef(u);
      const f = i.globalPosition;
      this._worldMatrix.invertToRef(D.Matrix[1]);
      const d = D.Vector3[1];
      g.TransformCoordinatesToRef(f, D.Matrix[1], d), d.normalize();
      const _ = -Math.atan2(d.z, d.x) + Math.PI / 2, E = Math.sqrt(d.x * d.x + d.z * d.z), m = -Math.atan2(d.y, E);
      if (z.RotationYawPitchRollToRef(_, m, 0, D.Quaternion[0]), (this.billboardMode & $.BILLBOARDMODE_ALL) !== $.BILLBOARDMODE_ALL) {
        const T = D.Vector3[1];
        D.Quaternion[0].toEulerAnglesToRef(T), (this.billboardMode & $.BILLBOARDMODE_X) !== $.BILLBOARDMODE_X && (T.x = 0), (this.billboardMode & $.BILLBOARDMODE_Y) !== $.BILLBOARDMODE_Y && (T.y = 0), (this.billboardMode & $.BILLBOARDMODE_Z) !== $.BILLBOARDMODE_Z && (T.z = 0), x.RotationYawPitchRollToRef(T.y, T.x, T.z, D.Matrix[0]);
      } else
        x.FromQuaternionToRef(D.Quaternion[0], D.Matrix[0]);
      this._worldMatrix.setTranslationFromFloats(0, 0, 0), this._worldMatrix.multiplyToRef(D.Matrix[0], this._worldMatrix), this._worldMatrix.setTranslation(D.Vector3[0]);
    }
    return this.ignoreNonUniformScaling ? this._updateNonUniformScalingState(!1) : this._scaling.isNonUniformWithinEpsilon(1e-6) ? this._updateNonUniformScalingState(!0) : a && a._nonUniformScaling ? this._updateNonUniformScalingState(a._nonUniformScaling) : this._updateNonUniformScalingState(!1), this._afterComputeWorldMatrix(), this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]), this._isAbsoluteSynced = !1, this.onAfterWorldMatrixUpdateObservable.notifyObservers(this), this._poseMatrix || (this._poseMatrix = x.Invert(this._worldMatrix)), this._worldMatrixDeterminantIsDirty = !0, this._worldMatrix;
  }
  resetLocalMatrix(e = !0) {
    if (this.computeWorldMatrix(), e) {
      const t = this.getChildren();
      for (let i = 0; i < t.length; ++i) {
        const s = t[i];
        if (s) {
          s.computeWorldMatrix();
          const r = D.Matrix[0];
          s._localMatrix.multiplyToRef(this._localMatrix, r);
          const n = D.Quaternion[0];
          r.decompose(s.scaling, n, s.position), s.rotationQuaternion ? s.rotationQuaternion.copyFrom(n) : n.toEulerAnglesToRef(s.rotation);
        }
      }
    }
    this.scaling.copyFromFloats(1, 1, 1), this.position.copyFromFloats(0, 0, 0), this.rotation.copyFromFloats(0, 0, 0), this.rotationQuaternion && (this.rotationQuaternion = z.Identity()), this._worldMatrix = x.Identity();
  }
  _afterComputeWorldMatrix() {
  }
  registerAfterWorldMatrixUpdate(e) {
    return this.onAfterWorldMatrixUpdateObservable.add(e), this;
  }
  unregisterAfterWorldMatrixUpdate(e) {
    return this.onAfterWorldMatrixUpdateObservable.removeCallback(e), this;
  }
  getPositionInCameraSpace(e = null) {
    return e || (e = this.getScene().activeCamera), g.TransformCoordinates(this.getAbsolutePosition(), e.getViewMatrix());
  }
  getDistanceToCamera(e = null) {
    return e || (e = this.getScene().activeCamera), this.getAbsolutePosition().subtract(e.globalPosition).length();
  }
  clone(e, t, i) {
    const s = ne.Clone(() => new $(e, this.getScene()), this);
    if (s.name = e, s.id = e, t && (s.parent = t), !i) {
      const r = this.getDescendants(!0);
      for (let n = 0; n < r.length; n++) {
        const a = r[n];
        a.clone && a.clone(e + "." + a.name, s);
      }
    }
    return s;
  }
  serialize(e) {
    const t = ne.Serialize(this, e);
    return t.type = this.getClassName(), t.uniqueId = this.uniqueId, this.parent && this.parent._serializeAsParent(t), t.localMatrix = this.getPivotMatrix().asArray(), t.isEnabled = this.isEnabled(), t;
  }
  static Parse(e, t, i) {
    const s = ne.Parse(() => new $(e.name, t), e, t, i);
    return e.localMatrix ? s.setPreTransformMatrix(x.FromArray(e.localMatrix)) : e.pivotMatrix && s.setPivotMatrix(x.FromArray(e.pivotMatrix)), s.setEnabled(e.isEnabled), s._waitingParsedUniqueId = e.uniqueId, e.parentId !== void 0 && (s._waitingParentId = e.parentId), e.parentInstanceIndex !== void 0 && (s._waitingParentInstanceIndex = e.parentInstanceIndex), s;
  }
  getChildTransformNodes(e, t) {
    const i = [];
    return this._getDescendants(i, e, (s) => (!t || t(s)) && s instanceof $), i;
  }
  dispose(e, t = !1) {
    if (this.getScene().stopAnimation(this), this.getScene().removeTransformNode(this), this._parentContainer) {
      const i = this._parentContainer.transformNodes.indexOf(this);
      i > -1 && this._parentContainer.transformNodes.splice(i, 1), this._parentContainer = null;
    }
    if (this.onAfterWorldMatrixUpdateObservable.clear(), e) {
      const i = this.getChildTransformNodes(!0);
      for (const s of i)
        s.parent = null, s.computeWorldMatrix(!0);
    }
    super.dispose(e, t);
  }
  normalizeToUnitCube(e = !0, t = !1, i) {
    let s = null, r = null;
    t && (this.rotationQuaternion ? (r = this.rotationQuaternion.clone(), this.rotationQuaternion.copyFromFloats(0, 0, 0, 1)) : this.rotation && (s = this.rotation.clone(), this.rotation.copyFromFloats(0, 0, 0)));
    const n = this.getHierarchyBoundingVectors(e, i), a = n.max.subtract(n.min), o = Math.max(a.x, a.y, a.z);
    if (o === 0)
      return this;
    const h = 1 / o;
    return this.scaling.scaleInPlace(h), t && (this.rotationQuaternion && r ? this.rotationQuaternion.copyFrom(r) : this.rotation && s && this.rotation.copyFrom(s)), this;
  }
  _syncAbsoluteScalingAndRotation() {
    this._isAbsoluteSynced || (this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion), this._isAbsoluteSynced = !0);
  }
}
$.BILLBOARDMODE_NONE = 0;
$.BILLBOARDMODE_X = 1;
$.BILLBOARDMODE_Y = 2;
$.BILLBOARDMODE_Z = 4;
$.BILLBOARDMODE_ALL = 7;
$.BILLBOARDMODE_USE_POSITION = 128;
$._TmpRotation = z.Zero();
$._TmpScaling = g.Zero();
$._TmpTranslation = g.Zero();
$._LookAtVectorCache = new g(0, 0, 0);
$._RotationAxisCache = new z();
S([
  Wt("position")
], $.prototype, "_position", void 0);
S([
  Wt("rotation")
], $.prototype, "_rotation", void 0);
S([
  pn("rotationQuaternion")
], $.prototype, "_rotationQuaternion", void 0);
S([
  Wt("scaling")
], $.prototype, "_scaling", void 0);
S([
  M("billboardMode")
], $.prototype, "_billboardMode", void 0);
S([
  M()
], $.prototype, "scalingDeterminant", void 0);
S([
  M("infiniteDistance")
], $.prototype, "_infiniteDistance", void 0);
S([
  M()
], $.prototype, "ignoreNonUniformScaling", void 0);
S([
  M()
], $.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0);
class Cn {
  constructor() {
    this._checkCollisions = !1, this._collisionMask = -1, this._collisionGroup = -1, this._surroundingMeshes = null, this._collider = null, this._oldPositionForCollisions = new g(0, 0, 0), this._diffPositionForCollisions = new g(0, 0, 0), this._collisionResponse = !0;
  }
}
class In {
  constructor() {
    this.facetNb = 0, this.partitioningSubdivisions = 10, this.partitioningBBoxRatio = 1.01, this.facetDataEnabled = !1, this.facetParameters = {}, this.bbSize = g.Zero(), this.subDiv = {
      max: 1,
      X: 1,
      Y: 1,
      Z: 1
    }, this.facetDepthSort = !1, this.facetDepthSortEnabled = !1;
  }
}
class Pn {
  constructor() {
    this._hasVertexAlpha = !1, this._useVertexColors = !0, this._numBoneInfluencers = 4, this._applyFog = !0, this._receiveShadows = !1, this._facetData = new In(), this._visibility = 1, this._skeleton = null, this._layerMask = 268435455, this._computeBonesUsingShaders = !0, this._isActive = !1, this._onlyForInstances = !1, this._isActiveIntermediate = !1, this._onlyForInstancesIntermediate = !1, this._actAsRegularMesh = !1, this._currentLOD = null, this._currentLODIsUpToDate = !1, this._collisionRetryCount = 3, this._morphTargetManager = null, this._renderingGroupId = 0, this._bakedVertexAnimationManager = null, this._material = null, this._positions = null, this._meshCollisionData = new Cn(), this._enableDistantPicking = !1;
  }
}
class at extends $ {
  constructor(e, t = null) {
    super(e, t, !1), this._internalAbstractMeshDataInfo = new Pn(), this._waitingMaterialId = null, this.cullingStrategy = at.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY, this.onCollideObservable = new F(), this.onCollisionPositionChangeObservable = new F(), this.onMaterialChangedObservable = new F(), this.definedFacingForward = !0, this._occlusionQuery = null, this._renderingGroup = null, this.alphaIndex = Number.MAX_VALUE, this.isVisible = !0, this.isPickable = !0, this.isNearPickable = !1, this.isNearGrabbable = !1, this.showSubMeshesBoundingBox = !1, this.isBlocker = !1, this.enablePointerMoveEvents = !1, this.outlineColor = te.Red(), this.outlineWidth = 0.02, this.overlayColor = te.Red(), this.overlayAlpha = 0.5, this.useOctreeForRenderingSelection = !0, this.useOctreeForPicking = !0, this.useOctreeForCollisions = !0, this.alwaysSelectAsActiveMesh = !1, this.doNotSyncBoundingInfo = !1, this.actionManager = null, this.ellipsoid = new g(0.5, 1, 0.5), this.ellipsoidOffset = new g(0, 0, 0), this.edgesWidth = 1, this.edgesColor = new ge(1, 0, 0, 1), this._edgesRenderer = null, this._masterMesh = null, this._boundingInfo = null, this._boundingInfoIsDirty = !0, this._renderId = 0, this._intersectionsInProgress = new Array(), this._unIndexed = !1, this._lightSources = new Array(), this._waitingData = {
      lods: null,
      actions: null,
      freezeWorldMatrix: null
    }, this._bonesTransformMatrices = null, this._transformMatrixTexture = null, this.onRebuildObservable = new F(), this._onCollisionPositionChange = (i, s, r = null) => {
      s.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions), this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > C.CollisionsEpsilon && this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions), r && this.onCollideObservable.notifyObservers(r), this.onCollisionPositionChangeObservable.notifyObservers(this.position);
    }, t = this.getScene(), t.addMesh(this), this._resyncLightSources(), this._uniformBuffer = new G(this.getScene().getEngine(), void 0, void 0, e, !this.getScene().getEngine().isWebGPU), this._buildUniformLayout(), t.performancePriority !== ri.BackwardCompatible && (this.alwaysSelectAsActiveMesh = !0, this.isPickable = !1);
  }
  static get BILLBOARDMODE_NONE() {
    return $.BILLBOARDMODE_NONE;
  }
  static get BILLBOARDMODE_X() {
    return $.BILLBOARDMODE_X;
  }
  static get BILLBOARDMODE_Y() {
    return $.BILLBOARDMODE_Y;
  }
  static get BILLBOARDMODE_Z() {
    return $.BILLBOARDMODE_Z;
  }
  static get BILLBOARDMODE_ALL() {
    return $.BILLBOARDMODE_ALL;
  }
  static get BILLBOARDMODE_USE_POSITION() {
    return $.BILLBOARDMODE_USE_POSITION;
  }
  get facetNb() {
    return this._internalAbstractMeshDataInfo._facetData.facetNb;
  }
  get partitioningSubdivisions() {
    return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;
  }
  set partitioningSubdivisions(e) {
    this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = e;
  }
  get partitioningBBoxRatio() {
    return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;
  }
  set partitioningBBoxRatio(e) {
    this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = e;
  }
  get mustDepthSortFacets() {
    return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;
  }
  set mustDepthSortFacets(e) {
    this._internalAbstractMeshDataInfo._facetData.facetDepthSort = e;
  }
  get facetDepthSortFrom() {
    return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;
  }
  set facetDepthSortFrom(e) {
    this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = e;
  }
  get collisionRetryCount() {
    return this._internalAbstractMeshDataInfo._collisionRetryCount;
  }
  set collisionRetryCount(e) {
    this._internalAbstractMeshDataInfo._collisionRetryCount = e;
  }
  get isFacetDataEnabled() {
    return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;
  }
  get morphTargetManager() {
    return this._internalAbstractMeshDataInfo._morphTargetManager;
  }
  set morphTargetManager(e) {
    this._internalAbstractMeshDataInfo._morphTargetManager !== e && (this._internalAbstractMeshDataInfo._morphTargetManager = e, this._syncGeometryWithMorphTargetManager());
  }
  get bakedVertexAnimationManager() {
    return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;
  }
  set bakedVertexAnimationManager(e) {
    this._internalAbstractMeshDataInfo._bakedVertexAnimationManager !== e && (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = e, this._markSubMeshesAsAttributesDirty());
  }
  _syncGeometryWithMorphTargetManager() {
  }
  _updateNonUniformScalingState(e) {
    return super._updateNonUniformScalingState(e) ? (this._markSubMeshesAsMiscDirty(), !0) : !1;
  }
  set onCollide(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver && this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver), this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(e);
  }
  set onCollisionPositionChange(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver && this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver), this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(e);
  }
  get visibility() {
    return this._internalAbstractMeshDataInfo._visibility;
  }
  set visibility(e) {
    if (this._internalAbstractMeshDataInfo._visibility === e)
      return;
    const t = this._internalAbstractMeshDataInfo._visibility;
    this._internalAbstractMeshDataInfo._visibility = e, (t === 1 && e !== 1 || t !== 1 && e === 1) && this._markSubMeshesAsMiscDirty();
  }
  get renderingGroupId() {
    return this._internalAbstractMeshDataInfo._renderingGroupId;
  }
  set renderingGroupId(e) {
    this._internalAbstractMeshDataInfo._renderingGroupId = e;
  }
  get material() {
    return this._internalAbstractMeshDataInfo._material;
  }
  set material(e) {
    this._internalAbstractMeshDataInfo._material !== e && (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap && (this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0), this._internalAbstractMeshDataInfo._material = e, e && e.meshMap && (e.meshMap[this.uniqueId] = this), this.onMaterialChangedObservable.hasObservers() && this.onMaterialChangedObservable.notifyObservers(this), this.subMeshes && (this.resetDrawCache(), this._unBindEffect()));
  }
  getMaterialForRenderPass(e) {
    var t;
    return (t = this._internalAbstractMeshDataInfo._materialForRenderPass) == null ? void 0 : t[e];
  }
  setMaterialForRenderPass(e, t) {
    this.resetDrawCache(e), this._internalAbstractMeshDataInfo._materialForRenderPass || (this._internalAbstractMeshDataInfo._materialForRenderPass = []), this._internalAbstractMeshDataInfo._materialForRenderPass[e] = t;
  }
  get receiveShadows() {
    return this._internalAbstractMeshDataInfo._receiveShadows;
  }
  set receiveShadows(e) {
    this._internalAbstractMeshDataInfo._receiveShadows !== e && (this._internalAbstractMeshDataInfo._receiveShadows = e, this._markSubMeshesAsLightDirty());
  }
  get hasVertexAlpha() {
    return this._internalAbstractMeshDataInfo._hasVertexAlpha;
  }
  set hasVertexAlpha(e) {
    this._internalAbstractMeshDataInfo._hasVertexAlpha !== e && (this._internalAbstractMeshDataInfo._hasVertexAlpha = e, this._markSubMeshesAsAttributesDirty(), this._markSubMeshesAsMiscDirty());
  }
  get useVertexColors() {
    return this._internalAbstractMeshDataInfo._useVertexColors;
  }
  set useVertexColors(e) {
    this._internalAbstractMeshDataInfo._useVertexColors !== e && (this._internalAbstractMeshDataInfo._useVertexColors = e, this._markSubMeshesAsAttributesDirty());
  }
  get computeBonesUsingShaders() {
    return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
  }
  set computeBonesUsingShaders(e) {
    this._internalAbstractMeshDataInfo._computeBonesUsingShaders !== e && (this._internalAbstractMeshDataInfo._computeBonesUsingShaders = e, this._markSubMeshesAsAttributesDirty());
  }
  get numBoneInfluencers() {
    return this._internalAbstractMeshDataInfo._numBoneInfluencers;
  }
  set numBoneInfluencers(e) {
    this._internalAbstractMeshDataInfo._numBoneInfluencers !== e && (this._internalAbstractMeshDataInfo._numBoneInfluencers = e, this._markSubMeshesAsAttributesDirty());
  }
  get applyFog() {
    return this._internalAbstractMeshDataInfo._applyFog;
  }
  set applyFog(e) {
    this._internalAbstractMeshDataInfo._applyFog !== e && (this._internalAbstractMeshDataInfo._applyFog = e, this._markSubMeshesAsMiscDirty());
  }
  get enableDistantPicking() {
    return this._internalAbstractMeshDataInfo._enableDistantPicking;
  }
  set enableDistantPicking(e) {
    this._internalAbstractMeshDataInfo._enableDistantPicking = e;
  }
  get layerMask() {
    return this._internalAbstractMeshDataInfo._layerMask;
  }
  set layerMask(e) {
    e !== this._internalAbstractMeshDataInfo._layerMask && (this._internalAbstractMeshDataInfo._layerMask = e, this._resyncLightSources());
  }
  get collisionMask() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;
  }
  set collisionMask(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = isNaN(e) ? -1 : e;
  }
  get collisionResponse() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;
  }
  set collisionResponse(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = e;
  }
  get collisionGroup() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;
  }
  set collisionGroup(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = isNaN(e) ? -1 : e;
  }
  get surroundingMeshes() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;
  }
  set surroundingMeshes(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = e;
  }
  get lightSources() {
    return this._lightSources;
  }
  get _positions() {
    return null;
  }
  set skeleton(e) {
    const t = this._internalAbstractMeshDataInfo._skeleton;
    t && t.needInitialSkinMatrix && t._unregisterMeshWithPoseMatrix(this), e && e.needInitialSkinMatrix && e._registerMeshWithPoseMatrix(this), this._internalAbstractMeshDataInfo._skeleton = e, this._internalAbstractMeshDataInfo._skeleton || (this._bonesTransformMatrices = null), this._markSubMeshesAsAttributesDirty();
  }
  get skeleton() {
    return this._internalAbstractMeshDataInfo._skeleton;
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("world", 16), this._uniformBuffer.addUniform("visibility", 1), this._uniformBuffer.create();
  }
  transferToEffect(e) {
    const t = this._uniformBuffer;
    t.updateMatrix("world", e), t.updateFloat("visibility", this._internalAbstractMeshDataInfo._visibility), t.update();
  }
  getMeshUniformBuffer() {
    return this._uniformBuffer;
  }
  getClassName() {
    return "AbstractMesh";
  }
  toString(e) {
    let t = "Name: " + this.name + ", isInstance: " + (this.getClassName() !== "InstancedMesh" ? "YES" : "NO");
    t += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0);
    const i = this._internalAbstractMeshDataInfo._skeleton;
    return i && (t += ", skeleton: " + i.name), e && (t += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode], t += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO")), t;
  }
  _getEffectiveParent() {
    return this._masterMesh && this.billboardMode !== $.BILLBOARDMODE_NONE ? this._masterMesh : super._getEffectiveParent();
  }
  _getActionManagerForTrigger(e, t = !0) {
    if (this.actionManager && (t || this.actionManager.isRecursive))
      if (e) {
        if (this.actionManager.hasSpecificTrigger(e))
          return this.actionManager;
      } else
        return this.actionManager;
    return this.parent ? this.parent._getActionManagerForTrigger(e, !1) : null;
  }
  _rebuild(e = !1) {
    if (this.onRebuildObservable.notifyObservers(this), this._occlusionQuery !== null && (this._occlusionQuery = null), !!this.subMeshes)
      for (const t of this.subMeshes)
        t._rebuild();
  }
  _resyncLightSources() {
    this._lightSources.length = 0;
    for (const e of this.getScene().lights)
      !e.isEnabled() || e.canAffectMesh(this) && this._lightSources.push(e);
    this._markSubMeshesAsLightDirty();
  }
  _resyncLightSource(e) {
    const t = e.isEnabled() && e.canAffectMesh(this), i = this._lightSources.indexOf(e);
    let s = !1;
    if (i === -1) {
      if (!t)
        return;
      this._lightSources.push(e);
    } else {
      if (t)
        return;
      s = !0, this._lightSources.splice(i, 1);
    }
    this._markSubMeshesAsLightDirty(s);
  }
  _unBindEffect() {
    for (const e of this.subMeshes)
      e.setEffect(null);
  }
  _removeLightSource(e, t) {
    const i = this._lightSources.indexOf(e);
    i !== -1 && (this._lightSources.splice(i, 1), this._markSubMeshesAsLightDirty(t));
  }
  _markSubMeshesAsDirty(e) {
    if (!!this.subMeshes)
      for (const t of this.subMeshes)
        for (let i = 0; i < t._drawWrappers.length; ++i) {
          const s = t._drawWrappers[i];
          !s || !s.defines || !s.defines.markAllAsDirty || e(s.defines);
        }
  }
  _markSubMeshesAsLightDirty(e = !1) {
    this._markSubMeshesAsDirty((t) => t.markAsLightDirty(e));
  }
  _markSubMeshesAsAttributesDirty() {
    this._markSubMeshesAsDirty((e) => e.markAsAttributesDirty());
  }
  _markSubMeshesAsMiscDirty() {
    this._markSubMeshesAsDirty((e) => e.markAsMiscDirty());
  }
  markAsDirty(e) {
    return this._currentRenderId = Number.MAX_VALUE, this._isDirty = !0, this;
  }
  resetDrawCache(e) {
    if (!!this.subMeshes)
      for (const t of this.subMeshes)
        t.resetDrawCache(e);
  }
  get isBlocked() {
    return !1;
  }
  getLOD(e) {
    return this;
  }
  getTotalVertices() {
    return 0;
  }
  getTotalIndices() {
    return 0;
  }
  getIndices() {
    return null;
  }
  getVerticesData(e) {
    return null;
  }
  setVerticesData(e, t, i, s) {
    return this;
  }
  updateVerticesData(e, t, i, s) {
    return this;
  }
  setIndices(e, t) {
    return this;
  }
  isVerticesDataPresent(e) {
    return !1;
  }
  getBoundingInfo() {
    return this._masterMesh ? this._masterMesh.getBoundingInfo() : (this._boundingInfoIsDirty && (this._boundingInfoIsDirty = !1, this._updateBoundingInfo()), this._boundingInfo);
  }
  setBoundingInfo(e) {
    return this._boundingInfo = e, this;
  }
  get hasBoundingInfo() {
    return this._boundingInfo !== null;
  }
  buildBoundingInfo(e, t, i) {
    return this._boundingInfo = new ft(e, t, i), this._boundingInfo;
  }
  normalizeToUnitCube(e = !0, t = !1, i) {
    return super.normalizeToUnitCube(e, t, i);
  }
  get useBones() {
    return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(p.MatricesIndicesKind) && this.isVerticesDataPresent(p.MatricesWeightsKind);
  }
  _preActivate() {
  }
  _preActivateForIntermediateRendering(e) {
  }
  _activate(e, t) {
    return this._renderId = e, !0;
  }
  _postActivate() {
  }
  _freeze() {
  }
  _unFreeze() {
  }
  getWorldMatrix() {
    return this._masterMesh && this.billboardMode === $.BILLBOARDMODE_NONE ? this._masterMesh.getWorldMatrix() : super.getWorldMatrix();
  }
  _getWorldMatrixDeterminant() {
    return this._masterMesh ? this._masterMesh._getWorldMatrixDeterminant() : super._getWorldMatrixDeterminant();
  }
  get isAnInstance() {
    return !1;
  }
  get hasInstances() {
    return !1;
  }
  get hasThinInstances() {
    return !1;
  }
  movePOV(e, t, i) {
    return this.position.addInPlace(this.calcMovePOV(e, t, i)), this;
  }
  calcMovePOV(e, t, i) {
    const s = new x();
    (this.rotationQuaternion ? this.rotationQuaternion : z.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z)).toRotationMatrix(s);
    const n = g.Zero(), a = this.definedFacingForward ? -1 : 1;
    return g.TransformCoordinatesFromFloatsToRef(e * a, t, i * a, s, n), n;
  }
  rotatePOV(e, t, i) {
    return this.rotation.addInPlace(this.calcRotatePOV(e, t, i)), this;
  }
  calcRotatePOV(e, t, i) {
    const s = this.definedFacingForward ? 1 : -1;
    return new g(e * s, t, i * s);
  }
  refreshBoundingInfo(e = !1, t = !1) {
    return this._boundingInfo && this._boundingInfo.isLocked ? this : (this._refreshBoundingInfo(this._getPositionData(e, t), null), this);
  }
  _refreshBoundingInfo(e, t) {
    if (e) {
      const i = Cr(e, 0, this.getTotalVertices(), t);
      this._boundingInfo ? this._boundingInfo.reConstruct(i.minimum, i.maximum) : this._boundingInfo = new ft(i.minimum, i.maximum);
    }
    if (this.subMeshes)
      for (let i = 0; i < this.subMeshes.length; i++)
        this.subMeshes[i].refreshBoundingInfo(e);
    this._updateBoundingInfo();
  }
  _getData(e = !1, t = !1, i, s = p.PositionKind) {
    if (i = i != null ? i : this.getVerticesData(s).slice(), i && t && this.morphTargetManager) {
      let r = 0, n = 0;
      for (let a = 0; a < i.length; a++) {
        for (let o = 0; o < this.morphTargetManager.numTargets; o++) {
          const h = this.morphTargetManager.getTarget(o), l = h.influence;
          if (l > 0) {
            const u = h.getPositions();
            u && (i[a] += (u[a] - i[a]) * l);
          }
        }
        if (r++, s === p.PositionKind && this._positions && r === 3) {
          r = 0;
          const o = n * 3;
          this._positions[n++].copyFromFloats(i[o], i[o + 1], i[o + 2]);
        }
      }
    }
    if (i && e && this.skeleton) {
      const r = this.getVerticesData(p.MatricesIndicesKind), n = this.getVerticesData(p.MatricesWeightsKind);
      if (n && r) {
        const a = this.numBoneInfluencers > 4, o = a ? this.getVerticesData(p.MatricesIndicesExtraKind) : null, h = a ? this.getVerticesData(p.MatricesWeightsExtraKind) : null, l = this.skeleton.getTransformMatrices(this), u = D.Vector3[0], f = D.Matrix[0], d = D.Matrix[1];
        let _ = 0;
        for (let E = 0; E < i.length; E += 3, _ += 4) {
          f.reset();
          let m, T;
          for (m = 0; m < 4; m++)
            T = n[_ + m], T > 0 && (x.FromFloat32ArrayToRefScaled(l, Math.floor(r[_ + m] * 16), T, d), f.addToSelf(d));
          if (a)
            for (m = 0; m < 4; m++)
              T = h[_ + m], T > 0 && (x.FromFloat32ArrayToRefScaled(l, Math.floor(o[_ + m] * 16), T, d), f.addToSelf(d));
          s === p.NormalKind ? g.TransformNormalFromFloatsToRef(i[E], i[E + 1], i[E + 2], f, u) : g.TransformCoordinatesFromFloatsToRef(i[E], i[E + 1], i[E + 2], f, u), u.toArray(i, E), s === p.PositionKind && this._positions && this._positions[E / 3].copyFrom(u);
        }
      }
    }
    return i;
  }
  getNormalsData(e = !1, t = !1) {
    return this._getData(e, t, null, p.NormalKind);
  }
  getPositionData(e = !1, t = !1, i) {
    return this._getData(e, t, i, p.PositionKind);
  }
  _getPositionData(e, t) {
    var s;
    let i = this.getVerticesData(p.PositionKind);
    if (this._internalAbstractMeshDataInfo._positions && (this._internalAbstractMeshDataInfo._positions = null), i && (e && this.skeleton || t && this.morphTargetManager)) {
      if (i = i.slice(), this._generatePointsArray(), this._positions) {
        const r = this._positions;
        this._internalAbstractMeshDataInfo._positions = new Array(r.length);
        for (let n = 0; n < r.length; n++)
          this._internalAbstractMeshDataInfo._positions[n] = ((s = r[n]) == null ? void 0 : s.clone()) || new g();
      }
      return this.getPositionData(e, t, i);
    }
    return i;
  }
  _updateBoundingInfo() {
    return this._boundingInfo ? this._boundingInfo.update(this.worldMatrixFromCache) : this._boundingInfo = new ft(g.Zero(), g.Zero(), this.worldMatrixFromCache), this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache), this;
  }
  _updateSubMeshesBoundingInfo(e) {
    if (!this.subMeshes)
      return this;
    const t = this.subMeshes.length;
    for (let i = 0; i < t; i++) {
      const s = this.subMeshes[i];
      (t > 1 || !s.IsGlobal) && s.updateBoundingInfo(e);
    }
    return this;
  }
  _afterComputeWorldMatrix() {
    this.doNotSyncBoundingInfo || (this._boundingInfoIsDirty = !0);
  }
  isInFrustum(e) {
    return this.getBoundingInfo().isInFrustum(e, this.cullingStrategy);
  }
  isCompletelyInFrustum(e) {
    return this.getBoundingInfo().isCompletelyInFrustum(e);
  }
  intersectsMesh(e, t = !1, i) {
    const s = this.getBoundingInfo(), r = e.getBoundingInfo();
    if (s.intersects(r, t))
      return !0;
    if (i) {
      for (const n of this.getChildMeshes())
        if (n.intersectsMesh(e, t, !0))
          return !0;
    }
    return !1;
  }
  intersectsPoint(e) {
    return this.getBoundingInfo().intersectsPoint(e);
  }
  get checkCollisions() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;
  }
  set checkCollisions(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = e;
  }
  get collider() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collider;
  }
  moveWithCollisions(e) {
    this.getAbsolutePosition().addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);
    const i = this.getScene().collisionCoordinator;
    return this._internalAbstractMeshDataInfo._meshCollisionData._collider || (this._internalAbstractMeshDataInfo._meshCollisionData._collider = i.createCollider()), this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid, i.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, e, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId), this;
  }
  _collideForSubMesh(e, t, i) {
    var s;
    if (this._generatePointsArray(), !this._positions)
      return this;
    if (!e._lastColliderWorldVertices || !e._lastColliderTransformMatrix.equals(t)) {
      e._lastColliderTransformMatrix = t.clone(), e._lastColliderWorldVertices = [], e._trianglePlanes = [];
      const r = e.verticesStart, n = e.verticesStart + e.verticesCount;
      for (let a = r; a < n; a++)
        e._lastColliderWorldVertices.push(g.TransformCoordinates(this._positions[a], t));
    }
    return i._collide(e._trianglePlanes, e._lastColliderWorldVertices, this.getIndices(), e.indexStart, e.indexStart + e.indexCount, e.verticesStart, !!e.getMaterial(), this, this._shouldConvertRHS(), ((s = e.getMaterial()) == null ? void 0 : s.fillMode) === 7), this;
  }
  _processCollisionsForSubMeshes(e, t) {
    const i = this._scene.getCollidingSubMeshCandidates(this, e), s = i.length;
    for (let r = 0; r < s; r++) {
      const n = i.data[r];
      s > 1 && !n._checkCollision(e) || this._collideForSubMesh(n, t, e);
    }
    return this;
  }
  _shouldConvertRHS() {
    return !1;
  }
  _checkCollision(e) {
    if (!this.getBoundingInfo()._checkCollision(e))
      return this;
    const t = D.Matrix[0], i = D.Matrix[1];
    return x.ScalingToRef(1 / e._radius.x, 1 / e._radius.y, 1 / e._radius.z, t), this.worldMatrixFromCache.multiplyToRef(t, i), this._processCollisionsForSubMeshes(e, i), this;
  }
  _generatePointsArray() {
    return !1;
  }
  intersects(e, t, i, s = !1, r, n = !1) {
    const a = new vt(), o = this.getClassName() === "InstancedLinesMesh" || this.getClassName() === "LinesMesh" ? this.intersectionThreshold : 0, h = this.getBoundingInfo();
    if (!this.subMeshes || !n && (!e.intersectsSphere(h.boundingSphere, o) || !e.intersectsBox(h.boundingBox, o)))
      return a;
    if (s)
      return a.hit = !n, a.pickedMesh = n ? null : this, a.distance = n ? 0 : g.Distance(e.origin, h.boundingSphere.center), a.subMeshId = 0, a;
    if (!this._generatePointsArray())
      return a;
    let l = null;
    const u = this._scene.getIntersectingSubMeshCandidates(this, e), f = u.length;
    let d = !1;
    for (let _ = 0; _ < f; _++) {
      const m = u.data[_].getMaterial();
      if (!!m && (m.fillMode == 7 || m.fillMode == 0 || m.fillMode == 1 || m.fillMode == 2 || m.fillMode == 4)) {
        d = !0;
        break;
      }
    }
    if (!d)
      return a.hit = !0, a.pickedMesh = this, a.distance = g.Distance(e.origin, h.boundingSphere.center), a.subMeshId = -1, a;
    for (let _ = 0; _ < f; _++) {
      const E = u.data[_];
      if (f > 1 && !E.canIntersects(e))
        continue;
      const m = E.intersects(e, this._positions, this.getIndices(), t, i);
      if (m && (t || !l || m.distance < l.distance) && (l = m, l.subMeshId = _, t))
        break;
    }
    if (l) {
      const _ = r != null ? r : this.getWorldMatrix(), E = D.Vector3[0], m = D.Vector3[1];
      g.TransformCoordinatesToRef(e.origin, _, E), e.direction.scaleToRef(l.distance, m);
      const b = g.TransformNormal(m, _).addInPlace(E);
      return a.hit = !0, a.distance = g.Distance(E, b), a.pickedPoint = b, a.pickedMesh = this, a.bu = l.bu || 0, a.bv = l.bv || 0, a.subMeshFaceId = l.faceId, a.faceId = l.faceId + u.data[l.subMeshId].indexStart / (this.getClassName().indexOf("LinesMesh") !== -1 ? 2 : 3), a.subMeshId = l.subMeshId, a;
    }
    return a;
  }
  clone(e, t, i) {
    return null;
  }
  releaseSubMeshes() {
    if (this.subMeshes)
      for (; this.subMeshes.length; )
        this.subMeshes[0].dispose();
    else
      this.subMeshes = new Array();
    return this;
  }
  dispose(e, t = !1) {
    let i;
    for (this._scene.useMaterialMeshMap && this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap && (this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0), this.getScene().freeActiveMeshes(), this.getScene().freeRenderingGroups(), this.actionManager !== void 0 && this.actionManager !== null && (this.actionManager.dispose(), this.actionManager = null), this._internalAbstractMeshDataInfo._skeleton = null, this._transformMatrixTexture && (this._transformMatrixTexture.dispose(), this._transformMatrixTexture = null), i = 0; i < this._intersectionsInProgress.length; i++) {
      const n = this._intersectionsInProgress[i], a = n._intersectionsInProgress.indexOf(this);
      n._intersectionsInProgress.splice(a, 1);
    }
    this._intersectionsInProgress.length = 0, this.getScene().lights.forEach((n) => {
      let a = n.includedOnlyMeshes.indexOf(this);
      a !== -1 && n.includedOnlyMeshes.splice(a, 1), a = n.excludedMeshes.indexOf(this), a !== -1 && n.excludedMeshes.splice(a, 1);
      const o = n.getShadowGenerator();
      if (o) {
        const h = o.getShadowMap();
        h && h.renderList && (a = h.renderList.indexOf(this), a !== -1 && h.renderList.splice(a, 1));
      }
    }), (this.getClassName() !== "InstancedMesh" || this.getClassName() !== "InstancedLinesMesh") && this.releaseSubMeshes();
    const r = this.getScene().getEngine();
    if (this._occlusionQuery !== null && (this.isOcclusionQueryInProgress = !1, r.deleteQuery(this._occlusionQuery), this._occlusionQuery = null), r.wipeCaches(), this.getScene().removeMesh(this), this._parentContainer) {
      const n = this._parentContainer.meshes.indexOf(this);
      n > -1 && this._parentContainer.meshes.splice(n, 1), this._parentContainer = null;
    }
    if (t && this.material && (this.material.getClassName() === "MultiMaterial" ? this.material.dispose(!1, !0, !0) : this.material.dispose(!1, !0)), !e)
      for (i = 0; i < this.getScene().particleSystems.length; i++)
        this.getScene().particleSystems[i].emitter === this && (this.getScene().particleSystems[i].dispose(), i--);
    this._internalAbstractMeshDataInfo._facetData.facetDataEnabled && this.disableFacetData(), this._uniformBuffer.dispose(), this.onAfterWorldMatrixUpdateObservable.clear(), this.onCollideObservable.clear(), this.onCollisionPositionChangeObservable.clear(), this.onRebuildObservable.clear(), super.dispose(e, t);
  }
  addChild(e, t = !1) {
    return e.setParent(this, t), this;
  }
  removeChild(e, t = !1) {
    return e.setParent(null, t), this;
  }
  _initFacetData() {
    const e = this._internalAbstractMeshDataInfo._facetData;
    e.facetNormals || (e.facetNormals = new Array()), e.facetPositions || (e.facetPositions = new Array()), e.facetPartitioning || (e.facetPartitioning = new Array()), e.facetNb = this.getIndices().length / 3 | 0, e.partitioningSubdivisions = e.partitioningSubdivisions ? e.partitioningSubdivisions : 10, e.partitioningBBoxRatio = e.partitioningBBoxRatio ? e.partitioningBBoxRatio : 1.01;
    for (let t = 0; t < e.facetNb; t++)
      e.facetNormals[t] = g.Zero(), e.facetPositions[t] = g.Zero();
    return e.facetDataEnabled = !0, this;
  }
  updateFacetData() {
    const e = this._internalAbstractMeshDataInfo._facetData;
    e.facetDataEnabled || this._initFacetData();
    const t = this.getVerticesData(p.PositionKind), i = this.getIndices(), s = this.getVerticesData(p.NormalKind), r = this.getBoundingInfo();
    if (e.facetDepthSort && !e.facetDepthSortEnabled) {
      if (e.facetDepthSortEnabled = !0, i instanceof Uint16Array)
        e.depthSortedIndices = new Uint16Array(i);
      else if (i instanceof Uint32Array)
        e.depthSortedIndices = new Uint32Array(i);
      else {
        let a = !1;
        for (let o = 0; o < i.length; o++)
          if (i[o] > 65535) {
            a = !0;
            break;
          }
        a ? e.depthSortedIndices = new Uint32Array(i) : e.depthSortedIndices = new Uint16Array(i);
      }
      if (e.facetDepthSortFunction = function(a, o) {
        return o.sqDistance - a.sqDistance;
      }, !e.facetDepthSortFrom) {
        const a = this.getScene().activeCamera;
        e.facetDepthSortFrom = a ? a.position : g.Zero();
      }
      e.depthSortedFacets = [];
      for (let a = 0; a < e.facetNb; a++) {
        const o = { ind: a * 3, sqDistance: 0 };
        e.depthSortedFacets.push(o);
      }
      e.invertedMatrix = x.Identity(), e.facetDepthSortOrigin = g.Zero();
    }
    e.bbSize.x = r.maximum.x - r.minimum.x > Re ? r.maximum.x - r.minimum.x : Re, e.bbSize.y = r.maximum.y - r.minimum.y > Re ? r.maximum.y - r.minimum.y : Re, e.bbSize.z = r.maximum.z - r.minimum.z > Re ? r.maximum.z - r.minimum.z : Re;
    let n = e.bbSize.x > e.bbSize.y ? e.bbSize.x : e.bbSize.y;
    if (n = n > e.bbSize.z ? n : e.bbSize.z, e.subDiv.max = e.partitioningSubdivisions, e.subDiv.X = Math.floor(e.subDiv.max * e.bbSize.x / n), e.subDiv.Y = Math.floor(e.subDiv.max * e.bbSize.y / n), e.subDiv.Z = Math.floor(e.subDiv.max * e.bbSize.z / n), e.subDiv.X = e.subDiv.X < 1 ? 1 : e.subDiv.X, e.subDiv.Y = e.subDiv.Y < 1 ? 1 : e.subDiv.Y, e.subDiv.Z = e.subDiv.Z < 1 ? 1 : e.subDiv.Z, e.facetParameters.facetNormals = this.getFacetLocalNormals(), e.facetParameters.facetPositions = this.getFacetLocalPositions(), e.facetParameters.facetPartitioning = this.getFacetLocalPartitioning(), e.facetParameters.bInfo = r, e.facetParameters.bbSize = e.bbSize, e.facetParameters.subDiv = e.subDiv, e.facetParameters.ratio = this.partitioningBBoxRatio, e.facetParameters.depthSort = e.facetDepthSort, e.facetDepthSort && e.facetDepthSortEnabled && (this.computeWorldMatrix(!0), this._worldMatrix.invertToRef(e.invertedMatrix), g.TransformCoordinatesToRef(e.facetDepthSortFrom, e.invertedMatrix, e.facetDepthSortOrigin), e.facetParameters.distanceTo = e.facetDepthSortOrigin), e.facetParameters.depthSortedFacets = e.depthSortedFacets, s && Z.ComputeNormals(t, i, s, e.facetParameters), e.facetDepthSort && e.facetDepthSortEnabled) {
      e.depthSortedFacets.sort(e.facetDepthSortFunction);
      const a = e.depthSortedIndices.length / 3 | 0;
      for (let o = 0; o < a; o++) {
        const h = e.depthSortedFacets[o].ind;
        e.depthSortedIndices[o * 3] = i[h], e.depthSortedIndices[o * 3 + 1] = i[h + 1], e.depthSortedIndices[o * 3 + 2] = i[h + 2];
      }
      this.updateIndices(e.depthSortedIndices, void 0, !0);
    }
    return this;
  }
  getFacetLocalNormals() {
    const e = this._internalAbstractMeshDataInfo._facetData;
    return e.facetNormals || this.updateFacetData(), e.facetNormals;
  }
  getFacetLocalPositions() {
    const e = this._internalAbstractMeshDataInfo._facetData;
    return e.facetPositions || this.updateFacetData(), e.facetPositions;
  }
  getFacetLocalPartitioning() {
    const e = this._internalAbstractMeshDataInfo._facetData;
    return e.facetPartitioning || this.updateFacetData(), e.facetPartitioning;
  }
  getFacetPosition(e) {
    const t = g.Zero();
    return this.getFacetPositionToRef(e, t), t;
  }
  getFacetPositionToRef(e, t) {
    const i = this.getFacetLocalPositions()[e], s = this.getWorldMatrix();
    return g.TransformCoordinatesToRef(i, s, t), this;
  }
  getFacetNormal(e) {
    const t = g.Zero();
    return this.getFacetNormalToRef(e, t), t;
  }
  getFacetNormalToRef(e, t) {
    const i = this.getFacetLocalNormals()[e];
    return g.TransformNormalToRef(i, this.getWorldMatrix(), t), this;
  }
  getFacetsAtLocalCoordinates(e, t, i) {
    const s = this.getBoundingInfo(), r = this._internalAbstractMeshDataInfo._facetData, n = Math.floor((e - s.minimum.x * r.partitioningBBoxRatio) * r.subDiv.X * r.partitioningBBoxRatio / r.bbSize.x), a = Math.floor((t - s.minimum.y * r.partitioningBBoxRatio) * r.subDiv.Y * r.partitioningBBoxRatio / r.bbSize.y), o = Math.floor((i - s.minimum.z * r.partitioningBBoxRatio) * r.subDiv.Z * r.partitioningBBoxRatio / r.bbSize.z);
    return n < 0 || n > r.subDiv.max || a < 0 || a > r.subDiv.max || o < 0 || o > r.subDiv.max ? null : r.facetPartitioning[n + r.subDiv.max * a + r.subDiv.max * r.subDiv.max * o];
  }
  getClosestFacetAtCoordinates(e, t, i, s, r = !1, n = !0) {
    const a = this.getWorldMatrix(), o = D.Matrix[5];
    a.invertToRef(o);
    const h = D.Vector3[8];
    g.TransformCoordinatesFromFloatsToRef(e, t, i, o, h);
    const l = this.getClosestFacetAtLocalCoordinates(h.x, h.y, h.z, s, r, n);
    return s && g.TransformCoordinatesFromFloatsToRef(s.x, s.y, s.z, a, s), l;
  }
  getClosestFacetAtLocalCoordinates(e, t, i, s, r = !1, n = !0) {
    let a = null, o = 0, h = 0, l = 0, u = 0, f = 0, d = 0, _ = 0, E = 0;
    const m = this.getFacetLocalPositions(), T = this.getFacetLocalNormals(), b = this.getFacetsAtLocalCoordinates(e, t, i);
    if (!b)
      return null;
    let R = Number.MAX_VALUE, y = R, P, v, A;
    for (let L = 0; L < b.length; L++)
      P = b[L], v = T[P], A = m[P], u = (e - A.x) * v.x + (t - A.y) * v.y + (i - A.z) * v.z, (!r || r && n && u >= 0 || r && !n && u <= 0) && (u = v.x * A.x + v.y * A.y + v.z * A.z, f = -(v.x * e + v.y * t + v.z * i - u) / (v.x * v.x + v.y * v.y + v.z * v.z), d = e + v.x * f, _ = t + v.y * f, E = i + v.z * f, o = d - e, h = _ - t, l = E - i, y = o * o + h * h + l * l, y < R && (R = y, a = P, s && (s.x = d, s.y = _, s.z = E)));
    return a;
  }
  getFacetDataParameters() {
    return this._internalAbstractMeshDataInfo._facetData.facetParameters;
  }
  disableFacetData() {
    const e = this._internalAbstractMeshDataInfo._facetData;
    return e.facetDataEnabled && (e.facetDataEnabled = !1, e.facetPositions = new Array(), e.facetNormals = new Array(), e.facetPartitioning = new Array(), e.facetParameters = null, e.depthSortedIndices = new Uint32Array(0)), this;
  }
  updateIndices(e, t, i = !1) {
    return this;
  }
  createNormals(e) {
    const t = this.getVerticesData(p.PositionKind), i = this.getIndices();
    let s;
    return this.isVerticesDataPresent(p.NormalKind) ? s = this.getVerticesData(p.NormalKind) : s = [], Z.ComputeNormals(t, i, s, { useRightHandedSystem: this.getScene().useRightHandedSystem }), this.setVerticesData(p.NormalKind, s, e), this;
  }
  alignWithNormal(e, t) {
    t || (t = hi.Y);
    const i = D.Vector3[0], s = D.Vector3[1];
    return g.CrossToRef(t, e, s), g.CrossToRef(e, s, i), this.rotationQuaternion ? z.RotationQuaternionFromAxisToRef(i, e, s, this.rotationQuaternion) : g.RotationFromAxisToRef(i, e, s, this.rotation), this;
  }
  _checkOcclusionQuery() {
    return !1;
  }
  disableEdgesRendering() {
    throw q("EdgesRenderer");
  }
  enableEdgesRendering(e, t, i) {
    throw q("EdgesRenderer");
  }
  getConnectedParticleSystems() {
    return this._scene.particleSystems.filter((e) => e.emitter === this);
  }
}
at.OCCLUSION_TYPE_NONE = 0;
at.OCCLUSION_TYPE_OPTIMISTIC = 1;
at.OCCLUSION_TYPE_STRICT = 2;
at.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;
at.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;
at.CULLINGSTRATEGY_STANDARD = 0;
at.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
at.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
at.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
it("BABYLON.AbstractMesh", at);
class ts {
  constructor(e, t, i, s) {
    this.x = e, this.y = t, this.width = i, this.height = s;
  }
  toGlobal(e, t) {
    return new ts(this.x * e, this.y * t, this.width * e, this.height * t);
  }
  toGlobalToRef(e, t, i) {
    return i.x = this.x * e, i.y = this.y * t, i.width = this.width * e, i.height = this.height * t, this;
  }
  clone() {
    return new ts(this.x, this.y, this.width, this.height);
  }
}
class Y extends Xe {
  constructor(e, t, i, s = !0) {
    super(e, i), this._position = g.Zero(), this._upVector = g.Up(), this._orthoLeft = null, this._orthoRight = null, this._orthoBottom = null, this._orthoTop = null, this.fov = 0.8, this.projectionPlaneTilt = 0, this.minZ = 1, this.maxZ = 1e4, this.inertia = 0.9, this._mode = Y.PERSPECTIVE_CAMERA, this.isIntermediate = !1, this.viewport = new ts(0, 0, 1, 1), this.layerMask = 268435455, this.fovMode = Y.FOVMODE_VERTICAL_FIXED, this.cameraRigMode = Y.RIG_MODE_NONE, this.customRenderTargets = new Array(), this.outputRenderTarget = null, this.onViewMatrixChangedObservable = new F(), this.onProjectionMatrixChangedObservable = new F(), this.onAfterCheckInputsObservable = new F(), this.onRestoreStateObservable = new F(), this.isRigCamera = !1, this._rigCameras = new Array(), this._webvrViewMatrix = x.Identity(), this._skipRendering = !1, this._projectionMatrix = new x(), this._postProcesses = new Array(), this._activeMeshes = new Qe(256), this._globalPosition = g.Zero(), this._computedViewMatrix = x.Identity(), this._doNotComputeProjectionMatrix = !1, this._transformMatrix = x.Zero(), this._refreshFrustumPlanes = !0, this._absoluteRotation = z.Identity(), this._isCamera = !0, this._isLeftCamera = !1, this._isRightCamera = !1, this.getScene().addCamera(this), s && !this.getScene().activeCamera && (this.getScene().activeCamera = this), this.position = t, this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${e}`);
  }
  get position() {
    return this._position;
  }
  set position(e) {
    this._position = e;
  }
  set upVector(e) {
    this._upVector = e;
  }
  get upVector() {
    return this._upVector;
  }
  get screenArea() {
    var i, s, r, n;
    let e = 0, t = 0;
    if (this.mode === Y.PERSPECTIVE_CAMERA)
      this.fovMode === Y.FOVMODE_VERTICAL_FIXED ? (t = this.minZ * 2 * Math.tan(this.fov / 2), e = this.getEngine().getAspectRatio(this) * t) : (e = this.minZ * 2 * Math.tan(this.fov / 2), t = e / this.getEngine().getAspectRatio(this));
    else {
      const a = this.getEngine().getRenderWidth() / 2, o = this.getEngine().getRenderHeight() / 2;
      e = ((i = this.orthoRight) != null ? i : a) - ((s = this.orthoLeft) != null ? s : -a), t = ((r = this.orthoTop) != null ? r : o) - ((n = this.orthoBottom) != null ? n : -o);
    }
    return e * t;
  }
  set orthoLeft(e) {
    this._orthoLeft = e;
    for (const t of this._rigCameras)
      t.orthoLeft = e;
  }
  get orthoLeft() {
    return this._orthoLeft;
  }
  set orthoRight(e) {
    this._orthoRight = e;
    for (const t of this._rigCameras)
      t.orthoRight = e;
  }
  get orthoRight() {
    return this._orthoRight;
  }
  set orthoBottom(e) {
    this._orthoBottom = e;
    for (const t of this._rigCameras)
      t.orthoBottom = e;
  }
  get orthoBottom() {
    return this._orthoBottom;
  }
  set orthoTop(e) {
    this._orthoTop = e;
    for (const t of this._rigCameras)
      t.orthoTop = e;
  }
  get orthoTop() {
    return this._orthoTop;
  }
  set mode(e) {
    this._mode = e;
    for (const t of this._rigCameras)
      t.mode = e;
  }
  get mode() {
    return this._mode;
  }
  storeState() {
    return this._stateStored = !0, this._storedFov = this.fov, this;
  }
  _restoreStateValues() {
    return this._stateStored ? (this.fov = this._storedFov, !0) : !1;
  }
  restoreState() {
    return this._restoreStateValues() ? (this.onRestoreStateObservable.notifyObservers(this), !0) : !1;
  }
  getClassName() {
    return "Camera";
  }
  toString(e) {
    let t = "Name: " + this.name;
    if (t += ", type: " + this.getClassName(), this.animations)
      for (let i = 0; i < this.animations.length; i++)
        t += ", animation[0]: " + this.animations[i].toString(e);
    return t;
  }
  applyVerticalCorrection() {
    const e = this.absoluteRotation.toEulerAngles();
    this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -e.x : e.x;
  }
  get globalPosition() {
    return this._globalPosition;
  }
  getActiveMeshes() {
    return this._activeMeshes;
  }
  isActiveMesh(e) {
    return this._activeMeshes.indexOf(e) !== -1;
  }
  isReady(e = !1) {
    if (e) {
      for (const t of this._postProcesses)
        if (t && !t.isReady())
          return !1;
    }
    return super.isReady(e);
  }
  _initCache() {
    super._initCache(), this._cache.position = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.upVector = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.mode = void 0, this._cache.minZ = void 0, this._cache.maxZ = void 0, this._cache.fov = void 0, this._cache.fovMode = void 0, this._cache.aspectRatio = void 0, this._cache.orthoLeft = void 0, this._cache.orthoRight = void 0, this._cache.orthoBottom = void 0, this._cache.orthoTop = void 0, this._cache.renderWidth = void 0, this._cache.renderHeight = void 0;
  }
  _updateCache(e) {
    e || super._updateCache(), this._cache.position.copyFrom(this.position), this._cache.upVector.copyFrom(this.upVector);
  }
  _isSynchronized() {
    return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
  }
  _isSynchronizedViewMatrix() {
    return super._isSynchronized() ? this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent() : !1;
  }
  _isSynchronizedProjectionMatrix() {
    let e = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
    if (!e)
      return !1;
    const t = this.getEngine();
    return this.mode === Y.PERSPECTIVE_CAMERA ? e = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === t.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt : e = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === t.getRenderWidth() && this._cache.renderHeight === t.getRenderHeight(), e;
  }
  attachControl(e, t) {
  }
  detachControl(e) {
  }
  update() {
    this._checkInputs(), this.cameraRigMode !== Y.RIG_MODE_NONE && this._updateRigCameras();
  }
  _checkInputs() {
    this.onAfterCheckInputsObservable.notifyObservers(this);
  }
  get rigCameras() {
    return this._rigCameras;
  }
  get rigPostProcess() {
    return this._rigPostProcess;
  }
  _getFirstPostProcess() {
    for (let e = 0; e < this._postProcesses.length; e++)
      if (this._postProcesses[e] !== null)
        return this._postProcesses[e];
    return null;
  }
  _cascadePostProcessesToRigCams() {
    const e = this._getFirstPostProcess();
    e && e.markTextureDirty();
    for (let t = 0, i = this._rigCameras.length; t < i; t++) {
      const s = this._rigCameras[t], r = s._rigPostProcess;
      r ? (r.getEffectName() === "pass" && (s.isIntermediate = this._postProcesses.length === 0), s._postProcesses = this._postProcesses.slice(0).concat(r), r.markTextureDirty()) : s._postProcesses = this._postProcesses.slice(0);
    }
  }
  attachPostProcess(e, t = null) {
    return !e.isReusable() && this._postProcesses.indexOf(e) > -1 ? (w.Error("You're trying to reuse a post process not defined as reusable."), 0) : (t == null || t < 0 ? this._postProcesses.push(e) : this._postProcesses[t] === null ? this._postProcesses[t] = e : this._postProcesses.splice(t, 0, e), this._cascadePostProcessesToRigCams(), this._scene.prePassRenderer && this._scene.prePassRenderer.markAsDirty(), this._postProcesses.indexOf(e));
  }
  detachPostProcess(e) {
    const t = this._postProcesses.indexOf(e);
    t !== -1 && (this._postProcesses[t] = null), this._scene.prePassRenderer && this._scene.prePassRenderer.markAsDirty(), this._cascadePostProcessesToRigCams();
  }
  getWorldMatrix() {
    return this._isSynchronizedViewMatrix() ? this._worldMatrix : (this.getViewMatrix(), this._worldMatrix);
  }
  _getViewMatrix() {
    return x.Identity();
  }
  getViewMatrix(e) {
    return !e && this._isSynchronizedViewMatrix() ? this._computedViewMatrix : (this.updateCache(), this._computedViewMatrix = this._getViewMatrix(), this._currentRenderId = this.getScene().getRenderId(), this._childUpdateId++, this._refreshFrustumPlanes = !0, this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix && this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix), this.parent && this.parent.onViewMatrixChangedObservable && this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent), this.onViewMatrixChangedObservable.notifyObservers(this), this._computedViewMatrix.invertToRef(this._worldMatrix), this._computedViewMatrix);
  }
  freezeProjectionMatrix(e) {
    this._doNotComputeProjectionMatrix = !0, e !== void 0 && (this._projectionMatrix = e);
  }
  unfreezeProjectionMatrix() {
    this._doNotComputeProjectionMatrix = !1;
  }
  getProjectionMatrix(e) {
    var s, r, n, a, o, h, l, u;
    if (this._doNotComputeProjectionMatrix || !e && this._isSynchronizedProjectionMatrix())
      return this._projectionMatrix;
    this._cache.mode = this.mode, this._cache.minZ = this.minZ, this._cache.maxZ = this.maxZ, this._refreshFrustumPlanes = !0;
    const t = this.getEngine(), i = this.getScene();
    if (this.mode === Y.PERSPECTIVE_CAMERA) {
      this._cache.fov = this.fov, this._cache.fovMode = this.fovMode, this._cache.aspectRatio = t.getAspectRatio(this), this._cache.projectionPlaneTilt = this.projectionPlaneTilt, this.minZ <= 0 && (this.minZ = 0.1);
      const f = t.useReverseDepthBuffer;
      let d;
      i.useRightHandedSystem ? d = x.PerspectiveFovRHToRef : d = x.PerspectiveFovLHToRef, d(this.fov, t.getAspectRatio(this), f ? this.maxZ : this.minZ, f ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === Y.FOVMODE_VERTICAL_FIXED, t.isNDCHalfZRange, this.projectionPlaneTilt, t.useReverseDepthBuffer);
    } else {
      const f = t.getRenderWidth() / 2, d = t.getRenderHeight() / 2;
      i.useRightHandedSystem ? x.OrthoOffCenterRHToRef((s = this.orthoLeft) != null ? s : -f, (r = this.orthoRight) != null ? r : f, (n = this.orthoBottom) != null ? n : -d, (a = this.orthoTop) != null ? a : d, this.minZ, this.maxZ, this._projectionMatrix, t.isNDCHalfZRange) : x.OrthoOffCenterLHToRef((o = this.orthoLeft) != null ? o : -f, (h = this.orthoRight) != null ? h : f, (l = this.orthoBottom) != null ? l : -d, (u = this.orthoTop) != null ? u : d, this.minZ, this.maxZ, this._projectionMatrix, t.isNDCHalfZRange), this._cache.orthoLeft = this.orthoLeft, this._cache.orthoRight = this.orthoRight, this._cache.orthoBottom = this.orthoBottom, this._cache.orthoTop = this.orthoTop, this._cache.renderWidth = t.getRenderWidth(), this._cache.renderHeight = t.getRenderHeight();
    }
    return this.onProjectionMatrixChangedObservable.notifyObservers(this), this._projectionMatrix;
  }
  getTransformationMatrix() {
    return this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._transformMatrix;
  }
  _updateFrustumPlanes() {
    !this._refreshFrustumPlanes || (this.getTransformationMatrix(), this._frustumPlanes ? pt.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = pt.GetPlanes(this._transformMatrix), this._refreshFrustumPlanes = !1);
  }
  isInFrustum(e, t = !1) {
    if (this._updateFrustumPlanes(), t && this.rigCameras.length > 0) {
      let i = !1;
      return this.rigCameras.forEach((s) => {
        s._updateFrustumPlanes(), i = i || e.isInFrustum(s._frustumPlanes);
      }), i;
    } else
      return e.isInFrustum(this._frustumPlanes);
  }
  isCompletelyInFrustum(e) {
    return this._updateFrustumPlanes(), e.isCompletelyInFrustum(this._frustumPlanes);
  }
  getForwardRay(e = 100, t, i) {
    throw q("Ray");
  }
  getForwardRayToRef(e, t = 100, i, s) {
    throw q("Ray");
  }
  dispose(e, t = !1) {
    for (this.onViewMatrixChangedObservable.clear(), this.onProjectionMatrixChangedObservable.clear(), this.onAfterCheckInputsObservable.clear(), this.onRestoreStateObservable.clear(), this.inputs && this.inputs.clear(), this.getScene().stopAnimation(this), this.getScene().removeCamera(this); this._rigCameras.length > 0; ) {
      const s = this._rigCameras.pop();
      s && s.dispose();
    }
    if (this._parentContainer) {
      const s = this._parentContainer.cameras.indexOf(this);
      s > -1 && this._parentContainer.cameras.splice(s, 1), this._parentContainer = null;
    }
    if (this._rigPostProcess)
      this._rigPostProcess.dispose(this), this._rigPostProcess = null, this._postProcesses.length = 0;
    else if (this.cameraRigMode !== Y.RIG_MODE_NONE)
      this._rigPostProcess = null, this._postProcesses.length = 0;
    else {
      let s = this._postProcesses.length;
      for (; --s >= 0; ) {
        const r = this._postProcesses[s];
        r && r.dispose(this);
      }
    }
    let i = this.customRenderTargets.length;
    for (; --i >= 0; )
      this.customRenderTargets[i].dispose();
    this.customRenderTargets.length = 0, this._activeMeshes.dispose(), this.getScene().getEngine().releaseRenderPassId(this.renderPassId), super.dispose(e, t);
  }
  get isLeftCamera() {
    return this._isLeftCamera;
  }
  get isRightCamera() {
    return this._isRightCamera;
  }
  get leftCamera() {
    return this._rigCameras.length < 1 ? null : this._rigCameras[0];
  }
  get rightCamera() {
    return this._rigCameras.length < 2 ? null : this._rigCameras[1];
  }
  getLeftTarget() {
    return this._rigCameras.length < 1 ? null : this._rigCameras[0].getTarget();
  }
  getRightTarget() {
    return this._rigCameras.length < 2 ? null : this._rigCameras[1].getTarget();
  }
  setCameraRigMode(e, t) {
    if (this.cameraRigMode !== e) {
      for (; this._rigCameras.length > 0; ) {
        const i = this._rigCameras.pop();
        i && i.dispose();
      }
      if (this.cameraRigMode = e, this._cameraRigParams = {}, this._cameraRigParams.interaxialDistance = t.interaxialDistance || 0.0637, this._cameraRigParams.stereoHalfAngle = U.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637), this.cameraRigMode !== Y.RIG_MODE_NONE) {
        const i = this.createRigCamera(this.name + "_L", 0);
        i && (i._isLeftCamera = !0);
        const s = this.createRigCamera(this.name + "_R", 1);
        s && (s._isRightCamera = !0), i && s && (this._rigCameras.push(i), this._rigCameras.push(s));
      }
      this._setRigMode(t), this._cascadePostProcessesToRigCams(), this.update();
    }
  }
  _setRigMode(e) {
  }
  _getVRProjectionMatrix() {
    return x.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, !0, this.getEngine().isNDCHalfZRange), this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix), this._projectionMatrix;
  }
  _updateCameraRotationMatrix() {
  }
  _updateWebVRCameraRotationMatrix() {
  }
  _getWebVRProjectionMatrix() {
    return x.Identity();
  }
  _getWebVRViewMatrix() {
    return x.Identity();
  }
  setCameraRigParameter(e, t) {
    this._cameraRigParams || (this._cameraRigParams = {}), this._cameraRigParams[e] = t, e === "interaxialDistance" && (this._cameraRigParams.stereoHalfAngle = U.ToRadians(t / 0.0637));
  }
  createRigCamera(e, t) {
    return null;
  }
  _updateRigCameras() {
    for (let e = 0; e < this._rigCameras.length; e++)
      this._rigCameras[e].minZ = this.minZ, this._rigCameras[e].maxZ = this.maxZ, this._rigCameras[e].fov = this.fov, this._rigCameras[e].upVector.copyFrom(this.upVector);
    this.cameraRigMode === Y.RIG_MODE_STEREOSCOPIC_ANAGLYPH && (this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport);
  }
  _setupInputs() {
  }
  serialize() {
    const e = ne.Serialize(this);
    return e.uniqueId = this.uniqueId, e.type = this.getClassName(), this.parent && this.parent._serializeAsParent(e), this.inputs && this.inputs.serialize(e), ne.AppendSerializedAnimations(this, e), e.ranges = this.serializeAnimationRanges(), e.isEnabled = this.isEnabled(), e;
  }
  clone(e, t = null) {
    const i = ne.Clone(Y.GetConstructorFromName(this.getClassName(), e, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
    return i.name = e, i.parent = t, this.onClonedObservable.notifyObservers(i), i;
  }
  getDirection(e) {
    const t = g.Zero();
    return this.getDirectionToRef(e, t), t;
  }
  get absoluteRotation() {
    return this.getWorldMatrix().decompose(void 0, this._absoluteRotation), this._absoluteRotation;
  }
  getDirectionToRef(e, t) {
    g.TransformNormalToRef(e, this.getWorldMatrix(), t);
  }
  static GetConstructorFromName(e, t, i, s = 0, r = !0) {
    const n = Xe.Construct(e, t, i, {
      interaxial_distance: s,
      isStereoscopicSideBySide: r
    });
    return n || (() => Y._CreateDefaultParsedCamera(t, i));
  }
  computeWorldMatrix() {
    return this.getWorldMatrix();
  }
  static Parse(e, t) {
    const i = e.type, s = Y.GetConstructorFromName(i, e.name, t, e.interaxial_distance, e.isStereoscopicSideBySide), r = ne.Parse(s, e, t);
    if (e.parentId !== void 0 && (r._waitingParentId = e.parentId), e.parentInstanceIndex !== void 0 && (r._waitingParentInstanceIndex = e.parentInstanceIndex), r.inputs && (r.inputs.parse(e), r._setupInputs()), e.upVector && (r.upVector = g.FromArray(e.upVector)), r.setPosition && (r.position.copyFromFloats(0, 0, 0), r.setPosition(g.FromArray(e.position))), e.target && r.setTarget && r.setTarget(g.FromArray(e.target)), e.cameraRigMode) {
      const n = e.interaxial_distance ? { interaxialDistance: e.interaxial_distance } : {};
      r.setCameraRigMode(e.cameraRigMode, n);
    }
    if (e.animations) {
      for (let n = 0; n < e.animations.length; n++) {
        const a = e.animations[n], o = oi("BABYLON.Animation");
        o && r.animations.push(o.Parse(a));
      }
      Xe.ParseAnimationRanges(r, e, t);
    }
    return e.autoAnimate && t.beginAnimation(r, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1), e.isEnabled !== void 0 && r.setEnabled(e.isEnabled), r;
  }
}
Y._CreateDefaultParsedCamera = (c, e) => {
  throw q("UniversalCamera");
};
Y.PERSPECTIVE_CAMERA = 0;
Y.ORTHOGRAPHIC_CAMERA = 1;
Y.FOVMODE_VERTICAL_FIXED = 0;
Y.FOVMODE_HORIZONTAL_FIXED = 1;
Y.RIG_MODE_NONE = 0;
Y.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
Y.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
Y.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
Y.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
Y.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
Y.RIG_MODE_VR = 20;
Y.RIG_MODE_WEBVR = 21;
Y.RIG_MODE_CUSTOM = 22;
Y.ForceAttachControlToAlwaysPreventDefault = !1;
S([
  Wt("position")
], Y.prototype, "_position", void 0);
S([
  Wt("upVector")
], Y.prototype, "_upVector", void 0);
S([
  M()
], Y.prototype, "orthoLeft", null);
S([
  M()
], Y.prototype, "orthoRight", null);
S([
  M()
], Y.prototype, "orthoBottom", null);
S([
  M()
], Y.prototype, "orthoTop", null);
S([
  M()
], Y.prototype, "fov", void 0);
S([
  M()
], Y.prototype, "projectionPlaneTilt", void 0);
S([
  M()
], Y.prototype, "minZ", void 0);
S([
  M()
], Y.prototype, "maxZ", void 0);
S([
  M()
], Y.prototype, "inertia", void 0);
S([
  M()
], Y.prototype, "mode", null);
S([
  M()
], Y.prototype, "layerMask", void 0);
S([
  M()
], Y.prototype, "fovMode", void 0);
S([
  M()
], Y.prototype, "cameraRigMode", void 0);
S([
  M()
], Y.prototype, "interaxialDistance", void 0);
S([
  M()
], Y.prototype, "isStereoscopicSideBySide", void 0);
class Dn {
  static BindClipPlane(e, t) {
    if (t.clipPlane) {
      const i = t.clipPlane;
      e.setFloat4("vClipPlane", i.normal.x, i.normal.y, i.normal.z, i.d);
    }
    if (t.clipPlane2) {
      const i = t.clipPlane2;
      e.setFloat4("vClipPlane2", i.normal.x, i.normal.y, i.normal.z, i.d);
    }
    if (t.clipPlane3) {
      const i = t.clipPlane3;
      e.setFloat4("vClipPlane3", i.normal.x, i.normal.y, i.normal.z, i.d);
    }
    if (t.clipPlane4) {
      const i = t.clipPlane4;
      e.setFloat4("vClipPlane4", i.normal.x, i.normal.y, i.normal.z, i.d);
    }
    if (t.clipPlane5) {
      const i = t.clipPlane5;
      e.setFloat4("vClipPlane5", i.normal.x, i.normal.y, i.normal.z, i.d);
    }
    if (t.clipPlane6) {
      const i = t.clipPlane6;
      e.setFloat4("vClipPlane6", i.normal.x, i.normal.y, i.normal.z, i.d);
    }
  }
}
class J {
  static BindSceneUniformBuffer(e, t) {
    t.bindToEffect(e, "Scene");
  }
  static PrepareDefinesForMergedUV(e, t, i) {
    t._needUVs = !0, t[i] = !0, e.getTextureMatrix().isIdentityAs3x2() ? (t[i + "DIRECTUV"] = e.coordinatesIndex + 1, t["MAINUV" + (e.coordinatesIndex + 1)] = !0) : t[i + "DIRECTUV"] = 0;
  }
  static BindTextureMatrix(e, t, i) {
    const s = e.getTextureMatrix();
    t.updateMatrix(i + "Matrix", s);
  }
  static GetFogState(e, t) {
    return t.fogEnabled && e.applyFog && t.fogMode !== re.FOGMODE_NONE;
  }
  static PrepareDefinesForMisc(e, t, i, s, r, n, a) {
    a._areMiscDirty && (a.LOGARITHMICDEPTH = i, a.POINTSIZE = s, a.FOG = r && this.GetFogState(e, t), a.NONUNIFORMSCALING = e.nonUniformScaling, a.ALPHATEST = n);
  }
  static PrepareDefinesForFrameBoundValues(e, t, i, s, r = null, n = !1) {
    let a = !1, o = !1, h = !1, l = !1, u = !1, f = !1, d = !1;
    o = r == null ? e.clipPlane !== void 0 && e.clipPlane !== null : r, h = r == null ? e.clipPlane2 !== void 0 && e.clipPlane2 !== null : r, l = r == null ? e.clipPlane3 !== void 0 && e.clipPlane3 !== null : r, u = r == null ? e.clipPlane4 !== void 0 && e.clipPlane4 !== null : r, f = r == null ? e.clipPlane5 !== void 0 && e.clipPlane5 !== null : r, d = r == null ? e.clipPlane6 !== void 0 && e.clipPlane6 !== null : r, i.CLIPPLANE !== o && (i.CLIPPLANE = o, a = !0), i.CLIPPLANE2 !== h && (i.CLIPPLANE2 = h, a = !0), i.CLIPPLANE3 !== l && (i.CLIPPLANE3 = l, a = !0), i.CLIPPLANE4 !== u && (i.CLIPPLANE4 = u, a = !0), i.CLIPPLANE5 !== f && (i.CLIPPLANE5 = f, a = !0), i.CLIPPLANE6 !== d && (i.CLIPPLANE6 = d, a = !0), i.DEPTHPREPASS !== !t.getColorWrite() && (i.DEPTHPREPASS = !i.DEPTHPREPASS, a = !0), i.INSTANCES !== s && (i.INSTANCES = s, a = !0), i.INSTANCESCOLOR && !i.INSTANCES && (i.INSTANCESCOLOR = !1, a = !0), i.THIN_INSTANCES !== n && (i.THIN_INSTANCES = n, a = !0), a && i.markAsUnprocessed();
  }
  static PrepareDefinesForBones(e, t) {
    if (e.useBones && e.computeBonesUsingShaders && e.skeleton) {
      t.NUM_BONE_INFLUENCERS = e.numBoneInfluencers;
      const i = t.BONETEXTURE !== void 0;
      if (e.skeleton.isUsingTextureForMatrices && i)
        t.BONETEXTURE = !0;
      else {
        t.BonesPerMesh = e.skeleton.bones.length + 1, t.BONETEXTURE = i ? !1 : void 0;
        const s = e.getScene().prePassRenderer;
        if (s && s.enabled) {
          const r = s.excludedSkinnedMesh.indexOf(e) === -1;
          t.BONES_VELOCITY_ENABLED = r;
        }
      }
    } else
      t.NUM_BONE_INFLUENCERS = 0, t.BonesPerMesh = 0;
  }
  static PrepareDefinesForMorphTargets(e, t) {
    const i = e.morphTargetManager;
    i ? (t.MORPHTARGETS_UV = i.supportsUVs && t.UV1, t.MORPHTARGETS_TANGENT = i.supportsTangents && t.TANGENT, t.MORPHTARGETS_NORMAL = i.supportsNormals && t.NORMAL, t.MORPHTARGETS = i.numInfluencers > 0, t.NUM_MORPH_INFLUENCERS = i.numInfluencers, t.MORPHTARGETS_TEXTURE = i.isUsingTextureForTargets) : (t.MORPHTARGETS_UV = !1, t.MORPHTARGETS_TANGENT = !1, t.MORPHTARGETS_NORMAL = !1, t.MORPHTARGETS = !1, t.NUM_MORPH_INFLUENCERS = 0);
  }
  static PrepareDefinesForBakedVertexAnimation(e, t) {
    const i = e.bakedVertexAnimationManager;
    t.BAKED_VERTEX_ANIMATION_TEXTURE = !!(i && i.isEnabled);
  }
  static PrepareDefinesForAttributes(e, t, i, s, r = !1, n = !0, a = !0) {
    if (!t._areAttributesDirty && t._needNormals === t._normals && t._needUVs === t._uvs)
      return !1;
    t._normals = t._needNormals, t._uvs = t._needUVs, t.NORMAL = t._needNormals && e.isVerticesDataPresent(p.NormalKind), t._needNormals && e.isVerticesDataPresent(p.TangentKind) && (t.TANGENT = !0);
    for (let o = 1; o <= 6; ++o)
      t["UV" + o] = t._needUVs ? e.isVerticesDataPresent(`uv${o === 1 ? "" : o}`) : !1;
    if (i) {
      const o = e.useVertexColors && e.isVerticesDataPresent(p.ColorKind);
      t.VERTEXCOLOR = o, t.VERTEXALPHA = e.hasVertexAlpha && o && n;
    }
    return e.isVerticesDataPresent(p.ColorInstanceKind) && (e.hasInstances || e.hasThinInstances) && (t.INSTANCESCOLOR = !0), s && this.PrepareDefinesForBones(e, t), r && this.PrepareDefinesForMorphTargets(e, t), a && this.PrepareDefinesForBakedVertexAnimation(e, t), !0;
  }
  static PrepareDefinesForMultiview(e, t) {
    if (e.activeCamera) {
      const i = t.MULTIVIEW;
      t.MULTIVIEW = e.activeCamera.outputRenderTarget !== null && e.activeCamera.outputRenderTarget.getViewCount() > 1, t.MULTIVIEW != i && t.markAsUnprocessed();
    }
  }
  static PrepareDefinesForOIT(e, t, i) {
    const s = t.ORDER_INDEPENDENT_TRANSPARENCY, r = t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;
    t.ORDER_INDEPENDENT_TRANSPARENCY = e.useOrderIndependentTransparency && i, t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !e.getEngine().getCaps().textureFloatLinearFiltering, (s !== t.ORDER_INDEPENDENT_TRANSPARENCY || r !== t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) && t.markAsUnprocessed();
  }
  static PrepareDefinesForPrePass(e, t, i) {
    const s = t.PREPASS;
    if (!t._arePrePassDirty)
      return;
    const r = [
      {
        type: 1,
        define: "PREPASS_POSITION",
        index: "PREPASS_POSITION_INDEX"
      },
      {
        type: 2,
        define: "PREPASS_VELOCITY",
        index: "PREPASS_VELOCITY_INDEX"
      },
      {
        type: 3,
        define: "PREPASS_REFLECTIVITY",
        index: "PREPASS_REFLECTIVITY_INDEX"
      },
      {
        type: 0,
        define: "PREPASS_IRRADIANCE",
        index: "PREPASS_IRRADIANCE_INDEX"
      },
      {
        type: 7,
        define: "PREPASS_ALBEDO_SQRT",
        index: "PREPASS_ALBEDO_SQRT_INDEX"
      },
      {
        type: 5,
        define: "PREPASS_DEPTH",
        index: "PREPASS_DEPTH_INDEX"
      },
      {
        type: 6,
        define: "PREPASS_NORMAL",
        index: "PREPASS_NORMAL_INDEX"
      }
    ];
    if (e.prePassRenderer && e.prePassRenderer.enabled && i) {
      t.PREPASS = !0, t.SCENE_MRT_COUNT = e.prePassRenderer.mrtCount;
      for (let n = 0; n < r.length; n++) {
        const a = e.prePassRenderer.getIndex(r[n].type);
        a !== -1 ? (t[r[n].define] = !0, t[r[n].index] = a) : t[r[n].define] = !1;
      }
    } else {
      t.PREPASS = !1;
      for (let n = 0; n < r.length; n++)
        t[r[n].define] = !1;
    }
    t.PREPASS != s && (t.markAsUnprocessed(), t.markAsImageProcessingDirty());
  }
  static PrepareDefinesForLight(e, t, i, s, r, n, a) {
    switch (a.needNormals = !0, r["LIGHT" + s] === void 0 && (a.needRebuild = !0), r["LIGHT" + s] = !0, r["SPOTLIGHT" + s] = !1, r["HEMILIGHT" + s] = !1, r["POINTLIGHT" + s] = !1, r["DIRLIGHT" + s] = !1, i.prepareLightSpecificDefines(r, s), r["LIGHT_FALLOFF_PHYSICAL" + s] = !1, r["LIGHT_FALLOFF_GLTF" + s] = !1, r["LIGHT_FALLOFF_STANDARD" + s] = !1, i.falloffType) {
      case Te.FALLOFF_GLTF:
        r["LIGHT_FALLOFF_GLTF" + s] = !0;
        break;
      case Te.FALLOFF_PHYSICAL:
        r["LIGHT_FALLOFF_PHYSICAL" + s] = !0;
        break;
      case Te.FALLOFF_STANDARD:
        r["LIGHT_FALLOFF_STANDARD" + s] = !0;
        break;
    }
    if (n && !i.specular.equalsFloats(0, 0, 0) && (a.specularEnabled = !0), r["SHADOW" + s] = !1, r["SHADOWCSM" + s] = !1, r["SHADOWCSMDEBUG" + s] = !1, r["SHADOWCSMNUM_CASCADES" + s] = !1, r["SHADOWCSMUSESHADOWMAXZ" + s] = !1, r["SHADOWCSMNOBLEND" + s] = !1, r["SHADOWCSM_RIGHTHANDED" + s] = !1, r["SHADOWPCF" + s] = !1, r["SHADOWPCSS" + s] = !1, r["SHADOWPOISSON" + s] = !1, r["SHADOWESM" + s] = !1, r["SHADOWCLOSEESM" + s] = !1, r["SHADOWCUBE" + s] = !1, r["SHADOWLOWQUALITY" + s] = !1, r["SHADOWMEDIUMQUALITY" + s] = !1, t && t.receiveShadows && e.shadowsEnabled && i.shadowEnabled) {
      const o = i.getShadowGenerator();
      if (o) {
        const h = o.getShadowMap();
        h && h.renderList && h.renderList.length > 0 && (a.shadowEnabled = !0, o.prepareDefines(r, s));
      }
    }
    i.lightmapMode != Te.LIGHTMAP_DEFAULT ? (a.lightmapMode = !0, r["LIGHTMAPEXCLUDED" + s] = !0, r["LIGHTMAPNOSPECULAR" + s] = i.lightmapMode == Te.LIGHTMAP_SHADOWSONLY) : (r["LIGHTMAPEXCLUDED" + s] = !1, r["LIGHTMAPNOSPECULAR" + s] = !1);
  }
  static PrepareDefinesForLights(e, t, i, s, r = 4, n = !1) {
    if (!i._areLightsDirty)
      return i._needNormals;
    let a = 0;
    const o = {
      needNormals: i._needNormals,
      needRebuild: !1,
      lightmapMode: !1,
      shadowEnabled: !1,
      specularEnabled: !1
    };
    if (e.lightsEnabled && !n) {
      for (const l of t.lightSources)
        if (this.PrepareDefinesForLight(e, t, l, a, i, s, o), a++, a === r)
          break;
    }
    i.SPECULARTERM = o.specularEnabled, i.SHADOWS = o.shadowEnabled;
    for (let l = a; l < r; l++)
      i["LIGHT" + l] !== void 0 && (i["LIGHT" + l] = !1, i["HEMILIGHT" + l] = !1, i["POINTLIGHT" + l] = !1, i["DIRLIGHT" + l] = !1, i["SPOTLIGHT" + l] = !1, i["SHADOW" + l] = !1, i["SHADOWCSM" + l] = !1, i["SHADOWCSMDEBUG" + l] = !1, i["SHADOWCSMNUM_CASCADES" + l] = !1, i["SHADOWCSMUSESHADOWMAXZ" + l] = !1, i["SHADOWCSMNOBLEND" + l] = !1, i["SHADOWCSM_RIGHTHANDED" + l] = !1, i["SHADOWPCF" + l] = !1, i["SHADOWPCSS" + l] = !1, i["SHADOWPOISSON" + l] = !1, i["SHADOWESM" + l] = !1, i["SHADOWCLOSEESM" + l] = !1, i["SHADOWCUBE" + l] = !1, i["SHADOWLOWQUALITY" + l] = !1, i["SHADOWMEDIUMQUALITY" + l] = !1);
    const h = e.getEngine().getCaps();
    return i.SHADOWFLOAT === void 0 && (o.needRebuild = !0), i.SHADOWFLOAT = o.shadowEnabled && (h.textureFloatRender && h.textureFloatLinearFiltering || h.textureHalfFloatRender && h.textureHalfFloatLinearFiltering), i.LIGHTMAPEXCLUDED = o.lightmapMode, o.needRebuild && i.rebuild(), o.needNormals;
  }
  static PrepareUniformsAndSamplersForLight(e, t, i, s, r = null, n = !1) {
    r && r.push("Light" + e), !n && (t.push("vLightData" + e, "vLightDiffuse" + e, "vLightSpecular" + e, "vLightDirection" + e, "vLightFalloff" + e, "vLightGround" + e, "lightMatrix" + e, "shadowsInfo" + e, "depthValues" + e), i.push("shadowSampler" + e), i.push("depthSampler" + e), t.push("viewFrustumZ" + e, "cascadeBlendFactor" + e, "lightSizeUVCorrection" + e, "depthCorrection" + e, "penumbraDarkness" + e, "frustumLengths" + e), s && (i.push("projectionLightSampler" + e), t.push("textureProjectionMatrix" + e)));
  }
  static PrepareUniformsAndSamplersList(e, t, i, s = 4) {
    let r, n = null;
    if (e.uniformsNames) {
      const a = e;
      r = a.uniformsNames, n = a.uniformBuffersNames, t = a.samplers, i = a.defines, s = a.maxSimultaneousLights || 0;
    } else
      r = e, t || (t = []);
    for (let a = 0; a < s && i["LIGHT" + a]; a++)
      this.PrepareUniformsAndSamplersForLight(a, r, t, i["PROJECTEDLIGHTTEXTURE" + a], n);
    i.NUM_MORPH_INFLUENCERS && r.push("morphTargetInfluences"), i.BAKED_VERTEX_ANIMATION_TEXTURE && (r.push("bakedVertexAnimationSettings"), r.push("bakedVertexAnimationTextureSizeInverted"), r.push("bakedVertexAnimationTime"), t.push("bakedVertexAnimationTexture"));
  }
  static HandleFallbacksForShadows(e, t, i = 4, s = 0) {
    let r = 0;
    for (let n = 0; n < i && e["LIGHT" + n]; n++)
      n > 0 && (r = s + n, t.addFallback(r, "LIGHT" + n)), e.SHADOWS || (e["SHADOW" + n] && t.addFallback(s, "SHADOW" + n), e["SHADOWPCF" + n] && t.addFallback(s, "SHADOWPCF" + n), e["SHADOWPCSS" + n] && t.addFallback(s, "SHADOWPCSS" + n), e["SHADOWPOISSON" + n] && t.addFallback(s, "SHADOWPOISSON" + n), e["SHADOWESM" + n] && t.addFallback(s, "SHADOWESM" + n), e["SHADOWCLOSEESM" + n] && t.addFallback(s, "SHADOWCLOSEESM" + n));
    return r++;
  }
  static PrepareAttributesForMorphTargetsInfluencers(e, t, i) {
    this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = i, this.PrepareAttributesForMorphTargets(e, t, this._TmpMorphInfluencers);
  }
  static PrepareAttributesForMorphTargets(e, t, i) {
    const s = i.NUM_MORPH_INFLUENCERS;
    if (s > 0 && _e.LastCreatedEngine) {
      const r = _e.LastCreatedEngine.getCaps().maxVertexAttribs, n = t.morphTargetManager;
      if (n != null && n.isUsingTextureForTargets)
        return;
      const a = n && n.supportsNormals && i.NORMAL, o = n && n.supportsTangents && i.TANGENT, h = n && n.supportsUVs && i.UV1;
      for (let l = 0; l < s; l++)
        e.push(p.PositionKind + l), a && e.push(p.NormalKind + l), o && e.push(p.TangentKind + l), h && e.push(p.UVKind + "_" + l), e.length > r && w.Error("Cannot add more vertex attributes for mesh " + t.name);
    }
  }
  static PrepareAttributesForBakedVertexAnimation(e, t, i) {
    i.BAKED_VERTEX_ANIMATION_TEXTURE && i.INSTANCES && e.push("bakedVertexAnimationSettingsInstanced");
  }
  static PrepareAttributesForBones(e, t, i, s) {
    i.NUM_BONE_INFLUENCERS > 0 && (s.addCPUSkinningFallback(0, t), e.push(p.MatricesIndicesKind), e.push(p.MatricesWeightsKind), i.NUM_BONE_INFLUENCERS > 4 && (e.push(p.MatricesIndicesExtraKind), e.push(p.MatricesWeightsExtraKind)));
  }
  static PrepareAttributesForInstances(e, t) {
    (t.INSTANCES || t.THIN_INSTANCES) && this.PushAttributesForInstances(e, !!t.PREPASS_VELOCITY), t.INSTANCESCOLOR && e.push(p.ColorInstanceKind);
  }
  static PushAttributesForInstances(e, t = !1) {
    e.push("world0"), e.push("world1"), e.push("world2"), e.push("world3"), t && (e.push("previousWorld0"), e.push("previousWorld1"), e.push("previousWorld2"), e.push("previousWorld3"));
  }
  static BindLightProperties(e, t, i) {
    e.transferToEffect(t, i + "");
  }
  static BindLight(e, t, i, s, r, n = !0) {
    e._bindLight(t, i, s, r, n);
  }
  static BindLights(e, t, i, s, r = 4) {
    const n = Math.min(t.lightSources.length, r);
    for (let a = 0; a < n; a++) {
      const o = t.lightSources[a];
      this.BindLight(o, a, e, i, typeof s == "boolean" ? s : s.SPECULARTERM, t.receiveShadows);
    }
  }
  static BindFogParameters(e, t, i, s = !1) {
    e.fogEnabled && t.applyFog && e.fogMode !== re.FOGMODE_NONE && (i.setFloat4("vFogInfos", e.fogMode, e.fogStart, e.fogEnd, e.fogDensity), s ? (e.fogColor.toLinearSpaceToRef(this._TempFogColor), i.setColor3("vFogColor", this._TempFogColor)) : i.setColor3("vFogColor", e.fogColor));
  }
  static BindBonesParameters(e, t, i) {
    if (!(!t || !e) && (e.computeBonesUsingShaders && t._bonesComputationForcedToCPU && (e.computeBonesUsingShaders = !1), e.useBones && e.computeBonesUsingShaders && e.skeleton)) {
      const s = e.skeleton;
      if (s.isUsingTextureForMatrices && t.getUniformIndex("boneTextureWidth") > -1) {
        const r = s.getTransformMatrixTexture(e);
        t.setTexture("boneSampler", r), t.setFloat("boneTextureWidth", 4 * (s.bones.length + 1));
      } else {
        const r = s.getTransformMatrices(e);
        r && (t.setMatrices("mBones", r), i && e.getScene().prePassRenderer && e.getScene().prePassRenderer.getIndex(2) && (i.previousBones[e.uniqueId] || (i.previousBones[e.uniqueId] = r.slice()), t.setMatrices("mPreviousBones", i.previousBones[e.uniqueId]), J._CopyBonesTransformationMatrices(r, i.previousBones[e.uniqueId])));
      }
    }
  }
  static _CopyBonesTransformationMatrices(e, t) {
    return t.set(e), t;
  }
  static BindMorphTargetParameters(e, t) {
    const i = e.morphTargetManager;
    !e || !i || t.setFloatArray("morphTargetInfluences", i.influences);
  }
  static BindLogDepth(e, t, i) {
    if (!e || e.LOGARITHMICDEPTH) {
      const s = i.activeCamera;
      s.mode === Y.ORTHOGRAPHIC_CAMERA && w.Error("Logarithmic depth is not compatible with orthographic cameras!", 20), t.setFloat("logarithmicDepthConstant", 2 / (Math.log(s.maxZ + 1) / Math.LN2));
    }
  }
  static BindClipPlane(e, t) {
    Dn.BindClipPlane(e, t);
  }
}
J._TmpMorphInfluencers = { NUM_MORPH_INFLUENCERS: 0 };
J._TempFogColor = te.Black();
class zt {
  constructor() {
    this.reset();
  }
  reset() {
    this.enabled = !1, this.mask = 255, this.func = 519, this.funcRef = 1, this.funcMask = 255, this.opStencilFail = 7680, this.opDepthFail = 7680, this.opStencilDepthPass = 7681;
  }
  get func() {
    return this._func;
  }
  set func(e) {
    this._func = e;
  }
  get funcRef() {
    return this._funcRef;
  }
  set funcRef(e) {
    this._funcRef = e;
  }
  get funcMask() {
    return this._funcMask;
  }
  set funcMask(e) {
    this._funcMask = e;
  }
  get opStencilFail() {
    return this._opStencilFail;
  }
  set opStencilFail(e) {
    this._opStencilFail = e;
  }
  get opDepthFail() {
    return this._opDepthFail;
  }
  set opDepthFail(e) {
    this._opDepthFail = e;
  }
  get opStencilDepthPass() {
    return this._opStencilDepthPass;
  }
  set opStencilDepthPass(e) {
    this._opStencilDepthPass = e;
  }
  get mask() {
    return this._mask;
  }
  set mask(e) {
    this._mask = e;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e;
  }
  getClassName() {
    return "MaterialStencilState";
  }
  copyTo(e) {
    ne.Clone(() => e, this);
  }
  serialize() {
    return ne.Serialize(this);
  }
  parse(e, t, i) {
    ne.Parse(() => this, e, t, i);
  }
}
S([
  M()
], zt.prototype, "func", null);
S([
  M()
], zt.prototype, "funcRef", null);
S([
  M()
], zt.prototype, "funcMask", null);
S([
  M()
], zt.prototype, "opStencilFail", null);
S([
  M()
], zt.prototype, "opDepthFail", null);
S([
  M()
], zt.prototype, "opStencilDepthPass", null);
S([
  M()
], zt.prototype, "mask", null);
S([
  M()
], zt.prototype, "enabled", null);
var je;
(function(c) {
  c[c.Created = 1] = "Created", c[c.Disposed = 2] = "Disposed", c[c.GetDefineNames = 4] = "GetDefineNames", c[c.PrepareUniformBuffer = 8] = "PrepareUniformBuffer", c[c.IsReadyForSubMesh = 16] = "IsReadyForSubMesh", c[c.PrepareDefines = 32] = "PrepareDefines", c[c.BindForSubMesh = 64] = "BindForSubMesh", c[c.PrepareEffect = 128] = "PrepareEffect", c[c.GetAnimatables = 256] = "GetAnimatables", c[c.GetActiveTextures = 512] = "GetActiveTextures", c[c.HasTexture = 1024] = "HasTexture", c[c.FillRenderTargetTextures = 2048] = "FillRenderTargetTextures", c[c.HasRenderTargetTextures = 4096] = "HasRenderTargetTextures", c[c.HardBindForSubMesh = 8192] = "HardBindForSubMesh";
})(je || (je = {}));
class I {
  constructor(e, t, i) {
    this.shadowDepthWrapper = null, this.allowShaderHotSwapping = !0, this.metadata = null, this.reservedDataStore = null, this.checkReadyOnEveryCall = !1, this.checkReadyOnlyOnce = !1, this.state = "", this._alpha = 1, this._backFaceCulling = !0, this._cullBackFaces = !0, this.onCompiled = null, this.onError = null, this.getRenderTargetTextures = null, this.doNotSerialize = !1, this._storeEffectOnSubMeshes = !1, this.animations = null, this.onDisposeObservable = new F(), this._onDisposeObserver = null, this._onUnBindObservable = null, this._onBindObserver = null, this._alphaMode = 2, this._needDepthPrePass = !1, this.disableDepthWrite = !1, this.disableColorWrite = !1, this.forceDepthWrite = !1, this.depthFunction = 0, this.separateCullingPass = !1, this._fogEnabled = !0, this.pointSize = 1, this.zOffset = 0, this.zOffsetUnits = 0, this.stencil = new zt(), this._useUBO = !1, this._fillMode = I.TriangleFillMode, this._cachedDepthWriteState = !1, this._cachedColorWriteState = !1, this._cachedDepthFunctionState = 0, this._indexInSceneMaterialArray = -1, this.meshMap = null, this._parentContainer = null, this._uniformBufferLayoutBuilt = !1, this._eventInfo = {}, this._callbackPluginEventGeneric = () => {
    }, this._callbackPluginEventIsReadyForSubMesh = () => {
    }, this._callbackPluginEventPrepareDefines = () => {
    }, this._callbackPluginEventPrepareDefinesBeforeAttributes = () => {
    }, this._callbackPluginEventHardBindForSubMesh = () => {
    }, this._callbackPluginEventBindForSubMesh = () => {
    }, this._callbackPluginEventHasRenderTargetTextures = () => {
    }, this._callbackPluginEventFillRenderTargetTextures = () => {
    }, this._forceAlphaTest = !1, this._transparencyMode = null, this.name = e;
    const s = t || _e.LastCreatedScene;
    !s || (this._scene = s, this._dirtyCallbacks = {}, this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this), this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this), this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this), this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this), this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this), this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this), this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this), this.id = e || U.RandomId(), this.uniqueId = this._scene.getUniqueId(), this._materialContext = this._scene.getEngine().createMaterialContext(), this._drawWrapper = new Oi(this._scene.getEngine(), !1), this._drawWrapper.materialContext = this._materialContext, this._scene.useRightHandedSystem ? this.sideOrientation = I.ClockWiseSideOrientation : this.sideOrientation = I.CounterClockWiseSideOrientation, this._uniformBuffer = new G(this._scene.getEngine(), void 0, void 0, e), this._useUBO = this.getScene().getEngine().supportsUniformBuffers, i || this._scene.addMaterial(this), this._scene.useMaterialMeshMap && (this.meshMap = {}), I.OnEventObservable.notifyObservers(this, je.Created));
  }
  get canRenderToMRT() {
    return !1;
  }
  set alpha(e) {
    if (this._alpha === e)
      return;
    const t = this._alpha;
    this._alpha = e, (t === 1 || e === 1) && this.markAsDirty(I.MiscDirtyFlag);
  }
  get alpha() {
    return this._alpha;
  }
  set backFaceCulling(e) {
    this._backFaceCulling !== e && (this._backFaceCulling = e, this.markAsDirty(I.TextureDirtyFlag));
  }
  get backFaceCulling() {
    return this._backFaceCulling;
  }
  set cullBackFaces(e) {
    this._cullBackFaces !== e && (this._cullBackFaces = e, this.markAsDirty(I.TextureDirtyFlag));
  }
  get cullBackFaces() {
    return this._cullBackFaces;
  }
  get hasRenderTargetTextures() {
    return this._eventInfo.hasRenderTargetTextures = !1, this._callbackPluginEventHasRenderTargetTextures(this._eventInfo), this._eventInfo.hasRenderTargetTextures;
  }
  set onDispose(e) {
    this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);
  }
  get onBindObservable() {
    return this._onBindObservable || (this._onBindObservable = new F()), this._onBindObservable;
  }
  set onBind(e) {
    this._onBindObserver && this.onBindObservable.remove(this._onBindObserver), this._onBindObserver = this.onBindObservable.add(e);
  }
  get onUnBindObservable() {
    return this._onUnBindObservable || (this._onUnBindObservable = new F()), this._onUnBindObservable;
  }
  get onEffectCreatedObservable() {
    return this._onEffectCreatedObservable || (this._onEffectCreatedObservable = new F()), this._onEffectCreatedObservable;
  }
  set alphaMode(e) {
    this._alphaMode !== e && (this._alphaMode = e, this.markAsDirty(I.TextureDirtyFlag));
  }
  get alphaMode() {
    return this._alphaMode;
  }
  set needDepthPrePass(e) {
    this._needDepthPrePass !== e && (this._needDepthPrePass = e, this._needDepthPrePass && (this.checkReadyOnEveryCall = !0));
  }
  get needDepthPrePass() {
    return this._needDepthPrePass;
  }
  get isPrePassCapable() {
    return !1;
  }
  set fogEnabled(e) {
    this._fogEnabled !== e && (this._fogEnabled = e, this.markAsDirty(I.MiscDirtyFlag));
  }
  get fogEnabled() {
    return this._fogEnabled;
  }
  get wireframe() {
    switch (this._fillMode) {
      case I.WireFrameFillMode:
      case I.LineListDrawMode:
      case I.LineLoopDrawMode:
      case I.LineStripDrawMode:
        return !0;
    }
    return this._scene.forceWireframe;
  }
  set wireframe(e) {
    this.fillMode = e ? I.WireFrameFillMode : I.TriangleFillMode;
  }
  get pointsCloud() {
    switch (this._fillMode) {
      case I.PointFillMode:
      case I.PointListDrawMode:
        return !0;
    }
    return this._scene.forcePointsCloud;
  }
  set pointsCloud(e) {
    this.fillMode = e ? I.PointFillMode : I.TriangleFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  set fillMode(e) {
    this._fillMode !== e && (this._fillMode = e, this.markAsDirty(I.MiscDirtyFlag));
  }
  _getDrawWrapper() {
    return this._drawWrapper;
  }
  _setDrawWrapper(e) {
    this._drawWrapper = e;
  }
  toString(e) {
    return "Name: " + this.name;
  }
  getClassName() {
    return "Material";
  }
  get isFrozen() {
    return this.checkReadyOnlyOnce;
  }
  freeze() {
    this.markDirty(), this.checkReadyOnlyOnce = !0;
  }
  unfreeze() {
    this.markDirty(), this.checkReadyOnlyOnce = !1;
  }
  isReady(e, t) {
    return !0;
  }
  isReadyForSubMesh(e, t, i) {
    const s = t.materialDefines;
    return s ? (this._eventInfo.isReadyForSubMesh = !0, this._eventInfo.defines = s, this._callbackPluginEventIsReadyForSubMesh(this._eventInfo), this._eventInfo.isReadyForSubMesh) : !1;
  }
  getEffect() {
    return this._drawWrapper.effect;
  }
  getScene() {
    return this._scene;
  }
  get transparencyMode() {
    return this._transparencyMode;
  }
  set transparencyMode(e) {
    this._transparencyMode !== e && (this._transparencyMode = e, this._forceAlphaTest = e === I.MATERIAL_ALPHATESTANDBLEND, this._markAllSubMeshesAsTexturesAndMiscDirty());
  }
  get _disableAlphaBlending() {
    return this._transparencyMode === I.MATERIAL_OPAQUE || this._transparencyMode === I.MATERIAL_ALPHATEST;
  }
  needAlphaBlending() {
    return this._disableAlphaBlending ? !1 : this.alpha < 1;
  }
  needAlphaBlendingForMesh(e) {
    return this._disableAlphaBlending && e.visibility >= 1 ? !1 : this.needAlphaBlending() || e.visibility < 1 || e.hasVertexAlpha;
  }
  needAlphaTesting() {
    return !!this._forceAlphaTest;
  }
  _shouldTurnAlphaTestOn(e) {
    return !this.needAlphaBlendingForMesh(e) && this.needAlphaTesting();
  }
  getAlphaTestTexture() {
    return null;
  }
  markDirty() {
    const e = this.getScene().meshes;
    for (const t of e)
      if (!!t.subMeshes)
        for (const i of t.subMeshes)
          i.getMaterial() === this && (!i.effect || (i.effect._wasPreviouslyReady = !1, i.effect._wasPreviouslyUsingInstances = null));
  }
  _preBind(e, t = null) {
    const i = this._scene.getEngine(), r = (t == null ? this.sideOrientation : t) === I.ClockWiseSideOrientation;
    return i.enableEffect(e || this._getDrawWrapper()), i.setState(this.backFaceCulling, this.zOffset, !1, r, this.cullBackFaces, this.stencil, this.zOffsetUnits), r;
  }
  bind(e, t) {
  }
  buildUniformLayout() {
    const e = this._uniformBuffer;
    this._eventInfo.ubo = e, this._callbackPluginEventGeneric(je.PrepareUniformBuffer, this._eventInfo), e.create(), this._uniformBufferLayoutBuilt = !0;
  }
  bindForSubMesh(e, t, i) {
    !i.effect || (this._eventInfo.subMesh = i, this._callbackPluginEventBindForSubMesh(this._eventInfo));
  }
  bindOnlyWorldMatrix(e) {
  }
  bindView(e) {
    this._useUBO ? this._needToBindSceneUbo = !0 : e.setMatrix("view", this.getScene().getViewMatrix());
  }
  bindViewProjection(e) {
    this._useUBO ? this._needToBindSceneUbo = !0 : (e.setMatrix("viewProjection", this.getScene().getTransformMatrix()), e.setMatrix("projection", this.getScene().getProjectionMatrix()));
  }
  bindEyePosition(e, t) {
    this._useUBO ? this._needToBindSceneUbo = !0 : this._scene.bindEyePosition(e, t);
  }
  _afterBind(e, t = null) {
    if (this._scene._cachedMaterial = this, this._needToBindSceneUbo && t && (this._needToBindSceneUbo = !1, J.BindSceneUniformBuffer(t, this.getScene().getSceneUniformBuffer()), this._scene.finalizeSceneUbo()), e ? this._scene._cachedVisibility = e.visibility : this._scene._cachedVisibility = 1, this._onBindObservable && e && this._onBindObservable.notifyObservers(e), this.disableDepthWrite) {
      const i = this._scene.getEngine();
      this._cachedDepthWriteState = i.getDepthWrite(), i.setDepthWrite(!1);
    }
    if (this.disableColorWrite) {
      const i = this._scene.getEngine();
      this._cachedColorWriteState = i.getColorWrite(), i.setColorWrite(!1);
    }
    if (this.depthFunction !== 0) {
      const i = this._scene.getEngine();
      this._cachedDepthFunctionState = i.getDepthFunction() || 0, i.setDepthFunction(this.depthFunction);
    }
  }
  unbind() {
    this._onUnBindObservable && this._onUnBindObservable.notifyObservers(this), this.depthFunction !== 0 && this._scene.getEngine().setDepthFunction(this._cachedDepthFunctionState), this.disableDepthWrite && this._scene.getEngine().setDepthWrite(this._cachedDepthWriteState), this.disableColorWrite && this._scene.getEngine().setColorWrite(this._cachedColorWriteState);
  }
  getAnimatables() {
    return this._eventInfo.animatables = [], this._callbackPluginEventGeneric(je.GetAnimatables, this._eventInfo), this._eventInfo.animatables;
  }
  getActiveTextures() {
    return this._eventInfo.activeTextures = [], this._callbackPluginEventGeneric(je.GetActiveTextures, this._eventInfo), this._eventInfo.activeTextures;
  }
  hasTexture(e) {
    return this._eventInfo.hasTexture = !1, this._eventInfo.texture = e, this._callbackPluginEventGeneric(je.HasTexture, this._eventInfo), this._eventInfo.hasTexture;
  }
  clone(e) {
    return null;
  }
  getBindedMeshes() {
    if (this.meshMap) {
      const e = new Array();
      for (const t in this.meshMap) {
        const i = this.meshMap[t];
        i && e.push(i);
      }
      return e;
    } else
      return this._scene.meshes.filter((t) => t.material === this);
  }
  forceCompilation(e, t, i, s) {
    const r = {
      clipPlane: !1,
      useInstances: !1,
      ...i
    }, n = this.getScene(), a = this.allowShaderHotSwapping;
    this.allowShaderHotSwapping = !1;
    const o = () => {
      if (!this._scene || !this._scene.getEngine())
        return;
      const h = n.clipPlane;
      if (r.clipPlane && (n.clipPlane = new xt(0, 0, 0, 1)), this._storeEffectOnSubMeshes) {
        let l = !0, u = null;
        if (e.subMeshes) {
          const f = new mt(0, 0, 0, 0, 0, e, void 0, !1, !1);
          f.materialDefines && (f.materialDefines._renderId = -1), this.isReadyForSubMesh(e, f, r.useInstances) || (f.effect && f.effect.getCompilationError() && f.effect.allFallbacksProcessed() ? u = f.effect.getCompilationError() : (l = !1, setTimeout(o, 16)));
        }
        l && (this.allowShaderHotSwapping = a, u && s && s(u), t && t(this));
      } else
        this.isReady() ? (this.allowShaderHotSwapping = a, t && t(this)) : setTimeout(o, 16);
      r.clipPlane && (n.clipPlane = h);
    };
    o();
  }
  forceCompilationAsync(e, t) {
    return new Promise((i, s) => {
      this.forceCompilation(e, () => {
        i();
      }, t, (r) => {
        s(r);
      });
    });
  }
  markAsDirty(e) {
    this.getScene().blockMaterialDirtyMechanism || (I._DirtyCallbackArray.length = 0, e & I.TextureDirtyFlag && I._DirtyCallbackArray.push(I._TextureDirtyCallBack), e & I.LightDirtyFlag && I._DirtyCallbackArray.push(I._LightsDirtyCallBack), e & I.FresnelDirtyFlag && I._DirtyCallbackArray.push(I._FresnelDirtyCallBack), e & I.AttributesDirtyFlag && I._DirtyCallbackArray.push(I._AttributeDirtyCallBack), e & I.MiscDirtyFlag && I._DirtyCallbackArray.push(I._MiscDirtyCallBack), e & I.PrePassDirtyFlag && I._DirtyCallbackArray.push(I._PrePassDirtyCallBack), I._DirtyCallbackArray.length && this._markAllSubMeshesAsDirty(I._RunDirtyCallBacks), this.getScene().resetCachedMaterial());
  }
  resetDrawCache() {
    const e = this.getScene().meshes;
    for (const t of e)
      if (!!t.subMeshes)
        for (const i of t.subMeshes)
          i.getMaterial() === this && i.resetDrawCache();
  }
  _markAllSubMeshesAsDirty(e) {
    if (this.getScene().blockMaterialDirtyMechanism)
      return;
    const t = this.getScene().meshes;
    for (const i of t)
      if (!!i.subMeshes) {
        for (const s of i.subMeshes)
          if (s.getMaterial(!1) === this)
            for (const r of s._drawWrappers)
              !r || !r.defines || !r.defines.markAllAsDirty || this._materialContext === r.materialContext && e(r.defines);
      }
  }
  _markScenePrePassDirty() {
    if (this.getScene().blockMaterialDirtyMechanism)
      return;
    const e = this.getScene().enablePrePassRenderer();
    e && e.markAsDirty();
  }
  _markAllSubMeshesAsAllDirty() {
    this._markAllSubMeshesAsDirty(I._AllDirtyCallBack);
  }
  _markAllSubMeshesAsImageProcessingDirty() {
    this._markAllSubMeshesAsDirty(I._ImageProcessingDirtyCallBack);
  }
  _markAllSubMeshesAsTexturesDirty() {
    this._markAllSubMeshesAsDirty(I._TextureDirtyCallBack);
  }
  _markAllSubMeshesAsFresnelDirty() {
    this._markAllSubMeshesAsDirty(I._FresnelDirtyCallBack);
  }
  _markAllSubMeshesAsFresnelAndMiscDirty() {
    this._markAllSubMeshesAsDirty(I._FresnelAndMiscDirtyCallBack);
  }
  _markAllSubMeshesAsLightsDirty() {
    this._markAllSubMeshesAsDirty(I._LightsDirtyCallBack);
  }
  _markAllSubMeshesAsAttributesDirty() {
    this._markAllSubMeshesAsDirty(I._AttributeDirtyCallBack);
  }
  _markAllSubMeshesAsMiscDirty() {
    this._markAllSubMeshesAsDirty(I._MiscDirtyCallBack);
  }
  _markAllSubMeshesAsPrePassDirty() {
    this._markAllSubMeshesAsDirty(I._MiscDirtyCallBack);
  }
  _markAllSubMeshesAsTexturesAndMiscDirty() {
    this._markAllSubMeshesAsDirty(I._TextureAndMiscDirtyCallBack);
  }
  setPrePassRenderer(e) {
    return !1;
  }
  dispose(e, t, i) {
    const s = this.getScene();
    if (s.stopAnimation(this), s.freeProcessedMaterials(), s.removeMaterial(this), this._eventInfo.forceDisposeTextures = t, this._callbackPluginEventGeneric(je.Disposed, this._eventInfo), this._parentContainer) {
      const r = this._parentContainer.materials.indexOf(this);
      r > -1 && this._parentContainer.materials.splice(r, 1), this._parentContainer = null;
    }
    if (i !== !0)
      if (this.meshMap)
        for (const r in this.meshMap) {
          const n = this.meshMap[r];
          n && (n.material = null, this.releaseVertexArrayObject(n, e));
        }
      else {
        const r = s.meshes;
        for (const n of r)
          n.material === this && !n.sourceMesh && (n.material = null, this.releaseVertexArrayObject(n, e));
      }
    this._uniformBuffer.dispose(), e && this._drawWrapper.effect && (this._storeEffectOnSubMeshes || this._drawWrapper.effect.dispose(), this._drawWrapper.effect = null), this.metadata = null, this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this._onBindObservable && this._onBindObservable.clear(), this._onUnBindObservable && this._onUnBindObservable.clear(), this._onEffectCreatedObservable && this._onEffectCreatedObservable.clear();
  }
  releaseVertexArrayObject(e, t) {
    if (e.geometry) {
      const i = e.geometry;
      if (this._storeEffectOnSubMeshes)
        for (const s of e.subMeshes)
          i._releaseVertexArrayObject(s.effect), t && s.effect && s.effect.dispose();
      else
        i._releaseVertexArrayObject(this._drawWrapper.effect);
    }
  }
  serialize() {
    const e = ne.Serialize(this);
    return e.stencil = this.stencil.serialize(), e.uniqueId = this.uniqueId, e;
  }
  static Parse(e, t, i) {
    if (!e.customType)
      e.customType = "BABYLON.StandardMaterial";
    else if (e.customType === "BABYLON.PBRMaterial" && e.overloadedAlbedo && (e.customType = "BABYLON.LegacyPBRMaterial", !BABYLON.LegacyPBRMaterial))
      return w.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library."), null;
    const r = U.Instantiate(e.customType).Parse(e, t, i);
    return r._loadedUniqueId = e.uniqueId, r;
  }
}
I.TriangleFillMode = 0;
I.WireFrameFillMode = 1;
I.PointFillMode = 2;
I.PointListDrawMode = 3;
I.LineListDrawMode = 4;
I.LineLoopDrawMode = 5;
I.LineStripDrawMode = 6;
I.TriangleStripDrawMode = 7;
I.TriangleFanDrawMode = 8;
I.ClockWiseSideOrientation = 0;
I.CounterClockWiseSideOrientation = 1;
I.TextureDirtyFlag = 1;
I.LightDirtyFlag = 2;
I.FresnelDirtyFlag = 4;
I.AttributesDirtyFlag = 8;
I.MiscDirtyFlag = 16;
I.PrePassDirtyFlag = 32;
I.AllDirtyFlag = 63;
I.MATERIAL_OPAQUE = 0;
I.MATERIAL_ALPHATEST = 1;
I.MATERIAL_ALPHABLEND = 2;
I.MATERIAL_ALPHATESTANDBLEND = 3;
I.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;
I.MATERIAL_NORMALBLENDMETHOD_RNM = 1;
I.OnEventObservable = new F();
I._AllDirtyCallBack = (c) => c.markAllAsDirty();
I._ImageProcessingDirtyCallBack = (c) => c.markAsImageProcessingDirty();
I._TextureDirtyCallBack = (c) => c.markAsTexturesDirty();
I._FresnelDirtyCallBack = (c) => c.markAsFresnelDirty();
I._MiscDirtyCallBack = (c) => c.markAsMiscDirty();
I._PrePassDirtyCallBack = (c) => c.markAsPrePassDirty();
I._LightsDirtyCallBack = (c) => c.markAsLightDirty();
I._AttributeDirtyCallBack = (c) => c.markAsAttributesDirty();
I._FresnelAndMiscDirtyCallBack = (c) => {
  I._FresnelDirtyCallBack(c), I._MiscDirtyCallBack(c);
};
I._TextureAndMiscDirtyCallBack = (c) => {
  I._TextureDirtyCallBack(c), I._MiscDirtyCallBack(c);
};
I._DirtyCallbackArray = [];
I._RunDirtyCallBacks = (c) => {
  for (const e of I._DirtyCallbackArray)
    e(c);
};
S([
  M()
], I.prototype, "id", void 0);
S([
  M()
], I.prototype, "uniqueId", void 0);
S([
  M()
], I.prototype, "name", void 0);
S([
  M()
], I.prototype, "metadata", void 0);
S([
  M()
], I.prototype, "checkReadyOnEveryCall", void 0);
S([
  M()
], I.prototype, "checkReadyOnlyOnce", void 0);
S([
  M()
], I.prototype, "state", void 0);
S([
  M("alpha")
], I.prototype, "_alpha", void 0);
S([
  M("backFaceCulling")
], I.prototype, "_backFaceCulling", void 0);
S([
  M("cullBackFaces")
], I.prototype, "_cullBackFaces", void 0);
S([
  M()
], I.prototype, "sideOrientation", void 0);
S([
  M("alphaMode")
], I.prototype, "_alphaMode", void 0);
S([
  M()
], I.prototype, "_needDepthPrePass", void 0);
S([
  M()
], I.prototype, "disableDepthWrite", void 0);
S([
  M()
], I.prototype, "disableColorWrite", void 0);
S([
  M()
], I.prototype, "forceDepthWrite", void 0);
S([
  M()
], I.prototype, "depthFunction", void 0);
S([
  M()
], I.prototype, "separateCullingPass", void 0);
S([
  M("fogEnabled")
], I.prototype, "_fogEnabled", void 0);
S([
  M()
], I.prototype, "pointSize", void 0);
S([
  M()
], I.prototype, "zOffset", void 0);
S([
  M()
], I.prototype, "zOffsetUnits", void 0);
S([
  M()
], I.prototype, "pointsCloud", null);
S([
  M()
], I.prototype, "fillMode", null);
S([
  M()
], I.prototype, "transparencyMode", null);
class bi extends I {
  constructor(e, t) {
    super(e, t, !0), this._waitingSubMaterialsUniqueIds = [], this.getScene().multiMaterials.push(this), this.subMaterials = new Array(), this._storeEffectOnSubMeshes = !0;
  }
  get subMaterials() {
    return this._subMaterials;
  }
  set subMaterials(e) {
    this._subMaterials = e, this._hookArray(e);
  }
  getChildren() {
    return this.subMaterials;
  }
  _hookArray(e) {
    const t = e.push;
    e.push = (...s) => {
      const r = t.apply(e, s);
      return this._markAllSubMeshesAsTexturesDirty(), r;
    };
    const i = e.splice;
    e.splice = (s, r) => {
      const n = i.apply(e, [s, r]);
      return this._markAllSubMeshesAsTexturesDirty(), n;
    };
  }
  getSubMaterial(e) {
    return e < 0 || e >= this.subMaterials.length ? this.getScene().defaultMaterial : this.subMaterials[e];
  }
  getActiveTextures() {
    return super.getActiveTextures().concat(...this.subMaterials.map((e) => e ? e.getActiveTextures() : []));
  }
  hasTexture(e) {
    var t;
    if (super.hasTexture(e))
      return !0;
    for (let i = 0; i < this.subMaterials.length; i++)
      if ((t = this.subMaterials[i]) != null && t.hasTexture(e))
        return !0;
    return !1;
  }
  getClassName() {
    return "MultiMaterial";
  }
  isReadyForSubMesh(e, t, i) {
    for (let s = 0; s < this.subMaterials.length; s++) {
      const r = this.subMaterials[s];
      if (r) {
        if (r._storeEffectOnSubMeshes) {
          if (!r.isReadyForSubMesh(e, t, i))
            return !1;
          continue;
        }
        if (!r.isReady(e))
          return !1;
      }
    }
    return !0;
  }
  clone(e, t) {
    const i = new bi(e, this.getScene());
    for (let s = 0; s < this.subMaterials.length; s++) {
      let r = null;
      const n = this.subMaterials[s];
      t && n ? r = n.clone(e + "-" + n.name) : r = this.subMaterials[s], i.subMaterials.push(r);
    }
    return i;
  }
  serialize() {
    const e = {};
    e.name = this.name, e.id = this.id, e.uniqueId = this.uniqueId, pe && (e.tags = pe.GetTags(this)), e.materialsUniqueIds = [], e.materials = [];
    for (let t = 0; t < this.subMaterials.length; t++) {
      const i = this.subMaterials[t];
      i ? (e.materialsUniqueIds.push(i.uniqueId), e.materials.push(i.id)) : (e.materialsUniqueIds.push(null), e.materials.push(null));
    }
    return e;
  }
  dispose(e, t, i) {
    const s = this.getScene();
    if (!s)
      return;
    if (i)
      for (let n = 0; n < this.subMaterials.length; n++) {
        const a = this.subMaterials[n];
        a && a.dispose(e, t);
      }
    const r = s.multiMaterials.indexOf(this);
    r >= 0 && s.multiMaterials.splice(r, 1), super.dispose(e, t);
  }
  static ParseMultiMaterial(e, t) {
    const i = new bi(e.name, t);
    return i.id = e.id, i._loadedUniqueId = e.uniqueId, pe && pe.AddTagsTo(i, e.tags), e.materialsUniqueIds ? i._waitingSubMaterialsUniqueIds = e.materialsUniqueIds : e.materials.forEach((s) => i.subMaterials.push(t.getLastMaterialById(s))), i;
  }
}
it("BABYLON.MultiMaterial", bi);
class Fn {
  constructor(e, t) {
    this.distanceOrScreenCoverage = e, this.mesh = t;
  }
}
class wn {
  constructor() {
    this.visibleInstances = {}, this.batchCache = new or(), this.batchCacheReplacementModeInFrozenMode = new or(), this.instancesBufferSize = 32 * 16 * 4;
  }
}
class or {
  constructor() {
    this.mustReturn = !1, this.visibleInstances = new Array(), this.renderSelf = new Array(), this.hardwareInstancedRendering = new Array();
  }
}
class On {
  constructor() {
    this.instancesCount = 0, this.matrixBuffer = null, this.previousMatrixBuffer = null, this.matrixBufferSize = 32 * 16, this.matrixData = null, this.boundingVectors = [], this.worldMatrices = null;
  }
}
class Ln {
  constructor() {
    this._areNormalsFrozen = !1, this._source = null, this.meshMap = null, this._preActivateId = -1, this._LODLevels = new Array(), this._useLODScreenCoverage = !1, this._effectiveMaterial = null, this._forcedInstanceCount = 0;
  }
}
class k extends at {
  constructor(e, t = null, i = null, s = null, r, n = !0) {
    if (super(e, t), this._internalMeshDataInfo = new Ln(), this.delayLoadState = 0, this.instances = new Array(), this._creationDataStorage = null, this._geometry = null, this._instanceDataStorage = new wn(), this._thinInstanceDataStorage = new On(), this._shouldGenerateFlatShading = !1, this._originalBuilderSideOrientation = k.DEFAULTSIDE, this.overrideMaterialSideOrientation = null, this.ignoreCameraMaxZ = !1, t = this.getScene(), this._onBeforeDraw = (a, o, h) => {
      a && h && (this._uniformBuffer ? this.transferToEffect(o) : h.bindOnlyWorldMatrix(o));
    }, s) {
      if (s._geometry && s._geometry.applyToMesh(this), ws.DeepCopy(s, this, [
        "name",
        "material",
        "skeleton",
        "instances",
        "parent",
        "uniqueId",
        "source",
        "metadata",
        "morphTargetManager",
        "hasInstances",
        "worldMatrixInstancedBuffer",
        "previousWorldMatrixInstancedBuffer",
        "hasLODLevels",
        "geometry",
        "isBlocked",
        "areNormalsFrozen",
        "facetNb",
        "isFacetDataEnabled",
        "lightSources",
        "useBones",
        "isAnInstance",
        "collider",
        "edgesRenderer",
        "forward",
        "up",
        "right",
        "absolutePosition",
        "absoluteScaling",
        "absoluteRotationQuaternion",
        "isWorldMatrixFrozen",
        "nonUniformScaling",
        "behaviors",
        "worldMatrixFromCache",
        "hasThinInstances",
        "cloneMeshMap",
        "hasBoundingInfo"
      ], ["_poseMatrix"]), this._internalMeshDataInfo._source = s, t.useClonedMeshMap && (s._internalMeshDataInfo.meshMap || (s._internalMeshDataInfo.meshMap = {}), s._internalMeshDataInfo.meshMap[this.uniqueId] = this), this._originalBuilderSideOrientation = s._originalBuilderSideOrientation, this._creationDataStorage = s._creationDataStorage, s._ranges) {
        const a = s._ranges;
        for (const o in a)
          !Object.prototype.hasOwnProperty.call(a, o) || !a[o] || this.createAnimationRange(o, a[o].from, a[o].to);
      }
      if (s.metadata && s.metadata.clone ? this.metadata = s.metadata.clone() : this.metadata = s.metadata, pe && pe.HasTags(s) && pe.AddTagsTo(this, pe.GetTags(s, !0)), this.setEnabled(s.isEnabled(!1)), this.parent = s.parent, this.setPivotMatrix(s.getPivotMatrix()), this.id = e + "." + s.id, this.material = s.material, !r) {
        const a = s.getDescendants(!0);
        for (let o = 0; o < a.length; o++) {
          const h = a[o];
          h.clone && h.clone(e + "." + h.name, this);
        }
      }
      if (s.morphTargetManager && (this.morphTargetManager = s.morphTargetManager), t.getPhysicsEngine) {
        const a = t.getPhysicsEngine();
        if (n && a) {
          const o = a.getImpostorForPhysicsObject(s);
          o && (this.physicsImpostor = o.clone(this));
        }
      }
      for (let a = 0; a < t.particleSystems.length; a++) {
        const o = t.particleSystems[a];
        o.emitter === s && o.clone(o.name, this);
      }
      this.skeleton = s.skeleton, this.refreshBoundingInfo(!0, !0), this.computeWorldMatrix(!0);
    }
    i !== null && (this.parent = i), this._instanceDataStorage.hardwareInstancedRendering = this.getEngine().getCaps().instancedArrays, this._internalMeshDataInfo._onMeshReadyObserverAdded = (a) => {
      a.unregisterOnNextCall = !0, this.isReady(!0) ? this.onMeshReadyObservable.notifyObservers(this) : this._internalMeshDataInfo._checkReadinessObserver || (this._internalMeshDataInfo._checkReadinessObserver = this._scene.onBeforeRenderObservable.add(() => {
        this.isReady(!0) && (this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver), this._internalMeshDataInfo._checkReadinessObserver = null, this.onMeshReadyObservable.notifyObservers(this));
      }));
    }, this.onMeshReadyObservable = new F(this._internalMeshDataInfo._onMeshReadyObserverAdded), s && s.onClonedObservable.notifyObservers(this);
  }
  static _GetDefaultSideOrientation(e) {
    return e || k.FRONTSIDE;
  }
  get useLODScreenCoverage() {
    return this._internalMeshDataInfo._useLODScreenCoverage;
  }
  set useLODScreenCoverage(e) {
    this._internalMeshDataInfo._useLODScreenCoverage = e;
  }
  get computeBonesUsingShaders() {
    return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
  }
  set computeBonesUsingShaders(e) {
    this._internalAbstractMeshDataInfo._computeBonesUsingShaders !== e && (e && this._internalMeshDataInfo._sourcePositions && (this.setVerticesData(p.PositionKind, this._internalMeshDataInfo._sourcePositions, !0), this._internalMeshDataInfo._sourceNormals && this.setVerticesData(p.NormalKind, this._internalMeshDataInfo._sourceNormals, !0), this._internalMeshDataInfo._sourcePositions = null, this._internalMeshDataInfo._sourceNormals = null), this._internalAbstractMeshDataInfo._computeBonesUsingShaders = e, this._markSubMeshesAsAttributesDirty());
  }
  get onBeforeRenderObservable() {
    return this._internalMeshDataInfo._onBeforeRenderObservable || (this._internalMeshDataInfo._onBeforeRenderObservable = new F()), this._internalMeshDataInfo._onBeforeRenderObservable;
  }
  get onBeforeBindObservable() {
    return this._internalMeshDataInfo._onBeforeBindObservable || (this._internalMeshDataInfo._onBeforeBindObservable = new F()), this._internalMeshDataInfo._onBeforeBindObservable;
  }
  get onAfterRenderObservable() {
    return this._internalMeshDataInfo._onAfterRenderObservable || (this._internalMeshDataInfo._onAfterRenderObservable = new F()), this._internalMeshDataInfo._onAfterRenderObservable;
  }
  get onBetweenPassObservable() {
    return this._internalMeshDataInfo._onBetweenPassObservable || (this._internalMeshDataInfo._onBetweenPassObservable = new F()), this._internalMeshDataInfo._onBetweenPassObservable;
  }
  get onBeforeDrawObservable() {
    return this._internalMeshDataInfo._onBeforeDrawObservable || (this._internalMeshDataInfo._onBeforeDrawObservable = new F()), this._internalMeshDataInfo._onBeforeDrawObservable;
  }
  set onBeforeDraw(e) {
    this._onBeforeDrawObserver && this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver), this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(e);
  }
  get hasInstances() {
    return this.instances.length > 0;
  }
  get hasThinInstances() {
    var e;
    return ((e = this._thinInstanceDataStorage.instancesCount) != null ? e : 0) > 0;
  }
  get forcedInstanceCount() {
    return this._internalMeshDataInfo._forcedInstanceCount;
  }
  set forcedInstanceCount(e) {
    this._internalMeshDataInfo._forcedInstanceCount = e;
  }
  get source() {
    return this._internalMeshDataInfo._source;
  }
  get cloneMeshMap() {
    return this._internalMeshDataInfo.meshMap;
  }
  get isUnIndexed() {
    return this._unIndexed;
  }
  set isUnIndexed(e) {
    this._unIndexed !== e && (this._unIndexed = e, this._markSubMeshesAsAttributesDirty());
  }
  get worldMatrixInstancedBuffer() {
    return this._instanceDataStorage.instancesData;
  }
  get previousWorldMatrixInstancedBuffer() {
    return this._instanceDataStorage.instancesPreviousData;
  }
  get manualUpdateOfWorldMatrixInstancedBuffer() {
    return this._instanceDataStorage.manualUpdate;
  }
  set manualUpdateOfWorldMatrixInstancedBuffer(e) {
    this._instanceDataStorage.manualUpdate = e;
  }
  get manualUpdateOfPreviousWorldMatrixInstancedBuffer() {
    return this._instanceDataStorage.previousManualUpdate;
  }
  set manualUpdateOfPreviousWorldMatrixInstancedBuffer(e) {
    this._instanceDataStorage.previousManualUpdate = e;
  }
  instantiateHierarchy(e = null, t, i) {
    const s = this.getTotalVertices() === 0 || t && t.doNotInstantiate && (t.doNotInstantiate === !0 || t.doNotInstantiate(this)) ? this.clone("Clone of " + (this.name || this.id), e || this.parent, !0) : this.createInstance("instance of " + (this.name || this.id));
    s.parent = e || this.parent, s.position = this.position.clone(), s.scaling = this.scaling.clone(), this.rotationQuaternion ? s.rotationQuaternion = this.rotationQuaternion.clone() : s.rotation = this.rotation.clone(), i && i(this, s);
    for (const r of this.getChildTransformNodes(!0))
      r.getClassName() === "InstancedMesh" && s.getClassName() === "Mesh" ? r.instantiateHierarchy(s, {
        doNotInstantiate: t && t.doNotInstantiate || !1,
        newSourcedMesh: s
      }, i) : r.instantiateHierarchy(s, t, i);
    return s;
  }
  getClassName() {
    return "Mesh";
  }
  get _isMesh() {
    return !0;
  }
  toString(e) {
    let t = super.toString(e);
    if (t += ", n vertices: " + this.getTotalVertices(), t += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE"), this.animations)
      for (let i = 0; i < this.animations.length; i++)
        t += ", animation[0]: " + this.animations[i].toString(e);
    if (e)
      if (this._geometry) {
        const i = this.getIndices(), s = this.getVerticesData(p.PositionKind);
        s && i && (t += ", flat shading: " + (s.length / 3 === i.length ? "YES" : "NO"));
      } else
        t += ", flat shading: UNKNOWN";
    return t;
  }
  _unBindEffect() {
    super._unBindEffect();
    for (const e of this.instances)
      e._unBindEffect();
  }
  get hasLODLevels() {
    return this._internalMeshDataInfo._LODLevels.length > 0;
  }
  getLODLevels() {
    return this._internalMeshDataInfo._LODLevels;
  }
  _sortLODLevels() {
    const e = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;
    this._internalMeshDataInfo._LODLevels.sort((t, i) => t.distanceOrScreenCoverage < i.distanceOrScreenCoverage ? e : t.distanceOrScreenCoverage > i.distanceOrScreenCoverage ? -e : 0);
  }
  addLODLevel(e, t) {
    if (t && t._masterMesh)
      return w.Warn("You cannot use a mesh as LOD level twice"), this;
    const i = new Fn(e, t);
    return this._internalMeshDataInfo._LODLevels.push(i), t && (t._masterMesh = this), this._sortLODLevels(), this;
  }
  getLODLevelAtDistance(e) {
    const t = this._internalMeshDataInfo;
    for (let i = 0; i < t._LODLevels.length; i++) {
      const s = t._LODLevels[i];
      if (s.distanceOrScreenCoverage === e)
        return s.mesh;
    }
    return null;
  }
  removeLODLevel(e) {
    const t = this._internalMeshDataInfo;
    for (let i = 0; i < t._LODLevels.length; i++)
      t._LODLevels[i].mesh === e && (t._LODLevels.splice(i, 1), e && (e._masterMesh = null));
    return this._sortLODLevels(), this;
  }
  getLOD(e, t) {
    const i = this._internalMeshDataInfo;
    if (!i._LODLevels || i._LODLevels.length === 0)
      return this;
    let s;
    t ? s = t : s = this.getBoundingInfo().boundingSphere;
    const r = s.centerWorld.subtract(e.globalPosition).length(), n = i._useLODScreenCoverage;
    let a = r, o = 1;
    if (n) {
      const h = e.screenArea;
      let l = s.radiusWorld * e.minZ / r;
      l = l * l * Math.PI, a = l / h, o = -1;
    }
    if (o * i._LODLevels[i._LODLevels.length - 1].distanceOrScreenCoverage > o * a)
      return this.onLODLevelSelection && this.onLODLevelSelection(a, this, this), this;
    for (let h = 0; h < i._LODLevels.length; h++) {
      const l = i._LODLevels[h];
      if (o * l.distanceOrScreenCoverage < o * a) {
        if (l.mesh) {
          if (l.mesh.delayLoadState === 4)
            return l.mesh._checkDelayState(), this;
          if (l.mesh.delayLoadState === 2)
            return this;
          l.mesh._preActivate(), l.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
        }
        return this.onLODLevelSelection && this.onLODLevelSelection(a, this, l.mesh), l.mesh;
      }
    }
    return this.onLODLevelSelection && this.onLODLevelSelection(a, this, this), this;
  }
  get geometry() {
    return this._geometry;
  }
  getTotalVertices() {
    return this._geometry === null || this._geometry === void 0 ? 0 : this._geometry.getTotalVertices();
  }
  getVerticesData(e, t, i) {
    var r, n;
    if (!this._geometry)
      return null;
    let s = (n = (r = this._userInstancedBuffersStorage) == null ? void 0 : r.vertexBuffers[e]) == null ? void 0 : n.getFloatData(this._geometry.getTotalVertices(), i || t && this._geometry.meshes.length !== 1);
    return s || (s = this._geometry.getVerticesData(e, t, i)), s;
  }
  getVertexBuffer(e) {
    var t, i;
    return this._geometry ? (i = (t = this._userInstancedBuffersStorage) == null ? void 0 : t.vertexBuffers[e]) != null ? i : this._geometry.getVertexBuffer(e) : null;
  }
  isVerticesDataPresent(e) {
    var t;
    return this._geometry ? ((t = this._userInstancedBuffersStorage) == null ? void 0 : t.vertexBuffers[e]) !== void 0 || this._geometry.isVerticesDataPresent(e) : this._delayInfo ? this._delayInfo.indexOf(e) !== -1 : !1;
  }
  isVertexBufferUpdatable(e) {
    var t, i;
    return this._geometry ? ((i = (t = this._userInstancedBuffersStorage) == null ? void 0 : t.vertexBuffers[e]) == null ? void 0 : i.isUpdatable()) || this._geometry.isVertexBufferUpdatable(e) : this._delayInfo ? this._delayInfo.indexOf(e) !== -1 : !1;
  }
  getVerticesDataKinds() {
    if (!this._geometry) {
      const t = new Array();
      return this._delayInfo && this._delayInfo.forEach(function(i) {
        t.push(i);
      }), t;
    }
    const e = this._geometry.getVerticesDataKinds();
    if (this._userInstancedBuffersStorage)
      for (const t in this._userInstancedBuffersStorage.vertexBuffers)
        e.push(t);
    return e;
  }
  getTotalIndices() {
    return this._geometry ? this._geometry.getTotalIndices() : 0;
  }
  getIndices(e, t) {
    return this._geometry ? this._geometry.getIndices(e, t) : [];
  }
  get isBlocked() {
    return this._masterMesh !== null && this._masterMesh !== void 0;
  }
  isReady(e = !1, t = !1) {
    var o, h, l, u, f, d;
    if (this.delayLoadState === 2 || !super.isReady(e))
      return !1;
    if (!this.subMeshes || this.subMeshes.length === 0 || !e)
      return !0;
    const i = this.getEngine(), s = this.getScene(), r = t || i.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);
    this.computeWorldMatrix();
    const n = this.material || s.defaultMaterial;
    if (n) {
      if (n._storeEffectOnSubMeshes)
        for (const _ of this.subMeshes) {
          const E = _.getMaterial();
          if (E) {
            if (E._storeEffectOnSubMeshes) {
              if (!E.isReadyForSubMesh(this, _, r))
                return !1;
            } else if (!E.isReady(this, r))
              return !1;
          }
        }
      else if (!n.isReady(this, r))
        return !1;
    }
    const a = i.currentRenderPassId;
    for (const _ of this.lightSources) {
      const E = _.getShadowGenerator();
      if (E && (!((o = E.getShadowMap()) != null && o.renderList) || ((h = E.getShadowMap()) == null ? void 0 : h.renderList) && ((u = (l = E.getShadowMap()) == null ? void 0 : l.renderList) == null ? void 0 : u.indexOf(this)) !== -1)) {
        E.getShadowMap() && (i.currentRenderPassId = E.getShadowMap().renderPassId);
        for (const m of this.subMeshes)
          if (!E.isReady(m, r, (d = (f = m.getMaterial()) == null ? void 0 : f.needAlphaBlendingForMesh(this)) != null ? d : !1))
            return i.currentRenderPassId = a, !1;
        i.currentRenderPassId = a;
      }
    }
    for (const _ of this._internalMeshDataInfo._LODLevels)
      if (_.mesh && !_.mesh.isReady(r))
        return !1;
    return !0;
  }
  get areNormalsFrozen() {
    return this._internalMeshDataInfo._areNormalsFrozen;
  }
  freezeNormals() {
    return this._internalMeshDataInfo._areNormalsFrozen = !0, this;
  }
  unfreezeNormals() {
    return this._internalMeshDataInfo._areNormalsFrozen = !1, this;
  }
  set overridenInstanceCount(e) {
    this._instanceDataStorage.overridenInstanceCount = e;
  }
  _preActivate() {
    const e = this._internalMeshDataInfo, t = this.getScene().getRenderId();
    return e._preActivateId === t ? this : (e._preActivateId = t, this._instanceDataStorage.visibleInstances = null, this);
  }
  _preActivateForIntermediateRendering(e) {
    return this._instanceDataStorage.visibleInstances && (this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = e), this;
  }
  _registerInstanceForRenderId(e, t) {
    return this._instanceDataStorage.visibleInstances || (this._instanceDataStorage.visibleInstances = {
      defaultRenderId: t,
      selfDefaultRenderId: this._renderId
    }), this._instanceDataStorage.visibleInstances[t] || (this._instanceDataStorage.previousRenderId !== void 0 && this._instanceDataStorage.isFrozen && (this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null), this._instanceDataStorage.previousRenderId = t, this._instanceDataStorage.visibleInstances[t] = new Array()), this._instanceDataStorage.visibleInstances[t].push(e), this;
  }
  _afterComputeWorldMatrix() {
    super._afterComputeWorldMatrix(), this.hasThinInstances && (this.doNotSyncBoundingInfo || this.thinInstanceRefreshBoundingInfo(!1));
  }
  _postActivate() {
    this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup && (this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer), this.edgesRenderer.customInstances.push(this.getWorldMatrix()));
  }
  refreshBoundingInfo(e = !1, t = !1) {
    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked)
      return this;
    const i = this.geometry ? this.geometry.boundingBias : null;
    return this._refreshBoundingInfo(this._getPositionData(e, t), i), this;
  }
  _createGlobalSubMesh(e) {
    const t = this.getTotalVertices();
    if (!t || !this.getIndices())
      return null;
    if (this.subMeshes && this.subMeshes.length > 0) {
      const i = this.getIndices();
      if (!i)
        return null;
      const s = i.length;
      let r = !1;
      if (e)
        r = !0;
      else
        for (const n of this.subMeshes) {
          if (n.indexStart + n.indexCount > s) {
            r = !0;
            break;
          }
          if (n.verticesStart + n.verticesCount > t) {
            r = !0;
            break;
          }
        }
      if (!r)
        return this.subMeshes[0];
    }
    return this.releaseSubMeshes(), new mt(0, 0, t, 0, this.getTotalIndices(), this);
  }
  subdivide(e) {
    if (e < 1)
      return;
    const t = this.getTotalIndices();
    let i = t / e | 0, s = 0;
    for (; i % 3 !== 0; )
      i++;
    this.releaseSubMeshes();
    for (let r = 0; r < e && !(s >= t); r++)
      mt.CreateFromIndices(0, s, r === e - 1 ? t - s : i, this), s += i;
    this.synchronizeInstances();
  }
  setVerticesData(e, t, i = !1, s) {
    if (this._geometry)
      this._geometry.setVerticesData(e, t, i, s);
    else {
      const r = new Z();
      r.set(t, e);
      const n = this.getScene();
      new nt(nt.RandomId(), n, r, i, this);
    }
    return this;
  }
  removeVerticesData(e) {
    !this._geometry || this._geometry.removeVerticesData(e);
  }
  markVerticesDataAsUpdatable(e, t = !0) {
    const i = this.getVertexBuffer(e);
    !i || i.isUpdatable() === t || this.setVerticesData(e, this.getVerticesData(e), t);
  }
  setVerticesBuffer(e, t = !0) {
    return this._geometry || (this._geometry = nt.CreateGeometryForMesh(this)), this._geometry.setVerticesBuffer(e, null, t), this;
  }
  updateVerticesData(e, t, i, s) {
    return this._geometry ? (s ? (this.makeGeometryUnique(), this.updateVerticesData(e, t, i, !1)) : this._geometry.updateVerticesData(e, t, i), this) : this;
  }
  updateMeshPositions(e, t = !0) {
    const i = this.getVerticesData(p.PositionKind);
    if (!i)
      return this;
    if (e(i), this.updateVerticesData(p.PositionKind, i, !1, !1), t) {
      const s = this.getIndices(), r = this.getVerticesData(p.NormalKind);
      if (!r)
        return this;
      Z.ComputeNormals(i, s, r), this.updateVerticesData(p.NormalKind, r, !1, !1);
    }
    return this;
  }
  makeGeometryUnique() {
    if (!this._geometry)
      return this;
    if (this._geometry.meshes.length === 1)
      return this;
    const e = this._geometry, t = this._geometry.copy(nt.RandomId());
    return e.releaseForMesh(this, !0), t.applyToMesh(this), this;
  }
  setIndices(e, t = null, i = !1) {
    if (this._geometry)
      this._geometry.setIndices(e, t, i);
    else {
      const s = new Z();
      s.indices = e;
      const r = this.getScene();
      new nt(nt.RandomId(), r, s, i, this);
    }
    return this;
  }
  updateIndices(e, t, i = !1) {
    return this._geometry ? (this._geometry.updateIndices(e, t, i), this) : this;
  }
  toLeftHanded() {
    return this._geometry ? (this._geometry.toLeftHanded(), this) : this;
  }
  _bind(e, t, i) {
    if (!this._geometry)
      return this;
    const s = this.getScene().getEngine();
    this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets && this.morphTargetManager._bind(t);
    let r;
    if (this._unIndexed)
      r = null;
    else
      switch (i) {
        case I.PointFillMode:
          r = null;
          break;
        case I.WireFrameFillMode:
          r = e._getLinesIndexBuffer(this.getIndices(), s);
          break;
        default:
        case I.TriangleFillMode:
          r = this._geometry.getIndexBuffer();
          break;
      }
    return !this._userInstancedBuffersStorage || this.hasThinInstances ? this._geometry._bind(t, r) : this._geometry._bind(t, r, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects), this;
  }
  _draw(e, t, i) {
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer())
      return this;
    this._internalMeshDataInfo._onBeforeDrawObservable && this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);
    const r = this.getScene().getEngine();
    return this._unIndexed || t == I.PointFillMode ? r.drawArraysType(t, e.verticesStart, e.verticesCount, this.forcedInstanceCount || i) : t == I.WireFrameFillMode ? r.drawElementsType(t, 0, e._linesIndexCount, this.forcedInstanceCount || i) : r.drawElementsType(t, e.indexStart, e.indexCount, this.forcedInstanceCount || i), this;
  }
  registerBeforeRender(e) {
    return this.onBeforeRenderObservable.add(e), this;
  }
  unregisterBeforeRender(e) {
    return this.onBeforeRenderObservable.removeCallback(e), this;
  }
  registerAfterRender(e) {
    return this.onAfterRenderObservable.add(e), this;
  }
  unregisterAfterRender(e) {
    return this.onAfterRenderObservable.removeCallback(e), this;
  }
  _getInstancesRenderList(e, t = !1) {
    if (this._instanceDataStorage.isFrozen) {
      if (t)
        return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[e] = !1, this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[e] = !0, this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;
      if (this._instanceDataStorage.previousBatch)
        return this._instanceDataStorage.previousBatch;
    }
    const i = this.getScene(), s = i._isInIntermediateRendering(), r = s ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances, n = this._instanceDataStorage.batchCache;
    if (n.mustReturn = !1, n.renderSelf[e] = t || !r && this.isEnabled() && this.isVisible, n.visibleInstances[e] = null, this._instanceDataStorage.visibleInstances && !t) {
      const a = this._instanceDataStorage.visibleInstances, o = i.getRenderId(), h = s ? a.intermediateDefaultRenderId : a.defaultRenderId;
      n.visibleInstances[e] = a[o], !n.visibleInstances[e] && h && (n.visibleInstances[e] = a[h]);
    }
    return n.hardwareInstancedRendering[e] = !t && this._instanceDataStorage.hardwareInstancedRendering && n.visibleInstances[e] !== null && n.visibleInstances[e] !== void 0, this._instanceDataStorage.previousBatch = n, n;
  }
  _renderWithInstances(e, t, i, s, r) {
    var T;
    const n = i.visibleInstances[e._id];
    if (!n)
      return this;
    const a = this._instanceDataStorage, o = a.instancesBufferSize;
    let h = a.instancesBuffer, l = a.instancesPreviousBuffer;
    const f = (n.length + 1) * 16 * 4;
    for (; a.instancesBufferSize < f; )
      a.instancesBufferSize *= 2;
    (!a.instancesData || o != a.instancesBufferSize) && (a.instancesData = new Float32Array(a.instancesBufferSize / 4)), (this._scene.needsPreviousWorldMatrices && !a.instancesPreviousData || o != a.instancesBufferSize) && (a.instancesPreviousData = new Float32Array(a.instancesBufferSize / 4));
    let d = 0, _ = 0;
    const E = i.renderSelf[e._id], m = !h || o !== a.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !a.instancesPreviousBuffer;
    if (!this._instanceDataStorage.manualUpdate && (!a.isFrozen || m)) {
      const b = this.getWorldMatrix();
      if (E && (this._scene.needsPreviousWorldMatrices && (a.masterMeshPreviousWorldMatrix ? (a.masterMeshPreviousWorldMatrix.copyToArray(a.instancesPreviousData, d), a.masterMeshPreviousWorldMatrix.copyFrom(b)) : (a.masterMeshPreviousWorldMatrix = b.clone(), a.masterMeshPreviousWorldMatrix.copyToArray(a.instancesPreviousData, d))), b.copyToArray(a.instancesData, d), d += 16, _++), n) {
        if (k.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && ((T = e.getMaterial()) == null ? void 0 : T.needAlphaBlendingForMesh(e.getRenderingMesh()))) {
          const R = this._scene.activeCamera.globalPosition;
          for (let y = 0; y < n.length; y++) {
            const P = n[y];
            P._distanceToCamera = g.Distance(P.getBoundingInfo().boundingSphere.centerWorld, R);
          }
          n.sort((y, P) => y._distanceToCamera > P._distanceToCamera ? -1 : y._distanceToCamera < P._distanceToCamera ? 1 : 0);
        }
        for (let R = 0; R < n.length; R++) {
          const y = n[R], P = y.getWorldMatrix();
          P.copyToArray(a.instancesData, d), this._scene.needsPreviousWorldMatrices && (y._previousWorldMatrix ? (y._previousWorldMatrix.copyToArray(a.instancesPreviousData, d), y._previousWorldMatrix.copyFrom(P)) : (y._previousWorldMatrix = P.clone(), y._previousWorldMatrix.copyToArray(a.instancesPreviousData, d))), d += 16, _++;
        }
      }
    } else
      _ = (E ? 1 : 0) + n.length;
    return m ? (h && h.dispose(), l && l.dispose(), h = new ji(r, a.instancesData, !0, 16, !1, !0), a.instancesBuffer = h, this._userInstancedBuffersStorage || (this._userInstancedBuffersStorage = {
      data: {},
      vertexBuffers: {},
      strides: {},
      sizes: {},
      vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
    }), this._userInstancedBuffersStorage.vertexBuffers.world0 = h.createVertexBuffer("world0", 0, 4), this._userInstancedBuffersStorage.vertexBuffers.world1 = h.createVertexBuffer("world1", 4, 4), this._userInstancedBuffersStorage.vertexBuffers.world2 = h.createVertexBuffer("world2", 8, 4), this._userInstancedBuffersStorage.vertexBuffers.world3 = h.createVertexBuffer("world3", 12, 4), this._scene.needsPreviousWorldMatrices && (l = new ji(r, a.instancesPreviousData, !0, 16, !1, !0), a.instancesPreviousBuffer = l, this._userInstancedBuffersStorage.vertexBuffers.previousWorld0 = l.createVertexBuffer("previousWorld0", 0, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld1 = l.createVertexBuffer("previousWorld1", 4, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld2 = l.createVertexBuffer("previousWorld2", 8, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld3 = l.createVertexBuffer("previousWorld3", 12, 4)), this._invalidateInstanceVertexArrayObject()) : this._instanceDataStorage.isFrozen || (h.updateDirectly(a.instancesData, 0, _), this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate) && l.updateDirectly(a.instancesPreviousData, 0, _)), this._processInstancedBuffers(n, E), this.getScene()._activeIndices.addCount(e.indexCount * _, !1), r._currentDrawContext && (r._currentDrawContext.useInstancing = !0), this._bind(e, s, t), this._draw(e, t, _), this._scene.needsPreviousWorldMatrices && !m && this._instanceDataStorage.manualUpdate && !this._instanceDataStorage.isFrozen && !this._instanceDataStorage.previousManualUpdate && l.updateDirectly(a.instancesData, 0, _), r.unbindInstanceAttributes(), this;
  }
  _renderWithThinInstances(e, t, i, s) {
    var n, a;
    const r = (a = (n = this._thinInstanceDataStorage) == null ? void 0 : n.instancesCount) != null ? a : 0;
    this.getScene()._activeIndices.addCount(e.indexCount * r, !1), s._currentDrawContext && (s._currentDrawContext.useInstancing = !0), this._bind(e, i, t), this._draw(e, t, r), this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData && (this._thinInstanceDataStorage.previousMatrixBuffer ? this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, r) : this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.matrixData, !1)), s.unbindInstanceAttributes();
  }
  _processInstancedBuffers(e, t) {
  }
  _processRendering(e, t, i, s, r, n, a, o) {
    const h = this.getScene(), l = h.getEngine();
    if (n && t.getRenderingMesh().hasThinInstances)
      return this._renderWithThinInstances(t, s, i, l), this;
    if (n)
      this._renderWithInstances(t, s, r, i, l);
    else {
      l._currentDrawContext && (l._currentDrawContext.useInstancing = !1);
      let u = 0;
      r.renderSelf[t._id] && (a && a(!1, e.getWorldMatrix(), o), u++, this._draw(t, s, this._instanceDataStorage.overridenInstanceCount));
      const f = r.visibleInstances[t._id];
      if (f) {
        const d = f.length;
        u += d;
        for (let _ = 0; _ < d; _++) {
          const m = f[_].getWorldMatrix();
          a && a(!0, m, o), this._draw(t, s);
        }
      }
      h._activeIndices.addCount(t.indexCount * u, !1);
    }
    return this;
  }
  _rebuild(e = !1) {
    if (this._instanceDataStorage.instancesBuffer && (e && this._instanceDataStorage.instancesBuffer.dispose(), this._instanceDataStorage.instancesBuffer = null), this._userInstancedBuffersStorage) {
      for (const t in this._userInstancedBuffersStorage.vertexBuffers) {
        const i = this._userInstancedBuffersStorage.vertexBuffers[t];
        i && (e && i.dispose(), this._userInstancedBuffersStorage.vertexBuffers[t] = null);
      }
      this._userInstancedBuffersStorage.vertexArrayObjects && (this._userInstancedBuffersStorage.vertexArrayObjects = {});
    }
    this._internalMeshDataInfo._effectiveMaterial = null, super._rebuild(e);
  }
  _freeze() {
    if (!!this.subMeshes) {
      for (let e = 0; e < this.subMeshes.length; e++)
        this._getInstancesRenderList(e);
      this._internalMeshDataInfo._effectiveMaterial = null, this._instanceDataStorage.isFrozen = !0;
    }
  }
  _unFreeze() {
    this._instanceDataStorage.isFrozen = !1, this._instanceDataStorage.previousBatch = null;
  }
  render(e, t, i) {
    var y, P, v;
    const s = this.getScene();
    if (this._internalAbstractMeshDataInfo._isActiveIntermediate ? this._internalAbstractMeshDataInfo._isActiveIntermediate = !1 : this._internalAbstractMeshDataInfo._isActive = !1, this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded)
      return this;
    const r = this._getInstancesRenderList(e._id, !!i);
    if (r.mustReturn)
      return this;
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer())
      return this;
    const n = s.getEngine();
    let a = 0, o = null;
    this.ignoreCameraMaxZ && s.activeCamera && !s._isInIntermediateRendering() && (a = s.activeCamera.maxZ, o = s.activeCamera, s.activeCamera.maxZ = 0, s.updateTransformMatrix(!0)), this._internalMeshDataInfo._onBeforeRenderObservable && this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);
    const h = r.hardwareInstancedRendering[e._id] || e.getRenderingMesh().hasThinInstances, l = this._instanceDataStorage, u = e.getMaterial();
    if (!u)
      return o && (o.maxZ = a, s.updateTransformMatrix(!0)), this;
    if (!l.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== u) {
      if (u._storeEffectOnSubMeshes) {
        if (!u.isReadyForSubMesh(this, e, h))
          return o && (o.maxZ = a, s.updateTransformMatrix(!0)), this;
      } else if (!u.isReady(this, h))
        return o && (o.maxZ = a, s.updateTransformMatrix(!0)), this;
      this._internalMeshDataInfo._effectiveMaterial = u;
    } else if (u._storeEffectOnSubMeshes && !((y = e.effect) != null && y._wasPreviouslyReady) || !u._storeEffectOnSubMeshes && !((P = u.getEffect()) != null && P._wasPreviouslyReady))
      return o && (o.maxZ = a, s.updateTransformMatrix(!0)), this;
    t && n.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);
    let f;
    this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes ? f = e._drawWrapper : f = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();
    const d = (v = f == null ? void 0 : f.effect) != null ? v : null;
    for (const A of s._beforeRenderingMeshStage)
      A.action(this, e, r, d);
    if (!f || !d)
      return o && (o.maxZ = a, s.updateTransformMatrix(!0)), this;
    const _ = i || this;
    let E;
    if (!l.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {
      const A = _._getWorldMatrixDeterminant();
      E = this.overrideMaterialSideOrientation, E == null && (E = this._internalMeshDataInfo._effectiveMaterial.sideOrientation), A < 0 && (E = E === I.ClockWiseSideOrientation ? I.CounterClockWiseSideOrientation : I.ClockWiseSideOrientation), l.sideOrientation = E;
    } else
      E = l.sideOrientation;
    const m = this._internalMeshDataInfo._effectiveMaterial._preBind(f, E);
    this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite && n.setDepthWrite(!0);
    const T = s.forcePointsCloud ? I.PointFillMode : s.forceWireframe ? I.WireFrameFillMode : this._internalMeshDataInfo._effectiveMaterial.fillMode;
    this._internalMeshDataInfo._onBeforeBindObservable && this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this), h || this._bind(e, d, T);
    const b = this._internalMeshDataInfo._effectiveMaterial, R = _.getWorldMatrix();
    b._storeEffectOnSubMeshes ? b.bindForSubMesh(R, this, e) : b.bind(R, this), !b.backFaceCulling && b.separateCullingPass && (n.setState(!0, b.zOffset, !1, !m, b.cullBackFaces, b.stencil, b.zOffsetUnits), this._processRendering(this, e, d, T, r, h, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial), n.setState(!0, b.zOffset, !1, m, b.cullBackFaces, b.stencil, b.zOffsetUnits), this._internalMeshDataInfo._onBetweenPassObservable && this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(e)), this._processRendering(this, e, d, T, r, h, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial), this._internalMeshDataInfo._effectiveMaterial.unbind();
    for (const A of s._afterRenderingMeshStage)
      A.action(this, e, r, d);
    return this._internalMeshDataInfo._onAfterRenderObservable && this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this), o && (o.maxZ = a, s.updateTransformMatrix(!0)), this;
  }
  cleanMatrixWeights() {
    this.isVerticesDataPresent(p.MatricesWeightsKind) && (this.isVerticesDataPresent(p.MatricesWeightsExtraKind) ? this._normalizeSkinWeightsAndExtra() : this._normalizeSkinFourWeights());
  }
  _normalizeSkinFourWeights() {
    const e = this.getVerticesData(p.MatricesWeightsKind), t = e.length;
    for (let i = 0; i < t; i += 4) {
      const s = e[i] + e[i + 1] + e[i + 2] + e[i + 3];
      if (s === 0)
        e[i] = 1;
      else {
        const r = 1 / s;
        e[i] *= r, e[i + 1] *= r, e[i + 2] *= r, e[i + 3] *= r;
      }
    }
    this.setVerticesData(p.MatricesWeightsKind, e);
  }
  _normalizeSkinWeightsAndExtra() {
    const e = this.getVerticesData(p.MatricesWeightsExtraKind), t = this.getVerticesData(p.MatricesWeightsKind), i = t.length;
    for (let s = 0; s < i; s += 4) {
      let r = t[s] + t[s + 1] + t[s + 2] + t[s + 3];
      if (r += e[s] + e[s + 1] + e[s + 2] + e[s + 3], r === 0)
        t[s] = 1;
      else {
        const n = 1 / r;
        t[s] *= n, t[s + 1] *= n, t[s + 2] *= n, t[s + 3] *= n, e[s] *= n, e[s + 1] *= n, e[s + 2] *= n, e[s + 3] *= n;
      }
    }
    this.setVerticesData(p.MatricesWeightsKind, t), this.setVerticesData(p.MatricesWeightsKind, e);
  }
  validateSkinning() {
    const e = this.getVerticesData(p.MatricesWeightsExtraKind), t = this.getVerticesData(p.MatricesWeightsKind);
    if (t === null || this.skeleton == null)
      return { skinned: !1, valid: !0, report: "not skinned" };
    const i = t.length;
    let s = 0, r = 0, n = 0, a = 0;
    const o = e === null ? 4 : 8, h = new Array();
    for (let m = 0; m <= o; m++)
      h[m] = 0;
    const l = 1e-3;
    for (let m = 0; m < i; m += 4) {
      let T = t[m], b = T, R = b === 0 ? 0 : 1;
      for (let y = 1; y < o; y++) {
        const P = y < 4 ? t[m + y] : e[m + y - 4];
        P > T && s++, P !== 0 && R++, b += P, T = P;
      }
      if (h[R]++, R > n && (n = R), b === 0)
        r++;
      else {
        const y = 1 / b;
        let P = 0;
        for (let v = 0; v < o; v++)
          v < 4 ? P += Math.abs(t[m + v] - t[m + v] * y) : P += Math.abs(e[m + v - 4] - e[m + v - 4] * y);
        P > l && a++;
      }
    }
    const u = this.skeleton.bones.length, f = this.getVerticesData(p.MatricesIndicesKind), d = this.getVerticesData(p.MatricesIndicesExtraKind);
    let _ = 0;
    for (let m = 0; m < i; m += 4)
      for (let T = 0; T < o; T++) {
        const b = T < 4 ? f[m + T] : d[m + T - 4];
        (b >= u || b < 0) && _++;
      }
    const E = "Number of Weights = " + i / 4 + `
Maximum influences = ` + n + `
Missing Weights = ` + r + `
Not Sorted = ` + s + `
Not Normalized = ` + a + `
WeightCounts = [` + h + `]
Number of bones = ` + u + `
Bad Bone Indices = ` + _;
    return { skinned: !0, valid: r === 0 && a === 0 && _ === 0, report: E };
  }
  _checkDelayState() {
    const e = this.getScene();
    return this._geometry ? this._geometry.load(e) : this.delayLoadState === 4 && (this.delayLoadState = 2, this._queueLoad(e)), this;
  }
  _queueLoad(e) {
    e.addPendingData(this);
    const t = this.delayLoadingFile.indexOf(".babylonbinarymeshdata") !== -1;
    return U.LoadFile(this.delayLoadingFile, (i) => {
      i instanceof ArrayBuffer ? this._delayLoadingFunction(i, this) : this._delayLoadingFunction(JSON.parse(i), this), this.instances.forEach((s) => {
        s.refreshBoundingInfo(), s._syncSubMeshes();
      }), this.delayLoadState = 1, e.removePendingData(this);
    }, () => {
    }, e.offlineProvider, t), this;
  }
  isInFrustum(e) {
    return this.delayLoadState === 2 || !super.isInFrustum(e) ? !1 : (this._checkDelayState(), !0);
  }
  setMaterialById(e) {
    const t = this.getScene().materials;
    let i;
    for (i = t.length - 1; i > -1; i--)
      if (t[i].id === e)
        return this.material = t[i], this;
    const s = this.getScene().multiMaterials;
    for (i = s.length - 1; i > -1; i--)
      if (s[i].id === e)
        return this.material = s[i], this;
    return this;
  }
  getAnimatables() {
    const e = new Array();
    return this.material && e.push(this.material), this.skeleton && e.push(this.skeleton), e;
  }
  bakeTransformIntoVertices(e) {
    if (!this.isVerticesDataPresent(p.PositionKind))
      return this;
    const t = this.subMeshes.splice(0);
    this._resetPointsArrayCache();
    let i = this.getVerticesData(p.PositionKind), s = new Array(), r;
    for (r = 0; r < i.length; r += 3)
      g.TransformCoordinates(g.FromArray(i, r), e).toArray(s, r);
    if (this.setVerticesData(p.PositionKind, s, this.getVertexBuffer(p.PositionKind).isUpdatable()), this.isVerticesDataPresent(p.NormalKind)) {
      for (i = this.getVerticesData(p.NormalKind), s = [], r = 0; r < i.length; r += 3)
        g.TransformNormal(g.FromArray(i, r), e).normalize().toArray(s, r);
      this.setVerticesData(p.NormalKind, s, this.getVertexBuffer(p.NormalKind).isUpdatable());
    }
    return e.determinant() < 0 && this.flipFaces(), this.releaseSubMeshes(), this.subMeshes = t, this;
  }
  bakeCurrentTransformIntoVertices(e = !0) {
    return this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)), this.resetLocalMatrix(e), this;
  }
  get _positions() {
    return this._internalAbstractMeshDataInfo._positions ? this._internalAbstractMeshDataInfo._positions : this._geometry ? this._geometry._positions : null;
  }
  _resetPointsArrayCache() {
    return this._geometry && this._geometry._resetPointsArrayCache(), this;
  }
  _generatePointsArray() {
    return this._geometry ? this._geometry._generatePointsArray() : !1;
  }
  clone(e = "", t = null, i, s = !0) {
    return new k(e, this.getScene(), t, this, i, s);
  }
  dispose(e, t = !1) {
    this.morphTargetManager = null, this._geometry && this._geometry.releaseForMesh(this, !0);
    const i = this._internalMeshDataInfo;
    if (i._onBeforeDrawObservable && i._onBeforeDrawObservable.clear(), i._onBeforeBindObservable && i._onBeforeBindObservable.clear(), i._onBeforeRenderObservable && i._onBeforeRenderObservable.clear(), i._onAfterRenderObservable && i._onAfterRenderObservable.clear(), i._onBetweenPassObservable && i._onBetweenPassObservable.clear(), this._scene.useClonedMeshMap) {
      if (i.meshMap)
        for (const s in i.meshMap) {
          const r = i.meshMap[s];
          r && (r._internalMeshDataInfo._source = null, i.meshMap[s] = void 0);
        }
      i._source && i._source._internalMeshDataInfo.meshMap && (i._source._internalMeshDataInfo.meshMap[this.uniqueId] = void 0);
    } else {
      const s = this.getScene().meshes;
      for (const r of s) {
        const n = r;
        n._internalMeshDataInfo && n._internalMeshDataInfo._source && n._internalMeshDataInfo._source === this && (n._internalMeshDataInfo._source = null);
      }
    }
    i._source = null, this._disposeInstanceSpecificData(), this._disposeThinInstanceSpecificData(), this._internalMeshDataInfo._checkReadinessObserver && this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver), super.dispose(e, t);
  }
  _disposeInstanceSpecificData() {
  }
  _disposeThinInstanceSpecificData() {
  }
  _invalidateInstanceVertexArrayObject() {
  }
  applyDisplacementMap(e, t, i, s, r, n, a = !1) {
    const o = this.getScene(), h = (l) => {
      const u = l.width, f = l.height, _ = this.getEngine().createCanvas(u, f).getContext("2d");
      _.drawImage(l, 0, 0);
      const E = _.getImageData(0, 0, u, f).data;
      this.applyDisplacementMapFromBuffer(E, u, f, t, i, r, n, a), s && s(this);
    };
    return U.LoadImage(e, h, () => {
    }, o.offlineProvider), this;
  }
  applyDisplacementMapFromBuffer(e, t, i, s, r, n, a, o = !1) {
    if (!this.isVerticesDataPresent(p.PositionKind) || !this.isVerticesDataPresent(p.NormalKind) || !this.isVerticesDataPresent(p.UVKind))
      return w.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing"), this;
    const h = this.getVerticesData(p.PositionKind, !0, !0), l = this.getVerticesData(p.NormalKind), u = this.getVerticesData(p.UVKind);
    let f = g.Zero();
    const d = g.Zero(), _ = ee.Zero();
    n = n || ee.Zero(), a = a || new ee(1, 1);
    for (let E = 0; E < h.length; E += 3) {
      g.FromArrayToRef(h, E, f), g.FromArrayToRef(l, E, d), ee.FromArrayToRef(u, E / 3 * 2, _);
      const m = Math.abs(_.x * a.x + n.x % 1) * (t - 1) % t | 0, T = Math.abs(_.y * a.y + n.y % 1) * (i - 1) % i | 0, b = (m + T * t) * 4, R = e[b] / 255, y = e[b + 1] / 255, P = e[b + 2] / 255, v = R * 0.3 + y * 0.59 + P * 0.11;
      d.normalize(), d.scaleInPlace(s + (r - s) * v), f = f.add(d), f.toArray(h, E);
    }
    return Z.ComputeNormals(h, this.getIndices(), l), o ? (this.setVerticesData(p.PositionKind, h), this.setVerticesData(p.NormalKind, l), this.setVerticesData(p.UVKind, u)) : (this.updateVerticesData(p.PositionKind, h), this.updateVerticesData(p.NormalKind, l)), this;
  }
  convertToFlatShadedMesh() {
    const e = this.getVerticesDataKinds(), t = {}, i = {}, s = {};
    let r = !1, n, a;
    for (n = 0; n < e.length; n++) {
      a = e[n];
      const m = this.getVertexBuffer(a), T = m.getData();
      if (!((T instanceof Array || T instanceof Float32Array) && T.length === 0)) {
        if (a === p.NormalKind) {
          r = m.isUpdatable(), e.splice(n, 1), n--;
          continue;
        }
        t[a] = m, i[a] = this.getVerticesData(a), s[a] = [];
      }
    }
    const o = this.subMeshes.slice(0), h = this.getIndices(), l = this.getTotalIndices();
    let u;
    for (u = 0; u < l; u++) {
      const m = h[u];
      for (n = 0; n < e.length; n++) {
        if (a = e[n], !t[a])
          continue;
        const T = t[a].getStrideSize();
        for (let b = 0; b < T; b++)
          s[a].push(i[a][m * T + b]);
      }
    }
    const f = [], d = s[p.PositionKind], _ = this.getScene().useRightHandedSystem;
    let E;
    for (_ ? E = this.overrideMaterialSideOrientation === 1 : E = this.overrideMaterialSideOrientation === 0, u = 0; u < l; u += 3) {
      h[u] = u, h[u + 1] = u + 1, h[u + 2] = u + 2;
      const m = g.FromArray(d, u * 3), T = g.FromArray(d, (u + 1) * 3), b = g.FromArray(d, (u + 2) * 3), R = m.subtract(T), y = b.subtract(T), P = g.Normalize(g.Cross(R, y));
      E && P.scaleInPlace(-1);
      for (let v = 0; v < 3; v++)
        f.push(P.x), f.push(P.y), f.push(P.z);
    }
    for (this.setIndices(h), this.setVerticesData(p.NormalKind, f, r), n = 0; n < e.length; n++)
      a = e[n], s[a] && this.setVerticesData(a, s[a], t[a].isUpdatable());
    this.releaseSubMeshes();
    for (let m = 0; m < o.length; m++) {
      const T = o[m];
      mt.AddToMesh(T.materialIndex, T.indexStart, T.indexCount, T.indexStart, T.indexCount, this);
    }
    return this.synchronizeInstances(), this;
  }
  convertToUnIndexedMesh() {
    const e = this.getVerticesDataKinds(), t = {}, i = {}, s = {};
    let r, n;
    for (r = 0; r < e.length; r++) {
      n = e[r];
      const u = this.getVertexBuffer(n);
      t[n] = u, i[n] = t[n].getData(), s[n] = [];
    }
    const a = this.subMeshes.slice(0), o = this.getIndices(), h = this.getTotalIndices();
    let l;
    for (l = 0; l < h; l++) {
      const u = o[l];
      for (r = 0; r < e.length; r++) {
        n = e[r];
        const f = t[n].getStrideSize();
        for (let d = 0; d < f; d++)
          s[n].push(i[n][u * f + d]);
      }
    }
    for (l = 0; l < h; l += 3)
      o[l] = l, o[l + 1] = l + 1, o[l + 2] = l + 2;
    for (this.setIndices(o), r = 0; r < e.length; r++)
      n = e[r], this.setVerticesData(n, s[n], t[n].isUpdatable(), t[n].getStrideSize());
    this.releaseSubMeshes();
    for (let u = 0; u < a.length; u++) {
      const f = a[u];
      mt.AddToMesh(f.materialIndex, f.indexStart, f.indexCount, f.indexStart, f.indexCount, this);
    }
    return this._unIndexed = !0, this.synchronizeInstances(), this;
  }
  flipFaces(e = !1) {
    const t = Z.ExtractFromMesh(this);
    let i;
    if (e && this.isVerticesDataPresent(p.NormalKind) && t.normals)
      for (i = 0; i < t.normals.length; i++)
        t.normals[i] *= -1;
    if (t.indices) {
      let s;
      for (i = 0; i < t.indices.length; i += 3)
        s = t.indices[i + 1], t.indices[i + 1] = t.indices[i + 2], t.indices[i + 2] = s;
    }
    return t.applyToMesh(this, this.isVertexBufferUpdatable(p.PositionKind)), this;
  }
  increaseVertices(e = 1) {
    const t = Z.ExtractFromMesh(this), i = t.indices && !Array.isArray(t.indices) && Array.from ? Array.from(t.indices) : t.indices, s = t.positions && !Array.isArray(t.positions) && Array.from ? Array.from(t.positions) : t.positions, r = t.uvs && !Array.isArray(t.uvs) && Array.from ? Array.from(t.uvs) : t.uvs, n = t.normals && !Array.isArray(t.normals) && Array.from ? Array.from(t.normals) : t.normals;
    if (!i || !s)
      w.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions");
    else {
      t.indices = i, t.positions = s, r && (t.uvs = r), n && (t.normals = n);
      const a = e + 1, o = new Array();
      for (let P = 0; P < a + 1; P++)
        o[P] = new Array();
      let h, l;
      const u = new g(0, 0, 0), f = new g(0, 0, 0), d = new ee(0, 0), _ = new Array(), E = new Array(), m = new Array();
      let T, b = s.length, R;
      r && (R = r.length);
      let y;
      n && (y = n.length);
      for (let P = 0; P < i.length; P += 3) {
        E[0] = i[P], E[1] = i[P + 1], E[2] = i[P + 2];
        for (let v = 0; v < 3; v++)
          if (h = E[v], l = E[(v + 1) % 3], m[h] === void 0 && m[l] === void 0 ? (m[h] = new Array(), m[l] = new Array()) : (m[h] === void 0 && (m[h] = new Array()), m[l] === void 0 && (m[l] = new Array())), m[h][l] === void 0 && m[l][h] === void 0) {
            m[h][l] = [], u.x = (s[3 * l] - s[3 * h]) / a, u.y = (s[3 * l + 1] - s[3 * h + 1]) / a, u.z = (s[3 * l + 2] - s[3 * h + 2]) / a, n && (f.x = (n[3 * l] - n[3 * h]) / a, f.y = (n[3 * l + 1] - n[3 * h + 1]) / a, f.z = (n[3 * l + 2] - n[3 * h + 2]) / a), r && (d.x = (r[2 * l] - r[2 * h]) / a, d.y = (r[2 * l + 1] - r[2 * h + 1]) / a), m[h][l].push(h);
            for (let A = 1; A < a; A++)
              m[h][l].push(s.length / 3), s[b++] = s[3 * h] + A * u.x, s[b++] = s[3 * h + 1] + A * u.y, s[b++] = s[3 * h + 2] + A * u.z, n && (n[y++] = n[3 * h] + A * f.x, n[y++] = n[3 * h + 1] + A * f.y, n[y++] = n[3 * h + 2] + A * f.z), r && (r[R++] = r[2 * h] + A * d.x, r[R++] = r[2 * h + 1] + A * d.y);
            m[h][l].push(l), m[l][h] = new Array(), T = m[h][l].length;
            for (let A = 0; A < T; A++)
              m[l][h][A] = m[h][l][T - 1 - A];
          }
        o[0][0] = i[P], o[1][0] = m[i[P]][i[P + 1]][1], o[1][1] = m[i[P]][i[P + 2]][1];
        for (let v = 2; v < a; v++) {
          o[v][0] = m[i[P]][i[P + 1]][v], o[v][v] = m[i[P]][i[P + 2]][v], u.x = (s[3 * o[v][v]] - s[3 * o[v][0]]) / v, u.y = (s[3 * o[v][v] + 1] - s[3 * o[v][0] + 1]) / v, u.z = (s[3 * o[v][v] + 2] - s[3 * o[v][0] + 2]) / v, n && (f.x = (n[3 * o[v][v]] - n[3 * o[v][0]]) / v, f.y = (n[3 * o[v][v] + 1] - n[3 * o[v][0] + 1]) / v, f.z = (n[3 * o[v][v] + 2] - n[3 * o[v][0] + 2]) / v), r && (d.x = (r[2 * o[v][v]] - r[2 * o[v][0]]) / v, d.y = (r[2 * o[v][v] + 1] - r[2 * o[v][0] + 1]) / v);
          for (let A = 1; A < v; A++)
            o[v][A] = s.length / 3, s[b++] = s[3 * o[v][0]] + A * u.x, s[b++] = s[3 * o[v][0] + 1] + A * u.y, s[b++] = s[3 * o[v][0] + 2] + A * u.z, n && (n[y++] = n[3 * o[v][0]] + A * f.x, n[y++] = n[3 * o[v][0] + 1] + A * f.y, n[y++] = n[3 * o[v][0] + 2] + A * f.z), r && (r[R++] = r[2 * o[v][0]] + A * d.x, r[R++] = r[2 * o[v][0] + 1] + A * d.y);
        }
        o[a] = m[i[P + 1]][i[P + 2]], _.push(o[0][0], o[1][0], o[1][1]);
        for (let v = 1; v < a; v++) {
          let A;
          for (A = 0; A < v; A++)
            _.push(o[v][A], o[v + 1][A], o[v + 1][A + 1]), _.push(o[v][A], o[v + 1][A + 1], o[v][A + 1]);
          _.push(o[v][A], o[v + 1][A], o[v + 1][A + 1]);
        }
      }
      t.indices = _, t.applyToMesh(this, this.isVertexBufferUpdatable(p.PositionKind));
    }
  }
  forceSharedVertices() {
    const e = Z.ExtractFromMesh(this), t = e.uvs, i = e.indices, s = e.positions, r = e.colors;
    if (i === void 0 || s === void 0 || i === null || s === null)
      w.Warn("VertexData contains empty entries");
    else {
      const n = new Array(), a = new Array(), o = new Array(), h = new Array();
      let l = new Array(), u = 0;
      const f = {};
      let d, _;
      for (let m = 0; m < i.length; m += 3) {
        _ = [i[m], i[m + 1], i[m + 2]], l = new Array();
        for (let T = 0; T < 3; T++) {
          l[T] = "";
          for (let b = 0; b < 3; b++)
            Math.abs(s[3 * _[T] + b]) < 1e-8 && (s[3 * _[T] + b] = 0), l[T] += s[3 * _[T] + b] + "|";
        }
        if (!(l[0] == l[1] || l[0] == l[2] || l[1] == l[2]))
          for (let T = 0; T < 3; T++) {
            if (d = f[l[T]], d === void 0) {
              f[l[T]] = u, d = u++;
              for (let b = 0; b < 3; b++)
                n.push(s[3 * _[T] + b]);
              if (r != null)
                for (let b = 0; b < 4; b++)
                  h.push(r[4 * _[T] + b]);
              if (t != null)
                for (let b = 0; b < 2; b++)
                  o.push(t[2 * _[T] + b]);
            }
            a.push(d);
          }
      }
      const E = new Array();
      Z.ComputeNormals(n, a, E), e.positions = n, e.indices = a, e.normals = E, t != null && (e.uvs = o), r != null && (e.colors = h), e.applyToMesh(this, this.isVertexBufferUpdatable(p.PositionKind));
    }
  }
  static _instancedMeshFactory(e, t) {
    throw q("InstancedMesh");
  }
  static _PhysicsImpostorParser(e, t, i) {
    throw q("PhysicsImpostor");
  }
  createInstance(e) {
    return k._instancedMeshFactory(e, this);
  }
  synchronizeInstances() {
    for (let e = 0; e < this.instances.length; e++)
      this.instances[e]._syncSubMeshes();
    return this;
  }
  optimizeIndices(e) {
    const t = this.getIndices(), i = this.getVerticesData(p.PositionKind);
    if (!i || !t)
      return this;
    const s = new Array();
    for (let n = 0; n < i.length; n = n + 3)
      s.push(g.FromArray(i, n));
    const r = new Array();
    return qi.SyncAsyncForLoop(s.length, 40, (n) => {
      const a = s.length - 1 - n, o = s[a];
      for (let h = 0; h < a; ++h) {
        const l = s[h];
        if (o.equals(l)) {
          r[a] = h;
          break;
        }
      }
    }, () => {
      for (let a = 0; a < t.length; ++a)
        t[a] = r[t[a]] || t[a];
      const n = this.subMeshes.slice(0);
      this.setIndices(t), this.subMeshes = n, e && e(this);
    }), this;
  }
  serialize(e) {
    e.name = this.name, e.id = this.id, e.uniqueId = this.uniqueId, e.type = this.getClassName(), pe && pe.HasTags(this) && (e.tags = pe.GetTags(this)), e.position = this.position.asArray(), this.rotationQuaternion ? e.rotationQuaternion = this.rotationQuaternion.asArray() : this.rotation && (e.rotation = this.rotation.asArray()), e.scaling = this.scaling.asArray(), this._postMultiplyPivotMatrix ? e.pivotMatrix = this.getPivotMatrix().asArray() : e.localMatrix = this.getPivotMatrix().asArray(), e.isEnabled = this.isEnabled(!1), e.isVisible = this.isVisible, e.infiniteDistance = this.infiniteDistance, e.pickable = this.isPickable, e.receiveShadows = this.receiveShadows, e.billboardMode = this.billboardMode, e.visibility = this.visibility, e.checkCollisions = this.checkCollisions, e.isBlocker = this.isBlocker, e.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation, this.parent && this.parent._serializeAsParent(e), e.isUnIndexed = this.isUnIndexed;
    const t = this._geometry;
    if (t && this.subMeshes) {
      e.geometryUniqueId = t.uniqueId, e.geometryId = t.id, e.subMeshes = [];
      for (let i = 0; i < this.subMeshes.length; i++) {
        const s = this.subMeshes[i];
        e.subMeshes.push({
          materialIndex: s.materialIndex,
          verticesStart: s.verticesStart,
          verticesCount: s.verticesCount,
          indexStart: s.indexStart,
          indexCount: s.indexCount
        });
      }
    }
    if (this.material ? this.material.doNotSerialize || (e.materialUniqueId = this.material.uniqueId, e.materialId = this.material.id) : (this.material = null, e.materialUniqueId = this._scene.defaultMaterial.uniqueId, e.materialId = this._scene.defaultMaterial.id), this.morphTargetManager && (e.morphTargetManagerId = this.morphTargetManager.uniqueId), this.skeleton && (e.skeletonId = this.skeleton.id, e.numBoneInfluencers = this.numBoneInfluencers), this.getScene()._getComponent(j.NAME_PHYSICSENGINE)) {
      const i = this.getPhysicsImpostor();
      i && (e.physicsMass = i.getParam("mass"), e.physicsFriction = i.getParam("friction"), e.physicsRestitution = i.getParam("mass"), e.physicsImpostor = i.type);
    }
    this.metadata && (e.metadata = this.metadata), e.instances = [];
    for (let i = 0; i < this.instances.length; i++) {
      const s = this.instances[i];
      if (s.doNotSerialize)
        continue;
      const r = {
        name: s.name,
        id: s.id,
        isEnabled: s.isEnabled(!1),
        isVisible: s.isVisible,
        isPickable: s.isPickable,
        checkCollisions: s.checkCollisions,
        position: s.position.asArray(),
        scaling: s.scaling.asArray()
      };
      if (s.parent && s.parent._serializeAsParent(r), s.rotationQuaternion ? r.rotationQuaternion = s.rotationQuaternion.asArray() : s.rotation && (r.rotation = s.rotation.asArray()), this.getScene()._getComponent(j.NAME_PHYSICSENGINE)) {
        const n = s.getPhysicsImpostor();
        n && (r.physicsMass = n.getParam("mass"), r.physicsFriction = n.getParam("friction"), r.physicsRestitution = n.getParam("mass"), r.physicsImpostor = n.type);
      }
      s.metadata && (r.metadata = s.metadata), e.instances.push(r), ne.AppendSerializedAnimations(s, r), r.ranges = s.serializeAnimationRanges();
    }
    if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData && (e.thinInstances = {
      instancesCount: this._thinInstanceDataStorage.instancesCount,
      matrixData: Array.from(this._thinInstanceDataStorage.matrixData),
      matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,
      enablePicking: this.thinInstanceEnablePicking
    }, this._userThinInstanceBuffersStorage)) {
      const i = {
        data: {},
        sizes: {},
        strides: {}
      };
      for (const s in this._userThinInstanceBuffersStorage.data)
        i.data[s] = Array.from(this._userThinInstanceBuffersStorage.data[s]), i.sizes[s] = this._userThinInstanceBuffersStorage.sizes[s], i.strides[s] = this._userThinInstanceBuffersStorage.strides[s];
      e.thinInstances.userThinInstance = i;
    }
    ne.AppendSerializedAnimations(this, e), e.ranges = this.serializeAnimationRanges(), e.layerMask = this.layerMask, e.alphaIndex = this.alphaIndex, e.hasVertexAlpha = this.hasVertexAlpha, e.overlayAlpha = this.overlayAlpha, e.overlayColor = this.overlayColor.asArray(), e.renderOverlay = this.renderOverlay, e.applyFog = this.applyFog, this.actionManager && (e.actions = this.actionManager.serialize(this.name));
  }
  _syncGeometryWithMorphTargetManager() {
    if (!this.geometry)
      return;
    this._markSubMeshesAsAttributesDirty();
    const e = this._internalAbstractMeshDataInfo._morphTargetManager;
    if (e && e.vertexCount) {
      if (e.vertexCount !== this.getTotalVertices()) {
        w.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count."), this.morphTargetManager = null;
        return;
      }
      if (e.isUsingTextureForTargets)
        return;
      for (let t = 0; t < e.numInfluencers; t++) {
        const i = e.getActiveTarget(t), s = i.getPositions();
        if (!s) {
          w.Error("Invalid morph target. Target must have positions.");
          return;
        }
        this.geometry.setVerticesData(p.PositionKind + t, s, !1, 3);
        const r = i.getNormals();
        r && this.geometry.setVerticesData(p.NormalKind + t, r, !1, 3);
        const n = i.getTangents();
        n && this.geometry.setVerticesData(p.TangentKind + t, n, !1, 3);
        const a = i.getUVs();
        a && this.geometry.setVerticesData(p.UVKind + "_" + t, a, !1, 2);
      }
    } else {
      let t = 0;
      for (; this.geometry.isVerticesDataPresent(p.PositionKind + t); )
        this.geometry.removeVerticesData(p.PositionKind + t), this.geometry.isVerticesDataPresent(p.NormalKind + t) && this.geometry.removeVerticesData(p.NormalKind + t), this.geometry.isVerticesDataPresent(p.TangentKind + t) && this.geometry.removeVerticesData(p.TangentKind + t), this.geometry.isVerticesDataPresent(p.UVKind + t) && this.geometry.removeVerticesData(p.UVKind + "_" + t), t++;
    }
  }
  static Parse(e, t, i) {
    let s;
    if (e.type && e.type === "LinesMesh" ? s = k._LinesMeshParser(e, t) : e.type && e.type === "GroundMesh" ? s = k._GroundMeshParser(e, t) : e.type && e.type === "GoldbergMesh" ? s = k._GoldbergMeshParser(e, t) : s = new k(e.name, t), s.id = e.id, s._waitingParsedUniqueId = e.uniqueId, pe && pe.AddTagsTo(s, e.tags), s.position = g.FromArray(e.position), e.metadata !== void 0 && (s.metadata = e.metadata), e.rotationQuaternion ? s.rotationQuaternion = z.FromArray(e.rotationQuaternion) : e.rotation && (s.rotation = g.FromArray(e.rotation)), s.scaling = g.FromArray(e.scaling), e.localMatrix ? s.setPreTransformMatrix(x.FromArray(e.localMatrix)) : e.pivotMatrix && s.setPivotMatrix(x.FromArray(e.pivotMatrix)), s.setEnabled(e.isEnabled), s.isVisible = e.isVisible, s.infiniteDistance = e.infiniteDistance, s.showBoundingBox = e.showBoundingBox, s.showSubMeshesBoundingBox = e.showSubMeshesBoundingBox, e.applyFog !== void 0 && (s.applyFog = e.applyFog), e.pickable !== void 0 && (s.isPickable = e.pickable), e.alphaIndex !== void 0 && (s.alphaIndex = e.alphaIndex), s.receiveShadows = e.receiveShadows, s.billboardMode = e.billboardMode, e.visibility !== void 0 && (s.visibility = e.visibility), s.checkCollisions = e.checkCollisions, s.overrideMaterialSideOrientation = e.overrideMaterialSideOrientation, e.isBlocker !== void 0 && (s.isBlocker = e.isBlocker), s._shouldGenerateFlatShading = e.useFlatShading, e.freezeWorldMatrix && (s._waitingData.freezeWorldMatrix = e.freezeWorldMatrix), e.parentId !== void 0 && (s._waitingParentId = e.parentId), e.parentInstanceIndex !== void 0 && (s._waitingParentInstanceIndex = e.parentInstanceIndex), e.actions !== void 0 && (s._waitingData.actions = e.actions), e.overlayAlpha !== void 0 && (s.overlayAlpha = e.overlayAlpha), e.overlayColor !== void 0 && (s.overlayColor = te.FromArray(e.overlayColor)), e.renderOverlay !== void 0 && (s.renderOverlay = e.renderOverlay), s.isUnIndexed = !!e.isUnIndexed, s.hasVertexAlpha = e.hasVertexAlpha, e.delayLoadingFile ? (s.delayLoadState = 4, s.delayLoadingFile = i + e.delayLoadingFile, s.buildBoundingInfo(g.FromArray(e.boundingBoxMinimum), g.FromArray(e.boundingBoxMaximum)), e._binaryInfo && (s._binaryInfo = e._binaryInfo), s._delayInfo = [], e.hasUVs && s._delayInfo.push(p.UVKind), e.hasUVs2 && s._delayInfo.push(p.UV2Kind), e.hasUVs3 && s._delayInfo.push(p.UV3Kind), e.hasUVs4 && s._delayInfo.push(p.UV4Kind), e.hasUVs5 && s._delayInfo.push(p.UV5Kind), e.hasUVs6 && s._delayInfo.push(p.UV6Kind), e.hasColors && s._delayInfo.push(p.ColorKind), e.hasMatricesIndices && s._delayInfo.push(p.MatricesIndicesKind), e.hasMatricesWeights && s._delayInfo.push(p.MatricesWeightsKind), s._delayLoadingFunction = nt._ImportGeometry, we.ForceFullSceneLoadingForIncremental && s._checkDelayState()) : nt._ImportGeometry(e, s), e.materialUniqueId ? s._waitingMaterialId = e.materialUniqueId : e.materialId && (s._waitingMaterialId = e.materialId), e.morphTargetManagerId > -1 && (s.morphTargetManager = t.getMorphTargetManagerById(e.morphTargetManagerId)), e.skeletonId !== void 0 && e.skeletonId !== null && (s.skeleton = t.getLastSkeletonById(e.skeletonId), e.numBoneInfluencers && (s.numBoneInfluencers = e.numBoneInfluencers)), e.animations) {
      for (let r = 0; r < e.animations.length; r++) {
        const n = e.animations[r], a = oi("BABYLON.Animation");
        a && s.animations.push(a.Parse(n));
      }
      Xe.ParseAnimationRanges(s, e, t);
    }
    if (e.autoAnimate && t.beginAnimation(s, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1), e.layerMask && !isNaN(e.layerMask) ? s.layerMask = Math.abs(parseInt(e.layerMask)) : s.layerMask = 268435455, e.physicsImpostor && k._PhysicsImpostorParser(t, s, e), e.lodMeshIds && (s._waitingData.lods = {
      ids: e.lodMeshIds,
      distances: e.lodDistances ? e.lodDistances : null,
      coverages: e.lodCoverages ? e.lodCoverages : null
    }), e.instances)
      for (let r = 0; r < e.instances.length; r++) {
        const n = e.instances[r], a = s.createInstance(n.name);
        if (n.id && (a.id = n.id), pe && (n.tags ? pe.AddTagsTo(a, n.tags) : pe.AddTagsTo(a, e.tags)), a.position = g.FromArray(n.position), n.metadata !== void 0 && (a.metadata = n.metadata), n.parentId !== void 0 && (a._waitingParentId = n.parentId), n.parentInstanceIndex !== void 0 && (a._waitingParentInstanceIndex = n.parentInstanceIndex), n.isEnabled !== void 0 && n.isEnabled !== null && a.setEnabled(n.isEnabled), n.isVisible !== void 0 && n.isVisible !== null && (a.isVisible = n.isVisible), n.isPickable !== void 0 && n.isPickable !== null && (a.isPickable = n.isPickable), n.rotationQuaternion ? a.rotationQuaternion = z.FromArray(n.rotationQuaternion) : n.rotation && (a.rotation = g.FromArray(n.rotation)), a.scaling = g.FromArray(n.scaling), n.checkCollisions != null && n.checkCollisions != null && (a.checkCollisions = n.checkCollisions), n.pickable != null && n.pickable != null && (a.isPickable = n.pickable), n.showBoundingBox != null && n.showBoundingBox != null && (a.showBoundingBox = n.showBoundingBox), n.showSubMeshesBoundingBox != null && n.showSubMeshesBoundingBox != null && (a.showSubMeshesBoundingBox = n.showSubMeshesBoundingBox), n.alphaIndex != null && n.showSubMeshesBoundingBox != null && (a.alphaIndex = n.alphaIndex), n.physicsImpostor && k._PhysicsImpostorParser(t, a, n), n.animations) {
          for (let o = 0; o < n.animations.length; o++) {
            const h = n.animations[o], l = oi("BABYLON.Animation");
            l && a.animations.push(l.Parse(h));
          }
          Xe.ParseAnimationRanges(a, n, t), n.autoAnimate && t.beginAnimation(a, n.autoAnimateFrom, n.autoAnimateTo, n.autoAnimateLoop, n.autoAnimateSpeed || 1);
        }
      }
    if (e.thinInstances) {
      const r = e.thinInstances;
      if (s.thinInstanceEnablePicking = !!r.enablePicking, r.matrixData ? (s.thinInstanceSetBuffer("matrix", new Float32Array(r.matrixData), 16, !1), s._thinInstanceDataStorage.matrixBufferSize = r.matrixBufferSize, s._thinInstanceDataStorage.instancesCount = r.instancesCount) : s._thinInstanceDataStorage.matrixBufferSize = r.matrixBufferSize, e.thinInstances.userThinInstance) {
        const n = e.thinInstances.userThinInstance;
        for (const a in n.data)
          s.thinInstanceSetBuffer(a, new Float32Array(n.data[a]), n.strides[a], !1), s._userThinInstanceBuffersStorage.sizes[a] = n.sizes[a];
      }
    }
    return s;
  }
  setPositionsForCPUSkinning() {
    const e = this._internalMeshDataInfo;
    if (!e._sourcePositions) {
      const t = this.getVerticesData(p.PositionKind);
      if (!t)
        return e._sourcePositions;
      e._sourcePositions = new Float32Array(t), this.isVertexBufferUpdatable(p.PositionKind) || this.setVerticesData(p.PositionKind, t, !0);
    }
    return e._sourcePositions;
  }
  setNormalsForCPUSkinning() {
    const e = this._internalMeshDataInfo;
    if (!e._sourceNormals) {
      const t = this.getVerticesData(p.NormalKind);
      if (!t)
        return e._sourceNormals;
      e._sourceNormals = new Float32Array(t), this.isVertexBufferUpdatable(p.NormalKind) || this.setVerticesData(p.NormalKind, t, !0);
    }
    return e._sourceNormals;
  }
  applySkeleton(e) {
    if (!this.geometry)
      return this;
    if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId())
      return this;
    if (this.geometry._softwareSkinningFrameId = this.getScene().getFrameId(), !this.isVerticesDataPresent(p.PositionKind))
      return this;
    if (!this.isVerticesDataPresent(p.MatricesIndicesKind))
      return this;
    if (!this.isVerticesDataPresent(p.MatricesWeightsKind))
      return this;
    const t = this.isVerticesDataPresent(p.NormalKind), i = this._internalMeshDataInfo;
    if (!i._sourcePositions) {
      const T = this.subMeshes.slice();
      this.setPositionsForCPUSkinning(), this.subMeshes = T;
    }
    t && !i._sourceNormals && this.setNormalsForCPUSkinning();
    let s = this.getVerticesData(p.PositionKind);
    if (!s)
      return this;
    s instanceof Float32Array || (s = new Float32Array(s));
    let r = this.getVerticesData(p.NormalKind);
    if (t) {
      if (!r)
        return this;
      r instanceof Float32Array || (r = new Float32Array(r));
    }
    const n = this.getVerticesData(p.MatricesIndicesKind), a = this.getVerticesData(p.MatricesWeightsKind);
    if (!a || !n)
      return this;
    const o = this.numBoneInfluencers > 4, h = o ? this.getVerticesData(p.MatricesIndicesExtraKind) : null, l = o ? this.getVerticesData(p.MatricesWeightsExtraKind) : null, u = e.getTransformMatrices(this), f = g.Zero(), d = new x(), _ = new x();
    let E = 0, m;
    for (let T = 0; T < s.length; T += 3, E += 4) {
      let b;
      for (m = 0; m < 4; m++)
        b = a[E + m], b > 0 && (x.FromFloat32ArrayToRefScaled(u, Math.floor(n[E + m] * 16), b, _), d.addToSelf(_));
      if (o)
        for (m = 0; m < 4; m++)
          b = l[E + m], b > 0 && (x.FromFloat32ArrayToRefScaled(u, Math.floor(h[E + m] * 16), b, _), d.addToSelf(_));
      g.TransformCoordinatesFromFloatsToRef(i._sourcePositions[T], i._sourcePositions[T + 1], i._sourcePositions[T + 2], d, f), f.toArray(s, T), t && (g.TransformNormalFromFloatsToRef(i._sourceNormals[T], i._sourceNormals[T + 1], i._sourceNormals[T + 2], d, f), f.toArray(r, T)), d.reset();
    }
    return this.updateVerticesData(p.PositionKind, s), t && this.updateVerticesData(p.NormalKind, r), this;
  }
  static MinMax(e) {
    let t = null, i = null;
    return e.forEach(function(s) {
      const n = s.getBoundingInfo().boundingBox;
      !t || !i ? (t = n.minimumWorld, i = n.maximumWorld) : (t.minimizeInPlace(n.minimumWorld), i.maximizeInPlace(n.maximumWorld));
    }), !t || !i ? {
      min: g.Zero(),
      max: g.Zero()
    } : {
      min: t,
      max: i
    };
  }
  static Center(e) {
    const t = e instanceof Array ? k.MinMax(e) : e;
    return g.Center(t.min, t.max);
  }
  static MergeMeshes(e, t = !0, i, s, r, n) {
    return Ws(k._MergeMeshesCoroutine(e, t, i, s, r, n, !1));
  }
  static MergeMeshesAsync(e, t = !0, i, s, r, n) {
    return Mn(k._MergeMeshesCoroutine(e, t, i, s, r, n, !0), vn());
  }
  static *_MergeMeshesCoroutine(e, t = !0, i, s, r, n, a) {
    if (e = e.filter(Boolean), e.length === 0)
      return null;
    let o;
    if (!i) {
      let A = 0;
      for (o = 0; o < e.length; o++)
        if (A += e[o].getTotalVertices(), A >= 65536)
          return w.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"), null;
    }
    n && (r = !1);
    const h = new Array(), l = new Array(), u = new Array(), f = e[0].overrideMaterialSideOrientation;
    for (o = 0; o < e.length; o++) {
      const A = e[o];
      if (A.isAnInstance)
        return w.Warn("Cannot merge instance meshes."), null;
      if (f !== A.overrideMaterialSideOrientation)
        return w.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values."), null;
      if (r && u.push(A.getTotalIndices()), n)
        if (A.material) {
          const L = A.material;
          if (L instanceof bi) {
            for (let Q = 0; Q < L.subMaterials.length; Q++)
              h.indexOf(L.subMaterials[Q]) < 0 && h.push(L.subMaterials[Q]);
            for (let Q = 0; Q < A.subMeshes.length; Q++)
              l.push(h.indexOf(L.subMaterials[A.subMeshes[Q].materialIndex])), u.push(A.subMeshes[Q].indexCount);
          } else {
            h.indexOf(L) < 0 && h.push(L);
            for (let Q = 0; Q < A.subMeshes.length; Q++)
              l.push(h.indexOf(L)), u.push(A.subMeshes[Q].indexCount);
          }
        } else
          for (let L = 0; L < A.subMeshes.length; L++)
            l.push(0), u.push(A.subMeshes[L].indexCount);
    }
    const d = e[0], _ = (A) => {
      const L = A.computeWorldMatrix(!0);
      return [Z.ExtractFromMesh(A, !1, !1), L];
    }, [E, m] = _(d);
    a && (yield);
    const T = new Array(e.length - 1);
    for (let A = 1; A < e.length; A++)
      T[A - 1] = _(e[A]), a && (yield);
    const b = E._mergeCoroutine(m, T, i, a, !t);
    let R = b.next();
    for (; !R.done; )
      a && (yield), R = b.next();
    const y = R.value;
    s || (s = new k(d.name + "_merged", d.getScene()));
    const P = y._applyToCoroutine(s, void 0, a);
    let v = P.next();
    for (; !v.done; )
      a && (yield), v = P.next();
    if (s.checkCollisions = d.checkCollisions, s.overrideMaterialSideOrientation = d.overrideMaterialSideOrientation, t)
      for (o = 0; o < e.length; o++)
        e[o].dispose();
    if (r || n) {
      s.releaseSubMeshes(), o = 0;
      let A = 0;
      for (; o < u.length; )
        mt.CreateFromIndices(0, A, u[o], s, void 0, !1), A += u[o], o++;
      for (const L of s.subMeshes)
        L.refreshBoundingInfo();
      s.computeWorldMatrix(!0);
    }
    if (n) {
      const A = new bi(d.name + "_merged", d.getScene());
      A.subMaterials = h;
      for (let L = 0; L < s.subMeshes.length; L++)
        s.subMeshes[L].materialIndex = l[L];
      s.material = A;
    } else
      s.material = d.material;
    return s;
  }
  addInstance(e) {
    e._indexInSourceMeshInstanceArray = this.instances.length, this.instances.push(e);
  }
  removeInstance(e) {
    const t = e._indexInSourceMeshInstanceArray;
    if (t != -1) {
      if (t !== this.instances.length - 1) {
        const i = this.instances[this.instances.length - 1];
        this.instances[t] = i, i._indexInSourceMeshInstanceArray = t;
      }
      e._indexInSourceMeshInstanceArray = -1, this.instances.pop();
    }
  }
  _shouldConvertRHS() {
    return this.overrideMaterialSideOrientation === I.CounterClockWiseSideOrientation;
  }
}
k.FRONTSIDE = Z.FRONTSIDE;
k.BACKSIDE = Z.BACKSIDE;
k.DOUBLESIDE = Z.DOUBLESIDE;
k.DEFAULTSIDE = Z.DEFAULTSIDE;
k.NO_CAP = 0;
k.CAP_START = 1;
k.CAP_END = 2;
k.CAP_ALL = 3;
k.NO_FLIP = 0;
k.FLIP_TILE = 1;
k.ROTATE_TILE = 2;
k.FLIP_ROW = 3;
k.ROTATE_ROW = 4;
k.FLIP_N_ROTATE_TILE = 5;
k.FLIP_N_ROTATE_ROW = 6;
k.CENTER = 0;
k.LEFT = 1;
k.RIGHT = 2;
k.TOP = 3;
k.BOTTOM = 4;
k.INSTANCEDMESH_SORT_TRANSPARENT = !1;
k._GroundMeshParser = (c, e) => {
  throw q("GroundMesh");
};
k._GoldbergMeshParser = (c, e) => {
  throw q("GoldbergMesh");
};
k._LinesMeshParser = (c, e) => {
  throw q("LinesMesh");
};
it("BABYLON.Mesh", k);
k.prototype.setMaterialByID = function(c) {
  return this.setMaterialById(c);
};
k.CreateDisc = k.CreateDisc || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreateBox = k.CreateBox || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreateSphere = k.CreateSphere || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreateCylinder = k.CreateCylinder || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreateTorusKnot = k.CreateTorusKnot || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreateTorus = k.CreateTorus || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreatePlane = k.CreatePlane || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreateGround = k.CreateGround || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreateTiledGround = k.CreateTiledGround || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreateGroundFromHeightMap = k.CreateGroundFromHeightMap || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreateTube = k.CreateTube || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreatePolyhedron = k.CreatePolyhedron || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreateIcoSphere = k.CreateIcoSphere || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreateDecal = k.CreateDecal || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.CreateCapsule = k.CreateCapsule || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
k.ExtendToGoldberg = k.ExtendToGoldberg || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
class Gt {
  constructor(e = 0) {
    this.priority = e;
  }
  getDescription() {
    return "";
  }
  apply(e, t) {
    return !0;
  }
}
class bs extends Gt {
  constructor(e = 0, t = 1024, i = 0.5) {
    super(e), this.priority = e, this.maximumSize = t, this.step = i;
  }
  getDescription() {
    return "Reducing render target texture size to " + this.maximumSize;
  }
  apply(e, t) {
    let i = !0;
    for (let s = 0; s < e.textures.length; s++) {
      const r = e.textures[s];
      if (!r.canRescale || r.getContext)
        continue;
      const n = r.getSize();
      Math.max(n.width, n.height) > this.maximumSize && (r.scale(this.step), i = !1);
    }
    return i;
  }
}
class hr extends Gt {
  constructor(e = 0, t = 2, i = 0.25) {
    super(e), this.priority = e, this.maximumScale = t, this.step = i, this._currentScale = -1, this._directionOffset = 1;
  }
  getDescription() {
    return "Setting hardware scaling level to " + this._currentScale;
  }
  apply(e, t) {
    return this._currentScale === -1 && (this._currentScale = e.getEngine().getHardwareScalingLevel(), this._currentScale > this.maximumScale && (this._directionOffset = -1)), this._currentScale += this._directionOffset * this.step, e.getEngine().setHardwareScalingLevel(this._currentScale), this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;
  }
}
class xs extends Gt {
  getDescription() {
    return "Turning shadows on/off";
  }
  apply(e, t) {
    return e.shadowsEnabled = t.isInImprovementMode, !0;
  }
}
class vs extends Gt {
  getDescription() {
    return "Turning post-processes on/off";
  }
  apply(e, t) {
    return e.postProcessesEnabled = t.isInImprovementMode, !0;
  }
}
class Ms extends Gt {
  getDescription() {
    return "Turning lens flares on/off";
  }
  apply(e, t) {
    return e.lensFlaresEnabled = t.isInImprovementMode, !0;
  }
}
class Nn extends Gt {
  getDescription() {
    return this.onGetDescription ? this.onGetDescription() : "Running user defined callback";
  }
  apply(e, t) {
    return this.onApply ? this.onApply(e, t) : !0;
  }
}
class As extends Gt {
  getDescription() {
    return "Turning particles on/off";
  }
  apply(e, t) {
    return e.particlesEnabled = t.isInImprovementMode, !0;
  }
}
class lr extends Gt {
  getDescription() {
    return "Turning render targets off";
  }
  apply(e, t) {
    return e.renderTargetsEnabled = t.isInImprovementMode, !0;
  }
}
class Zt extends Gt {
  constructor() {
    super(...arguments), this._canBeMerged = (e) => {
      if (!(e instanceof k))
        return !1;
      const t = e;
      return !(t.isDisposed() || !t.isVisible || !t.isEnabled() || t.instances.length > 0 || t.skeleton || t.hasLODLevels);
    };
  }
  static get UpdateSelectionTree() {
    return Zt._UpdateSelectionTree;
  }
  static set UpdateSelectionTree(e) {
    Zt._UpdateSelectionTree = e;
  }
  getDescription() {
    return "Merging similar meshes together";
  }
  apply(e, t, i) {
    const s = e.meshes.slice(0);
    let r = s.length;
    for (let a = 0; a < r; a++) {
      const o = new Array(), h = s[a];
      if (!!this._canBeMerged(h)) {
        o.push(h);
        for (let l = a + 1; l < r; l++) {
          const u = s[l];
          !this._canBeMerged(u) || u.material === h.material && u.checkCollisions === h.checkCollisions && (o.push(u), r--, s.splice(l, 1), l--);
        }
        o.length < 2 || k.MergeMeshes(o, void 0, !0);
      }
    }
    const n = e;
    return n.createOrUpdateSelectionOctree && (i != null ? i && n.createOrUpdateSelectionOctree() : Zt.UpdateSelectionTree && n.createOrUpdateSelectionOctree()), !0;
  }
}
Zt._UpdateSelectionTree = !1;
class ai {
  constructor(e = 60, t = 2e3) {
    this.targetFrameRate = e, this.trackerDuration = t, this.optimizations = new Array();
  }
  addOptimization(e) {
    return this.optimizations.push(e), this;
  }
  addCustomOptimization(e, t, i = 0) {
    const s = new Nn(i);
    return s.onApply = e, s.onGetDescription = t, this.optimizations.push(s), this;
  }
  static LowDegradationAllowed(e) {
    const t = new ai(e);
    let i = 0;
    return t.addOptimization(new Zt(i)), t.addOptimization(new xs(i)), t.addOptimization(new Ms(i)), i++, t.addOptimization(new vs(i)), t.addOptimization(new As(i)), i++, t.addOptimization(new bs(i, 1024)), t;
  }
  static ModerateDegradationAllowed(e) {
    const t = new ai(e);
    let i = 0;
    return t.addOptimization(new Zt(i)), t.addOptimization(new xs(i)), t.addOptimization(new Ms(i)), i++, t.addOptimization(new vs(i)), t.addOptimization(new As(i)), i++, t.addOptimization(new bs(i, 512)), i++, t.addOptimization(new lr(i)), i++, t.addOptimization(new hr(i, 2)), t;
  }
  static HighDegradationAllowed(e) {
    const t = new ai(e);
    let i = 0;
    return t.addOptimization(new Zt(i)), t.addOptimization(new xs(i)), t.addOptimization(new Ms(i)), i++, t.addOptimization(new vs(i)), t.addOptimization(new As(i)), i++, t.addOptimization(new bs(i, 256)), i++, t.addOptimization(new lr(i)), i++, t.addOptimization(new hr(i, 4)), t;
  }
}
class zs {
  constructor(e, t, i = !0, s = !1) {
    if (this._isRunning = !1, this._currentPriorityLevel = 0, this._targetFrameRate = 60, this._trackerDuration = 2e3, this._currentFrameRate = 0, this._improvementMode = !1, this.onSuccessObservable = new F(), this.onNewOptimizationAppliedObservable = new F(), this.onFailureObservable = new F(), t ? this._options = t : this._options = new ai(), this._options.targetFrameRate && (this._targetFrameRate = this._options.targetFrameRate), this._options.trackerDuration && (this._trackerDuration = this._options.trackerDuration), i) {
      let r = 0;
      for (const n of this._options.optimizations)
        n.priority = r++;
    }
    this._improvementMode = s, this._scene = e || _e.LastCreatedScene, this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {
      this._sceneDisposeObserver = null, this.dispose();
    });
  }
  get isInImprovementMode() {
    return this._improvementMode;
  }
  set isInImprovementMode(e) {
    this._improvementMode = e;
  }
  get currentPriorityLevel() {
    return this._currentPriorityLevel;
  }
  get currentFrameRate() {
    return this._currentFrameRate;
  }
  get targetFrameRate() {
    return this._targetFrameRate;
  }
  set targetFrameRate(e) {
    this._targetFrameRate = e;
  }
  get trackerDuration() {
    return this._trackerDuration;
  }
  set trackerDuration(e) {
    this._trackerDuration = e;
  }
  get optimizations() {
    return this._options.optimizations;
  }
  stop() {
    this._isRunning = !1;
  }
  reset() {
    this._currentPriorityLevel = 0;
  }
  start() {
    this._isRunning || (this._isRunning = !0, this._scene.executeWhenReady(() => {
      setTimeout(() => {
        this._checkCurrentState();
      }, this._trackerDuration);
    }));
  }
  _checkCurrentState() {
    if (!this._isRunning)
      return;
    const e = this._scene, t = this._options;
    if (this._currentFrameRate = Math.round(e.getEngine().getFps()), this._improvementMode && this._currentFrameRate <= this._targetFrameRate || !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {
      this._isRunning = !1, this.onSuccessObservable.notifyObservers(this);
      return;
    }
    let i = !0, s = !0;
    for (let r = 0; r < t.optimizations.length; r++) {
      const n = t.optimizations[r];
      n.priority === this._currentPriorityLevel && (s = !1, i = i && n.apply(e, this), this.onNewOptimizationAppliedObservable.notifyObservers(n));
    }
    if (s) {
      this._isRunning = !1, this.onFailureObservable.notifyObservers(this);
      return;
    }
    i && this._currentPriorityLevel++, e.executeWhenReady(() => {
      setTimeout(() => {
        this._checkCurrentState();
      }, this._trackerDuration);
    });
  }
  dispose() {
    this.stop(), this.onSuccessObservable.clear(), this.onFailureObservable.clear(), this.onNewOptimizationAppliedObservable.clear(), this._sceneDisposeObserver && this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);
  }
  static OptimizeAsync(e, t, i, s) {
    const r = new zs(e, t || ai.ModerateDegradationAllowed(), !1);
    return i && r.onSuccessObservable.add(() => {
      i();
    }), s && r.onFailureObservable.add(() => {
      s();
    }), r.start(), r;
  }
}
function Bn(c) {
  const { engine: e } = c, t = new re(e);
  t.clearColor = new ge(0, 0, 0, 0), t.pointerMovePredicate = () => !1, t.pointerDownPredicate = () => !1, t.pointerUpPredicate = () => !1, t.clearCachedVertexData(), t.themeData = {};
  const i = ai.LowDegradationAllowed();
  return i.optimizations = i.optimizations.splice(1), i.targetFrameRate = 60, zs.OptimizeAsync(t, i), t;
}
class Ge extends Y {
  constructor(e, t, i, s = !0) {
    super(e, t, i, s), this._tmpUpVector = g.Zero(), this._tmpTargetVector = g.Zero(), this.cameraDirection = new g(0, 0, 0), this.cameraRotation = new ee(0, 0), this.ignoreParentScaling = !1, this.updateUpVectorFromRotation = !1, this._tmpQuaternion = new z(), this.rotation = new g(0, 0, 0), this.speed = 2, this.noRotationConstraint = !1, this.invertRotation = !1, this.inverseRotationSpeed = 0.2, this.lockedTarget = null, this._currentTarget = g.Zero(), this._initialFocalDistance = 1, this._viewMatrix = x.Zero(), this._camMatrix = x.Zero(), this._cameraTransformMatrix = x.Zero(), this._cameraRotationMatrix = x.Zero(), this._referencePoint = new g(0, 0, 1), this._transformedReferencePoint = g.Zero(), this._defaultUp = g.Up(), this._cachedRotationZ = 0, this._cachedQuaternionRotationZ = 0;
  }
  getFrontPosition(e) {
    this.getWorldMatrix();
    const t = this.getTarget().subtract(this.position);
    return t.normalize(), t.scaleInPlace(e), this.globalPosition.add(t);
  }
  _getLockedTargetPosition() {
    return this.lockedTarget ? (this.lockedTarget.absolutePosition && this.lockedTarget.computeWorldMatrix(), this.lockedTarget.absolutePosition || this.lockedTarget) : null;
  }
  storeState() {
    return this._storedPosition = this.position.clone(), this._storedRotation = this.rotation.clone(), this.rotationQuaternion && (this._storedRotationQuaternion = this.rotationQuaternion.clone()), super.storeState();
  }
  _restoreStateValues() {
    return super._restoreStateValues() ? (this.position = this._storedPosition.clone(), this.rotation = this._storedRotation.clone(), this.rotationQuaternion && (this.rotationQuaternion = this._storedRotationQuaternion.clone()), this.cameraDirection.copyFromFloats(0, 0, 0), this.cameraRotation.copyFromFloats(0, 0), !0) : !1;
  }
  _initCache() {
    super._initCache(), this._cache.lockedTarget = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.rotation = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.rotationQuaternion = new z(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  }
  _updateCache(e) {
    e || super._updateCache();
    const t = this._getLockedTargetPosition();
    t ? this._cache.lockedTarget ? this._cache.lockedTarget.copyFrom(t) : this._cache.lockedTarget = t.clone() : this._cache.lockedTarget = null, this._cache.rotation.copyFrom(this.rotation), this.rotationQuaternion && this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);
  }
  _isSynchronizedViewMatrix() {
    if (!super._isSynchronizedViewMatrix())
      return !1;
    const e = this._getLockedTargetPosition();
    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(e) : !e) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));
  }
  _computeLocalCameraSpeed() {
    const e = this.getEngine();
    return this.speed * Math.sqrt(e.getDeltaTime() / (e.getFps() * 100));
  }
  setTarget(e) {
    this.upVector.normalize(), this._initialFocalDistance = e.subtract(this.position).length(), this.position.z === e.z && (this.position.z += Re), this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance), x.LookAtLHToRef(this.position, e, this._defaultUp, this._camMatrix), this._camMatrix.invert(), this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);
    const t = e.subtract(this.position);
    t.x >= 0 ? this.rotation.y = -Math.atan(t.z / t.x) + Math.PI / 2 : this.rotation.y = -Math.atan(t.z / t.x) - Math.PI / 2, this.rotation.z = 0, isNaN(this.rotation.x) && (this.rotation.x = 0), isNaN(this.rotation.y) && (this.rotation.y = 0), isNaN(this.rotation.z) && (this.rotation.z = 0), this.rotationQuaternion && z.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);
  }
  get target() {
    return this.getTarget();
  }
  set target(e) {
    this.setTarget(e);
  }
  getTarget() {
    return this._currentTarget;
  }
  _decideIfNeedsToMove() {
    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
  }
  _updatePosition() {
    if (this.parent) {
      this.parent.getWorldMatrix().invertToRef(D.Matrix[0]), g.TransformNormalToRef(this.cameraDirection, D.Matrix[0], D.Vector3[0]), this.position.addInPlace(D.Vector3[0]);
      return;
    }
    this.position.addInPlace(this.cameraDirection);
  }
  _checkInputs() {
    const e = this.invertRotation ? -this.inverseRotationSpeed : 1, t = this._decideIfNeedsToMove(), i = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;
    t && this._updatePosition(), i && (this.rotationQuaternion && this.rotationQuaternion.toEulerAnglesToRef(this.rotation), this.rotation.x += this.cameraRotation.x * e, this.rotation.y += this.cameraRotation.y * e, this.noRotationConstraint || (this.rotation.x > 1.570796 && (this.rotation.x = 1.570796), this.rotation.x < -1.570796 && (this.rotation.x = -1.570796)), this.rotationQuaternion && this.rotation.lengthSquared() && z.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion)), t && (Math.abs(this.cameraDirection.x) < this.speed * Re && (this.cameraDirection.x = 0), Math.abs(this.cameraDirection.y) < this.speed * Re && (this.cameraDirection.y = 0), Math.abs(this.cameraDirection.z) < this.speed * Re && (this.cameraDirection.z = 0), this.cameraDirection.scaleInPlace(this.inertia)), i && (Math.abs(this.cameraRotation.x) < this.speed * Re && (this.cameraRotation.x = 0), Math.abs(this.cameraRotation.y) < this.speed * Re && (this.cameraRotation.y = 0), this.cameraRotation.scaleInPlace(this.inertia)), super._checkInputs();
  }
  _updateCameraRotationMatrix() {
    this.rotationQuaternion ? this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix) : x.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
  }
  _rotateUpVectorWithCameraRotationMatrix() {
    return g.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector), this;
  }
  _getViewMatrix() {
    return this.lockedTarget && this.setTarget(this._getLockedTargetPosition()), this._updateCameraRotationMatrix(), this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z ? (this._rotateUpVectorWithCameraRotationMatrix(), this._cachedQuaternionRotationZ = this.rotationQuaternion.z) : this._cachedRotationZ !== this.rotation.z && (this._rotateUpVectorWithCameraRotationMatrix(), this._cachedRotationZ = this.rotation.z), g.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint), this.position.addToRef(this._transformedReferencePoint, this._currentTarget), this.updateUpVectorFromRotation && (this.rotationQuaternion ? hi.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector) : (z.FromEulerVectorToRef(this.rotation, this._tmpQuaternion), hi.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector))), this._computeViewMatrix(this.position, this._currentTarget, this.upVector), this._viewMatrix;
  }
  _computeViewMatrix(e, t, i) {
    if (this.ignoreParentScaling) {
      if (this.parent) {
        const s = this.parent.getWorldMatrix();
        g.TransformCoordinatesToRef(e, s, this._globalPosition), g.TransformCoordinatesToRef(t, s, this._tmpTargetVector), g.TransformNormalToRef(i, s, this._tmpUpVector), this._markSyncedWithParent();
      } else
        this._globalPosition.copyFrom(e), this._tmpTargetVector.copyFrom(t), this._tmpUpVector.copyFrom(i);
      this.getScene().useRightHandedSystem ? x.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix) : x.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
      return;
    }
    if (this.getScene().useRightHandedSystem ? x.LookAtRHToRef(e, t, i, this._viewMatrix) : x.LookAtLHToRef(e, t, i, this._viewMatrix), this.parent) {
      const s = this.parent.getWorldMatrix();
      this._viewMatrix.invert(), this._viewMatrix.multiplyToRef(s, this._viewMatrix), this._viewMatrix.getTranslationToRef(this._globalPosition), this._viewMatrix.invert(), this._markSyncedWithParent();
    } else
      this._globalPosition.copyFrom(e);
  }
  createRigCamera(e, t) {
    if (this.cameraRigMode !== Y.RIG_MODE_NONE) {
      const i = new Ge(e, this.position.clone(), this.getScene());
      return i.isRigCamera = !0, i.rigParent = this, (this.cameraRigMode === Y.RIG_MODE_VR || this.cameraRigMode === Y.RIG_MODE_WEBVR) && (this.rotationQuaternion || (this.rotationQuaternion = new z()), i._cameraRigParams = {}, i.rotationQuaternion = new z()), i.mode = this.mode, i.orthoLeft = this.orthoLeft, i.orthoRight = this.orthoRight, i.orthoTop = this.orthoTop, i.orthoBottom = this.orthoBottom, i;
    }
    return null;
  }
  _updateRigCameras() {
    const e = this._rigCameras[0], t = this._rigCameras[1];
    switch (this.computeWorldMatrix(), this.cameraRigMode) {
      case Y.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Y.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Y.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
      case Y.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Y.RIG_MODE_STEREOSCOPIC_INTERLACED: {
        const i = this.cameraRigMode === Y.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1, s = this.cameraRigMode === Y.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * i, e), this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * s, t);
        break;
      }
      case Y.RIG_MODE_VR:
        e.rotationQuaternion ? (e.rotationQuaternion.copyFrom(this.rotationQuaternion), t.rotationQuaternion.copyFrom(this.rotationQuaternion)) : (e.rotation.copyFrom(this.rotation), t.rotation.copyFrom(this.rotation)), e.position.copyFrom(this.position), t.position.copyFrom(this.position);
        break;
    }
    super._updateRigCameras();
  }
  _getRigCamPositionAndTarget(e, t) {
    this.getTarget().subtractToRef(this.position, Ge._TargetFocalPoint), Ge._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);
    const s = Ge._TargetFocalPoint.addInPlace(this.position);
    x.TranslationToRef(-s.x, -s.y, -s.z, Ge._TargetTransformMatrix), Ge._TargetTransformMatrix.multiplyToRef(x.RotationAxis(t.upVector, e), Ge._RigCamTransformMatrix), x.TranslationToRef(s.x, s.y, s.z, Ge._TargetTransformMatrix), Ge._RigCamTransformMatrix.multiplyToRef(Ge._TargetTransformMatrix, Ge._RigCamTransformMatrix), g.TransformCoordinatesToRef(this.position, Ge._RigCamTransformMatrix, t.position), t.setTarget(s);
  }
  getClassName() {
    return "TargetCamera";
  }
}
Ge._RigCamTransformMatrix = new x();
Ge._TargetTransformMatrix = new x();
Ge._TargetFocalPoint = new g();
S([
  Wt()
], Ge.prototype, "rotation", void 0);
S([
  M()
], Ge.prototype, "speed", void 0);
S([
  _n("lockedTargetId")
], Ge.prototype, "lockedTarget", void 0);
function Un(c) {
  const { scene: e } = c;
  let t;
  const i = 36.5;
  return t = new Ge("TargetCamera1", new g(0, i, 0), e), t.fov = 0.25, t.minZ = 5, t.maxZ = i + 1, t.setTarget(g.Zero()), t;
}
class he extends Xe {
  constructor(e, t) {
    super(e, t), this.diffuse = new te(1, 1, 1), this.specular = new te(1, 1, 1), this.falloffType = he.FALLOFF_DEFAULT, this.intensity = 1, this._range = Number.MAX_VALUE, this._inverseSquaredRange = 0, this._photometricScale = 1, this._intensityMode = he.INTENSITYMODE_AUTOMATIC, this._radius = 1e-5, this.renderPriority = 0, this._shadowEnabled = !0, this._excludeWithLayerMask = 0, this._includeOnlyWithLayerMask = 0, this._lightmapMode = 0, this._excludedMeshesIds = new Array(), this._includedOnlyMeshesIds = new Array(), this._isLight = !0, this.getScene().addLight(this), this._uniformBuffer = new G(this.getScene().getEngine(), void 0, void 0, e), this._buildUniformLayout(), this.includedOnlyMeshes = new Array(), this.excludedMeshes = new Array(), this._resyncMeshes();
  }
  get range() {
    return this._range;
  }
  set range(e) {
    this._range = e, this._inverseSquaredRange = 1 / (this.range * this.range);
  }
  get intensityMode() {
    return this._intensityMode;
  }
  set intensityMode(e) {
    this._intensityMode = e, this._computePhotometricScale();
  }
  get radius() {
    return this._radius;
  }
  set radius(e) {
    this._radius = e, this._computePhotometricScale();
  }
  get shadowEnabled() {
    return this._shadowEnabled;
  }
  set shadowEnabled(e) {
    this._shadowEnabled !== e && (this._shadowEnabled = e, this._markMeshesAsLightDirty());
  }
  get includedOnlyMeshes() {
    return this._includedOnlyMeshes;
  }
  set includedOnlyMeshes(e) {
    this._includedOnlyMeshes = e, this._hookArrayForIncludedOnly(e);
  }
  get excludedMeshes() {
    return this._excludedMeshes;
  }
  set excludedMeshes(e) {
    this._excludedMeshes = e, this._hookArrayForExcluded(e);
  }
  get excludeWithLayerMask() {
    return this._excludeWithLayerMask;
  }
  set excludeWithLayerMask(e) {
    this._excludeWithLayerMask = e, this._resyncMeshes();
  }
  get includeOnlyWithLayerMask() {
    return this._includeOnlyWithLayerMask;
  }
  set includeOnlyWithLayerMask(e) {
    this._includeOnlyWithLayerMask = e, this._resyncMeshes();
  }
  get lightmapMode() {
    return this._lightmapMode;
  }
  set lightmapMode(e) {
    this._lightmapMode !== e && (this._lightmapMode = e, this._markMeshesAsLightDirty());
  }
  transferTexturesToEffect(e, t) {
    return this;
  }
  _bindLight(e, t, i, s, r = !0) {
    const n = e.toString();
    let a = !1;
    if (this._uniformBuffer.bindToEffect(i, "Light" + n), this._renderId !== t.getRenderId() || this._lastUseSpecular !== s || !this._uniformBuffer.useUbo) {
      this._renderId = t.getRenderId(), this._lastUseSpecular = s;
      const o = this.getScaledIntensity();
      this.transferToEffect(i, n), this.diffuse.scaleToRef(o, _i.Color3[0]), this._uniformBuffer.updateColor4("vLightDiffuse", _i.Color3[0], this.range, n), s && (this.specular.scaleToRef(o, _i.Color3[1]), this._uniformBuffer.updateColor4("vLightSpecular", _i.Color3[1], this.radius, n)), a = !0;
    }
    if (this.transferTexturesToEffect(i, n), t.shadowsEnabled && this.shadowEnabled && r) {
      const o = this.getShadowGenerator();
      o && (o.bindShadowLight(n, i), a = !0);
    }
    a ? this._uniformBuffer.update() : this._uniformBuffer.bindUniformBuffer();
  }
  getClassName() {
    return "Light";
  }
  toString(e) {
    let t = "Name: " + this.name;
    if (t += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()], this.animations)
      for (let i = 0; i < this.animations.length; i++)
        t += ", animation[0]: " + this.animations[i].toString(e);
    return t;
  }
  _syncParentEnabledState() {
    super._syncParentEnabledState(), this.isDisposed() || this._resyncMeshes();
  }
  setEnabled(e) {
    super.setEnabled(e), this._resyncMeshes();
  }
  getShadowGenerator() {
    return this._shadowGenerator;
  }
  getAbsolutePosition() {
    return g.Zero();
  }
  canAffectMesh(e) {
    return e ? !(this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(e) === -1 || this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(e) !== -1 || this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & e.layerMask) === 0 || this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & e.layerMask) : !0;
  }
  dispose(e, t = !1) {
    if (this._shadowGenerator && (this._shadowGenerator.dispose(), this._shadowGenerator = null), this.getScene().stopAnimation(this), this._parentContainer) {
      const i = this._parentContainer.lights.indexOf(this);
      i > -1 && this._parentContainer.lights.splice(i, 1), this._parentContainer = null;
    }
    for (const i of this.getScene().meshes)
      i._removeLightSource(this, !0);
    this._uniformBuffer.dispose(), this.getScene().removeLight(this), super.dispose(e, t);
  }
  getTypeID() {
    return 0;
  }
  getScaledIntensity() {
    return this._photometricScale * this.intensity;
  }
  clone(e, t = null) {
    const i = he.GetConstructorFromName(this.getTypeID(), e, this.getScene());
    if (!i)
      return null;
    const s = ne.Clone(i, this);
    return e && (s.name = e), t && (s.parent = t), s.setEnabled(this.isEnabled()), this.onClonedObservable.notifyObservers(s), s;
  }
  serialize() {
    const e = ne.Serialize(this);
    return e.uniqueId = this.uniqueId, e.type = this.getTypeID(), this.parent && this.parent._serializeAsParent(e), this.excludedMeshes.length > 0 && (e.excludedMeshesIds = [], this.excludedMeshes.forEach((t) => {
      e.excludedMeshesIds.push(t.id);
    })), this.includedOnlyMeshes.length > 0 && (e.includedOnlyMeshesIds = [], this.includedOnlyMeshes.forEach((t) => {
      e.includedOnlyMeshesIds.push(t.id);
    })), ne.AppendSerializedAnimations(this, e), e.ranges = this.serializeAnimationRanges(), e.isEnabled = this.isEnabled(), e;
  }
  static GetConstructorFromName(e, t, i) {
    const s = Xe.Construct("Light_Type_" + e, t, i);
    return s || null;
  }
  static Parse(e, t) {
    const i = he.GetConstructorFromName(e.type, e.name, t);
    if (!i)
      return null;
    const s = ne.Parse(i, e, t);
    if (e.excludedMeshesIds && (s._excludedMeshesIds = e.excludedMeshesIds), e.includedOnlyMeshesIds && (s._includedOnlyMeshesIds = e.includedOnlyMeshesIds), e.parentId !== void 0 && (s._waitingParentId = e.parentId), e.parentInstanceIndex !== void 0 && (s._waitingParentInstanceIndex = e.parentInstanceIndex), e.falloffType !== void 0 && (s.falloffType = e.falloffType), e.lightmapMode !== void 0 && (s.lightmapMode = e.lightmapMode), e.animations) {
      for (let r = 0; r < e.animations.length; r++) {
        const n = e.animations[r], a = oi("BABYLON.Animation");
        a && s.animations.push(a.Parse(n));
      }
      Xe.ParseAnimationRanges(s, e, t);
    }
    return e.autoAnimate && t.beginAnimation(s, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1), e.isEnabled !== void 0 && s.setEnabled(e.isEnabled), s;
  }
  _hookArrayForExcluded(e) {
    const t = e.push;
    e.push = (...s) => {
      const r = t.apply(e, s);
      for (const n of s)
        n._resyncLightSource(this);
      return r;
    };
    const i = e.splice;
    e.splice = (s, r) => {
      const n = i.apply(e, [s, r]);
      for (const a of n)
        a._resyncLightSource(this);
      return n;
    };
    for (const s of e)
      s._resyncLightSource(this);
  }
  _hookArrayForIncludedOnly(e) {
    const t = e.push;
    e.push = (...s) => {
      const r = t.apply(e, s);
      return this._resyncMeshes(), r;
    };
    const i = e.splice;
    e.splice = (s, r) => {
      const n = i.apply(e, [s, r]);
      return this._resyncMeshes(), n;
    }, this._resyncMeshes();
  }
  _resyncMeshes() {
    for (const e of this.getScene().meshes)
      e._resyncLightSource(this);
  }
  _markMeshesAsLightDirty() {
    for (const e of this.getScene().meshes)
      e.lightSources.indexOf(this) !== -1 && e._markSubMeshesAsLightDirty();
  }
  _computePhotometricScale() {
    this._photometricScale = this._getPhotometricScale(), this.getScene().resetCachedMaterial();
  }
  _getPhotometricScale() {
    let e = 0;
    const t = this.getTypeID();
    let i = this.intensityMode;
    switch (i === he.INTENSITYMODE_AUTOMATIC && (t === he.LIGHTTYPEID_DIRECTIONALLIGHT ? i = he.INTENSITYMODE_ILLUMINANCE : i = he.INTENSITYMODE_LUMINOUSINTENSITY), t) {
      case he.LIGHTTYPEID_POINTLIGHT:
      case he.LIGHTTYPEID_SPOTLIGHT:
        switch (i) {
          case he.INTENSITYMODE_LUMINOUSPOWER:
            e = 1 / (4 * Math.PI);
            break;
          case he.INTENSITYMODE_LUMINOUSINTENSITY:
            e = 1;
            break;
          case he.INTENSITYMODE_LUMINANCE:
            e = this.radius * this.radius;
            break;
        }
        break;
      case he.LIGHTTYPEID_DIRECTIONALLIGHT:
        switch (i) {
          case he.INTENSITYMODE_ILLUMINANCE:
            e = 1;
            break;
          case he.INTENSITYMODE_LUMINANCE: {
            let s = this.radius;
            s = Math.max(s, 1e-3), e = 2 * Math.PI * (1 - Math.cos(s));
            break;
          }
        }
        break;
      case he.LIGHTTYPEID_HEMISPHERICLIGHT:
        e = 1;
        break;
    }
    return e;
  }
  _reorderLightsInScene() {
    const e = this.getScene();
    this._renderPriority != 0 && (e.requireLightSorting = !0), this.getScene().sortLightsByPriority();
  }
}
he.FALLOFF_DEFAULT = Te.FALLOFF_DEFAULT;
he.FALLOFF_PHYSICAL = Te.FALLOFF_PHYSICAL;
he.FALLOFF_GLTF = Te.FALLOFF_GLTF;
he.FALLOFF_STANDARD = Te.FALLOFF_STANDARD;
he.LIGHTMAP_DEFAULT = Te.LIGHTMAP_DEFAULT;
he.LIGHTMAP_SPECULAR = Te.LIGHTMAP_SPECULAR;
he.LIGHTMAP_SHADOWSONLY = Te.LIGHTMAP_SHADOWSONLY;
he.INTENSITYMODE_AUTOMATIC = Te.INTENSITYMODE_AUTOMATIC;
he.INTENSITYMODE_LUMINOUSPOWER = Te.INTENSITYMODE_LUMINOUSPOWER;
he.INTENSITYMODE_LUMINOUSINTENSITY = Te.INTENSITYMODE_LUMINOUSINTENSITY;
he.INTENSITYMODE_ILLUMINANCE = Te.INTENSITYMODE_ILLUMINANCE;
he.INTENSITYMODE_LUMINANCE = Te.INTENSITYMODE_LUMINANCE;
he.LIGHTTYPEID_POINTLIGHT = Te.LIGHTTYPEID_POINTLIGHT;
he.LIGHTTYPEID_DIRECTIONALLIGHT = Te.LIGHTTYPEID_DIRECTIONALLIGHT;
he.LIGHTTYPEID_SPOTLIGHT = Te.LIGHTTYPEID_SPOTLIGHT;
he.LIGHTTYPEID_HEMISPHERICLIGHT = Te.LIGHTTYPEID_HEMISPHERICLIGHT;
S([
  li()
], he.prototype, "diffuse", void 0);
S([
  li()
], he.prototype, "specular", void 0);
S([
  M()
], he.prototype, "falloffType", void 0);
S([
  M()
], he.prototype, "intensity", void 0);
S([
  M()
], he.prototype, "range", null);
S([
  M()
], he.prototype, "intensityMode", null);
S([
  M()
], he.prototype, "radius", null);
S([
  M()
], he.prototype, "_renderPriority", void 0);
S([
  xe("_reorderLightsInScene")
], he.prototype, "renderPriority", void 0);
S([
  M("shadowEnabled")
], he.prototype, "_shadowEnabled", void 0);
S([
  M("excludeWithLayerMask")
], he.prototype, "_excludeWithLayerMask", void 0);
S([
  M("includeOnlyWithLayerMask")
], he.prototype, "_includeOnlyWithLayerMask", void 0);
S([
  M("lightmapMode")
], he.prototype, "_lightmapMode", void 0);
class Ni extends he {
  constructor() {
    super(...arguments), this._needProjectionMatrixCompute = !0;
  }
  _setPosition(e) {
    this._position = e;
  }
  get position() {
    return this._position;
  }
  set position(e) {
    this._setPosition(e);
  }
  _setDirection(e) {
    this._direction = e;
  }
  get direction() {
    return this._direction;
  }
  set direction(e) {
    this._setDirection(e);
  }
  get shadowMinZ() {
    return this._shadowMinZ;
  }
  set shadowMinZ(e) {
    this._shadowMinZ = e, this.forceProjectionMatrixCompute();
  }
  get shadowMaxZ() {
    return this._shadowMaxZ;
  }
  set shadowMaxZ(e) {
    this._shadowMaxZ = e, this.forceProjectionMatrixCompute();
  }
  computeTransformedInformation() {
    return this.parent && this.parent.getWorldMatrix ? (this.transformedPosition || (this.transformedPosition = g.Zero()), g.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition), this.direction && (this.transformedDirection || (this.transformedDirection = g.Zero()), g.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection)), !0) : !1;
  }
  getDepthScale() {
    return 50;
  }
  getShadowDirection(e) {
    return this.transformedDirection ? this.transformedDirection : this.direction;
  }
  getAbsolutePosition() {
    return this.transformedPosition ? this.transformedPosition : this.position;
  }
  setDirectionToTarget(e) {
    return this.direction = g.Normalize(e.subtract(this.position)), this.direction;
  }
  getRotation() {
    this.direction.normalize();
    const e = g.Cross(this.direction, hi.Y), t = g.Cross(e, this.direction);
    return g.RotationFromAxis(e, t, this.direction);
  }
  needCube() {
    return !1;
  }
  needProjectionMatrixCompute() {
    return this._needProjectionMatrixCompute;
  }
  forceProjectionMatrixCompute() {
    this._needProjectionMatrixCompute = !0;
  }
  _initCache() {
    super._initCache(), this._cache.position = g.Zero();
  }
  _isSynchronized() {
    return !!this._cache.position.equals(this.position);
  }
  computeWorldMatrix(e) {
    return !e && this.isSynchronized() ? (this._currentRenderId = this.getScene().getRenderId(), this._worldMatrix) : (this._updateCache(), this._cache.position.copyFrom(this.position), this._worldMatrix || (this._worldMatrix = x.Identity()), x.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix), this.parent && this.parent.getWorldMatrix && (this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix), this._markSyncedWithParent()), this._worldMatrixDeterminantIsDirty = !0, this._worldMatrix);
  }
  getDepthMinZ(e) {
    return this.shadowMinZ !== void 0 ? this.shadowMinZ : e.minZ;
  }
  getDepthMaxZ(e) {
    return this.shadowMaxZ !== void 0 ? this.shadowMaxZ : e.maxZ;
  }
  setShadowProjectionMatrix(e, t, i) {
    return this.customProjectionMatrixBuilder ? this.customProjectionMatrixBuilder(t, i, e) : this._setDefaultShadowProjectionMatrix(e, t, i), this;
  }
  _syncParentEnabledState() {
    super._syncParentEnabledState(), (!this.parent || !this.parent.getWorldMatrix) && (this.transformedPosition = null, this.transformedDirection = null);
  }
}
S([
  Wt()
], Ni.prototype, "position", null);
S([
  Wt()
], Ni.prototype, "direction", null);
S([
  M()
], Ni.prototype, "shadowMinZ", null);
S([
  M()
], Ni.prototype, "shadowMaxZ", null);
Xe.AddNodeConstructor("Light_Type_1", (c, e) => () => new It(c, g.Zero(), e));
class It extends Ni {
  constructor(e, t, i) {
    super(e, i), this._shadowFrustumSize = 0, this._shadowOrthoScale = 0.1, this.autoUpdateExtends = !0, this.autoCalcShadowZBounds = !1, this._orthoLeft = Number.MAX_VALUE, this._orthoRight = Number.MIN_VALUE, this._orthoTop = Number.MIN_VALUE, this._orthoBottom = Number.MAX_VALUE, this.position = t.scale(-1), this.direction = t;
  }
  get shadowFrustumSize() {
    return this._shadowFrustumSize;
  }
  set shadowFrustumSize(e) {
    this._shadowFrustumSize = e, this.forceProjectionMatrixCompute();
  }
  get shadowOrthoScale() {
    return this._shadowOrthoScale;
  }
  set shadowOrthoScale(e) {
    this._shadowOrthoScale = e, this.forceProjectionMatrixCompute();
  }
  get orthoLeft() {
    return this._orthoLeft;
  }
  set orthoLeft(e) {
    this._orthoLeft = e;
  }
  get orthoRight() {
    return this._orthoRight;
  }
  set orthoRight(e) {
    this._orthoRight = e;
  }
  get orthoTop() {
    return this._orthoTop;
  }
  set orthoTop(e) {
    this._orthoTop = e;
  }
  get orthoBottom() {
    return this._orthoBottom;
  }
  set orthoBottom(e) {
    this._orthoBottom = e;
  }
  getClassName() {
    return "DirectionalLight";
  }
  getTypeID() {
    return he.LIGHTTYPEID_DIRECTIONALLIGHT;
  }
  _setDefaultShadowProjectionMatrix(e, t, i) {
    this.shadowFrustumSize > 0 ? this._setDefaultFixedFrustumShadowProjectionMatrix(e) : this._setDefaultAutoExtendShadowProjectionMatrix(e, t, i);
  }
  _setDefaultFixedFrustumShadowProjectionMatrix(e) {
    const t = this.getScene().activeCamera;
    !t || x.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== void 0 ? this.shadowMinZ : t.minZ, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : t.maxZ, e, this.getScene().getEngine().isNDCHalfZRange);
  }
  _setDefaultAutoExtendShadowProjectionMatrix(e, t, i) {
    const s = this.getScene().activeCamera;
    if (!s)
      return;
    if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
      const l = g.Zero();
      this._orthoLeft = Number.MAX_VALUE, this._orthoRight = Number.MIN_VALUE, this._orthoTop = Number.MIN_VALUE, this._orthoBottom = Number.MAX_VALUE;
      let u = Number.MAX_VALUE, f = Number.MIN_VALUE;
      for (let d = 0; d < i.length; d++) {
        const _ = i[d];
        if (!_)
          continue;
        const m = _.getBoundingInfo().boundingBox;
        for (let T = 0; T < m.vectorsWorld.length; T++)
          g.TransformCoordinatesToRef(m.vectorsWorld[T], t, l), l.x < this._orthoLeft && (this._orthoLeft = l.x), l.y < this._orthoBottom && (this._orthoBottom = l.y), l.x > this._orthoRight && (this._orthoRight = l.x), l.y > this._orthoTop && (this._orthoTop = l.y), this.autoCalcShadowZBounds && (l.z < u && (u = l.z), l.z > f && (f = l.z));
      }
      this.autoCalcShadowZBounds && (this._shadowMinZ = u, this._shadowMaxZ = f);
    }
    const r = this._orthoRight - this._orthoLeft, n = this._orthoTop - this._orthoBottom, a = this.shadowMinZ !== void 0 ? this.shadowMinZ : s.minZ, o = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : s.maxZ, h = this.getScene().getEngine().useReverseDepthBuffer;
    x.OrthoOffCenterLHToRef(this._orthoLeft - r * this.shadowOrthoScale, this._orthoRight + r * this.shadowOrthoScale, this._orthoBottom - n * this.shadowOrthoScale, this._orthoTop + n * this.shadowOrthoScale, h ? o : a, h ? a : o, e, this.getScene().getEngine().isNDCHalfZRange);
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("vLightData", 4), this._uniformBuffer.addUniform("vLightDiffuse", 4), this._uniformBuffer.addUniform("vLightSpecular", 4), this._uniformBuffer.addUniform("shadowsInfo", 3), this._uniformBuffer.addUniform("depthValues", 2), this._uniformBuffer.create();
  }
  transferToEffect(e, t) {
    return this.computeTransformedInformation() ? (this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, t), this) : (this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, t), this);
  }
  transferToNodeMaterialEffect(e, t) {
    return this.computeTransformedInformation() ? (e.setFloat3(t, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z), this) : (e.setFloat3(t, this.direction.x, this.direction.y, this.direction.z), this);
  }
  getDepthMinZ(e) {
    const t = this._scene.getEngine();
    return !t.useReverseDepthBuffer && t.isNDCHalfZRange ? 0 : 1;
  }
  getDepthMaxZ(e) {
    const t = this._scene.getEngine();
    return t.useReverseDepthBuffer && t.isNDCHalfZRange ? 0 : 1;
  }
  prepareLightSpecificDefines(e, t) {
    e["DIRLIGHT" + t] = !0;
  }
}
S([
  M()
], It.prototype, "shadowFrustumSize", null);
S([
  M()
], It.prototype, "shadowOrthoScale", null);
S([
  M()
], It.prototype, "autoUpdateExtends", void 0);
S([
  M()
], It.prototype, "autoCalcShadowZBounds", void 0);
S([
  M("orthoLeft")
], It.prototype, "_orthoLeft", void 0);
S([
  M("orthoRight")
], It.prototype, "_orthoRight", void 0);
S([
  M("orthoTop")
], It.prototype, "_orthoTop", void 0);
S([
  M("orthoBottom")
], It.prototype, "_orthoBottom", void 0);
Xe.AddNodeConstructor("Light_Type_3", (c, e) => () => new os(c, g.Zero(), e));
class os extends he {
  constructor(e, t, i) {
    super(e, i), this.groundColor = new te(0, 0, 0), this.direction = t || g.Up();
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("vLightData", 4), this._uniformBuffer.addUniform("vLightDiffuse", 4), this._uniformBuffer.addUniform("vLightSpecular", 4), this._uniformBuffer.addUniform("vLightGround", 3), this._uniformBuffer.addUniform("shadowsInfo", 3), this._uniformBuffer.addUniform("depthValues", 2), this._uniformBuffer.create();
  }
  getClassName() {
    return "HemisphericLight";
  }
  setDirectionToTarget(e) {
    return this.direction = g.Normalize(e.subtract(g.Zero())), this.direction;
  }
  getShadowGenerator() {
    return null;
  }
  transferToEffect(e, t) {
    const i = g.Normalize(this.direction);
    return this._uniformBuffer.updateFloat4("vLightData", i.x, i.y, i.z, 0, t), this._uniformBuffer.updateColor3("vLightGround", this.groundColor.scale(this.intensity), t), this;
  }
  transferToNodeMaterialEffect(e, t) {
    const i = g.Normalize(this.direction);
    return e.setFloat3(t, i.x, i.y, i.z), this;
  }
  computeWorldMatrix() {
    return this._worldMatrix || (this._worldMatrix = x.Identity()), this._worldMatrix;
  }
  getTypeID() {
    return he.LIGHTTYPEID_HEMISPHERICLIGHT;
  }
  prepareLightSpecificDefines(e, t) {
    e["HEMILIGHT" + t] = !0;
  }
}
S([
  li()
], os.prototype, "groundColor", void 0);
S([
  Wt()
], os.prototype, "direction", void 0);
class Nt {
  constructor(e, t) {
    this.width = e, this.height = t;
  }
  toString() {
    return `{W: ${this.width}, H: ${this.height}}`;
  }
  getClassName() {
    return "Size";
  }
  getHashCode() {
    let e = this.width | 0;
    return e = e * 397 ^ (this.height | 0), e;
  }
  copyFrom(e) {
    this.width = e.width, this.height = e.height;
  }
  copyFromFloats(e, t) {
    return this.width = e, this.height = t, this;
  }
  set(e, t) {
    return this.copyFromFloats(e, t);
  }
  multiplyByFloats(e, t) {
    return new Nt(this.width * e, this.height * t);
  }
  clone() {
    return new Nt(this.width, this.height);
  }
  equals(e) {
    return e ? this.width === e.width && this.height === e.height : !1;
  }
  get surface() {
    return this.width * this.height;
  }
  static Zero() {
    return new Nt(0, 0);
  }
  add(e) {
    return new Nt(this.width + e.width, this.height + e.height);
  }
  subtract(e) {
    return new Nt(this.width - e.width, this.height - e.height);
  }
  static Lerp(e, t, i) {
    const s = e.width + (t.width - e.width) * i, r = e.height + (t.height - e.height) * i;
    return new Nt(s, r);
  }
}
class kn {
  constructor(e) {
    this._wrapU = 1, this._wrapV = 1, this.wrapR = 1, this.anisotropicFilteringLevel = 4, this.delayLoadState = 0, this._texture = null, this._engine = null, this._cachedSize = Nt.Zero(), this._cachedBaseSize = Nt.Zero(), this._initialSamplingMode = 2, this._texture = e, this._texture && (this._engine = this._texture.getEngine());
  }
  get wrapU() {
    return this._wrapU;
  }
  set wrapU(e) {
    this._wrapU = e;
  }
  get wrapV() {
    return this._wrapV;
  }
  set wrapV(e) {
    this._wrapV = e;
  }
  get coordinatesMode() {
    return 0;
  }
  get isCube() {
    return this._texture ? this._texture.isCube : !1;
  }
  set isCube(e) {
    !this._texture || (this._texture.isCube = e);
  }
  get is3D() {
    return this._texture ? this._texture.is3D : !1;
  }
  set is3D(e) {
    !this._texture || (this._texture.is3D = e);
  }
  get is2DArray() {
    return this._texture ? this._texture.is2DArray : !1;
  }
  set is2DArray(e) {
    !this._texture || (this._texture.is2DArray = e);
  }
  getClassName() {
    return "ThinTexture";
  }
  isReady() {
    return this.delayLoadState === 4 ? (this.delayLoad(), !1) : this._texture ? this._texture.isReady : !1;
  }
  delayLoad() {
  }
  getInternalTexture() {
    return this._texture;
  }
  getSize() {
    if (this._texture) {
      if (this._texture.width)
        return this._cachedSize.width = this._texture.width, this._cachedSize.height = this._texture.height, this._cachedSize;
      if (this._texture._size)
        return this._cachedSize.width = this._texture._size, this._cachedSize.height = this._texture._size, this._cachedSize;
    }
    return this._cachedSize;
  }
  getBaseSize() {
    return !this.isReady() || !this._texture ? (this._cachedBaseSize.width = 0, this._cachedBaseSize.height = 0, this._cachedBaseSize) : this._texture._size ? (this._cachedBaseSize.width = this._texture._size, this._cachedBaseSize.height = this._texture._size, this._cachedBaseSize) : (this._cachedBaseSize.width = this._texture.baseWidth, this._cachedBaseSize.height = this._texture.baseHeight, this._cachedBaseSize);
  }
  get samplingMode() {
    return this._texture ? this._texture.samplingMode : this._initialSamplingMode;
  }
  updateSamplingMode(e) {
    this._texture && this._engine && this._engine.updateTextureSamplingMode(e, this._texture);
  }
  releaseInternalTexture() {
    this._texture && (this._texture.dispose(), this._texture = null);
  }
  dispose() {
    this._texture && (this.releaseInternalTexture(), this._engine = null);
  }
}
class Ae extends kn {
  constructor(e, t = null) {
    super(null), this.metadata = null, this.reservedDataStore = null, this._hasAlpha = !1, this._getAlphaFromRGB = !1, this.level = 1, this._coordinatesIndex = 0, this._coordinatesMode = 0, this.wrapR = 1, this.anisotropicFilteringLevel = Ae.DEFAULT_ANISOTROPIC_FILTERING_LEVEL, this._isCube = !1, this._gammaSpace = !0, this.invertZ = !1, this.lodLevelInAlpha = !1, this.isRenderTarget = !1, this._prefiltered = !1, this._forceSerialize = !1, this.animations = new Array(), this.onDisposeObservable = new F(), this._onDisposeObserver = null, this._scene = null, this._uid = null, this._parentContainer = null, this._loadingError = !1, e ? Ae._IsScene(e) ? this._scene = e : this._engine = e : this._scene = _e.LastCreatedScene, this._scene && (this.uniqueId = this._scene.getUniqueId(), this._scene.addTexture(this), this._engine = this._scene.getEngine()), this._texture = t, this._uid = null;
  }
  set hasAlpha(e) {
    this._hasAlpha !== e && (this._hasAlpha = e, this._scene && this._scene.markAllMaterialsAsDirty(1, (t) => t.hasTexture(this)));
  }
  get hasAlpha() {
    return this._hasAlpha;
  }
  set getAlphaFromRGB(e) {
    this._getAlphaFromRGB !== e && (this._getAlphaFromRGB = e, this._scene && this._scene.markAllMaterialsAsDirty(1, (t) => t.hasTexture(this)));
  }
  get getAlphaFromRGB() {
    return this._getAlphaFromRGB;
  }
  set coordinatesIndex(e) {
    this._coordinatesIndex !== e && (this._coordinatesIndex = e, this._scene && this._scene.markAllMaterialsAsDirty(1, (t) => t.hasTexture(this)));
  }
  get coordinatesIndex() {
    return this._coordinatesIndex;
  }
  set coordinatesMode(e) {
    this._coordinatesMode !== e && (this._coordinatesMode = e, this._scene && this._scene.markAllMaterialsAsDirty(1, (t) => t.hasTexture(this)));
  }
  get coordinatesMode() {
    return this._coordinatesMode;
  }
  get wrapU() {
    return this._wrapU;
  }
  set wrapU(e) {
    this._wrapU = e;
  }
  get wrapV() {
    return this._wrapV;
  }
  set wrapV(e) {
    this._wrapV = e;
  }
  get isCube() {
    return this._texture ? this._texture.isCube : this._isCube;
  }
  set isCube(e) {
    this._texture ? this._texture.isCube = e : this._isCube = e;
  }
  get is3D() {
    return this._texture ? this._texture.is3D : !1;
  }
  set is3D(e) {
    !this._texture || (this._texture.is3D = e);
  }
  get is2DArray() {
    return this._texture ? this._texture.is2DArray : !1;
  }
  set is2DArray(e) {
    !this._texture || (this._texture.is2DArray = e);
  }
  get gammaSpace() {
    if (this._texture)
      this._texture._gammaSpace === null && (this._texture._gammaSpace = this._gammaSpace);
    else
      return this._gammaSpace;
    return this._texture._gammaSpace && !this._texture._useSRGBBuffer;
  }
  set gammaSpace(e) {
    if (this._texture) {
      if (this._texture._gammaSpace === e)
        return;
      this._texture._gammaSpace = e;
    } else {
      if (this._gammaSpace === e)
        return;
      this._gammaSpace = e;
    }
    this._markAllSubMeshesAsTexturesDirty();
  }
  get isRGBD() {
    return this._texture != null && this._texture._isRGBD;
  }
  set isRGBD(e) {
    this._texture && (this._texture._isRGBD = e);
  }
  get noMipmap() {
    return !1;
  }
  get lodGenerationOffset() {
    return this._texture ? this._texture._lodGenerationOffset : 0;
  }
  set lodGenerationOffset(e) {
    this._texture && (this._texture._lodGenerationOffset = e);
  }
  get lodGenerationScale() {
    return this._texture ? this._texture._lodGenerationScale : 0;
  }
  set lodGenerationScale(e) {
    this._texture && (this._texture._lodGenerationScale = e);
  }
  get linearSpecularLOD() {
    return this._texture ? this._texture._linearSpecularLOD : !1;
  }
  set linearSpecularLOD(e) {
    this._texture && (this._texture._linearSpecularLOD = e);
  }
  get irradianceTexture() {
    return this._texture ? this._texture._irradianceTexture : null;
  }
  set irradianceTexture(e) {
    this._texture && (this._texture._irradianceTexture = e);
  }
  get uid() {
    return this._uid || (this._uid = vr()), this._uid;
  }
  toString() {
    return this.name;
  }
  getClassName() {
    return "BaseTexture";
  }
  set onDispose(e) {
    this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);
  }
  get isBlocking() {
    return !0;
  }
  get loadingError() {
    return this._loadingError;
  }
  get errorObject() {
    return this._errorObject;
  }
  getScene() {
    return this._scene;
  }
  _getEngine() {
    return this._engine;
  }
  checkTransformsAreIdentical(e) {
    return e !== null;
  }
  getTextureMatrix() {
    return x.IdentityReadOnly;
  }
  getReflectionTextureMatrix() {
    return x.IdentityReadOnly;
  }
  isReadyOrNotBlocking() {
    return !this.isBlocking || this.isReady() || this.loadingError;
  }
  scale(e) {
  }
  get canRescale() {
    return !1;
  }
  _getFromCache(e, t, i, s, r, n) {
    const a = this._getEngine();
    if (!a)
      return null;
    const o = a._getUseSRGBBuffer(!!r, t), h = a.getLoadedTexturesCache();
    for (let l = 0; l < h.length; l++) {
      const u = h[l];
      if ((r === void 0 || o === u._useSRGBBuffer) && (s === void 0 || s === u.invertY) && u.url === e && u.generateMipMaps === !t && (!i || i === u.samplingMode) && (n === void 0 || n === u.isCube))
        return u.incrementReferences(), u;
    }
    return null;
  }
  _rebuild() {
  }
  clone() {
    return null;
  }
  get textureType() {
    return this._texture && this._texture.type !== void 0 ? this._texture.type : 0;
  }
  get textureFormat() {
    return this._texture && this._texture.format !== void 0 ? this._texture.format : 5;
  }
  _markAllSubMeshesAsTexturesDirty() {
    const e = this.getScene();
    !e || e.markAllMaterialsAsDirty(1);
  }
  readPixels(e = 0, t = 0, i = null, s = !0, r = !1, n = 0, a = 0, o = Number.MAX_VALUE, h = Number.MAX_VALUE) {
    if (!this._texture)
      return null;
    const l = this._getEngine();
    if (!l)
      return null;
    const u = this.getSize();
    let f = u.width, d = u.height;
    t !== 0 && (f = f / Math.pow(2, t), d = d / Math.pow(2, t), f = Math.round(f), d = Math.round(d)), o = Math.min(f, o), h = Math.min(d, h);
    try {
      return this._texture.isCube ? l._readTexturePixels(this._texture, o, h, e, t, i, s, r, n, a) : l._readTexturePixels(this._texture, o, h, -1, t, i, s, r, n, a);
    } catch {
      return null;
    }
  }
  _readPixelsSync(e = 0, t = 0, i = null, s = !0, r = !1) {
    if (!this._texture)
      return null;
    const n = this.getSize();
    let a = n.width, o = n.height;
    const h = this._getEngine();
    if (!h)
      return null;
    t != 0 && (a = a / Math.pow(2, t), o = o / Math.pow(2, t), a = Math.round(a), o = Math.round(o));
    try {
      return this._texture.isCube ? h._readTexturePixelsSync(this._texture, a, o, e, t, i, s, r) : h._readTexturePixelsSync(this._texture, a, o, -1, t, i, s, r);
    } catch {
      return null;
    }
  }
  get _lodTextureHigh() {
    return this._texture ? this._texture._lodTextureHigh : null;
  }
  get _lodTextureMid() {
    return this._texture ? this._texture._lodTextureMid : null;
  }
  get _lodTextureLow() {
    return this._texture ? this._texture._lodTextureLow : null;
  }
  dispose() {
    if (this._scene) {
      this._scene.stopAnimation && this._scene.stopAnimation(this), this._scene.removePendingData(this);
      const e = this._scene.textures.indexOf(this);
      if (e >= 0 && this._scene.textures.splice(e, 1), this._scene.onTextureRemovedObservable.notifyObservers(this), this._scene = null, this._parentContainer) {
        const t = this._parentContainer.textures.indexOf(this);
        t > -1 && this._parentContainer.textures.splice(t, 1), this._parentContainer = null;
      }
    }
    this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.metadata = null, super.dispose();
  }
  serialize() {
    if (!this.name)
      return null;
    const e = ne.Serialize(this);
    return ne.AppendSerializedAnimations(this, e), e;
  }
  static WhenAllReady(e, t) {
    let i = e.length;
    if (i === 0) {
      t();
      return;
    }
    for (let s = 0; s < e.length; s++) {
      const r = e[s];
      if (r.isReady())
        --i === 0 && t();
      else {
        const n = r.onLoadObservable;
        n ? n.addOnce(() => {
          --i === 0 && t();
        }) : --i === 0 && t();
      }
    }
  }
  static _IsScene(e) {
    return e.getClassName() === "Scene";
  }
}
Ae.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;
S([
  M()
], Ae.prototype, "uniqueId", void 0);
S([
  M()
], Ae.prototype, "name", void 0);
S([
  M()
], Ae.prototype, "metadata", void 0);
S([
  M("hasAlpha")
], Ae.prototype, "_hasAlpha", void 0);
S([
  M("getAlphaFromRGB")
], Ae.prototype, "_getAlphaFromRGB", void 0);
S([
  M()
], Ae.prototype, "level", void 0);
S([
  M("coordinatesIndex")
], Ae.prototype, "_coordinatesIndex", void 0);
S([
  M("coordinatesMode")
], Ae.prototype, "_coordinatesMode", void 0);
S([
  M()
], Ae.prototype, "wrapU", null);
S([
  M()
], Ae.prototype, "wrapV", null);
S([
  M()
], Ae.prototype, "wrapR", void 0);
S([
  M()
], Ae.prototype, "anisotropicFilteringLevel", void 0);
S([
  M()
], Ae.prototype, "isCube", null);
S([
  M()
], Ae.prototype, "is3D", null);
S([
  M()
], Ae.prototype, "is2DArray", null);
S([
  M()
], Ae.prototype, "gammaSpace", null);
S([
  M()
], Ae.prototype, "invertZ", void 0);
S([
  M()
], Ae.prototype, "lodLevelInAlpha", void 0);
S([
  M()
], Ae.prototype, "lodGenerationOffset", null);
S([
  M()
], Ae.prototype, "lodGenerationScale", null);
S([
  M()
], Ae.prototype, "linearSpecularLOD", null);
S([
  Et()
], Ae.prototype, "irradianceTexture", null);
S([
  M()
], Ae.prototype, "isRenderTarget", void 0);
function Ir(c, e, t = !1) {
  const i = e.width, s = e.height;
  if (c instanceof Float32Array) {
    let h = c.byteLength / c.BYTES_PER_ELEMENT;
    const l = new Uint8Array(h);
    for (; --h >= 0; ) {
      let u = c[h];
      u < 0 ? u = 0 : u > 1 && (u = 1), l[h] = u * 255;
    }
    c = l;
  }
  const r = document.createElement("canvas");
  r.width = i, r.height = s;
  const n = r.getContext("2d");
  if (!n)
    return null;
  const a = n.createImageData(i, s);
  if (a.data.set(c), n.putImageData(a, 0, 0), t) {
    const h = document.createElement("canvas");
    h.width = i, h.height = s;
    const l = h.getContext("2d");
    return l ? (l.translate(0, s), l.scale(1, -1), l.drawImage(r, 0, 0), h.toDataURL("image/png")) : null;
  }
  return r.toDataURL("image/png");
}
function Vn(c, e = 0, t = 0) {
  const i = c.getInternalTexture();
  if (!i)
    return null;
  const s = c._readPixelsSync(e, t);
  return s ? Ir(s, c.getSize(), i.invertY) : null;
}
async function Wn(c, e = 0, t = 0) {
  const i = c.getInternalTexture();
  if (!i)
    return null;
  const s = await c.readPixels(e, t);
  return s ? Ir(s, c.getSize(), i.invertY) : null;
}
class B extends Ae {
  constructor(e, t, i, s, r = B.TRILINEAR_SAMPLINGMODE, n = null, a = null, o = null, h = !1, l, u, f, d, _) {
    var v, A, L, Q, ae, be, fe, ue, ie;
    super(t), this.url = null, this.uOffset = 0, this.vOffset = 0, this.uScale = 1, this.vScale = 1, this.uAng = 0, this.vAng = 0, this.wAng = 0, this.uRotationCenter = 0.5, this.vRotationCenter = 0.5, this.wRotationCenter = 0.5, this.homogeneousRotationInUVTransform = !1, this.inspectableCustomProperties = null, this._noMipmap = !1, this._invertY = !1, this._rowGenerationMatrix = null, this._cachedTextureMatrix = null, this._projectionModeMatrix = null, this._t0 = null, this._t1 = null, this._t2 = null, this._cachedUOffset = -1, this._cachedVOffset = -1, this._cachedUScale = 0, this._cachedVScale = 0, this._cachedUAng = -1, this._cachedVAng = -1, this._cachedWAng = -1, this._cachedProjectionMatrixId = -1, this._cachedURotationCenter = -1, this._cachedVRotationCenter = -1, this._cachedWRotationCenter = -1, this._cachedHomogeneousRotationInUVTransform = !1, this._cachedCoordinatesMode = -1, this._buffer = null, this._deleteBuffer = !1, this._format = null, this._delayedOnLoad = null, this._delayedOnError = null, this.onLoadObservable = new F(), this._isBlocking = !0, this.name = e || "", this.url = e;
    let E, m = !1, T = null;
    typeof i == "object" && i !== null ? (E = (v = i.noMipmap) != null ? v : !1, s = (A = i.invertY) != null ? A : !ct.UseOpenGLOrientationForUV, r = (L = i.samplingMode) != null ? L : B.TRILINEAR_SAMPLINGMODE, n = (Q = i.onLoad) != null ? Q : null, a = (ae = i.onError) != null ? ae : null, o = (be = i.buffer) != null ? be : null, h = (fe = i.deleteBuffer) != null ? fe : !1, l = i.format, u = i.mimeType, f = i.loaderOptions, d = i.creationFlags, m = (ue = i.useSRGBBuffer) != null ? ue : !1, T = (ie = i.internalTexture) != null ? ie : null) : E = !!i, this._noMipmap = E, this._invertY = s === void 0 ? !ct.UseOpenGLOrientationForUV : s, this._initialSamplingMode = r, this._buffer = o, this._deleteBuffer = h, this._mimeType = u, this._loaderOptions = f, this._creationFlags = d, this._useSRGBBuffer = m, this._forcedExtension = _, l && (this._format = l);
    const b = this.getScene(), R = this._getEngine();
    if (!R)
      return;
    R.onBeforeTextureInitObservable.notifyObservers(this);
    const y = () => {
      this._texture && (this._texture._invertVScale && (this.vScale *= -1, this.vOffset += 1), this._texture._cachedWrapU !== null && (this.wrapU = this._texture._cachedWrapU, this._texture._cachedWrapU = null), this._texture._cachedWrapV !== null && (this.wrapV = this._texture._cachedWrapV, this._texture._cachedWrapV = null), this._texture._cachedWrapR !== null && (this.wrapR = this._texture._cachedWrapR, this._texture._cachedWrapR = null)), this.onLoadObservable.hasObservers() && this.onLoadObservable.notifyObservers(this), n && n(), !this.isBlocking && b && b.resetCachedMaterial();
    }, P = (ye, Ce) => {
      this._loadingError = !0, this._errorObject = { message: ye, exception: Ce }, a && a(ye, Ce), B.OnTextureLoadErrorObservable.notifyObservers(this);
    };
    if (!this.url) {
      this._delayedOnLoad = y, this._delayedOnError = P;
      return;
    }
    if (this._texture = T != null ? T : this._getFromCache(this.url, E, r, this._invertY, m), this._texture)
      if (this._texture.isReady)
        Ki.SetImmediate(() => y());
      else {
        const ye = this._texture.onLoadedObservable.add(y);
        this._texture.onErrorObservable.add((Ce) => {
          var He;
          P(Ce.message, Ce.exception), (He = this._texture) == null || He.onLoadedObservable.remove(ye);
        });
      }
    else if (!b || !b.useDelayedTextureLoading) {
      try {
        this._texture = R.createTexture(this.url, E, this._invertY, b, r, y, P, this._buffer, void 0, this._format, this._forcedExtension, u, f, d, m);
      } catch (ye) {
        throw P("error loading", ye), ye;
      }
      h && (this._buffer = null);
    } else
      this.delayLoadState = 4, this._delayedOnLoad = y, this._delayedOnError = P;
  }
  get noMipmap() {
    return this._noMipmap;
  }
  get mimeType() {
    return this._mimeType;
  }
  set isBlocking(e) {
    this._isBlocking = e;
  }
  get isBlocking() {
    return this._isBlocking;
  }
  get invertY() {
    return this._invertY;
  }
  updateURL(e, t = null, i, s) {
    this.url && (this.releaseInternalTexture(), this.getScene().markAllMaterialsAsDirty(1)), (!this.name || this.name.startsWith("data:")) && (this.name = e), this.url = e, this._buffer = t, this._forcedExtension = s, this.delayLoadState = 4, i && (this._delayedOnLoad = i), this.delayLoad();
  }
  delayLoad() {
    if (this.delayLoadState !== 4)
      return;
    const e = this.getScene();
    !e || (this.delayLoadState = 1, this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer), this._texture ? this._delayedOnLoad && (this._texture.isReady ? Ki.SetImmediate(this._delayedOnLoad) : this._texture.onLoadedObservable.add(this._delayedOnLoad)) : (this._texture = e.getEngine().createTexture(this.url, this._noMipmap, this._invertY, e, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, this._forcedExtension, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer), this._deleteBuffer && (this._buffer = null)), this._delayedOnLoad = null, this._delayedOnError = null);
  }
  _prepareRowForTextureGeneration(e, t, i, s) {
    e *= this._cachedUScale, t *= this._cachedVScale, e -= this.uRotationCenter * this._cachedUScale, t -= this.vRotationCenter * this._cachedVScale, i -= this.wRotationCenter, g.TransformCoordinatesFromFloatsToRef(e, t, i, this._rowGenerationMatrix, s), s.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset, s.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset, s.z += this.wRotationCenter;
  }
  checkTransformsAreIdentical(e) {
    return e !== null && this.uOffset === e.uOffset && this.vOffset === e.vOffset && this.uScale === e.uScale && this.vScale === e.vScale && this.uAng === e.uAng && this.vAng === e.vAng && this.wAng === e.wAng;
  }
  getTextureMatrix(e = 1) {
    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * e === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform)
      return this._cachedTextureMatrix;
    this._cachedUOffset = this.uOffset, this._cachedVOffset = this.vOffset, this._cachedUScale = this.uScale * e, this._cachedVScale = this.vScale, this._cachedUAng = this.uAng, this._cachedVAng = this.vAng, this._cachedWAng = this.wAng, this._cachedURotationCenter = this.uRotationCenter, this._cachedVRotationCenter = this.vRotationCenter, this._cachedWRotationCenter = this.wRotationCenter, this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform, (!this._cachedTextureMatrix || !this._rowGenerationMatrix) && (this._cachedTextureMatrix = x.Zero(), this._rowGenerationMatrix = new x(), this._t0 = g.Zero(), this._t1 = g.Zero(), this._t2 = g.Zero()), x.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix), this.homogeneousRotationInUVTransform ? (x.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, D.Matrix[0]), x.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, D.Matrix[1]), x.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, D.Matrix[2]), x.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, D.Matrix[3]), D.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(D.Matrix[1], this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(D.Matrix[2], this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(D.Matrix[3], this._cachedTextureMatrix), this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1)) : (this._prepareRowForTextureGeneration(0, 0, 0, this._t0), this._prepareRowForTextureGeneration(1, 0, 0, this._t1), this._prepareRowForTextureGeneration(0, 1, 0, this._t2), this._t1.subtractInPlace(this._t0), this._t2.subtractInPlace(this._t0), x.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0, this._t2.x, this._t2.y, this._t2.z, 0, this._t0.x, this._t0.y, this._t0.z, 0, 0, 0, 0, 1, this._cachedTextureMatrix));
    const t = this.getScene();
    return t ? (t.markAllMaterialsAsDirty(1, (i) => i.hasTexture(this)), this._cachedTextureMatrix) : this._cachedTextureMatrix;
  }
  getReflectionTextureMatrix() {
    const e = this.getScene();
    if (!e)
      return this._cachedTextureMatrix;
    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale === this._cachedUScale && this.vScale === this._cachedVScale && this.coordinatesMode === this._cachedCoordinatesMode)
      if (this.coordinatesMode === B.PROJECTION_MODE) {
        if (this._cachedProjectionMatrixId === e.getProjectionMatrix().updateFlag)
          return this._cachedTextureMatrix;
      } else
        return this._cachedTextureMatrix;
    this._cachedTextureMatrix || (this._cachedTextureMatrix = x.Zero()), this._projectionModeMatrix || (this._projectionModeMatrix = x.Zero());
    const t = this._cachedCoordinatesMode !== this.coordinatesMode;
    switch (this._cachedUOffset = this.uOffset, this._cachedVOffset = this.vOffset, this._cachedUScale = this.uScale, this._cachedVScale = this.vScale, this._cachedCoordinatesMode = this.coordinatesMode, this.coordinatesMode) {
      case B.PLANAR_MODE: {
        x.IdentityToRef(this._cachedTextureMatrix), this._cachedTextureMatrix[0] = this.uScale, this._cachedTextureMatrix[5] = this.vScale, this._cachedTextureMatrix[12] = this.uOffset, this._cachedTextureMatrix[13] = this.vOffset;
        break;
      }
      case B.PROJECTION_MODE: {
        x.FromValuesToRef(0.5, 0, 0, 0, 0, -0.5, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, this._projectionModeMatrix);
        const i = e.getProjectionMatrix();
        this._cachedProjectionMatrixId = i.updateFlag, i.multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);
        break;
      }
      default:
        x.IdentityToRef(this._cachedTextureMatrix);
        break;
    }
    return t && e.markAllMaterialsAsDirty(1, (i) => i.getActiveTextures().indexOf(this) !== -1), this._cachedTextureMatrix;
  }
  clone() {
    const e = {
      noMipmap: this._noMipmap,
      invertY: this._invertY,
      samplingMode: this.samplingMode,
      onLoad: void 0,
      onError: void 0,
      buffer: this._texture ? this._texture._buffer : void 0,
      deleteBuffer: this._deleteBuffer,
      format: this.textureFormat,
      mimeType: this.mimeType,
      loaderOptions: this._loaderOptions,
      creationFlags: this._creationFlags,
      useSRGBBuffer: this._useSRGBBuffer
    };
    return ne.Clone(() => new B(this._texture ? this._texture.url : null, this.getScene(), e), this);
  }
  serialize() {
    const e = this.name;
    B.SerializeBuffers || this.name.startsWith("data:") && (this.name = ""), this.name.startsWith("data:") && this.url === this.name && (this.url = "");
    const t = super.serialize();
    return t ? ((B.SerializeBuffers || B.ForceSerializeBuffers) && (typeof this._buffer == "string" && this._buffer.substr(0, 5) === "data:" ? (t.base64String = this._buffer, t.name = t.name.replace("data:", "")) : this.url && this.url.startsWith("data:") && this._buffer instanceof Uint8Array ? t.base64String = "data:image/png;base64," + mr(this._buffer) : (B.ForceSerializeBuffers || this.url && this.url.startsWith("blob:") || this._forceSerialize) && (t.base64String = !this._engine || this._engine._features.supportSyncTextureRead ? Vn(this) : Wn(this))), t.invertY = this._invertY, t.samplingMode = this.samplingMode, t._creationFlags = this._creationFlags, t._useSRGBBuffer = this._useSRGBBuffer, this.name = e, t) : null;
  }
  getClassName() {
    return "Texture";
  }
  dispose() {
    super.dispose(), this.onLoadObservable.clear(), this._delayedOnLoad = null, this._delayedOnError = null;
  }
  static Parse(e, t, i) {
    if (e.customType) {
      const a = Ri.Instantiate(e.customType).Parse(e, t, i);
      return e.samplingMode && a.updateSamplingMode && a._samplingMode && a._samplingMode !== e.samplingMode && a.updateSamplingMode(e.samplingMode), a;
    }
    if (e.isCube && !e.isRenderTarget)
      return B._CubeTextureParser(e, t, i);
    if (!e.name && !e.isRenderTarget)
      return null;
    const s = (n) => {
      if (n && n._texture && (n._texture._cachedWrapU = null, n._texture._cachedWrapV = null, n._texture._cachedWrapR = null), e.samplingMode) {
        const a = e.samplingMode;
        n && n.samplingMode !== a && n.updateSamplingMode(a);
      }
      if (n && e.animations)
        for (let a = 0; a < e.animations.length; a++) {
          const o = e.animations[a], h = oi("BABYLON.Animation");
          h && n.animations.push(h.Parse(o));
        }
    };
    return ne.Parse(() => {
      var a, o, h;
      let n = !0;
      if (e.noMipmap && (n = !1), e.mirrorPlane) {
        const l = B._CreateMirror(e.name, e.renderTargetSize, t, n);
        return l._waitingRenderList = e.renderList, l.mirrorPlane = xt.FromArray(e.mirrorPlane), s(l), l;
      } else if (e.isRenderTarget) {
        let l = null;
        if (e.isCube) {
          if (t.reflectionProbes)
            for (let u = 0; u < t.reflectionProbes.length; u++) {
              const f = t.reflectionProbes[u];
              if (f.name === e.name)
                return f.cubeTexture;
            }
        } else
          l = B._CreateRenderTargetTexture(e.name, e.renderTargetSize, t, n, (a = e._creationFlags) != null ? a : 0), l._waitingRenderList = e.renderList;
        return s(l), l;
      } else {
        let l;
        if (e.base64String)
          l = B.CreateFromBase64String(e.base64String, e.base64String, t, !n, e.invertY, e.samplingMode, () => {
            s(l);
          }, (o = e._creationFlags) != null ? o : 0, (h = e._useSRGBBuffer) != null ? h : !1), l.name = e.name;
        else {
          let u;
          e.name && e.name.indexOf("://") > 0 ? u = e.name : u = i + e.name, e.url && (e.url.startsWith("data:") || B.UseSerializedUrlIfAny) && (u = e.url), l = new B(u, t, !n, e.invertY, e.samplingMode, () => {
            s(l);
          });
        }
        return l;
      }
    }, e, t);
  }
  static CreateFromBase64String(e, t, i, s, r, n = B.TRILINEAR_SAMPLINGMODE, a = null, o = null, h = 5, l) {
    return new B("data:" + t, i, s, r, n, a, o, e, !1, h, void 0, void 0, l);
  }
  static LoadFromDataString(e, t, i, s = !1, r, n = !0, a = B.TRILINEAR_SAMPLINGMODE, o = null, h = null, l = 5, u) {
    return e.substr(0, 5) !== "data:" && (e = "data:" + e), new B(e, i, r, n, a, o, h, t, s, l, void 0, void 0, u);
  }
}
B.SerializeBuffers = !0;
B.ForceSerializeBuffers = !1;
B.OnTextureLoadErrorObservable = new F();
B._CubeTextureParser = (c, e, t) => {
  throw q("CubeTexture");
};
B._CreateMirror = (c, e, t, i) => {
  throw q("MirrorTexture");
};
B._CreateRenderTargetTexture = (c, e, t, i, s) => {
  throw q("RenderTargetTexture");
};
B.NEAREST_SAMPLINGMODE = 1;
B.NEAREST_NEAREST_MIPLINEAR = 8;
B.BILINEAR_SAMPLINGMODE = 2;
B.LINEAR_LINEAR_MIPNEAREST = 11;
B.TRILINEAR_SAMPLINGMODE = 3;
B.LINEAR_LINEAR_MIPLINEAR = 3;
B.NEAREST_NEAREST_MIPNEAREST = 4;
B.NEAREST_LINEAR_MIPNEAREST = 5;
B.NEAREST_LINEAR_MIPLINEAR = 6;
B.NEAREST_LINEAR = 7;
B.NEAREST_NEAREST = 1;
B.LINEAR_NEAREST_MIPNEAREST = 9;
B.LINEAR_NEAREST_MIPLINEAR = 10;
B.LINEAR_LINEAR = 2;
B.LINEAR_NEAREST = 12;
B.EXPLICIT_MODE = 0;
B.SPHERICAL_MODE = 1;
B.PLANAR_MODE = 2;
B.CUBIC_MODE = 3;
B.PROJECTION_MODE = 4;
B.SKYBOX_MODE = 5;
B.INVCUBIC_MODE = 6;
B.EQUIRECTANGULAR_MODE = 7;
B.FIXED_EQUIRECTANGULAR_MODE = 8;
B.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
B.CLAMP_ADDRESSMODE = 0;
B.WRAP_ADDRESSMODE = 1;
B.MIRROR_ADDRESSMODE = 2;
B.UseSerializedUrlIfAny = !1;
S([
  M()
], B.prototype, "url", void 0);
S([
  M()
], B.prototype, "uOffset", void 0);
S([
  M()
], B.prototype, "vOffset", void 0);
S([
  M()
], B.prototype, "uScale", void 0);
S([
  M()
], B.prototype, "vScale", void 0);
S([
  M()
], B.prototype, "uAng", void 0);
S([
  M()
], B.prototype, "vAng", void 0);
S([
  M()
], B.prototype, "wAng", void 0);
S([
  M()
], B.prototype, "uRotationCenter", void 0);
S([
  M()
], B.prototype, "vRotationCenter", void 0);
S([
  M()
], B.prototype, "wRotationCenter", void 0);
S([
  M()
], B.prototype, "homogeneousRotationInUVTransform", void 0);
S([
  M()
], B.prototype, "isBlocking", null);
it("BABYLON.Texture", B);
ne._TextureParser = B.Parse;
class zn {
  constructor(e, t, i, s) {
    this._textures = null, this._attachments = null, this._generateStencilBuffer = !1, this._generateDepthBuffer = !1, this._depthStencilTextureWithStencil = !1, this._isMulti = e, this._isCube = t, this._size = i, this._engine = s, this._depthStencilTexture = null;
  }
  get depthStencilTexture() {
    return this._depthStencilTexture;
  }
  get depthStencilTextureWithStencil() {
    return this._depthStencilTextureWithStencil;
  }
  get isCube() {
    return this._isCube;
  }
  get isMulti() {
    return this._isMulti;
  }
  get is2DArray() {
    return this.layers > 0;
  }
  get size() {
    return this.width;
  }
  get width() {
    return this._size.width || this._size;
  }
  get height() {
    return this._size.height || this._size;
  }
  get layers() {
    return this._size.layers || 0;
  }
  get texture() {
    var e, t;
    return (t = (e = this._textures) == null ? void 0 : e[0]) != null ? t : null;
  }
  get textures() {
    return this._textures;
  }
  get samples() {
    var e, t;
    return (t = (e = this.texture) == null ? void 0 : e.samples) != null ? t : 1;
  }
  setSamples(e, t = !0, i = !1) {
    return this.samples === e && !i ? e : this._isMulti ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, e, t) : this._engine.updateRenderTargetTextureSampleCount(this, e);
  }
  setTextures(e) {
    Array.isArray(e) ? this._textures = e : e ? this._textures = [e] : this._textures = null;
  }
  setTexture(e, t = 0, i = !0) {
    this._textures || (this._textures = []), this._textures[t] && i && this._textures[t].dispose(), this._textures[t] = e;
  }
  createDepthStencilTexture(e = 0, t = !0, i = !1, s = 1, r = 14) {
    var n;
    return (n = this._depthStencilTexture) == null || n.dispose(), this._depthStencilTextureWithStencil = i, this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {
      bilinearFiltering: t,
      comparisonFunction: e,
      generateStencil: i,
      isCube: this._isCube,
      samples: s,
      depthTextureFormat: r
    }, this), this._depthStencilTexture;
  }
  _shareDepth(e) {
    this._depthStencilTexture && (e._depthStencilTexture && e._depthStencilTexture.dispose(), e._depthStencilTexture = this._depthStencilTexture, this._depthStencilTexture.incrementReferences());
  }
  _swapAndDie(e) {
    this.texture && this.texture._swapAndDie(e), this._textures = null, this.dispose(!0);
  }
  _cloneRenderTargetWrapper() {
    var t, i, s, r, n, a;
    let e = null;
    if (this._isMulti) {
      const o = this.textures;
      if (o && o.length > 0) {
        let h = !1, l = o.length;
        const u = o[o.length - 1]._source;
        (u === Le.Depth || u === Le.DepthStencil) && (h = !0, l--);
        const f = [], d = [];
        for (let m = 0; m < l; ++m) {
          const T = o[m];
          f.push(T.samplingMode), d.push(T.type);
        }
        const _ = {
          samplingModes: f,
          generateMipMaps: o[0].generateMipMaps,
          generateDepthBuffer: this._generateDepthBuffer,
          generateStencilBuffer: this._generateStencilBuffer,
          generateDepthTexture: h,
          types: d,
          textureCount: l
        }, E = {
          width: this.width,
          height: this.height
        };
        e = this._engine.createMultipleRenderTarget(E, _);
      }
    } else {
      const o = {};
      if (o.generateDepthBuffer = this._generateDepthBuffer, o.generateMipMaps = (i = (t = this.texture) == null ? void 0 : t.generateMipMaps) != null ? i : !1, o.generateStencilBuffer = this._generateStencilBuffer, o.samplingMode = (s = this.texture) == null ? void 0 : s.samplingMode, o.type = (r = this.texture) == null ? void 0 : r.type, o.format = (n = this.texture) == null ? void 0 : n.format, this.isCube)
        e = this._engine.createRenderTargetCubeTexture(this.width, o);
      else {
        const h = {
          width: this.width,
          height: this.height,
          layers: this.is2DArray ? (a = this.texture) == null ? void 0 : a.depth : void 0
        };
        e = this._engine.createRenderTargetTexture(h, o);
      }
      e.texture.isReady = !0;
    }
    return e;
  }
  _swapRenderTargetWrapper(e) {
    if (this._textures && e._textures)
      for (let t = 0; t < this._textures.length; ++t)
        this._textures[t]._swapAndDie(e._textures[t], !1), e._textures[t].isReady = !0;
    this._depthStencilTexture && e._depthStencilTexture && (this._depthStencilTexture._swapAndDie(e._depthStencilTexture), e._depthStencilTexture.isReady = !0), this._textures = null, this._depthStencilTexture = null;
  }
  _rebuild() {
    const e = this._cloneRenderTargetWrapper();
    if (!!e) {
      if (this._depthStencilTexture) {
        const t = this._depthStencilTexture.samplingMode, i = t === 2 || t === 3 || t === 11;
        e.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, i, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);
      }
      this.samples > 1 && e.setSamples(this.samples), e._swapRenderTargetWrapper(this), e.dispose();
    }
  }
  releaseTextures() {
    var e;
    if (this._textures)
      for (let t = 0; t < ((e = this._textures) == null ? void 0 : e.length); ++t)
        this._textures[t].dispose();
    this._textures = null;
  }
  dispose(e = !1) {
    var t;
    e || ((t = this._depthStencilTexture) == null || t.dispose(), this._depthStencilTexture = null, this.releaseTextures()), this._engine._releaseRenderTargetWrapper(this);
  }
}
class Gn extends zn {
  constructor(e, t, i, s, r) {
    super(e, t, i, s), this._framebuffer = null, this._depthStencilBuffer = null, this._MSAAFramebuffer = null, this._colorTextureArray = null, this._depthStencilTextureArray = null, this._context = r;
  }
  _cloneRenderTargetWrapper() {
    let e = null;
    return this._colorTextureArray && this._depthStencilTextureArray ? (e = this._engine.createMultiviewRenderTargetTexture(this.width, this.height), e.texture.isReady = !0) : e = super._cloneRenderTargetWrapper(), e;
  }
  _swapRenderTargetWrapper(e) {
    super._swapRenderTargetWrapper(e), e._framebuffer = this._framebuffer, e._depthStencilBuffer = this._depthStencilBuffer, e._MSAAFramebuffer = this._MSAAFramebuffer, e._colorTextureArray = this._colorTextureArray, e._depthStencilTextureArray = this._depthStencilTextureArray, this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null;
  }
  _shareDepth(e) {
    super._shareDepth(e);
    const t = this._context, i = this._depthStencilBuffer, s = e._framebuffer;
    e._depthStencilBuffer && t.deleteRenderbuffer(e._depthStencilBuffer), e._depthStencilBuffer = this._depthStencilBuffer, this._engine._bindUnboundFramebuffer(s), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, i), this._engine._bindUnboundFramebuffer(null);
  }
  _bindTextureRenderTarget(e, t = 0, i = -1, s = 0) {
    if (!e._hardwareTexture)
      return;
    const r = this._context, n = this._framebuffer, a = this._engine._currentFramebuffer;
    this._engine._bindUnboundFramebuffer(n);
    const o = r[this._engine.webGLVersion > 1 ? "COLOR_ATTACHMENT" + t : "COLOR_ATTACHMENT" + t + "_WEBGL"], h = i !== -1 ? r.TEXTURE_CUBE_MAP_POSITIVE_X + i : r.TEXTURE_2D;
    r.framebufferTexture2D(r.FRAMEBUFFER, o, h, e._hardwareTexture.underlyingResource, s), this._engine._bindUnboundFramebuffer(a);
  }
  setTexture(e, t = 0, i = !0) {
    super.setTexture(e, t, i), this._bindTextureRenderTarget(e, t);
  }
  dispose(e = !1) {
    const t = this._context;
    e || (this._colorTextureArray && (this._context.deleteTexture(this._colorTextureArray), this._colorTextureArray = null), this._depthStencilTextureArray && (this._context.deleteTexture(this._depthStencilTextureArray), this._depthStencilTextureArray = null)), this._framebuffer && (t.deleteFramebuffer(this._framebuffer), this._framebuffer = null), this._depthStencilBuffer && (t.deleteRenderbuffer(this._depthStencilBuffer), this._depthStencilBuffer = null), this._MSAAFramebuffer && (t.deleteFramebuffer(this._MSAAFramebuffer), this._MSAAFramebuffer = null), super.dispose(e);
  }
}
le.prototype._createHardwareRenderTargetWrapper = function(c, e, t) {
  const i = new Gn(c, e, t, this, this._gl);
  return this._renderTargetWrapperCache.push(i), i;
};
le.prototype.createRenderTargetTexture = function(c, e) {
  const t = this._createHardwareRenderTargetWrapper(!1, !1, c), i = {};
  e !== void 0 && typeof e == "object" ? (i.generateDepthBuffer = !!e.generateDepthBuffer, i.generateStencilBuffer = !!e.generateStencilBuffer, i.noColorTarget = !!e.noColorTarget) : (i.generateDepthBuffer = !0, i.generateStencilBuffer = !1, i.noColorTarget = !1);
  const s = i.noColorTarget ? null : this._createInternalTexture(c, e, !0, Le.RenderTarget), r = c.width || c, n = c.height || c, a = this._currentFramebuffer, o = this._gl, h = o.createFramebuffer();
  return this._bindUnboundFramebuffer(h), t._depthStencilBuffer = this._setupFramebufferDepthAttachments(!!i.generateStencilBuffer, i.generateDepthBuffer, r, n), s && !s.is2DArray && o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, s._hardwareTexture.underlyingResource, 0), this._bindUnboundFramebuffer(a), t._framebuffer = h, t._generateDepthBuffer = i.generateDepthBuffer, t._generateStencilBuffer = !!i.generateStencilBuffer, t.setTextures(s), t;
};
le.prototype.createDepthStencilTexture = function(c, e, t) {
  if (e.isCube) {
    const i = c.width || c;
    return this._createDepthStencilCubeTexture(i, e, t);
  } else
    return this._createDepthStencilTexture(c, e, t);
};
le.prototype._createDepthStencilTexture = function(c, e, t) {
  const i = this._gl, s = c.layers || 0, r = s !== 0 ? i.TEXTURE_2D_ARRAY : i.TEXTURE_2D, n = new kt(this, Le.DepthStencil);
  if (!this._caps.depthTextureExtension)
    return w.Error("Depth texture is not supported by your browser or hardware."), n;
  const a = {
    bilinearFiltering: !1,
    comparisonFunction: 0,
    generateStencil: !1,
    ...e
  };
  if (this._bindTextureDirectly(r, n, !0), this._setupDepthStencilTexture(n, c, a.generateStencil, a.comparisonFunction === 0 ? !1 : a.bilinearFiltering, a.comparisonFunction), a.depthTextureFormat !== void 0) {
    if (a.depthTextureFormat !== 15 && a.depthTextureFormat !== 16 && a.depthTextureFormat !== 17 && a.depthTextureFormat !== 13 && a.depthTextureFormat !== 14 && a.depthTextureFormat !== 18)
      return w.Error("Depth texture format is not supported."), n;
    n.format = a.depthTextureFormat;
  } else
    n.format = a.generateStencil ? 13 : 16;
  const o = n.format === 17 || n.format === 13 || n.format === 18;
  t._depthStencilTexture = n, t._depthStencilTextureWithStencil = o;
  let h = i.UNSIGNED_INT;
  n.format === 15 ? h = i.UNSIGNED_SHORT : n.format === 17 || n.format === 13 ? h = i.UNSIGNED_INT_24_8 : n.format === 14 ? h = i.FLOAT : n.format === 18 && (h = i.FLOAT_32_UNSIGNED_INT_24_8_REV);
  const l = o ? i.DEPTH_STENCIL : i.DEPTH_COMPONENT;
  let u = l;
  this.webGLVersion > 1 && (n.format === 15 ? u = i.DEPTH_COMPONENT16 : n.format === 16 ? u = i.DEPTH_COMPONENT24 : n.format === 17 || n.format === 13 ? u = i.DEPTH24_STENCIL8 : n.format === 14 ? u = i.DEPTH_COMPONENT32F : n.format === 18 && (u = i.DEPTH32F_STENCIL8)), n.is2DArray ? i.texImage3D(r, 0, u, n.width, n.height, s, 0, l, h, null) : i.texImage2D(r, 0, u, n.width, n.height, 0, l, h, null), this._bindTextureDirectly(r, null), this._internalTexturesCache.push(n);
  const f = t;
  if (f._depthStencilBuffer) {
    const d = this._currentFramebuffer;
    this._bindUnboundFramebuffer(f._framebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, null), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, null), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.STENCIL_ATTACHMENT, i.RENDERBUFFER, null), this._bindUnboundFramebuffer(d), i.deleteRenderbuffer(f._depthStencilBuffer), f._depthStencilBuffer = null;
  }
  return n;
};
le.prototype.updateRenderTargetTextureSampleCount = function(c, e) {
  if (this.webGLVersion < 2 || !c || !c.texture)
    return 1;
  if (c.samples === e)
    return e;
  const t = this._gl;
  e = Math.min(e, this.getCaps().maxMSAASamples), c._depthStencilBuffer && (t.deleteRenderbuffer(c._depthStencilBuffer), c._depthStencilBuffer = null), c._MSAAFramebuffer && (t.deleteFramebuffer(c._MSAAFramebuffer), c._MSAAFramebuffer = null);
  const i = c.texture._hardwareTexture;
  if (i._MSAARenderBuffer && (t.deleteRenderbuffer(i._MSAARenderBuffer), i._MSAARenderBuffer = null), e > 1 && t.renderbufferStorageMultisample) {
    const s = t.createFramebuffer();
    if (!s)
      throw new Error("Unable to create multi sampled framebuffer");
    c._MSAAFramebuffer = s, this._bindUnboundFramebuffer(c._MSAAFramebuffer);
    const r = this._createRenderBuffer(c.texture.width, c.texture.height, e, -1, this._getRGBAMultiSampleBufferFormat(c.texture.type), t.COLOR_ATTACHMENT0, !1);
    if (!r)
      throw new Error("Unable to create multi sampled framebuffer");
    i._MSAARenderBuffer = r;
  } else
    this._bindUnboundFramebuffer(c._framebuffer);
  return c.texture.samples = e, c._depthStencilBuffer = this._setupFramebufferDepthAttachments(c._generateStencilBuffer, c._generateDepthBuffer, c.texture.width, c.texture.height, e), this._bindUnboundFramebuffer(null), e;
};
le.prototype.createRenderTargetCubeTexture = function(c, e) {
  const t = this._createHardwareRenderTargetWrapper(!1, !0, c), i = {
    generateMipMaps: !0,
    generateDepthBuffer: !0,
    generateStencilBuffer: !1,
    type: 0,
    samplingMode: 3,
    format: 5,
    ...e
  };
  i.generateStencilBuffer = i.generateDepthBuffer && i.generateStencilBuffer, (i.type === 1 && !this._caps.textureFloatLinearFiltering || i.type === 2 && !this._caps.textureHalfFloatLinearFiltering) && (i.samplingMode = 1);
  const s = this._gl, r = new kt(this, Le.RenderTarget);
  this._bindTextureDirectly(s.TEXTURE_CUBE_MAP, r, !0);
  const n = this._getSamplingParameters(i.samplingMode, i.generateMipMaps);
  i.type === 1 && !this._caps.textureFloat && (i.type = 0, w.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type")), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAG_FILTER, n.mag), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MIN_FILTER, n.min), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE);
  for (let o = 0; o < 6; o++)
    s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, this._getRGBABufferInternalSizedFormat(i.type, i.format), c, c, 0, this._getInternalFormat(i.format), this._getWebGLTextureType(i.type), null);
  const a = s.createFramebuffer();
  return this._bindUnboundFramebuffer(a), t._depthStencilBuffer = this._setupFramebufferDepthAttachments(i.generateStencilBuffer, i.generateDepthBuffer, c, c), i.generateMipMaps && s.generateMipmap(s.TEXTURE_CUBE_MAP), this._bindTextureDirectly(s.TEXTURE_CUBE_MAP, null), this._bindUnboundFramebuffer(null), t._framebuffer = a, t._generateDepthBuffer = i.generateDepthBuffer, t._generateStencilBuffer = i.generateStencilBuffer, r.width = c, r.height = c, r.isReady = !0, r.isCube = !0, r.samples = 1, r.generateMipMaps = i.generateMipMaps, r.samplingMode = i.samplingMode, r.type = i.type, r.format = i.format, this._internalTexturesCache.push(r), t.setTextures(r), t;
};
class dt extends B {
  constructor(e, t, i, s, r = !0, n = 0, a = !1, o = B.TRILINEAR_SAMPLINGMODE, h = !0, l = !1, u = !1, f = 5, d = !1, _, E, m = !1, T = !1) {
    var R;
    if (super(null, i, !s, void 0, o, void 0, void 0, void 0, void 0, f), this._renderListHasChangedObservable = new F(), this._renderListHasChangedObserver = null, this.renderParticles = !0, this.renderSprites = !1, this.ignoreCameraViewport = !1, this.onBeforeBindObservable = new F(), this.onAfterUnbindObservable = new F(), this.onBeforeRenderObservable = new F(), this.onAfterRenderObservable = new F(), this.onClearObservable = new F(), this.onResizeObservable = new F(), this._cleared = !1, this.skipInitialClear = !1, this._currentRefreshId = -1, this._refreshRate = 1, this._samples = 1, this._canRescale = !0, this._renderTarget = null, this.boundingBoxPosition = g.Zero(), i = this.getScene(), !i)
      return;
    const b = this.getScene().getEngine();
    this._startObservingRenderListEvents(), this._coordinatesMode = B.PROJECTION_MODE, this.renderList = new Array(), this.name = e, this.isRenderTarget = !0, this._initialSizeParameter = t, this._renderPassIds = [], this._isCubeData = a, this._processSizeParameter(t), this.renderPassId = this._renderPassIds[0], this._resizeObserver = b.onResizeObservable.add(() => {
    }), this._generateMipMaps = !!s, this._doNotChangeAspectRatio = r, this._renderingManager = new Ye(i), this._renderingManager._useSceneAutoClearSetup = !0, !u && (this._renderTargetOptions = {
      generateMipMaps: s,
      type: n,
      format: (R = this._format) != null ? R : void 0,
      samplingMode: this.samplingMode,
      generateDepthBuffer: h,
      generateStencilBuffer: l,
      samples: _,
      creationFlags: E,
      noColorTarget: m,
      useSRGBBuffer: T
    }, this.samplingMode === B.NEAREST_SAMPLINGMODE && (this.wrapU = B.CLAMP_ADDRESSMODE, this.wrapV = B.CLAMP_ADDRESSMODE), d || (a ? (this._renderTarget = i.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions), this.coordinatesMode = B.INVCUBIC_MODE, this._textureMatrix = x.Identity()) : this._renderTarget = i.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions), this._texture = this._renderTarget.texture, _ !== void 0 && (this.samples = _)));
  }
  get renderList() {
    return this._renderList;
  }
  _startObservingRenderListEvents() {
    this._renderListHasChangedObserver = this._renderListHasChangedObservable.add(({ target: e, previousLength: t }) => {
      var i;
      e && t && (e.length > 0 && t === 0 || e.length === 0 && t > 0) && ((i = this.getScene()) == null || i.meshes.forEach((s) => {
        s._markSubMeshesAsLightDirty();
      }));
    });
  }
  _stopObservingRenderListEvents() {
    this._renderListHasChangedObservable.remove(this._renderListHasChangedObserver);
  }
  set renderList(e) {
    this._renderList = Me.MakeObservableArray(this._renderListHasChangedObservable, e);
  }
  get postProcesses() {
    return this._postProcesses;
  }
  get _prePassEnabled() {
    return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled;
  }
  set onAfterUnbind(e) {
    this._onAfterUnbindObserver && this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver), this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(e);
  }
  set onBeforeRender(e) {
    this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e);
  }
  set onAfterRender(e) {
    this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e);
  }
  set onClear(e) {
    this._onClearObserver && this.onClearObservable.remove(this._onClearObserver), this._onClearObserver = this.onClearObservable.add(e);
  }
  get renderPassIds() {
    return this._renderPassIds;
  }
  get currentRefreshId() {
    return this._currentRefreshId;
  }
  setMaterialForRendering(e, t) {
    let i;
    Array.isArray(e) ? i = e : i = [e];
    for (let s = 0; s < i.length; ++s)
      for (let r = 0; r < this._renderPassIds.length; ++r)
        i[s].setMaterialForRenderPass(this._renderPassIds[r], t !== void 0 ? Array.isArray(t) ? t[r] : t : void 0);
  }
  get renderTargetOptions() {
    return this._renderTargetOptions;
  }
  get renderTarget() {
    return this._renderTarget;
  }
  _onRatioRescale() {
    this._sizeRatio && this.resize(this._initialSizeParameter);
  }
  set boundingBoxSize(e) {
    if (this._boundingBoxSize && this._boundingBoxSize.equals(e))
      return;
    this._boundingBoxSize = e;
    const t = this.getScene();
    t && t.markAllMaterialsAsDirty(1);
  }
  get boundingBoxSize() {
    return this._boundingBoxSize;
  }
  get depthStencilTexture() {
    var e, t;
    return (t = (e = this._renderTarget) == null ? void 0 : e._depthStencilTexture) != null ? t : null;
  }
  createDepthStencilTexture(e = 0, t = !0, i = !1, s = 1, r = 14) {
    var n;
    (n = this._renderTarget) == null || n.createDepthStencilTexture(e, t, i, s, r);
  }
  _releaseRenderPassId() {
    if (this._scene) {
      const e = this._scene.getEngine();
      for (let t = 0; t < this._renderPassIds.length; ++t)
        e.releaseRenderPassId(this._renderPassIds[t]);
    }
    this._renderPassIds = [];
  }
  _createRenderPassId() {
    this._releaseRenderPassId();
    const e = this._scene.getEngine(), t = this._isCubeData ? 6 : this.getRenderLayers() || 1;
    for (let i = 0; i < t; ++i)
      this._renderPassIds[i] = e.createRenderPassId(`RenderTargetTexture - ${this.name}#${i}`);
  }
  _processSizeParameter(e) {
    if (e.ratio) {
      this._sizeRatio = e.ratio;
      const t = this._getEngine();
      this._size = {
        width: this._bestReflectionRenderTargetDimension(t.getRenderWidth(), this._sizeRatio),
        height: this._bestReflectionRenderTargetDimension(t.getRenderHeight(), this._sizeRatio)
      };
    } else
      this._size = e;
    this._createRenderPassId();
  }
  get samples() {
    var e, t;
    return (t = (e = this._renderTarget) == null ? void 0 : e.samples) != null ? t : this._samples;
  }
  set samples(e) {
    this._renderTarget && (this._samples = this._renderTarget.setSamples(e));
  }
  resetRefreshCounter() {
    this._currentRefreshId = -1;
  }
  get refreshRate() {
    return this._refreshRate;
  }
  set refreshRate(e) {
    this._refreshRate = e, this.resetRefreshCounter();
  }
  addPostProcess(e) {
    if (!this._postProcessManager) {
      const t = this.getScene();
      if (!t)
        return;
      this._postProcessManager = new Qi(t), this._postProcesses = new Array();
    }
    this._postProcesses.push(e), this._postProcesses[0].autoClear = !1;
  }
  clearPostProcesses(e = !1) {
    if (!!this._postProcesses) {
      if (e)
        for (const t of this._postProcesses)
          t.dispose();
      this._postProcesses = [];
    }
  }
  removePostProcess(e) {
    if (!this._postProcesses)
      return;
    const t = this._postProcesses.indexOf(e);
    t !== -1 && (this._postProcesses.splice(t, 1), this._postProcesses.length > 0 && (this._postProcesses[0].autoClear = !1));
  }
  _shouldRender() {
    return this._currentRefreshId === -1 ? (this._currentRefreshId = 1, !0) : this.refreshRate === this._currentRefreshId ? (this._currentRefreshId = 1, !0) : (this._currentRefreshId++, !1);
  }
  getRenderSize() {
    return this.getRenderWidth();
  }
  getRenderWidth() {
    return this._size.width ? this._size.width : this._size;
  }
  getRenderHeight() {
    return this._size.width ? this._size.height : this._size;
  }
  getRenderLayers() {
    const e = this._size.layers;
    return e || 0;
  }
  disableRescaling() {
    this._canRescale = !1;
  }
  get canRescale() {
    return this._canRescale;
  }
  scale(e) {
    const t = Math.max(1, this.getRenderSize() * e);
    this.resize(t);
  }
  getReflectionTextureMatrix() {
    return this.isCube ? this._textureMatrix : super.getReflectionTextureMatrix();
  }
  resize(e) {
    var s;
    const t = this.isCube;
    (s = this._renderTarget) == null || s.dispose(), this._renderTarget = null;
    const i = this.getScene();
    !i || (this._processSizeParameter(e), t ? this._renderTarget = i.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions) : this._renderTarget = i.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions), this._texture = this._renderTarget.texture, this._renderTargetOptions.samples !== void 0 && (this.samples = this._renderTargetOptions.samples), this.onResizeObservable.hasObservers() && this.onResizeObservable.notifyObservers(this));
  }
  render(e = !1, t = !1) {
    this._render(e, t);
  }
  isReadyForRendering() {
    return this._render(!1, !1, !0);
  }
  _render(e = !1, t = !1, i = !1) {
    var l;
    const s = this.getScene();
    if (!s)
      return i;
    const r = s.getEngine();
    if (this.useCameraPostProcesses !== void 0 && (e = this.useCameraPostProcesses), this._waitingRenderList) {
      this.renderList = [];
      for (let u = 0; u < this._waitingRenderList.length; u++) {
        const f = this._waitingRenderList[u], d = s.getMeshById(f);
        d && this.renderList.push(d);
      }
      this._waitingRenderList = void 0;
    }
    if (this.renderListPredicate) {
      this.renderList ? this.renderList.length = 0 : this.renderList = [];
      const u = this.getScene();
      if (!u)
        return i;
      const f = u.meshes;
      for (let d = 0; d < f.length; d++) {
        const _ = f[d];
        this.renderListPredicate(_) && this.renderList.push(_);
      }
    }
    const n = r.currentRenderPassId;
    this.onBeforeBindObservable.notifyObservers(this);
    const a = (l = this.activeCamera) != null ? l : s.activeCamera, o = s.activeCamera;
    a && (a !== s.activeCamera && (s.setTransformMatrix(a.getViewMatrix(), a.getProjectionMatrix(!0)), s.activeCamera = a), r.setViewport(a.viewport, this.getRenderWidth(), this.getRenderHeight())), this._defaultRenderListPrepared = !1;
    let h = i;
    if (i) {
      s.getViewMatrix() || s.updateTransformMatrix();
      const u = this.is2DArray ? this.getRenderLayers() : this.isCube ? 6 : 1;
      for (let f = 0; f < u && h; f++) {
        let d = null;
        const _ = this.renderList ? this.renderList : s.getActiveMeshes().data, E = this.renderList ? this.renderList.length : s.getActiveMeshes().length;
        r.currentRenderPassId = this._renderPassIds[f], this.onBeforeRenderObservable.notifyObservers(f), this.getCustomRenderList && (d = this.getCustomRenderList(f, _, E)), d || (d = _), this._doNotChangeAspectRatio || s.updateTransformMatrix(!0);
        for (let m = 0; m < d.length && h; ++m) {
          const T = d[m];
          if (!(!T.isEnabled() || T.isBlocked || !T.isVisible || !T.subMeshes)) {
            if (this.customIsReadyFunction) {
              if (!this.customIsReadyFunction(T, this.refreshRate)) {
                h = !1;
                break;
              }
            } else if (!T.isReady(!0)) {
              h = !1;
              break;
            }
          }
        }
        this.onAfterRenderObservable.notifyObservers(f);
      }
    } else if (this.is2DArray)
      for (let u = 0; u < this.getRenderLayers(); u++)
        this._renderToTarget(0, e, t, u, a), s.incrementRenderId(), s.resetCachedMaterial();
    else if (this.isCube)
      for (let u = 0; u < 6; u++)
        this._renderToTarget(u, e, t, void 0, a), s.incrementRenderId(), s.resetCachedMaterial();
    else
      this._renderToTarget(0, e, t, void 0, a);
    return this.onAfterUnbindObservable.notifyObservers(this), r.currentRenderPassId = n, o && (s.activeCamera = o, (s.getEngine().scenes.length > 1 || this.activeCamera && this.activeCamera !== s.activeCamera) && s.setTransformMatrix(s.activeCamera.getViewMatrix(), s.activeCamera.getProjectionMatrix(!0)), r.setViewport(s.activeCamera.viewport)), s.resetCachedMaterial(), h;
  }
  _bestReflectionRenderTargetDimension(e, t) {
    const s = e * t, r = C.NearestPOT(s + 128 * 128 / (128 + s));
    return Math.min(C.FloorPOT(e), r);
  }
  _prepareRenderingManager(e, t, i, s) {
    const r = this.getScene();
    if (!r)
      return;
    this._renderingManager.reset();
    const n = r.getRenderId();
    for (let a = 0; a < t; a++) {
      const o = e[a];
      if (o && !o.isBlocked) {
        if (this.customIsReadyFunction) {
          if (!this.customIsReadyFunction(o, this.refreshRate)) {
            this.resetRefreshCounter();
            continue;
          }
        } else if (!o.isReady(this.refreshRate === 0)) {
          this.resetRefreshCounter();
          continue;
        }
        if (!o._internalAbstractMeshDataInfo._currentLODIsUpToDate && r.activeCamera && (o._internalAbstractMeshDataInfo._currentLOD = r.customLODSelector ? r.customLODSelector(o, this.activeCamera || r.activeCamera) : o.getLOD(this.activeCamera || r.activeCamera), o._internalAbstractMeshDataInfo._currentLODIsUpToDate = !0), !o._internalAbstractMeshDataInfo._currentLOD)
          continue;
        let h = o._internalAbstractMeshDataInfo._currentLOD;
        h._preActivateForIntermediateRendering(n);
        let l;
        if (s && i ? l = (o.layerMask & i.layerMask) === 0 : l = !1, o.isEnabled() && o.isVisible && o.subMeshes && !l && (h !== o && h._activate(n, !0), o._activate(n, !0) && o.subMeshes.length)) {
          o.isAnInstance ? o._internalAbstractMeshDataInfo._actAsRegularMesh && (h = o) : h._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = !1, h._internalAbstractMeshDataInfo._isActiveIntermediate = !0;
          for (let u = 0; u < h.subMeshes.length; u++) {
            const f = h.subMeshes[u];
            this._renderingManager.dispatch(f, h);
          }
        }
      }
    }
    for (let a = 0; a < r.particleSystems.length; a++) {
      const o = r.particleSystems[a], h = o.emitter;
      !o.isStarted() || !h || !h.position || !h.isEnabled() || e.indexOf(h) >= 0 && this._renderingManager.dispatchParticles(o);
    }
  }
  _bindFrameBuffer(e = 0, t = 0) {
    const i = this.getScene();
    if (!i)
      return;
    const s = i.getEngine();
    this._renderTarget && s.bindFramebuffer(this._renderTarget, this.isCube ? e : void 0, void 0, void 0, this.ignoreCameraViewport, 0, t);
  }
  _unbindFrameBuffer(e, t) {
    !this._renderTarget || e.unBindFramebuffer(this._renderTarget, this.isCube, () => {
      this.onAfterRenderObservable.notifyObservers(t);
    });
  }
  _prepareFrame(e, t, i, s) {
    this._postProcessManager ? this._prePassEnabled || this._postProcessManager._prepareFrame(this._texture, this._postProcesses) : (!s || !e.postProcessManager._prepareFrame(this._texture)) && this._bindFrameBuffer(t, i);
  }
  _renderToTarget(e, t, i, s = 0, r = null) {
    var h, l, u, f, d, _;
    const n = this.getScene();
    if (!n)
      return;
    const a = n.getEngine();
    if ((h = a._debugPushGroup) == null || h.call(a, `render to face #${e} layer #${s}`, 1), this._prepareFrame(n, e, s, t), this.is2DArray ? (a.currentRenderPassId = this._renderPassIds[s], this.onBeforeRenderObservable.notifyObservers(s)) : (a.currentRenderPassId = this._renderPassIds[e], this.onBeforeRenderObservable.notifyObservers(e)), a.snapshotRendering && a.snapshotRenderingMode === 1)
      this.onClearObservable.hasObservers() ? this.onClearObservable.notifyObservers(a) : this.skipInitialClear || a.clear(this.clearColor || n.clearColor, !0, !0, !0);
    else {
      let E = null;
      const m = this.renderList ? this.renderList : n.getActiveMeshes().data, T = this.renderList ? this.renderList.length : n.getActiveMeshes().length;
      this.getCustomRenderList && (E = this.getCustomRenderList(this.is2DArray ? s : e, m, T)), E ? this._prepareRenderingManager(E, E.length, r, !1) : (this._defaultRenderListPrepared || (this._prepareRenderingManager(m, T, r, !this.renderList), this._defaultRenderListPrepared = !0), E = m);
      for (const R of n._beforeRenderTargetClearStage)
        R.action(this, e, s);
      this.onClearObservable.hasObservers() ? this.onClearObservable.notifyObservers(a) : this.skipInitialClear || a.clear(this.clearColor || n.clearColor, !0, !0, !0), this._doNotChangeAspectRatio || n.updateTransformMatrix(!0);
      for (const R of n._beforeRenderTargetDrawStage)
        R.action(this, e, s);
      this._renderingManager.render(this.customRenderFunction, E, this.renderParticles, this.renderSprites);
      for (const R of n._afterRenderTargetDrawStage)
        R.action(this, e, s);
      const b = (u = (l = this._texture) == null ? void 0 : l.generateMipMaps) != null ? u : !1;
      this._texture && (this._texture.generateMipMaps = !1), this._postProcessManager ? this._postProcessManager._finalizeFrame(!1, (f = this._renderTarget) != null ? f : void 0, e, this._postProcesses, this.ignoreCameraViewport) : t && n.postProcessManager._finalizeFrame(!1, (d = this._renderTarget) != null ? d : void 0, e), this._texture && (this._texture.generateMipMaps = b), this._doNotChangeAspectRatio || n.updateTransformMatrix(!0), i && U.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), a);
    }
    this._unbindFrameBuffer(a, e), this._texture && this.isCube && e === 5 && a.generateMipMapsForCubemap(this._texture), (_ = a._debugPopGroup) == null || _.call(a, 1);
  }
  setRenderingOrder(e, t = null, i = null, s = null) {
    this._renderingManager.setRenderingOrder(e, t, i, s);
  }
  setRenderingAutoClearDepthStencil(e, t) {
    this._renderingManager.setRenderingAutoClearDepthStencil(e, t), this._renderingManager._useSceneAutoClearSetup = !1;
  }
  clone() {
    const e = this.getSize(), t = new dt(this.name, e, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer, void 0, this._renderTargetOptions.format, void 0, this._renderTargetOptions.samples);
    return t.hasAlpha = this.hasAlpha, t.level = this.level, t.coordinatesMode = this.coordinatesMode, this.renderList && (t.renderList = this.renderList.slice(0)), t;
  }
  serialize() {
    if (!this.name)
      return null;
    const e = super.serialize();
    if (e.renderTargetSize = this.getRenderSize(), e.renderList = [], this.renderList)
      for (let t = 0; t < this.renderList.length; t++)
        e.renderList.push(this.renderList[t].id);
    return e;
  }
  disposeFramebufferObjects() {
    var e;
    (e = this._renderTarget) == null || e.dispose(!0);
  }
  releaseInternalTexture() {
    var e;
    (e = this._renderTarget) == null || e.releaseTextures(), this._texture = null;
  }
  dispose() {
    var i;
    this.onResizeObservable.clear(), this.onClearObservable.clear(), this.onAfterRenderObservable.clear(), this.onAfterUnbindObservable.clear(), this.onBeforeBindObservable.clear(), this.onBeforeRenderObservable.clear(), this._stopObservingRenderListEvents(), this._postProcessManager && (this._postProcessManager.dispose(), this._postProcessManager = null), this._prePassRenderTarget && this._prePassRenderTarget.dispose(), this._releaseRenderPassId(), this.clearPostProcesses(!0), this._resizeObserver && (this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver), this._resizeObserver = null), this.renderList = null;
    const e = this.getScene();
    if (!e)
      return;
    let t = e.customRenderTargets.indexOf(this);
    t >= 0 && e.customRenderTargets.splice(t, 1);
    for (const s of e.cameras)
      t = s.customRenderTargets.indexOf(this), t >= 0 && s.customRenderTargets.splice(t, 1);
    (i = this._renderTarget) == null || i.dispose(), this._renderTarget = null, this._texture = null, super.dispose();
  }
  _rebuild() {
    this.refreshRate === dt.REFRESHRATE_RENDER_ONCE && (this.refreshRate = dt.REFRESHRATE_RENDER_ONCE), this._postProcessManager && this._postProcessManager._rebuild();
  }
  freeRenderingGroups() {
    this._renderingManager && this._renderingManager.freeRenderingGroups();
  }
  getViewCount() {
    return 1;
  }
}
dt.REFRESHRATE_RENDER_ONCE = 0;
dt.REFRESHRATE_RENDER_ONEVERYFRAME = 1;
dt.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;
B._CreateRenderTargetTexture = (c, e, t, i, s) => new dt(c, e, t, i);
const Xn = "postprocessVertexShader", Hn = `attribute vec2 position;
uniform vec2 scale;
varying vec2 vUV;
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=(position*madd+madd)*scale;
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
N.ShadersStore[Xn] = Hn;
class Oe {
  constructor(e, t, i, s, r, n, a = 1, o, h, l = null, u = 0, f = "postprocess", d, _ = !1, E = 5) {
    this._parentContainer = null, this.width = -1, this.height = -1, this.nodeMaterialSource = null, this._outputTexture = null, this.autoClear = !0, this.alphaMode = 0, this.animations = new Array(), this.enablePixelPerfectMode = !1, this.forceFullscreenViewport = !0, this.scaleMode = 1, this.alwaysForcePOT = !1, this._samples = 1, this.adaptScaleToCurrentViewport = !1, this._reusable = !1, this._renderId = 0, this.externalTextureSamplerBinding = !1, this._textures = new Qe(2), this._textureCache = [], this._currentRenderTextureInd = 0, this._scaleRatio = new ee(1, 1), this._texelSize = ee.Zero(), this.onActivateObservable = new F(), this.onSizeChangedObservable = new F(), this.onApplyObservable = new F(), this.onBeforeRenderObservable = new F(), this.onAfterRenderObservable = new F(), this.name = e, n != null ? (this._camera = n, this._scene = n.getScene(), n.attachPostProcess(this), this._engine = this._scene.getEngine(), this._scene.postProcesses.push(this), this.uniqueId = this._scene.getUniqueId()) : o && (this._engine = o, this._engine.postProcesses.push(this)), this._options = r, this.renderTargetSamplingMode = a || 1, this._reusable = h || !1, this._textureType = u, this._textureFormat = E, this._samplers = s || [], this._samplers.push("textureSampler"), this._fragmentUrl = t, this._vertexUrl = f, this._parameters = i || [], this._parameters.push("scale"), this._indexParameters = d, this._drawWrapper = new Oi(this._engine), _ || this.updateEffect(l);
  }
  get samples() {
    return this._samples;
  }
  set samples(e) {
    this._samples = Math.min(e, this._engine.getCaps().maxMSAASamples), this._textures.forEach((t) => {
      t.samples !== this._samples && this._engine.updateRenderTargetTextureSampleCount(t, this._samples);
    });
  }
  getEffectName() {
    return this._fragmentUrl;
  }
  set onActivate(e) {
    this._onActivateObserver && this.onActivateObservable.remove(this._onActivateObserver), e && (this._onActivateObserver = this.onActivateObservable.add(e));
  }
  set onSizeChanged(e) {
    this._onSizeChangedObserver && this.onSizeChangedObservable.remove(this._onSizeChangedObserver), this._onSizeChangedObserver = this.onSizeChangedObservable.add(e);
  }
  set onApply(e) {
    this._onApplyObserver && this.onApplyObservable.remove(this._onApplyObserver), this._onApplyObserver = this.onApplyObservable.add(e);
  }
  set onBeforeRender(e) {
    this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e);
  }
  set onAfterRender(e) {
    this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e);
  }
  get inputTexture() {
    return this._textures.data[this._currentRenderTextureInd];
  }
  set inputTexture(e) {
    this._forcedOutputTexture = e;
  }
  restoreDefaultInputTexture() {
    this._forcedOutputTexture && (this._forcedOutputTexture = null, this.markTextureDirty());
  }
  getCamera() {
    return this._camera;
  }
  get texelSize() {
    return this._shareOutputWithPostProcess ? this._shareOutputWithPostProcess.texelSize : (this._forcedOutputTexture && this._texelSize.copyFromFloats(1 / this._forcedOutputTexture.width, 1 / this._forcedOutputTexture.height), this._texelSize);
  }
  getClassName() {
    return "PostProcess";
  }
  getEngine() {
    return this._engine;
  }
  getEffect() {
    return this._drawWrapper.effect;
  }
  shareOutputWith(e) {
    return this._disposeTextures(), this._shareOutputWithPostProcess = e, this;
  }
  useOwnOutput() {
    this._textures.length == 0 && (this._textures = new Qe(2)), this._shareOutputWithPostProcess = null;
  }
  updateEffect(e = null, t = null, i = null, s, r, n, a, o) {
    this._postProcessDefines = e, this._drawWrapper.effect = this._engine.createEffect({ vertex: a != null ? a : this._vertexUrl, fragment: o != null ? o : this._fragmentUrl }, ["position"], t || this._parameters, i || this._samplers, e !== null ? e : "", void 0, r, n, s || this._indexParameters);
  }
  isReusable() {
    return this._reusable;
  }
  markTextureDirty() {
    this.width = -1;
  }
  _createRenderTargetTexture(e, t, i = 0) {
    for (let r = 0; r < this._textureCache.length; r++)
      if (this._textureCache[r].texture.width === e.width && this._textureCache[r].texture.height === e.height && this._textureCache[r].postProcessChannel === i && this._textureCache[r].texture._generateDepthBuffer === t.generateDepthBuffer)
        return this._textureCache[r].texture;
    const s = this._engine.createRenderTargetTexture(e, t);
    return this._textureCache.push({ texture: s, postProcessChannel: i, lastUsedRenderId: -1 }), s;
  }
  _flushTextureCache() {
    const e = this._renderId;
    for (let t = this._textureCache.length - 1; t >= 0; t--)
      if (e - this._textureCache[t].lastUsedRenderId > 100) {
        let i = !1;
        for (let s = 0; s < this._textures.length; s++)
          if (this._textures.data[s] === this._textureCache[t].texture) {
            i = !0;
            break;
          }
        i || (this._textureCache[t].texture.dispose(), this._textureCache.splice(t, 1));
      }
  }
  _resize(e, t, i, s, r) {
    this._textures.length > 0 && this._textures.reset(), this.width = e, this.height = t;
    let n = null;
    for (let h = 0; h < i._postProcesses.length; h++)
      if (i._postProcesses[h] !== null) {
        n = i._postProcesses[h];
        break;
      }
    const a = { width: this.width, height: this.height }, o = {
      generateMipMaps: s,
      generateDepthBuffer: r || n === this,
      generateStencilBuffer: (r || n === this) && this._engine.isStencilEnable,
      samplingMode: this.renderTargetSamplingMode,
      type: this._textureType,
      format: this._textureFormat
    };
    this._textures.push(this._createRenderTargetTexture(a, o, 0)), this._reusable && this._textures.push(this._createRenderTargetTexture(a, o, 1)), this._texelSize.copyFromFloats(1 / this.width, 1 / this.height), this.onSizeChangedObservable.notifyObservers(this);
  }
  activate(e, t = null, i) {
    var _, E;
    e = e || this._camera;
    const s = e.getScene(), r = s.getEngine(), n = r.getCaps().maxTextureSize;
    let a = (t ? t.width : this._engine.getRenderWidth(!0)) * this._options | 0;
    const o = (t ? t.height : this._engine.getRenderHeight(!0)) * this._options | 0, h = e.parent;
    h && (h.leftCamera == e || h.rightCamera == e) && (a /= 2);
    let l = this._options.width || a, u = this._options.height || o;
    const f = this.renderTargetSamplingMode !== 7 && this.renderTargetSamplingMode !== 1 && this.renderTargetSamplingMode !== 2;
    if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {
      if (this.adaptScaleToCurrentViewport) {
        const m = r.currentViewport;
        m && (l *= m.width, u *= m.height);
      }
      (f || this.alwaysForcePOT) && (this._options.width || (l = r.needPOTTextures ? C.GetExponentOfTwo(l, n, this.scaleMode) : l), this._options.height || (u = r.needPOTTextures ? C.GetExponentOfTwo(u, n, this.scaleMode) : u)), (this.width !== l || this.height !== u) && this._resize(l, u, e, f, i), this._textures.forEach((m) => {
        m.samples !== this.samples && this._engine.updateRenderTargetTextureSampleCount(m, this.samples);
      }), this._flushTextureCache(), this._renderId++;
    }
    let d;
    if (this._shareOutputWithPostProcess)
      d = this._shareOutputWithPostProcess.inputTexture;
    else if (this._forcedOutputTexture)
      d = this._forcedOutputTexture, this.width = this._forcedOutputTexture.width, this.height = this._forcedOutputTexture.height;
    else {
      d = this.inputTexture;
      let m;
      for (let T = 0; T < this._textureCache.length; T++)
        if (this._textureCache[T].texture === d) {
          m = this._textureCache[T];
          break;
        }
      m && (m.lastUsedRenderId = this._renderId);
    }
    return this.enablePixelPerfectMode ? (this._scaleRatio.copyFromFloats(a / l, o / u), this._engine.bindFramebuffer(d, 0, a, o, this.forceFullscreenViewport)) : (this._scaleRatio.copyFromFloats(1, 1), this._engine.bindFramebuffer(d, 0, void 0, void 0, this.forceFullscreenViewport)), (E = (_ = this._engine)._debugInsertMarker) == null || E.call(_, `post process ${this.name} input`), this.onActivateObservable.notifyObservers(e), this.autoClear && this.alphaMode === 0 && this._engine.clear(this.clearColor ? this.clearColor : s.clearColor, s._allowPostProcessClearColor, !0, !0), this._reusable && (this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2), d;
  }
  get isSupported() {
    return this._drawWrapper.effect.isSupported;
  }
  get aspectRatio() {
    return this._shareOutputWithPostProcess ? this._shareOutputWithPostProcess.aspectRatio : this._forcedOutputTexture ? this._forcedOutputTexture.width / this._forcedOutputTexture.height : this.width / this.height;
  }
  isReady() {
    var e, t;
    return (t = (e = this._drawWrapper.effect) == null ? void 0 : e.isReady()) != null ? t : !1;
  }
  apply() {
    var t;
    if (!((t = this._drawWrapper.effect) != null && t.isReady()))
      return null;
    this._engine.enableEffect(this._drawWrapper), this._engine.setState(!1), this._engine.setDepthBuffer(!1), this._engine.setDepthWrite(!1), this._engine.setAlphaMode(this.alphaMode), this.alphaConstants && this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);
    let e;
    return this._shareOutputWithPostProcess ? e = this._shareOutputWithPostProcess.inputTexture : this._forcedOutputTexture ? e = this._forcedOutputTexture : e = this.inputTexture, this.externalTextureSamplerBinding || this._drawWrapper.effect._bindTexture("textureSampler", e == null ? void 0 : e.texture), this._drawWrapper.effect.setVector2("scale", this._scaleRatio), this.onApplyObservable.notifyObservers(this._drawWrapper.effect), this._drawWrapper.effect;
  }
  _disposeTextures() {
    if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {
      this._disposeTextureCache();
      return;
    }
    this._disposeTextureCache(), this._textures.dispose();
  }
  _disposeTextureCache() {
    for (let e = this._textureCache.length - 1; e >= 0; e--)
      this._textureCache[e].texture.dispose();
    this._textureCache.length = 0;
  }
  setPrePassRenderer(e) {
    return this._prePassEffectConfiguration ? (this._prePassEffectConfiguration = e.addEffectConfiguration(this._prePassEffectConfiguration), this._prePassEffectConfiguration.enabled = !0, !0) : !1;
  }
  dispose(e) {
    e = e || this._camera, this._disposeTextures();
    let t;
    if (this._scene && (t = this._scene.postProcesses.indexOf(this), t !== -1 && this._scene.postProcesses.splice(t, 1)), this._parentContainer) {
      const i = this._parentContainer.postProcesses.indexOf(this);
      i > -1 && this._parentContainer.postProcesses.splice(i, 1), this._parentContainer = null;
    }
    if (t = this._engine.postProcesses.indexOf(this), t !== -1 && this._engine.postProcesses.splice(t, 1), !!e) {
      if (e.detachPostProcess(this), t = e._postProcesses.indexOf(this), t === 0 && e._postProcesses.length > 0) {
        const i = this._camera._getFirstPostProcess();
        i && i.markTextureDirty();
      }
      this.onActivateObservable.clear(), this.onAfterRenderObservable.clear(), this.onApplyObservable.clear(), this.onBeforeRenderObservable.clear(), this.onSizeChangedObservable.clear();
    }
  }
  serialize() {
    const e = ne.Serialize(this), t = this.getCamera() || this._scene && this._scene.activeCamera;
    return e.customType = "BABYLON." + this.getClassName(), e.cameraId = t ? t.id : null, e.reusable = this._reusable, e.textureType = this._textureType, e.fragmentUrl = this._fragmentUrl, e.parameters = this._parameters, e.samplers = this._samplers, e.options = this._options, e.defines = this._postProcessDefines, e.textureFormat = this._textureFormat, e.vertexUrl = this._vertexUrl, e.indexParameters = this._indexParameters, e;
  }
  clone() {
    const e = this.serialize();
    e._engine = this._engine, e.cameraId = null;
    const t = Oe.Parse(e, this._scene, "");
    return t ? (t.onActivateObservable = this.onActivateObservable.clone(), t.onSizeChangedObservable = this.onSizeChangedObservable.clone(), t.onApplyObservable = this.onApplyObservable.clone(), t.onBeforeRenderObservable = this.onBeforeRenderObservable.clone(), t.onAfterRenderObservable = this.onAfterRenderObservable.clone(), t._prePassEffectConfiguration = this._prePassEffectConfiguration, t) : null;
  }
  static Parse(e, t, i) {
    const s = oi(e.customType);
    if (!s || !s._Parse)
      return null;
    const r = t ? t.getCameraById(e.cameraId) : null;
    return s._Parse(e, r, t, i);
  }
  static _Parse(e, t, i, s) {
    return ne.Parse(() => new Oe(e.name, e.fragmentUrl, e.parameters, e.samplers, e.options, t, e.renderTargetSamplingMode, e._engine, e.reusable, e.defines, e.textureType, e.vertexUrl, e.indexParameters, !1, e.textureFormat), e, i, s);
  }
}
S([
  M()
], Oe.prototype, "uniqueId", void 0);
S([
  M()
], Oe.prototype, "name", void 0);
S([
  M()
], Oe.prototype, "width", void 0);
S([
  M()
], Oe.prototype, "height", void 0);
S([
  M()
], Oe.prototype, "renderTargetSamplingMode", void 0);
S([
  Mr()
], Oe.prototype, "clearColor", void 0);
S([
  M()
], Oe.prototype, "autoClear", void 0);
S([
  M()
], Oe.prototype, "alphaMode", void 0);
S([
  M()
], Oe.prototype, "alphaConstants", void 0);
S([
  M()
], Oe.prototype, "enablePixelPerfectMode", void 0);
S([
  M()
], Oe.prototype, "forceFullscreenViewport", void 0);
S([
  M()
], Oe.prototype, "scaleMode", void 0);
S([
  M()
], Oe.prototype, "alwaysForcePOT", void 0);
S([
  M("samples")
], Oe.prototype, "_samples", void 0);
S([
  M()
], Oe.prototype, "adaptScaleToCurrentViewport", void 0);
it("BABYLON.PostProcess", Oe);
const Kn = "kernelBlurVaryingDeclaration", Yn = "varying vec2 sampleCoord{X};";
N.IncludesShadersStore[Kn] = Yn;
const Zn = "packingFunctions", qn = `vec4 pack(float depth)
{
const vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);
const vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);
vec4 res=fract(depth*bit_shift);
res-=res.xxyz*bit_mask;
return res;
}
float unpack(vec4 color)
{
const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);
return dot(color,bit_shift);
}`;
N.IncludesShadersStore[Zn] = qn;
const jn = "kernelBlurFragment", Qn = `#ifdef DOF
factor=sampleCoC(sampleCoord{X}); 
computedWeight=KERNEL_WEIGHT{X}*factor;
sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;
#endif
`;
N.IncludesShadersStore[jn] = Qn;
const $n = "kernelBlurFragment2", Jn = `#ifdef DOF
factor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});
computedWeight=KERNEL_DEP_WEIGHT{X}*factor;
sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_DEP_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;
#endif
`;
N.IncludesShadersStore[$n] = Jn;
const ea = "kernelBlurPixelShader", ta = `uniform sampler2D textureSampler;
uniform vec2 delta;
varying vec2 sampleCenter;
#ifdef DOF
uniform sampler2D circleOfConfusionSampler;
uniform vec2 cameraMinMaxZ;
float sampleDistance(in vec2 offset) {
float depth=texture2D(circleOfConfusionSampler,offset).g; 
return cameraMinMaxZ.x+(cameraMinMaxZ.y-cameraMinMaxZ.x)*depth; 
}
float sampleCoC(in vec2 offset) {
float coc=texture2D(circleOfConfusionSampler,offset).r; 
return coc; 
}
#endif
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#ifdef PACKEDFLOAT
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
float computedWeight=0.0;
#ifdef PACKEDFLOAT 
float blend=0.;
#else
vec4 blend=vec4(0.);
#endif
#ifdef DOF
float sumOfWeights=CENTER_WEIGHT; 
float factor=0.0;
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;
#else
blend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;
#endif
#endif
#include<kernelBlurFragment>[0..varyingCount]
#include<kernelBlurFragment2>[0..depCount]
#ifdef PACKEDFLOAT
gl_FragColor=pack(blend);
#else
gl_FragColor=blend;
#endif
#ifdef DOF
gl_FragColor/=sumOfWeights;
#endif
}`;
N.ShadersStore[ea] = ta;
const ia = "kernelBlurVertex", sa = "sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};";
N.IncludesShadersStore[ia] = sa;
const ra = "kernelBlurVertexShader", na = `attribute vec2 position;
uniform vec2 delta;
varying vec2 sampleCenter;
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
sampleCenter=(position*madd+madd);
#include<kernelBlurVertex>[0..varyingCount]
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
N.ShadersStore[ra] = na;
class Qt extends Oe {
  constructor(e, t, i, s, r, n = B.BILINEAR_SAMPLINGMODE, a, o, h = 0, l = "", u = !1) {
    super(e, "kernelBlur", ["delta", "direction", "cameraMinMaxZ"], ["circleOfConfusionSampler"], s, r, n, a, o, null, h, "kernelBlur", { varyingCount: 0, depCount: 0 }, !0), this._blockCompilation = u, this._packedFloat = !1, this._staticDefines = "", this._staticDefines = l, this.direction = t, this.onApplyObservable.add((f) => {
      this._outputTexture ? f.setFloat2("delta", 1 / this._outputTexture.width * this.direction.x, 1 / this._outputTexture.height * this.direction.y) : f.setFloat2("delta", 1 / this.width * this.direction.x, 1 / this.height * this.direction.y);
    }), this.kernel = i;
  }
  set kernel(e) {
    this._idealKernel !== e && (e = Math.max(e, 1), this._idealKernel = e, this._kernel = this._nearestBestKernel(e), this._blockCompilation || this._updateParameters());
  }
  get kernel() {
    return this._idealKernel;
  }
  set packedFloat(e) {
    this._packedFloat !== e && (this._packedFloat = e, this._blockCompilation || this._updateParameters());
  }
  get packedFloat() {
    return this._packedFloat;
  }
  getClassName() {
    return "BlurPostProcess";
  }
  updateEffect(e = null, t = null, i = null, s, r, n) {
    this._updateParameters(r, n);
  }
  _updateParameters(e, t) {
    const i = this._kernel, s = (i - 1) / 2;
    let r = [], n = [], a = 0;
    for (let m = 0; m < i; m++) {
      const T = m / (i - 1), b = this._gaussianWeight(T * 2 - 1);
      r[m] = m - s, n[m] = b, a += b;
    }
    for (let m = 0; m < n.length; m++)
      n[m] /= a;
    const o = [], h = [], l = [];
    for (let m = 0; m <= s; m += 2) {
      const T = Math.min(m + 1, Math.floor(s));
      if (m === T)
        l.push({ o: r[m], w: n[m] });
      else {
        const R = T === s, y = n[m] + n[T] * (R ? 0.5 : 1), P = r[m] + 1 / (1 + n[m] / n[T]);
        P === 0 ? (l.push({ o: r[m], w: n[m] }), l.push({ o: r[m + 1], w: n[m + 1] })) : (l.push({ o: P, w: y }), l.push({ o: -P, w: y }));
      }
    }
    for (let m = 0; m < l.length; m++)
      h[m] = l[m].o, o[m] = l[m].w;
    r = h, n = o;
    const u = this.getEngine().getCaps().maxVaryingVectors, f = Math.max(u, 0) - 1;
    let d = Math.min(r.length, f), _ = "";
    _ += this._staticDefines, this._staticDefines.indexOf("DOF") != -1 && (_ += `#define CENTER_WEIGHT ${this._glslFloat(n[d - 1])}\r
`, d--);
    for (let m = 0; m < d; m++)
      _ += `#define KERNEL_OFFSET${m} ${this._glslFloat(r[m])}\r
`, _ += `#define KERNEL_WEIGHT${m} ${this._glslFloat(n[m])}\r
`;
    let E = 0;
    for (let m = f; m < r.length; m++)
      _ += `#define KERNEL_DEP_OFFSET${E} ${this._glslFloat(r[m])}\r
`, _ += `#define KERNEL_DEP_WEIGHT${E} ${this._glslFloat(n[m])}\r
`, E++;
    this.packedFloat && (_ += "#define PACKEDFLOAT 1"), this._blockCompilation = !1, super.updateEffect(_, null, null, {
      varyingCount: d,
      depCount: E
    }, e, t);
  }
  _nearestBestKernel(e) {
    const t = Math.round(e);
    for (const i of [t, t - 1, t + 1, t - 2, t + 2])
      if (i % 2 !== 0 && Math.floor(i / 2) % 2 === 0 && i > 0)
        return Math.max(i, 3);
    return Math.max(t, 3);
  }
  _gaussianWeight(e) {
    const t = 0.3333333333333333, i = Math.sqrt(2 * Math.PI) * t, s = -(e * e / (2 * t * t));
    return 1 / i * Math.exp(s);
  }
  _glslFloat(e, t = 8) {
    return e.toFixed(t).replace(/0+$/, "");
  }
  static _Parse(e, t, i, s) {
    return ne.Parse(() => new Qt(e.name, e.direction, e.kernel, e.options, t, e.renderTargetSamplingMode, i.getEngine(), e.reusable, e.textureType, void 0, !1), e, i, s);
  }
}
S([
  M("kernel")
], Qt.prototype, "_kernel", void 0);
S([
  M("packedFloat")
], Qt.prototype, "_packedFloat", void 0);
S([
  dn()
], Qt.prototype, "direction", void 0);
it("BABYLON.BlurPostProcess", Qt);
class Gs {
  constructor() {
    this._defines = {}, this._currentRank = 32, this._maxRank = -1, this._mesh = null;
  }
  unBindMesh() {
    this._mesh = null;
  }
  addFallback(e, t) {
    this._defines[e] || (e < this._currentRank && (this._currentRank = e), e > this._maxRank && (this._maxRank = e), this._defines[e] = new Array()), this._defines[e].push(t);
  }
  addCPUSkinningFallback(e, t) {
    this._mesh = t, e < this._currentRank && (this._currentRank = e), e > this._maxRank && (this._maxRank = e);
  }
  get hasMoreFallbacks() {
    return this._currentRank <= this._maxRank;
  }
  reduce(e, t) {
    if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {
      this._mesh.computeBonesUsingShaders = !1, e = e.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0"), t._bonesComputationForcedToCPU = !0;
      const i = this._mesh.getScene();
      for (let s = 0; s < i.meshes.length; s++) {
        const r = i.meshes[s];
        if (!r.material) {
          !this._mesh.material && r.computeBonesUsingShaders && r.numBoneInfluencers > 0 && (r.computeBonesUsingShaders = !1);
          continue;
        }
        if (!(!r.computeBonesUsingShaders || r.numBoneInfluencers === 0)) {
          if (r.material.getEffect() === t)
            r.computeBonesUsingShaders = !1;
          else if (r.subMeshes) {
            for (const n of r.subMeshes)
              if (n.effect === t) {
                r.computeBonesUsingShaders = !1;
                break;
              }
          }
        }
      }
    } else {
      const i = this._defines[this._currentRank];
      if (i)
        for (let s = 0; s < i.length; s++)
          e = e.replace("#define " + i[s], "");
      this._currentRank++;
    }
    return e;
  }
}
const aa = "bayerDitherFunctions", oa = `float bayerDither2(vec2 _P) {
return mod(2.0*_P.y+_P.x+1.0,4.0);
}
float bayerDither4(vec2 _P) {
vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5*mod(_P,4.0)); 
return 4.0*bayerDither2(P1)+bayerDither2(P2);
}
float bayerDither8(vec2 _P) {
vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5 *mod(_P,4.0)); 
vec2 P4=floor(0.25*mod(_P,8.0)); 
return 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);
}
`;
N.IncludesShadersStore[aa] = oa;
const ha = "shadowMapFragmentExtraDeclaration", la = `#if SM_FLOAT==0
#include<packingFunctions>
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#include<bayerDitherFunctions>
uniform float softTransparentShadowSM;
#endif
varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
uniform vec3 lightDataSM;
varying vec3 vPositionWSM;
#endif
uniform vec3 biasAndScaleSM;
uniform vec2 depthValuesSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;
N.IncludesShadersStore[ha] = la;
const ca = "clipPlaneFragmentDeclaration", ua = `#ifdef CLIPPLANE
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
varying float fClipDistance6;
#endif
`;
N.IncludesShadersStore[ca] = ua;
const fa = "clipPlaneFragment", da = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fClipDistance>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE2
else if (fClipDistance2>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE3
else if (fClipDistance3>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE4
else if (fClipDistance4>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE5
else if (fClipDistance5>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE6
else if (fClipDistance6>0.0)
{
discard;
}
#endif
`;
N.IncludesShadersStore[fa] = da;
const _a = "shadowMapFragment", ga = `float depthSM=vDepthMetricSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
#if SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
depthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
depthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_FragDepth=clamp(1.0-depthSM,0.0,1.0);
#else
gl_FragDepth=clamp(depthSM,0.0,1.0); 
#endif
#elif SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#if SM_ESM==1
depthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);
#endif
#if SM_FLOAT==1
gl_FragColor=vec4(depthSM,1.0,1.0,1.0);
#else
gl_FragColor=pack(depthSM);
#endif
return;`;
N.IncludesShadersStore[_a] = ga;
const pa = "shadowMapPixelShader", ma = `#include<shadowMapFragmentExtraDeclaration>
#ifdef ALPHATEST
varying vec2 vUV;
uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEST
float alphaFromAlphaTexture=texture2D(diffuseSampler,vUV).a;
if (alphaFromAlphaTexture<ALPHATESTVALUE)
discard;
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#ifdef ALPHATEST
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alphaFromAlphaTexture) discard;
#else
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM) discard;
#endif
#endif
#include<shadowMapFragment>
}`;
N.ShadersStore[pa] = ma;
const Ea = "bonesDeclaration", Ta = `#if NUM_BONE_INFLUENCERS>0
attribute vec4 matricesIndices;
attribute vec4 matricesWeights;
#if NUM_BONE_INFLUENCERS>4
attribute vec4 matricesIndicesExtra;
attribute vec4 matricesWeightsExtra;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
uniform sampler2D boneSampler;
uniform float boneTextureWidth;
#else
uniform mat4 mBones[BonesPerMesh];
#ifdef BONES_VELOCITY_ENABLED
uniform mat4 mPreviousBones[BonesPerMesh];
#endif
#endif
#ifdef BONETEXTURE
#define inline
mat4 readMatrixFromRawSampler(sampler2D smp,float index)
{
float offset=index *4.0;
float dx=1.0/boneTextureWidth;
vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));
vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));
vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));
vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));
return mat4(m0,m1,m2,m3);
}
#endif
#endif
#endif
`;
N.IncludesShadersStore[Ea] = Ta;
const Sa = "bakedVertexAnimationDeclaration", ba = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform float bakedVertexAnimationTime;
uniform vec2 bakedVertexAnimationTextureSizeInverted;
uniform vec4 bakedVertexAnimationSettings;
uniform sampler2D bakedVertexAnimationTexture;
#ifdef INSTANCES
attribute vec4 bakedVertexAnimationSettingsInstanced;
#endif
#define inline
mat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)
{
float offset=index*4.0;
float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;
float dx=bakedVertexAnimationTextureSizeInverted.x;
vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));
vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));
vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));
vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));
return mat4(m0,m1,m2,m3);
}
#endif
`;
N.IncludesShadersStore[Sa] = ba;
const xa = "morphTargetsVertexGlobalDeclaration", va = `#ifdef MORPHTARGETS
uniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];
#ifdef MORPHTARGETS_TEXTURE 
precision mediump sampler2DArray; 
uniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];
uniform vec3 morphTargetTextureInfo;
uniform sampler2DArray morphTargets;
vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)
{ 
float y=floor(vertexIndex/morphTargetTextureInfo.y);
float x=vertexIndex-y*morphTargetTextureInfo.y;
vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);
return texture(morphTargets,textureUV).xyz;
}
#endif
#endif
`;
N.IncludesShadersStore[xa] = va;
const Ma = "morphTargetsVertexDeclaration", Aa = `#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
attribute vec3 position{X};
#ifdef MORPHTARGETS_NORMAL
attribute vec3 normal{X};
#endif
#ifdef MORPHTARGETS_TANGENT
attribute vec3 tangent{X};
#endif
#ifdef MORPHTARGETS_UV
attribute vec2 uv_{X};
#endif
#endif
#endif
`;
N.IncludesShadersStore[Ma] = Aa;
const Ra = "helperFunctions", ya = `const float PI=3.1415926535897932384626433832795;
const float HALF_MIN=5.96046448e-08; 
const float LinearEncodePowerApprox=2.2;
const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;
const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);
const float Epsilon=0.0000001;
#define saturate(x) clamp(x,0.0,1.0)
#define absEps(x) abs(x)+Epsilon
#define maxEps(x) max(x,Epsilon)
#define saturateEps(x) clamp(x,Epsilon,1.0)
mat3 transposeMat3(mat3 inMatrix) {
vec3 i0=inMatrix[0];
vec3 i1=inMatrix[1];
vec3 i2=inMatrix[2];
mat3 outMatrix=mat3(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);
return outMatrix;
}
mat3 inverseMat3(mat3 inMatrix) {
float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];
float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];
float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];
float b01=a22*a11-a12*a21;
float b11=-a22*a10+a12*a20;
float b21=a21*a10-a11*a20;
float det=a00*b01+a01*b11+a02*b21;
return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),
b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),
b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;
}
#if USE_EXACT_SRGB_CONVERSIONS
vec3 toLinearSpaceExact(vec3 color)
{
vec3 nearZeroSection=0.0773993808*color;
vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));
#if defined(WEBGL2) || defined(WEBGPU)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));
#else
return
vec3(
color.r<=0.04045 ? nearZeroSection.r : remainingSection.r,
color.g<=0.04045 ? nearZeroSection.g : remainingSection.g,
color.b<=0.04045 ? nearZeroSection.b : remainingSection.b);
#endif
}
vec3 toGammaSpaceExact(vec3 color)
{
vec3 nearZeroSection=12.92*color;
vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);
#if defined(WEBGL2) || defined(WEBGPU)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));
#else
return
vec3(
color.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,
color.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,
color.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);
#endif
}
#endif
float toLinearSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=0.0773993808*color;
float remainingSection=pow(0.947867299*(color+0.055),2.4);
return color<=0.04045 ? nearZeroSection : remainingSection;
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
vec3 toLinearSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3(LinearEncodePowerApprox));
#endif
}
vec4 toLinearSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);
#endif
}
float toGammaSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=12.92*color;
float remainingSection=1.055*pow(color,0.41666)-0.055;
return color<=0.0031308 ? nearZeroSection : remainingSection;
#else
return pow(color,GammaEncodePowerApprox);
#endif
}
vec3 toGammaSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3(GammaEncodePowerApprox));
#endif
}
vec4 toGammaSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);
#endif
}
float square(float value)
{
return value*value;
}
vec3 square(vec3 value)
{
return value*value;
}
float pow5(float value) {
float sq=value*value;
return sq*sq*value;
}
float getLuminance(vec3 color)
{
return clamp(dot(color,LuminanceEncodeApprox),0.,1.);
}
float getRand(vec2 seed) {
return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);
}
float dither(vec2 seed,float varianceAmount) {
float rand=getRand(seed);
float normVariance=varianceAmount/255.0;
float dither=mix(-normVariance,normVariance,rand);
return dither;
}
const float rgbdMaxRange=255.0;
vec4 toRGBD(vec3 color) {
float maxRGB=maxEps(max(color.r,max(color.g,color.b)));
float D =max(rgbdMaxRange/maxRGB,1.);
D =clamp(floor(D)/255.0,0.,1.);
vec3 rgb=color.rgb*D;
rgb=toGammaSpace(rgb);
return vec4(clamp(rgb,0.,1.),D); 
}
vec3 fromRGBD(vec4 rgbd) {
rgbd.rgb=toLinearSpace(rgbd.rgb);
return rgbd.rgb/rgbd.a;
}
vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {
vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;
vec3 halfSize=cubeSize*0.5;
vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;
vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;
vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);
float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);
vec3 intersectPositionWS=vertexPos+origVec*distance;
return intersectPositionWS-cubePos;
}
`;
N.IncludesShadersStore[Ra] = ya;
const Ca = "sceneVertexDeclaration", Ia = `uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
uniform mat4 view;
uniform mat4 projection;
uniform vec4 vEyePosition;
`;
N.IncludesShadersStore[Ca] = Ia;
const Pa = "meshVertexDeclaration", Da = `uniform mat4 world;
uniform float visibility;
`;
N.IncludesShadersStore[Pa] = Da;
const Fa = "shadowMapVertexDeclaration", wa = `#include<sceneVertexDeclaration>
#include<meshVertexDeclaration>
`;
N.IncludesShadersStore[Fa] = wa;
const Oa = "sceneUboDeclaration", La = `layout(std140,column_major) uniform;
uniform Scene {
mat4 viewProjection;
#ifdef MULTIVIEW
mat4 viewProjectionR;
#endif 
mat4 view;
mat4 projection;
vec4 vEyePosition;
};
`;
N.IncludesShadersStore[Oa] = La;
const Na = "meshUboDeclaration", Ba = `#ifdef WEBGL2
uniform mat4 world;
uniform float visibility;
#else
layout(std140,column_major) uniform;
uniform Mesh
{
mat4 world;
float visibility;
};
#endif
#define WORLD_UBO
`;
N.IncludesShadersStore[Na] = Ba;
const Ua = "shadowMapUboDeclaration", ka = `layout(std140,column_major) uniform;
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
N.IncludesShadersStore[Ua] = ka;
const Va = "shadowMapVertexExtraDeclaration", Wa = `#if SM_NORMALBIAS==1
uniform vec3 lightDataSM;
#endif
uniform vec3 biasAndScaleSM;
uniform vec2 depthValuesSM;
varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
varying vec3 vPositionWSM;
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;
N.IncludesShadersStore[Va] = Wa;
const za = "clipPlaneVertexDeclaration", Ga = `#ifdef CLIPPLANE
uniform vec4 vClipPlane;
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;
varying float fClipDistance6;
#endif
`;
N.IncludesShadersStore[za] = Ga;
const Xa = "morphTargetsVertexGlobal", Ha = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
float vertexID;
#endif
#endif
`;
N.IncludesShadersStore[Xa] = Ha;
const Ka = "morphTargetsVertex", Ya = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE 
vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;
positionUpdated+=(readVector3FromRawSampler({X},vertexID)-position)*morphTargetInfluences[{X}];
vertexID+=1.0;
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(readVector3FromRawSampler({X},vertexID) -normal)*morphTargetInfluences[{X}];
vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(readVector3FromRawSampler({X},vertexID).xy-uv)*morphTargetInfluences[{X}];
vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*morphTargetInfluences[{X}];
#endif
#else
positionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];
#endif
#endif
#endif
`;
N.IncludesShadersStore[Ka] = Ya;
const Za = "instancesVertex", qa = `#ifdef INSTANCES
mat4 finalWorld=mat4(world0,world1,world2,world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);
#endif
#ifdef THIN_INSTANCES
finalWorld=world*finalWorld;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
finalPreviousWorld=previousWorld*finalPreviousWorld;
#endif
#endif
#else
mat4 finalWorld=world;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=previousWorld;
#endif
#endif
`;
N.IncludesShadersStore[Za] = qa;
const ja = "bonesVertex", Qa = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
mat4 influence;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];
#endif
#else
influence=mBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=mBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=mBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=mBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;
N.IncludesShadersStore[ja] = Qa;
const $a = "bakedVertexAnimation", Ja = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
#define BVASNAME bakedVertexAnimationSettingsInstanced
#else
#define BVASNAME bakedVertexAnimationSettings
#endif
float VATStartFrame=BVASNAME.x;
float VATEndFrame=BVASNAME.y;
float VATOffsetFrame=BVASNAME.z;
float VATSpeed=BVASNAME.w;
float totalFrames=VATEndFrame-VATStartFrame+1.0;
float time=bakedVertexAnimationTime*VATSpeed/totalFrames;
float frameCorrection=time<1.0 ? 0.0 : 1.0;
float numOfFrames=totalFrames-frameCorrection;
float VATFrameNum=fract(time)*numOfFrames;
VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);
VATFrameNum=floor(VATFrameNum);
VATFrameNum+=VATStartFrame+frameCorrection;
mat4 VATInfluence;
VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;
}
#endif
`;
N.IncludesShadersStore[$a] = Ja;
const eo = "shadowMapVertexNormalBias", to = `#if SM_NORMALBIAS==1
#if SM_DIRECTIONINLIGHTDATA==1
vec3 worldLightDirSM=normalize(-lightDataSM.xyz);
#else
vec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;
vec3 worldLightDirSM=normalize(directionToLightSM);
#endif
float ndlSM=dot(vNormalW,worldLightDirSM);
float sinNLSM=sqrt(1.0-ndlSM*ndlSM);
float normalBiasSM=biasAndScaleSM.y*sinNLSM;
worldPos.xyz-=vNormalW*normalBiasSM;
#endif
`;
N.IncludesShadersStore[eo] = to;
const io = "shadowMapVertexMetric", so = `#if SM_USEDISTANCE==1
vPositionWSM=worldPos.xyz;
#endif
#if SM_DEPTHTEXTURE==1
#ifdef IS_NDC_HALF_ZRANGE
#define BIASFACTOR 0.5
#else
#define BIASFACTOR 1.0
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#else
gl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#endif
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
zSM=gl_Position.z;
gl_Position.z=0.0;
#elif SM_USEDISTANCE==0
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
vDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
`;
N.IncludesShadersStore[io] = so;
const ro = "clipPlaneVertex", no = `#ifdef CLIPPLANE
fClipDistance=dot(worldPos,vClipPlane);
#endif
#ifdef CLIPPLANE2
fClipDistance2=dot(worldPos,vClipPlane2);
#endif
#ifdef CLIPPLANE3
fClipDistance3=dot(worldPos,vClipPlane3);
#endif
#ifdef CLIPPLANE4
fClipDistance4=dot(worldPos,vClipPlane4);
#endif
#ifdef CLIPPLANE5
fClipDistance5=dot(worldPos,vClipPlane5);
#endif
#ifdef CLIPPLANE6
fClipDistance6=dot(worldPos,vClipPlane6);
#endif
`;
N.IncludesShadersStore[ro] = no;
const ao = "shadowMapVertexShader", oo = `attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef INSTANCES
attribute vec4 world0;
attribute vec4 world1;
attribute vec4 world2;
attribute vec4 world3;
#endif
#include<helperFunctions>
#include<__decl__shadowMapVertex>
#ifdef ALPHATEST
varying vec2 vUV;
uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#include<shadowMapVertexExtraDeclaration>
#include<clipPlaneVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{
vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normWorldSM=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));
vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
vec3 vNormalW=normalize(normWorldSM*normalUpdated);
#endif
#endif
#include<shadowMapVertexNormalBias>
gl_Position=viewProjection*worldPos;
#include<shadowMapVertexMetric>
#ifdef ALPHATEST
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
#include<clipPlaneVertex>
}`;
N.ShadersStore[ao] = oo;
const ho = "depthBoxBlurPixelShader", lo = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform vec2 screenSize;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
vec4 colorDepth=vec4(0.0);
for (int x=-OFFSET; x<=OFFSET; x++)
for (int y=-OFFSET; y<=OFFSET; y++)
colorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);
gl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));
}`;
N.ShadersStore[ho] = lo;
const co = "shadowMapFragmentSoftTransparentShadow", uo = `#if SM_SOFTTRANSPARENTSHADOW==1
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alpha) discard;
#endif
`;
N.IncludesShadersStore[co] = uo;
class W {
  constructor(e, t, i) {
    this.onBeforeShadowMapRenderObservable = new F(), this.onAfterShadowMapRenderObservable = new F(), this.onBeforeShadowMapRenderMeshObservable = new F(), this.onAfterShadowMapRenderMeshObservable = new F(), this._bias = 5e-5, this._normalBias = 0, this._blurBoxOffset = 1, this._blurScale = 2, this._blurKernel = 1, this._useKernelBlur = !1, this._filter = W.FILTER_NONE, this._filteringQuality = W.QUALITY_HIGH, this._contactHardeningLightSizeUVRatio = 0.1, this._darkness = 0, this._transparencyShadow = !1, this.enableSoftTransparentShadow = !1, this.useOpacityTextureForTransparentShadow = !1, this.frustumEdgeFalloff = 0, this.forceBackFacesOnly = !1, this._lightDirection = g.Zero(), this._viewMatrix = x.Zero(), this._projectionMatrix = x.Zero(), this._transformMatrix = x.Zero(), this._cachedPosition = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cachedDirection = new g(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._currentFaceIndex = 0, this._currentFaceIndexCache = 0, this._defaultTextureMatrix = x.Identity(), this._mapSize = e, this._light = t, this._scene = t.getScene(), t._shadowGenerator = this, this.id = t.id, this._useUBO = this._scene.getEngine().supportsUniformBuffers, this._useUBO && (this._sceneUBOs = [], this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`))), W._SceneComponentInitialization(this._scene);
    const s = this._scene.getEngine().getCaps();
    i ? s.textureFloatRender && s.textureFloatLinearFiltering ? this._textureType = 1 : s.textureHalfFloatRender && s.textureHalfFloatLinearFiltering ? this._textureType = 2 : this._textureType = 0 : s.textureHalfFloatRender && s.textureHalfFloatLinearFiltering ? this._textureType = 2 : s.textureFloatRender && s.textureFloatLinearFiltering ? this._textureType = 1 : this._textureType = 0, this._initializeGenerator(), this._applyFilterValues();
  }
  get bias() {
    return this._bias;
  }
  set bias(e) {
    this._bias = e;
  }
  get normalBias() {
    return this._normalBias;
  }
  set normalBias(e) {
    this._normalBias = e;
  }
  get blurBoxOffset() {
    return this._blurBoxOffset;
  }
  set blurBoxOffset(e) {
    this._blurBoxOffset !== e && (this._blurBoxOffset = e, this._disposeBlurPostProcesses());
  }
  get blurScale() {
    return this._blurScale;
  }
  set blurScale(e) {
    this._blurScale !== e && (this._blurScale = e, this._disposeBlurPostProcesses());
  }
  get blurKernel() {
    return this._blurKernel;
  }
  set blurKernel(e) {
    this._blurKernel !== e && (this._blurKernel = e, this._disposeBlurPostProcesses());
  }
  get useKernelBlur() {
    return this._useKernelBlur;
  }
  set useKernelBlur(e) {
    this._useKernelBlur !== e && (this._useKernelBlur = e, this._disposeBlurPostProcesses());
  }
  get depthScale() {
    return this._depthScale !== void 0 ? this._depthScale : this._light.getDepthScale();
  }
  set depthScale(e) {
    this._depthScale = e;
  }
  _validateFilter(e) {
    return e;
  }
  get filter() {
    return this._filter;
  }
  set filter(e) {
    if (e = this._validateFilter(e), this._light.needCube()) {
      if (e === W.FILTER_BLUREXPONENTIALSHADOWMAP) {
        this.useExponentialShadowMap = !0;
        return;
      } else if (e === W.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
        this.useCloseExponentialShadowMap = !0;
        return;
      } else if (e === W.FILTER_PCF || e === W.FILTER_PCSS) {
        this.usePoissonSampling = !0;
        return;
      }
    }
    if ((e === W.FILTER_PCF || e === W.FILTER_PCSS) && !this._scene.getEngine()._features.supportShadowSamplers) {
      this.usePoissonSampling = !0;
      return;
    }
    this._filter !== e && (this._filter = e, this._disposeBlurPostProcesses(), this._applyFilterValues(), this._light._markMeshesAsLightDirty());
  }
  get usePoissonSampling() {
    return this.filter === W.FILTER_POISSONSAMPLING;
  }
  set usePoissonSampling(e) {
    const t = this._validateFilter(W.FILTER_POISSONSAMPLING);
    !e && this.filter !== W.FILTER_POISSONSAMPLING || (this.filter = e ? t : W.FILTER_NONE);
  }
  get useExponentialShadowMap() {
    return this.filter === W.FILTER_EXPONENTIALSHADOWMAP;
  }
  set useExponentialShadowMap(e) {
    const t = this._validateFilter(W.FILTER_EXPONENTIALSHADOWMAP);
    !e && this.filter !== W.FILTER_EXPONENTIALSHADOWMAP || (this.filter = e ? t : W.FILTER_NONE);
  }
  get useBlurExponentialShadowMap() {
    return this.filter === W.FILTER_BLUREXPONENTIALSHADOWMAP;
  }
  set useBlurExponentialShadowMap(e) {
    const t = this._validateFilter(W.FILTER_BLUREXPONENTIALSHADOWMAP);
    !e && this.filter !== W.FILTER_BLUREXPONENTIALSHADOWMAP || (this.filter = e ? t : W.FILTER_NONE);
  }
  get useCloseExponentialShadowMap() {
    return this.filter === W.FILTER_CLOSEEXPONENTIALSHADOWMAP;
  }
  set useCloseExponentialShadowMap(e) {
    const t = this._validateFilter(W.FILTER_CLOSEEXPONENTIALSHADOWMAP);
    !e && this.filter !== W.FILTER_CLOSEEXPONENTIALSHADOWMAP || (this.filter = e ? t : W.FILTER_NONE);
  }
  get useBlurCloseExponentialShadowMap() {
    return this.filter === W.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
  }
  set useBlurCloseExponentialShadowMap(e) {
    const t = this._validateFilter(W.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);
    !e && this.filter !== W.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP || (this.filter = e ? t : W.FILTER_NONE);
  }
  get usePercentageCloserFiltering() {
    return this.filter === W.FILTER_PCF;
  }
  set usePercentageCloserFiltering(e) {
    const t = this._validateFilter(W.FILTER_PCF);
    !e && this.filter !== W.FILTER_PCF || (this.filter = e ? t : W.FILTER_NONE);
  }
  get filteringQuality() {
    return this._filteringQuality;
  }
  set filteringQuality(e) {
    this._filteringQuality !== e && (this._filteringQuality = e, this._disposeBlurPostProcesses(), this._applyFilterValues(), this._light._markMeshesAsLightDirty());
  }
  get useContactHardeningShadow() {
    return this.filter === W.FILTER_PCSS;
  }
  set useContactHardeningShadow(e) {
    const t = this._validateFilter(W.FILTER_PCSS);
    !e && this.filter !== W.FILTER_PCSS || (this.filter = e ? t : W.FILTER_NONE);
  }
  get contactHardeningLightSizeUVRatio() {
    return this._contactHardeningLightSizeUVRatio;
  }
  set contactHardeningLightSizeUVRatio(e) {
    this._contactHardeningLightSizeUVRatio = e;
  }
  get darkness() {
    return this._darkness;
  }
  set darkness(e) {
    this.setDarkness(e);
  }
  getDarkness() {
    return this._darkness;
  }
  setDarkness(e) {
    return e >= 1 ? this._darkness = 1 : e <= 0 ? this._darkness = 0 : this._darkness = e, this;
  }
  get transparencyShadow() {
    return this._transparencyShadow;
  }
  set transparencyShadow(e) {
    this.setTransparencyShadow(e);
  }
  setTransparencyShadow(e) {
    return this._transparencyShadow = e, this;
  }
  getShadowMap() {
    return this._shadowMap;
  }
  getShadowMapForRendering() {
    return this._shadowMap2 ? this._shadowMap2 : this._shadowMap;
  }
  getClassName() {
    return W.CLASSNAME;
  }
  addShadowCaster(e, t = !0) {
    if (!this._shadowMap)
      return this;
    if (this._shadowMap.renderList || (this._shadowMap.renderList = []), this._shadowMap.renderList.indexOf(e) === -1 && this._shadowMap.renderList.push(e), t)
      for (const i of e.getChildMeshes())
        this._shadowMap.renderList.indexOf(i) === -1 && this._shadowMap.renderList.push(i);
    return this;
  }
  removeShadowCaster(e, t = !0) {
    if (!this._shadowMap || !this._shadowMap.renderList)
      return this;
    const i = this._shadowMap.renderList.indexOf(e);
    if (i !== -1 && this._shadowMap.renderList.splice(i, 1), t)
      for (const s of e.getChildren())
        this.removeShadowCaster(s);
    return this;
  }
  getLight() {
    return this._light;
  }
  get mapSize() {
    return this._mapSize;
  }
  set mapSize(e) {
    this._mapSize = e, this._light._markMeshesAsLightDirty(), this.recreateShadowMap();
  }
  _initializeGenerator() {
    this._light._markMeshesAsLightDirty(), this._initializeShadowMap();
  }
  _createTargetRenderTexture() {
    const e = this._scene.getEngine();
    e._features.supportDepthStencilTexture ? (this._shadowMap = new dt(this._light.name + "_shadowMap", this._mapSize, this._scene, !1, !0, this._textureType, this._light.needCube(), void 0, !1, !1), this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer ? 516 : 513, !0)) : this._shadowMap = new dt(this._light.name + "_shadowMap", this._mapSize, this._scene, !1, !0, this._textureType, this._light.needCube());
  }
  _initializeShadowMap() {
    if (this._createTargetRenderTexture(), this._shadowMap === null)
      return;
    this._shadowMap.wrapU = B.CLAMP_ADDRESSMODE, this._shadowMap.wrapV = B.CLAMP_ADDRESSMODE, this._shadowMap.anisotropicFilteringLevel = 1, this._shadowMap.updateSamplingMode(B.BILINEAR_SAMPLINGMODE), this._shadowMap.renderParticles = !1, this._shadowMap.ignoreCameraViewport = !0, this._storedUniqueId && (this._shadowMap.uniqueId = this._storedUniqueId), this._shadowMap.customRenderFunction = this._renderForShadowMap.bind(this), this._shadowMap.customIsReadyFunction = () => !0;
    const e = this._scene.getEngine();
    this._shadowMap.onBeforeBindObservable.add(() => {
      var s;
      this._currentSceneUBO = this._scene.getSceneUniformBuffer(), (s = e._debugPushGroup) == null || s.call(e, `shadow map generation for pass id ${e.currentRenderPassId}`, 1);
    }), this._shadowMap.onBeforeRenderObservable.add((s) => {
      this._sceneUBOs && this._scene.setSceneUniformBuffer(this._sceneUBOs[0]), this._currentFaceIndex = s, this._filter === W.FILTER_PCF && e.setColorWrite(!1), this.getTransformMatrix(), this._scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix), this._useUBO && (this._scene.getSceneUniformBuffer().unbindEffect(), this._scene.finalizeSceneUbo());
    }), this._shadowMap.onAfterUnbindObservable.add(() => {
      var r, n;
      if (this._sceneUBOs && this._scene.setSceneUniformBuffer(this._currentSceneUBO), this._scene.updateTransformMatrix(), this._filter === W.FILTER_PCF && e.setColorWrite(!0), !this.useBlurExponentialShadowMap && !this.useBlurCloseExponentialShadowMap) {
        (r = e._debugPopGroup) == null || r.call(e, 1);
        return;
      }
      const s = this.getShadowMapForRendering();
      s && (this._scene.postProcessManager.directRender(this._blurPostProcesses, s.renderTarget, !0), e.unBindFramebuffer(s.renderTarget, !0), (n = e._debugPopGroup) == null || n.call(e, 1));
    });
    const t = new ge(0, 0, 0, 0), i = new ge(1, 1, 1, 1);
    this._shadowMap.onClearObservable.add((s) => {
      this._filter === W.FILTER_PCF ? s.clear(i, !1, !0, !1) : this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? s.clear(t, !0, !0, !1) : s.clear(i, !0, !0, !1);
    }), this._shadowMap.onResizeObservable.add((s) => {
      this._storedUniqueId = this._shadowMap.uniqueId, this._mapSize = s.getRenderSize(), this._light._markMeshesAsLightDirty(), this.recreateShadowMap();
    });
    for (let s = Ye.MIN_RENDERINGGROUPS; s < Ye.MAX_RENDERINGGROUPS; s++)
      this._shadowMap.setRenderingAutoClearDepthStencil(s, !1);
  }
  _initializeBlurRTTAndPostProcesses() {
    const e = this._scene.getEngine(), t = this._mapSize / this.blurScale;
    (!this.useKernelBlur || this.blurScale !== 1) && (this._shadowMap2 = new dt(this._light.name + "_shadowMap2", t, this._scene, !1, !0, this._textureType, void 0, void 0, !1), this._shadowMap2.wrapU = B.CLAMP_ADDRESSMODE, this._shadowMap2.wrapV = B.CLAMP_ADDRESSMODE, this._shadowMap2.updateSamplingMode(B.BILINEAR_SAMPLINGMODE)), this.useKernelBlur ? (this._kernelBlurXPostprocess = new Qt(this._light.name + "KernelBlurX", new ee(1, 0), this.blurKernel, 1, null, B.BILINEAR_SAMPLINGMODE, e, !1, this._textureType), this._kernelBlurXPostprocess.width = t, this._kernelBlurXPostprocess.height = t, this._kernelBlurXPostprocess.externalTextureSamplerBinding = !0, this._kernelBlurXPostprocess.onApplyObservable.add((i) => {
      i.setTexture("textureSampler", this._shadowMap);
    }), this._kernelBlurYPostprocess = new Qt(this._light.name + "KernelBlurY", new ee(0, 1), this.blurKernel, 1, null, B.BILINEAR_SAMPLINGMODE, e, !1, this._textureType), this._kernelBlurXPostprocess.autoClear = !1, this._kernelBlurYPostprocess.autoClear = !1, this._textureType === 0 && (this._kernelBlurXPostprocess.packedFloat = !0, this._kernelBlurYPostprocess.packedFloat = !0), this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess]) : (this._boxBlurPostprocess = new Oe(this._light.name + "DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1, null, B.BILINEAR_SAMPLINGMODE, e, !1, "#define OFFSET " + this._blurBoxOffset, this._textureType), this._boxBlurPostprocess.externalTextureSamplerBinding = !0, this._boxBlurPostprocess.onApplyObservable.add((i) => {
      i.setFloat2("screenSize", t, t), i.setTexture("textureSampler", this._shadowMap);
    }), this._boxBlurPostprocess.autoClear = !1, this._blurPostProcesses = [this._boxBlurPostprocess]);
  }
  _renderForShadowMap(e, t, i, s) {
    let r;
    if (s.length)
      for (r = 0; r < s.length; r++)
        this._renderSubMeshForShadowMap(s.data[r]);
    for (r = 0; r < e.length; r++)
      this._renderSubMeshForShadowMap(e.data[r]);
    for (r = 0; r < t.length; r++)
      this._renderSubMeshForShadowMap(t.data[r]);
    if (this._transparencyShadow)
      for (r = 0; r < i.length; r++)
        this._renderSubMeshForShadowMap(i.data[r], !0);
    else
      for (r = 0; r < i.length; r++)
        i.data[r].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = !1;
  }
  _bindCustomEffectForRenderSubMeshForShadowMap(e, t, i) {
    t.setMatrix("viewProjection", this.getTransformMatrix());
  }
  _renderSubMeshForShadowMap(e, t = !1) {
    var d, _;
    const i = e.getRenderingMesh(), s = e.getEffectiveMesh(), r = this._scene, n = r.getEngine(), a = e.getMaterial();
    if (s._internalAbstractMeshDataInfo._isActiveIntermediate = !1, !a || e.verticesCount === 0 || e._renderId === r.getRenderId())
      return;
    const o = s._getWorldMatrixDeterminant() < 0;
    let h = (d = i.overrideMaterialSideOrientation) != null ? d : a.sideOrientation;
    o && (h = h === 0 ? 1 : 0);
    const l = h === 0;
    n.setState(a.backFaceCulling, void 0, void 0, l, a.cullBackFaces);
    const u = i._getInstancesRenderList(e._id, !!e.getReplacementMesh());
    if (u.mustReturn)
      return;
    const f = n.getCaps().instancedArrays && (u.visibleInstances[e._id] !== null && u.visibleInstances[e._id] !== void 0 || i.hasThinInstances);
    if (!(this.customAllowRendering && !this.customAllowRendering(e)))
      if (this.isReady(e, f, t)) {
        e._renderId = r.getRenderId();
        const E = a.shadowDepthWrapper, m = (_ = E == null ? void 0 : E.getEffect(e, this, n.currentRenderPassId)) != null ? _ : e._getDrawWrapper(), T = Oi.GetEffect(m);
        if (n.enableEffect(m), f || i._bind(e, T, a.fillMode), this.getTransformMatrix(), T.setFloat3("biasAndScaleSM", this.bias, this.normalBias, this.depthScale), this.getLight().getTypeID() === he.LIGHTTYPEID_DIRECTIONALLIGHT ? T.setVector3("lightDataSM", this._cachedDirection) : T.setVector3("lightDataSM", this._cachedPosition), r.activeCamera && T.setFloat2("depthValuesSM", this.getLight().getDepthMinZ(r.activeCamera), this.getLight().getDepthMinZ(r.activeCamera) + this.getLight().getDepthMaxZ(r.activeCamera)), t && this.enableSoftTransparentShadow && T.setFloat("softTransparentShadowSM", s.visibility * a.alpha), E)
          e._setMainDrawWrapperOverride(m), E.standalone ? E.baseMaterial.bindForSubMesh(s.getWorldMatrix(), i, e) : a.bindForSubMesh(s.getWorldMatrix(), i, e), e._setMainDrawWrapperOverride(null);
        else {
          if (a && this.useOpacityTextureForTransparentShadow) {
            const R = a.opacityTexture;
            R && (T.setTexture("diffuseSampler", R), T.setMatrix("diffuseMatrix", R.getTextureMatrix() || this._defaultTextureMatrix));
          } else if (a && a.needAlphaTesting()) {
            const R = a.getAlphaTestTexture();
            R && (T.setTexture("diffuseSampler", R), T.setMatrix("diffuseMatrix", R.getTextureMatrix() || this._defaultTextureMatrix));
          }
          if (i.useBones && i.computeBonesUsingShaders && i.skeleton) {
            const R = i.skeleton;
            if (R.isUsingTextureForMatrices) {
              const y = R.getTransformMatrixTexture(i);
              if (!y)
                return;
              T.setTexture("boneSampler", y), T.setFloat("boneTextureWidth", 4 * (R.bones.length + 1));
            } else
              T.setMatrices("mBones", R.getTransformMatrices(i));
          }
          J.BindMorphTargetParameters(i, T), i.morphTargetManager && i.morphTargetManager.isUsingTextureForTargets && i.morphTargetManager._bind(T), J.BindClipPlane(T, r);
        }
        !this._useUBO && !E && this._bindCustomEffectForRenderSubMeshForShadowMap(e, T, s), J.BindSceneUniformBuffer(T, this._scene.getSceneUniformBuffer()), this._scene.getSceneUniformBuffer().bindUniformBuffer();
        const b = s.getWorldMatrix();
        f && (s.getMeshUniformBuffer().bindToEffect(T, "Mesh"), s.transferToEffect(b)), this.forceBackFacesOnly && n.setState(!0, 0, !1, !0, a.cullBackFaces), this.onBeforeShadowMapRenderMeshObservable.notifyObservers(i), this.onBeforeShadowMapRenderObservable.notifyObservers(T), i._processRendering(s, e, T, a.fillMode, u, f, (R, y) => {
          s !== i && !R ? (i.getMeshUniformBuffer().bindToEffect(T, "Mesh"), i.transferToEffect(y)) : (s.getMeshUniformBuffer().bindToEffect(T, "Mesh"), s.transferToEffect(R ? y : b));
        }), this.forceBackFacesOnly && n.setState(!0, 0, !1, !1, a.cullBackFaces), this.onAfterShadowMapRenderObservable.notifyObservers(T), this.onAfterShadowMapRenderMeshObservable.notifyObservers(i);
      } else
        this._shadowMap && this._shadowMap.resetRefreshCounter();
  }
  _applyFilterValues() {
    !this._shadowMap || (this.filter === W.FILTER_NONE || this.filter === W.FILTER_PCSS ? this._shadowMap.updateSamplingMode(B.NEAREST_SAMPLINGMODE) : this._shadowMap.updateSamplingMode(B.BILINEAR_SAMPLINGMODE));
  }
  forceCompilation(e, t) {
    const i = {
      useInstances: !1,
      ...t
    }, s = this.getShadowMap();
    if (!s) {
      e && e(this);
      return;
    }
    const r = s.renderList;
    if (!r) {
      e && e(this);
      return;
    }
    const n = new Array();
    for (const h of r)
      n.push(...h.subMeshes);
    if (n.length === 0) {
      e && e(this);
      return;
    }
    let a = 0;
    const o = () => {
      var h, l;
      if (!(!this._scene || !this._scene.getEngine())) {
        for (; this.isReady(n[a], i.useInstances, (l = (h = n[a].getMaterial()) == null ? void 0 : h.needAlphaBlendingForMesh(n[a].getMesh())) != null ? l : !1); )
          if (a++, a >= n.length) {
            e && e(this);
            return;
          }
        setTimeout(o, 16);
      }
    };
    o();
  }
  forceCompilationAsync(e) {
    return new Promise((t) => {
      this.forceCompilation(() => {
        t();
      }, e);
    });
  }
  _isReadyCustomDefines(e, t, i) {
  }
  _prepareShadowDefines(e, t, i, s) {
    i.push("#define SM_FLOAT " + (this._textureType !== 0 ? "1" : "0")), i.push("#define SM_ESM " + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? "1" : "0")), i.push("#define SM_DEPTHTEXTURE " + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? "1" : "0"));
    const r = e.getMesh();
    return i.push("#define SM_NORMALBIAS " + (this.normalBias && r.isVerticesDataPresent(p.NormalKind) ? "1" : "0")), i.push("#define SM_DIRECTIONINLIGHTDATA " + (this.getLight().getTypeID() === he.LIGHTTYPEID_DIRECTIONALLIGHT ? "1" : "0")), i.push("#define SM_USEDISTANCE " + (this._light.needCube() ? "1" : "0")), i.push("#define SM_SOFTTRANSPARENTSHADOW " + (this.enableSoftTransparentShadow && s ? "1" : "0")), this._isReadyCustomDefines(i, e, t), i;
  }
  isReady(e, t, i) {
    var a;
    const s = e.getMaterial(), r = s == null ? void 0 : s.shadowDepthWrapper, n = [];
    if (this._prepareShadowDefines(e, t, n, i), r) {
      if (!r.isReadyForSubMesh(e, n, this, t, this._scene.getEngine().currentRenderPassId))
        return !1;
    } else {
      const o = e._getDrawWrapper(void 0, !0);
      let h = o.effect, l = o.defines;
      const u = [p.PositionKind], f = e.getMesh();
      if (this.normalBias && f.isVerticesDataPresent(p.NormalKind) && (u.push(p.NormalKind), n.push("#define NORMAL"), f.nonUniformScaling && n.push("#define NONUNIFORMSCALING")), s && s.needAlphaTesting()) {
        let b = null;
        if (this.useOpacityTextureForTransparentShadow ? b = s.opacityTexture : b = s.getAlphaTestTexture(), b) {
          if (!b.isReady())
            return !1;
          const R = (a = s.alphaCutOff) != null ? a : W.DEFAULT_ALPHA_CUTOFF;
          n.push("#define ALPHATEST"), n.push(`#define ALPHATESTVALUE ${R}${R % 1 === 0 ? "." : ""}`), f.isVerticesDataPresent(p.UVKind) && (u.push(p.UVKind), n.push("#define UV1")), f.isVerticesDataPresent(p.UV2Kind) && b.coordinatesIndex === 1 && (u.push(p.UV2Kind), n.push("#define UV2"));
        }
      }
      const d = new Gs();
      if (f.useBones && f.computeBonesUsingShaders && f.skeleton) {
        u.push(p.MatricesIndicesKind), u.push(p.MatricesWeightsKind), f.numBoneInfluencers > 4 && (u.push(p.MatricesIndicesExtraKind), u.push(p.MatricesWeightsExtraKind));
        const b = f.skeleton;
        n.push("#define NUM_BONE_INFLUENCERS " + f.numBoneInfluencers), f.numBoneInfluencers > 0 && d.addCPUSkinningFallback(0, f), b.isUsingTextureForMatrices ? n.push("#define BONETEXTURE") : n.push("#define BonesPerMesh " + (b.bones.length + 1));
      } else
        n.push("#define NUM_BONE_INFLUENCERS 0");
      const _ = f.morphTargetManager;
      let E = 0;
      _ && _.numInfluencers > 0 && (n.push("#define MORPHTARGETS"), E = _.numInfluencers, n.push("#define NUM_MORPH_INFLUENCERS " + E), _.isUsingTextureForTargets && n.push("#define MORPHTARGETS_TEXTURE"), J.PrepareAttributesForMorphTargetsInfluencers(u, f, E));
      const m = this._scene;
      if (m.clipPlane && n.push("#define CLIPPLANE"), m.clipPlane2 && n.push("#define CLIPPLANE2"), m.clipPlane3 && n.push("#define CLIPPLANE3"), m.clipPlane4 && n.push("#define CLIPPLANE4"), m.clipPlane5 && n.push("#define CLIPPLANE5"), m.clipPlane6 && n.push("#define CLIPPLANE6"), t && (n.push("#define INSTANCES"), J.PushAttributesForInstances(u), e.getRenderingMesh().hasThinInstances && n.push("#define THIN_INSTANCES")), this.customShaderOptions && this.customShaderOptions.defines)
        for (const b of this.customShaderOptions.defines)
          n.indexOf(b) === -1 && n.push(b);
      const T = n.join(`
`);
      if (l !== T) {
        l = T;
        let b = "shadowMap";
        const R = [
          "world",
          "mBones",
          "viewProjection",
          "diffuseMatrix",
          "lightDataSM",
          "depthValuesSM",
          "biasAndScaleSM",
          "morphTargetInfluences",
          "boneTextureWidth",
          "vClipPlane",
          "vClipPlane2",
          "vClipPlane3",
          "vClipPlane4",
          "vClipPlane5",
          "vClipPlane6",
          "softTransparentShadowSM",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices"
        ], y = ["diffuseSampler", "boneSampler", "morphTargets"], P = ["Scene", "Mesh"];
        if (this.customShaderOptions) {
          if (b = this.customShaderOptions.shaderName, this.customShaderOptions.attributes)
            for (const A of this.customShaderOptions.attributes)
              u.indexOf(A) === -1 && u.push(A);
          if (this.customShaderOptions.uniforms)
            for (const A of this.customShaderOptions.uniforms)
              R.indexOf(A) === -1 && R.push(A);
          if (this.customShaderOptions.samplers)
            for (const A of this.customShaderOptions.samplers)
              y.indexOf(A) === -1 && y.push(A);
        }
        const v = this._scene.getEngine();
        h = v.createEffect(b, {
          attributes: u,
          uniformsNames: R,
          uniformBuffersNames: P,
          samplers: y,
          defines: T,
          fallbacks: d,
          onCompiled: null,
          onError: null,
          indexParameters: { maxSimultaneousMorphTargets: E }
        }, v), o.setEffect(h, l);
      }
      if (!h.isReady())
        return !1;
    }
    return (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) && (!this._blurPostProcesses || !this._blurPostProcesses.length) && this._initializeBlurRTTAndPostProcesses(), !(this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady() || this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady() || this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady());
  }
  prepareDefines(e, t) {
    const i = this._scene, s = this._light;
    !i.shadowsEnabled || !s.shadowEnabled || (e["SHADOW" + t] = !0, this.useContactHardeningShadow ? (e["SHADOWPCSS" + t] = !0, this._filteringQuality === W.QUALITY_LOW ? e["SHADOWLOWQUALITY" + t] = !0 : this._filteringQuality === W.QUALITY_MEDIUM && (e["SHADOWMEDIUMQUALITY" + t] = !0)) : this.usePercentageCloserFiltering ? (e["SHADOWPCF" + t] = !0, this._filteringQuality === W.QUALITY_LOW ? e["SHADOWLOWQUALITY" + t] = !0 : this._filteringQuality === W.QUALITY_MEDIUM && (e["SHADOWMEDIUMQUALITY" + t] = !0)) : this.usePoissonSampling ? e["SHADOWPOISSON" + t] = !0 : this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? e["SHADOWESM" + t] = !0 : (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) && (e["SHADOWCLOSEESM" + t] = !0), s.needCube() && (e["SHADOWCUBE" + t] = !0));
  }
  bindShadowLight(e, t) {
    const i = this._light, s = this._scene;
    if (!s.shadowsEnabled || !i.shadowEnabled)
      return;
    const r = s.activeCamera;
    if (!r)
      return;
    const n = this.getShadowMap();
    !n || (i.needCube() || t.setMatrix("lightMatrix" + e, this.getTransformMatrix()), this._filter === W.FILTER_PCF ? (t.setDepthStencilTexture("shadowSampler" + e, this.getShadowMapForRendering()), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), n.getSize().width, 1 / n.getSize().width, this.frustumEdgeFalloff, e)) : this._filter === W.FILTER_PCSS ? (t.setDepthStencilTexture("shadowSampler" + e, this.getShadowMapForRendering()), t.setTexture("depthSampler" + e, this.getShadowMapForRendering()), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / n.getSize().width, this._contactHardeningLightSizeUVRatio * n.getSize().width, this.frustumEdgeFalloff, e)) : (t.setTexture("shadowSampler" + e, this.getShadowMapForRendering()), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), this.blurScale / n.getSize().width, this.depthScale, this.frustumEdgeFalloff, e)), i._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(r), this.getLight().getDepthMinZ(r) + this.getLight().getDepthMaxZ(r), e));
  }
  getTransformMatrix() {
    const e = this._scene;
    if (this._currentRenderId === e.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex)
      return this._transformMatrix;
    this._currentRenderId = e.getRenderId(), this._currentFaceIndexCache = this._currentFaceIndex;
    let t = this._light.position;
    if (this._light.computeTransformedInformation() && (t = this._light.transformedPosition), g.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection), Math.abs(g.Dot(this._lightDirection, g.Up())) === 1 && (this._lightDirection.z = 1e-13), this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !t.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {
      this._cachedPosition.copyFrom(t), this._cachedDirection.copyFrom(this._lightDirection), x.LookAtLHToRef(t, t.add(this._lightDirection), g.Up(), this._viewMatrix);
      const i = this.getShadowMap();
      if (i) {
        const s = i.renderList;
        s && this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, s);
      }
      this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    }
    return this._transformMatrix;
  }
  recreateShadowMap() {
    const e = this._shadowMap;
    if (!e)
      return;
    const t = e.renderList;
    if (this._disposeRTTandPostProcesses(), this._initializeGenerator(), this.filter = this._filter, this._applyFilterValues(), t) {
      this._shadowMap.renderList || (this._shadowMap.renderList = []);
      for (const i of t)
        this._shadowMap.renderList.push(i);
    } else
      this._shadowMap.renderList = null;
  }
  _disposeBlurPostProcesses() {
    this._shadowMap2 && (this._shadowMap2.dispose(), this._shadowMap2 = null), this._boxBlurPostprocess && (this._boxBlurPostprocess.dispose(), this._boxBlurPostprocess = null), this._kernelBlurXPostprocess && (this._kernelBlurXPostprocess.dispose(), this._kernelBlurXPostprocess = null), this._kernelBlurYPostprocess && (this._kernelBlurYPostprocess.dispose(), this._kernelBlurYPostprocess = null), this._blurPostProcesses = [];
  }
  _disposeRTTandPostProcesses() {
    this._shadowMap && (this._shadowMap.dispose(), this._shadowMap = null), this._disposeBlurPostProcesses();
  }
  _disposeSceneUBOs() {
    if (this._sceneUBOs) {
      for (const e of this._sceneUBOs)
        e.dispose();
      this._sceneUBOs = [];
    }
  }
  dispose() {
    this._disposeRTTandPostProcesses(), this._disposeSceneUBOs(), this._light && (this._light._shadowGenerator = null, this._light._markMeshesAsLightDirty()), this.onBeforeShadowMapRenderMeshObservable.clear(), this.onBeforeShadowMapRenderObservable.clear(), this.onAfterShadowMapRenderMeshObservable.clear(), this.onAfterShadowMapRenderObservable.clear();
  }
  serialize() {
    const e = {}, t = this.getShadowMap();
    if (!t)
      return e;
    if (e.className = this.getClassName(), e.lightId = this._light.id, e.id = this.id, e.mapSize = t.getRenderSize(), e.forceBackFacesOnly = this.forceBackFacesOnly, e.darkness = this.getDarkness(), e.transparencyShadow = this._transparencyShadow, e.frustumEdgeFalloff = this.frustumEdgeFalloff, e.bias = this.bias, e.normalBias = this.normalBias, e.usePercentageCloserFiltering = this.usePercentageCloserFiltering, e.useContactHardeningShadow = this.useContactHardeningShadow, e.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio, e.filteringQuality = this.filteringQuality, e.useExponentialShadowMap = this.useExponentialShadowMap, e.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap, e.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap, e.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap, e.usePoissonSampling = this.usePoissonSampling, e.depthScale = this.depthScale, e.blurBoxOffset = this.blurBoxOffset, e.blurKernel = this.blurKernel, e.blurScale = this.blurScale, e.useKernelBlur = this.useKernelBlur, e.renderList = [], t.renderList)
      for (let i = 0; i < t.renderList.length; i++) {
        const s = t.renderList[i];
        e.renderList.push(s.id);
      }
    return e;
  }
  static Parse(e, t, i) {
    const s = t.getLightById(e.lightId), r = i ? i(e.mapSize, s) : new W(e.mapSize, s), n = r.getShadowMap();
    for (let a = 0; a < e.renderList.length; a++)
      t.getMeshesById(e.renderList[a]).forEach(function(h) {
        !n || (n.renderList || (n.renderList = []), n.renderList.push(h));
      });
    return e.id !== void 0 && (r.id = e.id), r.forceBackFacesOnly = !!e.forceBackFacesOnly, e.darkness !== void 0 && r.setDarkness(e.darkness), e.transparencyShadow && r.setTransparencyShadow(!0), e.frustumEdgeFalloff !== void 0 && (r.frustumEdgeFalloff = e.frustumEdgeFalloff), e.bias !== void 0 && (r.bias = e.bias), e.normalBias !== void 0 && (r.normalBias = e.normalBias), e.usePercentageCloserFiltering ? r.usePercentageCloserFiltering = !0 : e.useContactHardeningShadow ? r.useContactHardeningShadow = !0 : e.usePoissonSampling ? r.usePoissonSampling = !0 : e.useExponentialShadowMap ? r.useExponentialShadowMap = !0 : e.useBlurExponentialShadowMap ? r.useBlurExponentialShadowMap = !0 : e.useCloseExponentialShadowMap ? r.useCloseExponentialShadowMap = !0 : e.useBlurCloseExponentialShadowMap ? r.useBlurCloseExponentialShadowMap = !0 : e.useVarianceShadowMap ? r.useExponentialShadowMap = !0 : e.useBlurVarianceShadowMap && (r.useBlurExponentialShadowMap = !0), e.contactHardeningLightSizeUVRatio !== void 0 && (r.contactHardeningLightSizeUVRatio = e.contactHardeningLightSizeUVRatio), e.filteringQuality !== void 0 && (r.filteringQuality = e.filteringQuality), e.depthScale && (r.depthScale = e.depthScale), e.blurScale && (r.blurScale = e.blurScale), e.blurBoxOffset && (r.blurBoxOffset = e.blurBoxOffset), e.useKernelBlur && (r.useKernelBlur = e.useKernelBlur), e.blurKernel && (r.blurKernel = e.blurKernel), r;
  }
}
W.CLASSNAME = "ShadowGenerator";
W.FILTER_NONE = 0;
W.FILTER_EXPONENTIALSHADOWMAP = 1;
W.FILTER_POISSONSAMPLING = 2;
W.FILTER_BLUREXPONENTIALSHADOWMAP = 3;
W.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;
W.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;
W.FILTER_PCF = 6;
W.FILTER_PCSS = 7;
W.QUALITY_HIGH = 0;
W.QUALITY_MEDIUM = 1;
W.QUALITY_LOW = 2;
W.DEFAULT_ALPHA_CUTOFF = 0.5;
W._SceneComponentInitialization = (c) => {
  throw q("ShadowGeneratorSceneComponent");
};
const fo = "depthPixelShader", _o = `#ifdef ALPHATEST
varying vec2 vUV;
uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
varying float vDepthMetric;
#ifdef PACKED
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (texture2D(diffuseSampler,vUV).a<0.4)
discard;
#endif
#ifdef NONLINEARDEPTH
#ifdef PACKED
gl_FragColor=pack(gl_FragCoord.z);
#else
gl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);
#endif
#else
#ifdef PACKED
gl_FragColor=pack(vDepthMetric);
#else
gl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);
#endif
#endif
}`;
N.ShadersStore[fo] = _o;
const go = "instancesDeclaration", po = `#ifdef INSTANCES
attribute vec4 world0;
attribute vec4 world1;
attribute vec4 world2;
attribute vec4 world3;
#ifdef INSTANCESCOLOR
attribute vec4 instanceColor;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
attribute vec4 previousWorld0;
attribute vec4 previousWorld1;
attribute vec4 previousWorld2;
attribute vec4 previousWorld3;
#ifdef THIN_INSTANCES
uniform mat4 previousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
uniform mat4 previousWorld;
#endif
#endif
`;
N.IncludesShadersStore[go] = po;
const mo = "depthVertexShader", Eo = `attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
uniform vec2 depthValues;
#if defined(ALPHATEST) || defined(NEED_UV)
varying vec2 vUV;
uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
varying float vDepthMetric;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{
vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#include<clipPlaneVertex>
gl_Position=viewProjection*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));
#else
vDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));
#endif
#if defined(ALPHATEST) || defined(BASIC_RENDER)
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
}
`;
N.ShadersStore[mo] = Eo;
class hs {
  constructor(e, t = 1, i = null, s = !1, r = B.TRILINEAR_SAMPLINGMODE) {
    this.enabled = !0, this.forceDepthWriteTransparentMeshes = !1, this.useOnlyInActiveCamera = !1, this._scene = e, this._storeNonLinearDepth = s, this.isPacked = t === 0, this.isPacked ? this._clearColor = new ge(1, 1, 1, 1) : this._clearColor = new ge(1, 0, 0, 1), hs._SceneComponentInitialization(this._scene);
    const n = e.getEngine();
    this._camera = i, r !== B.NEAREST_SAMPLINGMODE && (t === 1 && !n._caps.textureFloatLinearFiltering && (r = B.NEAREST_SAMPLINGMODE), t === 2 && !n._caps.textureHalfFloatLinearFiltering && (r = B.NEAREST_SAMPLINGMODE));
    const a = this.isPacked || !n._features.supportExtendedTextureFormats ? 5 : 6;
    this._depthMap = new dt("DepthRenderer", { width: n.getRenderWidth(), height: n.getRenderHeight() }, this._scene, !1, !0, t, !1, r, void 0, void 0, void 0, a), this._depthMap.wrapU = B.CLAMP_ADDRESSMODE, this._depthMap.wrapV = B.CLAMP_ADDRESSMODE, this._depthMap.refreshRate = 1, this._depthMap.renderParticles = !1, this._depthMap.renderList = null, this._depthMap.activeCamera = this._camera, this._depthMap.ignoreCameraViewport = !0, this._depthMap.useCameraPostProcesses = !1, this._depthMap.onClearObservable.add((h) => {
      h.clear(this._clearColor, !0, !0, !0);
    }), this._depthMap.onBeforeBindObservable.add(() => {
      var h;
      (h = n._debugPushGroup) == null || h.call(n, "depth renderer", 1);
    }), this._depthMap.onAfterUnbindObservable.add(() => {
      var h;
      (h = n._debugPopGroup) == null || h.call(n, 1);
    }), this._depthMap.customIsReadyFunction = (h, l) => {
      if (!h.isReady(!1))
        return !1;
      if (l === 0 && h.subMeshes)
        for (let u = 0; u < h.subMeshes.length; ++u) {
          const f = h.subMeshes[u], d = f.getRenderingMesh(), _ = d._getInstancesRenderList(f._id, !!f.getReplacementMesh()), E = n.getCaps().instancedArrays && (_.visibleInstances[f._id] !== null && _.visibleInstances[f._id] !== void 0 || d.hasThinInstances);
          if (!this.isReady(f, E))
            return !1;
        }
      return !0;
    };
    const o = (h) => {
      var P, v;
      const l = h.getRenderingMesh(), u = h.getEffectiveMesh(), f = this._scene, d = f.getEngine(), _ = h.getMaterial();
      if (u._internalAbstractMeshDataInfo._isActiveIntermediate = !1, !_ || u.infiniteDistance || _.disableDepthWrite || h.verticesCount === 0 || h._renderId === f.getRenderId())
        return;
      const E = u._getWorldMatrixDeterminant() < 0;
      let m = (P = l.overrideMaterialSideOrientation) != null ? P : _.sideOrientation;
      E && (m = m === 0 ? 1 : 0);
      const T = m === 0;
      d.setState(_.backFaceCulling, 0, !1, T, _.cullBackFaces);
      const b = l._getInstancesRenderList(h._id, !!h.getReplacementMesh());
      if (b.mustReturn)
        return;
      const R = d.getCaps().instancedArrays && (b.visibleInstances[h._id] !== null && b.visibleInstances[h._id] !== void 0 || l.hasThinInstances), y = this._camera || f.activeCamera;
      if (this.isReady(h, R) && y) {
        h._renderId = f.getRenderId();
        const A = (v = u._internalAbstractMeshDataInfo._materialForRenderPass) == null ? void 0 : v[d.currentRenderPassId];
        let L = h._getDrawWrapper();
        !L && A && (L = A._getDrawWrapper());
        const Q = y.mode === Y.ORTHOGRAPHIC_CAMERA;
        if (!L)
          return;
        const ae = L.effect;
        d.enableEffect(L), R || l._bind(h, ae, _.fillMode), A ? A.bindForSubMesh(u.getWorldMatrix(), u, h) : (ae.setMatrix("viewProjection", f.getTransformMatrix()), ae.setMatrix("world", u.getWorldMatrix()));
        let be, fe;
        if (Q ? (be = !d.useReverseDepthBuffer && d.isNDCHalfZRange ? 0 : 1, fe = d.useReverseDepthBuffer && d.isNDCHalfZRange ? 0 : 1) : (be = d.useReverseDepthBuffer && d.isNDCHalfZRange ? y.minZ : d.isNDCHalfZRange ? 0 : y.minZ, fe = d.useReverseDepthBuffer && d.isNDCHalfZRange ? 0 : y.maxZ), ae.setFloat2("depthValues", be, be + fe), !A) {
          if (_ && _.needAlphaTesting()) {
            const ue = _.getAlphaTestTexture();
            ue && (ae.setTexture("diffuseSampler", ue), ae.setMatrix("diffuseMatrix", ue.getTextureMatrix()));
          }
          if (l.useBones && l.computeBonesUsingShaders && l.skeleton) {
            const ue = l.skeleton;
            if (ue.isUsingTextureForMatrices) {
              const ie = ue.getTransformMatrixTexture(l);
              if (!ie)
                return;
              ae.setTexture("boneSampler", ie), ae.setFloat("boneTextureWidth", 4 * (ue.bones.length + 1));
            } else
              ae.setMatrices("mBones", ue.getTransformMatrices(l));
          }
          J.BindClipPlane(ae, f), J.BindMorphTargetParameters(l, ae), l.morphTargetManager && l.morphTargetManager.isUsingTextureForTargets && l.morphTargetManager._bind(ae);
        }
        l._processRendering(u, h, ae, _.fillMode, b, R, (ue, ie) => ae.setMatrix("world", ie));
      }
    };
    this._depthMap.customRenderFunction = (h, l, u, f) => {
      let d;
      if (f.length)
        for (d = 0; d < f.length; d++)
          o(f.data[d]);
      for (d = 0; d < h.length; d++)
        o(h.data[d]);
      for (d = 0; d < l.length; d++)
        o(l.data[d]);
      if (this.forceDepthWriteTransparentMeshes)
        for (d = 0; d < u.length; d++)
          o(u.data[d]);
      else
        for (d = 0; d < u.length; d++)
          u.data[d].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = !1;
    };
  }
  setMaterialForRendering(e, t) {
    this._depthMap.setMaterialForRendering(e, t);
  }
  isReady(e, t) {
    var E;
    const i = this._scene.getEngine(), s = e.getMesh(), r = s.getScene(), n = (E = s._internalAbstractMeshDataInfo._materialForRenderPass) == null ? void 0 : E[i.currentRenderPassId];
    if (n)
      return n.isReadyForSubMesh(s, e, t);
    const a = e.getMaterial();
    if (!a || a.disableDepthWrite)
      return !1;
    const o = [], h = [p.PositionKind];
    if (a && a.needAlphaTesting() && a.getAlphaTestTexture() && (o.push("#define ALPHATEST"), s.isVerticesDataPresent(p.UVKind) && (h.push(p.UVKind), o.push("#define UV1")), s.isVerticesDataPresent(p.UV2Kind) && (h.push(p.UV2Kind), o.push("#define UV2"))), s.useBones && s.computeBonesUsingShaders) {
      h.push(p.MatricesIndicesKind), h.push(p.MatricesWeightsKind), s.numBoneInfluencers > 4 && (h.push(p.MatricesIndicesExtraKind), h.push(p.MatricesWeightsExtraKind)), o.push("#define NUM_BONE_INFLUENCERS " + s.numBoneInfluencers), o.push("#define BonesPerMesh " + (s.skeleton ? s.skeleton.bones.length + 1 : 0));
      const m = e.getRenderingMesh().skeleton;
      m != null && m.isUsingTextureForMatrices && o.push("#define BONETEXTURE");
    } else
      o.push("#define NUM_BONE_INFLUENCERS 0");
    const l = s.morphTargetManager;
    let u = 0;
    l && l.numInfluencers > 0 && (u = l.numInfluencers, o.push("#define MORPHTARGETS"), o.push("#define NUM_MORPH_INFLUENCERS " + u), l.isUsingTextureForTargets && o.push("#define MORPHTARGETS_TEXTURE"), J.PrepareAttributesForMorphTargetsInfluencers(h, s, u)), t && (o.push("#define INSTANCES"), J.PushAttributesForInstances(h), e.getRenderingMesh().hasThinInstances && o.push("#define THIN_INSTANCES")), this._storeNonLinearDepth && o.push("#define NONLINEARDEPTH"), this.isPacked && o.push("#define PACKED"), r.clipPlane && o.push("#define CLIPPLANE"), r.clipPlane2 && o.push("#define CLIPPLANE2"), r.clipPlane3 && o.push("#define CLIPPLANE3"), r.clipPlane4 && o.push("#define CLIPPLANE4"), r.clipPlane5 && o.push("#define CLIPPLANE5"), r.clipPlane6 && o.push("#define CLIPPLANE6");
    const f = e._getDrawWrapper(void 0, !0), d = f.defines, _ = o.join(`
`);
    return d !== _ && f.setEffect(i.createEffect("depth", h, [
      "world",
      "mBones",
      "boneTextureWidth",
      "viewProjection",
      "diffuseMatrix",
      "depthValues",
      "morphTargetInfluences",
      "morphTargetTextureInfo",
      "morphTargetTextureIndices",
      "vClipPlane",
      "vClipPlane2",
      "vClipPlane3",
      "vClipPlane4",
      "vClipPlane5",
      "vClipPlane6"
    ], ["diffuseSampler", "morphTargets", "boneSampler"], _, void 0, void 0, void 0, { maxSimultaneousMorphTargets: u }), _), f.effect.isReady();
  }
  getDepthMap() {
    return this._depthMap;
  }
  dispose() {
    const e = [];
    for (const t in this._scene._depthRenderer)
      this._scene._depthRenderer[t] === this && e.push(t);
    if (e.length > 0) {
      this._depthMap.dispose();
      for (const t of e)
        delete this._scene._depthRenderer[t];
    }
  }
}
hs._SceneComponentInitialization = (c) => {
  throw q("DepthRendererSceneComponent");
};
const To = "minmaxReduxPixelShader", So = `varying vec2 vUV;
uniform sampler2D textureSampler;
#if defined(INITIAL)
uniform sampler2D sourceTexture;
uniform vec2 texSize;
void main(void)
{
ivec2 coord=ivec2(vUV*(texSize-1.0));
float f1=texelFetch(sourceTexture,coord,0).r;
float f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;
float f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;
float f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;
float minz=min(min(min(f1,f2),f3),f4);
#ifdef DEPTH_REDUX
float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);
#else
float maxz=max(max(max(f1,f2),f3),f4);
#endif
glFragColor=vec4(minz,maxz,0.,0.);
}
#elif defined(MAIN)
uniform vec2 texSize;
void main(void)
{
ivec2 coord=ivec2(vUV*(texSize-1.0));
vec2 f1=texelFetch(textureSampler,coord,0).rg;
vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;
vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;
vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;
float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);
float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);
glFragColor=vec4(minz,maxz,0.,0.);
}
#elif defined(ONEBEFORELAST)
uniform ivec2 texSize;
void main(void)
{
ivec2 coord=ivec2(vUV*vec2(texSize-1));
vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;
vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;
vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;
vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;
float minz=min(f1.x,f2.x);
float maxz=max(f1.y,f2.y);
glFragColor=vec4(minz,maxz,0.,0.);
}
#elif defined(LAST)
void main(void)
{
glFragColor=vec4(0.);
if (true) { 
discard;
}
}
#endif
`;
N.ShadersStore[To] = So;
class bo {
  constructor(e) {
    this.onAfterReductionPerformed = new F(), this._forceFullscreenViewport = !0, this._activated = !1, this._camera = e, this._postProcessManager = new Qi(e.getScene()), this._onContextRestoredObserver = e.getEngine().onContextRestoredObservable.add(() => {
      this._postProcessManager._rebuild();
    });
  }
  get sourceTexture() {
    return this._sourceTexture;
  }
  setSourceTexture(e, t, i = 2, s = !0) {
    if (e === this._sourceTexture)
      return;
    this.dispose(!1), this._sourceTexture = e, this._reductionSteps = [], this._forceFullscreenViewport = s;
    const r = this._camera.getScene(), n = new Oe(
      "Initial reduction phase",
      "minmaxRedux",
      ["texSize"],
      ["sourceTexture"],
      1,
      null,
      1,
      r.getEngine(),
      !1,
      "#define INITIAL" + (t ? `
#define DEPTH_REDUX` : ""),
      i,
      void 0,
      void 0,
      void 0,
      7
    );
    n.autoClear = !1, n.forceFullscreenViewport = s;
    let a = this._sourceTexture.getRenderWidth(), o = this._sourceTexture.getRenderHeight();
    n.onApply = ((l, u) => (f) => {
      f.setTexture("sourceTexture", this._sourceTexture), f.setFloat2("texSize", l, u);
    })(a, o), this._reductionSteps.push(n);
    let h = 1;
    for (; a > 1 || o > 1; ) {
      a = Math.max(Math.round(a / 2), 1), o = Math.max(Math.round(o / 2), 1);
      const l = new Oe(
        "Reduction phase " + h,
        "minmaxRedux",
        ["texSize"],
        null,
        { width: a, height: o },
        null,
        1,
        r.getEngine(),
        !1,
        "#define " + (a == 1 && o == 1 ? "LAST" : a == 1 || o == 1 ? "ONEBEFORELAST" : "MAIN"),
        i,
        void 0,
        void 0,
        void 0,
        7
      );
      if (l.autoClear = !1, l.forceFullscreenViewport = s, l.onApply = ((u, f) => (d) => {
        u == 1 || f == 1 ? d.setInt2("texSize", u, f) : d.setFloat2("texSize", u, f);
      })(a, o), this._reductionSteps.push(l), h++, a == 1 && o == 1) {
        const u = (f, d, _) => {
          const E = new Float32Array(4 * f * d), m = { min: 0, max: 0 };
          return () => {
            r.getEngine()._readTexturePixels(_.inputTexture.texture, f, d, -1, 0, E, !1), m.min = E[0], m.max = E[1], this.onAfterReductionPerformed.notifyObservers(m);
          };
        };
        l.onAfterRenderObservable.add(u(a, o, l));
      }
    }
  }
  get refreshRate() {
    return this._sourceTexture ? this._sourceTexture.refreshRate : -1;
  }
  set refreshRate(e) {
    this._sourceTexture && (this._sourceTexture.refreshRate = e);
  }
  get activated() {
    return this._activated;
  }
  activate() {
    this._onAfterUnbindObserver || !this._sourceTexture || (this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(() => {
      var t, i;
      const e = this._camera.getScene().getEngine();
      (t = e._debugPushGroup) == null || t.call(e, "min max reduction", 1), this._reductionSteps[0].activate(this._camera), this._postProcessManager.directRender(this._reductionSteps, this._reductionSteps[0].inputTexture, this._forceFullscreenViewport), e.unBindFramebuffer(this._reductionSteps[0].inputTexture, !1), (i = e._debugPopGroup) == null || i.call(e, 1);
    }), this._activated = !0);
  }
  deactivate() {
    !this._onAfterUnbindObserver || !this._sourceTexture || (this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver), this._onAfterUnbindObserver = null, this._activated = !1);
  }
  dispose(e = !0) {
    if (e && (this.onAfterReductionPerformed.clear(), this._onContextRestoredObserver && (this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver), this._onContextRestoredObserver = null)), this.deactivate(), this._reductionSteps) {
      for (let t = 0; t < this._reductionSteps.length; ++t)
        this._reductionSteps[t].dispose();
      this._reductionSteps = null;
    }
    this._postProcessManager && e && this._postProcessManager.dispose(), this._sourceTexture = null;
  }
}
class xo extends bo {
  constructor(e) {
    super(e);
  }
  get depthRenderer() {
    return this._depthRenderer;
  }
  setDepthRenderer(e = null, t = 2, i = !0) {
    const s = this._camera.getScene();
    this._depthRenderer && (delete s._depthRenderer[this._depthRendererId], this._depthRenderer.dispose(), this._depthRenderer = null), e === null && (s._depthRenderer || (s._depthRenderer = {}), e = this._depthRenderer = new hs(s, t, this._camera, !1, 1), e.enabled = !1, this._depthRendererId = "minmax" + this._camera.id, s._depthRenderer[this._depthRendererId] = e), super.setSourceTexture(e.getDepthMap(), !0, t, i);
  }
  setSourceTexture(e, t, i = 2, s = !0) {
    super.setSourceTexture(e, t, i, s);
  }
  activate() {
    this._depthRenderer && (this._depthRenderer.enabled = !0), super.activate();
  }
  deactivate() {
    super.deactivate(), this._depthRenderer && (this._depthRenderer.enabled = !1);
  }
  dispose(e = !0) {
    if (super.dispose(e), this._depthRenderer && e) {
      const t = this._depthRenderer.getDepthMap().getScene();
      t && delete t._depthRenderer[this._depthRendererId], this._depthRenderer.dispose(), this._depthRenderer = null;
    }
  }
}
const cr = g.Up(), vo = g.Zero(), Fe = new g(), fi = new g(), zi = new x();
class Be extends W {
  constructor(e, t, i) {
    if (!Be.IsSupported) {
      w.Error("CascadedShadowMap is not supported by the current engine.");
      return;
    }
    super(e, t, i), this.usePercentageCloserFiltering = !0;
  }
  _validateFilter(e) {
    return e === W.FILTER_NONE || e === W.FILTER_PCF || e === W.FILTER_PCSS ? e : (console.error('Unsupported filter "' + e + '"!'), W.FILTER_NONE);
  }
  get numCascades() {
    return this._numCascades;
  }
  set numCascades(e) {
    e = Math.min(Math.max(e, Be.MIN_CASCADES_COUNT), Be.MAX_CASCADES_COUNT), e !== this._numCascades && (this._numCascades = e, this.recreateShadowMap(), this._recreateSceneUBOs());
  }
  get freezeShadowCastersBoundingInfo() {
    return this._freezeShadowCastersBoundingInfo;
  }
  set freezeShadowCastersBoundingInfo(e) {
    this._freezeShadowCastersBoundingInfoObservable && e && (this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable), this._freezeShadowCastersBoundingInfoObservable = null), !this._freezeShadowCastersBoundingInfoObservable && !e && (this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(this._computeShadowCastersBoundingInfo.bind(this))), this._freezeShadowCastersBoundingInfo = e, e && this._computeShadowCastersBoundingInfo();
  }
  _computeShadowCastersBoundingInfo() {
    if (this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._scbiMax.copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE), this._shadowMap && this._shadowMap.renderList) {
      const e = this._shadowMap.renderList;
      for (let i = 0; i < e.length; i++) {
        const s = e[i];
        if (!s)
          continue;
        const r = s.getBoundingInfo(), n = r.boundingBox;
        this._scbiMin.minimizeInPlace(n.minimumWorld), this._scbiMax.maximizeInPlace(n.maximumWorld);
      }
      const t = this._scene.meshes;
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        if (!s || !s.isVisible || !s.isEnabled || !s.receiveShadows)
          continue;
        const r = s.getBoundingInfo(), n = r.boundingBox;
        this._scbiMin.minimizeInPlace(n.minimumWorld), this._scbiMax.maximizeInPlace(n.maximumWorld);
      }
    }
    this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);
  }
  get shadowCastersBoundingInfo() {
    return this._shadowCastersBoundingInfo;
  }
  set shadowCastersBoundingInfo(e) {
    this._shadowCastersBoundingInfo = e;
  }
  setMinMaxDistance(e, t) {
    this._minDistance === e && this._maxDistance === t || (e > t && (e = 0, t = 1), e < 0 && (e = 0), t > 1 && (t = 1), this._minDistance = e, this._maxDistance = t, this._breaksAreDirty = !0);
  }
  get minDistance() {
    return this._minDistance;
  }
  get maxDistance() {
    return this._maxDistance;
  }
  getClassName() {
    return Be.CLASSNAME;
  }
  getCascadeMinExtents(e) {
    return e >= 0 && e < this._numCascades ? this._cascadeMinExtents[e] : null;
  }
  getCascadeMaxExtents(e) {
    return e >= 0 && e < this._numCascades ? this._cascadeMaxExtents[e] : null;
  }
  get shadowMaxZ() {
    return !this._scene || !this._scene.activeCamera ? 0 : this._shadowMaxZ;
  }
  set shadowMaxZ(e) {
    if (!this._scene || !this._scene.activeCamera) {
      this._shadowMaxZ = e;
      return;
    }
    this._shadowMaxZ === e || e < this._scene.activeCamera.minZ || e > this._scene.activeCamera.maxZ || (this._shadowMaxZ = e, this._light._markMeshesAsLightDirty(), this._breaksAreDirty = !0);
  }
  get debug() {
    return this._debug;
  }
  set debug(e) {
    this._debug = e, this._light._markMeshesAsLightDirty();
  }
  get depthClamp() {
    return this._depthClamp;
  }
  set depthClamp(e) {
    this._depthClamp = e;
  }
  get cascadeBlendPercentage() {
    return this._cascadeBlendPercentage;
  }
  set cascadeBlendPercentage(e) {
    this._cascadeBlendPercentage = e, this._light._markMeshesAsLightDirty();
  }
  get lambda() {
    return this._lambda;
  }
  set lambda(e) {
    const t = Math.min(Math.max(e, 0), 1);
    this._lambda != t && (this._lambda = t, this._breaksAreDirty = !0);
  }
  getCascadeViewMatrix(e) {
    return e >= 0 && e < this._numCascades ? this._viewMatrices[e] : null;
  }
  getCascadeProjectionMatrix(e) {
    return e >= 0 && e < this._numCascades ? this._projectionMatrices[e] : null;
  }
  getCascadeTransformMatrix(e) {
    return e >= 0 && e < this._numCascades ? this._transformMatrices[e] : null;
  }
  setDepthRenderer(e) {
    this._depthRenderer = e, this._depthReducer && this._depthReducer.setDepthRenderer(this._depthRenderer);
  }
  get autoCalcDepthBounds() {
    return this._autoCalcDepthBounds;
  }
  set autoCalcDepthBounds(e) {
    const t = this._scene.activeCamera;
    if (!!t) {
      if (this._autoCalcDepthBounds = e, !e) {
        this._depthReducer && this._depthReducer.deactivate(), this.setMinMaxDistance(0, 1);
        return;
      }
      this._depthReducer || (this._depthReducer = new xo(t), this._depthReducer.onAfterReductionPerformed.add((i) => {
        let s = i.min, r = i.max;
        s >= r && (s = 0, r = 1), (s != this._minDistance || r != this._maxDistance) && this.setMinMaxDistance(s, r);
      }), this._depthReducer.setDepthRenderer(this._depthRenderer)), this._depthReducer.activate();
    }
  }
  get autoCalcDepthBoundsRefreshRate() {
    var e, t, i;
    return (i = (t = (e = this._depthReducer) == null ? void 0 : e.depthRenderer) == null ? void 0 : t.getDepthMap().refreshRate) != null ? i : -1;
  }
  set autoCalcDepthBoundsRefreshRate(e) {
    var t;
    (t = this._depthReducer) != null && t.depthRenderer && (this._depthReducer.depthRenderer.getDepthMap().refreshRate = e);
  }
  splitFrustum() {
    this._breaksAreDirty = !0;
  }
  _splitFrustum() {
    const e = this._scene.activeCamera;
    if (!e)
      return;
    const t = e.minZ, i = e.maxZ, s = i - t, r = this._minDistance, n = this._shadowMaxZ < i && this._shadowMaxZ >= t ? Math.min((this._shadowMaxZ - t) / (i - t), this._maxDistance) : this._maxDistance, a = t + r * s, o = t + n * s, h = o - a, l = o / a;
    for (let u = 0; u < this._cascades.length; ++u) {
      const f = (u + 1) / this._numCascades, d = a * l ** f, _ = a + h * f, E = this._lambda * (d - _) + _;
      this._cascades[u].prevBreakDistance = u === 0 ? r : this._cascades[u - 1].breakDistance, this._cascades[u].breakDistance = (E - t) / s, this._viewSpaceFrustumsZ[u] = E, this._frustumLengths[u] = (this._cascades[u].breakDistance - this._cascades[u].prevBreakDistance) * s;
    }
    this._breaksAreDirty = !1;
  }
  _computeMatrices() {
    const e = this._scene;
    if (!e.activeCamera)
      return;
    g.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection), Math.abs(g.Dot(this._lightDirection, g.Up())) === 1 && (this._lightDirection.z = 1e-13), this._cachedDirection.copyFrom(this._lightDirection);
    const i = e.getEngine().useReverseDepthBuffer;
    for (let s = 0; s < this._numCascades; ++s) {
      this._computeFrustumInWorldSpace(s), this._computeCascadeFrustum(s), this._cascadeMaxExtents[s].subtractToRef(this._cascadeMinExtents[s], Fe), this._frustumCenter[s].addToRef(this._lightDirection.scale(this._cascadeMinExtents[s].z), this._shadowCameraPos[s]), x.LookAtLHToRef(this._shadowCameraPos[s], this._frustumCenter[s], cr, this._viewMatrices[s]);
      let r = 0, n = Fe.z;
      const a = this._shadowCastersBoundingInfo;
      a.update(this._viewMatrices[s]), n = Math.min(n, a.boundingBox.maximumWorld.z), !this._depthClamp || this.filter === W.FILTER_PCSS ? r = Math.min(r, a.boundingBox.minimumWorld.z) : r = Math.max(r, a.boundingBox.minimumWorld.z), x.OrthoOffCenterLHToRef(this._cascadeMinExtents[s].x, this._cascadeMaxExtents[s].x, this._cascadeMinExtents[s].y, this._cascadeMaxExtents[s].y, i ? n : r, i ? r : n, this._projectionMatrices[s], e.getEngine().isNDCHalfZRange), this._cascadeMinExtents[s].z = r, this._cascadeMaxExtents[s].z = n, this._viewMatrices[s].multiplyToRef(this._projectionMatrices[s], this._transformMatrices[s]), g.TransformCoordinatesToRef(vo, this._transformMatrices[s], Fe), Fe.scaleInPlace(this._mapSize / 2), fi.copyFromFloats(Math.round(Fe.x), Math.round(Fe.y), Math.round(Fe.z)), fi.subtractInPlace(Fe).scaleInPlace(2 / this._mapSize), x.TranslationToRef(fi.x, fi.y, 0, zi), this._projectionMatrices[s].multiplyToRef(zi, this._projectionMatrices[s]), this._viewMatrices[s].multiplyToRef(this._projectionMatrices[s], this._transformMatrices[s]), this._transformMatrices[s].copyToArray(this._transformMatricesAsArray, s * 16);
    }
  }
  _computeFrustumInWorldSpace(e) {
    if (!this._scene.activeCamera)
      return;
    const t = this._cascades[e].prevBreakDistance, i = this._cascades[e].breakDistance, s = this._scene.getEngine().isNDCHalfZRange;
    this._scene.activeCamera.getViewMatrix();
    const r = x.Invert(this._scene.activeCamera.getTransformationMatrix()), n = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;
    for (let a = 0; a < Be._FrustumCornersNDCSpace.length; ++a)
      Fe.copyFrom(Be._FrustumCornersNDCSpace[(a + n) % Be._FrustumCornersNDCSpace.length]), s && Fe.z === -1 && (Fe.z = 0), g.TransformCoordinatesToRef(Fe, r, this._frustumCornersWorldSpace[e][a]);
    for (let a = 0; a < Be._FrustumCornersNDCSpace.length / 2; ++a)
      Fe.copyFrom(this._frustumCornersWorldSpace[e][a + 4]).subtractInPlace(this._frustumCornersWorldSpace[e][a]), fi.copyFrom(Fe).scaleInPlace(t), Fe.scaleInPlace(i), Fe.addInPlace(this._frustumCornersWorldSpace[e][a]), this._frustumCornersWorldSpace[e][a + 4].copyFrom(Fe), this._frustumCornersWorldSpace[e][a].addInPlace(fi);
  }
  _computeCascadeFrustum(e) {
    if (this._cascadeMinExtents[e].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cascadeMaxExtents[e].copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE), this._frustumCenter[e].copyFromFloats(0, 0, 0), !!this._scene.activeCamera) {
      for (let i = 0; i < this._frustumCornersWorldSpace[e].length; ++i)
        this._frustumCenter[e].addInPlace(this._frustumCornersWorldSpace[e][i]);
      if (this._frustumCenter[e].scaleInPlace(1 / this._frustumCornersWorldSpace[e].length), this.stabilizeCascades) {
        let i = 0;
        for (let s = 0; s < this._frustumCornersWorldSpace[e].length; ++s) {
          const r = this._frustumCornersWorldSpace[e][s].subtractToRef(this._frustumCenter[e], Fe).length();
          i = Math.max(i, r);
        }
        i = Math.ceil(i * 16) / 16, this._cascadeMaxExtents[e].copyFromFloats(i, i, i), this._cascadeMinExtents[e].copyFromFloats(-i, -i, -i);
      } else {
        const i = this._frustumCenter[e];
        this._frustumCenter[e].addToRef(this._lightDirection, Fe), x.LookAtLHToRef(i, Fe, cr, zi);
        for (let s = 0; s < this._frustumCornersWorldSpace[e].length; ++s)
          g.TransformCoordinatesToRef(this._frustumCornersWorldSpace[e][s], zi, Fe), this._cascadeMinExtents[e].minimizeInPlace(Fe), this._cascadeMaxExtents[e].maximizeInPlace(Fe);
      }
    }
  }
  _recreateSceneUBOs() {
    if (this._disposeSceneUBOs(), this._sceneUBOs)
      for (let e = 0; e < this._numCascades; ++e)
        this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${e})`));
  }
  static get IsSupported() {
    const e = _e.LastCreatedEngine;
    return e ? e._features.supportCSM : !1;
  }
  _initializeGenerator() {
    var e, t, i, s, r, n, a, o, h, l, u, f, d, _, E, m, T, b, R, y;
    this.penumbraDarkness = (e = this.penumbraDarkness) != null ? e : 1, this._numCascades = (t = this._numCascades) != null ? t : Be.DEFAULT_CASCADES_COUNT, this.stabilizeCascades = (i = this.stabilizeCascades) != null ? i : !1, this._freezeShadowCastersBoundingInfoObservable = (s = this._freezeShadowCastersBoundingInfoObservable) != null ? s : null, this.freezeShadowCastersBoundingInfo = (r = this.freezeShadowCastersBoundingInfo) != null ? r : !1, this._scbiMin = (n = this._scbiMin) != null ? n : new g(0, 0, 0), this._scbiMax = (a = this._scbiMax) != null ? a : new g(0, 0, 0), this._shadowCastersBoundingInfo = (o = this._shadowCastersBoundingInfo) != null ? o : new ft(new g(0, 0, 0), new g(0, 0, 0)), this._breaksAreDirty = (h = this._breaksAreDirty) != null ? h : !0, this._minDistance = (l = this._minDistance) != null ? l : 0, this._maxDistance = (u = this._maxDistance) != null ? u : 1, this._currentLayer = (f = this._currentLayer) != null ? f : 0, this._shadowMaxZ = (E = (_ = this._shadowMaxZ) != null ? _ : (d = this._scene.activeCamera) == null ? void 0 : d.maxZ) != null ? E : 1e4, this._debug = (m = this._debug) != null ? m : !1, this._depthClamp = (T = this._depthClamp) != null ? T : !0, this._cascadeBlendPercentage = (b = this._cascadeBlendPercentage) != null ? b : 0.1, this._lambda = (R = this._lambda) != null ? R : 0.5, this._autoCalcDepthBounds = (y = this._autoCalcDepthBounds) != null ? y : !1, this._recreateSceneUBOs(), super._initializeGenerator();
  }
  _createTargetRenderTexture() {
    const e = this._scene.getEngine(), t = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };
    this._shadowMap = new dt(this._light.name + "_CSMShadowMap", t, this._scene, !1, !0, this._textureType, !1, void 0, !1, !1, void 0), this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer ? 516 : 513, !0);
  }
  _initializeShadowMap() {
    if (super._initializeShadowMap(), this._shadowMap === null)
      return;
    this._transformMatricesAsArray = new Float32Array(this._numCascades * 16), this._viewSpaceFrustumsZ = new Array(this._numCascades), this._frustumLengths = new Array(this._numCascades), this._lightSizeUVCorrection = new Array(this._numCascades * 2), this._depthCorrection = new Array(this._numCascades), this._cascades = [], this._viewMatrices = [], this._projectionMatrices = [], this._transformMatrices = [], this._cascadeMinExtents = [], this._cascadeMaxExtents = [], this._frustumCenter = [], this._shadowCameraPos = [], this._frustumCornersWorldSpace = [];
    for (let t = 0; t < this._numCascades; ++t) {
      this._cascades[t] = {
        prevBreakDistance: 0,
        breakDistance: 0
      }, this._viewMatrices[t] = x.Zero(), this._projectionMatrices[t] = x.Zero(), this._transformMatrices[t] = x.Zero(), this._cascadeMinExtents[t] = new g(), this._cascadeMaxExtents[t] = new g(), this._frustumCenter[t] = new g(), this._shadowCameraPos[t] = new g(), this._frustumCornersWorldSpace[t] = new Array(Be._FrustumCornersNDCSpace.length);
      for (let i = 0; i < Be._FrustumCornersNDCSpace.length; ++i)
        this._frustumCornersWorldSpace[t][i] = new g();
    }
    const e = this._scene.getEngine();
    this._shadowMap.onBeforeBindObservable.clear(), this._shadowMap.onBeforeRenderObservable.clear(), this._shadowMap.onBeforeRenderObservable.add((t) => {
      this._sceneUBOs && this._scene.setSceneUniformBuffer(this._sceneUBOs[t]), this._currentLayer = t, this._filter === W.FILTER_PCF && e.setColorWrite(!1), this._scene.setTransformMatrix(this.getCascadeViewMatrix(t), this.getCascadeProjectionMatrix(t)), this._useUBO && (this._scene.getSceneUniformBuffer().unbindEffect(), this._scene.finalizeSceneUbo());
    }), this._shadowMap.onBeforeBindObservable.add(() => {
      var t;
      this._currentSceneUBO = this._scene.getSceneUniformBuffer(), (t = e._debugPushGroup) == null || t.call(e, `cascaded shadow map generation for pass id ${e.currentRenderPassId}`, 1), this._breaksAreDirty && this._splitFrustum(), this._computeMatrices();
    }), this._splitFrustum();
  }
  _bindCustomEffectForRenderSubMeshForShadowMap(e, t) {
    t.setMatrix("viewProjection", this.getCascadeTransformMatrix(this._currentLayer));
  }
  _isReadyCustomDefines(e) {
    e.push("#define SM_DEPTHCLAMP " + (this._depthClamp && this._filter !== W.FILTER_PCSS ? "1" : "0"));
  }
  prepareDefines(e, t) {
    super.prepareDefines(e, t);
    const i = this._scene, s = this._light;
    if (!i.shadowsEnabled || !s.shadowEnabled)
      return;
    e["SHADOWCSM" + t] = !0, e["SHADOWCSMDEBUG" + t] = this.debug, e["SHADOWCSMNUM_CASCADES" + t] = this.numCascades, e["SHADOWCSM_RIGHTHANDED" + t] = i.useRightHandedSystem;
    const r = i.activeCamera;
    r && this._shadowMaxZ < r.maxZ && (e["SHADOWCSMUSESHADOWMAXZ" + t] = !0), this.cascadeBlendPercentage === 0 && (e["SHADOWCSMNOBLEND" + t] = !0);
  }
  bindShadowLight(e, t) {
    const i = this._light, s = this._scene;
    if (!s.shadowsEnabled || !i.shadowEnabled)
      return;
    const r = s.activeCamera;
    if (!r)
      return;
    const n = this.getShadowMap();
    if (!n)
      return;
    const a = n.getSize().width;
    if (t.setMatrices("lightMatrix" + e, this._transformMatricesAsArray), t.setArray("viewFrustumZ" + e, this._viewSpaceFrustumsZ), t.setFloat("cascadeBlendFactor" + e, this.cascadeBlendPercentage === 0 ? 1e4 : 1 / this.cascadeBlendPercentage), t.setArray("frustumLengths" + e, this._frustumLengths), this._filter === W.FILTER_PCF)
      t.setDepthStencilTexture("shadowSampler" + e, n), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), a, 1 / a, this.frustumEdgeFalloff, e);
    else if (this._filter === W.FILTER_PCSS) {
      for (let o = 0; o < this._numCascades; ++o)
        this._lightSizeUVCorrection[o * 2 + 0] = o === 0 ? 1 : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[o].x - this._cascadeMinExtents[o].x), this._lightSizeUVCorrection[o * 2 + 1] = o === 0 ? 1 : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[o].y - this._cascadeMinExtents[o].y), this._depthCorrection[o] = o === 0 ? 1 : (this._cascadeMaxExtents[o].z - this._cascadeMinExtents[o].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);
      t.setDepthStencilTexture("shadowSampler" + e, n), t.setTexture("depthSampler" + e, n), t.setArray2("lightSizeUVCorrection" + e, this._lightSizeUVCorrection), t.setArray("depthCorrection" + e, this._depthCorrection), t.setFloat("penumbraDarkness" + e, this.penumbraDarkness), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / a, this._contactHardeningLightSizeUVRatio * a, this.frustumEdgeFalloff, e);
    } else
      t.setTexture("shadowSampler" + e, n), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), a, 1 / a, this.frustumEdgeFalloff, e);
    i._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(r), this.getLight().getDepthMinZ(r) + this.getLight().getDepthMaxZ(r), e);
  }
  getTransformMatrix() {
    return this.getCascadeTransformMatrix(0);
  }
  dispose() {
    super.dispose(), this._freezeShadowCastersBoundingInfoObservable && (this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable), this._freezeShadowCastersBoundingInfoObservable = null), this._depthReducer && (this._depthReducer.dispose(), this._depthReducer = null);
  }
  serialize() {
    const e = super.serialize(), t = this.getShadowMap();
    if (!t)
      return e;
    if (e.numCascades = this._numCascades, e.debug = this._debug, e.stabilizeCascades = this.stabilizeCascades, e.lambda = this._lambda, e.cascadeBlendPercentage = this.cascadeBlendPercentage, e.depthClamp = this._depthClamp, e.autoCalcDepthBounds = this.autoCalcDepthBounds, e.shadowMaxZ = this._shadowMaxZ, e.penumbraDarkness = this.penumbraDarkness, e.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo, e.minDistance = this.minDistance, e.maxDistance = this.maxDistance, e.renderList = [], t.renderList)
      for (let i = 0; i < t.renderList.length; i++) {
        const s = t.renderList[i];
        e.renderList.push(s.id);
      }
    return e;
  }
  static Parse(e, t) {
    const i = W.Parse(e, t, (s, r) => new Be(s, r));
    return e.numCascades !== void 0 && (i.numCascades = e.numCascades), e.debug !== void 0 && (i.debug = e.debug), e.stabilizeCascades !== void 0 && (i.stabilizeCascades = e.stabilizeCascades), e.lambda !== void 0 && (i.lambda = e.lambda), e.cascadeBlendPercentage !== void 0 && (i.cascadeBlendPercentage = e.cascadeBlendPercentage), e.depthClamp !== void 0 && (i.depthClamp = e.depthClamp), e.autoCalcDepthBounds !== void 0 && (i.autoCalcDepthBounds = e.autoCalcDepthBounds), e.shadowMaxZ !== void 0 && (i.shadowMaxZ = e.shadowMaxZ), e.penumbraDarkness !== void 0 && (i.penumbraDarkness = e.penumbraDarkness), e.freezeShadowCastersBoundingInfo !== void 0 && (i.freezeShadowCastersBoundingInfo = e.freezeShadowCastersBoundingInfo), e.minDistance !== void 0 && e.maxDistance !== void 0 && i.setMinMaxDistance(e.minDistance, e.maxDistance), i;
  }
}
Be._FrustumCornersNDCSpace = [
  new g(-1, 1, -1),
  new g(1, 1, -1),
  new g(1, -1, -1),
  new g(-1, -1, -1),
  new g(-1, 1, 1),
  new g(1, 1, 1),
  new g(1, -1, 1),
  new g(-1, -1, 1)
];
Be.CLASSNAME = "CascadedShadowGenerator";
Be.DEFAULT_CASCADES_COUNT = 4;
Be.MIN_CASCADES_COUNT = 2;
Be.MAX_CASCADES_COUNT = 4;
Be._SceneComponentInitialization = (c) => {
  throw q("ShadowGeneratorSceneComponent");
};
rs.AddParser(j.NAME_SHADOWGENERATOR, (c, e) => {
  if (c.shadowGenerators !== void 0 && c.shadowGenerators !== null)
    for (let t = 0, i = c.shadowGenerators.length; t < i; t++) {
      const s = c.shadowGenerators[t];
      s.className === Be.CLASSNAME ? Be.Parse(s, e) : W.Parse(s, e);
    }
});
class Mo {
  constructor(e) {
    this.name = j.NAME_SHADOWGENERATOR, this.scene = e;
  }
  register() {
    this.scene._gatherRenderTargetsStage.registerStep(j.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);
  }
  rebuild() {
  }
  serialize(e) {
    e.shadowGenerators = [];
    const t = this.scene.lights;
    for (const i of t) {
      const s = i.getShadowGenerator();
      s && e.shadowGenerators.push(s.serialize());
    }
  }
  addFromContainer(e) {
  }
  removeFromContainer(e, t) {
  }
  dispose() {
  }
  _gatherRenderTargets(e) {
    const t = this.scene;
    if (this.scene.shadowsEnabled)
      for (let i = 0; i < t.lights.length; i++) {
        const s = t.lights[i], r = s.getShadowGenerator();
        if (s.isEnabled() && s.shadowEnabled && r) {
          const n = r.getShadowMap();
          t.textures.indexOf(n) !== -1 && e.push(n);
        }
      }
  }
}
W._SceneComponentInitialization = (c) => {
  let e = c._getComponent(j.NAME_SHADOWGENERATOR);
  e || (e = new Mo(c), c._addComponent(e));
};
const Ao = {
  enableShadows: !0
};
function ur(c = Ao) {
  const { enableShadows: e, shadowTransparency: t, intensity: i, scene: s } = c, r = new It("DirectionalLight", new g(-0.3, -1, 0.4), s);
  r.position = new g(-50, 65, -50), r.intensity = 0.65 * i;
  const n = new os("HemisphericLight", new g(1, 1, 0), s);
  return n.intensity = 0.4 * i, e && (r.shadowMinZ = 1, r.shadowMaxZ = 70, r.shadowGenerator = new W(2048, r), r.shadowGenerator.useCloseExponentialShadowMap = !0, r.shadowGenerator.darkness = t), { directional: r, hemispheric: n };
}
function Pr(c) {
  let t = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
  const i = [
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0
  ], s = [];
  let r = [];
  const n = c.width || c.size || 1, a = c.height || c.size || 1, o = c.depth || c.size || 1, h = c.wrap || !1;
  let l = c.topBaseAt === void 0 ? 1 : c.topBaseAt, u = c.bottomBaseAt === void 0 ? 0 : c.bottomBaseAt;
  l = (l + 4) % 4, u = (u + 4) % 4;
  const f = [2, 0, 3, 1], d = [2, 0, 1, 3];
  let _ = f[l], E = d[u], m = [
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1
  ];
  if (h) {
    t = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14], m = [
      -1,
      1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1
    ];
    let A = [
      [1, 1, 1],
      [-1, 1, 1],
      [-1, 1, -1],
      [1, 1, -1]
    ], L = [
      [-1, -1, 1],
      [1, -1, 1],
      [1, -1, -1],
      [-1, -1, -1]
    ];
    const Q = [17, 18, 19, 16], ae = [22, 23, 20, 21];
    for (; _ > 0; )
      A.unshift(A.pop()), Q.unshift(Q.pop()), _--;
    for (; E > 0; )
      L.unshift(L.pop()), ae.unshift(ae.pop()), E--;
    A = A.flat(), L = L.flat(), m = m.concat(A).concat(L), t.push(Q[0], Q[2], Q[3], Q[0], Q[1], Q[2]), t.push(ae[0], ae[2], ae[3], ae[0], ae[1], ae[2]);
  }
  const T = [n / 2, a / 2, o / 2];
  r = m.reduce((A, L, Q) => A.concat(L * T[Q % 3]), []);
  const b = c.sideOrientation === 0 ? 0 : c.sideOrientation || Z.DEFAULTSIDE, R = c.faceUV || new Array(6), y = c.faceColors, P = [];
  for (let A = 0; A < 6; A++)
    R[A] === void 0 && (R[A] = new Ee(0, 0, 1, 1)), y && y[A] === void 0 && (y[A] = new ge(1, 1, 1, 1));
  for (let A = 0; A < 6; A++)
    if (s.push(R[A].z, ct.UseOpenGLOrientationForUV ? 1 - R[A].w : R[A].w), s.push(R[A].x, ct.UseOpenGLOrientationForUV ? 1 - R[A].w : R[A].w), s.push(R[A].x, ct.UseOpenGLOrientationForUV ? 1 - R[A].y : R[A].y), s.push(R[A].z, ct.UseOpenGLOrientationForUV ? 1 - R[A].y : R[A].y), y)
      for (let L = 0; L < 4; L++)
        P.push(y[A].r, y[A].g, y[A].b, y[A].a);
  Z._ComputeSides(b, r, t, i, s, c.frontUVs, c.backUVs);
  const v = new Z();
  if (v.indices = t, v.positions = r, v.normals = i, v.uvs = s, y) {
    const A = b === Z.DOUBLESIDE ? P.concat(P) : P;
    v.colors = A;
  }
  return v;
}
function di(c, e = {}, t = null) {
  const i = new k(c, t);
  return e.sideOrientation = k._GetDefaultSideOrientation(e.sideOrientation), i._originalBuilderSideOrientation = e.sideOrientation, Pr(e).applyToMesh(i, e.updatable), i;
}
Z.CreateBox = Pr;
k.CreateBox = (c, e, t = null, i, s) => di(c, {
  size: e,
  sideOrientation: s,
  updatable: i
}, t);
class fr {
  constructor() {
    this.previousWorldMatrices = {}, this.previousBones = {};
  }
  static AddUniforms(e) {
    e.push("previousWorld", "previousViewProjection", "mPreviousBones");
  }
  static AddSamplers(e) {
  }
  bindForSubMesh(e, t, i, s, r) {
    if (t.prePassRenderer && t.prePassRenderer.enabled && t.prePassRenderer.currentRTisSceneRT && t.prePassRenderer.getIndex(2) !== -1) {
      this.previousWorldMatrices[i.uniqueId] || (this.previousWorldMatrices[i.uniqueId] = s.clone()), this.previousViewProjection || (this.previousViewProjection = t.getTransformMatrix().clone(), this.currentViewProjection = t.getTransformMatrix().clone());
      const n = t.getEngine();
      this.currentViewProjection.updateFlag !== t.getTransformMatrix().updateFlag ? (this._lastUpdateFrameId = n.frameId, this.previousViewProjection.copyFrom(this.currentViewProjection), this.currentViewProjection.copyFrom(t.getTransformMatrix())) : this._lastUpdateFrameId !== n.frameId && (this._lastUpdateFrameId = n.frameId, this.previousViewProjection.copyFrom(this.currentViewProjection)), e.setMatrix("previousWorld", this.previousWorldMatrices[i.uniqueId]), e.setMatrix("previousViewProjection", this.previousViewProjection), this.previousWorldMatrices[i.uniqueId] = s.clone();
    }
  }
}
class Dr extends I {
  constructor(e, t, i = !0) {
    super(e, t), this._normalMatrix = new x(), this._storeEffectOnSubMeshes = i;
  }
  getEffect() {
    return this._storeEffectOnSubMeshes ? this._activeEffect : super.getEffect();
  }
  isReady(e, t) {
    return e ? !this._storeEffectOnSubMeshes || !e.subMeshes || e.subMeshes.length === 0 ? !0 : this.isReadyForSubMesh(e, e.subMeshes[0], t) : !1;
  }
  _isReadyForSubMesh(e) {
    const t = e.materialDefines;
    return !!(!this.checkReadyOnEveryCall && e.effect && t && t._renderId === this.getScene().getRenderId());
  }
  bindOnlyWorldMatrix(e) {
    this._activeEffect.setMatrix("world", e);
  }
  bindOnlyNormalMatrix(e) {
    this._activeEffect.setMatrix("normalMatrix", e);
  }
  bind(e, t) {
    !t || this.bindForSubMesh(e, t, t.subMeshes[0]);
  }
  _afterBind(e, t = null) {
    super._afterBind(e, t), this.getScene()._cachedEffect = t;
  }
  _mustRebind(e, t, i = 1) {
    return e.isCachedMaterialInvalid(this, t, i);
  }
}
class ce {
  static get DiffuseTextureEnabled() {
    return this._DiffuseTextureEnabled;
  }
  static set DiffuseTextureEnabled(e) {
    this._DiffuseTextureEnabled !== e && (this._DiffuseTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get DetailTextureEnabled() {
    return this._DetailTextureEnabled;
  }
  static set DetailTextureEnabled(e) {
    this._DetailTextureEnabled !== e && (this._DetailTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get AmbientTextureEnabled() {
    return this._AmbientTextureEnabled;
  }
  static set AmbientTextureEnabled(e) {
    this._AmbientTextureEnabled !== e && (this._AmbientTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get OpacityTextureEnabled() {
    return this._OpacityTextureEnabled;
  }
  static set OpacityTextureEnabled(e) {
    this._OpacityTextureEnabled !== e && (this._OpacityTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get ReflectionTextureEnabled() {
    return this._ReflectionTextureEnabled;
  }
  static set ReflectionTextureEnabled(e) {
    this._ReflectionTextureEnabled !== e && (this._ReflectionTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get EmissiveTextureEnabled() {
    return this._EmissiveTextureEnabled;
  }
  static set EmissiveTextureEnabled(e) {
    this._EmissiveTextureEnabled !== e && (this._EmissiveTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get SpecularTextureEnabled() {
    return this._SpecularTextureEnabled;
  }
  static set SpecularTextureEnabled(e) {
    this._SpecularTextureEnabled !== e && (this._SpecularTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get BumpTextureEnabled() {
    return this._BumpTextureEnabled;
  }
  static set BumpTextureEnabled(e) {
    this._BumpTextureEnabled !== e && (this._BumpTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get LightmapTextureEnabled() {
    return this._LightmapTextureEnabled;
  }
  static set LightmapTextureEnabled(e) {
    this._LightmapTextureEnabled !== e && (this._LightmapTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get RefractionTextureEnabled() {
    return this._RefractionTextureEnabled;
  }
  static set RefractionTextureEnabled(e) {
    this._RefractionTextureEnabled !== e && (this._RefractionTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get ColorGradingTextureEnabled() {
    return this._ColorGradingTextureEnabled;
  }
  static set ColorGradingTextureEnabled(e) {
    this._ColorGradingTextureEnabled !== e && (this._ColorGradingTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get FresnelEnabled() {
    return this._FresnelEnabled;
  }
  static set FresnelEnabled(e) {
    this._FresnelEnabled !== e && (this._FresnelEnabled = e, C.MarkAllMaterialsAsDirty(4));
  }
  static get ClearCoatTextureEnabled() {
    return this._ClearCoatTextureEnabled;
  }
  static set ClearCoatTextureEnabled(e) {
    this._ClearCoatTextureEnabled !== e && (this._ClearCoatTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get ClearCoatBumpTextureEnabled() {
    return this._ClearCoatBumpTextureEnabled;
  }
  static set ClearCoatBumpTextureEnabled(e) {
    this._ClearCoatBumpTextureEnabled !== e && (this._ClearCoatBumpTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get ClearCoatTintTextureEnabled() {
    return this._ClearCoatTintTextureEnabled;
  }
  static set ClearCoatTintTextureEnabled(e) {
    this._ClearCoatTintTextureEnabled !== e && (this._ClearCoatTintTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get SheenTextureEnabled() {
    return this._SheenTextureEnabled;
  }
  static set SheenTextureEnabled(e) {
    this._SheenTextureEnabled !== e && (this._SheenTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get AnisotropicTextureEnabled() {
    return this._AnisotropicTextureEnabled;
  }
  static set AnisotropicTextureEnabled(e) {
    this._AnisotropicTextureEnabled !== e && (this._AnisotropicTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get ThicknessTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set ThicknessTextureEnabled(e) {
    this._ThicknessTextureEnabled !== e && (this._ThicknessTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get RefractionIntensityTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set RefractionIntensityTextureEnabled(e) {
    this._RefractionIntensityTextureEnabled !== e && (this._RefractionIntensityTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get TranslucencyIntensityTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set TranslucencyIntensityTextureEnabled(e) {
    this._TranslucencyIntensityTextureEnabled !== e && (this._TranslucencyIntensityTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
  static get IridescenceTextureEnabled() {
    return this._IridescenceTextureEnabled;
  }
  static set IridescenceTextureEnabled(e) {
    this._IridescenceTextureEnabled !== e && (this._IridescenceTextureEnabled = e, C.MarkAllMaterialsAsDirty(1));
  }
}
ce._DiffuseTextureEnabled = !0;
ce._DetailTextureEnabled = !0;
ce._AmbientTextureEnabled = !0;
ce._OpacityTextureEnabled = !0;
ce._ReflectionTextureEnabled = !0;
ce._EmissiveTextureEnabled = !0;
ce._SpecularTextureEnabled = !0;
ce._BumpTextureEnabled = !0;
ce._LightmapTextureEnabled = !0;
ce._RefractionTextureEnabled = !0;
ce._ColorGradingTextureEnabled = !0;
ce._FresnelEnabled = !0;
ce._ClearCoatTextureEnabled = !0;
ce._ClearCoatBumpTextureEnabled = !0;
ce._ClearCoatTintTextureEnabled = !0;
ce._SheenTextureEnabled = !0;
ce._AnisotropicTextureEnabled = !0;
ce._ThicknessTextureEnabled = !0;
ce._RefractionIntensityTextureEnabled = !0;
ce._TranslucencyIntensityTextureEnabled = !0;
ce._IridescenceTextureEnabled = !0;
const Ro = "defaultFragmentDeclaration", yo = `uniform vec4 vEyePosition;
uniform vec4 vDiffuseColor;
#ifdef SPECULARTERM
uniform vec4 vSpecularColor;
#endif
uniform vec3 vEmissiveColor;
uniform vec3 vAmbientColor;
uniform float visibility;
#ifdef DIFFUSE
uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY 
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;
uniform vec2 vTangentSpaceParams;
#endif
#ifdef ALPHATEST
uniform float alphaCutOff;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFRACTION
uniform vec4 vRefractionInfos;
#ifndef REFRACTIONMAP_3D
uniform mat4 refractionMatrix;
#endif
#ifdef REFRACTIONFRESNEL
uniform vec4 refractionLeftColor;
uniform vec4 refractionRightColor;
#endif
#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)
uniform vec3 vRefractionPosition;
uniform vec3 vRefractionSize; 
#endif
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;
#endif
#ifdef DIFFUSEFRESNEL
uniform vec4 diffuseLeftColor;
uniform vec4 diffuseRightColor;
#endif
#ifdef OPACITYFRESNEL
uniform vec4 opacityParts;
#endif
#ifdef EMISSIVEFRESNEL
uniform vec4 emissiveLeftColor;
uniform vec4 emissiveRightColor;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)
uniform mat4 reflectionMatrix;
#endif
#ifndef REFLECTIONMAP_SKYBOX
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;
uniform vec3 vReflectionSize; 
#endif
#endif
#ifdef REFLECTIONFRESNEL
uniform vec4 reflectionLeftColor;
uniform vec4 reflectionRightColor;
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#define ADDITIONAL_FRAGMENT_DECLARATION
`;
N.IncludesShadersStore[Ro] = yo;
const Co = "defaultUboDeclaration", Io = `layout(std140,column_major) uniform;
uniform Material
{
vec4 diffuseLeftColor;
vec4 diffuseRightColor;
vec4 opacityParts;
vec4 reflectionLeftColor;
vec4 reflectionRightColor;
vec4 refractionLeftColor;
vec4 refractionRightColor;
vec4 emissiveLeftColor;
vec4 emissiveRightColor;
vec2 vDiffuseInfos;
vec2 vAmbientInfos;
vec2 vOpacityInfos;
vec2 vReflectionInfos;
vec3 vReflectionPosition;
vec3 vReflectionSize;
vec2 vEmissiveInfos;
vec2 vLightmapInfos;
vec2 vSpecularInfos;
vec3 vBumpInfos;
mat4 diffuseMatrix;
mat4 ambientMatrix;
mat4 opacityMatrix;
mat4 reflectionMatrix;
mat4 emissiveMatrix;
mat4 lightmapMatrix;
mat4 specularMatrix;
mat4 bumpMatrix;
vec2 vTangentSpaceParams;
float pointSize;
float alphaCutOff;
mat4 refractionMatrix;
vec4 vRefractionInfos;
vec3 vRefractionPosition;
vec3 vRefractionSize;
vec4 vSpecularColor;
vec3 vEmissiveColor;
vec4 vDiffuseColor;
vec3 vAmbientColor;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
N.IncludesShadersStore[Co] = Io;
const Po = "prePassDeclaration", Do = `#ifdef PREPASS
#extension GL_EXT_draw_buffers : require
layout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;
#ifdef PREPASS_DEPTH
varying highp vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
varying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;
#endif
#endif
`;
N.IncludesShadersStore[Po] = Do;
const Fo = "oitDeclaration", wo = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#extension GL_EXT_draw_buffers : require
layout(location=0) out vec2 depth; 
layout(location=1) out vec4 frontColor;
layout(location=2) out vec4 backColor;
#define MAX_DEPTH 99999.0
highp vec4 gl_FragColor;
uniform sampler2D oitDepthSampler;
uniform sampler2D oitFrontColorSampler;
#endif
`;
N.IncludesShadersStore[Fo] = wo;
const Oo = "mainUVVaryingDeclaration", Lo = `#ifdef MAINUV{X}
varying vec2 vMainUV{X};
#endif
`;
N.IncludesShadersStore[Oo] = Lo;
const No = "lightFragmentDeclaration", Bo = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};
uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float cascadeBlendFactor{X};
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
uniform highp sampler2DArray depthSampler{X};
uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);
vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X};
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};
uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};
uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};
uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};
uniform sampler2D projectionLightSampler{X};
#endif
#endif
`;
N.IncludesShadersStore[No] = Bo;
const Uo = "lightUboDeclaration", ko = `#ifdef LIGHT{X}
uniform Light{X}
{
vec4 vLightData;
vec4 vLightDiffuse;
vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;
vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;
vec2 depthValues;
} light{X};
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};
uniform sampler2D projectionLightSampler{X};
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float cascadeBlendFactor{X};
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
uniform highp sampler2DArray depthSampler{X};
uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);
vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X}; 
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};
uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
N.IncludesShadersStore[Uo] = ko;
const Vo = "lightsFragmentFunctions", Wo = `struct lightingInfo
{
vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef NDOTL
float ndl;
#endif
};
lightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {
lightingInfo result;
vec3 lightVectorW;
float attenuation=1.0;
if (lightData.w==0.)
{
vec3 direction=lightData.xyz-vPositionW;
attenuation=max(0.,1.0-length(direction)/range);
lightVectorW=normalize(direction);
}
else
{
lightVectorW=normalize(-lightData.xyz);
}
float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);
float specComp=max(0.,dot(vNormal,angleW));
specComp=pow(specComp,max(1.,glossiness));
result.specular=specComp*specularColor*attenuation;
#endif
return result;
}
lightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {
lightingInfo result;
vec3 direction=lightData.xyz-vPositionW;
vec3 lightVectorW=normalize(direction);
float attenuation=max(0.,1.0-length(direction)/range);
float cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));
if (cosAngle>=lightDirection.w)
{
cosAngle=max(0.,pow(cosAngle,lightData.w));
attenuation*=cosAngle;
float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);
float specComp=max(0.,dot(vNormal,angleW));
specComp=pow(specComp,max(1.,glossiness));
result.specular=specComp*specularColor*attenuation;
#endif
return result;
}
result.diffuse=vec3(0.);
#ifdef SPECULARTERM
result.specular=vec3(0.);
#endif
#ifdef NDOTL
result.ndl=0.;
#endif
return result;
}
lightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {
lightingInfo result;
float ndl=dot(vNormal,lightData.xyz)*0.5+0.5;
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=mix(groundColor,diffuseColor,ndl);
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightData.xyz);
float specComp=max(0.,dot(vNormal,angleW));
specComp=pow(specComp,max(1.,glossiness));
result.specular=specComp*specularColor;
#endif
return result;
}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){
vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);
strq/=strq.w;
vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;
return textureColor;
}`;
N.IncludesShadersStore[Vo] = Wo;
const zo = "shadowsFragmentFunctions", Go = `#ifdef SHADOWS
#ifndef SHADOWFLOAT
float unpack(vec4 color)
{
const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);
return dot(color,bit_shift);
}
#endif
float computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)
{
float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));
return mix(value,1.0,mask);
}
#define inline
float computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
depth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadow=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadow=textureCube(shadowSampler,directionToLight).x;
#endif
return depth>shadow ? darkness : 1.0;
}
#define inline
float computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
depth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
float visibility=1.;
vec3 poissonDisk[4];
poissonDisk[0]=vec3(-1.0,1.0,-1.0);
poissonDisk[1]=vec3(1.0,-1.0,-1.0);
poissonDisk[2]=vec3(-1.0,-1.0,-1.0);
poissonDisk[3]=vec3(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;
#else
if (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;
if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;
if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;
if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;
#endif
return min(1.0,visibility+darkness);
}
#define inline
float computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
float shadowPixelDepth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness); 
return esm;
}
#define inline
float computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
float shadowPixelDepth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);
return esm;
}
#if defined(WEBGL2) || defined(WEBGPU)
#define inline
float computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
vec3 uvLayer=vec3(uv.x,uv.y,layer);
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uvLayer));
#else
float shadow=texture2D(shadowSampler,uvLayer).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;
}
#endif
#define inline
float computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uv));
#else
float shadow=texture2D(shadowSampler,uv).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;
}
}
#define inline
float computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
float visibility=1.;
vec2 poissonDisk[4];
poissonDisk[0]=vec2(-0.94201624,-0.39906216);
poissonDisk[1]=vec2(0.94558609,-0.76890725);
poissonDisk[2]=vec2(-0.094184101,-0.92938870);
poissonDisk[3]=vec2(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<shadowPixelDepth) visibility-=0.25;
if (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<shadowPixelDepth) visibility-=0.25;
if (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<shadowPixelDepth) visibility-=0.25;
if (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<shadowPixelDepth) visibility-=0.25;
#else
if (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<shadowPixelDepth) visibility-=0.25;
if (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<shadowPixelDepth) visibility-=0.25;
if (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<shadowPixelDepth) visibility-=0.25;
if (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<shadowPixelDepth) visibility-=0.25;
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(texture2D(shadowSampler,uv));
#else
float shadowMapSample=texture2D(shadowSampler,uv).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);
return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(texture2D(shadowSampler,uv));
#else
float shadowMapSample=texture2D(shadowSampler,uv).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);
return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);
}
}
#ifdef IS_NDC_HALF_ZRANGE
#define ZINCLIP clipSpace.z
#else
#define ZINCLIP uvDepth.z
#endif
#if defined(WEBGL2) || defined(WEBGPU)
#define GREATEST_LESS_THAN_ONE 0.99999994
#define inline
float computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);
float shadow=texture2D(shadowSampler,uvDepthLayer);
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
#define inline
float computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;
vec2 uvw1=1.+2.*st;
vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;
vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));
shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));
shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));
shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));
shadow=shadow/16.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
#define inline
float computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;
vec2 uvw1=vec2(7.);
vec2 uvw2=1.+3.*st;
vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;
vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));
shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));
shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));
shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));
shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));
shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));
shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));
shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));
shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));
shadow=shadow/144.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
#define inline
float computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
float shadow=texture2D(shadowSampler,uvDepth);
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;
vec2 uvw1=1.+2.*st;
vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;
vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));
shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));
shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));
shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));
shadow=shadow/16.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;
vec2 uvw1=vec2(7.);
vec2 uvw2=1.+3.*st;
vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;
vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));
shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));
shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z));
shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));
shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));
shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z));
shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z));
shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z));
shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z));
shadow=shadow/144.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
const vec3 PoissonSamplers32[64]=vec3[64](
vec3(0.06407013,0.05409927,0.),
vec3(0.7366577,0.5789394,0.),
vec3(-0.6270542,-0.5320278,0.),
vec3(-0.4096107,0.8411095,0.),
vec3(0.6849564,-0.4990818,0.),
vec3(-0.874181,-0.04579735,0.),
vec3(0.9989998,0.0009880066,0.),
vec3(-0.004920578,-0.9151649,0.),
vec3(0.1805763,0.9747483,0.),
vec3(-0.2138451,0.2635818,0.),
vec3(0.109845,0.3884785,0.),
vec3(0.06876755,-0.3581074,0.),
vec3(0.374073,-0.7661266,0.),
vec3(0.3079132,-0.1216763,0.),
vec3(-0.3794335,-0.8271583,0.),
vec3(-0.203878,-0.07715034,0.),
vec3(0.5912697,0.1469799,0.),
vec3(-0.88069,0.3031784,0.),
vec3(0.5040108,0.8283722,0.),
vec3(-0.5844124,0.5494877,0.),
vec3(0.6017799,-0.1726654,0.),
vec3(-0.5554981,0.1559997,0.),
vec3(-0.3016369,-0.3900928,0.),
vec3(-0.5550632,-0.1723762,0.),
vec3(0.925029,0.2995041,0.),
vec3(-0.2473137,0.5538505,0.),
vec3(0.9183037,-0.2862392,0.),
vec3(0.2469421,0.6718712,0.),
vec3(0.3916397,-0.4328209,0.),
vec3(-0.03576927,-0.6220032,0.),
vec3(-0.04661255,0.7995201,0.),
vec3(0.4402924,0.3640312,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.)
);
const vec3 PoissonSamplers64[64]=vec3[64](
vec3(-0.613392,0.617481,0.),
vec3(0.170019,-0.040254,0.),
vec3(-0.299417,0.791925,0.),
vec3(0.645680,0.493210,0.),
vec3(-0.651784,0.717887,0.),
vec3(0.421003,0.027070,0.),
vec3(-0.817194,-0.271096,0.),
vec3(-0.705374,-0.668203,0.),
vec3(0.977050,-0.108615,0.),
vec3(0.063326,0.142369,0.),
vec3(0.203528,0.214331,0.),
vec3(-0.667531,0.326090,0.),
vec3(-0.098422,-0.295755,0.),
vec3(-0.885922,0.215369,0.),
vec3(0.566637,0.605213,0.),
vec3(0.039766,-0.396100,0.),
vec3(0.751946,0.453352,0.),
vec3(0.078707,-0.715323,0.),
vec3(-0.075838,-0.529344,0.),
vec3(0.724479,-0.580798,0.),
vec3(0.222999,-0.215125,0.),
vec3(-0.467574,-0.405438,0.),
vec3(-0.248268,-0.814753,0.),
vec3(0.354411,-0.887570,0.),
vec3(0.175817,0.382366,0.),
vec3(0.487472,-0.063082,0.),
vec3(-0.084078,0.898312,0.),
vec3(0.488876,-0.783441,0.),
vec3(0.470016,0.217933,0.),
vec3(-0.696890,-0.549791,0.),
vec3(-0.149693,0.605762,0.),
vec3(0.034211,0.979980,0.),
vec3(0.503098,-0.308878,0.),
vec3(-0.016205,-0.872921,0.),
vec3(0.385784,-0.393902,0.),
vec3(-0.146886,-0.859249,0.),
vec3(0.643361,0.164098,0.),
vec3(0.634388,-0.049471,0.),
vec3(-0.688894,0.007843,0.),
vec3(0.464034,-0.188818,0.),
vec3(-0.440840,0.137486,0.),
vec3(0.364483,0.511704,0.),
vec3(0.034028,0.325968,0.),
vec3(0.099094,-0.308023,0.),
vec3(0.693960,-0.366253,0.),
vec3(0.678884,-0.204688,0.),
vec3(0.001801,0.780328,0.),
vec3(0.145177,-0.898984,0.),
vec3(0.062655,-0.611866,0.),
vec3(0.315226,-0.604297,0.),
vec3(-0.780145,0.486251,0.),
vec3(-0.371868,0.882138,0.),
vec3(0.200476,0.494430,0.),
vec3(-0.494552,-0.711051,0.),
vec3(0.612476,0.705252,0.),
vec3(-0.578845,-0.768792,0.),
vec3(-0.772454,-0.090976,0.),
vec3(0.504440,0.372295,0.),
vec3(0.155736,0.065157,0.),
vec3(0.391522,0.849605,0.),
vec3(-0.620106,-0.328104,0.),
vec3(0.789239,-0.419965,0.),
vec3(-0.545396,0.538133,0.),
vec3(-0.178564,-0.596057,0.)
);
#define inline
float computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);
float blockerDepth=0.0;
float sumBlockerDepth=0.0;
float numBlocker=0.0;
for (int i=0; i<searchTapCount; i ++) {
blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;
if (blockerDepth<depthMetric) {
sumBlockerDepth+=blockerDepth;
numBlocker++;
}
}
if (numBlocker<1.0) {
return 1.0;
}
else
{
float avgBlockerDepth=sumBlockerDepth/numBlocker;
float AAOffset=shadowMapSizeInverse*10.;
float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);
vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);
float random=getRand(vPositionFromLight.xy);
float rotationAngle=random*3.1415926;
vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));
float shadow=0.;
for (int i=0; i<pcfTapCount; i++) {
vec4 offset=vec4(poissonSamplers[i],0.);
offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);
shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);
}
shadow/=float(pcfTapCount);
shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
float blockerDepth=0.0;
float sumBlockerDepth=0.0;
float numBlocker=0.0;
for (int i=0; i<searchTapCount; i ++) {
blockerDepth=texture2D(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy)).r;
if (blockerDepth<depthMetric) {
sumBlockerDepth+=blockerDepth;
numBlocker++;
}
}
if (numBlocker<1.0) {
return 1.0;
}
else
{
float avgBlockerDepth=sumBlockerDepth/numBlocker;
float AAOffset=shadowMapSizeInverse*10.;
float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);
float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;
float random=getRand(vPositionFromLight.xy);
float rotationAngle=random*3.1415926;
vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));
float shadow=0.;
for (int i=0; i<pcfTapCount; i++) {
vec3 offset=poissonSamplers[i];
offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);
shadow+=texture2D(shadowSampler,uvDepth+offset*filterRadius);
}
shadow/=float(pcfTapCount);
shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
}
#define inline
float computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{
return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);
}
#define inline
float computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{
return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);
}
#define inline
float computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{
return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);
}
#define inline
float computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);
}
#define inline
float computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);
}
#define inline
float computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);
}
#endif
#endif
`;
N.IncludesShadersStore[zo] = Go;
const Xo = "samplerFragmentDeclaration", Ho = `#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
uniform sampler2D _SAMPLERNAME_Sampler;
#endif
`;
N.IncludesShadersStore[Xo] = Ho;
const Ko = "fresnelFunction", Yo = `#ifdef FRESNEL
float computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)
{
float fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);
return clamp(fresnelTerm,0.,1.);
}
#endif
`;
N.IncludesShadersStore[Ko] = Yo;
const Zo = "reflectionFunction", qo = `vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{
float lon=atan(direction.z,direction.x);
float lat=acos(direction.y);
vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;
float s=sphereCoords.x*0.5+0.5;
float t=sphereCoords.y;
return vec3(s,t,0); 
}
vec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{
float lon=atan(direction.z,direction.x);
float lat=acos(direction.y);
vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;
float s=sphereCoords.x*0.5+0.5;
float t=sphereCoords.y;
return vec3(1.0-s,t,0); 
}
vec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{
vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);
vec3 r=normalize(reflect(cameraToVertex,worldNormal));
r=vec3(reflectionMatrix*vec4(r,0));
float lon=atan(r.z,r.x);
float lat=acos(r.y);
vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;
float s=sphereCoords.x*0.5+0.5;
float t=sphereCoords.y;
return vec3(s,t,0);
}
vec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)
{
vec3 viewDir=normalize(vec3(view*worldPos));
vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));
vec3 r=reflect(viewDir,viewNormal);
r=vec3(reflectionMatrix*vec4(r,0));
r.z=r.z-1.0;
float m=2.0*length(r);
return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);
}
vec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{
vec3 viewDir=worldPos.xyz-eyePosition;
vec3 coords=normalize(reflect(viewDir,worldNormal));
return vec3(reflectionMatrix*vec4(coords,1));
}
vec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{
vec3 viewDir=normalize(worldPos.xyz-eyePosition);
vec3 coords=reflect(viewDir,worldNormal);
coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;
}
vec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)
{
vec3 viewDir=normalize(worldPos.xyz-eyePosition);
vec3 coords=reflect(viewDir,worldNormal);
coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);
coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;
}
vec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)
{
return vec3(reflectionMatrix*(view*worldPos));
}
vec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)
{
return vec3(reflectionMatrix*vec4(positionW,1.));
}
#ifdef REFLECTION
vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);
return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);
return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(vPositionUVW,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3(0,0,0);
#endif
}
#endif
`;
N.IncludesShadersStore[Zo] = qo;
const jo = "imageProcessingDeclaration", Qo = `#ifdef EXPOSURE
uniform float exposureLinear;
#endif
#ifdef CONTRAST
uniform float contrast;
#endif
#if defined(VIGNETTE) || defined(DITHER)
uniform vec2 vInverseScreenSize;
#endif
#ifdef VIGNETTE
uniform vec4 vignetteSettings1;
uniform vec4 vignetteSettings2;
#endif
#ifdef COLORCURVES
uniform vec4 vCameraColorCurveNegative;
uniform vec4 vCameraColorCurveNeutral;
uniform vec4 vCameraColorCurvePositive;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
uniform highp sampler3D txColorTransform;
#else
uniform sampler2D txColorTransform;
#endif
uniform vec4 colorTransformSettings;
#endif
#ifdef DITHER
uniform float ditherIntensity;
#endif
`;
N.IncludesShadersStore[jo] = Qo;
const $o = "imageProcessingFunctions", Jo = `#if defined(COLORGRADING) && !defined(COLORGRADING3D)
/** 
* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.
* sampler3dSetting.x=textureOffset (0.5/textureSize).
* sampler3dSetting.y=textureSize.
*/
#define inline
vec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)
{
float sliceSize=2.0*sampler3dSetting.x; 
#ifdef SAMPLER3DGREENDEPTH
float sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;
#else
float sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;
#endif
float sliceInteger=floor(sliceContinuous);
float sliceFraction=sliceContinuous-sliceInteger;
#ifdef SAMPLER3DGREENDEPTH
vec2 sliceUV=color.rb;
#else
vec2 sliceUV=color.rg;
#endif
sliceUV.x*=sliceSize;
sliceUV.x+=sliceInteger*sliceSize;
sliceUV=saturate(sliceUV);
vec4 slice0Color=texture2D(colorTransform,sliceUV);
sliceUV.x+=sliceSize;
sliceUV=saturate(sliceUV);
vec4 slice1Color=texture2D(colorTransform,sliceUV);
vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);
#ifdef SAMPLER3DBGRMAP
color.rgb=result.rgb;
#else
color.rgb=result.bgr;
#endif
return color;
}
#endif
#ifdef TONEMAPPING_ACES
const mat3 ACESInputMat=mat3(
vec3(0.59719,0.07600,0.02840),
vec3(0.35458,0.90834,0.13383),
vec3(0.04823,0.01566,0.83777)
);
const mat3 ACESOutputMat=mat3(
vec3( 1.60475,-0.10208,-0.00327),
vec3(-0.53108, 1.10813,-0.07276),
vec3(-0.07367,-0.00605, 1.07602)
);
vec3 RRTAndODTFit(vec3 v)
{
vec3 a=v*(v+0.0245786)-0.000090537;
vec3 b=v*(0.983729*v+0.4329510)+0.238081;
return a/b;
}
vec3 ACESFitted(vec3 color)
{
color=ACESInputMat*color;
color=RRTAndODTFit(color);
color=ACESOutputMat*color;
color=saturate(color);
return color;
}
#endif
vec4 applyImageProcessing(vec4 result) {
#ifdef EXPOSURE
result.rgb*=exposureLinear;
#endif
#ifdef VIGNETTE
vec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;
viewportXY=viewportXY*2.0-1.0;
vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);
float vignetteTerm=dot(vignetteXY1,vignetteXY1);
float vignette=pow(vignetteTerm,vignetteSettings2.w);
vec3 vignetteColor=vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
vec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);
result.rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
result.rgb=mix(vignetteColor,result.rgb,vignette);
#endif
#endif
#ifdef TONEMAPPING
#ifdef TONEMAPPING_ACES
result.rgb=ACESFitted(result.rgb);
#else
const float tonemappingCalibration=1.590579;
result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);
#endif
#endif
result.rgb=toGammaSpace(result.rgb);
result.rgb=saturate(result.rgb);
#ifdef CONTRAST
vec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);
if (contrast<1.0) {
result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);
} else {
result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);
}
#endif
#ifdef COLORGRADING
vec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;
#ifdef COLORGRADING3D
vec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;
#else
vec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;
#endif
result.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);
#endif
#ifdef COLORCURVES
float luma=getLuminance(result.rgb);
vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));
vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;
result.rgb*=colorCurve.rgb;
result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);
#endif
#ifdef DITHER
float rand=getRand(gl_FragCoord.xy*vInverseScreenSize);
float dither=mix(-ditherIntensity,ditherIntensity,rand);
result.rgb=saturate(result.rgb+vec3(dither));
#endif
return result;
}`;
N.IncludesShadersStore[$o] = Jo;
const eh = "bumpFragmentMainFunctions", th = `#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat4 normalMatrix;
#endif
vec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)
{
#ifdef NORMALXYSCALE
normal=normalize(normal*vec3(scale,scale,1.0));
#endif
return normalize(cotangentFrame*normal);
}
vec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)
{
return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);
}
mat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)
{
vec3 dp1=dFdx(p);
vec3 dp2=dFdy(p);
vec2 duv1=dFdx(uv);
vec2 duv2=dFdy(uv);
vec3 dp2perp=cross(dp2,normal);
vec3 dp1perp=cross(normal,dp1);
vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;
vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;
tangent*=tangentSpaceParams.x;
bitangent*=tangentSpaceParams.y;
float invmax=inversesqrt(max(dot(tangent,tangent),dot(bitangent,bitangent)));
return mat3(tangent*invmax,bitangent*invmax,normal);
}
#endif
`;
N.IncludesShadersStore[eh] = th;
const ih = "bumpFragmentFunctions", sh = `#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const float minSamples=4.;
const float maxSamples=15.;
const int iMaxSamples=15;
vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {
float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;
parallaxLimit*=parallaxScale;
vec2 vOffsetDir=normalize(vViewDirCoT.xy);
vec2 vMaxOffset=vOffsetDir*parallaxLimit;
float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));
float stepSize=1.0/numSamples;
float currRayHeight=1.0;
vec2 vCurrOffset=vec2(0,0);
vec2 vLastOffset=vec2(0,0);
float lastSampledHeight=1.0;
float currSampledHeight=1.0;
for (int i=0; i<iMaxSamples; i++)
{
currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;
if (currSampledHeight>currRayHeight)
{
float delta1=currSampledHeight-currRayHeight;
float delta2=(currRayHeight+stepSize)-lastSampledHeight;
float ratio=delta1/(delta1+delta2);
vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;
break;
}
else
{
currRayHeight-=stepSize;
vLastOffset=vCurrOffset;
vCurrOffset+=stepSize*vMaxOffset;
lastSampledHeight=currSampledHeight;
}
}
return vCurrOffset;
}
vec2 parallaxOffset(vec3 viewDir,float heightScale)
{
float height=texture2D(bumpSampler,vBumpUV).w;
vec2 texCoordOffset=heightScale*viewDir.xy*height;
return -texCoordOffset;
}
#endif
`;
N.IncludesShadersStore[ih] = sh;
const rh = "logDepthDeclaration", nh = `#ifdef LOGARITHMICDEPTH
uniform float logarithmicDepthConstant;
varying float vFragmentDepth;
#endif
`;
N.IncludesShadersStore[rh] = nh;
const ah = "fogFragmentDeclaration", oh = `#ifdef FOG
#define FOGMODE_NONE 0.
#define FOGMODE_EXP 1.
#define FOGMODE_EXP2 2.
#define FOGMODE_LINEAR 3.
#define E 2.71828
uniform vec4 vFogInfos;
uniform vec3 vFogColor;
varying vec3 vFogDistance;
float CalcFogFactor()
{
float fogCoeff=1.0;
float fogStart=vFogInfos.y;
float fogEnd=vFogInfos.z;
float fogDensity=vFogInfos.w;
float fogDistance=length(vFogDistance);
if (FOGMODE_LINEAR==vFogInfos.x)
{
fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);
}
else if (FOGMODE_EXP==vFogInfos.x)
{
fogCoeff=1.0/pow(E,fogDistance*fogDensity);
}
else if (FOGMODE_EXP2==vFogInfos.x)
{
fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);
}
return clamp(fogCoeff,0.0,1.0);
}
#endif
`;
N.IncludesShadersStore[ah] = oh;
const hh = "bumpFragment", lh = `vec2 uvOffset=vec2(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
float normalScale=1.0;
#elif defined(BUMP)
float normalScale=vBumpInfos.y;
#else
float normalScale=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#elif defined(BUMP)
vec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;
mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);
#else
vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;
mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#else
vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;
mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));
#endif
#endif
#ifdef PARALLAX
mat3 invTBN=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
vec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);
vec2 detailNormalRG=detailColor.wy*2.0-1.0;
float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));
vec3 detailNormal=vec3(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
normalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);
normalW=normalize(mat3(normalMatrix)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);
#else
vec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal.xy*=vDetailInfos.z;
vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal.xy*=vDetailInfos.z;
bumpNormal+=vec3(0.0,0.0,1.0);
detailNormal*=vec3(-1.0,-1.0,1.0);
vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal.xy*=vDetailInfos.z;
normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);
#endif
`;
N.IncludesShadersStore[hh] = lh;
const ch = "depthPrePass", uh = `#ifdef DEPTHPREPASS
gl_FragColor=vec4(0.,0.,0.,1.0);
return;
#endif
`;
N.IncludesShadersStore[ch] = uh;
const fh = "lightFragment", dh = `#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
#ifdef PBR
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#ifdef HEMILIGHT{X}
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);
#elif defined(SS_TRANSLUCENCY)
info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);
#else
info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);
#endif
#ifdef SPECULARTERM
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#endif
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);
info.diffuse*=absorption;
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) 
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;
#else
diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {
index{X}=i;
break;
}
}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
float frustumLength=frustumLengths{X}[index{X}];
float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};
if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{
index{X}+=1;
float nextShadow=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;
shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else 
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`;
N.IncludesShadersStore[fh] = dh;
const _h = "logDepthFragment", gh = `#ifdef LOGARITHMICDEPTH
gl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;
#endif
`;
N.IncludesShadersStore[_h] = gh;
const ph = "fogFragment", mh = `#ifdef FOG
float fog=CalcFogFactor();
#ifdef PBR
fog=toLinearSpace(fog);
#endif
color.rgb=mix(vFogColor,color.rgb,fog);
#endif
`;
N.IncludesShadersStore[ph] = mh;
const Eh = "oitFragment", Th = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
float fragDepth=gl_FragCoord.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
uint halfFloat=packHalf2x16(vec2(fragDepth));
vec2 full=unpackHalf2x16(halfFloat);
fragDepth=full.x;
#endif
ivec2 fragCoord=ivec2(gl_FragCoord.xy);
vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;
vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);
depth.rg=vec2(-MAX_DEPTH);
frontColor=lastFrontColor;
backColor=vec4(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
float furthestDepth=-lastDepth.x;
float nearestDepth=lastDepth.y;
#else
float nearestDepth=-lastDepth.x;
float furthestDepth=lastDepth.y;
#endif
float alphaMultiplier=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return;
}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
depth.rg=vec2(-fragDepth,fragDepth);
return;
}
#endif
`;
N.IncludesShadersStore[Eh] = Th;
const Sh = "defaultPixelShader", bh = `#include<__decl__defaultFragment>
#if defined(BUMP) || !defined(NORMAL)
#extension GL_OES_standard_derivatives : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
#include<oitDeclaration>
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#define RECIPROCAL_PI2 0.15915494
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)
varying vec4 vColor;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#ifdef REFRACTION
#ifdef REFRACTIONMAP_3D
uniform samplerCube refractionCubeSampler;
#else
uniform sampler2D refraction2DSampler;
#endif
#endif
#if defined(SPECULARTERM)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)
#endif
#include<fresnelFunction>
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
uniform samplerCube reflectionCubeSampler;
#else
uniform sampler2D reflection2DSampler;
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#include<reflectionFunction>
#endif
#include<imageProcessingDeclaration>
#include<imageProcessingFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
vec4 baseColor=vec4(1.,1.,1.,1.);
vec3 diffuseColor=vDiffuseColor.rgb;
float alpha=vDiffuseColor.a;
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));
#endif
#include<bumpFragment>
#ifdef TWOSIDEDLIGHTING
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
#ifdef DIFFUSE
baseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);
#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)
if (baseColor.a<alphaCutOff)
discard;
#endif
#ifdef ALPHAFROMDIFFUSE
alpha*=baseColor.a;
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
baseColor.rgb*=vDiffuseInfos.y;
#endif
#include<depthPrePass>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)
baseColor.rgb*=vColor.rgb;
#endif
#ifdef DETAIL
baseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);
#endif
#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE
vec3 baseAmbientColor=vec3(1.,1.,1.);
#ifdef AMBIENT
baseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;
#endif
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
#ifdef SPECULARTERM
float glossiness=vSpecularColor.a;
vec3 specularColor=vSpecularColor.rgb;
#ifdef SPECULAR
vec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);
specularColor=specularMapColor.rgb;
#ifdef GLOSSINESS
glossiness=glossiness*specularMapColor.a;
#endif
#endif
#else
float glossiness=0.;
#endif
vec3 diffuseBase=vec3(0.,0.,0.);
lightingInfo info;
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
float shadow=1.;
#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
#include<lightFragment>[0..maxSimultaneousLights]
vec4 refractionColor=vec4(0.,0.,0.,1.);
#ifdef REFRACTION
vec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));
#ifdef REFRACTIONMAP_3D
#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;
if (dot(refractionVector,viewDirectionW)<1.0) {
refractionColor=textureCube(refractionCubeSampler,refractionVector);
}
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));
vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;
refractionCoords.y=1.0-refractionCoords.y;
refractionColor=texture2D(refraction2DSampler,refractionCoords);
#endif
#ifdef RGBDREFRACTION
refractionColor.rgb=fromRGBD(refractionColor);
#endif
#ifdef IS_REFRACTION_LINEAR
refractionColor.rgb=toGammaSpace(refractionColor.rgb);
#endif
refractionColor.rgb*=vRefractionInfos.x;
#endif
vec4 reflectionColor=vec4(0.,0.,0.,1.);
#ifdef REFLECTION
vec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
vReflectionUVW.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
#ifdef ROUGHNESS
float bias=vReflectionInfos.y;
#ifdef SPECULARTERM
#ifdef SPECULAR
#ifdef GLOSSINESS
bias*=(1.0-specularMapColor.a);
#endif
#endif
#endif
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);
#else
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);
#endif
#else
vec2 coords=vReflectionUVW.xy;
#ifdef REFLECTIONMAP_PROJECTION
coords/=vReflectionUVW.z;
#endif
coords.y=1.0-coords.y;
reflectionColor=texture2D(reflection2DSampler,coords);
#endif
#ifdef RGBDREFLECTION
reflectionColor.rgb=fromRGBD(reflectionColor);
#endif
#ifdef IS_REFLECTION_LINEAR
reflectionColor.rgb=toGammaSpace(reflectionColor.rgb);
#endif
reflectionColor.rgb*=vReflectionInfos.x;
#ifdef REFLECTIONFRESNEL
float reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);
#ifdef REFLECTIONFRESNELFROMSPECULAR
#ifdef SPECULARTERM
reflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#endif
#endif
#ifdef REFRACTIONFRESNEL
float refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);
refractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#ifdef OPACITYRGB
opacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);
alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;
#else
alpha*=opacityMap.a*vOpacityInfos.y;
#endif
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR)
alpha*=vColor.a;
#endif
#ifdef OPACITYFRESNEL
float opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);
alpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;
#endif
#ifdef ALPHATEST
#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS
if (alpha<alphaCutOff)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
vec3 emissiveColor=vEmissiveColor;
#ifdef EMISSIVE
emissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;
#endif
#ifdef EMISSIVEFRESNEL
float emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);
emissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;
#endif
#ifdef DIFFUSEFRESNEL
float diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);
diffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;
#endif
#ifdef EMISSIVEASILLUMINATION
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
#ifdef LINKEMISSIVEWITHDIFFUSE
vec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#endif
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase*specularColor;
#ifdef SPECULAROVERALPHA
alpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#else
vec3 finalSpecular=vec3(0.0);
#endif
#ifdef REFLECTIONOVERALPHA
alpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#ifdef EMISSIVEASILLUMINATION
vec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);
#else
vec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);
#endif
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
color.rgb*=lightmapColor.rgb;
#else
color.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
#define CUSTOM_FRAGMENT_BEFORE_FOG
color.rgb=max(color.rgb,0.);
#include<logDepthFragment>
#include<fogFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
color.rgb=toLinearSpace(color.rgb);
#else
#ifdef IMAGEPROCESSING
color.rgb=toLinearSpace(color.rgb);
color=applyImageProcessing(color);
#endif
#endif
color.a*=visibility;
#ifdef PREMULTIPLYALPHA
color.rgb*=color.a;
#endif
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
float writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;
gl_FragData[0]=color; 
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;
vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;
vec2 velocity=abs(a-b);
velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;
gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_IRRADIANCE
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_NORMAL
gl_FragData[PREPASS_NORMAL_INDEX]=vec4((view*vec4(normalW,0.0)).rgb,writeGeometryInfo); 
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_REFLECTIVITY
#if defined(SPECULARTERM)
#if defined(SPECULAR)
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularMapColor)*writeGeometryInfo; 
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularColor,1.0)*writeGeometryInfo;
#endif
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=color;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {
frontColor.rgb+=color.rgb*color.a*alphaMultiplier;
frontColor.a=1.0-alphaMultiplier*(1.0-color.a);
} else {
backColor+=color;
}
#endif
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
N.ShadersStore[Sh] = bh;
const xh = "defaultVertexDeclaration", vh = `uniform mat4 viewProjection;
uniform mat4 view;
#ifdef DIFFUSE
uniform mat4 diffuseMatrix;
uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;
uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
uniform mat4 lightmapMatrix;
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;
uniform mat4 specularMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;
uniform mat4 bumpMatrix;
#endif
#ifdef REFLECTION
uniform mat4 reflectionMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
uniform mat4 detailMatrix;
#endif
#define ADDITIONAL_VERTEX_DECLARATION
`;
N.IncludesShadersStore[xh] = vh;
const Mh = "uvAttributeDeclaration", Ah = `#ifdef UV{X}
attribute vec2 uv{X};
#endif
`;
N.IncludesShadersStore[Mh] = Ah;
const Rh = "prePassVertexDeclaration", yh = `#ifdef PREPASS
#ifdef PREPASS_DEPTH
varying vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
uniform mat4 previousViewProjection;
varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;
#endif
#endif
`;
N.IncludesShadersStore[Rh] = yh;
const Ch = "samplerVertexDeclaration", Ih = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying vec2 v_VARYINGNAME_UV;
#endif
`;
N.IncludesShadersStore[Ch] = Ih;
const Ph = "bumpVertexDeclaration", Dh = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#endif
`;
N.IncludesShadersStore[Ph] = Dh;
const Fh = "fogVertexDeclaration", wh = `#ifdef FOG
varying vec3 vFogDistance;
#endif
`;
N.IncludesShadersStore[Fh] = wh;
const Oh = "lightVxFragmentDeclaration", Lh = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};
uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};
uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};
uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#endif
`;
N.IncludesShadersStore[Oh] = Lh;
const Nh = "lightVxUboDeclaration", Bh = `#ifdef LIGHT{X}
uniform Light{X}
{
vec4 vLightData;
vec4 vLightDiffuse;
vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;
vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;
vec2 depthValues;
} light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
N.IncludesShadersStore[Nh] = Bh;
const Uh = "prePassVertex", kh = `#ifdef PREPASS_DEPTH
vViewPos=(view*worldPos).rgb;
#endif
#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;
previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
`;
N.IncludesShadersStore[Uh] = kh;
const Vh = "uvVariableDeclaration", Wh = `#if !defined(UV{X}) && defined(MAINUV{X})
vec2 uv{X}=vec2(0.,0.);
#endif
#ifdef MAINUV{X}
vMainUV{X}=uv{X};
#endif
`;
N.IncludesShadersStore[Vh] = Wh;
const zh = "samplerVertexImplementation", Gh = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (v_INFONAME_==0.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));
}
#ifdef UV2
else if (v_INFONAME_==1.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));
}
#endif
#ifdef UV3
else if (v_INFONAME_==2.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));
}
#endif
#ifdef UV4
else if (v_INFONAME_==3.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));
}
#endif
#ifdef UV5
else if (v_INFONAME_==4.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));
}
#endif
#ifdef UV6
else if (v_INFONAME_==5.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));
}
#endif
#endif
`;
N.IncludesShadersStore[zh] = Gh;
const Xh = "bumpVertex", Hh = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
vec3 tbnNormal=normalize(normalUpdated);
vec3 tbnTangent=normalize(tangentUpdated.xyz);
vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;
vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);
#endif
#endif
`;
N.IncludesShadersStore[Xh] = Hh;
const Kh = "fogVertex", Yh = `#ifdef FOG
vFogDistance=(view*worldPos).xyz;
#endif
`;
N.IncludesShadersStore[Kh] = Yh;
const Zh = "shadowsVertex", qh = `#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vPositionFromCamera{X}=view*worldPos;
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {
vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
}
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vPositionFromLight{X}=lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`;
N.IncludesShadersStore[Zh] = qh;
const jh = "vertexColorMixing", Qh = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)
vColor=vec4(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vColor*=color;
#else
vColor.rgb*=color.rgb;
#endif
#endif
#ifdef INSTANCESCOLOR
vColor*=instanceColor;
#endif
#endif
`;
N.IncludesShadersStore[jh] = Qh;
const $h = "pointCloudVertex", Jh = `#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
`;
N.IncludesShadersStore[$h] = Jh;
const el = "logDepthVertex", tl = `#ifdef LOGARITHMICDEPTH
vFragmentDepth=1.0+gl_Position.w;
gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;
#endif
`;
N.IncludesShadersStore[el] = tl;
const il = "defaultVertexShader", sl = `#include<__decl__defaultVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<mainUVVaryingDeclaration>[1..7]
#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#if defined(SPECULARTERM)
#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)
#endif
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));
vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {
gl_Position=viewProjection*worldPos;
} else {
gl_Position=viewProjectionR*worldPos;
}
#else
gl_Position=viewProjection*worldPos;
#endif
vPositionW=vec3(worldPos);
#include<prePassVertex>
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#include<uvVariableDeclaration>[2..7]
#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#if defined(SPECULARTERM)
#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)
#endif
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#include<pointCloudVertex>
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`;
N.ShadersStore[il] = sl;
class Yt {
  constructor(e) {
    this._plugins = [], this._activePlugins = [], this._activePluginsForExtraEvents = [], this._material = e, this._scene = e.getScene(), this._engine = this._scene.getEngine();
  }
  _addPlugin(e) {
    for (let s = 0; s < this._plugins.length; ++s)
      if (this._plugins[s].name === e.name)
        throw `Plugin "${e.name}" already added to the material "${this._material.name}"!`;
    if (this._material._uniformBufferLayoutBuilt)
      throw `The plugin "${e.name}" can't be added to the material "${this._material.name}" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;
    const t = e.getClassName();
    Yt._MaterialPluginClassToMainDefine[t] || (Yt._MaterialPluginClassToMainDefine[t] = "MATERIALPLUGIN_" + ++Yt._MaterialPluginCounter), this._material._callbackPluginEventGeneric = this._handlePluginEvent.bind(this), this._plugins.push(e), this._plugins.sort((s, r) => s.priority - r.priority), this._codeInjectionPoints = {};
    const i = {};
    i[Yt._MaterialPluginClassToMainDefine[t]] = {
      type: "boolean",
      default: !0
    };
    for (const s of this._plugins)
      s.collectDefines(i), this._collectPointNames("vertex", s.getCustomCode("vertex")), this._collectPointNames("fragment", s.getCustomCode("fragment"));
    this._defineNamesFromPlugins = i;
  }
  _activatePlugin(e) {
    this._activePlugins.indexOf(e) === -1 && (this._activePlugins.push(e), this._activePlugins.sort((t, i) => t.priority - i.priority), this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this), this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this), this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this), this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this), e.registerForExtraEvents && (this._activePluginsForExtraEvents.push(e), this._activePluginsForExtraEvents.sort((t, i) => t.priority - i.priority), this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this), this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this), this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this)));
  }
  getPlugin(e) {
    for (let t = 0; t < this._plugins.length; ++t)
      if (this._plugins[t].name === e)
        return this._plugins[t];
    return null;
  }
  _handlePluginEventIsReadyForSubMesh(e) {
    let t = !0;
    for (const i of this._activePlugins)
      t = t && i.isReadyForSubMesh(e.defines, this._scene, this._engine, e.subMesh);
    e.isReadyForSubMesh = t;
  }
  _handlePluginEventPrepareDefinesBeforeAttributes(e) {
    for (const t of this._activePlugins)
      t.prepareDefinesBeforeAttributes(e.defines, this._scene, e.mesh);
  }
  _handlePluginEventPrepareDefines(e) {
    for (const t of this._activePlugins)
      t.prepareDefines(e.defines, this._scene, e.mesh);
  }
  _handlePluginEventHardBindForSubMesh(e) {
    for (const t of this._activePluginsForExtraEvents)
      t.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, e.subMesh);
  }
  _handlePluginEventBindForSubMesh(e) {
    for (const t of this._activePlugins)
      t.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, e.subMesh);
  }
  _handlePluginEventHasRenderTargetTextures(e) {
    let t = !1;
    for (const i of this._activePluginsForExtraEvents)
      if (t = i.hasRenderTargetTextures(), t)
        break;
    e.hasRenderTargetTextures = t;
  }
  _handlePluginEventFillRenderTargetTextures(e) {
    for (const t of this._activePluginsForExtraEvents)
      t.fillRenderTargetTextures(e.renderTargets);
  }
  _handlePluginEvent(e, t) {
    switch (e) {
      case je.GetActiveTextures: {
        const i = t;
        for (const s of this._activePlugins)
          s.getActiveTextures(i.activeTextures);
        break;
      }
      case je.GetAnimatables: {
        const i = t;
        for (const s of this._activePlugins)
          s.getAnimatables(i.animatables);
        break;
      }
      case je.HasTexture: {
        const i = t;
        let s = !1;
        for (const r of this._activePlugins)
          if (s = r.hasTexture(i.texture), s)
            break;
        i.hasTexture = s;
        break;
      }
      case je.Disposed: {
        const i = t;
        for (const s of this._plugins)
          s.dispose(i.forceDisposeTextures);
        break;
      }
      case je.GetDefineNames: {
        const i = t;
        i.defineNames = this._defineNamesFromPlugins;
        break;
      }
      case je.PrepareEffect: {
        const i = t;
        for (const s of this._activePlugins)
          i.fallbackRank = s.addFallbacks(i.defines, i.fallbacks, i.fallbackRank), s.getAttributes(i.attributes, this._scene, i.mesh);
        this._uniformList.length > 0 && i.uniforms.push(...this._uniformList), this._samplerList.length > 0 && i.samplers.push(...this._samplerList), this._uboList.length > 0 && i.uniformBuffersNames.push(...this._uboList), i.customCode = this._injectCustomCode(i.customCode);
        break;
      }
      case je.PrepareUniformBuffer: {
        const i = t;
        this._uboDeclaration = "", this._vertexDeclaration = "", this._fragmentDeclaration = "", this._uniformList = [], this._samplerList = [], this._uboList = [];
        for (const s of this._plugins) {
          const r = s.getUniforms();
          if (r) {
            if (r.ubo)
              for (const n of r.ubo)
                i.ubo.addUniform(n.name, n.size), this._uboDeclaration += `${n.type} ${n.name};\r
`, this._uniformList.push(n.name);
            r.vertex && (this._vertexDeclaration += r.vertex + `\r
`), r.fragment && (this._fragmentDeclaration += r.fragment + `\r
`);
          }
          s.getSamplers(this._samplerList), s.getUniformBuffersNames(this._uboList);
        }
        break;
      }
    }
  }
  _collectPointNames(e, t) {
    if (!!t)
      for (const i in t)
        this._codeInjectionPoints[e] || (this._codeInjectionPoints[e] = {}), this._codeInjectionPoints[e][i] = !0;
  }
  _injectCustomCode(e) {
    return (t, i) => {
      var r;
      e && (i = e(t, i)), this._uboDeclaration && (i = i.replace("#define ADDITIONAL_UBO_DECLARATION", this._uboDeclaration)), this._vertexDeclaration && (i = i.replace("#define ADDITIONAL_VERTEX_DECLARATION", this._vertexDeclaration)), this._fragmentDeclaration && (i = i.replace("#define ADDITIONAL_FRAGMENT_DECLARATION", this._fragmentDeclaration));
      const s = (r = this._codeInjectionPoints) == null ? void 0 : r[t];
      if (!s)
        return i;
      for (const n in s) {
        let a = "";
        for (const o of this._activePlugins) {
          const h = o.getCustomCode(t);
          h != null && h[n] && (a += h[n] + `\r
`);
        }
        if (a.length > 0)
          if (n.charAt(0) === "!") {
            const o = new RegExp(n.substring(1), "g");
            let h = o.exec(i);
            for (; h !== null; ) {
              let l = a;
              for (let u = 0; u < h.length; ++u)
                l = l.replace("$" + u, h[u]);
              i = i.replace(h[0], l), h = o.exec(i);
            }
          } else {
            const o = "#define " + n;
            i = i.replace(o, `\r
` + a + `\r
` + o);
          }
      }
      return i;
    };
  }
}
Yt._MaterialPluginClassToMainDefine = {};
Yt._MaterialPluginCounter = 0;
class ls {
  constructor(e, t, i, s, r = !0, n = !1) {
    this.priority = 500, this.registerForExtraEvents = !1, this._material = e, this.name = t, this.priority = i, e.pluginManager || (e.pluginManager = new Yt(e)), this._pluginDefineNames = s, this._pluginManager = e.pluginManager, r && this._pluginManager._addPlugin(this), n && this._enable(!0), this.markAllDefinesAsDirty = e._dirtyCallbacks[63];
  }
  _enable(e) {
    e && this._pluginManager._activatePlugin(this);
  }
  getClassName() {
    return "MaterialPluginBase";
  }
  isReadyForSubMesh(e, t, i, s) {
    return !0;
  }
  hardBindForSubMesh(e, t, i, s) {
  }
  bindForSubMesh(e, t, i, s) {
  }
  dispose(e) {
  }
  getCustomCode(e) {
    return null;
  }
  collectDefines(e) {
    if (!!this._pluginDefineNames)
      for (const t of Object.keys(this._pluginDefineNames)) {
        if (t[0] === "_")
          continue;
        const i = typeof this._pluginDefineNames[t];
        e[t] = {
          type: i === "number" ? "number" : i === "string" ? "string" : i === "boolean" ? "boolean" : "object",
          default: this._pluginDefineNames[t]
        };
      }
  }
  prepareDefinesBeforeAttributes(e, t, i) {
  }
  prepareDefines(e, t, i) {
  }
  hasTexture(e) {
    return !1;
  }
  hasRenderTargetTextures() {
    return !1;
  }
  fillRenderTargetTextures(e) {
  }
  getActiveTextures(e) {
  }
  getAnimatables(e) {
  }
  addFallbacks(e, t, i) {
    return i;
  }
  getSamplers(e) {
  }
  getAttributes(e, t, i) {
  }
  getUniformBuffersNames(e) {
  }
  getUniforms() {
    return {};
  }
  copyTo(e) {
    ne.Clone(() => e, this);
  }
  serialize() {
    return ne.Serialize(this);
  }
  parse(e, t, i) {
    ne.Parse(() => this, e, t, i);
  }
}
S([
  M()
], ls.prototype, "name", void 0);
S([
  M()
], ls.prototype, "priority", void 0);
S([
  M()
], ls.prototype, "registerForExtraEvents", void 0);
class rl extends Vs {
  constructor() {
    super(...arguments), this.DETAIL = !1, this.DETAILDIRECTUV = 0, this.DETAIL_NORMALBLENDMETHOD = 0;
  }
}
class ci extends ls {
  constructor(e, t = !0) {
    super(e, "DetailMap", 140, new rl(), t), this._texture = null, this.diffuseBlendLevel = 1, this.roughnessBlendLevel = 1, this.bumpLevel = 1, this._normalBlendMethod = I.MATERIAL_NORMALBLENDMETHOD_WHITEOUT, this._isEnabled = !1, this.isEnabled = !1, this._internalMarkAllSubMeshesAsTexturesDirty = e._dirtyCallbacks[1];
  }
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled), this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  isReadyForSubMesh(e, t, i) {
    return this._isEnabled ? !(e._areTexturesDirty && t.texturesEnabled && i.getCaps().standardDerivatives && this._texture && ce.DetailTextureEnabled && !this._texture.isReady()) : !0;
  }
  prepareDefines(e, t) {
    if (this._isEnabled) {
      e.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
      const i = t.getEngine();
      e._areTexturesDirty && (i.getCaps().standardDerivatives && this._texture && ce.DetailTextureEnabled && this._isEnabled ? (J.PrepareDefinesForMergedUV(this._texture, e, "DETAIL"), e.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod) : e.DETAIL = !1);
    } else
      e.DETAIL = !1;
  }
  bindForSubMesh(e, t) {
    if (!this._isEnabled)
      return;
    const i = this._material.isFrozen;
    (!e.useUbo || !i || !e.isSync) && this._texture && ce.DetailTextureEnabled && (e.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel), J.BindTextureMatrix(this._texture, e, "detail")), t.texturesEnabled && this._texture && ce.DetailTextureEnabled && e.setTexture("detailSampler", this._texture);
  }
  hasTexture(e) {
    return this._texture === e;
  }
  getActiveTextures(e) {
    this._texture && e.push(this._texture);
  }
  getAnimatables(e) {
    this._texture && this._texture.animations && this._texture.animations.length > 0 && e.push(this._texture);
  }
  dispose(e) {
    var t;
    e && ((t = this._texture) == null || t.dispose());
  }
  getClassName() {
    return "DetailMapConfiguration";
  }
  getSamplers(e) {
    e.push("detailSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vDetailInfos", size: 4, type: "vec4" },
        { name: "detailMatrix", size: 16, type: "mat4" }
      ]
    };
  }
}
S([
  Et("detailTexture"),
  xe("_markAllSubMeshesAsTexturesDirty")
], ci.prototype, "texture", void 0);
S([
  M()
], ci.prototype, "diffuseBlendLevel", void 0);
S([
  M()
], ci.prototype, "roughnessBlendLevel", void 0);
S([
  M()
], ci.prototype, "bumpLevel", void 0);
S([
  M(),
  xe("_markAllSubMeshesAsTexturesDirty")
], ci.prototype, "normalBlendMethod", void 0);
S([
  M(),
  xe("_markAllSubMeshesAsTexturesDirty")
], ci.prototype, "isEnabled", void 0);
const Rs = { effect: null, subMesh: null };
class nl extends Vs {
  constructor(e) {
    super(e), this.MAINUV1 = !1, this.MAINUV2 = !1, this.MAINUV3 = !1, this.MAINUV4 = !1, this.MAINUV5 = !1, this.MAINUV6 = !1, this.DIFFUSE = !1, this.DIFFUSEDIRECTUV = 0, this.BAKED_VERTEX_ANIMATION_TEXTURE = !1, this.AMBIENT = !1, this.AMBIENTDIRECTUV = 0, this.OPACITY = !1, this.OPACITYDIRECTUV = 0, this.OPACITYRGB = !1, this.REFLECTION = !1, this.EMISSIVE = !1, this.EMISSIVEDIRECTUV = 0, this.SPECULAR = !1, this.SPECULARDIRECTUV = 0, this.BUMP = !1, this.BUMPDIRECTUV = 0, this.PARALLAX = !1, this.PARALLAXOCCLUSION = !1, this.SPECULAROVERALPHA = !1, this.CLIPPLANE = !1, this.CLIPPLANE2 = !1, this.CLIPPLANE3 = !1, this.CLIPPLANE4 = !1, this.CLIPPLANE5 = !1, this.CLIPPLANE6 = !1, this.ALPHATEST = !1, this.DEPTHPREPASS = !1, this.ALPHAFROMDIFFUSE = !1, this.POINTSIZE = !1, this.FOG = !1, this.SPECULARTERM = !1, this.DIFFUSEFRESNEL = !1, this.OPACITYFRESNEL = !1, this.REFLECTIONFRESNEL = !1, this.REFRACTIONFRESNEL = !1, this.EMISSIVEFRESNEL = !1, this.FRESNEL = !1, this.NORMAL = !1, this.TANGENT = !1, this.UV1 = !1, this.UV2 = !1, this.UV3 = !1, this.UV4 = !1, this.UV5 = !1, this.UV6 = !1, this.VERTEXCOLOR = !1, this.VERTEXALPHA = !1, this.NUM_BONE_INFLUENCERS = 0, this.BonesPerMesh = 0, this.BONETEXTURE = !1, this.BONES_VELOCITY_ENABLED = !1, this.INSTANCES = !1, this.THIN_INSTANCES = !1, this.INSTANCESCOLOR = !1, this.GLOSSINESS = !1, this.ROUGHNESS = !1, this.EMISSIVEASILLUMINATION = !1, this.LINKEMISSIVEWITHDIFFUSE = !1, this.REFLECTIONFRESNELFROMSPECULAR = !1, this.LIGHTMAP = !1, this.LIGHTMAPDIRECTUV = 0, this.OBJECTSPACE_NORMALMAP = !1, this.USELIGHTMAPASSHADOWMAP = !1, this.REFLECTIONMAP_3D = !1, this.REFLECTIONMAP_SPHERICAL = !1, this.REFLECTIONMAP_PLANAR = !1, this.REFLECTIONMAP_CUBIC = !1, this.USE_LOCAL_REFLECTIONMAP_CUBIC = !1, this.USE_LOCAL_REFRACTIONMAP_CUBIC = !1, this.REFLECTIONMAP_PROJECTION = !1, this.REFLECTIONMAP_SKYBOX = !1, this.REFLECTIONMAP_EXPLICIT = !1, this.REFLECTIONMAP_EQUIRECTANGULAR = !1, this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1, this.REFLECTIONMAP_OPPOSITEZ = !1, this.INVERTCUBICMAP = !1, this.LOGARITHMICDEPTH = !1, this.REFRACTION = !1, this.REFRACTIONMAP_3D = !1, this.REFLECTIONOVERALPHA = !1, this.TWOSIDEDLIGHTING = !1, this.SHADOWFLOAT = !1, this.MORPHTARGETS = !1, this.MORPHTARGETS_NORMAL = !1, this.MORPHTARGETS_TANGENT = !1, this.MORPHTARGETS_UV = !1, this.NUM_MORPH_INFLUENCERS = 0, this.MORPHTARGETS_TEXTURE = !1, this.NONUNIFORMSCALING = !1, this.PREMULTIPLYALPHA = !1, this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = !1, this.ALPHABLEND = !0, this.PREPASS = !1, this.PREPASS_IRRADIANCE = !1, this.PREPASS_IRRADIANCE_INDEX = -1, this.PREPASS_ALBEDO_SQRT = !1, this.PREPASS_ALBEDO_SQRT_INDEX = -1, this.PREPASS_DEPTH = !1, this.PREPASS_DEPTH_INDEX = -1, this.PREPASS_NORMAL = !1, this.PREPASS_NORMAL_INDEX = -1, this.PREPASS_POSITION = !1, this.PREPASS_POSITION_INDEX = -1, this.PREPASS_VELOCITY = !1, this.PREPASS_VELOCITY_INDEX = -1, this.PREPASS_REFLECTIVITY = !1, this.PREPASS_REFLECTIVITY_INDEX = -1, this.SCENE_MRT_COUNT = 0, this.RGBDLIGHTMAP = !1, this.RGBDREFLECTION = !1, this.RGBDREFRACTION = !1, this.IMAGEPROCESSING = !1, this.VIGNETTE = !1, this.VIGNETTEBLENDMODEMULTIPLY = !1, this.VIGNETTEBLENDMODEOPAQUE = !1, this.TONEMAPPING = !1, this.TONEMAPPING_ACES = !1, this.CONTRAST = !1, this.COLORCURVES = !1, this.COLORGRADING = !1, this.COLORGRADING3D = !1, this.SAMPLER3DGREENDEPTH = !1, this.SAMPLER3DBGRMAP = !1, this.DITHER = !1, this.IMAGEPROCESSINGPOSTPROCESS = !1, this.SKIPFINALCOLORCLAMP = !1, this.MULTIVIEW = !1, this.ORDER_INDEPENDENT_TRANSPARENCY = !1, this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !1, this.IS_REFLECTION_LINEAR = !1, this.IS_REFRACTION_LINEAR = !1, this.EXPOSURE = !1, this.rebuild();
  }
  setReflectionMode(e) {
    const t = [
      "REFLECTIONMAP_CUBIC",
      "REFLECTIONMAP_EXPLICIT",
      "REFLECTIONMAP_PLANAR",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_SKYBOX",
      "REFLECTIONMAP_SPHERICAL",
      "REFLECTIONMAP_EQUIRECTANGULAR",
      "REFLECTIONMAP_EQUIRECTANGULAR_FIXED",
      "REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"
    ];
    for (const i of t)
      this[i] = i === e;
  }
}
class O extends Dr {
  constructor(e, t) {
    super(e, t), this._diffuseTexture = null, this._ambientTexture = null, this._opacityTexture = null, this._reflectionTexture = null, this._emissiveTexture = null, this._specularTexture = null, this._bumpTexture = null, this._lightmapTexture = null, this._refractionTexture = null, this.ambientColor = new te(0, 0, 0), this.diffuseColor = new te(1, 1, 1), this.specularColor = new te(1, 1, 1), this.emissiveColor = new te(0, 0, 0), this.specularPower = 64, this._useAlphaFromDiffuseTexture = !1, this._useEmissiveAsIllumination = !1, this._linkEmissiveWithDiffuse = !1, this._useSpecularOverAlpha = !1, this._useReflectionOverAlpha = !1, this._disableLighting = !1, this._useObjectSpaceNormalMap = !1, this._useParallax = !1, this._useParallaxOcclusion = !1, this.parallaxScaleBias = 0.05, this._roughness = 0, this.indexOfRefraction = 0.98, this.invertRefractionY = !0, this.alphaCutOff = 0.4, this._useLightmapAsShadowmap = !1, this._useReflectionFresnelFromSpecular = !1, this._useGlossinessFromSpecularMapAlpha = !1, this._maxSimultaneousLights = 4, this._invertNormalMapX = !1, this._invertNormalMapY = !1, this._twoSidedLighting = !1, this._renderTargets = new Qe(16), this._worldViewProjectionMatrix = x.Zero(), this._globalAmbientColor = new te(0, 0, 0), this._cacheHasRenderTargetTextures = !1, this.detailMap = new ci(this), this._attachImageProcessingConfiguration(null), this.prePassConfiguration = new fr(), this.getRenderTargetTextures = () => (this._renderTargets.reset(), O.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget && this._renderTargets.push(this._reflectionTexture), O.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget && this._renderTargets.push(this._refractionTexture), this._eventInfo.renderTargets = this._renderTargets, this._callbackPluginEventFillRenderTargetTextures(this._eventInfo), this._renderTargets);
  }
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  set imageProcessingConfiguration(e) {
    this._attachImageProcessingConfiguration(e), this._markAllSubMeshesAsTexturesDirty();
  }
  _attachImageProcessingConfiguration(e) {
    e !== this._imageProcessingConfiguration && (this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), e ? this._imageProcessingConfiguration = e : this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration, this._imageProcessingConfiguration && (this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
      this._markAllSubMeshesAsImageProcessingDirty();
    })));
  }
  get isPrePassCapable() {
    return !this.disableDepthWrite;
  }
  get cameraColorCurvesEnabled() {
    return this.imageProcessingConfiguration.colorCurvesEnabled;
  }
  set cameraColorCurvesEnabled(e) {
    this.imageProcessingConfiguration.colorCurvesEnabled = e;
  }
  get cameraColorGradingEnabled() {
    return this.imageProcessingConfiguration.colorGradingEnabled;
  }
  set cameraColorGradingEnabled(e) {
    this.imageProcessingConfiguration.colorGradingEnabled = e;
  }
  get cameraToneMappingEnabled() {
    return this._imageProcessingConfiguration.toneMappingEnabled;
  }
  set cameraToneMappingEnabled(e) {
    this._imageProcessingConfiguration.toneMappingEnabled = e;
  }
  get cameraExposure() {
    return this._imageProcessingConfiguration.exposure;
  }
  set cameraExposure(e) {
    this._imageProcessingConfiguration.exposure = e;
  }
  get cameraContrast() {
    return this._imageProcessingConfiguration.contrast;
  }
  set cameraContrast(e) {
    this._imageProcessingConfiguration.contrast = e;
  }
  get cameraColorGradingTexture() {
    return this._imageProcessingConfiguration.colorGradingTexture;
  }
  set cameraColorGradingTexture(e) {
    this._imageProcessingConfiguration.colorGradingTexture = e;
  }
  get cameraColorCurves() {
    return this._imageProcessingConfiguration.colorCurves;
  }
  set cameraColorCurves(e) {
    this._imageProcessingConfiguration.colorCurves = e;
  }
  get canRenderToMRT() {
    return !0;
  }
  get hasRenderTargetTextures() {
    return O.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget || O.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget ? !0 : this._cacheHasRenderTargetTextures;
  }
  getClassName() {
    return "StandardMaterial";
  }
  get useLogarithmicDepth() {
    return this._useLogarithmicDepth;
  }
  set useLogarithmicDepth(e) {
    this._useLogarithmicDepth = e && this.getScene().getEngine().getCaps().fragmentDepthSupported, this._markAllSubMeshesAsMiscDirty();
  }
  needAlphaBlending() {
    return this._disableAlphaBlending ? !1 : this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
  }
  needAlphaTesting() {
    return this._forceAlphaTest ? !0 : this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === I.MATERIAL_ALPHATEST);
  }
  _shouldUseAlphaFromDiffuseTexture() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== I.MATERIAL_OPAQUE;
  }
  _hasAlphaChannel() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._opacityTexture != null;
  }
  getAlphaTestTexture() {
    return this._diffuseTexture;
  }
  isReadyForSubMesh(e, t, i = !1) {
    if (this._uniformBufferLayoutBuilt || this.buildUniformLayout(), t.effect && this.isFrozen && t.effect._wasPreviouslyReady && t.effect._wasPreviouslyUsingInstances === i)
      return !0;
    t.materialDefines || (this._callbackPluginEventGeneric(je.GetDefineNames, this._eventInfo), t.materialDefines = new nl(this._eventInfo.defineNames));
    const s = this.getScene(), r = t.materialDefines;
    if (this._isReadyForSubMesh(t))
      return !0;
    const n = s.getEngine();
    r._needNormals = J.PrepareDefinesForLights(s, e, r, !0, this._maxSimultaneousLights, this._disableLighting), J.PrepareDefinesForMultiview(s, r);
    const a = this.needAlphaBlendingForMesh(e) && this.getScene().useOrderIndependentTransparency;
    if (J.PrepareDefinesForPrePass(s, r, this.canRenderToMRT && !a), J.PrepareDefinesForOIT(s, r, a), r._areTexturesDirty) {
      this._eventInfo.hasRenderTargetTextures = !1, this._callbackPluginEventHasRenderTargetTextures(this._eventInfo), this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures, r._needUVs = !1;
      for (let o = 1; o <= 6; ++o)
        r["MAINUV" + o] = !1;
      if (s.texturesEnabled) {
        if (r.DIFFUSEDIRECTUV = 0, r.BUMPDIRECTUV = 0, r.AMBIENTDIRECTUV = 0, r.OPACITYDIRECTUV = 0, r.EMISSIVEDIRECTUV = 0, r.SPECULARDIRECTUV = 0, r.LIGHTMAPDIRECTUV = 0, this._diffuseTexture && O.DiffuseTextureEnabled)
          if (this._diffuseTexture.isReadyOrNotBlocking())
            J.PrepareDefinesForMergedUV(this._diffuseTexture, r, "DIFFUSE");
          else
            return !1;
        else
          r.DIFFUSE = !1;
        if (this._ambientTexture && O.AmbientTextureEnabled)
          if (this._ambientTexture.isReadyOrNotBlocking())
            J.PrepareDefinesForMergedUV(this._ambientTexture, r, "AMBIENT");
          else
            return !1;
        else
          r.AMBIENT = !1;
        if (this._opacityTexture && O.OpacityTextureEnabled)
          if (this._opacityTexture.isReadyOrNotBlocking())
            J.PrepareDefinesForMergedUV(this._opacityTexture, r, "OPACITY"), r.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
          else
            return !1;
        else
          r.OPACITY = !1;
        if (this._reflectionTexture && O.ReflectionTextureEnabled)
          if (this._reflectionTexture.isReadyOrNotBlocking()) {
            switch (r._needNormals = !0, r.REFLECTION = !0, r.ROUGHNESS = this._roughness > 0, r.REFLECTIONOVERALPHA = this._useReflectionOverAlpha, r.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === B.INVCUBIC_MODE, r.REFLECTIONMAP_3D = this._reflectionTexture.isCube, r.REFLECTIONMAP_OPPOSITEZ = r.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ, r.RGBDREFLECTION = this._reflectionTexture.isRGBD, this._reflectionTexture.coordinatesMode) {
              case B.EXPLICIT_MODE:
                r.setReflectionMode("REFLECTIONMAP_EXPLICIT");
                break;
              case B.PLANAR_MODE:
                r.setReflectionMode("REFLECTIONMAP_PLANAR");
                break;
              case B.PROJECTION_MODE:
                r.setReflectionMode("REFLECTIONMAP_PROJECTION");
                break;
              case B.SKYBOX_MODE:
                r.setReflectionMode("REFLECTIONMAP_SKYBOX");
                break;
              case B.SPHERICAL_MODE:
                r.setReflectionMode("REFLECTIONMAP_SPHERICAL");
                break;
              case B.EQUIRECTANGULAR_MODE:
                r.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR");
                break;
              case B.FIXED_EQUIRECTANGULAR_MODE:
                r.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
                break;
              case B.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                r.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
                break;
              case B.CUBIC_MODE:
              case B.INVCUBIC_MODE:
              default:
                r.setReflectionMode("REFLECTIONMAP_CUBIC");
                break;
            }
            r.USE_LOCAL_REFLECTIONMAP_CUBIC = !!this._reflectionTexture.boundingBoxSize;
          } else
            return !1;
        else
          r.REFLECTION = !1, r.REFLECTIONMAP_OPPOSITEZ = !1;
        if (this._emissiveTexture && O.EmissiveTextureEnabled)
          if (this._emissiveTexture.isReadyOrNotBlocking())
            J.PrepareDefinesForMergedUV(this._emissiveTexture, r, "EMISSIVE");
          else
            return !1;
        else
          r.EMISSIVE = !1;
        if (this._lightmapTexture && O.LightmapTextureEnabled)
          if (this._lightmapTexture.isReadyOrNotBlocking())
            J.PrepareDefinesForMergedUV(this._lightmapTexture, r, "LIGHTMAP"), r.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap, r.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
          else
            return !1;
        else
          r.LIGHTMAP = !1;
        if (this._specularTexture && O.SpecularTextureEnabled)
          if (this._specularTexture.isReadyOrNotBlocking())
            J.PrepareDefinesForMergedUV(this._specularTexture, r, "SPECULAR"), r.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;
          else
            return !1;
        else
          r.SPECULAR = !1;
        if (s.getEngine().getCaps().standardDerivatives && this._bumpTexture && O.BumpTextureEnabled) {
          if (this._bumpTexture.isReady())
            J.PrepareDefinesForMergedUV(this._bumpTexture, r, "BUMP"), r.PARALLAX = this._useParallax, r.PARALLAXOCCLUSION = this._useParallaxOcclusion;
          else
            return !1;
          r.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
        } else
          r.BUMP = !1, r.PARALLAX = !1, r.PARALLAXOCCLUSION = !1;
        if (this._refractionTexture && O.RefractionTextureEnabled)
          if (this._refractionTexture.isReadyOrNotBlocking())
            r._needUVs = !0, r.REFRACTION = !0, r.REFRACTIONMAP_3D = this._refractionTexture.isCube, r.RGBDREFRACTION = this._refractionTexture.isRGBD, r.USE_LOCAL_REFRACTIONMAP_CUBIC = !!this._refractionTexture.boundingBoxSize;
          else
            return !1;
        else
          r.REFRACTION = !1;
        r.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;
      } else
        r.DIFFUSE = !1, r.AMBIENT = !1, r.OPACITY = !1, r.REFLECTION = !1, r.EMISSIVE = !1, r.LIGHTMAP = !1, r.BUMP = !1, r.REFRACTION = !1;
      r.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture(), r.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination, r.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse, r.SPECULAROVERALPHA = this._useSpecularOverAlpha, r.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8, r.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null, r.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(e);
    }
    if (this._eventInfo.isReadyForSubMesh = !0, this._eventInfo.defines = r, this._callbackPluginEventIsReadyForSubMesh(this._eventInfo), !this._eventInfo.isReadyForSubMesh)
      return !1;
    if (r._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady())
        return !1;
      this._imageProcessingConfiguration.prepareDefines(r), r.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace, r.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;
    }
    if (r._areFresnelDirty && (O.FresnelEnabled ? (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) && (r.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled, r.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled, r.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled, r.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular, r.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled, r.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled, r._needNormals = !0, r.FRESNEL = !0) : r.FRESNEL = !1), J.PrepareDefinesForMisc(e, s, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(e) || this._forceAlphaTest, r), J.PrepareDefinesForFrameBoundValues(s, n, r, i, null, t.getRenderingMesh().hasThinInstances), this._eventInfo.defines = r, this._eventInfo.mesh = e, this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo), J.PrepareDefinesForAttributes(e, r, !0, !0, !0), this._callbackPluginEventPrepareDefines(this._eventInfo), r.isDirty) {
      const o = r._areLightsDisposed;
      r.markAsProcessed();
      const h = new Gs();
      r.REFLECTION && h.addFallback(0, "REFLECTION"), r.SPECULAR && h.addFallback(0, "SPECULAR"), r.BUMP && h.addFallback(0, "BUMP"), r.PARALLAX && h.addFallback(1, "PARALLAX"), r.PARALLAXOCCLUSION && h.addFallback(0, "PARALLAXOCCLUSION"), r.SPECULAROVERALPHA && h.addFallback(0, "SPECULAROVERALPHA"), r.FOG && h.addFallback(1, "FOG"), r.POINTSIZE && h.addFallback(0, "POINTSIZE"), r.LOGARITHMICDEPTH && h.addFallback(0, "LOGARITHMICDEPTH"), J.HandleFallbacksForShadows(r, h, this._maxSimultaneousLights), r.SPECULARTERM && h.addFallback(0, "SPECULARTERM"), r.DIFFUSEFRESNEL && h.addFallback(1, "DIFFUSEFRESNEL"), r.OPACITYFRESNEL && h.addFallback(2, "OPACITYFRESNEL"), r.REFLECTIONFRESNEL && h.addFallback(3, "REFLECTIONFRESNEL"), r.EMISSIVEFRESNEL && h.addFallback(4, "EMISSIVEFRESNEL"), r.FRESNEL && h.addFallback(4, "FRESNEL"), r.MULTIVIEW && h.addFallback(0, "MULTIVIEW");
      const l = [p.PositionKind];
      r.NORMAL && l.push(p.NormalKind), r.TANGENT && l.push(p.TangentKind);
      for (let R = 1; R <= 6; ++R)
        r["UV" + R] && l.push(`uv${R === 1 ? "" : R}`);
      r.VERTEXCOLOR && l.push(p.ColorKind), J.PrepareAttributesForBones(l, e, r, h), J.PrepareAttributesForInstances(l, r), J.PrepareAttributesForMorphTargets(l, e, r), J.PrepareAttributesForBakedVertexAnimation(l, e, r);
      let u = "default";
      const f = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vAmbientColor",
        "vDiffuseColor",
        "vSpecularColor",
        "vEmissiveColor",
        "visibility",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "vAmbientInfos",
        "vOpacityInfos",
        "vReflectionInfos",
        "vEmissiveInfos",
        "vSpecularInfos",
        "vBumpInfos",
        "vLightmapInfos",
        "vRefractionInfos",
        "mBones",
        "vClipPlane",
        "vClipPlane2",
        "vClipPlane3",
        "vClipPlane4",
        "vClipPlane5",
        "vClipPlane6",
        "diffuseMatrix",
        "ambientMatrix",
        "opacityMatrix",
        "reflectionMatrix",
        "emissiveMatrix",
        "specularMatrix",
        "bumpMatrix",
        "normalMatrix",
        "lightmapMatrix",
        "refractionMatrix",
        "diffuseLeftColor",
        "diffuseRightColor",
        "opacityParts",
        "reflectionLeftColor",
        "reflectionRightColor",
        "emissiveLeftColor",
        "emissiveRightColor",
        "refractionLeftColor",
        "refractionRightColor",
        "vReflectionPosition",
        "vReflectionSize",
        "vRefractionPosition",
        "vRefractionSize",
        "logarithmicDepthConstant",
        "vTangentSpaceParams",
        "alphaCutOff",
        "boneTextureWidth",
        "morphTargetTextureInfo",
        "morphTargetTextureIndices"
      ], d = [
        "diffuseSampler",
        "ambientSampler",
        "opacitySampler",
        "reflectionCubeSampler",
        "reflection2DSampler",
        "emissiveSampler",
        "specularSampler",
        "bumpSampler",
        "lightmapSampler",
        "refractionCubeSampler",
        "refraction2DSampler",
        "boneSampler",
        "morphTargets",
        "oitDepthSampler",
        "oitFrontColorSampler"
      ], _ = ["Material", "Scene", "Mesh"];
      this._eventInfo.fallbacks = h, this._eventInfo.fallbackRank = 0, this._eventInfo.defines = r, this._eventInfo.uniforms = f, this._eventInfo.attributes = l, this._eventInfo.samplers = d, this._eventInfo.uniformBuffersNames = _, this._eventInfo.customCode = void 0, this._eventInfo.mesh = e, this._callbackPluginEventGeneric(je.PrepareEffect, this._eventInfo), fr.AddUniforms(f), me && (me.PrepareUniforms(f, r), me.PrepareSamplers(d, r)), J.PrepareUniformsAndSamplersList({
        uniformsNames: f,
        uniformBuffersNames: _,
        samplers: d,
        defines: r,
        maxSimultaneousLights: this._maxSimultaneousLights
      });
      const E = {};
      this.customShaderNameResolve && (u = this.customShaderNameResolve(u, f, _, d, r, l, E));
      const m = r.toString(), T = t.effect;
      let b = s.getEngine().createEffect(u, {
        attributes: l,
        uniformsNames: f,
        uniformBuffersNames: _,
        samplers: d,
        defines: m,
        fallbacks: h,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: r.NUM_MORPH_INFLUENCERS },
        processFinalCode: E.processFinalCode,
        processCodeAfterIncludes: this._eventInfo.customCode,
        multiTarget: r.PREPASS
      }, n);
      if (b)
        if (this._onEffectCreatedObservable && (Rs.effect = b, Rs.subMesh = t, this._onEffectCreatedObservable.notifyObservers(Rs)), this.allowShaderHotSwapping && T && !b.isReady()) {
          if (b = T, r.markAsUnprocessed(), o)
            return r._areLightsDisposed = !0, !1;
        } else
          s.resetCachedMaterial(), t.setEffect(b, r, this._materialContext);
    }
    return !t.effect || !t.effect.isReady() ? !1 : (r._renderId = s.getRenderId(), t.effect._wasPreviouslyReady = !0, t.effect._wasPreviouslyUsingInstances = i, s.performancePriority !== ri.BackwardCompatible && this.freeze(), !0);
  }
  buildUniformLayout() {
    const e = this._uniformBuffer;
    e.addUniform("diffuseLeftColor", 4), e.addUniform("diffuseRightColor", 4), e.addUniform("opacityParts", 4), e.addUniform("reflectionLeftColor", 4), e.addUniform("reflectionRightColor", 4), e.addUniform("refractionLeftColor", 4), e.addUniform("refractionRightColor", 4), e.addUniform("emissiveLeftColor", 4), e.addUniform("emissiveRightColor", 4), e.addUniform("vDiffuseInfos", 2), e.addUniform("vAmbientInfos", 2), e.addUniform("vOpacityInfos", 2), e.addUniform("vReflectionInfos", 2), e.addUniform("vReflectionPosition", 3), e.addUniform("vReflectionSize", 3), e.addUniform("vEmissiveInfos", 2), e.addUniform("vLightmapInfos", 2), e.addUniform("vSpecularInfos", 2), e.addUniform("vBumpInfos", 3), e.addUniform("diffuseMatrix", 16), e.addUniform("ambientMatrix", 16), e.addUniform("opacityMatrix", 16), e.addUniform("reflectionMatrix", 16), e.addUniform("emissiveMatrix", 16), e.addUniform("lightmapMatrix", 16), e.addUniform("specularMatrix", 16), e.addUniform("bumpMatrix", 16), e.addUniform("vTangentSpaceParams", 2), e.addUniform("pointSize", 1), e.addUniform("alphaCutOff", 1), e.addUniform("refractionMatrix", 16), e.addUniform("vRefractionInfos", 4), e.addUniform("vRefractionPosition", 3), e.addUniform("vRefractionSize", 3), e.addUniform("vSpecularColor", 4), e.addUniform("vEmissiveColor", 3), e.addUniform("vDiffuseColor", 4), e.addUniform("vAmbientColor", 3), super.buildUniformLayout();
  }
  bindForSubMesh(e, t, i) {
    var h;
    const s = this.getScene(), r = i.materialDefines;
    if (!r)
      return;
    const n = i.effect;
    if (!n)
      return;
    this._activeEffect = n, t.getMeshUniformBuffer().bindToEffect(n, "Mesh"), t.transferToEffect(e), this._uniformBuffer.bindToEffect(n, "Material"), this.prePassConfiguration.bindForSubMesh(this._activeEffect, s, t, e, this.isFrozen), this._eventInfo.subMesh = i, this._callbackPluginEventHardBindForSubMesh(this._eventInfo), r.OBJECTSPACE_NORMALMAP && (e.toNormalMatrix(this._normalMatrix), this.bindOnlyNormalMatrix(this._normalMatrix));
    const a = this._mustRebind(s, n, t.visibility);
    J.BindBonesParameters(t, n);
    const o = this._uniformBuffer;
    if (a) {
      if (this.bindViewProjection(n), !o.useUbo || !this.isFrozen || !o.isSync) {
        if (O.FresnelEnabled && r.FRESNEL && (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled && (o.updateColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power), o.updateColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias)), this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled && o.updateColor4("opacityParts", new te(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power), this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled && (o.updateColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power), o.updateColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias)), this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled && (o.updateColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power), o.updateColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias)), this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled && (o.updateColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power), o.updateColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias))), s.texturesEnabled) {
          if (this._diffuseTexture && O.DiffuseTextureEnabled && (o.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level), J.BindTextureMatrix(this._diffuseTexture, o, "diffuse")), this._ambientTexture && O.AmbientTextureEnabled && (o.updateFloat2("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level), J.BindTextureMatrix(this._ambientTexture, o, "ambient")), this._opacityTexture && O.OpacityTextureEnabled && (o.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level), J.BindTextureMatrix(this._opacityTexture, o, "opacity")), this._hasAlphaChannel() && o.updateFloat("alphaCutOff", this.alphaCutOff), this._reflectionTexture && O.ReflectionTextureEnabled && (o.updateFloat2("vReflectionInfos", this._reflectionTexture.level, this.roughness), o.updateMatrix("reflectionMatrix", this._reflectionTexture.getReflectionTextureMatrix()), this._reflectionTexture.boundingBoxSize)) {
            const l = this._reflectionTexture;
            o.updateVector3("vReflectionPosition", l.boundingBoxPosition), o.updateVector3("vReflectionSize", l.boundingBoxSize);
          }
          if (this._emissiveTexture && O.EmissiveTextureEnabled && (o.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level), J.BindTextureMatrix(this._emissiveTexture, o, "emissive")), this._lightmapTexture && O.LightmapTextureEnabled && (o.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level), J.BindTextureMatrix(this._lightmapTexture, o, "lightmap")), this._specularTexture && O.SpecularTextureEnabled && (o.updateFloat2("vSpecularInfos", this._specularTexture.coordinatesIndex, this._specularTexture.level), J.BindTextureMatrix(this._specularTexture, o, "specular")), this._bumpTexture && s.getEngine().getCaps().standardDerivatives && O.BumpTextureEnabled && (o.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias), J.BindTextureMatrix(this._bumpTexture, o, "bump"), s._mirroredCameraPosition ? o.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1) : o.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1)), this._refractionTexture && O.RefractionTextureEnabled) {
            let l = 1;
            if (this._refractionTexture.isCube || (o.updateMatrix("refractionMatrix", this._refractionTexture.getReflectionTextureMatrix()), this._refractionTexture.depth && (l = this._refractionTexture.depth)), o.updateFloat4("vRefractionInfos", this._refractionTexture.level, this.indexOfRefraction, l, this.invertRefractionY ? -1 : 1), this._refractionTexture.boundingBoxSize) {
              const u = this._refractionTexture;
              o.updateVector3("vRefractionPosition", u.boundingBoxPosition), o.updateVector3("vRefractionSize", u.boundingBoxSize);
            }
          }
        }
        this.pointsCloud && o.updateFloat("pointSize", this.pointSize), r.SPECULARTERM && o.updateColor4("vSpecularColor", this.specularColor, this.specularPower), o.updateColor3("vEmissiveColor", O.EmissiveTextureEnabled ? this.emissiveColor : te.BlackReadOnly), o.updateColor4("vDiffuseColor", this.diffuseColor, this.alpha), s.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor), o.updateColor3("vAmbientColor", this._globalAmbientColor);
      }
      s.texturesEnabled && (this._diffuseTexture && O.DiffuseTextureEnabled && n.setTexture("diffuseSampler", this._diffuseTexture), this._ambientTexture && O.AmbientTextureEnabled && n.setTexture("ambientSampler", this._ambientTexture), this._opacityTexture && O.OpacityTextureEnabled && n.setTexture("opacitySampler", this._opacityTexture), this._reflectionTexture && O.ReflectionTextureEnabled && (this._reflectionTexture.isCube ? n.setTexture("reflectionCubeSampler", this._reflectionTexture) : n.setTexture("reflection2DSampler", this._reflectionTexture)), this._emissiveTexture && O.EmissiveTextureEnabled && n.setTexture("emissiveSampler", this._emissiveTexture), this._lightmapTexture && O.LightmapTextureEnabled && n.setTexture("lightmapSampler", this._lightmapTexture), this._specularTexture && O.SpecularTextureEnabled && n.setTexture("specularSampler", this._specularTexture), this._bumpTexture && s.getEngine().getCaps().standardDerivatives && O.BumpTextureEnabled && n.setTexture("bumpSampler", this._bumpTexture), this._refractionTexture && O.RefractionTextureEnabled && (this._refractionTexture.isCube ? n.setTexture("refractionCubeSampler", this._refractionTexture) : n.setTexture("refraction2DSampler", this._refractionTexture))), this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(t) && this.getScene().depthPeelingRenderer.bind(n), this._eventInfo.subMesh = i, this._callbackPluginEventBindForSubMesh(this._eventInfo), J.BindClipPlane(n, s), this.bindEyePosition(n);
    } else
      s.getEngine()._features.needToAlwaysBindUniformBuffers && (this._needToBindSceneUbo = !0);
    (a || !this.isFrozen) && (s.lightsEnabled && !this._disableLighting && J.BindLights(s, t, n, r, this._maxSimultaneousLights), (s.fogEnabled && t.applyFog && s.fogMode !== re.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture || t.receiveShadows || r.PREPASS) && this.bindView(n), J.BindFogParameters(s, t, n), r.NUM_MORPH_INFLUENCERS && J.BindMorphTargetParameters(t, n), r.BAKED_VERTEX_ANIMATION_TEXTURE && ((h = t.bakedVertexAnimationManager) == null || h.bind(n, r.INSTANCES)), this.useLogarithmicDepth && J.BindLogDepth(r, n, s), this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess && this._imageProcessingConfiguration.bind(this._activeEffect)), this._afterBind(t, this._activeEffect), o.update();
  }
  getAnimatables() {
    const e = super.getAnimatables();
    return this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0 && e.push(this._diffuseTexture), this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0 && e.push(this._ambientTexture), this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0 && e.push(this._opacityTexture), this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0 && e.push(this._reflectionTexture), this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0 && e.push(this._emissiveTexture), this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0 && e.push(this._specularTexture), this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0 && e.push(this._bumpTexture), this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0 && e.push(this._lightmapTexture), this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0 && e.push(this._refractionTexture), e;
  }
  getActiveTextures() {
    const e = super.getActiveTextures();
    return this._diffuseTexture && e.push(this._diffuseTexture), this._ambientTexture && e.push(this._ambientTexture), this._opacityTexture && e.push(this._opacityTexture), this._reflectionTexture && e.push(this._reflectionTexture), this._emissiveTexture && e.push(this._emissiveTexture), this._specularTexture && e.push(this._specularTexture), this._bumpTexture && e.push(this._bumpTexture), this._lightmapTexture && e.push(this._lightmapTexture), this._refractionTexture && e.push(this._refractionTexture), e;
  }
  hasTexture(e) {
    return !!(super.hasTexture(e) || this._diffuseTexture === e || this._ambientTexture === e || this._opacityTexture === e || this._reflectionTexture === e || this._emissiveTexture === e || this._specularTexture === e || this._bumpTexture === e || this._lightmapTexture === e || this._refractionTexture === e);
  }
  dispose(e, t) {
    var i, s, r, n, a, o, h, l, u;
    t && ((i = this._diffuseTexture) == null || i.dispose(), (s = this._ambientTexture) == null || s.dispose(), (r = this._opacityTexture) == null || r.dispose(), (n = this._reflectionTexture) == null || n.dispose(), (a = this._emissiveTexture) == null || a.dispose(), (o = this._specularTexture) == null || o.dispose(), (h = this._bumpTexture) == null || h.dispose(), (l = this._lightmapTexture) == null || l.dispose(), (u = this._refractionTexture) == null || u.dispose()), this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), super.dispose(e, t);
  }
  clone(e) {
    const t = ne.Clone(() => new O(e, this.getScene()), this);
    return t.name = e, t.id = e, this.stencil.copyTo(t.stencil), t;
  }
  static Parse(e, t, i) {
    const s = ne.Parse(() => new O(e.name, t), e, t, i);
    return e.stencil && s.stencil.parse(e.stencil, t, i), s;
  }
  static get DiffuseTextureEnabled() {
    return ce.DiffuseTextureEnabled;
  }
  static set DiffuseTextureEnabled(e) {
    ce.DiffuseTextureEnabled = e;
  }
  static get DetailTextureEnabled() {
    return ce.DetailTextureEnabled;
  }
  static set DetailTextureEnabled(e) {
    ce.DetailTextureEnabled = e;
  }
  static get AmbientTextureEnabled() {
    return ce.AmbientTextureEnabled;
  }
  static set AmbientTextureEnabled(e) {
    ce.AmbientTextureEnabled = e;
  }
  static get OpacityTextureEnabled() {
    return ce.OpacityTextureEnabled;
  }
  static set OpacityTextureEnabled(e) {
    ce.OpacityTextureEnabled = e;
  }
  static get ReflectionTextureEnabled() {
    return ce.ReflectionTextureEnabled;
  }
  static set ReflectionTextureEnabled(e) {
    ce.ReflectionTextureEnabled = e;
  }
  static get EmissiveTextureEnabled() {
    return ce.EmissiveTextureEnabled;
  }
  static set EmissiveTextureEnabled(e) {
    ce.EmissiveTextureEnabled = e;
  }
  static get SpecularTextureEnabled() {
    return ce.SpecularTextureEnabled;
  }
  static set SpecularTextureEnabled(e) {
    ce.SpecularTextureEnabled = e;
  }
  static get BumpTextureEnabled() {
    return ce.BumpTextureEnabled;
  }
  static set BumpTextureEnabled(e) {
    ce.BumpTextureEnabled = e;
  }
  static get LightmapTextureEnabled() {
    return ce.LightmapTextureEnabled;
  }
  static set LightmapTextureEnabled(e) {
    ce.LightmapTextureEnabled = e;
  }
  static get RefractionTextureEnabled() {
    return ce.RefractionTextureEnabled;
  }
  static set RefractionTextureEnabled(e) {
    ce.RefractionTextureEnabled = e;
  }
  static get ColorGradingTextureEnabled() {
    return ce.ColorGradingTextureEnabled;
  }
  static set ColorGradingTextureEnabled(e) {
    ce.ColorGradingTextureEnabled = e;
  }
  static get FresnelEnabled() {
    return ce.FresnelEnabled;
  }
  static set FresnelEnabled(e) {
    ce.FresnelEnabled = e;
  }
}
S([
  Et("diffuseTexture")
], O.prototype, "_diffuseTexture", void 0);
S([
  xe("_markAllSubMeshesAsTexturesAndMiscDirty")
], O.prototype, "diffuseTexture", void 0);
S([
  Et("ambientTexture")
], O.prototype, "_ambientTexture", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "ambientTexture", void 0);
S([
  Et("opacityTexture")
], O.prototype, "_opacityTexture", void 0);
S([
  xe("_markAllSubMeshesAsTexturesAndMiscDirty")
], O.prototype, "opacityTexture", void 0);
S([
  Et("reflectionTexture")
], O.prototype, "_reflectionTexture", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "reflectionTexture", void 0);
S([
  Et("emissiveTexture")
], O.prototype, "_emissiveTexture", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "emissiveTexture", void 0);
S([
  Et("specularTexture")
], O.prototype, "_specularTexture", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "specularTexture", void 0);
S([
  Et("bumpTexture")
], O.prototype, "_bumpTexture", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "bumpTexture", void 0);
S([
  Et("lightmapTexture")
], O.prototype, "_lightmapTexture", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "lightmapTexture", void 0);
S([
  Et("refractionTexture")
], O.prototype, "_refractionTexture", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "refractionTexture", void 0);
S([
  li("ambient")
], O.prototype, "ambientColor", void 0);
S([
  li("diffuse")
], O.prototype, "diffuseColor", void 0);
S([
  li("specular")
], O.prototype, "specularColor", void 0);
S([
  li("emissive")
], O.prototype, "emissiveColor", void 0);
S([
  M()
], O.prototype, "specularPower", void 0);
S([
  M("useAlphaFromDiffuseTexture")
], O.prototype, "_useAlphaFromDiffuseTexture", void 0);
S([
  xe("_markAllSubMeshesAsTexturesAndMiscDirty")
], O.prototype, "useAlphaFromDiffuseTexture", void 0);
S([
  M("useEmissiveAsIllumination")
], O.prototype, "_useEmissiveAsIllumination", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "useEmissiveAsIllumination", void 0);
S([
  M("linkEmissiveWithDiffuse")
], O.prototype, "_linkEmissiveWithDiffuse", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "linkEmissiveWithDiffuse", void 0);
S([
  M("useSpecularOverAlpha")
], O.prototype, "_useSpecularOverAlpha", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "useSpecularOverAlpha", void 0);
S([
  M("useReflectionOverAlpha")
], O.prototype, "_useReflectionOverAlpha", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "useReflectionOverAlpha", void 0);
S([
  M("disableLighting")
], O.prototype, "_disableLighting", void 0);
S([
  xe("_markAllSubMeshesAsLightsDirty")
], O.prototype, "disableLighting", void 0);
S([
  M("useObjectSpaceNormalMap")
], O.prototype, "_useObjectSpaceNormalMap", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "useObjectSpaceNormalMap", void 0);
S([
  M("useParallax")
], O.prototype, "_useParallax", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "useParallax", void 0);
S([
  M("useParallaxOcclusion")
], O.prototype, "_useParallaxOcclusion", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "useParallaxOcclusion", void 0);
S([
  M()
], O.prototype, "parallaxScaleBias", void 0);
S([
  M("roughness")
], O.prototype, "_roughness", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "roughness", void 0);
S([
  M()
], O.prototype, "indexOfRefraction", void 0);
S([
  M()
], O.prototype, "invertRefractionY", void 0);
S([
  M()
], O.prototype, "alphaCutOff", void 0);
S([
  M("useLightmapAsShadowmap")
], O.prototype, "_useLightmapAsShadowmap", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "useLightmapAsShadowmap", void 0);
S([
  Li("diffuseFresnelParameters")
], O.prototype, "_diffuseFresnelParameters", void 0);
S([
  xe("_markAllSubMeshesAsFresnelDirty")
], O.prototype, "diffuseFresnelParameters", void 0);
S([
  Li("opacityFresnelParameters")
], O.prototype, "_opacityFresnelParameters", void 0);
S([
  xe("_markAllSubMeshesAsFresnelAndMiscDirty")
], O.prototype, "opacityFresnelParameters", void 0);
S([
  Li("reflectionFresnelParameters")
], O.prototype, "_reflectionFresnelParameters", void 0);
S([
  xe("_markAllSubMeshesAsFresnelDirty")
], O.prototype, "reflectionFresnelParameters", void 0);
S([
  Li("refractionFresnelParameters")
], O.prototype, "_refractionFresnelParameters", void 0);
S([
  xe("_markAllSubMeshesAsFresnelDirty")
], O.prototype, "refractionFresnelParameters", void 0);
S([
  Li("emissiveFresnelParameters")
], O.prototype, "_emissiveFresnelParameters", void 0);
S([
  xe("_markAllSubMeshesAsFresnelDirty")
], O.prototype, "emissiveFresnelParameters", void 0);
S([
  M("useReflectionFresnelFromSpecular")
], O.prototype, "_useReflectionFresnelFromSpecular", void 0);
S([
  xe("_markAllSubMeshesAsFresnelDirty")
], O.prototype, "useReflectionFresnelFromSpecular", void 0);
S([
  M("useGlossinessFromSpecularMapAlpha")
], O.prototype, "_useGlossinessFromSpecularMapAlpha", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "useGlossinessFromSpecularMapAlpha", void 0);
S([
  M("maxSimultaneousLights")
], O.prototype, "_maxSimultaneousLights", void 0);
S([
  xe("_markAllSubMeshesAsLightsDirty")
], O.prototype, "maxSimultaneousLights", void 0);
S([
  M("invertNormalMapX")
], O.prototype, "_invertNormalMapX", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "invertNormalMapX", void 0);
S([
  M("invertNormalMapY")
], O.prototype, "_invertNormalMapY", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "invertNormalMapY", void 0);
S([
  M("twoSidedLighting")
], O.prototype, "_twoSidedLighting", void 0);
S([
  xe("_markAllSubMeshesAsTexturesDirty")
], O.prototype, "twoSidedLighting", void 0);
S([
  M()
], O.prototype, "useLogarithmicDepth", null);
it("BABYLON.StandardMaterial", O);
re.DefaultMaterialFactory = (c) => new O("default material", c);
const al = "imageProcessingCompatibility", ol = `#ifdef IMAGEPROCESSINGPOSTPROCESS
gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(2.2));
#endif
`;
N.IncludesShadersStore[al] = ol;
const hl = "shadowOnlyPixelShader", ll = `precision highp float;
uniform vec4 vEyePosition;
uniform float alpha;
uniform vec3 shadowColor;
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
vec3 diffuseBase=vec3(0.,0.,0.);
lightingInfo info;
float shadow=1.;
float glossiness=0.;
#include<lightFragment>[0..1]
vec4 color=vec4(shadowColor,(1.0-clamp(shadow,0.,1.))*alpha);
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;
N.ShadersStore[hl] = ll;
const cl = "shadowOnlyVertexShader", ul = `precision highp float;
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;
uniform mat4 viewProjection;
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);
gl_Position=viewProjection*worldPos;
vPositionW=vec3(worldPos);
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
N.ShadersStore[cl] = ul;
class fl extends Vs {
  constructor() {
    super(), this.CLIPPLANE = !1, this.CLIPPLANE2 = !1, this.CLIPPLANE3 = !1, this.CLIPPLANE4 = !1, this.CLIPPLANE5 = !1, this.CLIPPLANE6 = !1, this.POINTSIZE = !1, this.FOG = !1, this.NORMAL = !1, this.NUM_BONE_INFLUENCERS = 0, this.BonesPerMesh = 0, this.INSTANCES = !1, this.IMAGEPROCESSINGPOSTPROCESS = !1, this.SKIPFINALCOLORCLAMP = !1, this.rebuild();
  }
}
class Ii extends Dr {
  constructor(e, t) {
    super(e, t), this._needAlphaBlending = !0, this.shadowColor = te.Black();
  }
  needAlphaBlending() {
    return this._needAlphaBlending;
  }
  needAlphaTesting() {
    return !1;
  }
  getAlphaTestTexture() {
    return null;
  }
  get activeLight() {
    return this._activeLight;
  }
  set activeLight(e) {
    this._activeLight = e;
  }
  _getFirstShadowLightForMesh(e) {
    for (const t of e.lightSources)
      if (t.shadowEnabled)
        return t;
    return null;
  }
  isReadyForSubMesh(e, t, i) {
    var o;
    if (this.isFrozen && t.effect && t.effect._wasPreviouslyReady && t.effect._wasPreviouslyUsingInstances === i)
      return !0;
    t.materialDefines || (t.materialDefines = new fl());
    const s = t.materialDefines, r = this.getScene();
    if (this._isReadyForSubMesh(t))
      return !0;
    const n = r.getEngine();
    if (this._activeLight) {
      for (const h of e.lightSources)
        if (h.shadowEnabled) {
          if (this._activeLight === h)
            break;
          const l = e.lightSources.indexOf(this._activeLight);
          l !== -1 && (e.lightSources.splice(l, 1), e.lightSources.splice(0, 0, this._activeLight));
          break;
        }
    }
    J.PrepareDefinesForFrameBoundValues(r, n, s, !!i), J.PrepareDefinesForMisc(e, r, !1, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(e), s), s._needNormals = J.PrepareDefinesForLights(r, e, s, !1, 1);
    const a = (o = this._getFirstShadowLightForMesh(e)) == null ? void 0 : o.getShadowGenerator();
    if (this._needAlphaBlending = !0, a && a.getClassName && a.getClassName() === "CascadedShadowGenerator") {
      const h = a;
      this._needAlphaBlending = !h.autoCalcDepthBounds;
    }
    if (J.PrepareDefinesForAttributes(e, s, !1, !0), s.isDirty) {
      s.markAsProcessed(), r.resetCachedMaterial();
      const h = new Gs();
      s.FOG && h.addFallback(1, "FOG"), J.HandleFallbacksForShadows(s, h, 1), s.NUM_BONE_INFLUENCERS > 0 && h.addCPUSkinningFallback(0, e), s.IMAGEPROCESSINGPOSTPROCESS = r.imageProcessingConfiguration.applyByPostProcess;
      const l = [p.PositionKind];
      s.NORMAL && l.push(p.NormalKind), J.PrepareAttributesForBones(l, e, s, h), J.PrepareAttributesForInstances(l, s);
      const u = "shadowOnly", f = s.toString(), d = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "alpha",
        "shadowColor",
        "mBones",
        "vClipPlane",
        "vClipPlane2",
        "vClipPlane3",
        "vClipPlane4",
        "vClipPlane5",
        "vClipPlane6"
      ], _ = new Array(), E = new Array();
      J.PrepareUniformsAndSamplersList({
        uniformsNames: d,
        uniformBuffersNames: E,
        samplers: _,
        defines: s,
        maxSimultaneousLights: 1
      }), t.setEffect(r.getEngine().createEffect(u, {
        attributes: l,
        uniformsNames: d,
        uniformBuffersNames: E,
        samplers: _,
        defines: f,
        fallbacks: h,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 1 }
      }, n), s, this._materialContext);
    }
    return !t.effect || !t.effect.isReady() ? !1 : (s._renderId = r.getRenderId(), t.effect._wasPreviouslyReady = !0, t.effect._wasPreviouslyUsingInstances = !!i, !0);
  }
  bindForSubMesh(e, t, i) {
    const s = this.getScene(), r = i.materialDefines;
    if (!r)
      return;
    const n = i.effect;
    if (!!n) {
      if (this._activeEffect = n, this.bindOnlyWorldMatrix(e), this._activeEffect.setMatrix("viewProjection", s.getTransformMatrix()), J.BindBonesParameters(t, this._activeEffect), this._mustRebind(s, n) && (J.BindClipPlane(this._activeEffect, s), this.pointsCloud && this._activeEffect.setFloat("pointSize", this.pointSize), this._activeEffect.setFloat("alpha", this.alpha), this._activeEffect.setColor3("shadowColor", this.shadowColor), s.bindEyePosition(n)), s.lightsEnabled) {
        J.BindLights(s, t, this._activeEffect, r, 1);
        const a = this._getFirstShadowLightForMesh(t);
        a && (a._renderId = -1);
      }
      (s.fogEnabled && t.applyFog && s.fogMode !== re.FOGMODE_NONE || r.SHADOWCSM0) && this._activeEffect.setMatrix("view", s.getViewMatrix()), J.BindFogParameters(s, t, this._activeEffect), this._afterBind(t, this._activeEffect);
    }
  }
  clone(e) {
    return ne.Clone(() => new Ii(e, this.getScene()), this);
  }
  serialize() {
    const e = super.serialize();
    return e.customType = "BABYLON.ShadowOnlyMaterial", e;
  }
  getClassName() {
    return "ShadowOnlyMaterial";
  }
  static Parse(e, t, i) {
    return ne.Parse(() => new Ii(e.name, t), e, t, i);
  }
}
it("BABYLON.ShadowOnlyMaterial", Ii);
const dl = {
  aspect: 300 / 150,
  enableDebugging: !1,
  enableShadows: !0
};
class _l {
  constructor(e) {
    _t(this, "size", 9.5);
    this.config = { ...dl, ...e }, this.create();
  }
  create(e) {
    this.destroy(), Object.assign(this.config, e);
    const { aspect: t, enableDebugging: i = !0, enableShadows: s } = this.config, r = 30;
    let n;
    this.box = new $("diceBox"), i ? (n = new O("diceBox_material"), n.alpha = 0.7, n.diffuseColor = new te(1, 1, 0)) : s && (n = new Ii("shadowOnly", this.config.scene));
    const a = di("ground", {
      width: this.size * 2,
      height: 1,
      depth: this.size * 2
    }, this.config.scene);
    if (a.scaling = new g(t, 1, 1), a.material = n, a.receiveShadows = !0, a.setParent(this.box), i) {
      const o = di("wallTop", {
        width: this.size,
        height: r,
        depth: 1
      }, this.config.scene);
      o.position.y = r / 2, o.position.z = this.size / -2, o.scaling = new g(t, 1, 1), o.material = n, o.setParent(this.box);
      const h = di("wallRight", {
        width: 1,
        height: r,
        depth: this.size
      }, this.config.scene);
      h.position.x = this.size * t / 2, h.position.y = r / 2, h.material = n, h.setParent(this.box);
      const l = di("wallBottom", {
        width: this.size,
        height: r,
        depth: 1
      }, this.config.scene);
      l.position.y = r / 2, l.position.z = this.size / 2, l.scaling = new g(t, 1, 1), l.material = n, l.setParent(this.box);
      const u = di("wallLeft", {
        width: 1,
        height: r,
        depth: this.size
      }, this.config.scene);
      u.position.x = this.size * t / -2, u.position.y = r / 2, u.material = n, u.setParent(this.box);
    }
  }
  destroy() {
    this.box && this.box.dispose();
  }
}
var Kt;
(function(c) {
  c[c.Clean = 0] = "Clean", c[c.Stop = 1] = "Stop", c[c.Sync = 2] = "Sync", c[c.NoSync = 3] = "NoSync";
})(Kt || (Kt = {}));
class oe {
  static get ForceFullSceneLoadingForIncremental() {
    return we.ForceFullSceneLoadingForIncremental;
  }
  static set ForceFullSceneLoadingForIncremental(e) {
    we.ForceFullSceneLoadingForIncremental = e;
  }
  static get ShowLoadingScreen() {
    return we.ShowLoadingScreen;
  }
  static set ShowLoadingScreen(e) {
    we.ShowLoadingScreen = e;
  }
  static get loggingLevel() {
    return we.loggingLevel;
  }
  static set loggingLevel(e) {
    we.loggingLevel = e;
  }
  static get CleanBoneMatrixWeights() {
    return we.CleanBoneMatrixWeights;
  }
  static set CleanBoneMatrixWeights(e) {
    we.CleanBoneMatrixWeights = e;
  }
  static GetDefaultPlugin() {
    return oe._RegisteredPlugins[".babylon"];
  }
  static _GetPluginForExtension(e) {
    const t = oe._RegisteredPlugins[e];
    return t || (w.Warn("Unable to find a plugin to load " + e + " files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/how_to/load_from_any_file_type"), oe.GetDefaultPlugin());
  }
  static _GetPluginForDirectLoad(e) {
    for (const t in oe._RegisteredPlugins) {
      const i = oe._RegisteredPlugins[t].plugin;
      if (i.canDirectLoad && i.canDirectLoad(e))
        return oe._RegisteredPlugins[t];
    }
    return oe.GetDefaultPlugin();
  }
  static _GetPluginForFilename(e) {
    const t = e.indexOf("?");
    t !== -1 && (e = e.substring(0, t));
    const i = e.lastIndexOf("."), s = e.substring(i, e.length).toLowerCase();
    return oe._GetPluginForExtension(s);
  }
  static _GetDirectLoad(e) {
    return e.substr(0, 5) === "data:" ? e.substr(5) : null;
  }
  static _FormatErrorMessage(e, t, i) {
    let s = "Unable to load from " + e.url;
    return t ? s += `: ${t}` : i && (s += `: ${i}`), s;
  }
  static _LoadData(e, t, i, s, r, n, a) {
    const o = oe._GetDirectLoad(e.url), h = a ? oe._GetPluginForExtension(a) : o ? oe._GetPluginForDirectLoad(e.url) : oe._GetPluginForFilename(e.url);
    let l;
    if (h.plugin.createPlugin !== void 0 ? l = h.plugin.createPlugin() : l = h.plugin, !l)
      throw "The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";
    if (oe.OnPluginActivatedObservable.notifyObservers(l), o && (l.canDirectLoad && l.canDirectLoad(e.url) || !Us(e.url))) {
      if (l.directLoad) {
        const R = l.directLoad(t, o);
        R.then ? R.then((y) => {
          i(l, y);
        }).catch((y) => {
          r("Error in directLoad of _loadData: " + y, y);
        }) : i(l, R);
      } else
        i(l, o);
      return l;
    }
    const u = h.isBinary, f = (R, y) => {
      if (t.isDisposed) {
        r("Scene has been disposed");
        return;
      }
      i(l, R, y);
    };
    let d = null, _ = !1;
    const E = l.onDisposeObservable;
    E && E.add(() => {
      _ = !0, d && (d.abort(), d = null), n();
    });
    const m = () => {
      if (_)
        return;
      const R = (P, v) => {
        r(P == null ? void 0 : P.statusText, v);
      }, y = e.file || e.url;
      d = l.loadFile ? l.loadFile(t, y, f, s, u, R) : t._loadFile(y, f, s, !0, u, R);
    }, T = t.getEngine();
    let b = T.enableOfflineSupport;
    if (b) {
      let R = !1;
      for (const y of t.disableOfflineSupportExceptionRules)
        if (y.test(e.url)) {
          R = !0;
          break;
        }
      b = !R;
    }
    return b && C.OfflineProviderFactory ? t.offlineProvider = C.OfflineProviderFactory(e.url, m, T.disableManifestCheck) : m(), l;
  }
  static _GetFileInfo(e, t) {
    let i, s, r = null;
    if (!t)
      i = e, s = U.GetFilename(e), e = U.GetFolderPath(e);
    else if (t.name) {
      const n = t;
      i = `file:${n.name}`, s = n.name, r = n;
    } else if (typeof t == "string" && t.startsWith("data:"))
      i = t, s = "";
    else {
      const n = t;
      if (n.substr(0, 1) === "/")
        return U.Error("Wrong sceneFilename parameter"), null;
      i = e + n, s = n;
    }
    return {
      url: i,
      rootUrl: e,
      name: s,
      file: r
    };
  }
  static GetPluginForExtension(e) {
    return oe._GetPluginForExtension(e).plugin;
  }
  static IsPluginForExtensionAvailable(e) {
    return !!oe._RegisteredPlugins[e];
  }
  static RegisterPlugin(e) {
    if (typeof e.extensions == "string") {
      const t = e.extensions;
      oe._RegisteredPlugins[t.toLowerCase()] = {
        plugin: e,
        isBinary: !1
      };
    } else {
      const t = e.extensions;
      Object.keys(t).forEach((i) => {
        oe._RegisteredPlugins[i.toLowerCase()] = {
          plugin: e,
          isBinary: t[i].isBinary
        };
      });
    }
  }
  static ImportMesh(e, t, i = "", s = _e.LastCreatedScene, r = null, n = null, a = null, o = null) {
    if (!s)
      return w.Error("No scene available to import mesh to"), null;
    const h = oe._GetFileInfo(t, i);
    if (!h)
      return null;
    const l = {};
    s.addPendingData(l);
    const u = () => {
      s.removePendingData(l);
    }, f = (E, m) => {
      const T = oe._FormatErrorMessage(h, E, m);
      a ? a(s, T, new Vt(T, si.SceneLoaderError, m)) : w.Error(T), u();
    }, d = n ? (E) => {
      try {
        n(E);
      } catch (m) {
        f("Error in onProgress callback: " + m, m);
      }
    } : void 0, _ = (E, m, T, b, R, y, P) => {
      if (s.importedMeshesFiles.push(h.url), r)
        try {
          r(E, m, T, b, R, y, P);
        } catch (v) {
          f("Error in onSuccess callback: " + v, v);
        }
      s.removePendingData(l);
    };
    return oe._LoadData(h, s, (E, m, T) => {
      if (E.rewriteRootURL && (h.rootUrl = E.rewriteRootURL(h.rootUrl, T)), E.importMesh) {
        const b = E, R = new Array(), y = new Array(), P = new Array();
        if (!b.importMesh(e, s, m, h.rootUrl, R, y, P, f))
          return;
        s.loadingPluginName = E.name, _(R, y, P, [], [], [], []);
      } else
        E.importMeshAsync(e, s, m, h.rootUrl, d, h.name).then((R) => {
          s.loadingPluginName = E.name, _(R.meshes, R.particleSystems, R.skeletons, R.animationGroups, R.transformNodes, R.geometries, R.lights);
        }).catch((R) => {
          f(R.message, R);
        });
    }, d, f, u, o);
  }
  static ImportMeshAsync(e, t, i = "", s = _e.LastCreatedScene, r = null, n = null) {
    return new Promise((a, o) => {
      oe.ImportMesh(e, t, i, s, (h, l, u, f, d, _, E) => {
        a({
          meshes: h,
          particleSystems: l,
          skeletons: u,
          animationGroups: f,
          transformNodes: d,
          geometries: _,
          lights: E
        });
      }, r, (h, l, u) => {
        o(u || new Error(l));
      }, n);
    });
  }
  static Load(e, t = "", i = _e.LastCreatedEngine, s = null, r = null, n = null, a = null) {
    return i ? oe.Append(e, t, new re(i), s, r, n, a) : (U.Error("No engine available"), null);
  }
  static LoadAsync(e, t = "", i = _e.LastCreatedEngine, s = null, r = null) {
    return new Promise((n, a) => {
      oe.Load(e, t, i, (o) => {
        n(o);
      }, s, (o, h, l) => {
        a(l || new Error(h));
      }, r);
    });
  }
  static Append(e, t = "", i = _e.LastCreatedScene, s = null, r = null, n = null, a = null) {
    if (!i)
      return w.Error("No scene available to append to"), null;
    const o = oe._GetFileInfo(e, t);
    if (!o)
      return null;
    const h = {};
    i.addPendingData(h);
    const l = () => {
      i.removePendingData(h);
    };
    oe.ShowLoadingScreen && !this._ShowingLoadingScreen && (this._ShowingLoadingScreen = !0, i.getEngine().displayLoadingUI(), i.executeWhenReady(() => {
      i.getEngine().hideLoadingUI(), this._ShowingLoadingScreen = !1;
    }));
    const u = (_, E) => {
      const m = oe._FormatErrorMessage(o, _, E);
      n ? n(i, m, new Vt(m, si.SceneLoaderError, E)) : w.Error(m), l();
    }, f = r ? (_) => {
      try {
        r(_);
      } catch (E) {
        u("Error in onProgress callback", E);
      }
    } : void 0, d = () => {
      if (s)
        try {
          s(i);
        } catch (_) {
          u("Error in onSuccess callback", _);
        }
      i.removePendingData(h);
    };
    return oe._LoadData(o, i, (_, E) => {
      if (_.load) {
        if (!_.load(i, E, o.rootUrl, u))
          return;
        i.loadingPluginName = _.name, d();
      } else
        _.loadAsync(i, E, o.rootUrl, f, o.name).then(() => {
          i.loadingPluginName = _.name, d();
        }).catch((T) => {
          u(T.message, T);
        });
    }, f, u, l, a);
  }
  static AppendAsync(e, t = "", i = _e.LastCreatedScene, s = null, r = null) {
    return new Promise((n, a) => {
      oe.Append(e, t, i, (o) => {
        n(o);
      }, s, (o, h, l) => {
        a(l || new Error(h));
      }, r);
    });
  }
  static LoadAssetContainer(e, t = "", i = _e.LastCreatedScene, s = null, r = null, n = null, a = null) {
    if (!i)
      return w.Error("No scene available to load asset container to"), null;
    const o = oe._GetFileInfo(e, t);
    if (!o)
      return null;
    const h = {};
    i.addPendingData(h);
    const l = () => {
      i.removePendingData(h);
    }, u = (_, E) => {
      const m = oe._FormatErrorMessage(o, _, E);
      n ? n(i, m, new Vt(m, si.SceneLoaderError, E)) : w.Error(m), l();
    }, f = r ? (_) => {
      try {
        r(_);
      } catch (E) {
        u("Error in onProgress callback", E);
      }
    } : void 0, d = (_) => {
      if (s)
        try {
          s(_);
        } catch (E) {
          u("Error in onSuccess callback", E);
        }
      i.removePendingData(h);
    };
    return oe._LoadData(o, i, (_, E) => {
      if (_.loadAssetContainer) {
        const T = _.loadAssetContainer(i, E, o.rootUrl, u);
        if (!T)
          return;
        i.loadingPluginName = _.name, d(T);
      } else
        _.loadAssetContainerAsync ? _.loadAssetContainerAsync(i, E, o.rootUrl, f, o.name).then((T) => {
          i.loadingPluginName = _.name, d(T);
        }).catch((T) => {
          u(T.message, T);
        }) : u("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.");
    }, f, u, l, a);
  }
  static LoadAssetContainerAsync(e, t = "", i = _e.LastCreatedScene, s = null, r = null) {
    return new Promise((n, a) => {
      oe.LoadAssetContainer(e, t, i, (o) => {
        n(o);
      }, s, (o, h, l) => {
        a(l || new Error(h));
      }, r);
    });
  }
  static ImportAnimations(e, t = "", i = _e.LastCreatedScene, s = !0, r = Kt.Clean, n = null, a = null, o = null, h = null, l = null) {
    if (!i) {
      w.Error("No scene available to load animations to");
      return;
    }
    if (s) {
      for (const _ of i.animatables)
        _.reset();
      i.stopAllAnimations(), i.animationGroups.slice().forEach((_) => {
        _.dispose();
      }), i.getNodes().forEach((_) => {
        _.animations && (_.animations = []);
      });
    } else
      switch (r) {
        case Kt.Clean:
          i.animationGroups.slice().forEach((d) => {
            d.dispose();
          });
          break;
        case Kt.Stop:
          i.animationGroups.forEach((d) => {
            d.stop();
          });
          break;
        case Kt.Sync:
          i.animationGroups.forEach((d) => {
            d.reset(), d.restart();
          });
          break;
        case Kt.NoSync:
          break;
        default:
          w.Error("Unknown animation group loading mode value '" + r + "'");
          return;
      }
    const u = i.animatables.length, f = (d) => {
      d.mergeAnimationsTo(i, i.animatables.slice(u), n), d.dispose(), i.onAnimationFileImportedObservable.notifyObservers(i), a && a(i);
    };
    this.LoadAssetContainer(e, t, i, f, o, h, l);
  }
  static ImportAnimationsAsync(e, t = "", i = _e.LastCreatedScene, s = !0, r = Kt.Clean, n = null, a = null, o = null, h = null, l = null) {
    return new Promise((u, f) => {
      oe.ImportAnimations(e, t, i, s, r, n, (d) => {
        u(d);
      }, o, (d, _, E) => {
        f(E || new Error(_));
      }, l);
    });
  }
}
oe.NO_LOGGING = 0;
oe.MINIMAL_LOGGING = 1;
oe.SUMMARY_LOGGING = 2;
oe.DETAILED_LOGGING = 3;
oe.OnPluginActivatedObservable = new F();
oe._RegisteredPlugins = {};
oe._ShowingLoadingScreen = !1;
class de {
  constructor(e, t, i = Number.MAX_VALUE) {
    this.origin = e, this.direction = t, this.length = i;
  }
  clone() {
    return new de(this.origin.clone(), this.direction.clone(), this.length);
  }
  intersectsBoxMinMax(e, t, i = 0) {
    const s = de._TmpVector3[0].copyFromFloats(e.x - i, e.y - i, e.z - i), r = de._TmpVector3[1].copyFromFloats(t.x + i, t.y + i, t.z + i);
    let n = 0, a = Number.MAX_VALUE, o, h, l, u;
    if (Math.abs(this.direction.x) < 1e-7) {
      if (this.origin.x < s.x || this.origin.x > r.x)
        return !1;
    } else if (o = 1 / this.direction.x, h = (s.x - this.origin.x) * o, l = (r.x - this.origin.x) * o, l === -1 / 0 && (l = 1 / 0), h > l && (u = h, h = l, l = u), n = Math.max(h, n), a = Math.min(l, a), n > a)
      return !1;
    if (Math.abs(this.direction.y) < 1e-7) {
      if (this.origin.y < s.y || this.origin.y > r.y)
        return !1;
    } else if (o = 1 / this.direction.y, h = (s.y - this.origin.y) * o, l = (r.y - this.origin.y) * o, l === -1 / 0 && (l = 1 / 0), h > l && (u = h, h = l, l = u), n = Math.max(h, n), a = Math.min(l, a), n > a)
      return !1;
    if (Math.abs(this.direction.z) < 1e-7) {
      if (this.origin.z < s.z || this.origin.z > r.z)
        return !1;
    } else if (o = 1 / this.direction.z, h = (s.z - this.origin.z) * o, l = (r.z - this.origin.z) * o, l === -1 / 0 && (l = 1 / 0), h > l && (u = h, h = l, l = u), n = Math.max(h, n), a = Math.min(l, a), n > a)
      return !1;
    return !0;
  }
  intersectsBox(e, t = 0) {
    return this.intersectsBoxMinMax(e.minimum, e.maximum, t);
  }
  intersectsSphere(e, t = 0) {
    const i = e.center.x - this.origin.x, s = e.center.y - this.origin.y, r = e.center.z - this.origin.z, n = i * i + s * s + r * r, a = e.radius + t, o = a * a;
    if (n <= o)
      return !0;
    const h = i * this.direction.x + s * this.direction.y + r * this.direction.z;
    return h < 0 ? !1 : n - h * h <= o;
  }
  intersectsTriangle(e, t, i) {
    const s = de._TmpVector3[0], r = de._TmpVector3[1], n = de._TmpVector3[2], a = de._TmpVector3[3], o = de._TmpVector3[4];
    t.subtractToRef(e, s), i.subtractToRef(e, r), g.CrossToRef(this.direction, r, n);
    const h = g.Dot(s, n);
    if (h === 0)
      return null;
    const l = 1 / h;
    this.origin.subtractToRef(e, a);
    const u = g.Dot(a, n) * l;
    if (u < 0 || u > 1)
      return null;
    g.CrossToRef(a, s, o);
    const f = g.Dot(this.direction, o) * l;
    if (f < 0 || u + f > 1)
      return null;
    const d = g.Dot(r, o) * l;
    return d > this.length ? null : new Ds(1 - u - f, u, d);
  }
  intersectsPlane(e) {
    let t;
    const i = g.Dot(e.normal, this.direction);
    if (Math.abs(i) < 999999997475243e-21)
      return null;
    {
      const s = g.Dot(e.normal, this.origin);
      return t = (-e.d - s) / i, t < 0 ? t < -999999997475243e-21 ? null : 0 : t;
    }
  }
  intersectsAxis(e, t = 0) {
    switch (e) {
      case "y": {
        const i = (this.origin.y - t) / this.direction.y;
        return i > 0 ? null : new g(this.origin.x + this.direction.x * -i, t, this.origin.z + this.direction.z * -i);
      }
      case "x": {
        const i = (this.origin.x - t) / this.direction.x;
        return i > 0 ? null : new g(t, this.origin.y + this.direction.y * -i, this.origin.z + this.direction.z * -i);
      }
      case "z": {
        const i = (this.origin.z - t) / this.direction.z;
        return i > 0 ? null : new g(this.origin.x + this.direction.x * -i, this.origin.y + this.direction.y * -i, t);
      }
      default:
        return null;
    }
  }
  intersectsMesh(e, t) {
    const i = D.Matrix[0];
    return e.getWorldMatrix().invertToRef(i), this._tmpRay ? de.TransformToRef(this, i, this._tmpRay) : this._tmpRay = de.Transform(this, i), e.intersects(this._tmpRay, t);
  }
  intersectsMeshes(e, t, i) {
    i ? i.length = 0 : i = [];
    for (let s = 0; s < e.length; s++) {
      const r = this.intersectsMesh(e[s], t);
      r.hit && i.push(r);
    }
    return i.sort(this._comparePickingInfo), i;
  }
  _comparePickingInfo(e, t) {
    return e.distance < t.distance ? -1 : e.distance > t.distance ? 1 : 0;
  }
  intersectionSegment(e, t, i) {
    const s = this.origin, r = D.Vector3[0], n = D.Vector3[1], a = D.Vector3[2], o = D.Vector3[3];
    t.subtractToRef(e, r), this.direction.scaleToRef(de._Rayl, a), s.addToRef(a, n), e.subtractToRef(s, o);
    const h = g.Dot(r, r), l = g.Dot(r, a), u = g.Dot(a, a), f = g.Dot(r, o), d = g.Dot(a, o), _ = h * u - l * l;
    let E, m = _, T, b = _;
    _ < de._Smallnum ? (E = 0, m = 1, T = d, b = u) : (E = l * d - u * f, T = h * d - l * f, E < 0 ? (E = 0, T = d, b = u) : E > m && (E = m, T = d + l, b = u)), T < 0 ? (T = 0, -f < 0 ? E = 0 : -f > h ? E = m : (E = -f, m = h)) : T > b && (T = b, -f + l < 0 ? E = 0 : -f + l > h ? E = m : (E = -f + l, m = h));
    const R = Math.abs(E) < de._Smallnum ? 0 : E / m, y = Math.abs(T) < de._Smallnum ? 0 : T / b, P = D.Vector3[4];
    a.scaleToRef(y, P);
    const v = D.Vector3[5];
    r.scaleToRef(R, v), v.addInPlace(o);
    const A = D.Vector3[6];
    return v.subtractToRef(P, A), y > 0 && y <= this.length && A.lengthSquared() < i * i ? v.length() : -1;
  }
  update(e, t, i, s, r, n, a, o = !1) {
    if (o) {
      de._RayDistant || (de._RayDistant = de.Zero()), de._RayDistant.unprojectRayToRef(e, t, i, s, x.IdentityReadOnly, n, a);
      const h = D.Matrix[0];
      r.invertToRef(h), de.TransformToRef(de._RayDistant, h, this);
    } else
      this.unprojectRayToRef(e, t, i, s, r, n, a);
    return this;
  }
  static Zero() {
    return new de(g.Zero(), g.Zero());
  }
  static CreateNew(e, t, i, s, r, n, a) {
    return de.Zero().update(e, t, i, s, r, n, a);
  }
  static CreateNewFromTo(e, t, i = x.IdentityReadOnly) {
    const s = t.subtract(e), r = Math.sqrt(s.x * s.x + s.y * s.y + s.z * s.z);
    return s.normalize(), de.Transform(new de(e, s, r), i);
  }
  static Transform(e, t) {
    const i = new de(new g(0, 0, 0), new g(0, 0, 0));
    return de.TransformToRef(e, t, i), i;
  }
  static TransformToRef(e, t, i) {
    g.TransformCoordinatesToRef(e.origin, t, i.origin), g.TransformNormalToRef(e.direction, t, i.direction), i.length = e.length;
    const s = i.direction, r = s.length();
    if (!(r === 0 || r === 1)) {
      const n = 1 / r;
      s.x *= n, s.y *= n, s.z *= n, i.length *= r;
    }
  }
  unprojectRayToRef(e, t, i, s, r, n, a) {
    var d;
    const o = D.Matrix[0];
    r.multiplyToRef(n, o), o.multiplyToRef(a, o), o.invert();
    const h = D.Vector3[0];
    h.x = e / i * 2 - 1, h.y = -(t / s * 2 - 1), h.z = (d = _e.LastCreatedEngine) != null && d.isNDCHalfZRange ? 0 : -1;
    const l = D.Vector3[1].copyFromFloats(h.x, h.y, 1 - 1e-8), u = D.Vector3[2], f = D.Vector3[3];
    g._UnprojectFromInvertedMatrixToRef(h, o, u), g._UnprojectFromInvertedMatrixToRef(l, o, f), this.origin.copyFrom(u), f.subtractToRef(u, this.direction), this.direction.normalize();
  }
}
de._TmpVector3 = Me.BuildArray(6, g.Zero);
de._RayDistant = de.Zero();
de._Smallnum = 1e-8;
de._Rayl = 1e9;
re.prototype.createPickingRay = function(c, e, t, i, s = !1) {
  const r = de.Zero();
  return this.createPickingRayToRef(c, e, t, r, i, s), r;
};
re.prototype.createPickingRayToRef = function(c, e, t, i, s, r = !1, n = !1) {
  const a = this.getEngine();
  if (!s) {
    if (!this.activeCamera)
      return this;
    s = this.activeCamera;
  }
  const h = s.viewport.toGlobal(a.getRenderWidth(), a.getRenderHeight());
  return c = c / a.getHardwareScalingLevel() - h.x, e = e / a.getHardwareScalingLevel() - (a.getRenderHeight() - h.y - h.height), i.update(c, e, h.width, h.height, t || x.IdentityReadOnly, r ? x.IdentityReadOnly : s.getViewMatrix(), s.getProjectionMatrix(), n), this;
};
re.prototype.createPickingRayInCameraSpace = function(c, e, t) {
  const i = de.Zero();
  return this.createPickingRayInCameraSpaceToRef(c, e, i, t), i;
};
re.prototype.createPickingRayInCameraSpaceToRef = function(c, e, t, i) {
  if (!vt)
    return this;
  const s = this.getEngine();
  if (!i) {
    if (!this.activeCamera)
      throw new Error("Active camera not set");
    i = this.activeCamera;
  }
  const n = i.viewport.toGlobal(s.getRenderWidth(), s.getRenderHeight()), a = x.Identity();
  return c = c / s.getHardwareScalingLevel() - n.x, e = e / s.getHardwareScalingLevel() - (s.getRenderHeight() - n.y - n.height), t.update(c, e, n.width, n.height, a, a, i.getProjectionMatrix()), this;
};
re.prototype._internalPickForMesh = function(c, e, t, i, s, r, n, a) {
  const o = e(i, t.enableDistantPicking), h = t.intersects(o, s, n, r, i, a);
  return !h || !h.hit || !s && c != null && h.distance >= c.distance ? null : h;
};
re.prototype._internalPick = function(c, e, t, i, s) {
  if (!vt)
    return null;
  let r = null;
  for (let n = 0; n < this.meshes.length; n++) {
    const a = this.meshes[n];
    if (e) {
      if (!e(a))
        continue;
    } else if (!a.isEnabled() || !a.isVisible || !a.isPickable)
      continue;
    const o = a.getWorldMatrix();
    if (a.hasThinInstances && a.thinInstanceEnablePicking) {
      const h = this._internalPickForMesh(r, c, a, o, !0, !0, s);
      if (h) {
        if (i)
          return h;
        const l = D.Matrix[1], u = a.thinInstanceGetWorldMatrices();
        for (let f = 0; f < u.length; f++) {
          u[f].multiplyToRef(o, l);
          const _ = this._internalPickForMesh(r, c, a, l, t, i, s, !0);
          if (_ && (r = _, r.thinInstanceIndex = f, t))
            return r;
        }
      }
    } else {
      const h = this._internalPickForMesh(r, c, a, o, t, i, s);
      if (h && (r = h, t))
        return r;
    }
  }
  return r || new vt();
};
re.prototype._internalMultiPick = function(c, e, t) {
  if (!vt)
    return null;
  const i = new Array();
  for (let s = 0; s < this.meshes.length; s++) {
    const r = this.meshes[s];
    if (e) {
      if (!e(r))
        continue;
    } else if (!r.isEnabled() || !r.isVisible || !r.isPickable)
      continue;
    const n = r.getWorldMatrix();
    if (r.hasThinInstances && r.thinInstanceEnablePicking) {
      if (this._internalPickForMesh(null, c, r, n, !0, !0, t)) {
        const o = D.Matrix[1], h = r.thinInstanceGetWorldMatrices();
        for (let l = 0; l < h.length; l++) {
          h[l].multiplyToRef(n, o);
          const f = this._internalPickForMesh(null, c, r, o, !1, !1, t, !0);
          f && (f.thinInstanceIndex = l, i.push(f));
        }
      }
    } else {
      const a = this._internalPickForMesh(null, c, r, n, !1, !1, t);
      a && i.push(a);
    }
  }
  return i;
};
re.prototype.pickWithBoundingInfo = function(c, e, t, i, s) {
  if (!vt)
    return null;
  const r = this._internalPick((n) => (this._tempPickingRay || (this._tempPickingRay = de.Zero()), this.createPickingRayToRef(c, e, n, this._tempPickingRay, s || null), this._tempPickingRay), t, i, !0);
  return r && (r.ray = this.createPickingRay(c, e, x.Identity(), s || null)), r;
};
re.prototype.pick = function(c, e, t, i, s, r, n = !1) {
  if (!vt)
    return null;
  const a = this._internalPick((o, h) => (this._tempPickingRay || (this._tempPickingRay = de.Zero()), this.createPickingRayToRef(c, e, o, this._tempPickingRay, s || null, !1, h), this._tempPickingRay), t, i, !1, r);
  return a && (a.ray = this.createPickingRay(c, e, x.Identity(), s || null)), a;
};
re.prototype.pickWithRay = function(c, e, t, i) {
  const s = this._internalPick((r) => (this._pickWithRayInverseMatrix || (this._pickWithRayInverseMatrix = x.Identity()), r.invertToRef(this._pickWithRayInverseMatrix), this._cachedRayForTransform || (this._cachedRayForTransform = de.Zero()), de.TransformToRef(c, this._pickWithRayInverseMatrix, this._cachedRayForTransform), this._cachedRayForTransform), e, t, !1, i);
  return s && (s.ray = c), s;
};
re.prototype.multiPick = function(c, e, t, i, s) {
  return this._internalMultiPick((r) => this.createPickingRay(c, e, r, i || null), t, s);
};
re.prototype.multiPickWithRay = function(c, e, t) {
  return this._internalMultiPick((i) => (this._pickWithRayInverseMatrix || (this._pickWithRayInverseMatrix = x.Identity()), i.invertToRef(this._pickWithRayInverseMatrix), this._cachedRayForTransform || (this._cachedRayForTransform = de.Zero()), de.TransformToRef(c, this._pickWithRayInverseMatrix, this._cachedRayForTransform), this._cachedRayForTransform), e, t);
};
Y.prototype.getForwardRay = function(c = 100, e, t) {
  return this.getForwardRayToRef(new de(g.Zero(), g.Zero(), c), c, e, t);
};
Y.prototype.getForwardRayToRef = function(c, e = 100, t, i) {
  return t || (t = this.getWorldMatrix()), c.length = e, i ? c.origin.copyFrom(i) : c.origin.copyFrom(this.position), D.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1), g.TransformNormalToRef(D.Vector3[2], t, D.Vector3[3]), g.NormalizeToRef(D.Vector3[3], c.direction), c;
};
var gl = function(c, e, t) {
  for (var i in e)
    if (c.name === e[i])
      return t.push(c.id), !0;
  return c.parentId && t.indexOf(c.parentId) !== -1 ? (t.push(c.id), !0) : !1;
}, Gi = function(c, e) {
  return c + " of " + (e ? e.file + " from " + e.name + " version: " + e.version + ", exporter version: " + e.exporter_version : "unknown");
};
oe.RegisterPlugin({
  name: "babylon.js",
  extensions: ".json",
  canDirectLoad: function(c) {
    return c.indexOf("json") !== -1, !0;
  },
  importMesh: function(c, e, t, i, s, r, n, a) {
    var o = "importMesh has failed JSON parse";
    try {
      var h = JSON.parse(t);
      h.physicsEnabled = !1, h == null || h.meshes.map((b) => delete b.physicsImpostor), o = "";
      var l = oe.loggingLevel === oe.DETAILED_LOGGING;
      c ? Array.isArray(c) || (c = [c]) : c = null;
      var u = new Array();
      if (h.meshes !== void 0 && h.meshes !== null) {
        var f, d;
        for (f = 0, d = h.meshes.length; f < d; f++) {
          var _ = h.meshes[f];
          if (c === null || gl(_, c, u)) {
            c !== null && delete c[c.indexOf(_.name)];
            var E = k.Parse(_, e, i);
            s.push(E), o += `
	Mesh ` + E.toString(l);
          }
        }
        var m;
        for (f = 0, d = e.meshes.length; f < d; f++)
          m = e.meshes[f], m._waitingParentId && (m.parent = e.getLastEntryByID(m._waitingParentId), m._waitingParentId = null), m.computeWorldMatrix(!0);
      }
      return !0;
    } catch (b) {
      var T = Gi("importMesh", h ? h.producer : "Unknown") + o;
      if (a)
        a(T, b);
      else
        throw w.Log(T), b;
    } finally {
      o !== null && oe.loggingLevel !== oe.NO_LOGGING && w.Log(Gi("importMesh", h ? h.producer : "Unknown") + (oe.loggingLevel !== oe.MINIMAL_LOGGING ? o : ""));
    }
    return !1;
  },
  load: function(c, e, t, i) {
    var s = "importScene has failed JSON parse";
    try {
      var r = JSON.parse(e);
      s = "", r.clearColor !== void 0 && r.clearColor !== null && (c.clearColor = Color4.FromArray(r.clearColor));
      var n = loadAssetContainer(c, e, t, i, !0);
      return !!n;
    } catch (o) {
      var a = Gi("importScene", r ? r.producer : "Unknown") + s;
      if (i)
        i(a, o);
      else
        throw w.Log(a), o;
    } finally {
      s !== null && oe.loggingLevel !== oe.NO_LOGGING && w.Log(Gi("importScene", r ? r.producer : "Unknown") + (oe.loggingLevel !== oe.MINIMAL_LOGGING ? s : ""));
    }
    return !1;
  },
  loadAssetContainer: function(c, e, t, i) {
    var s = loadAssetContainer(c, e, t, i);
    return s;
  }
});
k._instancedMeshFactory = (c, e) => {
  const t = new pl(c, e);
  if (e.instancedBuffers) {
    t.instancedBuffers = {};
    for (const i in e.instancedBuffers)
      t.instancedBuffers[i] = e.instancedBuffers[i];
  }
  return t;
};
class pl extends at {
  constructor(e, t) {
    super(e, t.getScene()), this._indexInSourceMeshInstanceArray = -1, this._distanceToCamera = 0, t.addInstance(this), this._sourceMesh = t, this._unIndexed = t._unIndexed, this.position.copyFrom(t.position), this.rotation.copyFrom(t.rotation), this.scaling.copyFrom(t.scaling), t.rotationQuaternion && (this.rotationQuaternion = t.rotationQuaternion.clone()), this.animations = t.animations.slice();
    for (const i of t.getAnimationRanges())
      i != null && this.createAnimationRange(i.name, i.from, i.to);
    this.infiniteDistance = t.infiniteDistance, this.setPivotMatrix(t.getPivotMatrix()), this.refreshBoundingInfo(!0, !0), this._syncSubMeshes();
  }
  getClassName() {
    return "InstancedMesh";
  }
  get lightSources() {
    return this._sourceMesh._lightSources;
  }
  _resyncLightSources() {
  }
  _resyncLightSource() {
  }
  _removeLightSource() {
  }
  get receiveShadows() {
    return this._sourceMesh.receiveShadows;
  }
  get material() {
    return this._sourceMesh.material;
  }
  get visibility() {
    return this._sourceMesh.visibility;
  }
  get skeleton() {
    return this._sourceMesh.skeleton;
  }
  get renderingGroupId() {
    return this._sourceMesh.renderingGroupId;
  }
  set renderingGroupId(e) {
    !this._sourceMesh || e === this._sourceMesh.renderingGroupId || w.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene");
  }
  getTotalVertices() {
    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;
  }
  getTotalIndices() {
    return this._sourceMesh.getTotalIndices();
  }
  get sourceMesh() {
    return this._sourceMesh;
  }
  createInstance(e) {
    return this._sourceMesh.createInstance(e);
  }
  isReady(e = !1) {
    return this._sourceMesh.isReady(e, !0);
  }
  getVerticesData(e, t) {
    return this._sourceMesh.getVerticesData(e, t);
  }
  setVerticesData(e, t, i, s) {
    return this.sourceMesh && this.sourceMesh.setVerticesData(e, t, i, s), this.sourceMesh;
  }
  updateVerticesData(e, t, i, s) {
    return this.sourceMesh && this.sourceMesh.updateVerticesData(e, t, i, s), this.sourceMesh;
  }
  setIndices(e, t = null) {
    return this.sourceMesh && this.sourceMesh.setIndices(e, t), this.sourceMesh;
  }
  isVerticesDataPresent(e) {
    return this._sourceMesh.isVerticesDataPresent(e);
  }
  getIndices() {
    return this._sourceMesh.getIndices();
  }
  get _positions() {
    return this._sourceMesh._positions;
  }
  refreshBoundingInfo(e = !1, t = !1) {
    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked)
      return this;
    const i = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
    return this._refreshBoundingInfo(this._sourceMesh._getPositionData(e, t), i), this;
  }
  _preActivate() {
    return this._currentLOD && this._currentLOD._preActivate(), this;
  }
  _activate(e, t) {
    if (super._activate(e, t), this._sourceMesh.subMeshes || w.Warn("Instances should only be created for meshes with geometry."), this._currentLOD) {
      if (this._currentLOD._getWorldMatrixDeterminant() >= 0 != this._getWorldMatrixDeterminant() >= 0)
        return this._internalAbstractMeshDataInfo._actAsRegularMesh = !0, !0;
      if (this._internalAbstractMeshDataInfo._actAsRegularMesh = !1, this._currentLOD._registerInstanceForRenderId(this, e), t) {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate)
          return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = !0, !0;
      } else if (!this._currentLOD._internalAbstractMeshDataInfo._isActive)
        return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = !0, !0;
    }
    return !1;
  }
  _postActivate() {
    this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup ? (this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer), this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())) : this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup && this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);
  }
  getWorldMatrix() {
    if (this._currentLOD && this._currentLOD.billboardMode !== $.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
      this._billboardWorldMatrix || (this._billboardWorldMatrix = new x());
      const e = this._currentLOD._masterMesh;
      return this._currentLOD._masterMesh = this, D.Vector3[7].copyFrom(this._currentLOD.position), this._currentLOD.position.set(0, 0, 0), this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)), this._currentLOD.position.copyFrom(D.Vector3[7]), this._currentLOD._masterMesh = e, this._billboardWorldMatrix;
    }
    return super.getWorldMatrix();
  }
  get isAnInstance() {
    return !0;
  }
  getLOD(e) {
    if (!e)
      return this;
    const t = this.sourceMesh.getLODLevels();
    if (!t || t.length === 0)
      this._currentLOD = this.sourceMesh;
    else {
      const i = this.getBoundingInfo();
      this._currentLOD = this.sourceMesh.getLOD(e, i.boundingSphere);
    }
    return this._currentLOD;
  }
  _preActivateForIntermediateRendering(e) {
    return this.sourceMesh._preActivateForIntermediateRendering(e);
  }
  _syncSubMeshes() {
    if (this.releaseSubMeshes(), this._sourceMesh.subMeshes)
      for (let e = 0; e < this._sourceMesh.subMeshes.length; e++)
        this._sourceMesh.subMeshes[e].clone(this, this._sourceMesh);
    return this;
  }
  _generatePointsArray() {
    return this._sourceMesh._generatePointsArray();
  }
  _updateBoundingInfo() {
    return this.hasBoundingInfo ? this.getBoundingInfo().update(this.worldMatrixFromCache) : this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache), this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache), this;
  }
  clone(e, t = null, i, s) {
    const r = (s || this._sourceMesh).createInstance(e);
    if (ws.DeepCopy(this, r, [
      "name",
      "subMeshes",
      "uniqueId",
      "parent",
      "lightSources",
      "receiveShadows",
      "material",
      "visibility",
      "skeleton",
      "sourceMesh",
      "isAnInstance",
      "facetNb",
      "isFacetDataEnabled",
      "isBlocked",
      "useBones",
      "hasInstances",
      "collider",
      "edgesRenderer",
      "forward",
      "up",
      "right",
      "absolutePosition",
      "absoluteScaling",
      "absoluteRotationQuaternion",
      "isWorldMatrixFrozen",
      "nonUniformScaling",
      "behaviors",
      "worldMatrixFromCache",
      "hasThinInstances",
      "hasBoundingInfo"
    ], []), this.refreshBoundingInfo(), t && (r.parent = t), !i)
      for (let n = 0; n < this.getScene().meshes.length; n++) {
        const a = this.getScene().meshes[n];
        a.parent === this && a.clone(a.name, r);
      }
    return r.computeWorldMatrix(!0), this.onClonedObservable.notifyObservers(r), r;
  }
  dispose(e, t = !1) {
    this._sourceMesh.removeInstance(this), super.dispose(e, t);
  }
  _serializeAsParent(e) {
    super._serializeAsParent(e), e.parentId = this._sourceMesh.uniqueId, e.parentInstanceIndex = this._indexInSourceMeshInstanceArray;
  }
  instantiateHierarchy(e = null, t, i) {
    const s = this.clone("Clone of " + (this.name || this.id), e || this.parent, !0, t && t.newSourcedMesh);
    s && i && i(this, s);
    for (const r of this.getChildTransformNodes(!0))
      r.instantiateHierarchy(s, t, i);
    return s;
  }
}
k.prototype.registerInstancedBuffer = function(c, e) {
  var t, i;
  if ((i = (t = this._userInstancedBuffersStorage) == null ? void 0 : t.vertexBuffers[c]) == null || i.dispose(), !this.instancedBuffers) {
    this.instancedBuffers = {};
    for (const s of this.instances)
      s.instancedBuffers = {};
    this._userInstancedBuffersStorage || (this._userInstancedBuffersStorage = {
      data: {},
      vertexBuffers: {},
      strides: {},
      sizes: {},
      vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
    });
  }
  this.instancedBuffers[c] = null, this._userInstancedBuffersStorage.strides[c] = e, this._userInstancedBuffersStorage.sizes[c] = e * 32, this._userInstancedBuffersStorage.data[c] = new Float32Array(this._userInstancedBuffersStorage.sizes[c]), this._userInstancedBuffersStorage.vertexBuffers[c] = new p(this.getEngine(), this._userInstancedBuffersStorage.data[c], c, !0, !1, e, !0);
  for (const s of this.instances)
    s.instancedBuffers[c] = null;
  this._invalidateInstanceVertexArrayObject(), this._markSubMeshesAsAttributesDirty();
};
k.prototype._processInstancedBuffers = function(c, e) {
  const t = c.length;
  for (const i in this.instancedBuffers) {
    let s = this._userInstancedBuffersStorage.sizes[i];
    const r = this._userInstancedBuffersStorage.strides[i], n = (t + 1) * r;
    for (; s < n; )
      s *= 2;
    this._userInstancedBuffersStorage.data[i].length != s && (this._userInstancedBuffersStorage.data[i] = new Float32Array(s), this._userInstancedBuffersStorage.sizes[i] = s, this._userInstancedBuffersStorage.vertexBuffers[i] && (this._userInstancedBuffersStorage.vertexBuffers[i].dispose(), this._userInstancedBuffersStorage.vertexBuffers[i] = null));
    const a = this._userInstancedBuffersStorage.data[i];
    let o = 0;
    if (e) {
      const h = this.instancedBuffers[i];
      h.toArray ? h.toArray(a, o) : h.copyToArray ? h.copyToArray(a, o) : a[o] = h, o += r;
    }
    for (let h = 0; h < t; h++) {
      const u = c[h].instancedBuffers[i];
      u.toArray ? u.toArray(a, o) : u.copyToArray ? u.copyToArray(a, o) : a[o] = u, o += r;
    }
    this._userInstancedBuffersStorage.vertexBuffers[i] ? this._userInstancedBuffersStorage.vertexBuffers[i].updateDirectly(a, 0) : (this._userInstancedBuffersStorage.vertexBuffers[i] = new p(this.getEngine(), this._userInstancedBuffersStorage.data[i], i, !0, !1, r, !0), this._invalidateInstanceVertexArrayObject());
  }
};
k.prototype._invalidateInstanceVertexArrayObject = function() {
  if (!(!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === void 0)) {
    for (const c in this._userInstancedBuffersStorage.vertexArrayObjects)
      this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[c]);
    this._userInstancedBuffersStorage.vertexArrayObjects = {};
  }
};
k.prototype._disposeInstanceSpecificData = function() {
  for (this._instanceDataStorage.instancesBuffer && (this._instanceDataStorage.instancesBuffer.dispose(), this._instanceDataStorage.instancesBuffer = null); this.instances.length; )
    this.instances[0].dispose();
  for (const c in this.instancedBuffers)
    this._userInstancedBuffersStorage.vertexBuffers[c] && this._userInstancedBuffersStorage.vertexBuffers[c].dispose();
  this._invalidateInstanceVertexArrayObject(), this.instancedBuffers = {};
};
const ml = {
  assetPath: "",
  enableShadows: !1,
  groupId: null,
  id: null,
  lights: [],
  rollId: null,
  scene: null
}, Lt = class {
  constructor(e, t) {
    _t(this, "value", 0);
    _t(this, "asleep", !1);
    this.config = { ...ml, ...e }, this.id = this.config.id !== void 0 ? this.config.id : Date.now(), this.dieType = `d${this.config.sides}`, this.comboKey = `${this.config.theme}_${this.dieType}`, this.scene = t, this.createInstance();
  }
  createInstance() {
    const e = `${this.config.meshName}_${this.dieType}_${this.config.theme}${this.config.colorSuffix}`, t = `${e}-instance-${this.id}`, i = this.scene.getMeshByName(e).createInstance(t);
    if (this.config.colorSuffix.length > 0) {
      const s = te.FromHexString(this.config.themeColor);
      i.instancedBuffers.customColor = s;
    }
    i.position.y = -100, i.scaling = new g(this.config.scale, this.config.scale, this.config.scale), this.config.enableShadows && this.config.lights.directional.shadowGenerator.addShadowCaster(i), this.mesh = i;
  }
  static async loadDie(e, t) {
    const { sides: i, theme: s = "default", meshName: r, colorSuffix: n } = e, a = r + "_d" + i, o = a + "_" + s + n;
    let h = t.getMeshByName(o);
    return h || (h = t.getMeshByName(a).clone(o)), h.material || (h.material = t.getMaterialByName(s + n), n.length > 0 && h.registerInstancedBuffer("customColor", 3)), e;
  }
  static async loadModels(e, t) {
    const { meshFilePath: i, meshName: s, scale: r, d4FaceDown: n = !0 } = e;
    let a = !1, o = !1;
    const h = await fetch(`${i}`).then((l) => {
      if (l.ok) {
        const u = l.headers.get("content-type");
        if (u && u.indexOf("application/json") !== -1)
          return l.json();
        if (l.type && l.type === "basic")
          return l.json();
        throw new Error(`Incorrect contentType: ${u}. Expected "application/json" or "basic"`);
      } else
        throw new Error(`Unable to load 3D mesh file: '${i}'. Request rejected with status ${l.status}: ${l.statusText}`);
    }).catch((l) => console.error(l));
    if (!!h)
      return oe.ImportMeshAsync(null, null, "data:" + JSON.stringify(h), t).then((l) => {
        if (l.meshes.forEach((u) => {
          u.name === "__root__" && u.dispose(), u.name.includes("collider") && (u.scaling = new g(0.9, 0.9, 0.9)), a || (a = u.name === "d100"), o || (o = u.name === "d10"), u.setEnabled(!1), u.freezeNormals(), u.freezeWorldMatrix(), u.isPickable = !1, u.doNotSyncBoundingInfo = !0, u.name = s + "_" + u.name;
        }), !a && o && (t.getMeshByName(s + "_d10").clone(s + "_d100"), t.getMeshByName(s + "_d10_collider").clone(s + "_d100_collider"), h.colliderFaceMap && (h.colliderFaceMap.d100 = dr(h.colliderFaceMap.d10), Object.values(h.colliderFaceMap.d100).forEach((u, f) => {
          h.colliderFaceMap.d100[f] = u * (u === 10 ? 0 : 10);
        }))), !h.colliderFaceMap)
          throw new Error(`'colliderFaceMap' data not found in ${i}. Without the colliderFaceMap data dice values can not be resolved.`);
        t.themeData[s] = {}, t.themeData[s].colliderFaceMap = h.colliderFaceMap, t.themeData[s].d4FaceDown = n;
      }).catch((l) => console.error(l)), h.meshes.filter((l) => l.name.includes("collider"));
  }
  updateConfig(e) {
    this.config = { ...this.config, ...e };
  }
  static setVector3(e, t, i) {
    return Lt.vector3.set(e, t, i);
  }
  static getVector3() {
    return Lt.vector3;
  }
  static async getRollResult(e, t) {
    const i = (s = e) => new Promise((r, n) => {
      const a = e.config.parentMesh || e.config.meshName, o = t.themeData[a].colliderFaceMap, h = t.themeData[a].d4FaceDown;
      if (!o[s.dieType])
        throw new Error(`No colliderFaceMap data for ${s.dieType}`);
      const l = t.getMeshByName(`${a}_${s.dieType}_collider`).createInstance(`${a}_${s.dieType}-hitbox-${s.id}`);
      l.isPickable = !0, l.isVisible = !0, l.setEnabled(!0), l.position = s.mesh.position, l.rotationQuaternion = s.mesh.rotationQuaternion;
      let u = Lt.setVector3(0, 1, 0);
      s.dieType === "d4" && h && (u = Lt.setVector3(0, -1, 0)), Lt.ray.direction = u, Lt.ray.origin = e.mesh.position;
      const f = t.pickWithRay(Lt.ray);
      if (l.dispose(), s.value = o[s.dieType][f.faceId], s.value === void 0)
        throw new Error(`colliderFaceMap Error: No value found for ${s.dieType} mesh face ${f.faceId}`);
      return r(s.value);
    }).catch((r) => console.error(r));
    return e.mesh ? await i() : e.value;
  }
};
let Rt = Lt;
_t(Rt, "ray", new de(g.Zero(), g.Zero(), 1)), _t(Rt, "vector3", new g.Zero());
class El {
  constructor() {
  }
}
class $t extends O {
  constructor(e, t) {
    super(e, t), this.CustomParts = new El(), this.customShaderNameResolve = this.Builder, this.FragmentShader = De.ShadersStore.defaultPixelShader, this.VertexShader = De.ShadersStore.defaultVertexShader;
  }
  AttachAfterBind(e, t) {
    if (this._newUniformInstances)
      for (const i in this._newUniformInstances) {
        const s = i.toString().split("-");
        s[0] == "vec2" ? t.setVector2(s[1], this._newUniformInstances[i]) : s[0] == "vec3" ? t.setVector3(s[1], this._newUniformInstances[i]) : s[0] == "vec4" ? t.setVector4(s[1], this._newUniformInstances[i]) : s[0] == "mat4" ? t.setMatrix(s[1], this._newUniformInstances[i]) : s[0] == "float" && t.setFloat(s[1], this._newUniformInstances[i]);
      }
    if (this._newSamplerInstances)
      for (const i in this._newSamplerInstances) {
        const s = i.toString().split("-");
        s[0] == "sampler2D" && this._newSamplerInstances[i].isReady && this._newSamplerInstances[i].isReady() && t.setTexture(s[1], this._newSamplerInstances[i]);
      }
  }
  ReviewUniform(e, t) {
    if (e == "uniform" && this._newUniforms)
      for (let i = 0; i < this._newUniforms.length; i++)
        this._customUniform[i].indexOf("sampler") == -1 && t.push(this._newUniforms[i]);
    if (e == "sampler" && this._newUniforms)
      for (let i = 0; i < this._newUniforms.length; i++)
        this._customUniform[i].indexOf("sampler") != -1 && t.push(this._newUniforms[i]);
    return t;
  }
  Builder(e, t, i, s, r, n) {
    if (n && this._customAttributes && this._customAttributes.length > 0 && n.push(...this._customAttributes), this.ReviewUniform("uniform", t), this.ReviewUniform("sampler", s), this._isCreatedShader)
      return this._createdShaderName;
    this._isCreatedShader = !1, $t.ShaderIndexer++;
    const a = "custom_" + $t.ShaderIndexer, o = this._afterBind.bind(this);
    return this._afterBind = (h, l) => {
      if (!!l) {
        this.AttachAfterBind(h, l);
        try {
          o(h, l);
        } catch {
        }
      }
    }, De.ShadersStore[a + "VertexShader"] = this.VertexShader.replace("#define CUSTOM_VERTEX_BEGIN", this.CustomParts.Vertex_Begin ? this.CustomParts.Vertex_Begin : "").replace("#define CUSTOM_VERTEX_DEFINITIONS", (this._customUniform ? this._customUniform.join(`
`) : "") + (this.CustomParts.Vertex_Definitions ? this.CustomParts.Vertex_Definitions : "")).replace("#define CUSTOM_VERTEX_MAIN_BEGIN", this.CustomParts.Vertex_MainBegin ? this.CustomParts.Vertex_MainBegin : "").replace("#define CUSTOM_VERTEX_UPDATE_POSITION", this.CustomParts.Vertex_Before_PositionUpdated ? this.CustomParts.Vertex_Before_PositionUpdated : "").replace("#define CUSTOM_VERTEX_UPDATE_NORMAL", this.CustomParts.Vertex_Before_NormalUpdated ? this.CustomParts.Vertex_Before_NormalUpdated : "").replace("#define CUSTOM_VERTEX_MAIN_END", this.CustomParts.Vertex_MainEnd ? this.CustomParts.Vertex_MainEnd : ""), this.CustomParts.Vertex_After_WorldPosComputed && (De.ShadersStore[a + "VertexShader"] = De.ShadersStore[a + "VertexShader"].replace("#define CUSTOM_VERTEX_UPDATE_WORLDPOS", this.CustomParts.Vertex_After_WorldPosComputed)), De.ShadersStore[a + "PixelShader"] = this.FragmentShader.replace("#define CUSTOM_FRAGMENT_BEGIN", this.CustomParts.Fragment_Begin ? this.CustomParts.Fragment_Begin : "").replace("#define CUSTOM_FRAGMENT_MAIN_BEGIN", this.CustomParts.Fragment_MainBegin ? this.CustomParts.Fragment_MainBegin : "").replace("#define CUSTOM_FRAGMENT_DEFINITIONS", (this._customUniform ? this._customUniform.join(`
`) : "") + (this.CustomParts.Fragment_Definitions ? this.CustomParts.Fragment_Definitions : "")).replace("#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE", this.CustomParts.Fragment_Custom_Diffuse ? this.CustomParts.Fragment_Custom_Diffuse : "").replace("#define CUSTOM_FRAGMENT_UPDATE_ALPHA", this.CustomParts.Fragment_Custom_Alpha ? this.CustomParts.Fragment_Custom_Alpha : "").replace("#define CUSTOM_FRAGMENT_BEFORE_LIGHTS", this.CustomParts.Fragment_Before_Lights ? this.CustomParts.Fragment_Before_Lights : "").replace("#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR", this.CustomParts.Fragment_Before_FragColor ? this.CustomParts.Fragment_Before_FragColor : "").replace("#define CUSTOM_FRAGMENT_MAIN_END", this.CustomParts.Fragment_MainEnd ? this.CustomParts.Fragment_MainEnd : ""), this.CustomParts.Fragment_Before_Fog && (De.ShadersStore[a + "PixelShader"] = De.ShadersStore[a + "PixelShader"].replace("#define CUSTOM_FRAGMENT_BEFORE_FOG", this.CustomParts.Fragment_Before_Fog)), this._isCreatedShader = !0, this._createdShaderName = a, a;
  }
  AddUniform(e, t, i) {
    return this._customUniform || (this._customUniform = new Array(), this._newUniforms = new Array(), this._newSamplerInstances = {}, this._newUniformInstances = {}), i && (t.indexOf("sampler") != -1 ? this._newSamplerInstances[t + "-" + e] = i : this._newUniformInstances[t + "-" + e] = i), this._customUniform.push("uniform " + t + " " + e + ";"), this._newUniforms.push(e), this;
  }
  AddAttribute(e) {
    return this._customAttributes || (this._customAttributes = []), this._customAttributes.push(e), this;
  }
  Fragment_Begin(e) {
    return this.CustomParts.Fragment_Begin = e, this;
  }
  Fragment_Definitions(e) {
    return this.CustomParts.Fragment_Definitions = e, this;
  }
  Fragment_MainBegin(e) {
    return this.CustomParts.Fragment_MainBegin = e, this;
  }
  Fragment_MainEnd(e) {
    return this.CustomParts.Fragment_MainEnd = e, this;
  }
  Fragment_Custom_Diffuse(e) {
    return this.CustomParts.Fragment_Custom_Diffuse = e.replace("result", "diffuseColor"), this;
  }
  Fragment_Custom_Alpha(e) {
    return this.CustomParts.Fragment_Custom_Alpha = e.replace("result", "alpha"), this;
  }
  Fragment_Before_Lights(e) {
    return this.CustomParts.Fragment_Before_Lights = e, this;
  }
  Fragment_Before_Fog(e) {
    return this.CustomParts.Fragment_Before_Fog = e, this;
  }
  Fragment_Before_FragColor(e) {
    return this.CustomParts.Fragment_Before_FragColor = e.replace("result", "color"), this;
  }
  Vertex_Begin(e) {
    return this.CustomParts.Vertex_Begin = e, this;
  }
  Vertex_Definitions(e) {
    return this.CustomParts.Vertex_Definitions = e, this;
  }
  Vertex_MainBegin(e) {
    return this.CustomParts.Vertex_MainBegin = e, this;
  }
  Vertex_Before_PositionUpdated(e) {
    return this.CustomParts.Vertex_Before_PositionUpdated = e.replace("result", "positionUpdated"), this;
  }
  Vertex_Before_NormalUpdated(e) {
    return this.CustomParts.Vertex_Before_NormalUpdated = e.replace("result", "normalUpdated"), this;
  }
  Vertex_After_WorldPosComputed(e) {
    return this.CustomParts.Vertex_After_WorldPosComputed = e, this;
  }
  Vertex_MainEnd(e) {
    return this.CustomParts.Vertex_MainEnd = e, this;
  }
}
$t.ShaderIndexer = 1;
it("BABYLON.CustomMaterial", $t);
$t.prototype.clone = function(c) {
  const e = this, t = ne.Clone(() => new $t(c, this.getScene()), this);
  return t.name = c, t.id = c, t.CustomParts.Fragment_Begin = e.CustomParts.Fragment_Begin, t.CustomParts.Fragment_Definitions = e.CustomParts.Fragment_Definitions, t.CustomParts.Fragment_MainBegin = e.CustomParts.Fragment_MainBegin, t.CustomParts.Fragment_Custom_Diffuse = e.CustomParts.Fragment_Custom_Diffuse, t.CustomParts.Fragment_Before_Lights = e.CustomParts.Fragment_Before_Lights, t.CustomParts.Fragment_Before_Fog = e.CustomParts.Fragment_Before_Fog, t.CustomParts.Fragment_Custom_Alpha = e.CustomParts.Fragment_Custom_Alpha, t.CustomParts.Fragment_Before_FragColor = e.CustomParts.Fragment_Before_FragColor, t.CustomParts.Vertex_Begin = e.CustomParts.Vertex_Begin, t.CustomParts.Vertex_Definitions = e.CustomParts.Vertex_Definitions, t.CustomParts.Vertex_MainBegin = e.CustomParts.Vertex_MainBegin, t.CustomParts.Vertex_Before_PositionUpdated = e.CustomParts.Vertex_Before_PositionUpdated, t.CustomParts.Vertex_Before_NormalUpdated = e.CustomParts.Vertex_Before_NormalUpdated, t.CustomParts.Vertex_After_WorldPosComputed = e.CustomParts.Vertex_After_WorldPosComputed, t.CustomParts.Vertex_MainEnd = e.CustomParts.Vertex_MainEnd, t;
};
class Tl {
  constructor(e) {
    _t(this, "loadedThemes", {});
    _t(this, "themeData", {});
    this.scene = e.scene;
  }
  async loadStandardMaterial(e) {
    const { theme: t, material: i } = e, s = new O(t, this.scene);
    i.diffuseTexture && (s.diffuseTexture = await this.getTexture("diffuse", e)), i.bumpTexture && (s.bumpTexture = await this.getTexture("bump", e)), i.specularTexture && (s.specularTexture = await this.getTexture("specular", e)), s.allowShaderHotSwapping = !1;
  }
  async loadColorMaterial(e) {
    const { theme: t, material: i } = e, s = new $t(t + "_light", this.scene), r = dr(e);
    i.diffuseTexture && i.diffuseTexture.light && (r.material.diffuseTexture = e.material.diffuseTexture.light, s.diffuseTexture = await this.getTexture("diffuse", r)), i.bumpTexture && (s.bumpTexture = await this.getTexture("bump", e)), i.specularTexture && (s.specularTexture = await this.getTexture("specular", e)), s.allowShaderHotSwapping = !1, s.Vertex_Definitions(`
      attribute vec3 customColor;
      varying vec3 vColor;
    `).Vertex_MainEnd(`
      vColor = customColor;
    `).Fragment_Definitions(`
      varying vec3 vColor;
    `).Fragment_Custom_Diffuse(`
      baseColor.rgb = mix(vColor.rgb, baseColor.rgb, baseColor.a);
    `), s.AddAttribute("customColor");
    const n = s.clone(t + "_dark");
    i.diffuseTexture && i.diffuseTexture.dark && (r.material.diffuseTexture = e.material.diffuseTexture.dark, n.diffuseTexture = await this.getTexture("diffuse", r)), n.AddAttribute("customColor");
  }
  async getTexture(e, t) {
    const { basePath: i, material: s, theme: r } = t;
    let n;
    const a = e + "Level", o = e + "Texture";
    try {
      switch (e) {
        case "diffuse":
          n = await this.importTextureAsync(`${i}/${s[o]}`, r), s[a] && (n.level = s[a]);
          break;
        case "bump":
          n = await this.importTextureAsync(`${i}/${s[o]}`, r), s[a] && (n.level = s[a]);
          break;
        case "specular":
          n = await this.importTextureAsync(`${i}/${s[o]}`, r), s.specularPower && (n.specularPower = s.specularPower);
          break;
        default:
          throw new Error(`Texture type: ${e} is not supported`);
      }
    } catch (h) {
      console.error(h);
    }
    return n;
  }
  async importTextureAsync(e, t) {
    return new Promise((i, s) => {
      let r = e.match(/^(.*\/)(.*)$/), n = new B(
        e,
        this.scene,
        void 0,
        !0,
        void 0,
        () => i(n),
        () => s(`Unable to load texture '${r[2]}' for theme: '${t}'. Check that your assetPath is configured correctly and that the files exist at path: '${r[1]}'`)
      );
    }).catch((i) => console.error(i));
  }
  async load(e) {
    const { material: t } = e;
    t.type === "color" ? await this.loadColorMaterial(e) : t.type === "standard" ? await this.loadStandardMaterial(e) : console.error(`Material type: ${t.type} not supported`);
  }
}
var We, Ei, At, Ti, St, gt, qe, is, bt, Pi, Di, ht, Fi, ss, Fr;
class xl {
  constructor(e) {
    Je(this, ss);
    _t(this, "config");
    _t(this, "initialized", !1);
    Je(this, We, {});
    Je(this, Ei, 0);
    Je(this, At, 0);
    Je(this, Ti, []);
    Je(this, St, void 0);
    Je(this, gt, void 0);
    Je(this, qe, void 0);
    Je(this, is, void 0);
    Je(this, bt, void 0);
    Je(this, Pi, void 0);
    Je(this, Di, void 0);
    Je(this, ht, void 0);
    Je(this, Fi, {});
    _t(this, "noop", () => {
    });
    _t(this, "diceBufferView", new Float32Array(8e3));
    this.onInitComplete = e.onInitComplete || this.noop, this.onThemeLoaded = e.onThemeLoaded || this.noop, this.onRollResult = e.onRollResult || this.noop, this.onRollComplete = e.onRollComplete || this.noop, this.onDieRemoved = e.onDieRemoved || this.noop, this.initialized = this.initScene(e);
  }
  async initScene(e) {
    rt(this, St, e.canvas), K(this, St).width = e.width, K(this, St).height = e.height, this.config = e.options, rt(this, gt, sn(K(this, St))), rt(this, qe, Bn({ engine: K(this, gt) })), rt(this, is, Un({ engine: K(this, gt), scene: K(this, qe) })), rt(this, bt, ur({
      enableShadows: this.config.enableShadows,
      shadowTransparency: this.config.shadowTransparency,
      intensity: this.config.lightIntensity,
      scene: K(this, qe)
    })), rt(this, Pi, new _l({
      enableShadows: this.config.enableShadows,
      aspect: K(this, St).width / K(this, St).height,
      lights: K(this, bt),
      scene: K(this, qe)
    })), rt(this, Di, new Tl({ scene: K(this, qe) })), this.onInitComplete();
  }
  connect(e) {
    rt(this, ht, e), K(this, ht).postMessage({
      action: "initBuffer",
      diceBuffer: this.diceBufferView.buffer
    }, [this.diceBufferView.buffer]), K(this, ht).onmessage = (t) => {
      switch (t.data.action) {
        case "updates":
          this.updatesFromPhysics(t.data.diceBuffer);
          break;
        default:
          console.error("action from physicsWorker not found in offscreen worker");
          break;
      }
    };
  }
  updateConfig(e) {
    const t = this.config;
    this.config = e, t.enableShadows !== this.config.enableShadows && (Object.values(K(this, bt)).forEach((i) => i.dispose()), rt(this, bt, ur({ enableShadows: this.config.enableShadows }))), t.scale !== this.config.scale && Object.values(K(this, We)).forEach(({ mesh: i }) => {
      i && (i.scaling = new g(this.config.scale, this.config.scale, this.config.scale));
    }), t.shadowTransparency !== this.config.shadowTransparency && (K(this, bt).directional.shadowGenerator.darkness = this.config.shadowTransparency), t.lightIntensity !== this.config.lightIntensity && (K(this, bt).directional.intensity = 0.65 * this.config.lightIntensity, K(this, bt).hemispheric.intensity = 0.4 * this.config.lightIntensity);
  }
  render(e) {
    K(this, gt).runRenderLoop(this.renderLoop.bind(this)), K(this, ht).postMessage({
      action: "resumeSimulation",
      newStartPoint: e
    });
  }
  renderLoop() {
    K(this, At) && K(this, At) === Object.keys(K(this, We)).length ? (K(this, gt).stopRenderLoop(), K(this, ht).postMessage({
      action: "stopSimulation"
    }), this.onRollComplete()) : K(this, qe).render();
  }
  async loadTheme(e) {
    const { theme: t, basePath: i, material: s, meshFilePath: r, meshName: n } = e;
    if (await K(this, Di).load({ theme: t, basePath: i, material: s }), !Object.keys(K(this, Fi)).includes(n)) {
      K(this, Fi)[n] = r;
      const a = await Rt.loadModels({ meshFilePath: r, meshName: n }, K(this, qe));
      if (!a)
        throw new Error("No colliders returned from the 3D mesh file. Low poly colliders are expected to be in the same file as the high poly dice and the mesh name contains the word 'collider'");
      K(this, ht).postMessage({
        action: "loadModels",
        options: {
          colliders: a,
          meshName: n
        }
      });
    }
    this.onThemeLoaded({ id: t });
  }
  clear() {
    !Object.keys(K(this, We)).length && !K(this, At) || (this.diceBufferView.byteLength && this.diceBufferView.fill(0), K(this, Ti).forEach((e) => clearTimeout(e)), K(this, gt).stopRenderLoop(), Object.values(K(this, We)).forEach((e) => {
      e.mesh && e.mesh.dispose();
    }), rt(this, We, {}), rt(this, Ei, 0), rt(this, At, 0), K(this, qe).render());
  }
  add(e) {
    Rt.loadDie(e, K(this, qe)).then((t) => {
      K(this, Ti).push(setTimeout(() => {
        Xs(this, ss, Fr).call(this, t);
      }, ui(this, Ei)._++ * this.config.delay));
    });
  }
  addNonDie(e) {
    K(this, gt).activeRenderLoops.length === 0 && this.render(!1);
    const { id: t, value: i, ...s } = e, r = {
      id: t,
      value: i,
      config: s
    };
    K(this, We)[t] = r, setTimeout(() => {
      K(this, Ti).push(setTimeout(() => {
        this.handleAsleep(r);
      }, ui(this, Ei)._++ * this.config.delay));
    }, 10);
  }
  remove(e) {
    const t = K(this, We)[e.id];
    t.hasOwnProperty("d10Instance") && (K(this, We)[t.d10Instance.id].mesh && (K(this, We)[t.d10Instance.id].mesh.dispose(), K(this, ht).postMessage({
      action: "removeDie",
      id: t.d10Instance.id
    })), delete K(this, We)[t.d10Instance.id], ui(this, At)._--), K(this, We)[e.id].mesh && K(this, We)[e.id].mesh.dispose(), delete K(this, We)[e.id], ui(this, At)._--, K(this, qe).render(), this.onDieRemoved(e.rollId);
  }
  updatesFromPhysics(e) {
    this.diceBufferView = new Float32Array(e);
    let t = 1;
    for (let i = 0, s = this.diceBufferView[0]; i < s; i++) {
      if (!Object.keys(K(this, We)).length)
        continue;
      const r = K(this, We)[`${this.diceBufferView[t]}`];
      if (!r) {
        console.log("Error: die not available in scene to animate");
        break;
      }
      if (this.diceBufferView[t + 1] === -1)
        this.handleAsleep(r);
      else {
        const n = this.diceBufferView[t + 1], a = this.diceBufferView[t + 2], o = this.diceBufferView[t + 3], h = this.diceBufferView[t + 4], l = this.diceBufferView[t + 5], u = this.diceBufferView[t + 6], f = this.diceBufferView[t + 7];
        r.mesh.position.set(n, a, o), r.mesh.rotationQuaternion.set(h, l, u, f);
      }
      t = t + 8;
    }
    requestAnimationFrame(() => {
      K(this, ht).postMessage({
        action: "stepSimulation",
        diceBuffer: this.diceBufferView.buffer
      }, [this.diceBufferView.buffer]);
    });
  }
  async handleAsleep(e) {
    var t, i;
    if (e.asleep = !0, await Rt.getRollResult(e, K(this, qe)), e.d10Instance || e.dieParent) {
      if (((t = e == null ? void 0 : e.d10Instance) == null ? void 0 : t.asleep) || ((i = e == null ? void 0 : e.dieParent) == null ? void 0 : i.asleep)) {
        const s = e.config.sides === 100 ? e : e.dieParent, r = e.config.sides === 10 ? e : e.d10Instance;
        r.value === 0 && s.value === 0 ? s.value = 100 : s.value = s.value + r.value, this.onRollResult({
          rollId: s.config.rollId,
          value: s.value
        });
      }
    } else
      e.config.sides === 10 && e.value === 0 && (e.value = 10), this.onRollResult({
        rollId: e.config.rollId,
        value: e.value
      });
    ui(this, At)._++;
  }
  resize(e) {
    const t = K(this, St).width = e.width, i = K(this, St).height = e.height;
    K(this, Pi).create({ aspect: t / i }), K(this, gt).resize();
  }
}
We = new WeakMap(), Ei = new WeakMap(), At = new WeakMap(), Ti = new WeakMap(), St = new WeakMap(), gt = new WeakMap(), qe = new WeakMap(), is = new WeakMap(), bt = new WeakMap(), Pi = new WeakMap(), Di = new WeakMap(), ht = new WeakMap(), Fi = new WeakMap(), ss = new WeakSet(), Fr = async function(e) {
  K(this, gt).activeRenderLoops.length === 0 && this.render(e.newStartPoint);
  const t = {
    ...e,
    assetPath: this.config.assetPath,
    enableShadows: this.config.enableShadows,
    scale: this.config.scale,
    lights: K(this, bt)
  }, i = new Rt(t, K(this, qe));
  return K(this, We)[i.id] = i, K(this, ht).postMessage({
    action: "addDie",
    options: {
      sides: e.sides,
      scale: this.config.scale,
      id: i.id,
      newStartPoint: e.newStartPoint,
      theme: e.theme,
      meshName: e.meshName
    }
  }), e.sides === 100 && (i.d10Instance = await Rt.loadDie({ ...t, sides: 10, id: i.id + 1e4 }, K(this, qe)).then((s) => {
    const r = new Rt(s, K(this, qe));
    return r.dieParent = i, r;
  }), K(this, We)[`${i.d10Instance.id}`] = i.d10Instance, K(this, ht).postMessage({
    action: "addDie",
    options: {
      sides: 10,
      scale: this.config.scale,
      id: i.d10Instance.id,
      theme: e.theme,
      meshName: e.meshName
    }
  })), i;
};
export {
  xl as default
};
