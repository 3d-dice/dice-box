var Tn = Object.defineProperty;
var Sn = (i, e, t) => e in i ? Tn(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var Xe = (i, e, t) => (Sn(i, typeof e != "symbol" ? e + "" : e, t), t), Wr = (i, e, t) => {
  if (!e.has(i))
    throw TypeError("Cannot " + t);
};
var V = (i, e, t) => (Wr(i, e, "read from private field"), t ? t.call(i) : e.get(i)), Oe = (i, e, t) => {
  if (e.has(i))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(i) : e.set(i, t);
}, Ue = (i, e, t, r) => (Wr(i, e, "write to private field"), r ? r.call(i, t) : e.set(i, t), t), It = (i, e, t, r) => ({
  set _(n) {
    Ue(i, e, n, t);
  },
  get _() {
    return V(i, e, r);
  }
}), bi = (i, e, t) => (Wr(i, e, "access private method"), t);
import { d as qi } from "./dice-box.es.js";
var J = function() {
  function i() {
  }
  return i.WithinEpsilon = function(e, t, r) {
    return r === void 0 && (r = 1401298e-51), Math.abs(e - t) <= r;
  }, i.ToHex = function(e) {
    var t = e.toString(16);
    return e <= 15 ? ("0" + t).toUpperCase() : t.toUpperCase();
  }, i.Sign = function(e) {
    return e = +e, e === 0 || isNaN(e) ? e : e > 0 ? 1 : -1;
  }, i.Clamp = function(e, t, r) {
    return t === void 0 && (t = 0), r === void 0 && (r = 1), Math.min(r, Math.max(t, e));
  }, i.Log2 = function(e) {
    return Math.log(e) * Math.LOG2E;
  }, i.ILog2 = function(e) {
    if (Math.log2)
      return Math.floor(Math.log2(e));
    if (e < 0)
      return NaN;
    if (e === 0)
      return -1 / 0;
    var t = 0;
    if (e < 1) {
      for (; e < 1; )
        t++, e = e * 2;
      t = -t;
    } else if (e > 1)
      for (; e > 1; )
        t++, e = Math.floor(e / 2);
    return t;
  }, i.Repeat = function(e, t) {
    return e - Math.floor(e / t) * t;
  }, i.Normalize = function(e, t, r) {
    return (e - t) / (r - t);
  }, i.Denormalize = function(e, t, r) {
    return e * (r - t) + t;
  }, i.DeltaAngle = function(e, t) {
    var r = i.Repeat(t - e, 360);
    return r > 180 && (r -= 360), r;
  }, i.PingPong = function(e, t) {
    var r = i.Repeat(e, t * 2);
    return t - Math.abs(r - t);
  }, i.SmoothStep = function(e, t, r) {
    var n = i.Clamp(r);
    return n = -2 * n * n * n + 3 * n * n, t * n + e * (1 - n);
  }, i.MoveTowards = function(e, t, r) {
    var n = 0;
    return Math.abs(t - e) <= r ? n = t : n = e + i.Sign(t - e) * r, n;
  }, i.MoveTowardsAngle = function(e, t, r) {
    var n = i.DeltaAngle(e, t), a = 0;
    return -r < n && n < r ? a = t : (t = e + n, a = i.MoveTowards(e, t, r)), a;
  }, i.Lerp = function(e, t, r) {
    return e + (t - e) * r;
  }, i.LerpAngle = function(e, t, r) {
    var n = i.Repeat(t - e, 360);
    return n > 180 && (n -= 360), e + n * i.Clamp(r);
  }, i.InverseLerp = function(e, t, r) {
    var n = 0;
    return e != t ? n = i.Clamp((r - e) / (t - e)) : n = 0, n;
  }, i.Hermite = function(e, t, r, n, a) {
    var s = a * a, o = a * s, u = 2 * o - 3 * s + 1, f = -2 * o + 3 * s, l = o - 2 * s + a, h = o - s;
    return e * u + r * f + t * l + n * h;
  }, i.Hermite1stDerivative = function(e, t, r, n, a) {
    var s = a * a;
    return (s - a) * 6 * e + (3 * s - 4 * a + 1) * t + (-s + a) * 6 * r + (3 * s - 2 * a) * n;
  }, i.RandomRange = function(e, t) {
    return e === t ? e : Math.random() * (t - e) + e;
  }, i.RangeToPercent = function(e, t, r) {
    return (e - t) / (r - t);
  }, i.PercentToRange = function(e, t, r) {
    return (r - t) * e + t;
  }, i.NormalizeRadians = function(e) {
    return e -= i.TwoPi * Math.floor((e + Math.PI) / i.TwoPi), e;
  }, i.HCF = function(e, t) {
    var r = e % t;
    return r === 0 ? t : i.HCF(t, r);
  }, i.TwoPi = Math.PI * 2, i;
}(), Lt = 1 / 2.2, Nt = 2.2, ce = 1e-3, xe = function() {
  function i() {
  }
  return i.BuildArray = function(e, t) {
    for (var r = [], n = 0; n < e; ++n)
      r.push(t());
    return r;
  }, i.BuildTuple = function(e, t) {
    return i.BuildArray(e, t);
  }, i;
}(), Qi = {};
function Ne(i, e) {
  Qi[i] = e;
}
function Ct(i) {
  return Qi[i];
}
var St = function() {
  function i() {
  }
  return i.SetMatrixPrecision = function(e) {
    if (i.MatrixTrackPrecisionChange = !1, e && !i.MatrixUse64Bits && i.MatrixTrackedMatrices)
      for (var t = 0; t < i.MatrixTrackedMatrices.length; ++t) {
        var r = i.MatrixTrackedMatrices[t], n = r._m;
        r._m = new Array(16);
        for (var a = 0; a < 16; ++a)
          r._m[a] = n[a];
      }
    i.MatrixUse64Bits = e, i.MatrixCurrentType = i.MatrixUse64Bits ? Array : Float32Array, i.MatrixTrackedMatrices = null;
  }, i.MatrixUse64Bits = !1, i.MatrixTrackPrecisionChange = !0, i.MatrixCurrentType = Float32Array, i.MatrixTrackedMatrices = [], i;
}(), re = function() {
  function i() {
  }
  return Object.defineProperty(i, "LastCreatedEngine", {
    get: function() {
      return this.Instances.length === 0 ? null : this.Instances[this.Instances.length - 1];
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "LastCreatedScene", {
    get: function() {
      return this._LastCreatedScene;
    },
    enumerable: !1,
    configurable: !0
  }), i.Instances = new Array(), i._LastCreatedScene = null, i.UseFallbackTexture = !0, i.FallbackTexture = "", i;
}(), Le = function(i) {
  return parseInt(i.toString().replace(/\W/g, ""));
}, Ee = function() {
  function i(e, t) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), this.x = e, this.y = t;
  }
  return i.prototype.toString = function() {
    return "{X: ".concat(this.x, " Y: ").concat(this.y, "}");
  }, i.prototype.getClassName = function() {
    return "Vector2";
  }, i.prototype.getHashCode = function() {
    var e = Le(this.x), t = Le(this.y), r = e;
    return r = r * 397 ^ t, r;
  }, i.prototype.toArray = function(e, t) {
    return t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, this;
  }, i.prototype.fromArray = function(e, t) {
    return t === void 0 && (t = 0), i.FromArrayToRef(e, t, this), this;
  }, i.prototype.asArray = function() {
    var e = new Array();
    return this.toArray(e, 0), e;
  }, i.prototype.copyFrom = function(e) {
    return this.x = e.x, this.y = e.y, this;
  }, i.prototype.copyFromFloats = function(e, t) {
    return this.x = e, this.y = t, this;
  }, i.prototype.set = function(e, t) {
    return this.copyFromFloats(e, t);
  }, i.prototype.add = function(e) {
    return new i(this.x + e.x, this.y + e.y);
  }, i.prototype.addToRef = function(e, t) {
    return t.x = this.x + e.x, t.y = this.y + e.y, this;
  }, i.prototype.addInPlace = function(e) {
    return this.x += e.x, this.y += e.y, this;
  }, i.prototype.addVector3 = function(e) {
    return new i(this.x + e.x, this.y + e.y);
  }, i.prototype.subtract = function(e) {
    return new i(this.x - e.x, this.y - e.y);
  }, i.prototype.subtractToRef = function(e, t) {
    return t.x = this.x - e.x, t.y = this.y - e.y, this;
  }, i.prototype.subtractInPlace = function(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }, i.prototype.multiplyInPlace = function(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }, i.prototype.multiply = function(e) {
    return new i(this.x * e.x, this.y * e.y);
  }, i.prototype.multiplyToRef = function(e, t) {
    return t.x = this.x * e.x, t.y = this.y * e.y, this;
  }, i.prototype.multiplyByFloats = function(e, t) {
    return new i(this.x * e, this.y * t);
  }, i.prototype.divide = function(e) {
    return new i(this.x / e.x, this.y / e.y);
  }, i.prototype.divideToRef = function(e, t) {
    return t.x = this.x / e.x, t.y = this.y / e.y, this;
  }, i.prototype.divideInPlace = function(e) {
    return this.divideToRef(e, this);
  }, i.prototype.negate = function() {
    return new i(-this.x, -this.y);
  }, i.prototype.negateInPlace = function() {
    return this.x *= -1, this.y *= -1, this;
  }, i.prototype.negateToRef = function(e) {
    return e.copyFromFloats(this.x * -1, this.y * -1);
  }, i.prototype.scaleInPlace = function(e) {
    return this.x *= e, this.y *= e, this;
  }, i.prototype.scale = function(e) {
    var t = new i(0, 0);
    return this.scaleToRef(e, t), t;
  }, i.prototype.scaleToRef = function(e, t) {
    return t.x = this.x * e, t.y = this.y * e, this;
  }, i.prototype.scaleAndAddToRef = function(e, t) {
    return t.x += this.x * e, t.y += this.y * e, this;
  }, i.prototype.equals = function(e) {
    return e && this.x === e.x && this.y === e.y;
  }, i.prototype.equalsWithEpsilon = function(e, t) {
    return t === void 0 && (t = ce), e && J.WithinEpsilon(this.x, e.x, t) && J.WithinEpsilon(this.y, e.y, t);
  }, i.prototype.floor = function() {
    return new i(Math.floor(this.x), Math.floor(this.y));
  }, i.prototype.fract = function() {
    return new i(this.x - Math.floor(this.x), this.y - Math.floor(this.y));
  }, i.prototype.rotateToRef = function(e, t) {
    var r = Math.cos(e), n = Math.sin(e);
    return t.x = r * this.x - n * this.y, t.y = n * this.x + r * this.y, this;
  }, i.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, i.prototype.lengthSquared = function() {
    return this.x * this.x + this.y * this.y;
  }, i.prototype.normalize = function() {
    return i.NormalizeToRef(this, this), this;
  }, i.prototype.clone = function() {
    return new i(this.x, this.y);
  }, i.Zero = function() {
    return new i(0, 0);
  }, i.One = function() {
    return new i(1, 1);
  }, i.FromArray = function(e, t) {
    return t === void 0 && (t = 0), new i(e[t], e[t + 1]);
  }, i.FromArrayToRef = function(e, t, r) {
    r.x = e[t], r.y = e[t + 1];
  }, i.CatmullRom = function(e, t, r, n, a) {
    var s = a * a, o = a * s, u = 0.5 * (2 * t.x + (-e.x + r.x) * a + (2 * e.x - 5 * t.x + 4 * r.x - n.x) * s + (-e.x + 3 * t.x - 3 * r.x + n.x) * o), f = 0.5 * (2 * t.y + (-e.y + r.y) * a + (2 * e.y - 5 * t.y + 4 * r.y - n.y) * s + (-e.y + 3 * t.y - 3 * r.y + n.y) * o);
    return new i(u, f);
  }, i.Clamp = function(e, t, r) {
    var n = e.x;
    n = n > r.x ? r.x : n, n = n < t.x ? t.x : n;
    var a = e.y;
    return a = a > r.y ? r.y : a, a = a < t.y ? t.y : a, new i(n, a);
  }, i.Hermite = function(e, t, r, n, a) {
    var s = a * a, o = a * s, u = 2 * o - 3 * s + 1, f = -2 * o + 3 * s, l = o - 2 * s + a, h = o - s, c = e.x * u + r.x * f + t.x * l + n.x * h, d = e.y * u + r.y * f + t.y * l + n.y * h;
    return new i(c, d);
  }, i.Hermite1stDerivative = function(e, t, r, n, a) {
    var s = i.Zero();
    return this.Hermite1stDerivativeToRef(e, t, r, n, a, s), s;
  }, i.Hermite1stDerivativeToRef = function(e, t, r, n, a, s) {
    var o = a * a;
    s.x = (o - a) * 6 * e.x + (3 * o - 4 * a + 1) * t.x + (-o + a) * 6 * r.x + (3 * o - 2 * a) * n.x, s.y = (o - a) * 6 * e.y + (3 * o - 4 * a + 1) * t.y + (-o + a) * 6 * r.y + (3 * o - 2 * a) * n.y;
  }, i.Lerp = function(e, t, r) {
    var n = e.x + (t.x - e.x) * r, a = e.y + (t.y - e.y) * r;
    return new i(n, a);
  }, i.Dot = function(e, t) {
    return e.x * t.x + e.y * t.y;
  }, i.Normalize = function(e) {
    var t = i.Zero();
    return this.NormalizeToRef(e, t), t;
  }, i.NormalizeToRef = function(e, t) {
    var r = e.length();
    r !== 0 && (t.x = e.x / r, t.y = e.y / r);
  }, i.Minimize = function(e, t) {
    var r = e.x < t.x ? e.x : t.x, n = e.y < t.y ? e.y : t.y;
    return new i(r, n);
  }, i.Maximize = function(e, t) {
    var r = e.x > t.x ? e.x : t.x, n = e.y > t.y ? e.y : t.y;
    return new i(r, n);
  }, i.Transform = function(e, t) {
    var r = i.Zero();
    return i.TransformToRef(e, t, r), r;
  }, i.TransformToRef = function(e, t, r) {
    var n = t.m, a = e.x * n[0] + e.y * n[4] + n[12], s = e.x * n[1] + e.y * n[5] + n[13];
    r.x = a, r.y = s;
  }, i.PointInTriangle = function(e, t, r, n) {
    var a = 0.5 * (-r.y * n.x + t.y * (-r.x + n.x) + t.x * (r.y - n.y) + r.x * n.y), s = a < 0 ? -1 : 1, o = (t.y * n.x - t.x * n.y + (n.y - t.y) * e.x + (t.x - n.x) * e.y) * s, u = (t.x * r.y - t.y * r.x + (t.y - r.y) * e.x + (r.x - t.x) * e.y) * s;
    return o > 0 && u > 0 && o + u < 2 * a * s;
  }, i.Distance = function(e, t) {
    return Math.sqrt(i.DistanceSquared(e, t));
  }, i.DistanceSquared = function(e, t) {
    var r = e.x - t.x, n = e.y - t.y;
    return r * r + n * n;
  }, i.Center = function(e, t) {
    return i.CenterToRef(e, t, i.Zero());
  }, i.CenterToRef = function(e, t, r) {
    return r.copyFromFloats((e.x + t.x) / 2, (e.y + t.y) / 2);
  }, i.DistanceOfPointFromSegment = function(e, t, r) {
    var n = i.DistanceSquared(t, r);
    if (n === 0)
      return i.Distance(e, t);
    var a = r.subtract(t), s = Math.max(0, Math.min(1, i.Dot(e.subtract(t), a) / n)), o = t.add(a.multiplyByFloats(s, s));
    return i.Distance(e, o);
  }, i;
}(), b = function() {
  function i(e, t, r) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), r === void 0 && (r = 0), this._isDirty = !0, this._x = e, this._y = t, this._z = r;
  }
  return Object.defineProperty(i.prototype, "x", {
    get: function() {
      return this._x;
    },
    set: function(e) {
      this._x = e, this._isDirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "y", {
    get: function() {
      return this._y;
    },
    set: function(e) {
      this._y = e, this._isDirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "z", {
    get: function() {
      return this._z;
    },
    set: function(e) {
      this._z = e, this._isDirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.toString = function() {
    return "{X: ".concat(this._x, " Y: ").concat(this._y, " Z: ").concat(this._z, "}");
  }, i.prototype.getClassName = function() {
    return "Vector3";
  }, i.prototype.getHashCode = function() {
    var e = Le(this._x), t = Le(this._y), r = Le(this._z), n = e;
    return n = n * 397 ^ t, n = n * 397 ^ r, n;
  }, i.prototype.asArray = function() {
    var e = [];
    return this.toArray(e, 0), e;
  }, i.prototype.toArray = function(e, t) {
    return t === void 0 && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, this;
  }, i.prototype.fromArray = function(e, t) {
    return t === void 0 && (t = 0), i.FromArrayToRef(e, t, this), this;
  }, i.prototype.toQuaternion = function() {
    return ie.RotationYawPitchRoll(this._y, this._x, this._z);
  }, i.prototype.addInPlace = function(e) {
    return this.addInPlaceFromFloats(e._x, e._y, e._z);
  }, i.prototype.addInPlaceFromFloats = function(e, t, r) {
    return this.x += e, this.y += t, this.z += r, this;
  }, i.prototype.add = function(e) {
    return new i(this._x + e._x, this._y + e._y, this._z + e._z);
  }, i.prototype.addToRef = function(e, t) {
    return t.copyFromFloats(this._x + e._x, this._y + e._y, this._z + e._z);
  }, i.prototype.subtractInPlace = function(e) {
    return this.x -= e._x, this.y -= e._y, this.z -= e._z, this;
  }, i.prototype.subtract = function(e) {
    return new i(this._x - e._x, this._y - e._y, this._z - e._z);
  }, i.prototype.subtractToRef = function(e, t) {
    return this.subtractFromFloatsToRef(e._x, e._y, e._z, t);
  }, i.prototype.subtractFromFloats = function(e, t, r) {
    return new i(this._x - e, this._y - t, this._z - r);
  }, i.prototype.subtractFromFloatsToRef = function(e, t, r, n) {
    return n.copyFromFloats(this._x - e, this._y - t, this._z - r);
  }, i.prototype.negate = function() {
    return new i(-this._x, -this._y, -this._z);
  }, i.prototype.negateInPlace = function() {
    return this.x *= -1, this.y *= -1, this.z *= -1, this;
  }, i.prototype.negateToRef = function(e) {
    return e.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);
  }, i.prototype.scaleInPlace = function(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }, i.prototype.scale = function(e) {
    return new i(this._x * e, this._y * e, this._z * e);
  }, i.prototype.scaleToRef = function(e, t) {
    return t.copyFromFloats(this._x * e, this._y * e, this._z * e);
  }, i.prototype.applyRotationQuaternionToRef = function(e, t) {
    var r = e.w * this.x + e.y * this.z - e.z * this.y, n = e.w * this.y + e.z * this.x - e.x * this.z, a = e.w * this.z + e.x * this.y - e.y * this.x, s = -e.x * this.x - e.y * this.y - e.z * this.z;
    return t.x = r * e.w + s * -e.x + n * -e.z - a * -e.y, t.y = n * e.w + s * -e.y + a * -e.x - r * -e.z, t.z = a * e.w + s * -e.z + r * -e.y - n * -e.x, t;
  }, i.prototype.applyRotationQuaternionInPlace = function(e) {
    return this.applyRotationQuaternionToRef(e, this);
  }, i.prototype.applyRotationQuaternion = function(e) {
    return this.applyRotationQuaternionToRef(e, i.Zero());
  }, i.prototype.scaleAndAddToRef = function(e, t) {
    return t.addInPlaceFromFloats(this._x * e, this._y * e, this._z * e);
  }, i.prototype.projectOnPlane = function(e, t) {
    var r = i.Zero();
    return this.projectOnPlaneToRef(e, t, r), r;
  }, i.prototype.projectOnPlaneToRef = function(e, t, r) {
    var n = e.normal, a = e.d, s = U.Vector3[0];
    this.subtractToRef(t, s), s.normalize();
    var o = i.Dot(s, n), u = -(i.Dot(t, n) + a) / o, f = s.scaleInPlace(u);
    t.addToRef(f, r);
  }, i.prototype.equals = function(e) {
    return e && this._x === e._x && this._y === e._y && this._z === e._z;
  }, i.prototype.equalsWithEpsilon = function(e, t) {
    return t === void 0 && (t = ce), e && J.WithinEpsilon(this._x, e._x, t) && J.WithinEpsilon(this._y, e._y, t) && J.WithinEpsilon(this._z, e._z, t);
  }, i.prototype.equalsToFloats = function(e, t, r) {
    return this._x === e && this._y === t && this._z === r;
  }, i.prototype.multiplyInPlace = function(e) {
    return this.x *= e._x, this.y *= e._y, this.z *= e._z, this;
  }, i.prototype.multiply = function(e) {
    return this.multiplyByFloats(e._x, e._y, e._z);
  }, i.prototype.multiplyToRef = function(e, t) {
    return t.copyFromFloats(this._x * e._x, this._y * e._y, this._z * e._z);
  }, i.prototype.multiplyByFloats = function(e, t, r) {
    return new i(this._x * e, this._y * t, this._z * r);
  }, i.prototype.divide = function(e) {
    return new i(this._x / e._x, this._y / e._y, this._z / e._z);
  }, i.prototype.divideToRef = function(e, t) {
    return t.copyFromFloats(this._x / e._x, this._y / e._y, this._z / e._z);
  }, i.prototype.divideInPlace = function(e) {
    return this.divideToRef(e, this);
  }, i.prototype.minimizeInPlace = function(e) {
    return this.minimizeInPlaceFromFloats(e._x, e._y, e._z);
  }, i.prototype.maximizeInPlace = function(e) {
    return this.maximizeInPlaceFromFloats(e._x, e._y, e._z);
  }, i.prototype.minimizeInPlaceFromFloats = function(e, t, r) {
    return e < this._x && (this.x = e), t < this._y && (this.y = t), r < this._z && (this.z = r), this;
  }, i.prototype.maximizeInPlaceFromFloats = function(e, t, r) {
    return e > this._x && (this.x = e), t > this._y && (this.y = t), r > this._z && (this.z = r), this;
  }, i.prototype.isNonUniformWithinEpsilon = function(e) {
    var t = Math.abs(this._x), r = Math.abs(this._y);
    if (!J.WithinEpsilon(t, r, e))
      return !0;
    var n = Math.abs(this._z);
    return !J.WithinEpsilon(t, n, e) || !J.WithinEpsilon(r, n, e);
  }, Object.defineProperty(i.prototype, "isNonUniform", {
    get: function() {
      var e = Math.abs(this._x), t = Math.abs(this._y);
      if (e !== t)
        return !0;
      var r = Math.abs(this._z);
      return e !== r;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.floor = function() {
    return new i(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));
  }, i.prototype.fract = function() {
    return new i(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));
  }, i.prototype.length = function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
  }, i.prototype.lengthSquared = function() {
    return this._x * this._x + this._y * this._y + this._z * this._z;
  }, Object.defineProperty(i.prototype, "hasAZeroComponent", {
    get: function() {
      return this._x * this._y * this._z === 0;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.normalize = function() {
    return this.normalizeFromLength(this.length());
  }, i.prototype.reorderInPlace = function(e) {
    var t = this;
    return e = e.toLowerCase(), e === "xyz" ? this : (U.Vector3[0].copyFrom(this), ["x", "y", "z"].forEach(function(r, n) {
      t[r] = U.Vector3[0][e[n]];
    }), this);
  }, i.prototype.rotateByQuaternionToRef = function(e, t) {
    return e.toRotationMatrix(U.Matrix[0]), i.TransformCoordinatesToRef(this, U.Matrix[0], t), t;
  }, i.prototype.rotateByQuaternionAroundPointToRef = function(e, t, r) {
    return this.subtractToRef(t, U.Vector3[0]), U.Vector3[0].rotateByQuaternionToRef(e, U.Vector3[0]), t.addToRef(U.Vector3[0], r), r;
  }, i.prototype.cross = function(e) {
    return i.Cross(this, e);
  }, i.prototype.normalizeFromLength = function(e) {
    return e === 0 || e === 1 ? this : this.scaleInPlace(1 / e);
  }, i.prototype.normalizeToNew = function() {
    var e = new i(0, 0, 0);
    return this.normalizeToRef(e), e;
  }, i.prototype.normalizeToRef = function(e) {
    var t = this.length();
    return t === 0 || t === 1 ? e.copyFromFloats(this._x, this._y, this._z) : this.scaleToRef(1 / t, e);
  }, i.prototype.clone = function() {
    return new i(this._x, this._y, this._z);
  }, i.prototype.copyFrom = function(e) {
    return this.copyFromFloats(e._x, e._y, e._z);
  }, i.prototype.copyFromFloats = function(e, t, r) {
    return this.x = e, this.y = t, this.z = r, this;
  }, i.prototype.set = function(e, t, r) {
    return this.copyFromFloats(e, t, r);
  }, i.prototype.setAll = function(e) {
    return this.x = this.y = this.z = e, this;
  }, i.GetClipFactor = function(e, t, r, n) {
    var a = i.Dot(e, r) - n, s = i.Dot(t, r) - n, o = a / (a - s);
    return o;
  }, i.GetAngleBetweenVectors = function(e, t, r) {
    var n = e.normalizeToRef(U.Vector3[1]), a = t.normalizeToRef(U.Vector3[2]), s = i.Dot(n, a);
    s = J.Clamp(s, -1, 1);
    var o = Math.acos(s), u = U.Vector3[3];
    return i.CrossToRef(n, a, u), i.Dot(u, r) > 0 ? isNaN(o) ? 0 : o : isNaN(o) ? -Math.PI : -Math.acos(s);
  }, i.GetAngleBetweenVectorsOnPlane = function(e, t, r) {
    U.Vector3[0].copyFrom(e);
    var n = U.Vector3[0];
    U.Vector3[1].copyFrom(t);
    var a = U.Vector3[1];
    U.Vector3[2].copyFrom(r);
    var s = U.Vector3[2], o = U.Vector3[3], u = U.Vector3[4];
    n.normalize(), a.normalize(), s.normalize(), i.CrossToRef(s, n, o), i.CrossToRef(o, s, u);
    var f = Math.atan2(i.Dot(a, o), i.Dot(a, u));
    return J.NormalizeRadians(f);
  }, i.SlerpToRef = function(e, t, r, n) {
    r = J.Clamp(r, 0, 1);
    var a = U.Vector3[0], s = U.Vector3[1];
    a.copyFrom(e);
    var o = a.length();
    a.normalizeFromLength(o), s.copyFrom(t);
    var u = s.length();
    s.normalizeFromLength(u);
    var f = i.Dot(a, s), l, h;
    if (f < 1 - ce) {
      var c = Math.acos(f), d = 1 / Math.sin(c);
      l = Math.sin((1 - r) * c) * d, h = Math.sin(r * c) * d;
    } else
      l = 1 - r, h = r;
    a.scaleInPlace(l), s.scaleInPlace(h), n.copyFrom(a).addInPlace(s), n.scaleInPlace(J.Lerp(o, u, r));
  }, i.SmoothToRef = function(e, t, r, n, a) {
    i.SlerpToRef(e, t, n === 0 ? 1 : r / n, a);
  }, i.FromArray = function(e, t) {
    return t === void 0 && (t = 0), new i(e[t], e[t + 1], e[t + 2]);
  }, i.FromFloatArray = function(e, t) {
    return i.FromArray(e, t);
  }, i.FromArrayToRef = function(e, t, r) {
    r.x = e[t], r.y = e[t + 1], r.z = e[t + 2];
  }, i.FromFloatArrayToRef = function(e, t, r) {
    return i.FromArrayToRef(e, t, r);
  }, i.FromFloatsToRef = function(e, t, r, n) {
    n.copyFromFloats(e, t, r);
  }, i.Zero = function() {
    return new i(0, 0, 0);
  }, i.One = function() {
    return new i(1, 1, 1);
  }, i.Up = function() {
    return new i(0, 1, 0);
  }, Object.defineProperty(i, "UpReadOnly", {
    get: function() {
      return i._UpReadOnly;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "RightReadOnly", {
    get: function() {
      return i._RightReadOnly;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "LeftReadOnly", {
    get: function() {
      return i._LeftReadOnly;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "LeftHandedForwardReadOnly", {
    get: function() {
      return i._LeftHandedForwardReadOnly;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "RightHandedForwardReadOnly", {
    get: function() {
      return i._RightHandedForwardReadOnly;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "ZeroReadOnly", {
    get: function() {
      return i._ZeroReadOnly;
    },
    enumerable: !1,
    configurable: !0
  }), i.Down = function() {
    return new i(0, -1, 0);
  }, i.Forward = function(e) {
    return e === void 0 && (e = !1), new i(0, 0, e ? -1 : 1);
  }, i.Backward = function(e) {
    return e === void 0 && (e = !1), new i(0, 0, e ? 1 : -1);
  }, i.Right = function() {
    return new i(1, 0, 0);
  }, i.Left = function() {
    return new i(-1, 0, 0);
  }, i.TransformCoordinates = function(e, t) {
    var r = i.Zero();
    return i.TransformCoordinatesToRef(e, t, r), r;
  }, i.TransformCoordinatesToRef = function(e, t, r) {
    i.TransformCoordinatesFromFloatsToRef(e._x, e._y, e._z, t, r);
  }, i.TransformCoordinatesFromFloatsToRef = function(e, t, r, n, a) {
    var s = n.m, o = e * s[0] + t * s[4] + r * s[8] + s[12], u = e * s[1] + t * s[5] + r * s[9] + s[13], f = e * s[2] + t * s[6] + r * s[10] + s[14], l = 1 / (e * s[3] + t * s[7] + r * s[11] + s[15]);
    a.x = o * l, a.y = u * l, a.z = f * l;
  }, i.TransformNormal = function(e, t) {
    var r = i.Zero();
    return i.TransformNormalToRef(e, t, r), r;
  }, i.TransformNormalToRef = function(e, t, r) {
    this.TransformNormalFromFloatsToRef(e._x, e._y, e._z, t, r);
  }, i.TransformNormalFromFloatsToRef = function(e, t, r, n, a) {
    var s = n.m;
    a.x = e * s[0] + t * s[4] + r * s[8], a.y = e * s[1] + t * s[5] + r * s[9], a.z = e * s[2] + t * s[6] + r * s[10];
  }, i.CatmullRom = function(e, t, r, n, a) {
    var s = a * a, o = a * s, u = 0.5 * (2 * t._x + (-e._x + r._x) * a + (2 * e._x - 5 * t._x + 4 * r._x - n._x) * s + (-e._x + 3 * t._x - 3 * r._x + n._x) * o), f = 0.5 * (2 * t._y + (-e._y + r._y) * a + (2 * e._y - 5 * t._y + 4 * r._y - n._y) * s + (-e._y + 3 * t._y - 3 * r._y + n._y) * o), l = 0.5 * (2 * t._z + (-e._z + r._z) * a + (2 * e._z - 5 * t._z + 4 * r._z - n._z) * s + (-e._z + 3 * t._z - 3 * r._z + n._z) * o);
    return new i(u, f, l);
  }, i.Clamp = function(e, t, r) {
    var n = new i();
    return i.ClampToRef(e, t, r, n), n;
  }, i.ClampToRef = function(e, t, r, n) {
    var a = e._x;
    a = a > r._x ? r._x : a, a = a < t._x ? t._x : a;
    var s = e._y;
    s = s > r._y ? r._y : s, s = s < t._y ? t._y : s;
    var o = e._z;
    o = o > r._z ? r._z : o, o = o < t._z ? t._z : o, n.copyFromFloats(a, s, o);
  }, i.CheckExtends = function(e, t, r) {
    t.minimizeInPlace(e), r.maximizeInPlace(e);
  }, i.Hermite = function(e, t, r, n, a) {
    var s = a * a, o = a * s, u = 2 * o - 3 * s + 1, f = -2 * o + 3 * s, l = o - 2 * s + a, h = o - s, c = e._x * u + r._x * f + t._x * l + n._x * h, d = e._y * u + r._y * f + t._y * l + n._y * h, p = e._z * u + r._z * f + t._z * l + n._z * h;
    return new i(c, d, p);
  }, i.Hermite1stDerivative = function(e, t, r, n, a) {
    var s = i.Zero();
    return this.Hermite1stDerivativeToRef(e, t, r, n, a, s), s;
  }, i.Hermite1stDerivativeToRef = function(e, t, r, n, a, s) {
    var o = a * a;
    s.x = (o - a) * 6 * e.x + (3 * o - 4 * a + 1) * t.x + (-o + a) * 6 * r.x + (3 * o - 2 * a) * n.x, s.y = (o - a) * 6 * e.y + (3 * o - 4 * a + 1) * t.y + (-o + a) * 6 * r.y + (3 * o - 2 * a) * n.y, s.z = (o - a) * 6 * e.z + (3 * o - 4 * a + 1) * t.z + (-o + a) * 6 * r.z + (3 * o - 2 * a) * n.z;
  }, i.Lerp = function(e, t, r) {
    var n = new i(0, 0, 0);
    return i.LerpToRef(e, t, r, n), n;
  }, i.LerpToRef = function(e, t, r, n) {
    n.x = e._x + (t._x - e._x) * r, n.y = e._y + (t._y - e._y) * r, n.z = e._z + (t._z - e._z) * r;
  }, i.Dot = function(e, t) {
    return e._x * t._x + e._y * t._y + e._z * t._z;
  }, i.Cross = function(e, t) {
    var r = i.Zero();
    return i.CrossToRef(e, t, r), r;
  }, i.CrossToRef = function(e, t, r) {
    var n = e._y * t._z - e._z * t._y, a = e._z * t._x - e._x * t._z, s = e._x * t._y - e._y * t._x;
    r.copyFromFloats(n, a, s);
  }, i.Normalize = function(e) {
    var t = i.Zero();
    return i.NormalizeToRef(e, t), t;
  }, i.NormalizeToRef = function(e, t) {
    e.normalizeToRef(t);
  }, i.Project = function(e, t, r, n) {
    var a = new i();
    return i.ProjectToRef(e, t, r, n, a), a;
  }, i.ProjectToRef = function(e, t, r, n, a) {
    var s = n.width, o = n.height, u = n.x, f = n.y, l = U.Matrix[1];
    I.FromValuesToRef(s / 2, 0, 0, 0, 0, -o / 2, 0, 0, 0, 0, 0.5, 0, u + s / 2, o / 2 + f, 0.5, 1, l);
    var h = U.Matrix[0];
    return t.multiplyToRef(r, h), h.multiplyToRef(l, h), i.TransformCoordinatesToRef(e, h, a), a;
  }, i._UnprojectFromInvertedMatrixToRef = function(e, t, r) {
    i.TransformCoordinatesToRef(e, t, r);
    var n = t.m, a = e._x * n[3] + e._y * n[7] + e._z * n[11] + n[15];
    J.WithinEpsilon(a, 1) && r.scaleInPlace(1 / a);
  }, i.UnprojectFromTransform = function(e, t, r, n, a) {
    return this.Unproject(e, t, r, n, a, I.IdentityReadOnly);
  }, i.Unproject = function(e, t, r, n, a, s) {
    var o = i.Zero();
    return i.UnprojectToRef(e, t, r, n, a, s, o), o;
  }, i.UnprojectToRef = function(e, t, r, n, a, s, o) {
    i.UnprojectFloatsToRef(e._x, e._y, e._z, t, r, n, a, s, o);
  }, i.UnprojectFloatsToRef = function(e, t, r, n, a, s, o, u, f) {
    var l, h = U.Matrix[0];
    s.multiplyToRef(o, h), h.multiplyToRef(u, h), h.invert();
    var c = U.Vector3[0];
    c.x = e / n * 2 - 1, c.y = -(t / a * 2 - 1), !((l = re.LastCreatedEngine) === null || l === void 0) && l.isNDCHalfZRange ? c.z = r : c.z = 2 * r - 1, i._UnprojectFromInvertedMatrixToRef(c, h, f);
  }, i.Minimize = function(e, t) {
    var r = e.clone();
    return r.minimizeInPlace(t), r;
  }, i.Maximize = function(e, t) {
    var r = e.clone();
    return r.maximizeInPlace(t), r;
  }, i.Distance = function(e, t) {
    return Math.sqrt(i.DistanceSquared(e, t));
  }, i.DistanceSquared = function(e, t) {
    var r = e._x - t._x, n = e._y - t._y, a = e._z - t._z;
    return r * r + n * n + a * a;
  }, i.ProjectOnTriangleToRef = function(e, t, r, n, a) {
    var s = U.Vector3[0], o = U.Vector3[1], u = U.Vector3[2], f = U.Vector3[3], l = U.Vector3[4];
    r.subtractToRef(t, s), n.subtractToRef(t, o), n.subtractToRef(r, u);
    var h = s.length(), c = o.length(), d = u.length();
    if (h < ce || c < ce || d < ce)
      return a.copyFrom(t), i.Distance(e, t);
    e.subtractToRef(t, l), i.CrossToRef(s, o, f);
    var p = f.length();
    if (p < ce)
      return a.copyFrom(t), i.Distance(e, t);
    f.normalizeFromLength(p);
    var g = l.length();
    if (g < ce)
      return a.copyFrom(t), 0;
    l.normalizeFromLength(g);
    var _ = i.Dot(f, l), v = U.Vector3[5], y = U.Vector3[6];
    v.copyFrom(f).scaleInPlace(-g * _), y.copyFrom(e).addInPlace(v);
    var E = U.Vector3[4], R = U.Vector3[5], M = U.Vector3[7], C = U.Vector3[8];
    E.copyFrom(s).scaleInPlace(1 / h), C.copyFrom(o).scaleInPlace(1 / c), E.addInPlace(C).scaleInPlace(-1), R.copyFrom(s).scaleInPlace(-1 / h), C.copyFrom(u).scaleInPlace(1 / d), R.addInPlace(C).scaleInPlace(-1), M.copyFrom(u).scaleInPlace(-1 / d), C.copyFrom(o).scaleInPlace(-1 / c), M.addInPlace(C).scaleInPlace(-1);
    var A = U.Vector3[9], S;
    A.copyFrom(y).subtractInPlace(t), i.CrossToRef(E, A, C), S = i.Dot(C, f);
    var w = S;
    A.copyFrom(y).subtractInPlace(r), i.CrossToRef(R, A, C), S = i.Dot(C, f);
    var F = S;
    A.copyFrom(y).subtractInPlace(n), i.CrossToRef(M, A, C), S = i.Dot(C, f);
    var x = S, z = U.Vector3[10], W, N;
    w > 0 && F < 0 ? (z.copyFrom(s), W = t, N = r) : F > 0 && x < 0 ? (z.copyFrom(u), W = r, N = n) : (z.copyFrom(o).scaleInPlace(-1), W = n, N = t);
    var Z = U.Vector3[9], q = U.Vector3[4];
    W.subtractToRef(y, C), N.subtractToRef(y, Z), i.CrossToRef(C, Z, q);
    var ae = i.Dot(q, f) < 0;
    if (!ae)
      return a.copyFrom(y), Math.abs(g * _);
    var Y = U.Vector3[5];
    i.CrossToRef(z, q, Y), Y.normalize();
    var H = U.Vector3[9];
    H.copyFrom(W).subtractInPlace(y);
    var se = H.length();
    if (se < ce)
      return a.copyFrom(W), i.Distance(e, W);
    H.normalizeFromLength(se);
    var Se = i.Dot(Y, H), Be = U.Vector3[7];
    Be.copyFrom(y).addInPlace(Y.scaleInPlace(se * Se)), C.copyFrom(Be).subtractInPlace(W), g = z.length(), z.normalizeFromLength(g);
    var Ge = i.Dot(C, z) / Math.max(g, ce);
    return Ge = J.Clamp(Ge, 0, 1), Be.copyFrom(W).addInPlace(z.scaleInPlace(Ge * g)), a.copyFrom(Be), i.Distance(e, Be);
  }, i.Center = function(e, t) {
    return i.CenterToRef(e, t, i.Zero());
  }, i.CenterToRef = function(e, t, r) {
    return r.copyFromFloats((e._x + t._x) / 2, (e._y + t._y) / 2, (e._z + t._z) / 2);
  }, i.RotationFromAxis = function(e, t, r) {
    var n = i.Zero();
    return i.RotationFromAxisToRef(e, t, r, n), n;
  }, i.RotationFromAxisToRef = function(e, t, r, n) {
    var a = U.Quaternion[0];
    ie.RotationQuaternionFromAxisToRef(e, t, r, a), a.toEulerAnglesToRef(n);
  }, i._UpReadOnly = i.Up(), i._LeftHandedForwardReadOnly = i.Forward(!1), i._RightHandedForwardReadOnly = i.Forward(!0), i._RightReadOnly = i.Right(), i._LeftReadOnly = i.Left(), i._ZeroReadOnly = i.Zero(), i;
}(), yt = function() {
  function i(e, t, r, n) {
    this.x = e, this.y = t, this.z = r, this.w = n;
  }
  return i.prototype.toString = function() {
    return "{X: ".concat(this.x, " Y: ").concat(this.y, " Z: ").concat(this.z, " W: ").concat(this.w, "}");
  }, i.prototype.getClassName = function() {
    return "Vector4";
  }, i.prototype.getHashCode = function() {
    var e = Le(this.x), t = Le(this.y), r = Le(this.z), n = Le(this.w), a = e;
    return a = a * 397 ^ t, a = a * 397 ^ r, a = a * 397 ^ n, a;
  }, i.prototype.asArray = function() {
    var e = new Array();
    return this.toArray(e, 0), e;
  }, i.prototype.toArray = function(e, t) {
    return t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, this;
  }, i.prototype.fromArray = function(e, t) {
    return t === void 0 && (t = 0), i.FromArrayToRef(e, t, this), this;
  }, i.prototype.addInPlace = function(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }, i.prototype.add = function(e) {
    return new i(this.x + e.x, this.y + e.y, this.z + e.z, this.w + e.w);
  }, i.prototype.addToRef = function(e, t) {
    return t.x = this.x + e.x, t.y = this.y + e.y, t.z = this.z + e.z, t.w = this.w + e.w, this;
  }, i.prototype.subtractInPlace = function(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }, i.prototype.subtract = function(e) {
    return new i(this.x - e.x, this.y - e.y, this.z - e.z, this.w - e.w);
  }, i.prototype.subtractToRef = function(e, t) {
    return t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z, t.w = this.w - e.w, this;
  }, i.prototype.subtractFromFloats = function(e, t, r, n) {
    return new i(this.x - e, this.y - t, this.z - r, this.w - n);
  }, i.prototype.subtractFromFloatsToRef = function(e, t, r, n, a) {
    return a.x = this.x - e, a.y = this.y - t, a.z = this.z - r, a.w = this.w - n, this;
  }, i.prototype.negate = function() {
    return new i(-this.x, -this.y, -this.z, -this.w);
  }, i.prototype.negateInPlace = function() {
    return this.x *= -1, this.y *= -1, this.z *= -1, this.w *= -1, this;
  }, i.prototype.negateToRef = function(e) {
    return e.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);
  }, i.prototype.scaleInPlace = function(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }, i.prototype.scale = function(e) {
    return new i(this.x * e, this.y * e, this.z * e, this.w * e);
  }, i.prototype.scaleToRef = function(e, t) {
    return t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e, this;
  }, i.prototype.scaleAndAddToRef = function(e, t) {
    return t.x += this.x * e, t.y += this.y * e, t.z += this.z * e, t.w += this.w * e, this;
  }, i.prototype.equals = function(e) {
    return e && this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w;
  }, i.prototype.equalsWithEpsilon = function(e, t) {
    return t === void 0 && (t = ce), e && J.WithinEpsilon(this.x, e.x, t) && J.WithinEpsilon(this.y, e.y, t) && J.WithinEpsilon(this.z, e.z, t) && J.WithinEpsilon(this.w, e.w, t);
  }, i.prototype.equalsToFloats = function(e, t, r, n) {
    return this.x === e && this.y === t && this.z === r && this.w === n;
  }, i.prototype.multiplyInPlace = function(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }, i.prototype.multiply = function(e) {
    return new i(this.x * e.x, this.y * e.y, this.z * e.z, this.w * e.w);
  }, i.prototype.multiplyToRef = function(e, t) {
    return t.x = this.x * e.x, t.y = this.y * e.y, t.z = this.z * e.z, t.w = this.w * e.w, this;
  }, i.prototype.multiplyByFloats = function(e, t, r, n) {
    return new i(this.x * e, this.y * t, this.z * r, this.w * n);
  }, i.prototype.divide = function(e) {
    return new i(this.x / e.x, this.y / e.y, this.z / e.z, this.w / e.w);
  }, i.prototype.divideToRef = function(e, t) {
    return t.x = this.x / e.x, t.y = this.y / e.y, t.z = this.z / e.z, t.w = this.w / e.w, this;
  }, i.prototype.divideInPlace = function(e) {
    return this.divideToRef(e, this);
  }, i.prototype.minimizeInPlace = function(e) {
    return e.x < this.x && (this.x = e.x), e.y < this.y && (this.y = e.y), e.z < this.z && (this.z = e.z), e.w < this.w && (this.w = e.w), this;
  }, i.prototype.maximizeInPlace = function(e) {
    return e.x > this.x && (this.x = e.x), e.y > this.y && (this.y = e.y), e.z > this.z && (this.z = e.z), e.w > this.w && (this.w = e.w), this;
  }, i.prototype.floor = function() {
    return new i(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));
  }, i.prototype.fract = function() {
    return new i(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));
  }, i.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }, i.prototype.lengthSquared = function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }, i.prototype.normalize = function() {
    var e = this.length();
    return e === 0 ? this : this.scaleInPlace(1 / e);
  }, i.prototype.toVector3 = function() {
    return new b(this.x, this.y, this.z);
  }, i.prototype.clone = function() {
    return new i(this.x, this.y, this.z, this.w);
  }, i.prototype.copyFrom = function(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;
  }, i.prototype.copyFromFloats = function(e, t, r, n) {
    return this.x = e, this.y = t, this.z = r, this.w = n, this;
  }, i.prototype.set = function(e, t, r, n) {
    return this.copyFromFloats(e, t, r, n);
  }, i.prototype.setAll = function(e) {
    return this.x = this.y = this.z = this.w = e, this;
  }, i.FromArray = function(e, t) {
    return t || (t = 0), new i(e[t], e[t + 1], e[t + 2], e[t + 3]);
  }, i.FromArrayToRef = function(e, t, r) {
    r.x = e[t], r.y = e[t + 1], r.z = e[t + 2], r.w = e[t + 3];
  }, i.FromFloatArrayToRef = function(e, t, r) {
    i.FromArrayToRef(e, t, r);
  }, i.FromFloatsToRef = function(e, t, r, n, a) {
    a.x = e, a.y = t, a.z = r, a.w = n;
  }, i.Zero = function() {
    return new i(0, 0, 0, 0);
  }, i.One = function() {
    return new i(1, 1, 1, 1);
  }, i.Normalize = function(e) {
    var t = i.Zero();
    return i.NormalizeToRef(e, t), t;
  }, i.NormalizeToRef = function(e, t) {
    t.copyFrom(e), t.normalize();
  }, i.Minimize = function(e, t) {
    var r = e.clone();
    return r.minimizeInPlace(t), r;
  }, i.Maximize = function(e, t) {
    var r = e.clone();
    return r.maximizeInPlace(t), r;
  }, i.Distance = function(e, t) {
    return Math.sqrt(i.DistanceSquared(e, t));
  }, i.DistanceSquared = function(e, t) {
    var r = e.x - t.x, n = e.y - t.y, a = e.z - t.z, s = e.w - t.w;
    return r * r + n * n + a * a + s * s;
  }, i.Center = function(e, t) {
    return i.CenterToRef(e, t, i.Zero());
  }, i.CenterToRef = function(e, t, r) {
    return r.copyFromFloats((e.x + t.x) / 2, (e.y + t.y) / 2, (e.z + t.z) / 2, (e.w + t.w) / 2);
  }, i.TransformCoordinates = function(e, t) {
    var r = i.Zero();
    return i.TransformCoordinatesToRef(e, t, r), r;
  }, i.TransformCoordinatesToRef = function(e, t, r) {
    i.TransformCoordinatesFromFloatsToRef(e._x, e._y, e._z, t, r);
  }, i.TransformCoordinatesFromFloatsToRef = function(e, t, r, n, a) {
    var s = n.m, o = e * s[0] + t * s[4] + r * s[8] + s[12], u = e * s[1] + t * s[5] + r * s[9] + s[13], f = e * s[2] + t * s[6] + r * s[10] + s[14], l = e * s[3] + t * s[7] + r * s[11] + s[15];
    a.x = o, a.y = u, a.z = f, a.w = l;
  }, i.TransformNormal = function(e, t) {
    var r = i.Zero();
    return i.TransformNormalToRef(e, t, r), r;
  }, i.TransformNormalToRef = function(e, t, r) {
    var n = t.m, a = e.x * n[0] + e.y * n[4] + e.z * n[8], s = e.x * n[1] + e.y * n[5] + e.z * n[9], o = e.x * n[2] + e.y * n[6] + e.z * n[10];
    r.x = a, r.y = s, r.z = o, r.w = e.w;
  }, i.TransformNormalFromFloatsToRef = function(e, t, r, n, a, s) {
    var o = a.m;
    s.x = e * o[0] + t * o[4] + r * o[8], s.y = e * o[1] + t * o[5] + r * o[9], s.z = e * o[2] + t * o[6] + r * o[10], s.w = n;
  }, i.FromVector3 = function(e, t) {
    return t === void 0 && (t = 0), new i(e._x, e._y, e._z, t);
  }, i;
}(), ie = function() {
  function i(e, t, r, n) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), r === void 0 && (r = 0), n === void 0 && (n = 1), this._isDirty = !0, this._x = e, this._y = t, this._z = r, this._w = n;
  }
  return Object.defineProperty(i.prototype, "x", {
    get: function() {
      return this._x;
    },
    set: function(e) {
      this._x = e, this._isDirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "y", {
    get: function() {
      return this._y;
    },
    set: function(e) {
      this._y = e, this._isDirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "z", {
    get: function() {
      return this._z;
    },
    set: function(e) {
      this._z = e, this._isDirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "w", {
    get: function() {
      return this._w;
    },
    set: function(e) {
      this._w = e, this._isDirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.toString = function() {
    return "{X: ".concat(this._x, " Y: ").concat(this._y, " Z: ").concat(this._z, " W: ").concat(this._w, "}");
  }, i.prototype.getClassName = function() {
    return "Quaternion";
  }, i.prototype.getHashCode = function() {
    var e = Le(this._x), t = Le(this._y), r = Le(this._z), n = Le(this._w), a = e;
    return a = a * 397 ^ t, a = a * 397 ^ r, a = a * 397 ^ n, a;
  }, i.prototype.asArray = function() {
    return [this._x, this._y, this._z, this._w];
  }, i.prototype.equals = function(e) {
    return e && this._x === e._x && this._y === e._y && this._z === e._z && this._w === e._w;
  }, i.prototype.equalsWithEpsilon = function(e, t) {
    return t === void 0 && (t = ce), e && J.WithinEpsilon(this._x, e._x, t) && J.WithinEpsilon(this._y, e._y, t) && J.WithinEpsilon(this._z, e._z, t) && J.WithinEpsilon(this._w, e._w, t);
  }, i.prototype.clone = function() {
    return new i(this._x, this._y, this._z, this._w);
  }, i.prototype.copyFrom = function(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this.w = e._w, this;
  }, i.prototype.copyFromFloats = function(e, t, r, n) {
    return this.x = e, this.y = t, this.z = r, this.w = n, this;
  }, i.prototype.set = function(e, t, r, n) {
    return this.copyFromFloats(e, t, r, n);
  }, i.prototype.add = function(e) {
    return new i(this._x + e._x, this._y + e._y, this._z + e._z, this._w + e._w);
  }, i.prototype.addInPlace = function(e) {
    return this._x += e._x, this._y += e._y, this._z += e._z, this._w += e._w, this;
  }, i.prototype.subtract = function(e) {
    return new i(this._x - e._x, this._y - e._y, this._z - e._z, this._w - e._w);
  }, i.prototype.subtractInPlace = function(e) {
    return this._x -= e._x, this._y -= e._y, this._z -= e._z, this._w -= e._w, this;
  }, i.prototype.scale = function(e) {
    return new i(this._x * e, this._y * e, this._z * e, this._w * e);
  }, i.prototype.scaleToRef = function(e, t) {
    return t.x = this._x * e, t.y = this._y * e, t.z = this._z * e, t.w = this._w * e, this;
  }, i.prototype.scaleInPlace = function(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }, i.prototype.scaleAndAddToRef = function(e, t) {
    return t.x += this._x * e, t.y += this._y * e, t.z += this._z * e, t.w += this._w * e, this;
  }, i.prototype.multiply = function(e) {
    var t = new i(0, 0, 0, 1);
    return this.multiplyToRef(e, t), t;
  }, i.prototype.multiplyToRef = function(e, t) {
    var r = this._x * e._w + this._y * e._z - this._z * e._y + this._w * e._x, n = -this._x * e._z + this._y * e._w + this._z * e._x + this._w * e._y, a = this._x * e._y - this._y * e._x + this._z * e._w + this._w * e._z, s = -this._x * e._x - this._y * e._y - this._z * e._z + this._w * e._w;
    return t.copyFromFloats(r, n, a, s), this;
  }, i.prototype.multiplyInPlace = function(e) {
    return this.multiplyToRef(e, this), this;
  }, i.prototype.conjugateToRef = function(e) {
    return e.copyFromFloats(-this._x, -this._y, -this._z, this._w), this;
  }, i.prototype.conjugateInPlace = function() {
    return this.x *= -1, this.y *= -1, this.z *= -1, this;
  }, i.prototype.conjugate = function() {
    return new i(-this._x, -this._y, -this._z, this._w);
  }, i.prototype.invert = function() {
    var e = this.conjugate(), t = this.lengthSquared();
    return t == 0 || t == 1 || e.scaleInPlace(1 / t), e;
  }, i.prototype.invertInPlace = function() {
    this.conjugateInPlace();
    var e = this.lengthSquared();
    return e == 0 || e == 1 ? this : (this.scaleInPlace(1 / e), this);
  }, i.prototype.lengthSquared = function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }, i.prototype.length = function() {
    return Math.sqrt(this.lengthSquared());
  }, i.prototype.normalize = function() {
    var e = this.length();
    if (e === 0)
      return this;
    var t = 1 / e;
    return this.scaleInPlace(t), this;
  }, i.prototype.normalizeToNew = function() {
    var e = this.length();
    if (e === 0)
      return this.clone();
    var t = 1 / e;
    return this.scale(t);
  }, i.prototype.toEulerAngles = function() {
    var e = b.Zero();
    return this.toEulerAnglesToRef(e), e;
  }, i.prototype.toEulerAnglesToRef = function(e) {
    var t = this._z, r = this._x, n = this._y, a = this._w, s = n * t - r * a, o = 0.4999999;
    if (s < -o)
      e.y = 2 * Math.atan2(n, a), e.x = Math.PI / 2, e.z = 0;
    else if (s > o)
      e.y = 2 * Math.atan2(n, a), e.x = -Math.PI / 2, e.z = 0;
    else {
      var u = a * a, f = t * t, l = r * r, h = n * n;
      e.z = Math.atan2(2 * (r * n + t * a), -f - l + h + u), e.x = Math.asin(-2 * s), e.y = Math.atan2(2 * (t * r + n * a), f - l - h + u);
    }
    return this;
  }, i.prototype.toRotationMatrix = function(e) {
    return I.FromQuaternionToRef(this, e), this;
  }, i.prototype.fromRotationMatrix = function(e) {
    return i.FromRotationMatrixToRef(e, this), this;
  }, i.FromRotationMatrix = function(e) {
    var t = new i();
    return i.FromRotationMatrixToRef(e, t), t;
  }, i.FromRotationMatrixToRef = function(e, t) {
    var r = e.m, n = r[0], a = r[4], s = r[8], o = r[1], u = r[5], f = r[9], l = r[2], h = r[6], c = r[10], d = n + u + c, p;
    d > 0 ? (p = 0.5 / Math.sqrt(d + 1), t.w = 0.25 / p, t.x = (h - f) * p, t.y = (s - l) * p, t.z = (o - a) * p) : n > u && n > c ? (p = 2 * Math.sqrt(1 + n - u - c), t.w = (h - f) / p, t.x = 0.25 * p, t.y = (a + o) / p, t.z = (s + l) / p) : u > c ? (p = 2 * Math.sqrt(1 + u - n - c), t.w = (s - l) / p, t.x = (a + o) / p, t.y = 0.25 * p, t.z = (f + h) / p) : (p = 2 * Math.sqrt(1 + c - n - u), t.w = (o - a) / p, t.x = (s + l) / p, t.y = (f + h) / p, t.z = 0.25 * p);
  }, i.Dot = function(e, t) {
    return e._x * t._x + e._y * t._y + e._z * t._z + e._w * t._w;
  }, i.AreClose = function(e, t) {
    var r = i.Dot(e, t);
    return r >= 0;
  }, i.SmoothToRef = function(e, t, r, n, a) {
    var s = n === 0 ? 1 : r / n;
    s = J.Clamp(s, 0, 1), i.SlerpToRef(e, t, s, a);
  }, i.Zero = function() {
    return new i(0, 0, 0, 0);
  }, i.Inverse = function(e) {
    return new i(-e._x, -e._y, -e._z, e._w);
  }, i.InverseToRef = function(e, t) {
    return t.set(-e._x, -e._y, -e._z, e._w), t;
  }, i.Identity = function() {
    return new i(0, 0, 0, 1);
  }, i.IsIdentity = function(e) {
    return e && e._x === 0 && e._y === 0 && e._z === 0 && e._w === 1;
  }, i.RotationAxis = function(e, t) {
    return i.RotationAxisToRef(e, t, new i());
  }, i.RotationAxisToRef = function(e, t, r) {
    var n = Math.sin(t / 2);
    return e.normalize(), r.w = Math.cos(t / 2), r.x = e._x * n, r.y = e._y * n, r.z = e._z * n, r;
  }, i.FromArray = function(e, t) {
    return t || (t = 0), new i(e[t], e[t + 1], e[t + 2], e[t + 3]);
  }, i.FromArrayToRef = function(e, t, r) {
    r.x = e[t], r.y = e[t + 1], r.z = e[t + 2], r.w = e[t + 3];
  }, i.FromEulerAngles = function(e, t, r) {
    var n = new i();
    return i.RotationYawPitchRollToRef(t, e, r, n), n;
  }, i.FromEulerAnglesToRef = function(e, t, r, n) {
    return i.RotationYawPitchRollToRef(t, e, r, n), n;
  }, i.FromEulerVector = function(e) {
    var t = new i();
    return i.RotationYawPitchRollToRef(e._y, e._x, e._z, t), t;
  }, i.FromEulerVectorToRef = function(e, t) {
    return i.RotationYawPitchRollToRef(e._y, e._x, e._z, t), t;
  }, i.FromUnitVectorsToRef = function(e, t, r) {
    var n = b.Dot(e, t) + 1;
    return n < ce ? Math.abs(e.x) > Math.abs(e.z) ? r.set(-e.y, e.x, 0, 0) : r.set(0, -e.z, e.y, 0) : (b.CrossToRef(e, t, D.Vector3[0]), r.set(D.Vector3[0].x, D.Vector3[0].y, D.Vector3[0].z, n)), r.normalize();
  }, i.RotationYawPitchRoll = function(e, t, r) {
    var n = new i();
    return i.RotationYawPitchRollToRef(e, t, r, n), n;
  }, i.RotationYawPitchRollToRef = function(e, t, r, n) {
    var a = r * 0.5, s = t * 0.5, o = e * 0.5, u = Math.sin(a), f = Math.cos(a), l = Math.sin(s), h = Math.cos(s), c = Math.sin(o), d = Math.cos(o);
    n.x = d * l * f + c * h * u, n.y = c * h * f - d * l * u, n.z = d * h * u - c * l * f, n.w = d * h * f + c * l * u;
  }, i.RotationAlphaBetaGamma = function(e, t, r) {
    var n = new i();
    return i.RotationAlphaBetaGammaToRef(e, t, r, n), n;
  }, i.RotationAlphaBetaGammaToRef = function(e, t, r, n) {
    var a = (r + e) * 0.5, s = (r - e) * 0.5, o = t * 0.5;
    n.x = Math.cos(s) * Math.sin(o), n.y = Math.sin(s) * Math.sin(o), n.z = Math.sin(a) * Math.cos(o), n.w = Math.cos(a) * Math.cos(o);
  }, i.RotationQuaternionFromAxis = function(e, t, r) {
    var n = new i(0, 0, 0, 0);
    return i.RotationQuaternionFromAxisToRef(e, t, r, n), n;
  }, i.RotationQuaternionFromAxisToRef = function(e, t, r, n) {
    var a = U.Matrix[0];
    I.FromXYZAxesToRef(e.normalize(), t.normalize(), r.normalize(), a), i.FromRotationMatrixToRef(a, n);
  }, i.FromLookDirectionLH = function(e, t) {
    var r = new i();
    return i.FromLookDirectionLHToRef(e, t, r), r;
  }, i.FromLookDirectionLHToRef = function(e, t, r) {
    var n = U.Matrix[0];
    I.LookDirectionLHToRef(e, t, n), i.FromRotationMatrixToRef(n, r);
  }, i.FromLookDirectionRH = function(e, t) {
    var r = new i();
    return i.FromLookDirectionRHToRef(e, t, r), r;
  }, i.FromLookDirectionRHToRef = function(e, t, r) {
    var n = U.Matrix[0];
    return I.LookDirectionRHToRef(e, t, n), i.FromRotationMatrixToRef(n, r);
  }, i.Slerp = function(e, t, r) {
    var n = i.Identity();
    return i.SlerpToRef(e, t, r, n), n;
  }, i.SlerpToRef = function(e, t, r, n) {
    var a, s, o = e._x * t._x + e._y * t._y + e._z * t._z + e._w * t._w, u = !1;
    if (o < 0 && (u = !0, o = -o), o > 0.999999)
      s = 1 - r, a = u ? -r : r;
    else {
      var f = Math.acos(o), l = 1 / Math.sin(f);
      s = Math.sin((1 - r) * f) * l, a = u ? -Math.sin(r * f) * l : Math.sin(r * f) * l;
    }
    n.x = s * e._x + a * t._x, n.y = s * e._y + a * t._y, n.z = s * e._z + a * t._z, n.w = s * e._w + a * t._w;
  }, i.Hermite = function(e, t, r, n, a) {
    var s = a * a, o = a * s, u = 2 * o - 3 * s + 1, f = -2 * o + 3 * s, l = o - 2 * s + a, h = o - s, c = e._x * u + r._x * f + t._x * l + n._x * h, d = e._y * u + r._y * f + t._y * l + n._y * h, p = e._z * u + r._z * f + t._z * l + n._z * h, g = e._w * u + r._w * f + t._w * l + n._w * h;
    return new i(c, d, p, g);
  }, i.Hermite1stDerivative = function(e, t, r, n, a) {
    var s = i.Zero();
    return this.Hermite1stDerivativeToRef(e, t, r, n, a, s), s;
  }, i.Hermite1stDerivativeToRef = function(e, t, r, n, a, s) {
    var o = a * a;
    s.x = (o - a) * 6 * e.x + (3 * o - 4 * a + 1) * t.x + (-o + a) * 6 * r.x + (3 * o - 2 * a) * n.x, s.y = (o - a) * 6 * e.y + (3 * o - 4 * a + 1) * t.y + (-o + a) * 6 * r.y + (3 * o - 2 * a) * n.y, s.z = (o - a) * 6 * e.z + (3 * o - 4 * a + 1) * t.z + (-o + a) * 6 * r.z + (3 * o - 2 * a) * n.z, s.w = (o - a) * 6 * e.w + (3 * o - 4 * a + 1) * t.w + (-o + a) * 6 * r.w + (3 * o - 2 * a) * n.w;
  }, i;
}(), I = function() {
  function i() {
    this._isIdentity = !1, this._isIdentityDirty = !0, this._isIdentity3x2 = !0, this._isIdentity3x2Dirty = !0, this.updateFlag = -1, St.MatrixTrackPrecisionChange && St.MatrixTrackedMatrices.push(this), this._m = new St.MatrixCurrentType(16), this.markAsUpdated();
  }
  return Object.defineProperty(i, "Use64Bits", {
    get: function() {
      return St.MatrixUse64Bits;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "m", {
    get: function() {
      return this._m;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.markAsUpdated = function() {
    this.updateFlag = i._UpdateFlagSeed++, this._isIdentity = !1, this._isIdentity3x2 = !1, this._isIdentityDirty = !0, this._isIdentity3x2Dirty = !0;
  }, i.prototype._updateIdentityStatus = function(e, t, r, n) {
    t === void 0 && (t = !1), r === void 0 && (r = !1), n === void 0 && (n = !0), this._isIdentity = e, this._isIdentity3x2 = e || r, this._isIdentityDirty = this._isIdentity ? !1 : t, this._isIdentity3x2Dirty = this._isIdentity3x2 ? !1 : n;
  }, i.prototype.isIdentity = function() {
    if (this._isIdentityDirty) {
      this._isIdentityDirty = !1;
      var e = this._m;
      this._isIdentity = e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 0 && e[4] === 0 && e[5] === 1 && e[6] === 0 && e[7] === 0 && e[8] === 0 && e[9] === 0 && e[10] === 1 && e[11] === 0 && e[12] === 0 && e[13] === 0 && e[14] === 0 && e[15] === 1;
    }
    return this._isIdentity;
  }, i.prototype.isIdentityAs3x2 = function() {
    return this._isIdentity3x2Dirty && (this._isIdentity3x2Dirty = !1, this._m[0] !== 1 || this._m[5] !== 1 || this._m[15] !== 1 ? this._isIdentity3x2 = !1 : this._m[1] !== 0 || this._m[2] !== 0 || this._m[3] !== 0 || this._m[4] !== 0 || this._m[6] !== 0 || this._m[7] !== 0 || this._m[8] !== 0 || this._m[9] !== 0 || this._m[10] !== 0 || this._m[11] !== 0 || this._m[12] !== 0 || this._m[13] !== 0 || this._m[14] !== 0 ? this._isIdentity3x2 = !1 : this._isIdentity3x2 = !0), this._isIdentity3x2;
  }, i.prototype.determinant = function() {
    if (this._isIdentity === !0)
      return 1;
    var e = this._m, t = e[0], r = e[1], n = e[2], a = e[3], s = e[4], o = e[5], u = e[6], f = e[7], l = e[8], h = e[9], c = e[10], d = e[11], p = e[12], g = e[13], _ = e[14], v = e[15], y = c * v - _ * d, E = h * v - g * d, R = h * _ - g * c, M = l * v - p * d, C = l * _ - c * p, A = l * g - p * h, S = +(o * y - u * E + f * R), w = -(s * y - u * M + f * C), F = +(s * E - o * M + f * A), x = -(s * R - o * C + u * A);
    return t * S + r * w + n * F + a * x;
  }, i.prototype.toArray = function() {
    return this._m;
  }, i.prototype.asArray = function() {
    return this._m;
  }, i.prototype.invert = function() {
    return this.invertToRef(this), this;
  }, i.prototype.reset = function() {
    return i.FromValuesToRef(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this), this._updateIdentityStatus(!1), this;
  }, i.prototype.add = function(e) {
    var t = new i();
    return this.addToRef(e, t), t;
  }, i.prototype.addToRef = function(e, t) {
    for (var r = this._m, n = t._m, a = e.m, s = 0; s < 16; s++)
      n[s] = r[s] + a[s];
    return t.markAsUpdated(), this;
  }, i.prototype.addToSelf = function(e) {
    for (var t = this._m, r = e.m, n = 0; n < 16; n++)
      t[n] += r[n];
    return this.markAsUpdated(), this;
  }, i.prototype.invertToRef = function(e) {
    if (this._isIdentity === !0)
      return i.IdentityToRef(e), this;
    var t = this._m, r = t[0], n = t[1], a = t[2], s = t[3], o = t[4], u = t[5], f = t[6], l = t[7], h = t[8], c = t[9], d = t[10], p = t[11], g = t[12], _ = t[13], v = t[14], y = t[15], E = d * y - v * p, R = c * y - _ * p, M = c * v - _ * d, C = h * y - g * p, A = h * v - d * g, S = h * _ - g * c, w = +(u * E - f * R + l * M), F = -(o * E - f * C + l * A), x = +(o * R - u * C + l * S), z = -(o * M - u * A + f * S), W = r * w + n * F + a * x + s * z;
    if (W === 0)
      return e.copyFrom(this), this;
    var N = 1 / W, Z = f * y - v * l, q = u * y - _ * l, ae = u * v - _ * f, Y = o * y - g * l, H = o * v - g * f, se = o * _ - g * u, Se = f * p - d * l, Be = u * p - c * l, Ge = u * d - c * f, Dt = o * p - h * l, ur = o * d - h * f, fr = o * c - h * u, Lr = -(n * E - a * R + s * M), Nr = +(r * E - a * C + s * A), Br = -(r * R - n * C + s * S), Ur = +(r * M - n * A + a * S), Vr = +(n * Z - a * q + s * ae), kr = -(r * Z - a * Y + s * H), st = +(r * q - n * Y + s * se), ot = -(r * ae - n * H + a * se), ut = -(n * Se - a * Be + s * Ge), ft = +(r * Se - a * Dt + s * ur), lr = -(r * Be - n * Dt + s * fr), En = +(r * Ge - n * ur + a * fr);
    return i.FromValuesToRef(w * N, Lr * N, Vr * N, ut * N, F * N, Nr * N, kr * N, ft * N, x * N, Br * N, st * N, lr * N, z * N, Ur * N, ot * N, En * N, e), this;
  }, i.prototype.addAtIndex = function(e, t) {
    return this._m[e] += t, this.markAsUpdated(), this;
  }, i.prototype.multiplyAtIndex = function(e, t) {
    return this._m[e] *= t, this.markAsUpdated(), this;
  }, i.prototype.setTranslationFromFloats = function(e, t, r) {
    return this._m[12] = e, this._m[13] = t, this._m[14] = r, this.markAsUpdated(), this;
  }, i.prototype.addTranslationFromFloats = function(e, t, r) {
    return this._m[12] += e, this._m[13] += t, this._m[14] += r, this.markAsUpdated(), this;
  }, i.prototype.setTranslation = function(e) {
    return this.setTranslationFromFloats(e._x, e._y, e._z);
  }, i.prototype.getTranslation = function() {
    return new b(this._m[12], this._m[13], this._m[14]);
  }, i.prototype.getTranslationToRef = function(e) {
    return e.x = this._m[12], e.y = this._m[13], e.z = this._m[14], this;
  }, i.prototype.removeRotationAndScaling = function() {
    var e = this.m;
    return i.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e[12], e[13], e[14], e[15], this), this._updateIdentityStatus(e[12] === 0 && e[13] === 0 && e[14] === 0 && e[15] === 1), this;
  }, i.prototype.multiply = function(e) {
    var t = new i();
    return this.multiplyToRef(e, t), t;
  }, i.prototype.copyFrom = function(e) {
    e.copyToArray(this._m);
    var t = e;
    return this.updateFlag = t.updateFlag, this._updateIdentityStatus(t._isIdentity, t._isIdentityDirty, t._isIdentity3x2, t._isIdentity3x2Dirty), this;
  }, i.prototype.copyToArray = function(e, t) {
    t === void 0 && (t = 0);
    var r = this._m;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], this;
  }, i.prototype.multiplyToRef = function(e, t) {
    return this._isIdentity ? (t.copyFrom(e), this) : e._isIdentity ? (t.copyFrom(this), this) : (this.multiplyToArray(e, t._m, 0), t.markAsUpdated(), this);
  }, i.prototype.multiplyToArray = function(e, t, r) {
    var n = this._m, a = e.m, s = n[0], o = n[1], u = n[2], f = n[3], l = n[4], h = n[5], c = n[6], d = n[7], p = n[8], g = n[9], _ = n[10], v = n[11], y = n[12], E = n[13], R = n[14], M = n[15], C = a[0], A = a[1], S = a[2], w = a[3], F = a[4], x = a[5], z = a[6], W = a[7], N = a[8], Z = a[9], q = a[10], ae = a[11], Y = a[12], H = a[13], se = a[14], Se = a[15];
    return t[r] = s * C + o * F + u * N + f * Y, t[r + 1] = s * A + o * x + u * Z + f * H, t[r + 2] = s * S + o * z + u * q + f * se, t[r + 3] = s * w + o * W + u * ae + f * Se, t[r + 4] = l * C + h * F + c * N + d * Y, t[r + 5] = l * A + h * x + c * Z + d * H, t[r + 6] = l * S + h * z + c * q + d * se, t[r + 7] = l * w + h * W + c * ae + d * Se, t[r + 8] = p * C + g * F + _ * N + v * Y, t[r + 9] = p * A + g * x + _ * Z + v * H, t[r + 10] = p * S + g * z + _ * q + v * se, t[r + 11] = p * w + g * W + _ * ae + v * Se, t[r + 12] = y * C + E * F + R * N + M * Y, t[r + 13] = y * A + E * x + R * Z + M * H, t[r + 14] = y * S + E * z + R * q + M * se, t[r + 15] = y * w + E * W + R * ae + M * Se, this;
  }, i.prototype.equals = function(e) {
    var t = e;
    if (!t)
      return !1;
    if ((this._isIdentity || t._isIdentity) && !this._isIdentityDirty && !t._isIdentityDirty)
      return this._isIdentity && t._isIdentity;
    var r = this.m, n = t.m;
    return r[0] === n[0] && r[1] === n[1] && r[2] === n[2] && r[3] === n[3] && r[4] === n[4] && r[5] === n[5] && r[6] === n[6] && r[7] === n[7] && r[8] === n[8] && r[9] === n[9] && r[10] === n[10] && r[11] === n[11] && r[12] === n[12] && r[13] === n[13] && r[14] === n[14] && r[15] === n[15];
  }, i.prototype.clone = function() {
    var e = new i();
    return e.copyFrom(this), e;
  }, i.prototype.getClassName = function() {
    return "Matrix";
  }, i.prototype.getHashCode = function() {
    for (var e = Le(this._m[0]), t = 1; t < 16; t++)
      e = e * 397 ^ Le(this._m[t]);
    return e;
  }, i.prototype.decomposeToTransformNode = function(e) {
    return e.rotationQuaternion = e.rotationQuaternion || new ie(), this.decompose(e.scaling, e.rotationQuaternion, e.position);
  }, i.prototype.decompose = function(e, t, r, n) {
    if (this._isIdentity)
      return r && r.setAll(0), e && e.setAll(1), t && t.copyFromFloats(0, 0, 0, 1), !0;
    var a = this._m;
    if (r && r.copyFromFloats(a[12], a[13], a[14]), e = e || U.Vector3[0], e.x = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]), e.y = Math.sqrt(a[4] * a[4] + a[5] * a[5] + a[6] * a[6]), e.z = Math.sqrt(a[8] * a[8] + a[9] * a[9] + a[10] * a[10]), n) {
      var s = n.scaling.x < 0 ? -1 : 1, o = n.scaling.y < 0 ? -1 : 1, u = n.scaling.z < 0 ? -1 : 1;
      e.x *= s, e.y *= o, e.z *= u;
    } else
      this.determinant() <= 0 && (e.y *= -1);
    if (e._x === 0 || e._y === 0 || e._z === 0)
      return t && t.copyFromFloats(0, 0, 0, 1), !1;
    if (t) {
      var f = 1 / e._x, l = 1 / e._y, h = 1 / e._z;
      i.FromValuesToRef(a[0] * f, a[1] * f, a[2] * f, 0, a[4] * l, a[5] * l, a[6] * l, 0, a[8] * h, a[9] * h, a[10] * h, 0, 0, 0, 0, 1, U.Matrix[0]), ie.FromRotationMatrixToRef(U.Matrix[0], t);
    }
    return !0;
  }, i.prototype.getRow = function(e) {
    if (e < 0 || e > 3)
      return null;
    var t = e * 4;
    return new yt(this._m[t + 0], this._m[t + 1], this._m[t + 2], this._m[t + 3]);
  }, i.prototype.setRow = function(e, t) {
    return this.setRowFromFloats(e, t.x, t.y, t.z, t.w);
  }, i.prototype.transpose = function() {
    return i.Transpose(this);
  }, i.prototype.transposeToRef = function(e) {
    return i.TransposeToRef(this, e), this;
  }, i.prototype.setRowFromFloats = function(e, t, r, n, a) {
    if (e < 0 || e > 3)
      return this;
    var s = e * 4;
    return this._m[s + 0] = t, this._m[s + 1] = r, this._m[s + 2] = n, this._m[s + 3] = a, this.markAsUpdated(), this;
  }, i.prototype.scale = function(e) {
    var t = new i();
    return this.scaleToRef(e, t), t;
  }, i.prototype.scaleToRef = function(e, t) {
    for (var r = 0; r < 16; r++)
      t._m[r] = this._m[r] * e;
    return t.markAsUpdated(), this;
  }, i.prototype.scaleAndAddToRef = function(e, t) {
    for (var r = 0; r < 16; r++)
      t._m[r] += this._m[r] * e;
    return t.markAsUpdated(), this;
  }, i.prototype.toNormalMatrix = function(e) {
    var t = U.Matrix[0];
    this.invertToRef(t), t.transposeToRef(e);
    var r = e._m;
    i.FromValuesToRef(r[0], r[1], r[2], 0, r[4], r[5], r[6], 0, r[8], r[9], r[10], 0, 0, 0, 0, 1, e);
  }, i.prototype.getRotationMatrix = function() {
    var e = new i();
    return this.getRotationMatrixToRef(e), e;
  }, i.prototype.getRotationMatrixToRef = function(e) {
    var t = U.Vector3[0];
    if (!this.decompose(t))
      return i.IdentityToRef(e), this;
    var r = this._m, n = 1 / t._x, a = 1 / t._y, s = 1 / t._z;
    return i.FromValuesToRef(r[0] * n, r[1] * n, r[2] * n, 0, r[4] * a, r[5] * a, r[6] * a, 0, r[8] * s, r[9] * s, r[10] * s, 0, 0, 0, 0, 1, e), this;
  }, i.prototype.toggleModelMatrixHandInPlace = function() {
    var e = this._m;
    e[2] *= -1, e[6] *= -1, e[8] *= -1, e[9] *= -1, e[14] *= -1, this.markAsUpdated();
  }, i.prototype.toggleProjectionMatrixHandInPlace = function() {
    var e = this._m;
    e[8] *= -1, e[9] *= -1, e[10] *= -1, e[11] *= -1, this.markAsUpdated();
  }, i.FromArray = function(e, t) {
    t === void 0 && (t = 0);
    var r = new i();
    return i.FromArrayToRef(e, t, r), r;
  }, i.FromArrayToRef = function(e, t, r) {
    for (var n = 0; n < 16; n++)
      r._m[n] = e[n + t];
    r.markAsUpdated();
  }, i.FromFloat32ArrayToRefScaled = function(e, t, r, n) {
    for (var a = 0; a < 16; a++)
      n._m[a] = e[a + t] * r;
    n.markAsUpdated();
  }, Object.defineProperty(i, "IdentityReadOnly", {
    get: function() {
      return i._IdentityReadOnly;
    },
    enumerable: !1,
    configurable: !0
  }), i.FromValuesToRef = function(e, t, r, n, a, s, o, u, f, l, h, c, d, p, g, _, v) {
    var y = v._m;
    y[0] = e, y[1] = t, y[2] = r, y[3] = n, y[4] = a, y[5] = s, y[6] = o, y[7] = u, y[8] = f, y[9] = l, y[10] = h, y[11] = c, y[12] = d, y[13] = p, y[14] = g, y[15] = _, v.markAsUpdated();
  }, i.FromValues = function(e, t, r, n, a, s, o, u, f, l, h, c, d, p, g, _) {
    var v = new i(), y = v._m;
    return y[0] = e, y[1] = t, y[2] = r, y[3] = n, y[4] = a, y[5] = s, y[6] = o, y[7] = u, y[8] = f, y[9] = l, y[10] = h, y[11] = c, y[12] = d, y[13] = p, y[14] = g, y[15] = _, v.markAsUpdated(), v;
  }, i.Compose = function(e, t, r) {
    var n = new i();
    return i.ComposeToRef(e, t, r, n), n;
  }, i.ComposeToRef = function(e, t, r, n) {
    var a = n._m, s = t._x, o = t._y, u = t._z, f = t._w, l = s + s, h = o + o, c = u + u, d = s * l, p = s * h, g = s * c, _ = o * h, v = o * c, y = u * c, E = f * l, R = f * h, M = f * c, C = e._x, A = e._y, S = e._z;
    a[0] = (1 - (_ + y)) * C, a[1] = (p + M) * C, a[2] = (g - R) * C, a[3] = 0, a[4] = (p - M) * A, a[5] = (1 - (d + y)) * A, a[6] = (v + E) * A, a[7] = 0, a[8] = (g + R) * S, a[9] = (v - E) * S, a[10] = (1 - (d + _)) * S, a[11] = 0, a[12] = r._x, a[13] = r._y, a[14] = r._z, a[15] = 1, n.markAsUpdated();
  }, i.Identity = function() {
    var e = i.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return e._updateIdentityStatus(!0), e;
  }, i.IdentityToRef = function(e) {
    i.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, e), e._updateIdentityStatus(!0);
  }, i.Zero = function() {
    var e = i.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    return e._updateIdentityStatus(!1), e;
  }, i.RotationX = function(e) {
    var t = new i();
    return i.RotationXToRef(e, t), t;
  }, i.Invert = function(e) {
    var t = new i();
    return e.invertToRef(t), t;
  }, i.RotationXToRef = function(e, t) {
    var r = Math.sin(e), n = Math.cos(e);
    i.FromValuesToRef(1, 0, 0, 0, 0, n, r, 0, 0, -r, n, 0, 0, 0, 0, 1, t), t._updateIdentityStatus(n === 1 && r === 0);
  }, i.RotationY = function(e) {
    var t = new i();
    return i.RotationYToRef(e, t), t;
  }, i.RotationYToRef = function(e, t) {
    var r = Math.sin(e), n = Math.cos(e);
    i.FromValuesToRef(n, 0, -r, 0, 0, 1, 0, 0, r, 0, n, 0, 0, 0, 0, 1, t), t._updateIdentityStatus(n === 1 && r === 0);
  }, i.RotationZ = function(e) {
    var t = new i();
    return i.RotationZToRef(e, t), t;
  }, i.RotationZToRef = function(e, t) {
    var r = Math.sin(e), n = Math.cos(e);
    i.FromValuesToRef(n, r, 0, 0, -r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, t), t._updateIdentityStatus(n === 1 && r === 0);
  }, i.RotationAxis = function(e, t) {
    var r = new i();
    return i.RotationAxisToRef(e, t, r), r;
  }, i.RotationAxisToRef = function(e, t, r) {
    var n = Math.sin(-t), a = Math.cos(-t), s = 1 - a;
    e.normalize();
    var o = r._m;
    o[0] = e._x * e._x * s + a, o[1] = e._x * e._y * s - e._z * n, o[2] = e._x * e._z * s + e._y * n, o[3] = 0, o[4] = e._y * e._x * s + e._z * n, o[5] = e._y * e._y * s + a, o[6] = e._y * e._z * s - e._x * n, o[7] = 0, o[8] = e._z * e._x * s - e._y * n, o[9] = e._z * e._y * s + e._x * n, o[10] = e._z * e._z * s + a, o[11] = 0, o[12] = 0, o[13] = 0, o[14] = 0, o[15] = 1, r.markAsUpdated();
  }, i.RotationAlignToRef = function(e, t, r) {
    var n = b.Dot(t, e), a = r._m;
    if (n < -1 + ce)
      a[0] = -1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = -1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0;
    else {
      var s = b.Cross(t, e), o = 1 / (1 + n);
      a[0] = s._x * s._x * o + n, a[1] = s._y * s._x * o - s._z, a[2] = s._z * s._x * o + s._y, a[3] = 0, a[4] = s._x * s._y * o + s._z, a[5] = s._y * s._y * o + n, a[6] = s._z * s._y * o - s._x, a[7] = 0, a[8] = s._x * s._z * o - s._y, a[9] = s._y * s._z * o + s._x, a[10] = s._z * s._z * o + n, a[11] = 0;
    }
    a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, r.markAsUpdated();
  }, i.RotationYawPitchRoll = function(e, t, r) {
    var n = new i();
    return i.RotationYawPitchRollToRef(e, t, r, n), n;
  }, i.RotationYawPitchRollToRef = function(e, t, r, n) {
    ie.RotationYawPitchRollToRef(e, t, r, U.Quaternion[0]), U.Quaternion[0].toRotationMatrix(n);
  }, i.Scaling = function(e, t, r) {
    var n = new i();
    return i.ScalingToRef(e, t, r, n), n;
  }, i.ScalingToRef = function(e, t, r, n) {
    i.FromValuesToRef(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1, n), n._updateIdentityStatus(e === 1 && t === 1 && r === 1);
  }, i.Translation = function(e, t, r) {
    var n = new i();
    return i.TranslationToRef(e, t, r, n), n;
  }, i.TranslationToRef = function(e, t, r, n) {
    i.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, t, r, 1, n), n._updateIdentityStatus(e === 0 && t === 0 && r === 0);
  }, i.Lerp = function(e, t, r) {
    var n = new i();
    return i.LerpToRef(e, t, r, n), n;
  }, i.LerpToRef = function(e, t, r, n) {
    for (var a = n._m, s = e.m, o = t.m, u = 0; u < 16; u++)
      a[u] = s[u] * (1 - r) + o[u] * r;
    n.markAsUpdated();
  }, i.DecomposeLerp = function(e, t, r) {
    var n = new i();
    return i.DecomposeLerpToRef(e, t, r, n), n;
  }, i.DecomposeLerpToRef = function(e, t, r, n) {
    var a = U.Vector3[0], s = U.Quaternion[0], o = U.Vector3[1];
    e.decompose(a, s, o);
    var u = U.Vector3[2], f = U.Quaternion[1], l = U.Vector3[3];
    t.decompose(u, f, l);
    var h = U.Vector3[4];
    b.LerpToRef(a, u, r, h);
    var c = U.Quaternion[2];
    ie.SlerpToRef(s, f, r, c);
    var d = U.Vector3[5];
    b.LerpToRef(o, l, r, d), i.ComposeToRef(h, c, d, n);
  }, i.LookAtLH = function(e, t, r) {
    var n = new i();
    return i.LookAtLHToRef(e, t, r, n), n;
  }, i.LookAtLHToRef = function(e, t, r, n) {
    var a = U.Vector3[0], s = U.Vector3[1], o = U.Vector3[2];
    t.subtractToRef(e, o), o.normalize(), b.CrossToRef(r, o, a);
    var u = a.lengthSquared();
    u === 0 ? a.x = 1 : a.normalizeFromLength(Math.sqrt(u)), b.CrossToRef(o, a, s), s.normalize();
    var f = -b.Dot(a, e), l = -b.Dot(s, e), h = -b.Dot(o, e);
    i.FromValuesToRef(a._x, s._x, o._x, 0, a._y, s._y, o._y, 0, a._z, s._z, o._z, 0, f, l, h, 1, n);
  }, i.LookAtRH = function(e, t, r) {
    var n = new i();
    return i.LookAtRHToRef(e, t, r, n), n;
  }, i.LookAtRHToRef = function(e, t, r, n) {
    var a = U.Vector3[0], s = U.Vector3[1], o = U.Vector3[2];
    e.subtractToRef(t, o), o.normalize(), b.CrossToRef(r, o, a);
    var u = a.lengthSquared();
    u === 0 ? a.x = 1 : a.normalizeFromLength(Math.sqrt(u)), b.CrossToRef(o, a, s), s.normalize();
    var f = -b.Dot(a, e), l = -b.Dot(s, e), h = -b.Dot(o, e);
    i.FromValuesToRef(a._x, s._x, o._x, 0, a._y, s._y, o._y, 0, a._z, s._z, o._z, 0, f, l, h, 1, n);
  }, i.LookDirectionLH = function(e, t) {
    var r = new i();
    return i.LookDirectionLHToRef(e, t, r), r;
  }, i.LookDirectionLHToRef = function(e, t, r) {
    var n = U.Vector3[0];
    n.copyFrom(e), n.scaleInPlace(-1);
    var a = U.Vector3[1];
    b.CrossToRef(t, n, a), i.FromValuesToRef(a._x, a._y, a._z, 0, t._x, t._y, t._z, 0, n._x, n._y, n._z, 0, 0, 0, 0, 1, r);
  }, i.LookDirectionRH = function(e, t) {
    var r = new i();
    return i.LookDirectionRHToRef(e, t, r), r;
  }, i.LookDirectionRHToRef = function(e, t, r) {
    var n = U.Vector3[2];
    b.CrossToRef(t, e, n), i.FromValuesToRef(n._x, n._y, n._z, 0, t._x, t._y, t._z, 0, e._x, e._y, e._z, 0, 0, 0, 0, 1, r);
  }, i.OrthoLH = function(e, t, r, n, a) {
    var s = new i();
    return i.OrthoLHToRef(e, t, r, n, s, a), s;
  }, i.OrthoLHToRef = function(e, t, r, n, a, s) {
    var o = r, u = n, f = 2 / e, l = 2 / t, h = 2 / (u - o), c = -(u + o) / (u - o);
    i.FromValuesToRef(f, 0, 0, 0, 0, l, 0, 0, 0, 0, h, 0, 0, 0, c, 1, a), s && a.multiplyToRef(_t, a), a._updateIdentityStatus(f === 1 && l === 1 && h === 1 && c === 0);
  }, i.OrthoOffCenterLH = function(e, t, r, n, a, s, o) {
    var u = new i();
    return i.OrthoOffCenterLHToRef(e, t, r, n, a, s, u, o), u;
  }, i.OrthoOffCenterLHToRef = function(e, t, r, n, a, s, o, u) {
    var f = a, l = s, h = 2 / (t - e), c = 2 / (n - r), d = 2 / (l - f), p = -(l + f) / (l - f), g = (e + t) / (e - t), _ = (n + r) / (r - n);
    i.FromValuesToRef(h, 0, 0, 0, 0, c, 0, 0, 0, 0, d, 0, g, _, p, 1, o), u && o.multiplyToRef(_t, o), o.markAsUpdated();
  }, i.OrthoOffCenterRH = function(e, t, r, n, a, s, o) {
    var u = new i();
    return i.OrthoOffCenterRHToRef(e, t, r, n, a, s, u, o), u;
  }, i.OrthoOffCenterRHToRef = function(e, t, r, n, a, s, o, u) {
    i.OrthoOffCenterLHToRef(e, t, r, n, a, s, o, u), o._m[10] *= -1;
  }, i.PerspectiveLH = function(e, t, r, n, a, s) {
    s === void 0 && (s = 0);
    var o = new i(), u = r, f = n, l = 2 * u / e, h = 2 * u / t, c = (f + u) / (f - u), d = -2 * f * u / (f - u), p = Math.tan(s);
    return i.FromValuesToRef(l, 0, 0, 0, 0, h, 0, p, 0, 0, c, 1, 0, 0, d, 0, o), a && o.multiplyToRef(_t, o), o._updateIdentityStatus(!1), o;
  }, i.PerspectiveFovLH = function(e, t, r, n, a, s, o) {
    s === void 0 && (s = 0), o === void 0 && (o = !1);
    var u = new i();
    return i.PerspectiveFovLHToRef(e, t, r, n, u, !0, a, s, o), u;
  }, i.PerspectiveFovLHToRef = function(e, t, r, n, a, s, o, u, f) {
    s === void 0 && (s = !0), u === void 0 && (u = 0), f === void 0 && (f = !1);
    var l = r, h = n, c = 1 / Math.tan(e * 0.5), d = s ? c / t : c, p = s ? c : c * t, g = f && l === 0 ? -1 : h !== 0 ? (h + l) / (h - l) : 1, _ = f && l === 0 ? 2 * h : h !== 0 ? -2 * h * l / (h - l) : -2 * l, v = Math.tan(u);
    i.FromValuesToRef(d, 0, 0, 0, 0, p, 0, v, 0, 0, g, 1, 0, 0, _, 0, a), o && a.multiplyToRef(_t, a), a._updateIdentityStatus(!1);
  }, i.PerspectiveFovReverseLHToRef = function(e, t, r, n, a, s, o, u) {
    s === void 0 && (s = !0), u === void 0 && (u = 0);
    var f = 1 / Math.tan(e * 0.5), l = s ? f / t : f, h = s ? f : f * t, c = Math.tan(u);
    i.FromValuesToRef(l, 0, 0, 0, 0, h, 0, c, 0, 0, -r, 1, 0, 0, 1, 0, a), o && a.multiplyToRef(_t, a), a._updateIdentityStatus(!1);
  }, i.PerspectiveFovRH = function(e, t, r, n, a, s, o) {
    s === void 0 && (s = 0), o === void 0 && (o = !1);
    var u = new i();
    return i.PerspectiveFovRHToRef(e, t, r, n, u, !0, a, s, o), u;
  }, i.PerspectiveFovRHToRef = function(e, t, r, n, a, s, o, u, f) {
    s === void 0 && (s = !0), u === void 0 && (u = 0), f === void 0 && (f = !1);
    var l = r, h = n, c = 1 / Math.tan(e * 0.5), d = s ? c / t : c, p = s ? c : c * t, g = f && l === 0 ? 1 : h !== 0 ? -(h + l) / (h - l) : -1, _ = f && l === 0 ? 2 * h : h !== 0 ? -2 * h * l / (h - l) : -2 * l, v = Math.tan(u);
    i.FromValuesToRef(d, 0, 0, 0, 0, p, 0, v, 0, 0, g, -1, 0, 0, _, 0, a), o && a.multiplyToRef(_t, a), a._updateIdentityStatus(!1);
  }, i.PerspectiveFovReverseRHToRef = function(e, t, r, n, a, s, o, u) {
    s === void 0 && (s = !0), u === void 0 && (u = 0);
    var f = 1 / Math.tan(e * 0.5), l = s ? f / t : f, h = s ? f : f * t, c = Math.tan(u);
    i.FromValuesToRef(l, 0, 0, 0, 0, h, 0, c, 0, 0, -r, -1, 0, 0, -1, 0, a), o && a.multiplyToRef(_t, a), a._updateIdentityStatus(!1);
  }, i.PerspectiveFovWebVRToRef = function(e, t, r, n, a, s, o) {
    a === void 0 && (a = !1), o === void 0 && (o = 0);
    var u = a ? -1 : 1, f = Math.tan(e.upDegrees * Math.PI / 180), l = Math.tan(e.downDegrees * Math.PI / 180), h = Math.tan(e.leftDegrees * Math.PI / 180), c = Math.tan(e.rightDegrees * Math.PI / 180), d = 2 / (h + c), p = 2 / (f + l), g = Math.tan(o), _ = n._m;
    _[0] = d, _[1] = _[2] = _[3] = _[4] = 0, _[5] = p, _[6] = 0, _[7] = g, _[8] = (h - c) * d * 0.5, _[9] = -((f - l) * p * 0.5), _[10] = -r / (t - r), _[11] = 1 * u, _[12] = _[13] = _[15] = 0, _[14] = -(2 * r * t) / (r - t), s && n.multiplyToRef(_t, n), n.markAsUpdated();
  }, i.GetFinalMatrix = function(e, t, r, n, a, s) {
    var o = e.width, u = e.height, f = e.x, l = e.y, h = i.FromValues(o / 2, 0, 0, 0, 0, -u / 2, 0, 0, 0, 0, s - a, 0, f + o / 2, u / 2 + l, a, 1), c = U.Matrix[0];
    return t.multiplyToRef(r, c), c.multiplyToRef(n, c), c.multiply(h);
  }, i.GetAsMatrix2x2 = function(e) {
    var t = e.m, r = [t[0], t[1], t[4], t[5]];
    return St.MatrixUse64Bits ? r : new Float32Array(r);
  }, i.GetAsMatrix3x3 = function(e) {
    var t = e.m, r = [t[0], t[1], t[2], t[4], t[5], t[6], t[8], t[9], t[10]];
    return St.MatrixUse64Bits ? r : new Float32Array(r);
  }, i.Transpose = function(e) {
    var t = new i();
    return i.TransposeToRef(e, t), t;
  }, i.TransposeToRef = function(e, t) {
    var r = t._m, n = e.m;
    r[0] = n[0], r[1] = n[4], r[2] = n[8], r[3] = n[12], r[4] = n[1], r[5] = n[5], r[6] = n[9], r[7] = n[13], r[8] = n[2], r[9] = n[6], r[10] = n[10], r[11] = n[14], r[12] = n[3], r[13] = n[7], r[14] = n[11], r[15] = n[15], t.markAsUpdated(), t._updateIdentityStatus(e._isIdentity, e._isIdentityDirty);
  }, i.Reflection = function(e) {
    var t = new i();
    return i.ReflectionToRef(e, t), t;
  }, i.ReflectionToRef = function(e, t) {
    e.normalize();
    var r = e.normal.x, n = e.normal.y, a = e.normal.z, s = -2 * r, o = -2 * n, u = -2 * a;
    i.FromValuesToRef(s * r + 1, o * r, u * r, 0, s * n, o * n + 1, u * n, 0, s * a, o * a, u * a + 1, 0, s * e.d, o * e.d, u * e.d, 1, t);
  }, i.FromXYZAxesToRef = function(e, t, r, n) {
    i.FromValuesToRef(e._x, e._y, e._z, 0, t._x, t._y, t._z, 0, r._x, r._y, r._z, 0, 0, 0, 0, 1, n);
  }, i.FromQuaternionToRef = function(e, t) {
    var r = e._x * e._x, n = e._y * e._y, a = e._z * e._z, s = e._x * e._y, o = e._z * e._w, u = e._z * e._x, f = e._y * e._w, l = e._y * e._z, h = e._x * e._w;
    t._m[0] = 1 - 2 * (n + a), t._m[1] = 2 * (s + o), t._m[2] = 2 * (u - f), t._m[3] = 0, t._m[4] = 2 * (s - o), t._m[5] = 1 - 2 * (a + r), t._m[6] = 2 * (l + h), t._m[7] = 0, t._m[8] = 2 * (u + f), t._m[9] = 2 * (l - h), t._m[10] = 1 - 2 * (n + r), t._m[11] = 0, t._m[12] = 0, t._m[13] = 0, t._m[14] = 0, t._m[15] = 1, t.markAsUpdated();
  }, i._UpdateFlagSeed = 0, i._IdentityReadOnly = i.Identity(), i;
}(), U = function() {
  function i() {
  }
  return i.Vector3 = xe.BuildTuple(11, b.Zero), i.Matrix = xe.BuildTuple(2, I.Identity), i.Quaternion = xe.BuildTuple(3, ie.Zero), i;
}(), D = function() {
  function i() {
  }
  return i.Vector2 = xe.BuildTuple(3, Ee.Zero), i.Vector3 = xe.BuildTuple(13, b.Zero), i.Vector4 = xe.BuildTuple(3, yt.Zero), i.Quaternion = xe.BuildTuple(2, ie.Zero), i.Matrix = xe.BuildTuple(8, I.Identity), i;
}();
Ne("BABYLON.Vector2", Ee);
Ne("BABYLON.Vector3", b);
Ne("BABYLON.Vector4", yt);
Ne("BABYLON.Matrix", I);
var _t = I.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1), ei = function(i, e) {
  return ei = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var n in r)
      Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
  }, ei(i, e);
};
function K(i, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  ei(i, e);
  function t() {
    this.constructor = i;
  }
  i.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var Tt = function() {
  return Tt = Object.assign || function(e) {
    for (var t, r = 1, n = arguments.length; r < n; r++) {
      t = arguments[r];
      for (var a in t)
        Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
    }
    return e;
  }, Tt.apply(this, arguments);
};
function T(i, e, t, r) {
  var n = arguments.length, a = n < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    a = Reflect.decorate(i, e, t, r);
  else
    for (var o = i.length - 1; o >= 0; o--)
      (s = i[o]) && (a = (n < 3 ? s(a) : n > 3 ? s(e, t, a) : s(e, t)) || a);
  return n > 3 && a && Object.defineProperty(e, t, a), a;
}
function fi(i, e, t, r) {
  function n(a) {
    return a instanceof t ? a : new t(function(s) {
      s(a);
    });
  }
  return new (t || (t = Promise))(function(a, s) {
    function o(l) {
      try {
        f(r.next(l));
      } catch (h) {
        s(h);
      }
    }
    function u(l) {
      try {
        f(r.throw(l));
      } catch (h) {
        s(h);
      }
    }
    function f(l) {
      l.done ? a(l.value) : n(l.value).then(o, u);
    }
    f((r = r.apply(i, e || [])).next());
  });
}
function Gt(i, e) {
  var t = { label: 0, sent: function() {
    if (a[0] & 1)
      throw a[1];
    return a[1];
  }, trys: [], ops: [] }, r, n, a, s;
  return s = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function o(f) {
    return function(l) {
      return u([f, l]);
    };
  }
  function u(f) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (r = 1, n && (a = f[0] & 2 ? n.return : f[0] ? n.throw || ((a = n.return) && a.call(n), 0) : n.next) && !(a = a.call(n, f[1])).done)
          return a;
        switch (n = 0, a && (f = [f[0] & 2, a.value]), f[0]) {
          case 0:
          case 1:
            a = f;
            break;
          case 4:
            return t.label++, { value: f[1], done: !1 };
          case 5:
            t.label++, n = f[1], f = [0];
            continue;
          case 7:
            f = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (a = t.trys, !(a = a.length > 0 && a[a.length - 1]) && (f[0] === 6 || f[0] === 2)) {
              t = 0;
              continue;
            }
            if (f[0] === 3 && (!a || f[1] > a[0] && f[1] < a[3])) {
              t.label = f[1];
              break;
            }
            if (f[0] === 6 && t.label < a[1]) {
              t.label = a[1], a = f;
              break;
            }
            if (a && t.label < a[2]) {
              t.label = a[2], t.ops.push(f);
              break;
            }
            a[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        f = e.call(i, t);
      } catch (l) {
        f = [6, l], n = 0;
      } finally {
        r = a = 0;
      }
    if (f[0] & 5)
      throw f[1];
    return { value: f[0] ? f[1] : void 0, done: !0 };
  }
}
var Mn = function() {
  function i(e, t, r, n) {
    t === void 0 && (t = !1), this.initialize(e, t, r, n);
  }
  return i.prototype.initialize = function(e, t, r, n) {
    return t === void 0 && (t = !1), this.mask = e, this.skipNextObservers = t, this.target = r, this.currentTarget = n, this;
  }, i;
}(), An = function() {
  function i(e, t, r) {
    r === void 0 && (r = null), this.callback = e, this.mask = t, this.scope = r, this._willBeUnregistered = !1, this.unregisterOnNextCall = !1;
  }
  return i;
}(), O = function() {
  function i(e) {
    this._observers = new Array(), this._eventState = new Mn(0), e && (this._onObserverAdded = e);
  }
  return i.FromPromise = function(e, t) {
    var r = new i();
    return e.then(function(n) {
      r.notifyObservers(n);
    }).catch(function(n) {
      if (t)
        t.notifyObservers(n);
      else
        throw n;
    }), r;
  }, Object.defineProperty(i.prototype, "observers", {
    get: function() {
      return this._observers;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.add = function(e, t, r, n, a) {
    if (t === void 0 && (t = -1), r === void 0 && (r = !1), n === void 0 && (n = null), a === void 0 && (a = !1), !e)
      return null;
    var s = new An(e, t, n);
    return s.unregisterOnNextCall = a, r ? this._observers.unshift(s) : this._observers.push(s), this._onObserverAdded && this._onObserverAdded(s), s;
  }, i.prototype.addOnce = function(e) {
    return this.add(e, void 0, void 0, void 0, !0);
  }, i.prototype.remove = function(e) {
    if (!e)
      return !1;
    var t = this._observers.indexOf(e);
    return t !== -1 ? (this._deferUnregister(e), !0) : !1;
  }, i.prototype.removeCallback = function(e, t) {
    for (var r = 0; r < this._observers.length; r++) {
      var n = this._observers[r];
      if (!n._willBeUnregistered && n.callback === e && (!t || t === n.scope))
        return this._deferUnregister(n), !0;
    }
    return !1;
  }, i.prototype._deferUnregister = function(e) {
    var t = this;
    e.unregisterOnNextCall = !1, e._willBeUnregistered = !0, setTimeout(function() {
      t._remove(e);
    }, 0);
  }, i.prototype._remove = function(e) {
    if (!e)
      return !1;
    var t = this._observers.indexOf(e);
    return t !== -1 ? (this._observers.splice(t, 1), !0) : !1;
  }, i.prototype.makeObserverTopPriority = function(e) {
    this._remove(e), this._observers.unshift(e);
  }, i.prototype.makeObserverBottomPriority = function(e) {
    this._remove(e), this._observers.push(e);
  }, i.prototype.notifyObservers = function(e, t, r, n, a) {
    if (t === void 0 && (t = -1), !this._observers.length)
      return !0;
    var s = this._eventState;
    s.mask = t, s.target = r, s.currentTarget = n, s.skipNextObservers = !1, s.lastReturnValue = e, s.userInfo = a;
    for (var o = 0, u = this._observers; o < u.length; o++) {
      var f = u[o];
      if (!f._willBeUnregistered && (f.mask & t && (f.scope ? s.lastReturnValue = f.callback.apply(f.scope, [e, s]) : s.lastReturnValue = f.callback(e, s), f.unregisterOnNextCall && this._deferUnregister(f)), s.skipNextObservers))
        return !1;
    }
    return !0;
  }, i.prototype.notifyObserversWithPromise = function(e, t, r, n, a) {
    var s = this;
    t === void 0 && (t = -1);
    var o = Promise.resolve(e);
    if (!this._observers.length)
      return o;
    var u = this._eventState;
    return u.mask = t, u.target = r, u.currentTarget = n, u.skipNextObservers = !1, u.userInfo = a, this._observers.forEach(function(f) {
      u.skipNextObservers || f._willBeUnregistered || f.mask & t && (f.scope ? o = o.then(function(l) {
        return u.lastReturnValue = l, f.callback.apply(f.scope, [e, u]);
      }) : o = o.then(function(l) {
        return u.lastReturnValue = l, f.callback(e, u);
      }), f.unregisterOnNextCall && s._deferUnregister(f));
    }), o.then(function() {
      return e;
    });
  }, i.prototype.notifyObserver = function(e, t, r) {
    if (r === void 0 && (r = -1), !e._willBeUnregistered) {
      var n = this._eventState;
      n.mask = r, n.skipNextObservers = !1, e.callback(t, n), e.unregisterOnNextCall && this._deferUnregister(e);
    }
  }, i.prototype.hasObservers = function() {
    return this._observers.length > 0;
  }, i.prototype.clear = function() {
    this._observers = new Array(), this._onObserverAdded = null;
  }, i.prototype.clone = function() {
    var e = new i();
    return e._observers = this._observers.slice(0), e;
  }, i.prototype.hasSpecificMask = function(e) {
    e === void 0 && (e = -1);
    for (var t = 0, r = this._observers; t < r.length; t++) {
      var n = r[t];
      if (n.mask & e || n.mask === e)
        return !0;
    }
    return !1;
  }, i;
}(), Rn = function() {
  function i() {
    this.samplingMode = -1, this._useMipMaps = !0, this._cachedWrapU = null, this._cachedWrapV = null, this._cachedWrapR = null, this._cachedAnisotropicFilteringLevel = null, this._comparisonFunction = 0;
  }
  return Object.defineProperty(i.prototype, "wrapU", {
    get: function() {
      return this._cachedWrapU;
    },
    set: function(e) {
      this._cachedWrapU = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "wrapV", {
    get: function() {
      return this._cachedWrapV;
    },
    set: function(e) {
      this._cachedWrapV = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "wrapR", {
    get: function() {
      return this._cachedWrapR;
    },
    set: function(e) {
      this._cachedWrapR = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "anisotropicFilteringLevel", {
    get: function() {
      return this._cachedAnisotropicFilteringLevel;
    },
    set: function(e) {
      this._cachedAnisotropicFilteringLevel = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "comparisonFunction", {
    get: function() {
      return this._comparisonFunction;
    },
    set: function(e) {
      this._comparisonFunction = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "useMipMaps", {
    get: function() {
      return this._useMipMaps;
    },
    set: function(e) {
      this._useMipMaps = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.setParameters = function(e, t, r, n, a, s) {
    return e === void 0 && (e = 1), t === void 0 && (t = 1), r === void 0 && (r = 1), n === void 0 && (n = 1), a === void 0 && (a = 2), s === void 0 && (s = 0), this._cachedWrapU = e, this._cachedWrapV = t, this._cachedWrapR = r, this._cachedAnisotropicFilteringLevel = n, this.samplingMode = a, this._comparisonFunction = s, this;
  }, i.prototype.compareSampler = function(e) {
    return this._cachedWrapU === e._cachedWrapU && this._cachedWrapV === e._cachedWrapV && this._cachedWrapR === e._cachedWrapR && this._cachedAnisotropicFilteringLevel === e._cachedAnisotropicFilteringLevel && this.samplingMode === e.samplingMode && this._comparisonFunction === e._comparisonFunction && this._useMipMaps === e._useMipMaps;
  }, i;
}(), ve;
(function(i) {
  i[i.Unknown = 0] = "Unknown", i[i.Url = 1] = "Url", i[i.Temp = 2] = "Temp", i[i.Raw = 3] = "Raw", i[i.Dynamic = 4] = "Dynamic", i[i.RenderTarget = 5] = "RenderTarget", i[i.MultiRenderTarget = 6] = "MultiRenderTarget", i[i.Cube = 7] = "Cube", i[i.CubeRaw = 8] = "CubeRaw", i[i.CubePrefiltered = 9] = "CubePrefiltered", i[i.Raw3D = 10] = "Raw3D", i[i.Raw2DArray = 11] = "Raw2DArray", i[i.DepthStencil = 12] = "DepthStencil", i[i.CubeRawRGBD = 13] = "CubeRawRGBD", i[i.Depth = 14] = "Depth";
})(ve || (ve = {}));
var Bt = function(i) {
  K(e, i);
  function e(t, r, n) {
    n === void 0 && (n = !1);
    var a = i.call(this) || this;
    return a.isReady = !1, a.isCube = !1, a.is3D = !1, a.is2DArray = !1, a.isMultiview = !1, a.url = "", a.generateMipMaps = !1, a.samples = 0, a.type = -1, a.format = -1, a.onLoadedObservable = new O(), a.onErrorObservable = new O(), a.onRebuildCallback = null, a.width = 0, a.height = 0, a.depth = 0, a.baseWidth = 0, a.baseHeight = 0, a.baseDepth = 0, a.invertY = !1, a._invertVScale = !1, a._associatedChannel = -1, a._source = ve.Unknown, a._buffer = null, a._bufferView = null, a._bufferViewArray = null, a._bufferViewArrayArray = null, a._size = 0, a._extension = "", a._files = null, a._workingCanvas = null, a._workingContext = null, a._cachedCoordinatesMode = null, a._isDisabled = !1, a._compression = null, a._sphericalPolynomial = null, a._sphericalPolynomialPromise = null, a._sphericalPolynomialComputed = !1, a._lodGenerationScale = 0, a._lodGenerationOffset = 0, a._useSRGBBuffer = !1, a._lodTextureHigh = null, a._lodTextureMid = null, a._lodTextureLow = null, a._isRGBD = !1, a._linearSpecularLOD = !1, a._irradianceTexture = null, a._hardwareTexture = null, a._maxLodLevel = null, a._references = 1, a._gammaSpace = null, a._engine = t, a._source = r, a._uniqueId = e._Counter++, n || (a._hardwareTexture = t._createHardwareTexture()), a;
  }
  return Object.defineProperty(e.prototype, "useMipMaps", {
    get: function() {
      return this.generateMipMaps;
    },
    set: function(t) {
      this.generateMipMaps = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "uniqueId", {
    get: function() {
      return this._uniqueId;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getEngine = function() {
    return this._engine;
  }, Object.defineProperty(e.prototype, "source", {
    get: function() {
      return this._source;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.incrementReferences = function() {
    this._references++;
  }, e.prototype.updateSize = function(t, r, n) {
    n === void 0 && (n = 1), this._engine.updateTextureDimensions(this, t, r, n), this.width = t, this.height = r, this.depth = n, this.baseWidth = t, this.baseHeight = r, this.baseDepth = n, this._size = t * r * n;
  }, e.prototype._rebuild = function() {
    var t = this, r;
    if (this.isReady = !1, this._cachedCoordinatesMode = null, this._cachedWrapU = null, this._cachedWrapV = null, this._cachedWrapR = null, this._cachedAnisotropicFilteringLevel = null, this.onRebuildCallback) {
      var n = this.onRebuildCallback(this), a = function(o) {
        o._swapAndDie(t, !1), t.isReady = n.isReady;
      };
      n.isAsync ? n.proxy.then(a) : a(n.proxy);
      return;
    }
    var s;
    switch (this.source) {
      case ve.Temp:
        break;
      case ve.Url:
        s = this._engine.createTexture((r = this._originalUrl) !== null && r !== void 0 ? r : this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, function() {
          s._swapAndDie(t, !1), t.isReady = !0;
        }, null, this._buffer, void 0, this.format, this._extension, void 0, void 0, void 0, this._useSRGBBuffer);
        return;
      case ve.Raw:
        s = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type, void 0, this._useSRGBBuffer), s._swapAndDie(this, !1), this.isReady = !0;
        break;
      case ve.Raw3D:
        s = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type), s._swapAndDie(this, !1), this.isReady = !0;
        break;
      case ve.Raw2DArray:
        s = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type), s._swapAndDie(this, !1), this.isReady = !0;
        break;
      case ve.Dynamic:
        s = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode), s._swapAndDie(this, !1), this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas(), this.invertY, void 0, void 0, !0);
        break;
      case ve.Cube:
        s = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, function() {
          s._swapAndDie(t, !1), t.isReady = !0;
        }, null, this.format, this._extension, !1, 0, 0, null, void 0, this._useSRGBBuffer);
        return;
      case ve.CubeRaw:
        s = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression), s._swapAndDie(this, !1), this.isReady = !0;
        break;
      case ve.CubeRawRGBD:
        return;
      case ve.CubePrefiltered:
        s = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, function(o) {
          o && o._swapAndDie(t, !1), t.isReady = !0;
        }, null, this.format, this._extension), s._sphericalPolynomial = this._sphericalPolynomial;
        return;
    }
  }, e.prototype._swapAndDie = function(t, r) {
    var n;
    r === void 0 && (r = !0), (n = this._hardwareTexture) === null || n === void 0 || n.setUsage(t._source, this.generateMipMaps, this.isCube, this.width, this.height), t._hardwareTexture = this._hardwareTexture, r && (t._isRGBD = this._isRGBD), this._lodTextureHigh && (t._lodTextureHigh && t._lodTextureHigh.dispose(), t._lodTextureHigh = this._lodTextureHigh), this._lodTextureMid && (t._lodTextureMid && t._lodTextureMid.dispose(), t._lodTextureMid = this._lodTextureMid), this._lodTextureLow && (t._lodTextureLow && t._lodTextureLow.dispose(), t._lodTextureLow = this._lodTextureLow), this._irradianceTexture && (t._irradianceTexture && t._irradianceTexture.dispose(), t._irradianceTexture = this._irradianceTexture);
    var a = this._engine.getLoadedTexturesCache(), s = a.indexOf(this);
    s !== -1 && a.splice(s, 1), s = a.indexOf(t), s === -1 && a.push(t);
  }, e.prototype.dispose = function() {
    this._references--, this.onLoadedObservable.clear(), this.onErrorObservable.clear(), this._references === 0 && (this._engine._releaseTexture(this), this._hardwareTexture = null);
  }, e._Counter = 0, e;
}(Rn);
function me() {
  return typeof window < "u";
}
function $i() {
  return typeof navigator < "u";
}
function br() {
  return typeof document < "u";
}
function li(i) {
  for (var e = "", t = i.firstChild; t; )
    t.nodeType === 3 && (e += t.textContent), t = t.nextSibling;
  return e;
}
var ti = {
  IsWindowObjectExist: me,
  IsNavigatorAvailable: $i,
  IsDocumentAvailable: br,
  GetDOMTextContent: li
};
function G(i) {
  return "".concat(i, " needs to be imported before as it contains a side-effect required by your code.");
}
var k = function() {
  function i() {
  }
  return i._CheckLimit = function(e, t) {
    var r = i._LogLimitOutputs[e];
    return r ? r.current++ : (r = { limit: t, current: 1 }, i._LogLimitOutputs[e] = r), r.current <= r.limit;
  }, i._GenerateLimitMessage = function(e, t) {
    var r = i._LogLimitOutputs[e];
    if (!(!r || !i.MessageLimitReached) && r.current === r.limit)
      switch (t) {
        case 0:
          i.Log(i.MessageLimitReached.replace(/%LIMIT%/g, "" + r.limit).replace(/%TYPE%/g, "log"));
          break;
        case 1:
          i.Warn(i.MessageLimitReached.replace(/%LIMIT%/g, "" + r.limit).replace(/%TYPE%/g, "warning"));
          break;
        case 2:
          i.Error(i.MessageLimitReached.replace(/%LIMIT%/g, "" + r.limit).replace(/%TYPE%/g, "error"));
          break;
      }
  }, i._AddLogEntry = function(e) {
    i._LogCache = e + i._LogCache, i.OnNewCacheEntry && i.OnNewCacheEntry(e);
  }, i._FormatMessage = function(e) {
    var t = function(n) {
      return n < 10 ? "0" + n : "" + n;
    }, r = new Date();
    return "[" + t(r.getHours()) + ":" + t(r.getMinutes()) + ":" + t(r.getSeconds()) + "]: " + e;
  }, i._LogDisabled = function(e, t) {
  }, i._LogEnabled = function(e, t) {
    if (!(t !== void 0 && !i._CheckLimit(e, t))) {
      var r = i._FormatMessage(e);
      console.log("BJS - " + r);
      var n = "<div style='color:white'>" + r + "</div><br>";
      i._AddLogEntry(n), i._GenerateLimitMessage(e, 0);
    }
  }, i._WarnDisabled = function(e, t) {
  }, i._WarnEnabled = function(e, t) {
    if (!(t !== void 0 && !i._CheckLimit(e, t))) {
      var r = i._FormatMessage(e);
      console.warn("BJS - " + r);
      var n = "<div style='color:orange'>" + e + "</div><br>";
      i._AddLogEntry(n), i._GenerateLimitMessage(e, 1);
    }
  }, i._ErrorDisabled = function(e, t) {
  }, i._ErrorEnabled = function(e, t) {
    if (!(t !== void 0 && !i._CheckLimit(e, t))) {
      var r = i._FormatMessage(e);
      i.errorsCount++, console.error("BJS - " + r);
      var n = "<div style='color:red'>" + r + "</div><br>";
      i._AddLogEntry(n), i._GenerateLimitMessage(e, 2);
    }
  }, Object.defineProperty(i, "LogCache", {
    get: function() {
      return i._LogCache;
    },
    enumerable: !1,
    configurable: !0
  }), i.ClearLogCache = function() {
    i._LogCache = "", i._LogLimitOutputs = {}, i.errorsCount = 0;
  }, Object.defineProperty(i, "LogLevels", {
    set: function(e) {
      (e & i.MessageLogLevel) === i.MessageLogLevel ? i.Log = i._LogEnabled : i.Log = i._LogDisabled, (e & i.WarningLogLevel) === i.WarningLogLevel ? i.Warn = i._WarnEnabled : i.Warn = i._WarnDisabled, (e & i.ErrorLogLevel) === i.ErrorLogLevel ? i.Error = i._ErrorEnabled : i.Error = i._ErrorDisabled;
    },
    enumerable: !1,
    configurable: !0
  }), i.NoneLogLevel = 0, i.MessageLogLevel = 1, i.WarningLogLevel = 2, i.ErrorLogLevel = 4, i.AllLogLevel = 7, i.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.", i._LogCache = "", i._LogLimitOutputs = {}, i.errorsCount = 0, i.Log = i._LogEnabled, i.Warn = i._WarnEnabled, i.Error = i._ErrorEnabled, i;
}(), Qt = function() {
  function i() {
    this.children = [];
  }
  return i.prototype.isValid = function(e) {
    return !0;
  }, i.prototype.process = function(e, t) {
    var r = "";
    if (this.line) {
      var n = this.line, a = t.processor;
      if (a) {
        if (a.lineProcessor && (n = a.lineProcessor(n, t.isFragment, t.processingContext)), a.attributeProcessor && this.line.startsWith("attribute"))
          n = a.attributeProcessor(this.line, e, t.processingContext);
        else if (a.varyingProcessor && this.line.startsWith("varying"))
          n = a.varyingProcessor(this.line, t.isFragment, e, t.processingContext);
        else if (a.uniformProcessor && a.uniformRegexp && a.uniformRegexp.test(this.line))
          t.lookForClosingBracketForUniformBuffer || (n = a.uniformProcessor(this.line, t.isFragment, e, t.processingContext));
        else if (a.uniformBufferProcessor && a.uniformBufferRegexp && a.uniformBufferRegexp.test(this.line))
          t.lookForClosingBracketForUniformBuffer || (n = a.uniformBufferProcessor(this.line, t.isFragment, t.processingContext), t.lookForClosingBracketForUniformBuffer = !0);
        else if (a.textureProcessor && a.textureRegexp && a.textureRegexp.test(this.line))
          n = a.textureProcessor(this.line, t.isFragment, e, t.processingContext);
        else if ((a.uniformProcessor || a.uniformBufferProcessor) && this.line.startsWith("uniform") && !t.lookForClosingBracketForUniformBuffer) {
          var s = /uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/;
          s.test(this.line) ? a.uniformProcessor && (n = a.uniformProcessor(this.line, t.isFragment, e, t.processingContext)) : a.uniformBufferProcessor && (n = a.uniformBufferProcessor(this.line, t.isFragment, t.processingContext), t.lookForClosingBracketForUniformBuffer = !0);
        }
        t.lookForClosingBracketForUniformBuffer && this.line.indexOf("}") !== -1 && (t.lookForClosingBracketForUniformBuffer = !1, a.endOfUniformBufferProcessor && (n = a.endOfUniformBufferProcessor(this.line, t.isFragment, t.processingContext)));
      }
      r += n + `\r
`;
    }
    return this.children.forEach(function(o) {
      r += o.process(e, t);
    }), this.additionalDefineKey && (e[this.additionalDefineKey] = this.additionalDefineValue || "true"), r;
  }, i;
}(), Pn = function() {
  function i() {
  }
  return Object.defineProperty(i.prototype, "currentLine", {
    get: function() {
      return this._lines[this.lineIndex];
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "canRead", {
    get: function() {
      return this.lineIndex < this._lines.length - 1;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "lines", {
    set: function(e) {
      this._lines = [];
      for (var t = 0, r = e; t < r.length; t++) {
        var n = r[t];
        if (n[0] === "#") {
          this._lines.push(n);
          continue;
        }
        if (n.trim().startsWith("//")) {
          this._lines.push(n);
          continue;
        }
        for (var a = n.split(";"), s = 0; s < a.length; s++) {
          var o = a[s];
          o = o.trim(), o && this._lines.push(o + (s !== a.length - 1 ? ";" : ""));
        }
      }
    },
    enumerable: !1,
    configurable: !0
  }), i;
}(), zr = function(i) {
  K(e, i);
  function e() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return e.prototype.process = function(t, r) {
    for (var n = 0; n < this.children.length; n++) {
      var a = this.children[n];
      if (a.isValid(t))
        return a.process(t, r);
    }
    return "";
  }, e;
}(Qt), Cn = function(i) {
  K(e, i);
  function e() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return e.prototype.isValid = function(t) {
    return this.testExpression.isTrue(t);
  }, e;
}(Qt), ar = function() {
  function i() {
  }
  return i.prototype.isTrue = function(e) {
    return !0;
  }, i.postfixToInfix = function(e) {
    for (var t = [], r = 0, n = e; r < n.length; r++) {
      var a = n[r];
      if (i._OperatorPriority[a] === void 0)
        t.push(a);
      else {
        var s = t[t.length - 1], o = t[t.length - 2];
        t.length -= 2, t.push("(".concat(o).concat(a).concat(s, ")"));
      }
    }
    return t[t.length - 1];
  }, i.infixToPostfix = function(e) {
    for (var t = [], r = -1, n = function() {
      f = f.trim(), f !== "" && (t.push(f), f = "");
    }, a = function(c) {
      r < i._Stack.length - 1 && (i._Stack[++r] = c);
    }, s = function() {
      return i._Stack[r];
    }, o = function() {
      return r === -1 ? "!!INVALID EXPRESSION!!" : i._Stack[r--];
    }, u = 0, f = ""; u < e.length; ) {
      var l = e.charAt(u), h = u < e.length - 1 ? e.substr(u, 2) : "";
      if (l === "(")
        f = "", a(l);
      else if (l === ")") {
        for (n(); r !== -1 && s() !== "("; )
          t.push(o());
        o();
      } else if (i._OperatorPriority[h] > 1) {
        for (n(); r !== -1 && i._OperatorPriority[s()] >= i._OperatorPriority[h]; )
          t.push(o());
        a(h), u++;
      } else
        f += l;
      u++;
    }
    for (n(); r !== -1; )
      s() === "(" ? o() : t.push(o());
    return t;
  }, i._OperatorPriority = {
    ")": 0,
    "(": 1,
    "||": 2,
    "&&": 3
  }, i._Stack = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], i;
}(), hr = function(i) {
  K(e, i);
  function e(t, r) {
    r === void 0 && (r = !1);
    var n = i.call(this) || this;
    return n.define = t, n.not = r, n;
  }
  return e.prototype.isTrue = function(t) {
    var r = t[this.define] !== void 0;
    return this.not && (r = !r), r;
  }, e;
}(ar), xn = function(i) {
  K(e, i);
  function e() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return e.prototype.isTrue = function(t) {
    return this.leftOperand.isTrue(t) || this.rightOperand.isTrue(t);
  }, e;
}(ar), Dn = function(i) {
  K(e, i);
  function e() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return e.prototype.isTrue = function(t) {
    return this.leftOperand.isTrue(t) && this.rightOperand.isTrue(t);
  }, e;
}(ar), In = function(i) {
  K(e, i);
  function e(t, r, n) {
    var a = i.call(this) || this;
    return a.define = t, a.operand = r, a.testValue = n, a;
  }
  return e.prototype.isTrue = function(t) {
    var r = t[this.define];
    r === void 0 && (r = this.define);
    var n = !1, a = parseInt(r), s = parseInt(this.testValue);
    switch (this.operand) {
      case ">":
        n = a > s;
        break;
      case "<":
        n = a < s;
        break;
      case "<=":
        n = a <= s;
        break;
      case ">=":
        n = a >= s;
        break;
      case "==":
        n = a === s;
        break;
    }
    return n;
  }, e;
}(ar), Ae;
(function(i) {
  i[i.GLSL = 0] = "GLSL", i[i.WGSL = 1] = "WGSL";
})(Ae || (Ae = {}));
var On = /defined\s*?\((.+?)\)/g, Gr = /defined\s*?\[(.+?)\]/g, Ei = /#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g, Zt = function() {
  function i() {
  }
  return i.Initialize = function(e) {
    e.processor && e.processor.initializeShaders && e.processor.initializeShaders(e.processingContext);
  }, i.Process = function(e, t, r, n) {
    var a = this, s;
    !((s = t.processor) === null || s === void 0) && s.preProcessShaderCode && (e = t.processor.preProcessShaderCode(e, t.isFragment)), this._ProcessIncludes(e, t, function(o) {
      t.processCodeAfterIncludes && (o = t.processCodeAfterIncludes(t.isFragment ? "fragment" : "vertex", o));
      var u = a._ProcessShaderConversion(o, t, n);
      r(u);
    });
  }, i.PreProcess = function(e, t, r, n) {
    var a = this, s;
    !((s = t.processor) === null || s === void 0) && s.preProcessShaderCode && (e = t.processor.preProcessShaderCode(e, t.isFragment)), this._ProcessIncludes(e, t, function(o) {
      t.processCodeAfterIncludes && (o = t.processCodeAfterIncludes(t.isFragment ? "fragment" : "vertex", o));
      var u = a._ApplyPreProcessing(o, t, n);
      r(u);
    });
  }, i.Finalize = function(e, t, r) {
    return !r.processor || !r.processor.finalizeShaders ? { vertexCode: e, fragmentCode: t } : r.processor.finalizeShaders(e, t, r.processingContext);
  }, i._ProcessPrecision = function(e, t) {
    var r;
    if (!((r = t.processor) === null || r === void 0) && r.noPrecision)
      return e;
    var n = t.shouldUseHighPrecisionShader;
    return e.indexOf("precision highp float") === -1 ? n ? e = `precision highp float;
` + e : e = `precision mediump float;
` + e : n || (e = e.replace("precision highp float", "precision mediump float")), e;
  }, i._ExtractOperation = function(e) {
    var t = /defined\((.+)\)/, r = t.exec(e);
    if (r && r.length)
      return new hr(r[1].trim(), e[0] === "!");
    for (var n = ["==", ">=", "<=", "<", ">"], a = "", s = 0, o = 0, u = n; o < u.length && (a = u[o], s = e.indexOf(a), !(s > -1)); o++)
      ;
    if (s === -1)
      return new hr(e);
    var f = e.substring(0, s).trim(), l = e.substring(s + a.length).trim();
    return new In(f, a, l);
  }, i._BuildSubExpression = function(e) {
    e = e.replace(On, "defined[$1]");
    for (var t = ar.infixToPostfix(e), r = [], n = 0, a = t; n < a.length; n++) {
      var s = a[n];
      if (s !== "||" && s !== "&&")
        r.push(s);
      else if (r.length >= 2) {
        var o = r[r.length - 1], u = r[r.length - 2];
        r.length -= 2;
        var f = s == "&&" ? new Dn() : new xn();
        typeof o == "string" && (o = o.replace(Gr, "defined($1)")), typeof u == "string" && (u = u.replace(Gr, "defined($1)")), f.leftOperand = typeof u == "string" ? this._ExtractOperation(u) : u, f.rightOperand = typeof o == "string" ? this._ExtractOperation(o) : o, r.push(f);
      }
    }
    var l = r[r.length - 1];
    return typeof l == "string" && (l = l.replace(Gr, "defined($1)")), typeof l == "string" ? this._ExtractOperation(l) : l;
  }, i._BuildExpression = function(e, t) {
    var r = new Cn(), n = e.substring(0, t), a = e.substring(t);
    return a = a.substring(0, (a.indexOf("//") + 1 || a.length + 1) - 1).trim(), n === "#ifdef" ? r.testExpression = new hr(a) : n === "#ifndef" ? r.testExpression = new hr(a, !0) : r.testExpression = this._BuildSubExpression(a), r;
  }, i._MoveCursorWithinIf = function(e, t, r) {
    for (var n = e.currentLine; this._MoveCursor(e, r); ) {
      n = e.currentLine;
      var a = n.substring(0, 5).toLowerCase();
      if (a === "#else") {
        var s = new Qt();
        t.children.push(s), this._MoveCursor(e, s);
        return;
      } else if (a === "#elif") {
        var o = this._BuildExpression(n, 5);
        t.children.push(o), r = o;
      }
    }
  }, i._MoveCursor = function(e, t) {
    for (; e.canRead; ) {
      e.lineIndex++;
      var r = e.currentLine, n = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/, a = n.exec(r);
      if (a && a.length) {
        var s = a[0];
        switch (s) {
          case "#ifdef": {
            var o = new zr();
            t.children.push(o);
            var u = this._BuildExpression(r, 6);
            o.children.push(u), this._MoveCursorWithinIf(e, o, u);
            break;
          }
          case "#else":
          case "#elif":
            return !0;
          case "#endif":
            return !1;
          case "#ifndef": {
            var o = new zr();
            t.children.push(o);
            var u = this._BuildExpression(r, 7);
            o.children.push(u), this._MoveCursorWithinIf(e, o, u);
            break;
          }
          case "#if": {
            var o = new zr(), u = this._BuildExpression(r, 3);
            t.children.push(o), o.children.push(u), this._MoveCursorWithinIf(e, o, u);
            break;
          }
        }
      } else {
        var f = new Qt();
        if (f.line = r, t.children.push(f), r[0] === "#" && r[1] === "d") {
          var l = r.replace(";", "").split(" ");
          f.additionalDefineKey = l[1], l.length === 3 && (f.additionalDefineValue = l[2]);
        }
      }
    }
    return !1;
  }, i._EvaluatePreProcessors = function(e, t, r) {
    var n = new Qt(), a = new Pn();
    return a.lineIndex = -1, a.lines = e.split(`
`), this._MoveCursor(a, n), n.process(t, r);
  }, i._PreparePreProcessors = function(e, t) {
    for (var r, n = e.defines, a = {}, s = 0, o = n; s < o.length; s++) {
      var u = o[s], f = u.replace("#define", "").replace(";", "").trim(), l = f.split(" ");
      a[l[0]] = l.length > 1 ? l[1] : "";
    }
    return ((r = e.processor) === null || r === void 0 ? void 0 : r.shaderLanguage) === Ae.GLSL && (a.GL_ES = "true"), a.__VERSION__ = e.version, a[e.platformName] = "true", t._getGlobalDefines(a), a;
  }, i._ProcessShaderConversion = function(e, t, r) {
    var n = this._ProcessPrecision(e, t);
    if (!t.processor)
      return n;
    if (t.processor.shaderLanguage === Ae.GLSL && n.indexOf("#version 3") !== -1)
      return n.replace("#version 300 es", "");
    var a = t.defines, s = this._PreparePreProcessors(t, r);
    return t.processor.preProcessor && (n = t.processor.preProcessor(n, a, t.isFragment, t.processingContext)), n = this._EvaluatePreProcessors(n, s, t), t.processor.postProcessor && (n = t.processor.postProcessor(n, a, t.isFragment, t.processingContext, r)), r._features.needShaderCodeInlining && (n = r.inlineShaderCode(n)), n;
  }, i._ApplyPreProcessing = function(e, t, r) {
    var n, a, s = e, o = t.defines, u = this._PreparePreProcessors(t, r);
    return !((n = t.processor) === null || n === void 0) && n.preProcessor && (s = t.processor.preProcessor(s, o, t.isFragment, t.processingContext)), s = this._EvaluatePreProcessors(s, u, t), !((a = t.processor) === null || a === void 0) && a.postProcessor && (s = t.processor.postProcessor(s, o, t.isFragment, t.processingContext, r)), r._features.needShaderCodeInlining && (s = r.inlineShaderCode(s)), s;
  }, i._ProcessIncludes = function(e, t, r) {
    for (var n = this, a = Ei.exec(e), s = new String(e), o = !1, u = function() {
      var l = a[1];
      if (l.indexOf("__decl__") !== -1 && (l = l.replace(/__decl__/, ""), t.supportsUniformBuffers && (l = l.replace(/Vertex/, "Ubo"), l = l.replace(/Fragment/, "Ubo")), l = l + "Declaration"), t.includesShadersStore[l]) {
        var h = t.includesShadersStore[l];
        if (a[2])
          for (var c = a[3].split(","), d = 0; d < c.length; d += 2) {
            var p = new RegExp(c[d], "g"), g = c[d + 1];
            h = h.replace(p, g);
          }
        if (a[4]) {
          var _ = a[5];
          if (_.indexOf("..") !== -1) {
            var v = _.split(".."), y = parseInt(v[0]), E = parseInt(v[1]), R = h.slice(0);
            h = "", isNaN(E) && (E = t.indexParameters[v[1]]);
            for (var M = y; M < E; M++)
              t.supportsUniformBuffers || (R = R.replace(/light\{X\}.(\w*)/g, function(A, S) {
                return S + "{X}";
              })), h += R.replace(/\{X\}/g, M.toString()) + `
`;
          } else
            t.supportsUniformBuffers || (h = h.replace(/light\{X\}.(\w*)/g, function(A, S) {
              return S + "{X}";
            })), h = h.replace(/\{X\}/g, _);
        }
        s = s.replace(a[0], h), o = o || h.indexOf("#include<") >= 0 || h.indexOf("#include <") >= 0;
      } else {
        var C = t.shadersRepository + "ShadersInclude/" + l + ".fx";
        return i._FileToolsLoadFile(C, function(A) {
          t.includesShadersStore[l] = A, n._ProcessIncludes(s, t, r);
        }), { value: void 0 };
      }
      a = Ei.exec(e);
    }; a != null; ) {
      var f = u();
      if (typeof f == "object")
        return f.value;
    }
    o ? this._ProcessIncludes(s.toString(), t, r) : r(s);
  }, i._FileToolsLoadFile = function(e, t, r, n, a, s) {
    throw G("FileTools");
  }, i;
}(), L = function() {
  function i() {
  }
  return i.GetShadersRepository = function(e) {
    return e === void 0 && (e = Ae.GLSL), e === Ae.GLSL ? i.ShadersRepository : i.ShadersRepositoryWGSL;
  }, i.GetShadersStore = function(e) {
    return e === void 0 && (e = Ae.GLSL), e === Ae.GLSL ? i.ShadersStore : i.ShadersStoreWGSL;
  }, i.GetIncludesShadersStore = function(e) {
    return e === void 0 && (e = Ae.GLSL), e === Ae.GLSL ? i.IncludesShadersStore : i.IncludesShadersStoreWGSL;
  }, i.ShadersRepository = "src/Shaders/", i.ShadersStore = {}, i.IncludesShadersStore = {}, i.ShadersRepositoryWGSL = "src/ShadersWGSL/", i.ShadersStoreWGSL = {}, i.IncludesShadersStoreWGSL = {}, i;
}(), ze = function() {
  function i(e, t, r, n, a, s, o, u, f, l, h, c) {
    n === void 0 && (n = null), s === void 0 && (s = null), o === void 0 && (o = null), u === void 0 && (u = null), f === void 0 && (f = null), h === void 0 && (h = ""), c === void 0 && (c = Ae.GLSL);
    var d = this, p, g, _;
    this.name = null, this.defines = "", this.onCompiled = null, this.onError = null, this.onBind = null, this.uniqueId = 0, this.onCompileObservable = new O(), this.onErrorObservable = new O(), this._onBindObservable = null, this._wasPreviouslyReady = !1, this._isDisposed = !1, this._bonesComputationForcedToCPU = !1, this._uniformBuffersNames = {}, this._multiTarget = !1, this._samplers = {}, this._isReady = !1, this._compilationError = "", this._allFallbacksProcessed = !1, this._uniforms = {}, this._key = "", this._fallbacks = null, this._vertexSourceCodeOverride = "", this._fragmentSourceCodeOverride = "", this._transformFeedbackVaryings = null, this._pipelineContext = null, this._vertexSourceCode = "", this._fragmentSourceCode = "", this._rawVertexSourceCode = "", this._rawFragmentSourceCode = "", this.name = e, this._key = h;
    var v = void 0, y = null;
    if (t.attributes) {
      var E = t;
      if (this._engine = r, this._attributesNames = E.attributes, this._uniformsNames = E.uniformsNames.concat(E.samplers), this._samplerList = E.samplers.slice(), this.defines = E.defines, this.onError = E.onError, this.onCompiled = E.onCompiled, this._fallbacks = E.fallbacks, this._indexParameters = E.indexParameters, this._transformFeedbackVaryings = E.transformFeedbackVaryings || null, this._multiTarget = !!E.multiTarget, this._shaderLanguage = (p = E.shaderLanguage) !== null && p !== void 0 ? p : Ae.GLSL, E.uniformBuffersNames) {
        this._uniformBuffersNamesList = E.uniformBuffersNames.slice();
        for (var R = 0; R < E.uniformBuffersNames.length; R++)
          this._uniformBuffersNames[E.uniformBuffersNames[R]] = R;
      }
      y = (g = E.processFinalCode) !== null && g !== void 0 ? g : null, v = (_ = E.processCodeAfterIncludes) !== null && _ !== void 0 ? _ : void 0;
    } else
      this._engine = a, this.defines = s == null ? "" : s, this._uniformsNames = r.concat(n), this._samplerList = n ? n.slice() : [], this._attributesNames = t, this._uniformBuffersNamesList = [], this._shaderLanguage = c, this.onError = f, this.onCompiled = u, this._indexParameters = l, this._fallbacks = o;
    this._attributeLocationByName = {}, this.uniqueId = i._UniqueIdSeed++;
    var M, C, A = me() ? this._engine.getHostDocument() : null;
    e.vertexSource ? M = "source:" + e.vertexSource : e.vertexElement ? (M = A ? A.getElementById(e.vertexElement) : null, M || (M = e.vertexElement)) : M = e.vertex || e, e.fragmentSource ? C = "source:" + e.fragmentSource : e.fragmentElement ? (C = A ? A.getElementById(e.fragmentElement) : null, C || (C = e.fragmentElement)) : C = e.fragment || e, this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);
    var S = {
      defines: this.defines.split(`
`),
      indexParameters: this._indexParameters,
      isFragment: !1,
      shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
      processor: this._engine._getShaderProcessor(this._shaderLanguage),
      supportsUniformBuffers: this._engine.supportsUniformBuffers,
      shadersRepository: L.GetShadersRepository(this._shaderLanguage),
      includesShadersStore: L.GetIncludesShadersStore(this._shaderLanguage),
      version: (this._engine.version * 100).toString(),
      platformName: this._engine.shaderPlatformName,
      processingContext: this._processingContext,
      isNDCHalfZRange: this._engine.isNDCHalfZRange,
      useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
      processCodeAfterIncludes: v
    }, w = [void 0, void 0], F = function() {
      if (w[0] && w[1]) {
        S.isFragment = !0;
        var x = w[0], z = w[1];
        Zt.Process(z, S, function(W) {
          y && (W = y("fragment", W));
          var N = Zt.Finalize(x, W, S);
          d._useFinalCode(N.vertexCode, N.fragmentCode, e);
        }, d._engine);
      }
    };
    this._loadShader(M, "Vertex", "", function(x) {
      Zt.Initialize(S), Zt.Process(x, S, function(z) {
        d._rawVertexSourceCode = x, y && (z = y("vertex", z)), w[0] = z, F();
      }, d._engine);
    }), this._loadShader(C, "Fragment", "Pixel", function(x) {
      d._rawFragmentSourceCode = x, w[1] = x, F();
    });
  }
  return Object.defineProperty(i, "ShadersRepository", {
    get: function() {
      return L.ShadersRepository;
    },
    set: function(e) {
      L.ShadersRepository = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "onBindObservable", {
    get: function() {
      return this._onBindObservable || (this._onBindObservable = new O()), this._onBindObservable;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._useFinalCode = function(e, t, r) {
    if (r) {
      var n = r.vertexElement || r.vertex || r.spectorName || r, a = r.fragmentElement || r.fragment || r.spectorName || r;
      this._vertexSourceCode = (this._shaderLanguage === Ae.WGSL ? "//" : "") + "#define SHADER_NAME vertex:" + n + `
` + e, this._fragmentSourceCode = (this._shaderLanguage === Ae.WGSL ? "//" : "") + "#define SHADER_NAME fragment:" + a + `
` + t;
    } else
      this._vertexSourceCode = e, this._fragmentSourceCode = t;
    this._prepareEffect();
  }, Object.defineProperty(i.prototype, "key", {
    get: function() {
      return this._key;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.isReady = function() {
    try {
      return this._isReadyInternal();
    } catch {
      return !1;
    }
  }, i.prototype._isReadyInternal = function() {
    return this._isReady ? !0 : this._pipelineContext ? this._pipelineContext.isReady : !1;
  }, i.prototype.getEngine = function() {
    return this._engine;
  }, i.prototype.getPipelineContext = function() {
    return this._pipelineContext;
  }, i.prototype.getAttributesNames = function() {
    return this._attributesNames;
  }, i.prototype.getAttributeLocation = function(e) {
    return this._attributes[e];
  }, i.prototype.getAttributeLocationByName = function(e) {
    return this._attributeLocationByName[e];
  }, i.prototype.getAttributesCount = function() {
    return this._attributes.length;
  }, i.prototype.getUniformIndex = function(e) {
    return this._uniformsNames.indexOf(e);
  }, i.prototype.getUniform = function(e) {
    return this._uniforms[e];
  }, i.prototype.getSamplers = function() {
    return this._samplerList;
  }, i.prototype.getUniformNames = function() {
    return this._uniformsNames;
  }, i.prototype.getUniformBuffersNames = function() {
    return this._uniformBuffersNamesList;
  }, i.prototype.getIndexParameters = function() {
    return this._indexParameters;
  }, i.prototype.getCompilationError = function() {
    return this._compilationError;
  }, i.prototype.allFallbacksProcessed = function() {
    return this._allFallbacksProcessed;
  }, i.prototype.executeWhenCompiled = function(e) {
    var t = this;
    if (this.isReady()) {
      e(this);
      return;
    }
    this.onCompileObservable.add(function(r) {
      e(r);
    }), (!this._pipelineContext || this._pipelineContext.isAsync) && setTimeout(function() {
      t._checkIsReady(null);
    }, 16);
  }, i.prototype._checkIsReady = function(e) {
    var t = this;
    try {
      if (this._isReadyInternal())
        return;
    } catch (r) {
      this._processCompilationErrors(r, e);
      return;
    }
    this._isDisposed || setTimeout(function() {
      t._checkIsReady(e);
    }, 16);
  }, i.prototype._loadShader = function(e, t, r, n) {
    if (typeof HTMLElement < "u" && e instanceof HTMLElement) {
      var a = li(e);
      n(a);
      return;
    }
    if (e.substr(0, 7) === "source:") {
      n(e.substr(7));
      return;
    }
    if (e.substr(0, 7) === "base64:") {
      var s = window.atob(e.substr(7));
      n(s);
      return;
    }
    var o = L.GetShadersStore(this._shaderLanguage);
    if (o[e + t + "Shader"]) {
      n(o[e + t + "Shader"]);
      return;
    }
    if (r && o[e + r + "Shader"]) {
      n(o[e + r + "Shader"]);
      return;
    }
    var u;
    e[0] === "." || e[0] === "/" || e.indexOf("http") > -1 ? u = e : u = L.GetShadersRepository(this._shaderLanguage) + e, this._engine._loadFile(u + "." + t.toLowerCase() + ".fx", n);
  }, Object.defineProperty(i.prototype, "vertexSourceCode", {
    get: function() {
      var e, t;
      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : (t = (e = this._pipelineContext) === null || e === void 0 ? void 0 : e._getVertexShaderCode()) !== null && t !== void 0 ? t : this._vertexSourceCode;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "fragmentSourceCode", {
    get: function() {
      var e, t;
      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : (t = (e = this._pipelineContext) === null || e === void 0 ? void 0 : e._getFragmentShaderCode()) !== null && t !== void 0 ? t : this._fragmentSourceCode;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "rawVertexSourceCode", {
    get: function() {
      return this._rawVertexSourceCode;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "rawFragmentSourceCode", {
    get: function() {
      return this._rawFragmentSourceCode;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._rebuildProgram = function(e, t, r, n) {
    var a = this;
    this._isReady = !1, this._vertexSourceCodeOverride = e, this._fragmentSourceCodeOverride = t, this.onError = function(s, o) {
      n && n(o);
    }, this.onCompiled = function() {
      var s = a.getEngine().scenes;
      if (s)
        for (var o = 0; o < s.length; o++)
          s[o].markAllMaterialsAsDirty(63);
      a._pipelineContext._handlesSpectorRebuildCallback(r);
    }, this._fallbacks = null, this._prepareEffect();
  }, i.prototype._prepareEffect = function() {
    var e = this, t = this._attributesNames, r = this.defines, n = this._pipelineContext;
    this._isReady = !1;
    try {
      var a = this._engine;
      this._pipelineContext = a.createPipelineContext(this._processingContext), this._pipelineContext._name = this._key;
      var s = this._rebuildProgram.bind(this);
      this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? a._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, !0, this._rawVertexSourceCode, this._rawFragmentSourceCode, s, null, this._transformFeedbackVaryings, this._key) : a._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, !1, this._rawVertexSourceCode, this._rawFragmentSourceCode, s, r, this._transformFeedbackVaryings, this._key), a._executeWhenRenderingStateIsCompiled(this._pipelineContext, function() {
        if (e._attributes = [], e._pipelineContext._fillEffectInformation(e, e._uniformBuffersNames, e._uniformsNames, e._uniforms, e._samplerList, e._samplers, t, e._attributes), t)
          for (var o = 0; o < t.length; o++) {
            var u = t[o];
            e._attributeLocationByName[u] = e._attributes[o];
          }
        a.bindSamplers(e), e._compilationError = "", e._isReady = !0, e.onCompiled && e.onCompiled(e), e.onCompileObservable.notifyObservers(e), e.onCompileObservable.clear(), e._fallbacks && e._fallbacks.unBindMesh(), n && e.getEngine()._deletePipelineContext(n);
      }), this._pipelineContext.isAsync && this._checkIsReady(n);
    } catch (o) {
      this._processCompilationErrors(o, n);
    }
  }, i.prototype._getShaderCodeAndErrorLine = function(e, t, r) {
    var n = r ? /FRAGMENT SHADER ERROR: 0:(\d+?):/ : /VERTEX SHADER ERROR: 0:(\d+?):/, a = null;
    if (t && e) {
      var s = t.match(n);
      if (s && s.length === 2) {
        var o = parseInt(s[1]), u = e.split(`
`, -1);
        u.length >= o && (a = "Offending line [".concat(o, "] in ").concat(r ? "fragment" : "vertex", " code: ").concat(u[o - 1]));
      }
    }
    return [e, a];
  }, i.prototype._processCompilationErrors = function(e, t) {
    var r, n, a, s, o;
    t === void 0 && (t = null), this._compilationError = e.message;
    var u = this._attributesNames, f = this._fallbacks;
    if (k.Error("Unable to compile effect:"), k.Error("Uniforms: " + this._uniformsNames.map(function(d) {
      return " " + d;
    })), k.Error("Attributes: " + u.map(function(d) {
      return " " + d;
    })), k.Error(`Defines:\r
` + this.defines), i.LogShaderCodeOnCompilationError) {
      var l = null, h = null, c = null;
      !((a = this._pipelineContext) === null || a === void 0) && a._getVertexShaderCode() && (r = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, !1), c = r[0], l = r[1], c && (k.Error("Vertex code:"), k.Error(c))), !((s = this._pipelineContext) === null || s === void 0) && s._getFragmentShaderCode() && (n = this._getShaderCodeAndErrorLine((o = this._pipelineContext) === null || o === void 0 ? void 0 : o._getFragmentShaderCode(), this._compilationError, !0), c = n[0], h = n[1], c && (k.Error("Fragment code:"), k.Error(c))), l && k.Error(l), h && k.Error(h);
    }
    k.Error("Error: " + this._compilationError), t && (this._pipelineContext = t, this._isReady = !0, this.onError && this.onError(this, this._compilationError), this.onErrorObservable.notifyObservers(this)), f ? (this._pipelineContext = null, f.hasMoreFallbacks ? (this._allFallbacksProcessed = !1, k.Error("Trying next fallback."), this.defines = f.reduce(this.defines, this), this._prepareEffect()) : (this._allFallbacksProcessed = !0, this.onError && this.onError(this, this._compilationError), this.onErrorObservable.notifyObservers(this), this.onErrorObservable.clear(), this._fallbacks && this._fallbacks.unBindMesh())) : this._allFallbacksProcessed = !0;
  }, Object.defineProperty(i.prototype, "isSupported", {
    get: function() {
      return this._compilationError === "";
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._bindTexture = function(e, t) {
    this._engine._bindTexture(this._samplers[e], t, e);
  }, i.prototype.setTexture = function(e, t) {
    this._engine.setTexture(this._samplers[e], this._uniforms[e], t, e);
  }, i.prototype.setDepthStencilTexture = function(e, t) {
    this._engine.setDepthStencilTexture(this._samplers[e], this._uniforms[e], t, e);
  }, i.prototype.setTextureArray = function(e, t) {
    var r = e + "Ex";
    if (this._samplerList.indexOf(r + "0") === -1) {
      for (var n = this._samplerList.indexOf(e), a = 1; a < t.length; a++) {
        var s = r + (a - 1).toString();
        this._samplerList.splice(n + a, 0, s);
      }
      for (var o = 0, u = 0, f = this._samplerList; u < f.length; u++) {
        var l = f[u];
        this._samplers[l] = o, o += 1;
      }
    }
    this._engine.setTextureArray(this._samplers[e], this._uniforms[e], t, e);
  }, i.prototype.setTextureFromPostProcess = function(e, t) {
    this._engine.setTextureFromPostProcess(this._samplers[e], t, e);
  }, i.prototype.setTextureFromPostProcessOutput = function(e, t) {
    this._engine.setTextureFromPostProcessOutput(this._samplers[e], t, e);
  }, i.prototype.bindUniformBuffer = function(e, t) {
    var r = this._uniformBuffersNames[t];
    r === void 0 || i._BaseCache[r] === e && this._engine._features.useUBOBindingCache || (i._BaseCache[r] = e, this._engine.bindUniformBufferBase(e, r, t));
  }, i.prototype.bindUniformBlock = function(e, t) {
    this._engine.bindUniformBlock(this._pipelineContext, e, t);
  }, i.prototype.setInt = function(e, t) {
    return this._pipelineContext.setInt(e, t), this;
  }, i.prototype.setInt2 = function(e, t, r) {
    return this._pipelineContext.setInt2(e, t, r), this;
  }, i.prototype.setInt3 = function(e, t, r, n) {
    return this._pipelineContext.setInt3(e, t, r, n), this;
  }, i.prototype.setInt4 = function(e, t, r, n, a) {
    return this._pipelineContext.setInt4(e, t, r, n, a), this;
  }, i.prototype.setIntArray = function(e, t) {
    return this._pipelineContext.setIntArray(e, t), this;
  }, i.prototype.setIntArray2 = function(e, t) {
    return this._pipelineContext.setIntArray2(e, t), this;
  }, i.prototype.setIntArray3 = function(e, t) {
    return this._pipelineContext.setIntArray3(e, t), this;
  }, i.prototype.setIntArray4 = function(e, t) {
    return this._pipelineContext.setIntArray4(e, t), this;
  }, i.prototype.setFloatArray = function(e, t) {
    return this._pipelineContext.setArray(e, t), this;
  }, i.prototype.setFloatArray2 = function(e, t) {
    return this._pipelineContext.setArray2(e, t), this;
  }, i.prototype.setFloatArray3 = function(e, t) {
    return this._pipelineContext.setArray3(e, t), this;
  }, i.prototype.setFloatArray4 = function(e, t) {
    return this._pipelineContext.setArray4(e, t), this;
  }, i.prototype.setArray = function(e, t) {
    return this._pipelineContext.setArray(e, t), this;
  }, i.prototype.setArray2 = function(e, t) {
    return this._pipelineContext.setArray2(e, t), this;
  }, i.prototype.setArray3 = function(e, t) {
    return this._pipelineContext.setArray3(e, t), this;
  }, i.prototype.setArray4 = function(e, t) {
    return this._pipelineContext.setArray4(e, t), this;
  }, i.prototype.setMatrices = function(e, t) {
    return this._pipelineContext.setMatrices(e, t), this;
  }, i.prototype.setMatrix = function(e, t) {
    return this._pipelineContext.setMatrix(e, t), this;
  }, i.prototype.setMatrix3x3 = function(e, t) {
    return this._pipelineContext.setMatrix3x3(e, t), this;
  }, i.prototype.setMatrix2x2 = function(e, t) {
    return this._pipelineContext.setMatrix2x2(e, t), this;
  }, i.prototype.setFloat = function(e, t) {
    return this._pipelineContext.setFloat(e, t), this;
  }, i.prototype.setBool = function(e, t) {
    return this._pipelineContext.setInt(e, t ? 1 : 0), this;
  }, i.prototype.setVector2 = function(e, t) {
    return this._pipelineContext.setVector2(e, t), this;
  }, i.prototype.setFloat2 = function(e, t, r) {
    return this._pipelineContext.setFloat2(e, t, r), this;
  }, i.prototype.setVector3 = function(e, t) {
    return this._pipelineContext.setVector3(e, t), this;
  }, i.prototype.setFloat3 = function(e, t, r, n) {
    return this._pipelineContext.setFloat3(e, t, r, n), this;
  }, i.prototype.setVector4 = function(e, t) {
    return this._pipelineContext.setVector4(e, t), this;
  }, i.prototype.setQuaternion = function(e, t) {
    return this._pipelineContext.setQuaternion(e, t), this;
  }, i.prototype.setFloat4 = function(e, t, r, n, a) {
    return this._pipelineContext.setFloat4(e, t, r, n, a), this;
  }, i.prototype.setColor3 = function(e, t) {
    return this._pipelineContext.setColor3(e, t), this;
  }, i.prototype.setColor4 = function(e, t, r) {
    return this._pipelineContext.setColor4(e, t, r), this;
  }, i.prototype.setDirectColor4 = function(e, t) {
    return this._pipelineContext.setDirectColor4(e, t), this;
  }, i.prototype.dispose = function() {
    this._pipelineContext && this._pipelineContext.dispose(), this._engine._releaseEffect(this), this._isDisposed = !0;
  }, i.RegisterShader = function(e, t, r, n) {
    n === void 0 && (n = Ae.GLSL), t && (L.GetShadersStore(n)["".concat(e, "PixelShader")] = t), r && (L.GetShadersStore(n)["".concat(e, "VertexShader")] = r);
  }, i.ResetCache = function() {
    i._BaseCache = {};
  }, i.LogShaderCodeOnCompilationError = !0, i._UniqueIdSeed = 0, i._BaseCache = {}, i.ShadersStore = L.ShadersStore, i.IncludesShadersStore = L.IncludesShadersStore, i;
}(), Fn = function() {
  function i(e) {
    e === void 0 && (e = !0), this._isDepthTestDirty = !1, this._isDepthMaskDirty = !1, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !1, this._isFrontFaceDirty = !1, e && this.reset();
  }
  return Object.defineProperty(i.prototype, "isDirty", {
    get: function() {
      return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "zOffset", {
    get: function() {
      return this._zOffset;
    },
    set: function(e) {
      this._zOffset !== e && (this._zOffset = e, this._isZOffsetDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "zOffsetUnits", {
    get: function() {
      return this._zOffsetUnits;
    },
    set: function(e) {
      this._zOffsetUnits !== e && (this._zOffsetUnits = e, this._isZOffsetDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "cullFace", {
    get: function() {
      return this._cullFace;
    },
    set: function(e) {
      this._cullFace !== e && (this._cullFace = e, this._isCullFaceDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "cull", {
    get: function() {
      return this._cull;
    },
    set: function(e) {
      this._cull !== e && (this._cull = e, this._isCullDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "depthFunc", {
    get: function() {
      return this._depthFunc;
    },
    set: function(e) {
      this._depthFunc !== e && (this._depthFunc = e, this._isDepthFuncDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "depthMask", {
    get: function() {
      return this._depthMask;
    },
    set: function(e) {
      this._depthMask !== e && (this._depthMask = e, this._isDepthMaskDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "depthTest", {
    get: function() {
      return this._depthTest;
    },
    set: function(e) {
      this._depthTest !== e && (this._depthTest = e, this._isDepthTestDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "frontFace", {
    get: function() {
      return this._frontFace;
    },
    set: function(e) {
      this._frontFace !== e && (this._frontFace = e, this._isFrontFaceDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.reset = function() {
    this._depthMask = !0, this._depthTest = !0, this._depthFunc = null, this._cullFace = null, this._cull = null, this._zOffset = 0, this._zOffsetUnits = 0, this._frontFace = null, this._isDepthTestDirty = !0, this._isDepthMaskDirty = !0, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !0, this._isFrontFaceDirty = !1;
  }, i.prototype.apply = function(e) {
    !this.isDirty || (this._isCullDirty && (this.cull ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), this._isCullDirty = !1), this._isCullFaceDirty && (e.cullFace(this.cullFace), this._isCullFaceDirty = !1), this._isDepthMaskDirty && (e.depthMask(this.depthMask), this._isDepthMaskDirty = !1), this._isDepthTestDirty && (this.depthTest ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this._isDepthTestDirty = !1), this._isDepthFuncDirty && (e.depthFunc(this.depthFunc), this._isDepthFuncDirty = !1), this._isZOffsetDirty && (this.zOffset || this.zOffsetUnits ? (e.enable(e.POLYGON_OFFSET_FILL), e.polygonOffset(this.zOffset, this.zOffsetUnits)) : e.disable(e.POLYGON_OFFSET_FILL), this._isZOffsetDirty = !1), this._isFrontFaceDirty && (e.frontFace(this.frontFace), this._isFrontFaceDirty = !1));
  }, i;
}(), wn = function() {
  function i() {
    this.reset();
  }
  return i.prototype.reset = function() {
    this.enabled = !1, this.mask = 255, this.func = i.ALWAYS, this.funcRef = 1, this.funcMask = 255, this.opStencilFail = i.KEEP, this.opDepthFail = i.KEEP, this.opStencilDepthPass = i.REPLACE;
  }, Object.defineProperty(i.prototype, "stencilFunc", {
    get: function() {
      return this.func;
    },
    set: function(e) {
      this.func = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "stencilFuncRef", {
    get: function() {
      return this.funcRef;
    },
    set: function(e) {
      this.funcRef = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "stencilFuncMask", {
    get: function() {
      return this.funcMask;
    },
    set: function(e) {
      this.funcMask = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "stencilOpStencilFail", {
    get: function() {
      return this.opStencilFail;
    },
    set: function(e) {
      this.opStencilFail = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "stencilOpDepthFail", {
    get: function() {
      return this.opDepthFail;
    },
    set: function(e) {
      this.opDepthFail = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "stencilOpStencilDepthPass", {
    get: function() {
      return this.opStencilDepthPass;
    },
    set: function(e) {
      this.opStencilDepthPass = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "stencilMask", {
    get: function() {
      return this.mask;
    },
    set: function(e) {
      this.mask = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "stencilTest", {
    get: function() {
      return this.enabled;
    },
    set: function(e) {
      this.enabled = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.ALWAYS = 519, i.KEEP = 7680, i.REPLACE = 7681, i;
}(), Ln = function() {
  function i() {
    this._blendFunctionParameters = new Array(4), this._blendEquationParameters = new Array(2), this._blendConstants = new Array(4), this._isBlendConstantsDirty = !1, this._alphaBlend = !1, this._isAlphaBlendDirty = !1, this._isBlendFunctionParametersDirty = !1, this._isBlendEquationParametersDirty = !1, this.reset();
  }
  return Object.defineProperty(i.prototype, "isDirty", {
    get: function() {
      return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "alphaBlend", {
    get: function() {
      return this._alphaBlend;
    },
    set: function(e) {
      this._alphaBlend !== e && (this._alphaBlend = e, this._isAlphaBlendDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.setAlphaBlendConstants = function(e, t, r, n) {
    this._blendConstants[0] === e && this._blendConstants[1] === t && this._blendConstants[2] === r && this._blendConstants[3] === n || (this._blendConstants[0] = e, this._blendConstants[1] = t, this._blendConstants[2] = r, this._blendConstants[3] = n, this._isBlendConstantsDirty = !0);
  }, i.prototype.setAlphaBlendFunctionParameters = function(e, t, r, n) {
    this._blendFunctionParameters[0] === e && this._blendFunctionParameters[1] === t && this._blendFunctionParameters[2] === r && this._blendFunctionParameters[3] === n || (this._blendFunctionParameters[0] = e, this._blendFunctionParameters[1] = t, this._blendFunctionParameters[2] = r, this._blendFunctionParameters[3] = n, this._isBlendFunctionParametersDirty = !0);
  }, i.prototype.setAlphaEquationParameters = function(e, t) {
    this._blendEquationParameters[0] === e && this._blendEquationParameters[1] === t || (this._blendEquationParameters[0] = e, this._blendEquationParameters[1] = t, this._isBlendEquationParametersDirty = !0);
  }, i.prototype.reset = function() {
    this._alphaBlend = !1, this._blendFunctionParameters[0] = null, this._blendFunctionParameters[1] = null, this._blendFunctionParameters[2] = null, this._blendFunctionParameters[3] = null, this._blendEquationParameters[0] = null, this._blendEquationParameters[1] = null, this._blendConstants[0] = null, this._blendConstants[1] = null, this._blendConstants[2] = null, this._blendConstants[3] = null, this._isAlphaBlendDirty = !0, this._isBlendFunctionParametersDirty = !1, this._isBlendEquationParametersDirty = !1, this._isBlendConstantsDirty = !1;
  }, i.prototype.apply = function(e) {
    !this.isDirty || (this._isAlphaBlendDirty && (this._alphaBlend ? e.enable(e.BLEND) : e.disable(e.BLEND), this._isAlphaBlendDirty = !1), this._isBlendFunctionParametersDirty && (e.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]), this._isBlendFunctionParametersDirty = !1), this._isBlendEquationParametersDirty && (e.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]), this._isBlendEquationParametersDirty = !1), this._isBlendConstantsDirty && (e.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]), this._isBlendConstantsDirty = !1));
  }, i;
}(), Nn = function() {
  function i() {
    this.shaderLanguage = Ae.GLSL;
  }
  return i.prototype.postProcessor = function(e, t, r, n, a) {
    if (!a.getCaps().drawBuffersExtension) {
      var s = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;
      e = e.replace(s, "");
    }
    return e;
  }, i;
}(), Bn = function() {
  function i() {
    this.shaderLanguage = Ae.GLSL;
  }
  return i.prototype.attributeProcessor = function(e) {
    return e.replace("attribute", "in");
  }, i.prototype.varyingProcessor = function(e, t) {
    return e.replace("varying", t ? "in" : "out");
  }, i.prototype.postProcessor = function(e, t, r) {
    var n = e.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1, a = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
    if (e = e.replace(a, ""), e = e.replace(/texture2D\s*\(/g, "texture("), r)
      e = e.replace(/texture2DLodEXT\s*\(/g, "textureLod("), e = e.replace(/textureCubeLodEXT\s*\(/g, "textureLod("), e = e.replace(/textureCube\s*\(/g, "texture("), e = e.replace(/gl_FragDepthEXT/g, "gl_FragDepth"), e = e.replace(/gl_FragColor/g, "glFragColor"), e = e.replace(/gl_FragData/g, "glFragData"), e = e.replace(/void\s+?main\s*\(/g, (n ? "" : `out vec4 glFragColor;
`) + "void main(");
    else {
      var s = t.indexOf("#define MULTIVIEW") !== -1;
      if (s)
        return `#extension GL_OVR_multiview2 : require
layout (num_views = 2) in;
` + e;
    }
    return e;
  }, i;
}(), Ji = function() {
  function i() {
    this.references = 0, this.capacity = 0, this.is32Bits = !1, this.uniqueId = i._Counter++;
  }
  return Object.defineProperty(i.prototype, "underlyingResource", {
    get: function() {
      return null;
    },
    enumerable: !1,
    configurable: !0
  }), i._Counter = 0, i;
}(), $t = function(i) {
  K(e, i);
  function e(t) {
    var r = i.call(this) || this;
    return r._buffer = t, r;
  }
  return Object.defineProperty(e.prototype, "underlyingResource", {
    get: function() {
      return this._buffer;
    },
    enumerable: !1,
    configurable: !0
  }), e;
}(Ji), Un = function() {
  function i() {
    this._valueCache = {}, this.vertexCompilationError = null, this.fragmentCompilationError = null, this.programLinkError = null, this.programValidationError = null;
  }
  return Object.defineProperty(i.prototype, "isAsync", {
    get: function() {
      return this.isParallelCompiled;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "isReady", {
    get: function() {
      return this.program ? this.isParallelCompiled ? this.engine._isRenderingStateCompiled(this) : !0 : !1;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._handlesSpectorRebuildCallback = function(e) {
    e && this.program && e(this.program);
  }, i.prototype._fillEffectInformation = function(e, t, r, n, a, s, o, u) {
    var f = this.engine;
    if (f.supportsUniformBuffers)
      for (var l in t)
        e.bindUniformBlock(l, t[l]);
    var h = this.engine.getUniforms(this, r);
    h.forEach(function(v, y) {
      n[r[y]] = v;
    }), this._uniforms = n;
    var c;
    for (c = 0; c < a.length; c++) {
      var d = e.getUniform(a[c]);
      d == null && (a.splice(c, 1), c--);
    }
    a.forEach(function(v, y) {
      s[v] = y;
    });
    for (var p = 0, g = f.getAttributes(this, o); p < g.length; p++) {
      var _ = g[p];
      u.push(_);
    }
  }, i.prototype.dispose = function() {
    this._uniforms = {};
  }, i.prototype._cacheMatrix = function(e, t) {
    var r = this._valueCache[e], n = t.updateFlag;
    return r !== void 0 && r === n ? !1 : (this._valueCache[e] = n, !0);
  }, i.prototype._cacheFloat2 = function(e, t, r) {
    var n = this._valueCache[e];
    if (!n || n.length !== 2)
      return n = [t, r], this._valueCache[e] = n, !0;
    var a = !1;
    return n[0] !== t && (n[0] = t, a = !0), n[1] !== r && (n[1] = r, a = !0), a;
  }, i.prototype._cacheFloat3 = function(e, t, r, n) {
    var a = this._valueCache[e];
    if (!a || a.length !== 3)
      return a = [t, r, n], this._valueCache[e] = a, !0;
    var s = !1;
    return a[0] !== t && (a[0] = t, s = !0), a[1] !== r && (a[1] = r, s = !0), a[2] !== n && (a[2] = n, s = !0), s;
  }, i.prototype._cacheFloat4 = function(e, t, r, n, a) {
    var s = this._valueCache[e];
    if (!s || s.length !== 4)
      return s = [t, r, n, a], this._valueCache[e] = s, !0;
    var o = !1;
    return s[0] !== t && (s[0] = t, o = !0), s[1] !== r && (s[1] = r, o = !0), s[2] !== n && (s[2] = n, o = !0), s[3] !== a && (s[3] = a, o = !0), o;
  }, i.prototype.setInt = function(e, t) {
    var r = this._valueCache[e];
    r !== void 0 && r === t || this.engine.setInt(this._uniforms[e], t) && (this._valueCache[e] = t);
  }, i.prototype.setInt2 = function(e, t, r) {
    this._cacheFloat2(e, t, r) && (this.engine.setInt2(this._uniforms[e], t, r) || (this._valueCache[e] = null));
  }, i.prototype.setInt3 = function(e, t, r, n) {
    this._cacheFloat3(e, t, r, n) && (this.engine.setInt3(this._uniforms[e], t, r, n) || (this._valueCache[e] = null));
  }, i.prototype.setInt4 = function(e, t, r, n, a) {
    this._cacheFloat4(e, t, r, n, a) && (this.engine.setInt4(this._uniforms[e], t, r, n, a) || (this._valueCache[e] = null));
  }, i.prototype.setIntArray = function(e, t) {
    this._valueCache[e] = null, this.engine.setIntArray(this._uniforms[e], t);
  }, i.prototype.setIntArray2 = function(e, t) {
    this._valueCache[e] = null, this.engine.setIntArray2(this._uniforms[e], t);
  }, i.prototype.setIntArray3 = function(e, t) {
    this._valueCache[e] = null, this.engine.setIntArray3(this._uniforms[e], t);
  }, i.prototype.setIntArray4 = function(e, t) {
    this._valueCache[e] = null, this.engine.setIntArray4(this._uniforms[e], t);
  }, i.prototype.setArray = function(e, t) {
    this._valueCache[e] = null, this.engine.setArray(this._uniforms[e], t);
  }, i.prototype.setArray2 = function(e, t) {
    this._valueCache[e] = null, this.engine.setArray2(this._uniforms[e], t);
  }, i.prototype.setArray3 = function(e, t) {
    this._valueCache[e] = null, this.engine.setArray3(this._uniforms[e], t);
  }, i.prototype.setArray4 = function(e, t) {
    this._valueCache[e] = null, this.engine.setArray4(this._uniforms[e], t);
  }, i.prototype.setMatrices = function(e, t) {
    !t || (this._valueCache[e] = null, this.engine.setMatrices(this._uniforms[e], t));
  }, i.prototype.setMatrix = function(e, t) {
    this._cacheMatrix(e, t) && (this.engine.setMatrices(this._uniforms[e], t.toArray()) || (this._valueCache[e] = null));
  }, i.prototype.setMatrix3x3 = function(e, t) {
    this._valueCache[e] = null, this.engine.setMatrix3x3(this._uniforms[e], t);
  }, i.prototype.setMatrix2x2 = function(e, t) {
    this._valueCache[e] = null, this.engine.setMatrix2x2(this._uniforms[e], t);
  }, i.prototype.setFloat = function(e, t) {
    var r = this._valueCache[e];
    r !== void 0 && r === t || this.engine.setFloat(this._uniforms[e], t) && (this._valueCache[e] = t);
  }, i.prototype.setVector2 = function(e, t) {
    this._cacheFloat2(e, t.x, t.y) && (this.engine.setFloat2(this._uniforms[e], t.x, t.y) || (this._valueCache[e] = null));
  }, i.prototype.setFloat2 = function(e, t, r) {
    this._cacheFloat2(e, t, r) && (this.engine.setFloat2(this._uniforms[e], t, r) || (this._valueCache[e] = null));
  }, i.prototype.setVector3 = function(e, t) {
    this._cacheFloat3(e, t.x, t.y, t.z) && (this.engine.setFloat3(this._uniforms[e], t.x, t.y, t.z) || (this._valueCache[e] = null));
  }, i.prototype.setFloat3 = function(e, t, r, n) {
    this._cacheFloat3(e, t, r, n) && (this.engine.setFloat3(this._uniforms[e], t, r, n) || (this._valueCache[e] = null));
  }, i.prototype.setVector4 = function(e, t) {
    this._cacheFloat4(e, t.x, t.y, t.z, t.w) && (this.engine.setFloat4(this._uniforms[e], t.x, t.y, t.z, t.w) || (this._valueCache[e] = null));
  }, i.prototype.setQuaternion = function(e, t) {
    this._cacheFloat4(e, t.x, t.y, t.z, t.w) && (this.engine.setFloat4(this._uniforms[e], t.x, t.y, t.z, t.w) || (this._valueCache[e] = null));
  }, i.prototype.setFloat4 = function(e, t, r, n, a) {
    this._cacheFloat4(e, t, r, n, a) && (this.engine.setFloat4(this._uniforms[e], t, r, n, a) || (this._valueCache[e] = null));
  }, i.prototype.setColor3 = function(e, t) {
    this._cacheFloat3(e, t.r, t.g, t.b) && (this.engine.setFloat3(this._uniforms[e], t.r, t.g, t.b) || (this._valueCache[e] = null));
  }, i.prototype.setColor4 = function(e, t, r) {
    this._cacheFloat4(e, t.r, t.g, t.b, r) && (this.engine.setFloat4(this._uniforms[e], t.r, t.g, t.b, r) || (this._valueCache[e] = null));
  }, i.prototype.setDirectColor4 = function(e, t) {
    this._cacheFloat4(e, t.r, t.g, t.b, t.a) && (this.engine.setFloat4(this._uniforms[e], t.r, t.g, t.b, t.a) || (this._valueCache[e] = null));
  }, i.prototype._getVertexShaderCode = function() {
    return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null;
  }, i.prototype._getFragmentShaderCode = function() {
    return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null;
  }, i;
}(), en = function() {
  function i(e, t) {
    if (e === void 0 && (e = null), this._MSAARenderBuffer = null, this._context = t, !e && (e = t.createTexture(), !e))
      throw new Error("Unable to create webGL texture");
    this.set(e);
  }
  return Object.defineProperty(i.prototype, "underlyingResource", {
    get: function() {
      return this._webGLTexture;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.setUsage = function() {
  }, i.prototype.set = function(e) {
    this._webGLTexture = e;
  }, i.prototype.reset = function() {
    this._webGLTexture = null, this._MSAARenderBuffer = null;
  }, i.prototype.release = function() {
    this._MSAARenderBuffer && (this._context.deleteRenderbuffer(this._MSAARenderBuffer), this._MSAARenderBuffer = null), this._webGLTexture && this._context.deleteTexture(this._webGLTexture), this.reset();
  }, i;
}(), sr = function() {
  function i(e, t) {
    t === void 0 && (t = !0), this.effect = null, this.defines = null, this.drawContext = e.createDrawContext(), t && (this.materialContext = e.createMaterialContext());
  }
  return i.IsWrapper = function(e) {
    return e.getPipelineContext === void 0;
  }, i.GetEffect = function(e) {
    return e.getPipelineContext === void 0 ? e.effect : e;
  }, i.prototype.setEffect = function(e, t, r) {
    var n;
    r === void 0 && (r = !0), this.effect = e, t !== void 0 && (this.defines = t), r && ((n = this.drawContext) === null || n === void 0 || n.reset());
  }, i.prototype.dispose = function() {
    var e;
    (e = this.drawContext) === null || e === void 0 || e.dispose();
  }, i;
}(), Vn = function() {
  function i(e) {
    e === void 0 && (e = !0), this._isStencilTestDirty = !1, this._isStencilMaskDirty = !1, this._isStencilFuncDirty = !1, this._isStencilOpDirty = !1, this.useStencilGlobalOnly = !1, e && this.reset();
  }
  return Object.defineProperty(i.prototype, "isDirty", {
    get: function() {
      return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "func", {
    get: function() {
      return this._func;
    },
    set: function(e) {
      this._func !== e && (this._func = e, this._isStencilFuncDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "funcRef", {
    get: function() {
      return this._funcRef;
    },
    set: function(e) {
      this._funcRef !== e && (this._funcRef = e, this._isStencilFuncDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "funcMask", {
    get: function() {
      return this._funcMask;
    },
    set: function(e) {
      this._funcMask !== e && (this._funcMask = e, this._isStencilFuncDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "opStencilFail", {
    get: function() {
      return this._opStencilFail;
    },
    set: function(e) {
      this._opStencilFail !== e && (this._opStencilFail = e, this._isStencilOpDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "opDepthFail", {
    get: function() {
      return this._opDepthFail;
    },
    set: function(e) {
      this._opDepthFail !== e && (this._opDepthFail = e, this._isStencilOpDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "opStencilDepthPass", {
    get: function() {
      return this._opStencilDepthPass;
    },
    set: function(e) {
      this._opStencilDepthPass !== e && (this._opStencilDepthPass = e, this._isStencilOpDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "mask", {
    get: function() {
      return this._mask;
    },
    set: function(e) {
      this._mask !== e && (this._mask = e, this._isStencilMaskDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "enabled", {
    get: function() {
      return this._enabled;
    },
    set: function(e) {
      this._enabled !== e && (this._enabled = e, this._isStencilTestDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.reset = function() {
    var e;
    this.stencilMaterial = void 0, (e = this.stencilGlobal) === null || e === void 0 || e.reset(), this._isStencilTestDirty = !0, this._isStencilMaskDirty = !0, this._isStencilFuncDirty = !0, this._isStencilOpDirty = !0;
  }, i.prototype.apply = function(e) {
    var t;
    if (!!e) {
      var r = !this.useStencilGlobalOnly && !!(!((t = this.stencilMaterial) === null || t === void 0) && t.enabled);
      this.enabled = r ? this.stencilMaterial.enabled : this.stencilGlobal.enabled, this.func = r ? this.stencilMaterial.func : this.stencilGlobal.func, this.funcRef = r ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef, this.funcMask = r ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask, this.opStencilFail = r ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail, this.opDepthFail = r ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail, this.opStencilDepthPass = r ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass, this.mask = r ? this.stencilMaterial.mask : this.stencilGlobal.mask, this.isDirty && (this._isStencilTestDirty && (this.enabled ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this._isStencilTestDirty = !1), this._isStencilMaskDirty && (e.stencilMask(this.mask), this._isStencilMaskDirty = !1), this._isStencilFuncDirty && (e.stencilFunc(this.func, this.funcRef, this.funcMask), this._isStencilFuncDirty = !1), this._isStencilOpDirty && (e.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass), this._isStencilOpDirty = !1));
    }
  }, i;
}(), kn = function() {
  function i() {
  }
  return i;
}(), ue = function() {
  function i(e, t, r, n) {
    var a = this;
    this._name = "WebGL", this.forcePOTTextures = !1, this.isFullscreen = !1, this.cullBackFaces = null, this.renderEvenInBackground = !0, this.preventCacheWipeBetweenFrames = !1, this.validateShaderPrograms = !1, this._useReverseDepthBuffer = !1, this.isNDCHalfZRange = !1, this.hasOriginBottomLeft = !0, this.disableUniformBuffers = !1, this.onDisposeObservable = new O(), this._frameId = 0, this._uniformBuffers = new Array(), this._storageBuffers = new Array(), this._webGLVersion = 1, this._windowIsBackground = !1, this._highPrecisionShadersAllowed = !0, this._badOS = !1, this._badDesktopOS = !1, this._renderingQueueLaunched = !1, this._activeRenderLoops = new Array(), this.onContextLostObservable = new O(), this.onContextRestoredObservable = new O(), this._contextWasLost = !1, this._doNotHandleContextLost = !1, this.disableVertexArrayObjects = !1, this._colorWrite = !0, this._colorWriteChanged = !0, this._depthCullingState = new Fn(), this._stencilStateComposer = new Vn(), this._stencilState = new wn(), this._alphaState = new Ln(), this._alphaMode = 1, this._alphaEquation = 0, this._internalTexturesCache = new Array(), this._renderTargetWrapperCache = new Array(), this._activeChannel = 0, this._currentTextureChannel = -1, this._boundTexturesCache = {}, this._compiledEffects = {}, this._vertexAttribArraysEnabled = [], this._uintIndicesCurrentlySet = !1, this._currentBoundBuffer = new Array(), this._currentFramebuffer = null, this._dummyFramebuffer = null, this._currentBufferPointers = new Array(), this._currentInstanceLocations = new Array(), this._currentInstanceBuffers = new Array(), this._vaoRecordInProgress = !1, this._mustWipeVertexAttributes = !1, this._nextFreeTextureSlots = new Array(), this._maxSimultaneousTextures = 0, this._maxMSAASamplesOverride = null, this._activeRequests = new Array(), this._adaptToDeviceRatio = !1, this._transformTextureUrl = null, this.hostInformation = {
      isMobile: !1
    }, this.premultipliedAlpha = !0, this.onBeforeTextureInitObservable = new O(), this._isWebGPU = !1, this._snapshotRenderingMode = 0, this._viewportCached = { x: 0, y: 0, z: 0, w: 0 }, this._unpackFlipYCached = null, this.enableUnpackFlipYCached = !0, this._boundUniforms = {};
    var s = null;
    if (r = r || {}, this._creationOptions = r, this._adaptToDeviceRatio = n != null ? n : !1, this._stencilStateComposer.stencilGlobal = this._stencilState, St.SetMatrixPrecision(!!r.useHighPrecisionMatrix), !!e) {
      if (n = n || r.adaptToDeviceRatio || !1, e.getContext) {
        if (s = e, this._renderingCanvas = s, t !== void 0 && (r.antialias = t), r.deterministicLockstep === void 0 && (r.deterministicLockstep = !1), r.lockstepMaxSteps === void 0 && (r.lockstepMaxSteps = 4), r.timeStep === void 0 && (r.timeStep = 1 / 60), r.preserveDrawingBuffer === void 0 && (r.preserveDrawingBuffer = !1), r.audioEngine === void 0 && (r.audioEngine = !0), r.audioEngineOptions !== void 0 && r.audioEngineOptions.audioContext !== void 0 && (this._audioContext = r.audioEngineOptions.audioContext), r.audioEngineOptions !== void 0 && r.audioEngineOptions.audioDestination !== void 0 && (this._audioDestination = r.audioEngineOptions.audioDestination), r.stencil === void 0 && (r.stencil = !0), r.premultipliedAlpha === !1 && (this.premultipliedAlpha = !1), r.xrCompatible === void 0 && (r.xrCompatible = !0), this._doNotHandleContextLost = !!r.doNotHandleContextLost, navigator && navigator.userAgent) {
          this._checkForMobile = function() {
            var x = navigator.userAgent;
            a.hostInformation.isMobile = x.indexOf("Mobile") !== -1 || x.indexOf("Mac") !== -1 && br() && "ontouchend" in document;
          }, this._checkForMobile(), me() && window.addEventListener("resize", this._checkForMobile);
          for (var o = navigator.userAgent, u = 0, f = i.ExceptionList; u < f.length; u++) {
            var l = f[u], h = l.key, c = l.targets, d = new RegExp(h);
            if (d.test(o)) {
              if (l.capture && l.captureConstraint) {
                var p = l.capture, g = l.captureConstraint, _ = new RegExp(p), v = _.exec(o);
                if (v && v.length > 0) {
                  var y = parseInt(v[v.length - 1]);
                  if (y >= g)
                    continue;
                }
              }
              for (var E = 0, R = c; E < R.length; E++) {
                var M = R[E];
                switch (M) {
                  case "uniformBuffer":
                    this.disableUniformBuffers = !0;
                    break;
                  case "vao":
                    this.disableVertexArrayObjects = !0;
                    break;
                  case "antialias":
                    r.antialias = !1;
                    break;
                  case "maxMSAASamples":
                    this._maxMSAASamplesOverride = 1;
                    break;
                }
              }
            }
          }
        }
        if (this._doNotHandleContextLost || (this._onContextLost = function(x) {
          x.preventDefault(), a._contextWasLost = !0, k.Warn("WebGL context lost."), a.onContextLostObservable.notifyObservers(a);
        }, this._onContextRestored = function() {
          a._restoreEngineAfterContextLost(a._initGLContext.bind(a));
        }, s.addEventListener("webglcontextlost", this._onContextLost, !1), s.addEventListener("webglcontextrestored", this._onContextRestored, !1), r.powerPreference = "high-performance"), this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), this._badDesktopOS && (r.xrCompatible = !1), !r.disableWebGL2Support)
          try {
            this._gl = s.getContext("webgl2", r) || s.getContext("experimental-webgl2", r), this._gl && (this._webGLVersion = 2, this._shaderPlatformName = "WEBGL2", this._gl.deleteQuery || (this._webGLVersion = 1, this._shaderPlatformName = "WEBGL1"));
          } catch {
          }
        if (!this._gl) {
          if (!s)
            throw new Error("The provided canvas is null or undefined.");
          try {
            this._gl = s.getContext("webgl", r) || s.getContext("experimental-webgl", r);
          } catch {
            throw new Error("WebGL not supported");
          }
        }
        if (!this._gl)
          throw new Error("WebGL not supported");
      } else {
        this._gl = e, this._renderingCanvas = this._gl.canvas, this._gl.renderbufferStorageMultisample ? (this._webGLVersion = 2, this._shaderPlatformName = "WEBGL2") : this._shaderPlatformName = "WEBGL1";
        var C = this._gl.getContextAttributes();
        C && (r.stencil = C.stencil);
      }
      this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE), r.useHighPrecisionFloats !== void 0 && (this._highPrecisionShadersAllowed = r.useHighPrecisionFloats);
      var A = me() && window.devicePixelRatio || 1, S = r.limitDeviceRatio || A;
      this._hardwareScalingLevel = n ? 1 / Math.min(S, A) : 1, this.resize(), this._isStencilEnable = !!r.stencil, this._initGLContext(), this._initFeatures();
      for (var w = 0; w < this._caps.maxVertexAttribs; w++)
        this._currentBufferPointers[w] = new kn();
      this._shaderProcessor = this.webGLVersion > 1 ? new Bn() : new Nn(), this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);
      var F = "Babylon.js v".concat(i.Version);
      console.log(F + " - ".concat(this.description)), this._renderingCanvas && this._renderingCanvas.setAttribute && this._renderingCanvas.setAttribute("data-engine", F);
    }
  }
  return Object.defineProperty(i, "NpmPackage", {
    get: function() {
      return "babylonjs@5.10.0";
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "Version", {
    get: function() {
      return "5.10.0";
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "description", {
    get: function() {
      var e = this.name + this.webGLVersion;
      return this._caps.parallelShaderCompile && (e += " - Parallel shader compilation"), e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "name", {
    get: function() {
      return this._name;
    },
    set: function(e) {
      this._name = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "version", {
    get: function() {
      return this._webGLVersion;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "ShadersRepository", {
    get: function() {
      return ze.ShadersRepository;
    },
    set: function(e) {
      ze.ShadersRepository = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._getShaderProcessor = function(e) {
    return this._shaderProcessor;
  }, Object.defineProperty(i.prototype, "useReverseDepthBuffer", {
    get: function() {
      return this._useReverseDepthBuffer;
    },
    set: function(e) {
      e !== this._useReverseDepthBuffer && (this._useReverseDepthBuffer = e, e ? this._depthCullingState.depthFunc = 518 : this._depthCullingState.depthFunc = 515);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "frameId", {
    get: function() {
      return this._frameId;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "supportsUniformBuffers", {
    get: function() {
      return this.webGLVersion > 1 && !this.disableUniformBuffers;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getCreationOptions = function() {
    return this._creationOptions;
  }, Object.defineProperty(i.prototype, "_shouldUseHighPrecisionShader", {
    get: function() {
      return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "needPOTTextures", {
    get: function() {
      return this._webGLVersion < 2 || this.forcePOTTextures;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "activeRenderLoops", {
    get: function() {
      return this._activeRenderLoops;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "doNotHandleContextLost", {
    get: function() {
      return this._doNotHandleContextLost;
    },
    set: function(e) {
      this._doNotHandleContextLost = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "_supportsHardwareTextureRescaling", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "framebufferDimensionsObject", {
    set: function(e) {
      this._framebufferDimensionsObject = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "currentViewport", {
    get: function() {
      return this._cachedViewport;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "emptyTexture", {
    get: function() {
      return this._emptyTexture || (this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, !1, !1, 1)), this._emptyTexture;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "emptyTexture3D", {
    get: function() {
      return this._emptyTexture3D || (this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, !1, !1, 1)), this._emptyTexture3D;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "emptyTexture2DArray", {
    get: function() {
      return this._emptyTexture2DArray || (this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, !1, !1, 1)), this._emptyTexture2DArray;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "emptyCubeTexture", {
    get: function() {
      if (!this._emptyCubeTexture) {
        var e = new Uint8Array(4), t = [e, e, e, e, e, e];
        this._emptyCubeTexture = this.createRawCubeTexture(t, 1, 5, 0, !1, !1, 1);
      }
      return this._emptyCubeTexture;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "isWebGPU", {
    get: function() {
      return this._isWebGPU;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "shaderPlatformName", {
    get: function() {
      return this._shaderPlatformName;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "snapshotRendering", {
    get: function() {
      return !1;
    },
    set: function(e) {
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "snapshotRenderingMode", {
    get: function() {
      return this._snapshotRenderingMode;
    },
    set: function(e) {
      this._snapshotRenderingMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.snapshotRenderingReset = function() {
    this.snapshotRendering = !1;
  }, i._CreateCanvas = function(e, t) {
    if (typeof document > "u")
      return new OffscreenCanvas(e, t);
    var r = document.createElement("canvas");
    return r.width = e, r.height = t, r;
  }, i.prototype.createCanvas = function(e, t) {
    return i._CreateCanvas(e, t);
  }, i.prototype.createCanvasImage = function() {
    return document.createElement("img");
  }, i.prototype._restoreEngineAfterContextLost = function(e) {
    var t = this;
    setTimeout(function() {
      return fi(t, void 0, void 0, function() {
        var r, n, a, s, o;
        return Gt(this, function(u) {
          switch (u.label) {
            case 0:
              return this._dummyFramebuffer = null, r = this._depthCullingState.depthTest, n = this._depthCullingState.depthFunc, a = this._depthCullingState.depthMask, s = this._stencilState.stencilTest, [4, e()];
            case 1:
              return u.sent(), this._rebuildEffects(), (o = this._rebuildComputeEffects) === null || o === void 0 || o.call(this), this._rebuildInternalTextures(), this._rebuildRenderTargetWrappers(), this._rebuildBuffers(), this.wipeCaches(!0), this._depthCullingState.depthTest = r, this._depthCullingState.depthFunc = n, this._depthCullingState.depthMask = a, this._stencilState.stencilTest = s, k.Warn(this.name + " context successfully restored."), this.onContextRestoredObservable.notifyObservers(this), this._contextWasLost = !1, [2];
          }
        });
      });
    }, 0);
  }, i.prototype._sharedInit = function(e, t, r) {
    this._renderingCanvas = e;
  }, i.prototype._getShaderProcessingContext = function(e) {
    return null;
  }, i.prototype._rebuildInternalTextures = function() {
    for (var e = this._internalTexturesCache.slice(), t = 0, r = e; t < r.length; t++) {
      var n = r[t];
      n._rebuild();
    }
  }, i.prototype._rebuildRenderTargetWrappers = function() {
    for (var e = this._renderTargetWrapperCache.slice(), t = 0, r = e; t < r.length; t++) {
      var n = r[t];
      n._rebuild();
    }
  }, i.prototype._rebuildEffects = function() {
    for (var e in this._compiledEffects) {
      var t = this._compiledEffects[e];
      t._pipelineContext = null, t._wasPreviouslyReady = !1, t._prepareEffect();
    }
    ze.ResetCache();
  }, i.prototype.areAllEffectsReady = function() {
    for (var e in this._compiledEffects) {
      var t = this._compiledEffects[e];
      if (!t.isReady())
        return !1;
    }
    return !0;
  }, i.prototype._rebuildBuffers = function() {
    for (var e = 0, t = this._uniformBuffers; e < t.length; e++) {
      var r = t[e];
      r._rebuild();
    }
    for (var n = 0, a = this._storageBuffers; n < a.length; n++) {
      var s = a[n];
      s._rebuild();
    }
  }, i.prototype._initGLContext = function() {
    this._caps = {
      maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),
      maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),
      maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,
      maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),
      maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),
      maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),
      maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),
      maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),
      maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),
      parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile") || void 0,
      standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension("OES_standard_derivatives") !== null,
      maxAnisotropy: 1,
      astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
      bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
      s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
      s3tc_srgb: this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),
      pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
      etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"),
      textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),
      uintIndices: this._webGLVersion > 1 || this._gl.getExtension("OES_element_index_uint") !== null,
      fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension("EXT_frag_depth") !== null,
      highPrecisionShaderSupported: !1,
      timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"),
      supportOcclusionQuery: this._webGLVersion > 1,
      canUseTimestampForTimerQuery: !1,
      drawBuffersExtension: !1,
      maxMSAASamples: 1,
      colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float")),
      textureFloat: !!(this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float")),
      textureHalfFloat: !!(this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float")),
      textureHalfFloatRender: !1,
      textureFloatLinearFiltering: !1,
      textureFloatRender: !1,
      textureHalfFloatLinearFiltering: !1,
      vertexArrayObject: !1,
      instancedArrays: !1,
      textureLOD: !!(this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod")),
      blendMinMax: !1,
      multiview: this._gl.getExtension("OVR_multiview2"),
      oculusMultiview: this._gl.getExtension("OCULUS_multiview"),
      depthTextureExtension: !1,
      canUseGLInstanceID: this._webGLVersion > 1,
      canUseGLVertexID: this._webGLVersion > 1,
      supportComputeShaders: !1,
      supportSRGBBuffers: !1,
      supportTransformFeedbacks: this._webGLVersion > 1,
      textureMaxLevel: this._webGLVersion > 1,
      texture2DArrayMaxLayerCount: this._webGLVersion > 1 ? 256 : 128
    }, this._glVersion = this._gl.getParameter(this._gl.VERSION);
    var e = this._gl.getExtension("WEBGL_debug_renderer_info");
    if (e != null && (this._glRenderer = this._gl.getParameter(e.UNMASKED_RENDERER_WEBGL), this._glVendor = this._gl.getParameter(e.UNMASKED_VENDOR_WEBGL)), this._glVendor || (this._glVendor = this._gl.getParameter(this._gl.VENDOR) || "Unknown vendor"), this._glRenderer || (this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || "Unknown renderer"), this._gl.HALF_FLOAT_OES !== 36193 && (this._gl.HALF_FLOAT_OES = 36193), this._gl.RGBA16F !== 34842 && (this._gl.RGBA16F = 34842), this._gl.RGBA32F !== 34836 && (this._gl.RGBA32F = 34836), this._gl.DEPTH24_STENCIL8 !== 35056 && (this._gl.DEPTH24_STENCIL8 = 35056), this._caps.timerQuery && (this._webGLVersion === 1 && (this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery)), this._caps.canUseTimestampForTimerQuery = this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT) > 0), this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, this._caps.textureFloatLinearFiltering = !!(this._caps.textureFloat && this._gl.getExtension("OES_texture_float_linear")), this._caps.textureFloatRender = !!(this._caps.textureFloat && this._canRenderToFloatFramebuffer()), this._caps.textureHalfFloatLinearFiltering = !!(this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear")), this._caps.astc && (this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR), this._caps.bptc && (this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT), this._caps.s3tc_srgb && (this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT, this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT), this._caps.etc2 && (this._gl.COMPRESSED_SRGB8_ETC2 = this._caps.etc2.COMPRESSED_SRGB8_ETC2, this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC), this._webGLVersion > 1 && this._gl.HALF_FLOAT_OES !== 5131 && (this._gl.HALF_FLOAT_OES = 5131), this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer(), this._webGLVersion > 1)
      this._caps.drawBuffersExtension = !0, this._caps.maxMSAASamples = this._maxMSAASamplesOverride !== null ? this._maxMSAASamplesOverride : this._gl.getParameter(this._gl.MAX_SAMPLES);
    else {
      var t = this._gl.getExtension("WEBGL_draw_buffers");
      if (t !== null) {
        this._caps.drawBuffersExtension = !0, this._gl.drawBuffers = t.drawBuffersWEBGL.bind(t), this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;
        for (var r = 0; r < 16; r++)
          this._gl["COLOR_ATTACHMENT" + r + "_WEBGL"] = t["COLOR_ATTACHMENT" + r + "_WEBGL"];
      }
    }
    if (this._webGLVersion > 1)
      this._caps.depthTextureExtension = !0;
    else {
      var n = this._gl.getExtension("WEBGL_depth_texture");
      n != null && (this._caps.depthTextureExtension = !0, this._gl.UNSIGNED_INT_24_8 = n.UNSIGNED_INT_24_8_WEBGL);
    }
    if (this.disableVertexArrayObjects)
      this._caps.vertexArrayObject = !1;
    else if (this._webGLVersion > 1)
      this._caps.vertexArrayObject = !0;
    else {
      var a = this._gl.getExtension("OES_vertex_array_object");
      a != null && (this._caps.vertexArrayObject = !0, this._gl.createVertexArray = a.createVertexArrayOES.bind(a), this._gl.bindVertexArray = a.bindVertexArrayOES.bind(a), this._gl.deleteVertexArray = a.deleteVertexArrayOES.bind(a));
    }
    if (this._webGLVersion > 1)
      this._caps.instancedArrays = !0;
    else {
      var s = this._gl.getExtension("ANGLE_instanced_arrays");
      s != null ? (this._caps.instancedArrays = !0, this._gl.drawArraysInstanced = s.drawArraysInstancedANGLE.bind(s), this._gl.drawElementsInstanced = s.drawElementsInstancedANGLE.bind(s), this._gl.vertexAttribDivisor = s.vertexAttribDivisorANGLE.bind(s)) : this._caps.instancedArrays = !1;
    }
    if (this._gl.getShaderPrecisionFormat) {
      var o = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT), u = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
      o && u && (this._caps.highPrecisionShaderSupported = o.precision !== 0 && u.precision !== 0);
    }
    if (this._webGLVersion > 1)
      this._caps.blendMinMax = !0;
    else {
      var f = this._gl.getExtension("EXT_blend_minmax");
      f != null && (this._caps.blendMinMax = !0, this._gl.MAX = f.MAX_EXT, this._gl.MIN = f.MIN_EXT);
    }
    if (!this._caps.supportSRGBBuffers) {
      if (this._webGLVersion > 1)
        this._caps.supportSRGBBuffers = !0;
      else {
        var l = this._gl.getExtension("EXT_sRGB");
        l != null && (this._caps.supportSRGBBuffers = !0, this._gl.SRGB = l.SRGB_EXT, this._gl.SRGB8 = l.SRGB_ALPHA_EXT, this._gl.SRGB8_ALPHA8 = l.SRGB_ALPHA_EXT);
      }
      this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && !!(this._creationOptions && this._creationOptions.forceSRGBBufferSupportState);
    }
    this._depthCullingState.depthTest = !0, this._depthCullingState.depthFunc = this._gl.LEQUAL, this._depthCullingState.depthMask = !0, this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;
    for (var h = 0; h < this._maxSimultaneousTextures; h++)
      this._nextFreeTextureSlots.push(h);
  }, i.prototype._initFeatures = function() {
    this._features = {
      forceBitmapOverHTMLImageElement: !1,
      supportRenderAndCopyToLodForFloatTextures: this._webGLVersion !== 1,
      supportDepthStencilTexture: this._webGLVersion !== 1,
      supportShadowSamplers: this._webGLVersion !== 1,
      uniformBufferHardCheckMatrix: !1,
      allowTexturePrefiltering: this._webGLVersion !== 1,
      trackUbosInFrame: !1,
      checkUbosContentBeforeUpload: !1,
      supportCSM: this._webGLVersion !== 1,
      basisNeedsPOT: this._webGLVersion === 1,
      support3DTextures: this._webGLVersion !== 1,
      needTypeSuffixInShaderConstants: this._webGLVersion !== 1,
      supportMSAA: this._webGLVersion !== 1,
      supportSSAO2: this._webGLVersion !== 1,
      supportExtendedTextureFormats: this._webGLVersion !== 1,
      supportSwitchCaseInShader: this._webGLVersion !== 1,
      supportSyncTextureRead: !0,
      needsInvertingBitmap: !0,
      useUBOBindingCache: !0,
      needShaderCodeInlining: !1,
      needToAlwaysBindUniformBuffers: !1,
      supportRenderPasses: !1,
      _collectUbosUpdatedInFrame: !1
    };
  }, Object.defineProperty(i.prototype, "webGLVersion", {
    get: function() {
      return this._webGLVersion;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getClassName = function() {
    return "ThinEngine";
  }, Object.defineProperty(i.prototype, "isStencilEnable", {
    get: function() {
      return this._isStencilEnable;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._prepareWorkingCanvas = function() {
    if (!this._workingCanvas) {
      this._workingCanvas = this.createCanvas(1, 1);
      var e = this._workingCanvas.getContext("2d");
      e && (this._workingContext = e);
    }
  }, i.prototype.resetTextureCache = function() {
    for (var e in this._boundTexturesCache)
      !Object.prototype.hasOwnProperty.call(this._boundTexturesCache, e) || (this._boundTexturesCache[e] = null);
    this._currentTextureChannel = -1;
  }, i.prototype.getInfo = function() {
    return this.getGlInfo();
  }, i.prototype.getGlInfo = function() {
    return {
      vendor: this._glVendor,
      renderer: this._glRenderer,
      version: this._glVersion
    };
  }, i.prototype.setHardwareScalingLevel = function(e) {
    this._hardwareScalingLevel = e, this.resize();
  }, i.prototype.getHardwareScalingLevel = function() {
    return this._hardwareScalingLevel;
  }, i.prototype.getLoadedTexturesCache = function() {
    return this._internalTexturesCache;
  }, i.prototype.getCaps = function() {
    return this._caps;
  }, i.prototype.stopRenderLoop = function(e) {
    if (!e) {
      this._activeRenderLoops = [];
      return;
    }
    var t = this._activeRenderLoops.indexOf(e);
    t >= 0 && this._activeRenderLoops.splice(t, 1);
  }, i.prototype._renderLoop = function() {
    if (!this._contextWasLost) {
      var e = !0;
      if (!this.renderEvenInBackground && this._windowIsBackground && (e = !1), e) {
        this.beginFrame();
        for (var t = 0; t < this._activeRenderLoops.length; t++) {
          var r = this._activeRenderLoops[t];
          r();
        }
        this.endFrame();
      }
    }
    this._activeRenderLoops.length > 0 ? this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow()) : this._renderingQueueLaunched = !1;
  }, i.prototype.getRenderingCanvas = function() {
    return this._renderingCanvas;
  }, i.prototype.getAudioContext = function() {
    return this._audioContext;
  }, i.prototype.getAudioDestination = function() {
    return this._audioDestination;
  }, i.prototype.getHostWindow = function() {
    return me() ? this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView ? this._renderingCanvas.ownerDocument.defaultView : window : null;
  }, i.prototype.getRenderWidth = function(e) {
    return e === void 0 && (e = !1), !e && this._currentRenderTarget ? this._currentRenderTarget.width : this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth;
  }, i.prototype.getRenderHeight = function(e) {
    return e === void 0 && (e = !1), !e && this._currentRenderTarget ? this._currentRenderTarget.height : this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight;
  }, i.prototype._queueNewFrame = function(e, t) {
    return i.QueueNewFrame(e, t);
  }, i.prototype.runRenderLoop = function(e) {
    this._activeRenderLoops.indexOf(e) === -1 && (this._activeRenderLoops.push(e), this._renderingQueueLaunched || (this._renderingQueueLaunched = !0, this._boundRenderFunction = this._renderLoop.bind(this), this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow())));
  }, i.prototype.clear = function(e, t, r, n) {
    n === void 0 && (n = !1);
    var a = this.stencilStateComposer.useStencilGlobalOnly;
    this.stencilStateComposer.useStencilGlobalOnly = !0, this.applyStates(), this.stencilStateComposer.useStencilGlobalOnly = a;
    var s = 0;
    t && e && (this._gl.clearColor(e.r, e.g, e.b, e.a !== void 0 ? e.a : 1), s |= this._gl.COLOR_BUFFER_BIT), r && (this.useReverseDepthBuffer ? (this._depthCullingState.depthFunc = this._gl.GEQUAL, this._gl.clearDepth(0)) : this._gl.clearDepth(1), s |= this._gl.DEPTH_BUFFER_BIT), n && (this._gl.clearStencil(0), s |= this._gl.STENCIL_BUFFER_BIT), this._gl.clear(s);
  }, i.prototype._viewport = function(e, t, r, n) {
    (e !== this._viewportCached.x || t !== this._viewportCached.y || r !== this._viewportCached.z || n !== this._viewportCached.w) && (this._viewportCached.x = e, this._viewportCached.y = t, this._viewportCached.z = r, this._viewportCached.w = n, this._gl.viewport(e, t, r, n));
  }, i.prototype.setViewport = function(e, t, r) {
    var n = t || this.getRenderWidth(), a = r || this.getRenderHeight(), s = e.x || 0, o = e.y || 0;
    this._cachedViewport = e, this._viewport(s * n, o * a, n * e.width, a * e.height);
  }, i.prototype.beginFrame = function() {
  }, i.prototype.endFrame = function() {
    this._badOS && this.flushFramebuffer(), this._frameId++;
  }, i.prototype.resize = function(e) {
    e === void 0 && (e = !1);
    var t, r;
    if (this._adaptToDeviceRatio) {
      var n = me() && window.devicePixelRatio || 1, a = this._creationOptions.limitDeviceRatio || n;
      this._hardwareScalingLevel = this._adaptToDeviceRatio ? 1 / Math.min(a, n) : 1;
    }
    me() ? (t = this._renderingCanvas ? this._renderingCanvas.clientWidth || this._renderingCanvas.width : window.innerWidth, r = this._renderingCanvas ? this._renderingCanvas.clientHeight || this._renderingCanvas.height : window.innerHeight) : (t = this._renderingCanvas ? this._renderingCanvas.width : 100, r = this._renderingCanvas ? this._renderingCanvas.height : 100), this.setSize(t / this._hardwareScalingLevel, r / this._hardwareScalingLevel, e);
  }, i.prototype.setSize = function(e, t, r) {
    return r === void 0 && (r = !1), !this._renderingCanvas || (e = e | 0, t = t | 0, !r && this._renderingCanvas.width === e && this._renderingCanvas.height === t) ? !1 : (this._renderingCanvas.width = e, this._renderingCanvas.height = t, !0);
  }, i.prototype.bindFramebuffer = function(e, t, r, n, a, s, o) {
    var u, f, l, h, c;
    t === void 0 && (t = 0), s === void 0 && (s = 0), o === void 0 && (o = 0);
    var d = e;
    this._currentRenderTarget && this.unBindFramebuffer(this._currentRenderTarget), this._currentRenderTarget = e, this._bindUnboundFramebuffer(d._MSAAFramebuffer ? d._MSAAFramebuffer : d._framebuffer);
    var p = this._gl;
    e.is2DArray ? p.framebufferTextureLayer(p.FRAMEBUFFER, p.COLOR_ATTACHMENT0, (u = e.texture._hardwareTexture) === null || u === void 0 ? void 0 : u.underlyingResource, s, o) : e.isCube && p.framebufferTexture2D(p.FRAMEBUFFER, p.COLOR_ATTACHMENT0, p.TEXTURE_CUBE_MAP_POSITIVE_X + t, (f = e.texture._hardwareTexture) === null || f === void 0 ? void 0 : f.underlyingResource, s);
    var g = e._depthStencilTexture;
    if (g) {
      var _ = e._depthStencilTextureWithStencil ? p.DEPTH_STENCIL_ATTACHMENT : p.DEPTH_ATTACHMENT;
      e.is2DArray ? p.framebufferTextureLayer(p.FRAMEBUFFER, _, (l = g._hardwareTexture) === null || l === void 0 ? void 0 : l.underlyingResource, s, o) : e.isCube ? p.framebufferTexture2D(p.FRAMEBUFFER, _, p.TEXTURE_CUBE_MAP_POSITIVE_X + t, (h = g._hardwareTexture) === null || h === void 0 ? void 0 : h.underlyingResource, s) : p.framebufferTexture2D(p.FRAMEBUFFER, _, p.TEXTURE_2D, (c = g._hardwareTexture) === null || c === void 0 ? void 0 : c.underlyingResource, s);
    }
    this._cachedViewport && !a ? this.setViewport(this._cachedViewport, r, n) : (r || (r = e.width, s && (r = r / Math.pow(2, s))), n || (n = e.height, s && (n = n / Math.pow(2, s))), this._viewport(0, 0, r, n)), this.wipeCaches();
  }, i.prototype.setState = function(e, t, r, n, a, s, o) {
    var u, f;
    t === void 0 && (t = 0), n === void 0 && (n = !1), o === void 0 && (o = 0), (this._depthCullingState.cull !== e || r) && (this._depthCullingState.cull = e);
    var l = !((f = (u = this.cullBackFaces) !== null && u !== void 0 ? u : a) !== null && f !== void 0) || f ? this._gl.BACK : this._gl.FRONT;
    (this._depthCullingState.cullFace !== l || r) && (this._depthCullingState.cullFace = l), this.setZOffset(t), this.setZOffsetUnits(o);
    var h = n ? this._gl.CW : this._gl.CCW;
    (this._depthCullingState.frontFace !== h || r) && (this._depthCullingState.frontFace = h), this._stencilStateComposer.stencilMaterial = s;
  }, i.prototype.setZOffset = function(e) {
    this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -e : e;
  }, i.prototype.getZOffset = function() {
    var e = this._depthCullingState.zOffset;
    return this.useReverseDepthBuffer ? -e : e;
  }, i.prototype.setZOffsetUnits = function(e) {
    this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -e : e;
  }, i.prototype.getZOffsetUnits = function() {
    var e = this._depthCullingState.zOffsetUnits;
    return this.useReverseDepthBuffer ? -e : e;
  }, i.prototype._bindUnboundFramebuffer = function(e) {
    this._currentFramebuffer !== e && (this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, e), this._currentFramebuffer = e);
  }, i.prototype._currentFrameBufferIsDefaultFrameBuffer = function() {
    return this._currentFramebuffer === null;
  }, i.prototype.generateMipmaps = function(e) {
    this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0), this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  }, i.prototype.unBindFramebuffer = function(e, t, r) {
    var n;
    t === void 0 && (t = !1);
    var a = e;
    this._currentRenderTarget = null;
    var s = this._gl;
    if (a._MSAAFramebuffer) {
      if (e.isMulti) {
        this.unBindMultiColorAttachmentFramebuffer(e, t, r);
        return;
      }
      s.bindFramebuffer(s.READ_FRAMEBUFFER, a._MSAAFramebuffer), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, a._framebuffer), s.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, s.COLOR_BUFFER_BIT, s.NEAREST);
    }
    ((n = e.texture) === null || n === void 0 ? void 0 : n.generateMipMaps) && !t && !e.isCube && this.generateMipmaps(e.texture), r && (a._MSAAFramebuffer && this._bindUnboundFramebuffer(a._framebuffer), r()), this._bindUnboundFramebuffer(null);
  }, i.prototype.flushFramebuffer = function() {
    this._gl.flush();
  }, i.prototype.restoreDefaultFramebuffer = function() {
    this._currentRenderTarget ? this.unBindFramebuffer(this._currentRenderTarget) : this._bindUnboundFramebuffer(null), this._cachedViewport && this.setViewport(this._cachedViewport), this.wipeCaches();
  }, i.prototype._resetVertexBufferBinding = function() {
    this.bindArrayBuffer(null), this._cachedVertexBuffers = null;
  }, i.prototype.createVertexBuffer = function(e) {
    return this._createVertexBuffer(e, this._gl.STATIC_DRAW);
  }, i.prototype._createVertexBuffer = function(e, t) {
    var r = this._gl.createBuffer();
    if (!r)
      throw new Error("Unable to create vertex buffer");
    var n = new $t(r);
    return this.bindArrayBuffer(n), e instanceof Array ? this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(e), t) : this._gl.bufferData(this._gl.ARRAY_BUFFER, e, t), this._resetVertexBufferBinding(), n.references = 1, n;
  }, i.prototype.createDynamicVertexBuffer = function(e) {
    return this._createVertexBuffer(e, this._gl.DYNAMIC_DRAW);
  }, i.prototype._resetIndexBufferBinding = function() {
    this.bindIndexBuffer(null), this._cachedIndexBuffer = null;
  }, i.prototype.createIndexBuffer = function(e, t) {
    var r = this._gl.createBuffer(), n = new $t(r);
    if (!r)
      throw new Error("Unable to create index buffer");
    this.bindIndexBuffer(n);
    var a = this._normalizeIndexData(e);
    return this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, a, t ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW), this._resetIndexBufferBinding(), n.references = 1, n.is32Bits = a.BYTES_PER_ELEMENT === 4, n;
  }, i.prototype._normalizeIndexData = function(e) {
    var t = e.BYTES_PER_ELEMENT;
    if (t === 2)
      return e;
    if (this._caps.uintIndices) {
      if (e instanceof Uint32Array)
        return e;
      for (var r = 0; r < e.length; r++)
        if (e[r] >= 65535)
          return new Uint32Array(e);
      return new Uint16Array(e);
    }
    return new Uint16Array(e);
  }, i.prototype.bindArrayBuffer = function(e) {
    this._vaoRecordInProgress || this._unbindVertexArrayObject(), this._bindBuffer(e, this._gl.ARRAY_BUFFER);
  }, i.prototype.bindUniformBlock = function(e, t, r) {
    var n = e.program, a = this._gl.getUniformBlockIndex(n, t);
    this._gl.uniformBlockBinding(n, a, r);
  }, i.prototype.bindIndexBuffer = function(e) {
    this._vaoRecordInProgress || this._unbindVertexArrayObject(), this._bindBuffer(e, this._gl.ELEMENT_ARRAY_BUFFER);
  }, i.prototype._bindBuffer = function(e, t) {
    (this._vaoRecordInProgress || this._currentBoundBuffer[t] !== e) && (this._gl.bindBuffer(t, e ? e.underlyingResource : null), this._currentBoundBuffer[t] = e);
  }, i.prototype.updateArrayBuffer = function(e) {
    this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, e);
  }, i.prototype._vertexAttribPointer = function(e, t, r, n, a, s, o) {
    var u = this._currentBufferPointers[t];
    if (!!u) {
      var f = !1;
      u.active ? (u.buffer !== e && (u.buffer = e, f = !0), u.size !== r && (u.size = r, f = !0), u.type !== n && (u.type = n, f = !0), u.normalized !== a && (u.normalized = a, f = !0), u.stride !== s && (u.stride = s, f = !0), u.offset !== o && (u.offset = o, f = !0)) : (f = !0, u.active = !0, u.index = t, u.size = r, u.type = n, u.normalized = a, u.stride = s, u.offset = o, u.buffer = e), (f || this._vaoRecordInProgress) && (this.bindArrayBuffer(e), this._gl.vertexAttribPointer(t, r, n, a, s, o));
    }
  }, i.prototype._bindIndexBufferWithCache = function(e) {
    e != null && this._cachedIndexBuffer !== e && (this._cachedIndexBuffer = e, this.bindIndexBuffer(e), this._uintIndicesCurrentlySet = e.is32Bits);
  }, i.prototype._bindVertexBuffersAttributes = function(e, t, r) {
    var n = t.getAttributesNames();
    this._vaoRecordInProgress || this._unbindVertexArrayObject(), this.unbindAllAttributes();
    for (var a = 0; a < n.length; a++) {
      var s = t.getAttributeLocation(a);
      if (s >= 0) {
        var o = n[a], u = null;
        if (r && (u = r[o]), u || (u = e[o]), !u)
          continue;
        this._gl.enableVertexAttribArray(s), this._vaoRecordInProgress || (this._vertexAttribArraysEnabled[s] = !0);
        var f = u.getBuffer();
        f && (this._vertexAttribPointer(f, s, u.getSize(), u.type, u.normalized, u.byteStride, u.byteOffset), u.getIsInstanced() && (this._gl.vertexAttribDivisor(s, u.getInstanceDivisor()), this._vaoRecordInProgress || (this._currentInstanceLocations.push(s), this._currentInstanceBuffers.push(f))));
      }
    }
  }, i.prototype.recordVertexArrayObject = function(e, t, r, n) {
    var a = this._gl.createVertexArray();
    return this._vaoRecordInProgress = !0, this._gl.bindVertexArray(a), this._mustWipeVertexAttributes = !0, this._bindVertexBuffersAttributes(e, r, n), this.bindIndexBuffer(t), this._vaoRecordInProgress = !1, this._gl.bindVertexArray(null), a;
  }, i.prototype.bindVertexArrayObject = function(e, t) {
    this._cachedVertexArrayObject !== e && (this._cachedVertexArrayObject = e, this._gl.bindVertexArray(e), this._cachedVertexBuffers = null, this._cachedIndexBuffer = null, this._uintIndicesCurrentlySet = t != null && t.is32Bits, this._mustWipeVertexAttributes = !0);
  }, i.prototype.bindBuffersDirectly = function(e, t, r, n, a) {
    if (this._cachedVertexBuffers !== e || this._cachedEffectForVertexBuffers !== a) {
      this._cachedVertexBuffers = e, this._cachedEffectForVertexBuffers = a;
      var s = a.getAttributesCount();
      this._unbindVertexArrayObject(), this.unbindAllAttributes();
      for (var o = 0, u = 0; u < s; u++)
        if (u < r.length) {
          var f = a.getAttributeLocation(u);
          f >= 0 && (this._gl.enableVertexAttribArray(f), this._vertexAttribArraysEnabled[f] = !0, this._vertexAttribPointer(e, f, r[u], this._gl.FLOAT, !1, n, o)), o += r[u] * 4;
        }
    }
    this._bindIndexBufferWithCache(t);
  }, i.prototype._unbindVertexArrayObject = function() {
    !this._cachedVertexArrayObject || (this._cachedVertexArrayObject = null, this._gl.bindVertexArray(null));
  }, i.prototype.bindBuffers = function(e, t, r, n) {
    (this._cachedVertexBuffers !== e || this._cachedEffectForVertexBuffers !== r) && (this._cachedVertexBuffers = e, this._cachedEffectForVertexBuffers = r, this._bindVertexBuffersAttributes(e, r, n)), this._bindIndexBufferWithCache(t);
  }, i.prototype.unbindInstanceAttributes = function() {
    for (var e, t = 0, r = this._currentInstanceLocations.length; t < r; t++) {
      var n = this._currentInstanceBuffers[t];
      e != n && n.references && (e = n, this.bindArrayBuffer(n));
      var a = this._currentInstanceLocations[t];
      this._gl.vertexAttribDivisor(a, 0);
    }
    this._currentInstanceBuffers.length = 0, this._currentInstanceLocations.length = 0;
  }, i.prototype.releaseVertexArrayObject = function(e) {
    this._gl.deleteVertexArray(e);
  }, i.prototype._releaseBuffer = function(e) {
    return e.references--, e.references === 0 ? (this._deleteBuffer(e), !0) : !1;
  }, i.prototype._deleteBuffer = function(e) {
    this._gl.deleteBuffer(e.underlyingResource);
  }, i.prototype.updateAndBindInstancesBuffer = function(e, t, r) {
    if (this.bindArrayBuffer(e), t && this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, t), r[0].index !== void 0)
      this.bindInstancesBuffer(e, r, !0);
    else
      for (var n = 0; n < 4; n++) {
        var a = r[n];
        this._vertexAttribArraysEnabled[a] || (this._gl.enableVertexAttribArray(a), this._vertexAttribArraysEnabled[a] = !0), this._vertexAttribPointer(e, a, 4, this._gl.FLOAT, !1, 64, n * 16), this._gl.vertexAttribDivisor(a, 1), this._currentInstanceLocations.push(a), this._currentInstanceBuffers.push(e);
      }
  }, i.prototype.bindInstancesBuffer = function(e, t, r) {
    r === void 0 && (r = !0), this.bindArrayBuffer(e);
    var n = 0;
    if (r)
      for (var a = 0; a < t.length; a++) {
        var s = t[a];
        n += s.attributeSize * 4;
      }
    for (var a = 0; a < t.length; a++) {
      var s = t[a];
      s.index === void 0 && (s.index = this._currentEffect.getAttributeLocationByName(s.attributeName)), !(s.index < 0) && (this._vertexAttribArraysEnabled[s.index] || (this._gl.enableVertexAttribArray(s.index), this._vertexAttribArraysEnabled[s.index] = !0), this._vertexAttribPointer(e, s.index, s.attributeSize, s.attributeType || this._gl.FLOAT, s.normalized || !1, n, s.offset), this._gl.vertexAttribDivisor(s.index, s.divisor === void 0 ? 1 : s.divisor), this._currentInstanceLocations.push(s.index), this._currentInstanceBuffers.push(e));
    }
  }, i.prototype.disableInstanceAttributeByName = function(e) {
    if (!!this._currentEffect) {
      var t = this._currentEffect.getAttributeLocationByName(e);
      this.disableInstanceAttribute(t);
    }
  }, i.prototype.disableInstanceAttribute = function(e) {
    for (var t = !1, r; (r = this._currentInstanceLocations.indexOf(e)) !== -1; )
      this._currentInstanceLocations.splice(r, 1), this._currentInstanceBuffers.splice(r, 1), t = !0, r = this._currentInstanceLocations.indexOf(e);
    t && (this._gl.vertexAttribDivisor(e, 0), this.disableAttributeByIndex(e));
  }, i.prototype.disableAttributeByIndex = function(e) {
    this._gl.disableVertexAttribArray(e), this._vertexAttribArraysEnabled[e] = !1, this._currentBufferPointers[e].active = !1;
  }, i.prototype.draw = function(e, t, r, n) {
    this.drawElementsType(e ? 0 : 1, t, r, n);
  }, i.prototype.drawPointClouds = function(e, t, r) {
    this.drawArraysType(2, e, t, r);
  }, i.prototype.drawUnIndexed = function(e, t, r, n) {
    this.drawArraysType(e ? 0 : 1, t, r, n);
  }, i.prototype.drawElementsType = function(e, t, r, n) {
    this.applyStates(), this._reportDrawCall();
    var a = this._drawMode(e), s = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT, o = this._uintIndicesCurrentlySet ? 4 : 2;
    n ? this._gl.drawElementsInstanced(a, r, s, t * o, n) : this._gl.drawElements(a, r, s, t * o);
  }, i.prototype.drawArraysType = function(e, t, r, n) {
    this.applyStates(), this._reportDrawCall();
    var a = this._drawMode(e);
    n ? this._gl.drawArraysInstanced(a, t, r, n) : this._gl.drawArrays(a, t, r);
  }, i.prototype._drawMode = function(e) {
    switch (e) {
      case 0:
        return this._gl.TRIANGLES;
      case 2:
        return this._gl.POINTS;
      case 1:
        return this._gl.LINES;
      case 3:
        return this._gl.POINTS;
      case 4:
        return this._gl.LINES;
      case 5:
        return this._gl.LINE_LOOP;
      case 6:
        return this._gl.LINE_STRIP;
      case 7:
        return this._gl.TRIANGLE_STRIP;
      case 8:
        return this._gl.TRIANGLE_FAN;
      default:
        return this._gl.TRIANGLES;
    }
  }, i.prototype._reportDrawCall = function() {
  }, i.prototype._releaseEffect = function(e) {
    if (this._compiledEffects[e._key]) {
      delete this._compiledEffects[e._key];
      var t = e.getPipelineContext();
      t && this._deletePipelineContext(t);
    }
  }, i.prototype._deletePipelineContext = function(e) {
    var t = e;
    t && t.program && (t.program.__SPECTOR_rebuildProgram = null, this._gl.deleteProgram(t.program));
  }, i.prototype._getGlobalDefines = function(e) {
    if (e) {
      this.isNDCHalfZRange ? e.IS_NDC_HALF_ZRANGE = "" : delete e.IS_NDC_HALF_ZRANGE, this.useReverseDepthBuffer ? e.USE_REVERSE_DEPTHBUFFER = "" : delete e.USE_REVERSE_DEPTHBUFFER;
      return;
    } else {
      var t = "";
      return this.isNDCHalfZRange && (t += "#define IS_NDC_HALF_ZRANGE"), this.useReverseDepthBuffer && (t && (t += `
`), t += "#define USE_REVERSE_DEPTHBUFFER"), t;
    }
  }, i.prototype.createEffect = function(e, t, r, n, a, s, o, u, f, l) {
    var h;
    l === void 0 && (l = Ae.GLSL);
    var c = e.vertexElement || e.vertex || e.vertexToken || e.vertexSource || e, d = e.fragmentElement || e.fragment || e.fragmentToken || e.fragmentSource || e, p = this._getGlobalDefines(), g = (h = a != null ? a : t.defines) !== null && h !== void 0 ? h : "";
    p && (g += p);
    var _ = c + "+" + d + "@" + g;
    if (this._compiledEffects[_]) {
      var v = this._compiledEffects[_];
      return o && v.isReady() && o(v), v;
    }
    var y = new ze(e, t, r, n, this, a, s, o, u, f, _, l);
    return this._compiledEffects[_] = y, y;
  }, i._ConcatenateShader = function(e, t, r) {
    return r === void 0 && (r = ""), r + (t ? t + `
` : "") + e;
  }, i.prototype._compileShader = function(e, t, r, n) {
    return this._compileRawShader(i._ConcatenateShader(e, r, n), t);
  }, i.prototype._compileRawShader = function(e, t) {
    var r = this._gl, n = r.createShader(t === "vertex" ? r.VERTEX_SHADER : r.FRAGMENT_SHADER);
    if (!n) {
      for (var a = r.NO_ERROR, s = r.NO_ERROR; (s = r.getError()) !== r.NO_ERROR; )
        a = s;
      throw new Error("Something went wrong while creating a gl ".concat(t, " shader object. gl error=").concat(a, ", gl isContextLost=").concat(r.isContextLost(), ", _contextWasLost=").concat(this._contextWasLost));
    }
    return r.shaderSource(n, e), r.compileShader(n), n;
  }, i.prototype._getShaderSource = function(e) {
    return this._gl.getShaderSource(e);
  }, i.prototype.createRawShaderProgram = function(e, t, r, n, a) {
    a === void 0 && (a = null), n = n || this._gl;
    var s = this._compileRawShader(t, "vertex"), o = this._compileRawShader(r, "fragment");
    return this._createShaderProgram(e, s, o, n, a);
  }, i.prototype.createShaderProgram = function(e, t, r, n, a, s) {
    s === void 0 && (s = null), a = a || this._gl;
    var o = this._webGLVersion > 1 ? `#version 300 es
#define WEBGL2 
` : "", u = this._compileShader(t, "vertex", n, o), f = this._compileShader(r, "fragment", n, o);
    return this._createShaderProgram(e, u, f, a, s);
  }, i.prototype.inlineShaderCode = function(e) {
    return e;
  }, i.prototype.createPipelineContext = function(e) {
    var t = new Un();
    return t.engine = this, this._caps.parallelShaderCompile && (t.isParallelCompiled = !0), t;
  }, i.prototype.createMaterialContext = function() {
  }, i.prototype.createDrawContext = function() {
  }, i.prototype._createShaderProgram = function(e, t, r, n, a) {
    var s = n.createProgram();
    if (e.program = s, !s)
      throw new Error("Unable to create program");
    return n.attachShader(s, t), n.attachShader(s, r), n.linkProgram(s), e.context = n, e.vertexShader = t, e.fragmentShader = r, e.isParallelCompiled || this._finalizePipelineContext(e), s;
  }, i.prototype._finalizePipelineContext = function(e) {
    var t = e.context, r = e.vertexShader, n = e.fragmentShader, a = e.program, s = t.getProgramParameter(a, t.LINK_STATUS);
    if (!s) {
      if (!this._gl.getShaderParameter(r, this._gl.COMPILE_STATUS)) {
        var o = this._gl.getShaderInfoLog(r);
        if (o)
          throw e.vertexCompilationError = o, new Error("VERTEX SHADER " + o);
      }
      if (!this._gl.getShaderParameter(n, this._gl.COMPILE_STATUS)) {
        var o = this._gl.getShaderInfoLog(n);
        if (o)
          throw e.fragmentCompilationError = o, new Error("FRAGMENT SHADER " + o);
      }
      var u = t.getProgramInfoLog(a);
      if (u)
        throw e.programLinkError = u, new Error(u);
    }
    if (this.validateShaderPrograms) {
      t.validateProgram(a);
      var f = t.getProgramParameter(a, t.VALIDATE_STATUS);
      if (!f) {
        var u = t.getProgramInfoLog(a);
        if (u)
          throw e.programValidationError = u, new Error(u);
      }
    }
    t.deleteShader(r), t.deleteShader(n), e.vertexShader = void 0, e.fragmentShader = void 0, e.onCompiled && (e.onCompiled(), e.onCompiled = void 0);
  }, i.prototype._preparePipelineContext = function(e, t, r, n, a, s, o, u, f, l) {
    var h = e;
    n ? h.program = this.createRawShaderProgram(h, t, r, void 0, f) : h.program = this.createShaderProgram(h, t, r, u, void 0, f), h.program.__SPECTOR_rebuildProgram = o;
  }, i.prototype._isRenderingStateCompiled = function(e) {
    var t = e;
    return this._gl.getProgramParameter(t.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR) ? (this._finalizePipelineContext(t), !0) : !1;
  }, i.prototype._executeWhenRenderingStateIsCompiled = function(e, t) {
    var r = e;
    if (!r.isParallelCompiled) {
      t();
      return;
    }
    var n = r.onCompiled;
    n ? r.onCompiled = function() {
      n(), t();
    } : r.onCompiled = t;
  }, i.prototype.getUniforms = function(e, t) {
    for (var r = new Array(), n = e, a = 0; a < t.length; a++)
      r.push(this._gl.getUniformLocation(n.program, t[a]));
    return r;
  }, i.prototype.getAttributes = function(e, t) {
    for (var r = [], n = e, a = 0; a < t.length; a++)
      try {
        r.push(this._gl.getAttribLocation(n.program, t[a]));
      } catch {
        r.push(-1);
      }
    return r;
  }, i.prototype.enableEffect = function(e) {
    e = e !== null && sr.IsWrapper(e) ? e.effect : e, !(!e || e === this._currentEffect) && (this._stencilStateComposer.stencilMaterial = void 0, e = e, this.bindSamplers(e), this._currentEffect = e, e.onBind && e.onBind(e), e._onBindObservable && e._onBindObservable.notifyObservers(e));
  }, i.prototype.setInt = function(e, t) {
    return e ? (this._gl.uniform1i(e, t), !0) : !1;
  }, i.prototype.setInt2 = function(e, t, r) {
    return e ? (this._gl.uniform2i(e, t, r), !0) : !1;
  }, i.prototype.setInt3 = function(e, t, r, n) {
    return e ? (this._gl.uniform3i(e, t, r, n), !0) : !1;
  }, i.prototype.setInt4 = function(e, t, r, n, a) {
    return e ? (this._gl.uniform4i(e, t, r, n, a), !0) : !1;
  }, i.prototype.setIntArray = function(e, t) {
    return e ? (this._gl.uniform1iv(e, t), !0) : !1;
  }, i.prototype.setIntArray2 = function(e, t) {
    return !e || t.length % 2 !== 0 ? !1 : (this._gl.uniform2iv(e, t), !0);
  }, i.prototype.setIntArray3 = function(e, t) {
    return !e || t.length % 3 !== 0 ? !1 : (this._gl.uniform3iv(e, t), !0);
  }, i.prototype.setIntArray4 = function(e, t) {
    return !e || t.length % 4 !== 0 ? !1 : (this._gl.uniform4iv(e, t), !0);
  }, i.prototype.setArray = function(e, t) {
    return !e || t.length < 1 ? !1 : (this._gl.uniform1fv(e, t), !0);
  }, i.prototype.setArray2 = function(e, t) {
    return !e || t.length % 2 !== 0 ? !1 : (this._gl.uniform2fv(e, t), !0);
  }, i.prototype.setArray3 = function(e, t) {
    return !e || t.length % 3 !== 0 ? !1 : (this._gl.uniform3fv(e, t), !0);
  }, i.prototype.setArray4 = function(e, t) {
    return !e || t.length % 4 !== 0 ? !1 : (this._gl.uniform4fv(e, t), !0);
  }, i.prototype.setMatrices = function(e, t) {
    return e ? (this._gl.uniformMatrix4fv(e, !1, t), !0) : !1;
  }, i.prototype.setMatrix3x3 = function(e, t) {
    return e ? (this._gl.uniformMatrix3fv(e, !1, t), !0) : !1;
  }, i.prototype.setMatrix2x2 = function(e, t) {
    return e ? (this._gl.uniformMatrix2fv(e, !1, t), !0) : !1;
  }, i.prototype.setFloat = function(e, t) {
    return e ? (this._gl.uniform1f(e, t), !0) : !1;
  }, i.prototype.setFloat2 = function(e, t, r) {
    return e ? (this._gl.uniform2f(e, t, r), !0) : !1;
  }, i.prototype.setFloat3 = function(e, t, r, n) {
    return e ? (this._gl.uniform3f(e, t, r, n), !0) : !1;
  }, i.prototype.setFloat4 = function(e, t, r, n, a) {
    return e ? (this._gl.uniform4f(e, t, r, n, a), !0) : !1;
  }, i.prototype.applyStates = function() {
    if (this._depthCullingState.apply(this._gl), this._stencilStateComposer.apply(this._gl), this._alphaState.apply(this._gl), this._colorWriteChanged) {
      this._colorWriteChanged = !1;
      var e = this._colorWrite;
      this._gl.colorMask(e, e, e, e);
    }
  }, i.prototype.setColorWrite = function(e) {
    e !== this._colorWrite && (this._colorWriteChanged = !0, this._colorWrite = e);
  }, i.prototype.getColorWrite = function() {
    return this._colorWrite;
  }, Object.defineProperty(i.prototype, "depthCullingState", {
    get: function() {
      return this._depthCullingState;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "alphaState", {
    get: function() {
      return this._alphaState;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "stencilState", {
    get: function() {
      return this._stencilState;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "stencilStateComposer", {
    get: function() {
      return this._stencilStateComposer;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.clearInternalTexturesCache = function() {
    this._internalTexturesCache = [];
  }, i.prototype.wipeCaches = function(e) {
    this.preventCacheWipeBetweenFrames && !e || (this._currentEffect = null, this._viewportCached.x = 0, this._viewportCached.y = 0, this._viewportCached.z = 0, this._viewportCached.w = 0, this._unbindVertexArrayObject(), e && (this._currentProgram = null, this.resetTextureCache(), this._stencilStateComposer.reset(), this._depthCullingState.reset(), this._depthCullingState.depthFunc = this._gl.LEQUAL, this._alphaState.reset(), this._alphaMode = 1, this._alphaEquation = 0, this._colorWrite = !0, this._colorWriteChanged = !0, this._unpackFlipYCached = null, this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE), this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0), this._mustWipeVertexAttributes = !0, this.unbindAllAttributes()), this._resetVertexBufferBinding(), this._cachedIndexBuffer = null, this._cachedEffectForVertexBuffers = null, this.bindIndexBuffer(null));
  }, i.prototype._getSamplingParameters = function(e, t) {
    var r = this._gl, n = r.NEAREST, a = r.NEAREST;
    switch (e) {
      case 11:
        n = r.LINEAR, t ? a = r.LINEAR_MIPMAP_NEAREST : a = r.LINEAR;
        break;
      case 3:
        n = r.LINEAR, t ? a = r.LINEAR_MIPMAP_LINEAR : a = r.LINEAR;
        break;
      case 8:
        n = r.NEAREST, t ? a = r.NEAREST_MIPMAP_LINEAR : a = r.NEAREST;
        break;
      case 4:
        n = r.NEAREST, t ? a = r.NEAREST_MIPMAP_NEAREST : a = r.NEAREST;
        break;
      case 5:
        n = r.NEAREST, t ? a = r.LINEAR_MIPMAP_NEAREST : a = r.LINEAR;
        break;
      case 6:
        n = r.NEAREST, t ? a = r.LINEAR_MIPMAP_LINEAR : a = r.LINEAR;
        break;
      case 7:
        n = r.NEAREST, a = r.LINEAR;
        break;
      case 1:
        n = r.NEAREST, a = r.NEAREST;
        break;
      case 9:
        n = r.LINEAR, t ? a = r.NEAREST_MIPMAP_NEAREST : a = r.NEAREST;
        break;
      case 10:
        n = r.LINEAR, t ? a = r.NEAREST_MIPMAP_LINEAR : a = r.NEAREST;
        break;
      case 2:
        n = r.LINEAR, a = r.LINEAR;
        break;
      case 12:
        n = r.LINEAR, a = r.NEAREST;
        break;
    }
    return {
      min: a,
      mag: n
    };
  }, i.prototype._createTexture = function() {
    var e = this._gl.createTexture();
    if (!e)
      throw new Error("Unable to create texture");
    return e;
  }, i.prototype._createHardwareTexture = function() {
    return new en(this._createTexture(), this._gl);
  }, i.prototype._createInternalTexture = function(e, t, r, n) {
    n === void 0 && (n = ve.Unknown);
    var a = {};
    t !== void 0 && typeof t == "object" ? (a.generateMipMaps = t.generateMipMaps, a.type = t.type === void 0 ? 0 : t.type, a.samplingMode = t.samplingMode === void 0 ? 3 : t.samplingMode, a.format = t.format === void 0 ? 5 : t.format, a.useSRGBBuffer = t.useSRGBBuffer === void 0 ? !1 : t.useSRGBBuffer) : (a.generateMipMaps = t, a.type = 0, a.samplingMode = 3, a.format = 5, a.useSRGBBuffer = !1), a.useSRGBBuffer = a.useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU), (a.type === 1 && !this._caps.textureFloatLinearFiltering || a.type === 2 && !this._caps.textureHalfFloatLinearFiltering) && (a.samplingMode = 1), a.type === 1 && !this._caps.textureFloat && (a.type = 0, k.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE"));
    var s = this._gl, o = new Bt(this, n);
    o._useSRGBBuffer = !!a.useSRGBBuffer;
    var u = e.width || e, f = e.height || e, l = e.layers || 0, h = this._getSamplingParameters(a.samplingMode, !!a.generateMipMaps), c = l !== 0 ? s.TEXTURE_2D_ARRAY : s.TEXTURE_2D, d = this._getRGBABufferInternalSizedFormat(a.type, a.format, a.useSRGBBuffer), p = this._getInternalFormat(a.format), g = this._getWebGLTextureType(a.type);
    return this._bindTextureDirectly(c, o), l !== 0 ? (o.is2DArray = !0, s.texImage3D(c, 0, d, u, f, l, 0, p, g, null)) : s.texImage2D(c, 0, d, u, f, 0, p, g, null), s.texParameteri(c, s.TEXTURE_MAG_FILTER, h.mag), s.texParameteri(c, s.TEXTURE_MIN_FILTER, h.min), s.texParameteri(c, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(c, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), a.generateMipMaps && this._gl.generateMipmap(c), this._bindTextureDirectly(c, null), o.baseWidth = u, o.baseHeight = f, o.width = u, o.height = f, o.depth = l, o.isReady = !0, o.samples = 1, o.generateMipMaps = !!a.generateMipMaps, o.samplingMode = a.samplingMode, o.type = a.type, o.format = a.format, this._internalTexturesCache.push(o), o;
  }, i.prototype._getUseSRGBBuffer = function(e, t) {
    return e && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || t);
  }, i.prototype._createTextureBase = function(e, t, r, n, a, s, o, u, f, l, h, c, d, p, g, _) {
    var v = this;
    a === void 0 && (a = 3), s === void 0 && (s = null), o === void 0 && (o = null), l === void 0 && (l = null), h === void 0 && (h = null), c === void 0 && (c = null), d === void 0 && (d = null), e = e || "";
    var y = e.substr(0, 5) === "data:", E = e.substr(0, 5) === "blob:", R = y && e.indexOf(";base64,") !== -1, M = h || new Bt(this, ve.Url), C = e;
    this._transformTextureUrl && !R && !h && !l && (e = this._transformTextureUrl(e)), C !== e && (M._originalUrl = C);
    var A = e.lastIndexOf("."), S = d || (A > -1 ? e.substring(A).toLowerCase() : ""), w = null, F = S.indexOf("?");
    F > -1 && (S = S.split("?")[0]);
    for (var x = 0, z = i._TextureLoaders; x < z.length; x++) {
      var W = z[x];
      if (W.canLoad(S, p)) {
        w = W;
        break;
      }
    }
    n && n._addPendingData(M), M.url = e, M.generateMipMaps = !t, M.samplingMode = a, M.invertY = r, M._useSRGBBuffer = this._getUseSRGBBuffer(!!_, t), this._doNotHandleContextLost || (M._buffer = l);
    var N = null;
    s && !h && (N = M.onLoadedObservable.add(s)), h || this._internalTexturesCache.push(M);
    var Z = function(Y, H) {
      n && n._removePendingData(M), e === C ? (N && M.onLoadedObservable.remove(N), re.UseFallbackTexture && v._createTextureBase(re.FallbackTexture, t, M.invertY, n, a, null, o, u, f, l, M), Y = (Y || "Unknown error") + (re.UseFallbackTexture ? " - Fallback texture was used" : ""), M.onErrorObservable.notifyObservers({ message: Y, exception: H }), o && o(Y, H)) : (k.Warn("Failed to load ".concat(e, ", falling back to ").concat(C)), v._createTextureBase(C, t, M.invertY, n, a, s, o, u, f, l, M, c, d, p, g, _));
    };
    if (w) {
      var q = function(Y) {
        w.loadData(Y, M, function(H, se, Se, Be, Ge, Dt) {
          Dt ? Z("TextureLoader failed to load data") : u(M, S, n, { width: H, height: se }, M.invertY, !Se, Be, function() {
            return Ge(), !1;
          }, a);
        }, g);
      };
      l ? l instanceof ArrayBuffer ? q(new Uint8Array(l)) : ArrayBuffer.isView(l) ? q(l) : o && o("Unable to load: only ArrayBuffer or ArrayBufferView is supported", null) : this._loadFile(e, function(Y) {
        return q(new Uint8Array(Y));
      }, void 0, n ? n.offlineProvider : void 0, !0, function(Y, H) {
        Z("Unable to load " + (Y && Y.responseURL, H));
      });
    } else {
      var ae = function(Y) {
        E && !v._doNotHandleContextLost && (M._buffer = Y), u(M, S, n, Y, M.invertY, t, !1, f, a);
      };
      !y || R ? l && (typeof l.decoding == "string" || l.close) ? ae(l) : i._FileToolsLoadImage(e, ae, Z, n ? n.offlineProvider : null, p, M.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0) : typeof l == "string" || l instanceof ArrayBuffer || ArrayBuffer.isView(l) || l instanceof Blob ? i._FileToolsLoadImage(l, ae, Z, n ? n.offlineProvider : null, p, M.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0) : l && ae(l);
    }
    return M;
  }, i.prototype.createTexture = function(e, t, r, n, a, s, o, u, f, l, h, c, d, p, g) {
    var _ = this;
    return a === void 0 && (a = 3), s === void 0 && (s = null), o === void 0 && (o = null), u === void 0 && (u = null), f === void 0 && (f = null), l === void 0 && (l = null), h === void 0 && (h = null), this._createTextureBase(e, t, r, n, a, s, o, this._prepareWebGLTexture.bind(this), function(v, y, E, R, M, C) {
      var A = _._gl, S = E.width === v && E.height === y, w = l ? _._getInternalFormat(l, M._useSRGBBuffer) : R === ".jpg" && !M._useSRGBBuffer ? A.RGB : M._useSRGBBuffer ? A.SRGB8_ALPHA8 : A.RGBA, F = l ? _._getInternalFormat(l) : R === ".jpg" && !M._useSRGBBuffer ? A.RGB : A.RGBA;
      if (M._useSRGBBuffer && _.webGLVersion === 1 && (F = w), S)
        return A.texImage2D(A.TEXTURE_2D, 0, w, F, A.UNSIGNED_BYTE, E), !1;
      var x = _._caps.maxTextureSize;
      if (E.width > x || E.height > x || !_._supportsHardwareTextureRescaling)
        return _._prepareWorkingCanvas(), !_._workingCanvas || !_._workingContext || (_._workingCanvas.width = v, _._workingCanvas.height = y, _._workingContext.drawImage(E, 0, 0, E.width, E.height, 0, 0, v, y), A.texImage2D(A.TEXTURE_2D, 0, w, F, A.UNSIGNED_BYTE, _._workingCanvas), M.width = v, M.height = y), !1;
      var z = new Bt(_, ve.Temp);
      return _._bindTextureDirectly(A.TEXTURE_2D, z, !0), A.texImage2D(A.TEXTURE_2D, 0, w, F, A.UNSIGNED_BYTE, E), _._rescaleTexture(z, M, n, w, function() {
        _._releaseTexture(z), _._bindTextureDirectly(A.TEXTURE_2D, M, !0), C();
      }), !0;
    }, u, f, l, h, c, d, g);
  }, i._FileToolsLoadImage = function(e, t, r, n, a, s) {
    throw G("FileTools");
  }, i.prototype._rescaleTexture = function(e, t, r, n, a) {
  }, i.prototype.createRawTexture = function(e, t, r, n, a, s, o, u, f, l, h) {
    throw G("Engine.RawTexture");
  }, i.prototype.createRawCubeTexture = function(e, t, r, n, a, s, o, u) {
    throw G("Engine.RawTexture");
  }, i.prototype.createRawTexture3D = function(e, t, r, n, a, s, o, u, f, l) {
    throw G("Engine.RawTexture");
  }, i.prototype.createRawTexture2DArray = function(e, t, r, n, a, s, o, u, f, l) {
    throw G("Engine.RawTexture");
  }, i.prototype._unpackFlipY = function(e) {
    this._unpackFlipYCached !== e && (this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, e ? 1 : 0), this.enableUnpackFlipYCached && (this._unpackFlipYCached = e));
  }, i.prototype._getUnpackAlignement = function() {
    return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);
  }, i.prototype._getTextureTarget = function(e) {
    return e.isCube ? this._gl.TEXTURE_CUBE_MAP : e.is3D ? this._gl.TEXTURE_3D : e.is2DArray || e.isMultiview ? this._gl.TEXTURE_2D_ARRAY : this._gl.TEXTURE_2D;
  }, i.prototype.updateTextureSamplingMode = function(e, t, r) {
    r === void 0 && (r = !1);
    var n = this._getTextureTarget(t), a = this._getSamplingParameters(e, t.generateMipMaps || r);
    this._setTextureParameterInteger(n, this._gl.TEXTURE_MAG_FILTER, a.mag, t), this._setTextureParameterInteger(n, this._gl.TEXTURE_MIN_FILTER, a.min), r && (t.generateMipMaps = !0, this._gl.generateMipmap(n)), this._bindTextureDirectly(n, null), t.samplingMode = e;
  }, i.prototype.updateTextureDimensions = function(e, t, r, n) {
  }, i.prototype.updateTextureWrappingMode = function(e, t, r, n) {
    r === void 0 && (r = null), n === void 0 && (n = null);
    var a = this._getTextureTarget(e);
    t !== null && (this._setTextureParameterInteger(a, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t), e), e._cachedWrapU = t), r !== null && (this._setTextureParameterInteger(a, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(r), e), e._cachedWrapV = r), (e.is2DArray || e.is3D) && n !== null && (this._setTextureParameterInteger(a, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(n), e), e._cachedWrapR = n), this._bindTextureDirectly(a, null);
  }, i.prototype._setupDepthStencilTexture = function(e, t, r, n, a, s) {
    s === void 0 && (s = 1);
    var o = t.width || t, u = t.height || t, f = t.layers || 0;
    e.baseWidth = o, e.baseHeight = u, e.width = o, e.height = u, e.is2DArray = f > 0, e.depth = f, e.isReady = !0, e.samples = s, e.generateMipMaps = !1, e.samplingMode = n ? 2 : 1, e.type = 0, e._comparisonFunction = a;
    var l = this._gl, h = this._getTextureTarget(e), c = this._getSamplingParameters(e.samplingMode, !1);
    l.texParameteri(h, l.TEXTURE_MAG_FILTER, c.mag), l.texParameteri(h, l.TEXTURE_MIN_FILTER, c.min), l.texParameteri(h, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(h, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), a === 0 ? (l.texParameteri(h, l.TEXTURE_COMPARE_FUNC, 515), l.texParameteri(h, l.TEXTURE_COMPARE_MODE, l.NONE)) : (l.texParameteri(h, l.TEXTURE_COMPARE_FUNC, a), l.texParameteri(h, l.TEXTURE_COMPARE_MODE, l.COMPARE_REF_TO_TEXTURE));
  }, i.prototype._uploadCompressedDataToTextureDirectly = function(e, t, r, n, a, s, o) {
    s === void 0 && (s = 0), o === void 0 && (o = 0);
    var u = this._gl, f = u.TEXTURE_2D;
    if (e.isCube && (f = u.TEXTURE_CUBE_MAP_POSITIVE_X + s), e._useSRGBBuffer)
      switch (t) {
        case 37492:
        case 36196:
          this._caps.etc2 ? t = u.COMPRESSED_SRGB8_ETC2 : e._useSRGBBuffer = !1;
          break;
        case 37496:
          this._caps.etc2 ? t = u.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : e._useSRGBBuffer = !1;
          break;
        case 36492:
          t = u.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
          break;
        case 37808:
          t = u.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
          break;
        case 33776:
          this._caps.s3tc_srgb ? t = u.COMPRESSED_SRGB_S3TC_DXT1_EXT : e._useSRGBBuffer = !1;
          break;
        case 33777:
          this._caps.s3tc_srgb ? t = u.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT : e._useSRGBBuffer = !1;
          break;
        case 33779:
          this._caps.s3tc_srgb ? t = u.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT : e._useSRGBBuffer = !1;
          break;
        default:
          e._useSRGBBuffer = !1;
          break;
      }
    this._gl.compressedTexImage2D(f, o, t, r, n, 0, a);
  }, i.prototype._uploadDataToTextureDirectly = function(e, t, r, n, a, s) {
    r === void 0 && (r = 0), n === void 0 && (n = 0), s === void 0 && (s = !1);
    var o = this._gl, u = this._getWebGLTextureType(e.type), f = this._getInternalFormat(e.format), l = a === void 0 ? this._getRGBABufferInternalSizedFormat(e.type, e.format, e._useSRGBBuffer) : this._getInternalFormat(a, e._useSRGBBuffer);
    this._unpackFlipY(e.invertY);
    var h = o.TEXTURE_2D;
    e.isCube && (h = o.TEXTURE_CUBE_MAP_POSITIVE_X + r);
    var c = Math.round(Math.log(e.width) * Math.LOG2E), d = Math.round(Math.log(e.height) * Math.LOG2E), p = s ? e.width : Math.pow(2, Math.max(c - n, 0)), g = s ? e.height : Math.pow(2, Math.max(d - n, 0));
    o.texImage2D(h, n, l, p, g, 0, f, u, t);
  }, i.prototype.updateTextureData = function(e, t, r, n, a, s, o, u, f) {
    o === void 0 && (o = 0), u === void 0 && (u = 0), f === void 0 && (f = !1);
    var l = this._gl, h = this._getWebGLTextureType(e.type), c = this._getInternalFormat(e.format);
    this._unpackFlipY(e.invertY);
    var d = l.TEXTURE_2D;
    e.isCube && (d = l.TEXTURE_CUBE_MAP_POSITIVE_X + o), this._bindTextureDirectly(d, e, !0), l.texSubImage2D(d, u, r, n, a, s, c, h, t), f && this._gl.generateMipmap(d), this._bindTextureDirectly(d, null);
  }, i.prototype._uploadArrayBufferViewToTexture = function(e, t, r, n) {
    r === void 0 && (r = 0), n === void 0 && (n = 0);
    var a = this._gl, s = e.isCube ? a.TEXTURE_CUBE_MAP : a.TEXTURE_2D;
    this._bindTextureDirectly(s, e, !0), this._uploadDataToTextureDirectly(e, t, r, n), this._bindTextureDirectly(s, null, !0);
  }, i.prototype._prepareWebGLTextureContinuation = function(e, t, r, n, a) {
    var s = this._gl;
    if (!!s) {
      var o = this._getSamplingParameters(a, !r);
      s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, o.mag), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, o.min), !r && !n && s.generateMipmap(s.TEXTURE_2D), this._bindTextureDirectly(s.TEXTURE_2D, null), t && t._removePendingData(e), e.onLoadedObservable.notifyObservers(e), e.onLoadedObservable.clear();
    }
  }, i.prototype._prepareWebGLTexture = function(e, t, r, n, a, s, o, u, f) {
    var l = this;
    f === void 0 && (f = 3);
    var h = this.getCaps().maxTextureSize, c = Math.min(h, this.needPOTTextures ? i.GetExponentOfTwo(n.width, h) : n.width), d = Math.min(h, this.needPOTTextures ? i.GetExponentOfTwo(n.height, h) : n.height), p = this._gl;
    if (!!p) {
      if (!e._hardwareTexture) {
        r && r._removePendingData(e);
        return;
      }
      this._bindTextureDirectly(p.TEXTURE_2D, e, !0), this._unpackFlipY(a === void 0 ? !0 : !!a), e.baseWidth = n.width, e.baseHeight = n.height, e.width = c, e.height = d, e.isReady = !0, !u(c, d, n, t, e, function() {
        l._prepareWebGLTextureContinuation(e, r, s, o, f);
      }) && this._prepareWebGLTextureContinuation(e, r, s, o, f);
    }
  }, i.prototype._setupFramebufferDepthAttachments = function(e, t, r, n, a) {
    a === void 0 && (a = 1);
    var s = this._gl;
    if (e && t)
      return this._createRenderBuffer(r, n, a, s.DEPTH_STENCIL, s.DEPTH24_STENCIL8, s.DEPTH_STENCIL_ATTACHMENT);
    if (t) {
      var o = s.DEPTH_COMPONENT16;
      return this._webGLVersion > 1 && (o = s.DEPTH_COMPONENT32F), this._createRenderBuffer(r, n, a, o, o, s.DEPTH_ATTACHMENT);
    }
    return e ? this._createRenderBuffer(r, n, a, s.STENCIL_INDEX8, s.STENCIL_INDEX8, s.STENCIL_ATTACHMENT) : null;
  }, i.prototype._createRenderBuffer = function(e, t, r, n, a, s, o) {
    o === void 0 && (o = !0);
    var u = this._gl, f = u.createRenderbuffer();
    return u.bindRenderbuffer(u.RENDERBUFFER, f), r > 1 && u.renderbufferStorageMultisample ? u.renderbufferStorageMultisample(u.RENDERBUFFER, r, a, e, t) : u.renderbufferStorage(u.RENDERBUFFER, n, e, t), u.framebufferRenderbuffer(u.FRAMEBUFFER, s, u.RENDERBUFFER, f), o && u.bindRenderbuffer(u.RENDERBUFFER, null), f;
  }, i.prototype._releaseTexture = function(e) {
    var t;
    this._deleteTexture((t = e._hardwareTexture) === null || t === void 0 ? void 0 : t.underlyingResource), this.unbindAllTextures();
    var r = this._internalTexturesCache.indexOf(e);
    r !== -1 && this._internalTexturesCache.splice(r, 1), e._lodTextureHigh && e._lodTextureHigh.dispose(), e._lodTextureMid && e._lodTextureMid.dispose(), e._lodTextureLow && e._lodTextureLow.dispose(), e._irradianceTexture && e._irradianceTexture.dispose();
  }, i.prototype._releaseRenderTargetWrapper = function(e) {
    var t = this._renderTargetWrapperCache.indexOf(e);
    t !== -1 && this._renderTargetWrapperCache.splice(t, 1);
  }, i.prototype._deleteTexture = function(e) {
    e && this._gl.deleteTexture(e);
  }, i.prototype._setProgram = function(e) {
    this._currentProgram !== e && (this._gl.useProgram(e), this._currentProgram = e);
  }, i.prototype.bindSamplers = function(e) {
    var t = e.getPipelineContext();
    this._setProgram(t.program);
    for (var r = e.getSamplers(), n = 0; n < r.length; n++) {
      var a = e.getUniform(r[n]);
      a && (this._boundUniforms[n] = a);
    }
    this._currentEffect = null;
  }, i.prototype._activateCurrentTexture = function() {
    this._currentTextureChannel !== this._activeChannel && (this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel), this._currentTextureChannel = this._activeChannel);
  }, i.prototype._bindTextureDirectly = function(e, t, r, n) {
    var a, s;
    r === void 0 && (r = !1), n === void 0 && (n = !1);
    var o = !1, u = t && t._associatedChannel > -1;
    r && u && (this._activeChannel = t._associatedChannel);
    var f = this._boundTexturesCache[this._activeChannel];
    if (f !== t || n) {
      if (this._activateCurrentTexture(), t && t.isMultiview)
        throw console.error(e, t), "_bindTextureDirectly called with a multiview texture!";
      this._gl.bindTexture(e, (s = (a = t == null ? void 0 : t._hardwareTexture) === null || a === void 0 ? void 0 : a.underlyingResource) !== null && s !== void 0 ? s : null), this._boundTexturesCache[this._activeChannel] = t, t && (t._associatedChannel = this._activeChannel);
    } else
      r && (o = !0, this._activateCurrentTexture());
    return u && !r && this._bindSamplerUniformToChannel(t._associatedChannel, this._activeChannel), o;
  }, i.prototype._bindTexture = function(e, t, r) {
    if (e !== void 0) {
      t && (t._associatedChannel = e), this._activeChannel = e;
      var n = t ? this._getTextureTarget(t) : this._gl.TEXTURE_2D;
      this._bindTextureDirectly(n, t);
    }
  }, i.prototype.unbindAllTextures = function() {
    for (var e = 0; e < this._maxSimultaneousTextures; e++)
      this._activeChannel = e, this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), this.webGLVersion > 1 && (this._bindTextureDirectly(this._gl.TEXTURE_3D, null), this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null));
  }, i.prototype.setTexture = function(e, t, r, n) {
    e !== void 0 && (t && (this._boundUniforms[e] = t), this._setTexture(e, r));
  }, i.prototype._bindSamplerUniformToChannel = function(e, t) {
    var r = this._boundUniforms[e];
    !r || r._currentState === t || (this._gl.uniform1i(r, t), r._currentState = t);
  }, i.prototype._getTextureWrapMode = function(e) {
    switch (e) {
      case 1:
        return this._gl.REPEAT;
      case 0:
        return this._gl.CLAMP_TO_EDGE;
      case 2:
        return this._gl.MIRRORED_REPEAT;
    }
    return this._gl.REPEAT;
  }, i.prototype._setTexture = function(e, t, r, n, a) {
    if (r === void 0 && (r = !1), n === void 0 && (n = !1), !t)
      return this._boundTexturesCache[e] != null && (this._activeChannel = e, this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), this.webGLVersion > 1 && (this._bindTextureDirectly(this._gl.TEXTURE_3D, null), this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null))), !1;
    if (t.video)
      this._activeChannel = e, t.update();
    else if (t.delayLoadState === 4)
      return t.delayLoad(), !1;
    var s;
    n ? s = t.depthStencilTexture : t.isReady() ? s = t.getInternalTexture() : t.isCube ? s = this.emptyCubeTexture : t.is3D ? s = this.emptyTexture3D : t.is2DArray ? s = this.emptyTexture2DArray : s = this.emptyTexture, !r && s && (s._associatedChannel = e);
    var o = !0;
    this._boundTexturesCache[e] === s && (r || this._bindSamplerUniformToChannel(s._associatedChannel, e), o = !1), this._activeChannel = e;
    var u = this._getTextureTarget(s);
    if (o && this._bindTextureDirectly(u, s, r), s && !s.isMultiview) {
      if (s.isCube && s._cachedCoordinatesMode !== t.coordinatesMode) {
        s._cachedCoordinatesMode = t.coordinatesMode;
        var f = t.coordinatesMode !== 3 && t.coordinatesMode !== 5 ? 1 : 0;
        t.wrapU = f, t.wrapV = f;
      }
      s._cachedWrapU !== t.wrapU && (s._cachedWrapU = t.wrapU, this._setTextureParameterInteger(u, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t.wrapU), s)), s._cachedWrapV !== t.wrapV && (s._cachedWrapV = t.wrapV, this._setTextureParameterInteger(u, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(t.wrapV), s)), s.is3D && s._cachedWrapR !== t.wrapR && (s._cachedWrapR = t.wrapR, this._setTextureParameterInteger(u, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(t.wrapR), s)), this._setAnisotropicLevel(u, s, t.anisotropicFilteringLevel);
    }
    return !0;
  }, i.prototype.setTextureArray = function(e, t, r, n) {
    if (!(e === void 0 || !t)) {
      (!this._textureUnits || this._textureUnits.length !== r.length) && (this._textureUnits = new Int32Array(r.length));
      for (var a = 0; a < r.length; a++) {
        var s = r[a].getInternalTexture();
        s ? (this._textureUnits[a] = e + a, s._associatedChannel = e + a) : this._textureUnits[a] = -1;
      }
      this._gl.uniform1iv(t, this._textureUnits);
      for (var o = 0; o < r.length; o++)
        this._setTexture(this._textureUnits[o], r[o], !0);
    }
  }, i.prototype._setAnisotropicLevel = function(e, t, r) {
    var n = this._caps.textureAnisotropicFilterExtension;
    t.samplingMode !== 11 && t.samplingMode !== 3 && t.samplingMode !== 2 && (r = 1), n && t._cachedAnisotropicFilteringLevel !== r && (this._setTextureParameterFloat(e, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(r, this._caps.maxAnisotropy), t), t._cachedAnisotropicFilteringLevel = r);
  }, i.prototype._setTextureParameterFloat = function(e, t, r, n) {
    this._bindTextureDirectly(e, n, !0, !0), this._gl.texParameterf(e, t, r);
  }, i.prototype._setTextureParameterInteger = function(e, t, r, n) {
    n && this._bindTextureDirectly(e, n, !0, !0), this._gl.texParameteri(e, t, r);
  }, i.prototype.unbindAllAttributes = function() {
    if (this._mustWipeVertexAttributes) {
      this._mustWipeVertexAttributes = !1;
      for (var e = 0; e < this._caps.maxVertexAttribs; e++)
        this.disableAttributeByIndex(e);
      return;
    }
    for (var e = 0, t = this._vertexAttribArraysEnabled.length; e < t; e++)
      e >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[e] || this.disableAttributeByIndex(e);
  }, i.prototype.releaseEffects = function() {
    for (var e in this._compiledEffects) {
      var t = this._compiledEffects[e].getPipelineContext();
      this._deletePipelineContext(t);
    }
    this._compiledEffects = {};
  }, i.prototype.dispose = function() {
    var e;
    this.stopRenderLoop(), this.onBeforeTextureInitObservable && this.onBeforeTextureInitObservable.clear(), this._emptyTexture && (this._releaseTexture(this._emptyTexture), this._emptyTexture = null), this._emptyCubeTexture && (this._releaseTexture(this._emptyCubeTexture), this._emptyCubeTexture = null), this._dummyFramebuffer && this._gl.deleteFramebuffer(this._dummyFramebuffer), this.releaseEffects(), (e = this.releaseComputeEffects) === null || e === void 0 || e.call(this), this.unbindAllAttributes(), this._boundUniforms = [], me() && this._renderingCanvas && (this._doNotHandleContextLost || (this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost), this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored)), window.removeEventListener("resize", this._checkForMobile)), this._workingCanvas = null, this._workingContext = null, this._currentBufferPointers = [], this._renderingCanvas = null, this._currentProgram = null, this._boundRenderFunction = null, ze.ResetCache();
    for (var t = 0, r = this._activeRequests; t < r.length; t++) {
      var n = r[t];
      n.abort();
    }
    this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear();
  }, i.prototype.attachContextLostEvent = function(e) {
    this._renderingCanvas && this._renderingCanvas.addEventListener("webglcontextlost", e, !1);
  }, i.prototype.attachContextRestoredEvent = function(e) {
    this._renderingCanvas && this._renderingCanvas.addEventListener("webglcontextrestored", e, !1);
  }, i.prototype.getError = function() {
    return this._gl.getError();
  }, i.prototype._canRenderToFloatFramebuffer = function() {
    return this._webGLVersion > 1 ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(1);
  }, i.prototype._canRenderToHalfFloatFramebuffer = function() {
    return this._webGLVersion > 1 ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(2);
  }, i.prototype._canRenderToFramebuffer = function(e) {
    for (var t = this._gl; t.getError() !== t.NO_ERROR; )
      ;
    var r = !0, n = t.createTexture();
    t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(e), 1, 1, 0, t.RGBA, this._getWebGLTextureType(e), null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST);
    var a = t.createFramebuffer();
    t.bindFramebuffer(t.FRAMEBUFFER, a), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);
    var s = t.checkFramebufferStatus(t.FRAMEBUFFER);
    if (r = r && s === t.FRAMEBUFFER_COMPLETE, r = r && t.getError() === t.NO_ERROR, r && (t.clear(t.COLOR_BUFFER_BIT), r = r && t.getError() === t.NO_ERROR), r) {
      t.bindFramebuffer(t.FRAMEBUFFER, null);
      var o = t.RGBA, u = t.UNSIGNED_BYTE, f = new Uint8Array(4);
      t.readPixels(0, 0, 1, 1, o, u, f), r = r && t.getError() === t.NO_ERROR;
    }
    for (t.deleteTexture(n), t.deleteFramebuffer(a), t.bindFramebuffer(t.FRAMEBUFFER, null); !r && t.getError() !== t.NO_ERROR; )
      ;
    return r;
  }, i.prototype._getWebGLTextureType = function(e) {
    if (this._webGLVersion === 1) {
      switch (e) {
        case 1:
          return this._gl.FLOAT;
        case 2:
          return this._gl.HALF_FLOAT_OES;
        case 0:
          return this._gl.UNSIGNED_BYTE;
        case 8:
          return this._gl.UNSIGNED_SHORT_4_4_4_4;
        case 9:
          return this._gl.UNSIGNED_SHORT_5_5_5_1;
        case 10:
          return this._gl.UNSIGNED_SHORT_5_6_5;
      }
      return this._gl.UNSIGNED_BYTE;
    }
    switch (e) {
      case 3:
        return this._gl.BYTE;
      case 0:
        return this._gl.UNSIGNED_BYTE;
      case 4:
        return this._gl.SHORT;
      case 5:
        return this._gl.UNSIGNED_SHORT;
      case 6:
        return this._gl.INT;
      case 7:
        return this._gl.UNSIGNED_INT;
      case 1:
        return this._gl.FLOAT;
      case 2:
        return this._gl.HALF_FLOAT;
      case 8:
        return this._gl.UNSIGNED_SHORT_4_4_4_4;
      case 9:
        return this._gl.UNSIGNED_SHORT_5_5_5_1;
      case 10:
        return this._gl.UNSIGNED_SHORT_5_6_5;
      case 11:
        return this._gl.UNSIGNED_INT_2_10_10_10_REV;
      case 12:
        return this._gl.UNSIGNED_INT_24_8;
      case 13:
        return this._gl.UNSIGNED_INT_10F_11F_11F_REV;
      case 14:
        return this._gl.UNSIGNED_INT_5_9_9_9_REV;
      case 15:
        return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
    }
    return this._gl.UNSIGNED_BYTE;
  }, i.prototype._getInternalFormat = function(e, t) {
    t === void 0 && (t = !1);
    var r = t ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
    switch (e) {
      case 0:
        r = this._gl.ALPHA;
        break;
      case 1:
        r = this._gl.LUMINANCE;
        break;
      case 2:
        r = this._gl.LUMINANCE_ALPHA;
        break;
      case 6:
        r = this._gl.RED;
        break;
      case 7:
        r = this._gl.RG;
        break;
      case 4:
        r = t ? this._gl.SRGB : this._gl.RGB;
        break;
      case 5:
        r = t ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
        break;
    }
    if (this._webGLVersion > 1)
      switch (e) {
        case 8:
          r = this._gl.RED_INTEGER;
          break;
        case 9:
          r = this._gl.RG_INTEGER;
          break;
        case 10:
          r = this._gl.RGB_INTEGER;
          break;
        case 11:
          r = this._gl.RGBA_INTEGER;
          break;
      }
    return r;
  }, i.prototype._getRGBABufferInternalSizedFormat = function(e, t, r) {
    if (r === void 0 && (r = !1), this._webGLVersion === 1) {
      if (t !== void 0)
        switch (t) {
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          case 4:
            return r ? this._gl.SRGB : this._gl.RGB;
        }
      return this._gl.RGBA;
    }
    switch (e) {
      case 3:
        switch (t) {
          case 6:
            return this._gl.R8_SNORM;
          case 7:
            return this._gl.RG8_SNORM;
          case 4:
            return this._gl.RGB8_SNORM;
          case 8:
            return this._gl.R8I;
          case 9:
            return this._gl.RG8I;
          case 10:
            return this._gl.RGB8I;
          case 11:
            return this._gl.RGBA8I;
          default:
            return this._gl.RGBA8_SNORM;
        }
      case 0:
        switch (t) {
          case 6:
            return this._gl.R8;
          case 7:
            return this._gl.RG8;
          case 4:
            return r ? this._gl.SRGB8 : this._gl.RGB8;
          case 5:
            return r ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
          case 8:
            return this._gl.R8UI;
          case 9:
            return this._gl.RG8UI;
          case 10:
            return this._gl.RGB8UI;
          case 11:
            return this._gl.RGBA8UI;
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          default:
            return this._gl.RGBA8;
        }
      case 4:
        switch (t) {
          case 8:
            return this._gl.R16I;
          case 9:
            return this._gl.RG16I;
          case 10:
            return this._gl.RGB16I;
          case 11:
            return this._gl.RGBA16I;
          default:
            return this._gl.RGBA16I;
        }
      case 5:
        switch (t) {
          case 8:
            return this._gl.R16UI;
          case 9:
            return this._gl.RG16UI;
          case 10:
            return this._gl.RGB16UI;
          case 11:
            return this._gl.RGBA16UI;
          default:
            return this._gl.RGBA16UI;
        }
      case 6:
        switch (t) {
          case 8:
            return this._gl.R32I;
          case 9:
            return this._gl.RG32I;
          case 10:
            return this._gl.RGB32I;
          case 11:
            return this._gl.RGBA32I;
          default:
            return this._gl.RGBA32I;
        }
      case 7:
        switch (t) {
          case 8:
            return this._gl.R32UI;
          case 9:
            return this._gl.RG32UI;
          case 10:
            return this._gl.RGB32UI;
          case 11:
            return this._gl.RGBA32UI;
          default:
            return this._gl.RGBA32UI;
        }
      case 1:
        switch (t) {
          case 6:
            return this._gl.R32F;
          case 7:
            return this._gl.RG32F;
          case 4:
            return this._gl.RGB32F;
          case 5:
            return this._gl.RGBA32F;
          default:
            return this._gl.RGBA32F;
        }
      case 2:
        switch (t) {
          case 6:
            return this._gl.R16F;
          case 7:
            return this._gl.RG16F;
          case 4:
            return this._gl.RGB16F;
          case 5:
            return this._gl.RGBA16F;
          default:
            return this._gl.RGBA16F;
        }
      case 10:
        return this._gl.RGB565;
      case 13:
        return this._gl.R11F_G11F_B10F;
      case 14:
        return this._gl.RGB9_E5;
      case 8:
        return this._gl.RGBA4;
      case 9:
        return this._gl.RGB5_A1;
      case 11:
        switch (t) {
          case 5:
            return this._gl.RGB10_A2;
          case 11:
            return this._gl.RGB10_A2UI;
          default:
            return this._gl.RGB10_A2;
        }
    }
    return r ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
  }, i.prototype._getRGBAMultiSampleBufferFormat = function(e) {
    return e === 1 ? this._gl.RGBA32F : e === 2 ? this._gl.RGBA16F : this._gl.RGBA8;
  }, i.prototype._loadFile = function(e, t, r, n, a, s) {
    var o = this, u = i._FileToolsLoadFile(e, t, r, n, a, s);
    return this._activeRequests.push(u), u.onCompleteObservable.add(function(f) {
      o._activeRequests.splice(o._activeRequests.indexOf(f), 1);
    }), u;
  }, i._FileToolsLoadFile = function(e, t, r, n, a, s) {
    throw G("FileTools");
  }, i.prototype.readPixels = function(e, t, r, n, a, s) {
    a === void 0 && (a = !0), s === void 0 && (s = !0);
    var o = a ? 4 : 3, u = a ? this._gl.RGBA : this._gl.RGB, f = new Uint8Array(n * r * o);
    return s && this.flushFramebuffer(), this._gl.readPixels(e, t, r, n, u, this._gl.UNSIGNED_BYTE, f), Promise.resolve(f);
  }, Object.defineProperty(i, "IsSupportedAsync", {
    get: function() {
      return Promise.resolve(this.isSupported());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "IsSupported", {
    get: function() {
      return this.isSupported();
    },
    enumerable: !1,
    configurable: !0
  }), i.isSupported = function() {
    if (this._HasMajorPerformanceCaveat !== null)
      return !this._HasMajorPerformanceCaveat;
    if (this._IsSupported === null)
      try {
        var e = this._CreateCanvas(1, 1), t = e.getContext("webgl") || e.getContext("experimental-webgl");
        this._IsSupported = t != null && !!window.WebGLRenderingContext;
      } catch {
        this._IsSupported = !1;
      }
    return this._IsSupported;
  }, Object.defineProperty(i, "HasMajorPerformanceCaveat", {
    get: function() {
      if (this._HasMajorPerformanceCaveat === null)
        try {
          var e = this._CreateCanvas(1, 1), t = e.getContext("webgl", { failIfMajorPerformanceCaveat: !0 }) || e.getContext("experimental-webgl", { failIfMajorPerformanceCaveat: !0 });
          this._HasMajorPerformanceCaveat = !t;
        } catch {
          this._HasMajorPerformanceCaveat = !1;
        }
      return this._HasMajorPerformanceCaveat;
    },
    enumerable: !1,
    configurable: !0
  }), i.CeilingPOT = function(e) {
    return e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, e++, e;
  }, i.FloorPOT = function(e) {
    return e = e | e >> 1, e = e | e >> 2, e = e | e >> 4, e = e | e >> 8, e = e | e >> 16, e - (e >> 1);
  }, i.NearestPOT = function(e) {
    var t = i.CeilingPOT(e), r = i.FloorPOT(e);
    return t - e > e - r ? r : t;
  }, i.GetExponentOfTwo = function(e, t, r) {
    r === void 0 && (r = 2);
    var n;
    switch (r) {
      case 1:
        n = i.FloorPOT(e);
        break;
      case 2:
        n = i.NearestPOT(e);
        break;
      case 3:
      default:
        n = i.CeilingPOT(e);
        break;
    }
    return Math.min(n, t);
  }, i.QueueNewFrame = function(e, t) {
    return me() ? (t || (t = window), t.requestPostAnimationFrame ? t.requestPostAnimationFrame(e) : t.requestAnimationFrame ? t.requestAnimationFrame(e) : t.msRequestAnimationFrame ? t.msRequestAnimationFrame(e) : t.webkitRequestAnimationFrame ? t.webkitRequestAnimationFrame(e) : t.mozRequestAnimationFrame ? t.mozRequestAnimationFrame(e) : t.oRequestAnimationFrame ? t.oRequestAnimationFrame(e) : window.setTimeout(e, 16)) : typeof requestAnimationFrame < "u" ? requestAnimationFrame(e) : setTimeout(e, 16);
  }, i.prototype.getHostDocument = function() {
    return this._renderingCanvas && this._renderingCanvas.ownerDocument ? this._renderingCanvas.ownerDocument : br() ? document : null;
  }, i.ExceptionList = [
    { key: "Chrome/63.0", capture: "63\\.0\\.3239\\.(\\d+)", captureConstraint: 108, targets: ["uniformBuffer"] },
    { key: "Firefox/58", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    { key: "Firefox/59", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    { key: "Chrome/72.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Chrome/73.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Chrome/74.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Mac OS.+Chrome/71", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Mac OS.+Chrome/72", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Mac OS.+Chrome", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    { key: ".*AppleWebKit.*(15.4).*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] },
    { key: ".*(15.4).*AppleWebKit.*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] }
  ], i._TextureLoaders = [], i.CollisionsEpsilon = 1e-3, i._IsSupported = null, i._HasMajorPerformanceCaveat = null, i;
}(), Ut = function() {
  function i() {
  }
  return Object.defineProperty(i, "Now", {
    get: function() {
      return ti.IsWindowObjectExist() && window.performance && window.performance.now ? window.performance.now() : Date.now();
    },
    enumerable: !1,
    configurable: !0
  }), i;
}(), Wn = function() {
  function i(e) {
    e === void 0 && (e = 30), this._enabled = !0, this._rollingFrameTime = new zn(e);
  }
  return i.prototype.sampleFrame = function(e) {
    if (e === void 0 && (e = Ut.Now), !!this._enabled) {
      if (this._lastFrameTimeMs != null) {
        var t = e - this._lastFrameTimeMs;
        this._rollingFrameTime.add(t);
      }
      this._lastFrameTimeMs = e;
    }
  }, Object.defineProperty(i.prototype, "averageFrameTime", {
    get: function() {
      return this._rollingFrameTime.average;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "averageFrameTimeVariance", {
    get: function() {
      return this._rollingFrameTime.variance;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "instantaneousFrameTime", {
    get: function() {
      return this._rollingFrameTime.history(0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "averageFPS", {
    get: function() {
      return 1e3 / this._rollingFrameTime.average;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "instantaneousFPS", {
    get: function() {
      var e = this._rollingFrameTime.history(0);
      return e === 0 ? 0 : 1e3 / e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "isSaturated", {
    get: function() {
      return this._rollingFrameTime.isSaturated();
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.enable = function() {
    this._enabled = !0;
  }, i.prototype.disable = function() {
    this._enabled = !1, this._lastFrameTimeMs = null;
  }, Object.defineProperty(i.prototype, "isEnabled", {
    get: function() {
      return this._enabled;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.reset = function() {
    this._lastFrameTimeMs = null, this._rollingFrameTime.reset();
  }, i;
}(), zn = function() {
  function i(e) {
    this._samples = new Array(e), this.reset();
  }
  return i.prototype.add = function(e) {
    var t;
    if (this.isSaturated()) {
      var r = this._samples[this._pos];
      t = r - this.average, this.average -= t / (this._sampleCount - 1), this._m2 -= t * (r - this.average);
    } else
      this._sampleCount++;
    t = e - this.average, this.average += t / this._sampleCount, this._m2 += t * (e - this.average), this.variance = this._m2 / (this._sampleCount - 1), this._samples[this._pos] = e, this._pos++, this._pos %= this._samples.length;
  }, i.prototype.history = function(e) {
    if (e >= this._sampleCount || e >= this._samples.length)
      return 0;
    var t = this._wrapPosition(this._pos - 1);
    return this._samples[this._wrapPosition(t - e)];
  }, i.prototype.isSaturated = function() {
    return this._sampleCount >= this._samples.length;
  }, i.prototype.reset = function() {
    this.average = 0, this.variance = 0, this._sampleCount = 0, this._pos = 0, this._m2 = 0;
  }, i.prototype._wrapPosition = function(e) {
    var t = this._samples.length;
    return (e % t + t) % t;
  }, i;
}(), qt = function() {
  function i() {
    this._startMonitoringTime = 0, this._min = 0, this._max = 0, this._average = 0, this._lastSecAverage = 0, this._current = 0, this._totalValueCount = 0, this._totalAccumulated = 0, this._lastSecAccumulated = 0, this._lastSecTime = 0, this._lastSecValueCount = 0;
  }
  return Object.defineProperty(i.prototype, "min", {
    get: function() {
      return this._min;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "max", {
    get: function() {
      return this._max;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "average", {
    get: function() {
      return this._average;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "lastSecAverage", {
    get: function() {
      return this._lastSecAverage;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "current", {
    get: function() {
      return this._current;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "total", {
    get: function() {
      return this._totalAccumulated;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "count", {
    get: function() {
      return this._totalValueCount;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.fetchNewFrame = function() {
    this._totalValueCount++, this._current = 0, this._lastSecValueCount++;
  }, i.prototype.addCount = function(e, t) {
    !i.Enabled || (this._current += e, t && this._fetchResult());
  }, i.prototype.beginMonitoring = function() {
    !i.Enabled || (this._startMonitoringTime = Ut.Now);
  }, i.prototype.endMonitoring = function(e) {
    if (e === void 0 && (e = !0), !!i.Enabled) {
      e && this.fetchNewFrame();
      var t = Ut.Now;
      this._current = t - this._startMonitoringTime, e && this._fetchResult();
    }
  }, i.prototype._fetchResult = function() {
    this._totalAccumulated += this._current, this._lastSecAccumulated += this._current, this._min = Math.min(this._min, this._current), this._max = Math.max(this._max, this._current), this._average = this._totalAccumulated / this._totalValueCount;
    var e = Ut.Now;
    e - this._lastSecTime > 1e3 && (this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount, this._lastSecTime = e, this._lastSecAccumulated = 0, this._lastSecValueCount = 0);
  }, i.Enabled = !0, i;
}();
ue.prototype.setAlphaConstants = function(i, e, t, r) {
  this._alphaState.setAlphaBlendConstants(i, e, t, r);
};
ue.prototype.setAlphaMode = function(i, e) {
  if (e === void 0 && (e = !1), this._alphaMode !== i) {
    switch (i) {
      case 0:
        this._alphaState.alphaBlend = !1;
        break;
      case 7:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 8:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 2:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 6:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 1:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 3:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 4:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 5:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 9:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 10:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 11:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 12:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO), this._alphaState.alphaBlend = !0;
        break;
      case 13:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 14:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 15:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO), this._alphaState.alphaBlend = !0;
        break;
      case 16:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 17:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
    }
    e || (this.depthCullingState.depthMask = i === 0), this._alphaMode = i;
  }
};
ue.prototype.getAlphaMode = function() {
  return this._alphaMode;
};
ue.prototype.setAlphaEquation = function(i) {
  if (this._alphaEquation !== i) {
    switch (i) {
      case 0:
        this._alphaState.setAlphaEquationParameters(32774, 32774);
        break;
      case 1:
        this._alphaState.setAlphaEquationParameters(32778, 32778);
        break;
      case 2:
        this._alphaState.setAlphaEquationParameters(32779, 32779);
        break;
      case 3:
        this._alphaState.setAlphaEquationParameters(32776, 32776);
        break;
      case 4:
        this._alphaState.setAlphaEquationParameters(32775, 32775);
        break;
      case 5:
        this._alphaState.setAlphaEquationParameters(32775, 32774);
        break;
    }
    this._alphaEquation = i;
  }
};
ue.prototype.getAlphaEquation = function() {
  return this._alphaEquation;
};
function Gn(i, e, t, r) {
  switch (t === void 0 && (t = !1), i) {
    case 3: {
      var n = e instanceof ArrayBuffer ? new Int8Array(e) : new Int8Array(e);
      return r && n.set(new Int8Array(r)), n;
    }
    case 0: {
      var a = e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e);
      return r && a.set(new Uint8Array(r)), a;
    }
    case 4: {
      var s = e instanceof ArrayBuffer ? new Int16Array(e) : new Int16Array(t ? e / 2 : e);
      return r && s.set(new Int16Array(r)), s;
    }
    case 5:
    case 8:
    case 9:
    case 10:
    case 2: {
      var o = e instanceof ArrayBuffer ? new Uint16Array(e) : new Uint16Array(t ? e / 2 : e);
      return r && o.set(new Uint16Array(r)), o;
    }
    case 6: {
      var u = e instanceof ArrayBuffer ? new Int32Array(e) : new Int32Array(t ? e / 4 : e);
      return r && u.set(new Int32Array(r)), u;
    }
    case 7:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15: {
      var f = e instanceof ArrayBuffer ? new Uint32Array(e) : new Uint32Array(t ? e / 4 : e);
      return r && f.set(new Uint32Array(r)), f;
    }
    case 1: {
      var l = e instanceof ArrayBuffer ? new Float32Array(e) : new Float32Array(t ? e / 4 : e);
      return r && l.set(new Float32Array(r)), l;
    }
  }
  var h = e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e);
  return r && h.set(new Uint8Array(r)), h;
}
ue.prototype._readTexturePixelsSync = function(i, e, t, r, n, a, s, o, u, f) {
  var l, h;
  r === void 0 && (r = -1), n === void 0 && (n = 0), a === void 0 && (a = null), s === void 0 && (s = !0), o === void 0 && (o = !1), u === void 0 && (u = 0), f === void 0 && (f = 0);
  var c = this._gl;
  if (!c)
    throw new Error("Engine does not have gl rendering context.");
  if (!this._dummyFramebuffer) {
    var d = c.createFramebuffer();
    if (!d)
      throw new Error("Unable to create dummy framebuffer");
    this._dummyFramebuffer = d;
  }
  c.bindFramebuffer(c.FRAMEBUFFER, this._dummyFramebuffer), r > -1 ? c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_CUBE_MAP_POSITIVE_X + r, (l = i._hardwareTexture) === null || l === void 0 ? void 0 : l.underlyingResource, n) : c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, (h = i._hardwareTexture) === null || h === void 0 ? void 0 : h.underlyingResource, n);
  var p = i.type !== void 0 ? this._getWebGLTextureType(i.type) : c.UNSIGNED_BYTE;
  if (o)
    a || (a = Gn(i.type, 4 * e * t));
  else
    switch (p) {
      case c.UNSIGNED_BYTE:
        a || (a = new Uint8Array(4 * e * t)), p = c.UNSIGNED_BYTE;
        break;
      default:
        a || (a = new Float32Array(4 * e * t)), p = c.FLOAT;
        break;
    }
  return s && this.flushFramebuffer(), c.readPixels(u, f, e, t, c.RGBA, p, a), c.bindFramebuffer(c.FRAMEBUFFER, this._currentFramebuffer), a;
};
ue.prototype._readTexturePixels = function(i, e, t, r, n, a, s, o, u, f) {
  return r === void 0 && (r = -1), n === void 0 && (n = 0), a === void 0 && (a = null), s === void 0 && (s = !0), o === void 0 && (o = !1), u === void 0 && (u = 0), f === void 0 && (f = 0), Promise.resolve(this._readTexturePixelsSync(i, e, t, r, n, a, s, o, u, f));
};
ue.prototype.updateDynamicIndexBuffer = function(i, e, t) {
  this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null, this.bindIndexBuffer(i);
  var r;
  i.is32Bits ? r = e instanceof Uint32Array ? e : new Uint32Array(e) : r = e instanceof Uint16Array ? e : new Uint16Array(e), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, r, this._gl.DYNAMIC_DRAW), this._resetIndexBufferBinding();
};
ue.prototype.updateDynamicVertexBuffer = function(i, e, t, r) {
  this.bindArrayBuffer(i), t === void 0 && (t = 0);
  var n = e.byteLength || e.length;
  r === void 0 || r >= n && t === 0 ? e instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, t, new Float32Array(e)) : this._gl.bufferSubData(this._gl.ARRAY_BUFFER, t, e) : e instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(e).subarray(t, t + r)) : (e instanceof ArrayBuffer ? e = new Uint8Array(e, t, r) : e = new Uint8Array(e.buffer, e.byteOffset + t, r), this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, e)), this._resetVertexBufferBinding();
};
var fe = function(i) {
  K(e, i);
  function e(t, r, n, a) {
    a === void 0 && (a = !1);
    var s = i.call(this, t, r, n, a) || this;
    if (s.enableOfflineSupport = !1, s.disableManifestCheck = !1, s.scenes = new Array(), s._virtualScenes = new Array(), s.onNewSceneAddedObservable = new O(), s.postProcesses = new Array(), s.isPointerLock = !1, s.onResizeObservable = new O(), s.onCanvasBlurObservable = new O(), s.onCanvasFocusObservable = new O(), s.onCanvasPointerOutObservable = new O(), s.onBeginFrameObservable = new O(), s.customAnimationFrameRequester = null, s.onEndFrameObservable = new O(), s.onBeforeShaderCompilationObservable = new O(), s.onAfterShaderCompilationObservable = new O(), s._deterministicLockstep = !1, s._lockstepMaxSteps = 4, s._timeStep = 1 / 60, s._fps = 60, s._deltaTime = 0, s._drawCalls = new qt(), s.canvasTabIndex = 1, s.disablePerformanceMonitorInBackground = !1, s._performanceMonitor = new Wn(), s._compatibilityMode = !0, s.currentRenderPassId = 0, s._renderPassNames = ["main"], e.Instances.push(s), !t)
      return s;
    if (s._features.supportRenderPasses = !0, n = s._creationOptions, t.getContext) {
      var o = t;
      if (s._sharedInit(o, !!n.doNotHandleTouchAction, n.audioEngine), me()) {
        var u = document;
        s._onFullscreenChange = function() {
          u.fullscreen !== void 0 ? s.isFullscreen = u.fullscreen : u.mozFullScreen !== void 0 ? s.isFullscreen = u.mozFullScreen : u.webkitIsFullScreen !== void 0 ? s.isFullscreen = u.webkitIsFullScreen : u.msIsFullScreen !== void 0 && (s.isFullscreen = u.msIsFullScreen), s.isFullscreen && s._pointerLockRequested && o && e._RequestPointerlock(o);
        }, document.addEventListener("fullscreenchange", s._onFullscreenChange, !1), document.addEventListener("mozfullscreenchange", s._onFullscreenChange, !1), document.addEventListener("webkitfullscreenchange", s._onFullscreenChange, !1), document.addEventListener("msfullscreenchange", s._onFullscreenChange, !1), s._onPointerLockChange = function() {
          s.isPointerLock = u.mozPointerLockElement === o || u.webkitPointerLockElement === o || u.msPointerLockElement === o || u.pointerLockElement === o;
        }, document.addEventListener("pointerlockchange", s._onPointerLockChange, !1), document.addEventListener("mspointerlockchange", s._onPointerLockChange, !1), document.addEventListener("mozpointerlockchange", s._onPointerLockChange, !1), document.addEventListener("webkitpointerlockchange", s._onPointerLockChange, !1), !e.audioEngine && n.audioEngine && e.AudioEngineFactory && (e.audioEngine = e.AudioEngineFactory(s.getRenderingCanvas(), s.getAudioContext(), s.getAudioDestination()));
      }
      s._connectVREvents(), s.enableOfflineSupport = e.OfflineProviderFactory !== void 0, s._deterministicLockstep = !!n.deterministicLockstep, s._lockstepMaxSteps = n.lockstepMaxSteps || 0, s._timeStep = n.timeStep || 1 / 60;
    }
    return s._prepareVRComponent(), n.autoEnableWebVR && s.initWebVR(), s;
  }
  return Object.defineProperty(e, "NpmPackage", {
    get: function() {
      return ue.NpmPackage;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "Version", {
    get: function() {
      return ue.Version;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "Instances", {
    get: function() {
      return re.Instances;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "LastCreatedEngine", {
    get: function() {
      return re.LastCreatedEngine;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "LastCreatedScene", {
    get: function() {
      return re.LastCreatedScene;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._createImageBitmapFromSource = function(t, r) {
    var n = this, a = new Promise(function(s, o) {
      var u = new Image();
      u.onload = function() {
        u.decode().then(function() {
          n.createImageBitmap(u, r).then(function(f) {
            s(f);
          });
        });
      }, u.onerror = function() {
        o("Error loading image ".concat(u.src));
      }, u.src = t;
    });
    return a;
  }, e.prototype.createImageBitmap = function(t, r) {
    return createImageBitmap(t, r);
  }, e.prototype.resizeImageBitmap = function(t, r, n) {
    var a = this.createCanvas(r, n), s = a.getContext("2d");
    if (!s)
      throw new Error("Unable to get 2d context for resizeImageBitmap");
    s.drawImage(t, 0, 0);
    var o = s.getImageData(0, 0, r, n).data;
    return o;
  }, e.MarkAllMaterialsAsDirty = function(t, r) {
    for (var n = 0; n < e.Instances.length; n++)
      for (var a = e.Instances[n], s = 0; s < a.scenes.length; s++)
        a.scenes[s].markAllMaterialsAsDirty(t, r);
  }, e.DefaultLoadingScreenFactory = function(t) {
    throw G("LoadingScreen");
  }, Object.defineProperty(e.prototype, "_supportsHardwareTextureRescaling", {
    get: function() {
      return !!e._RescalePostProcessFactory;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "performanceMonitor", {
    get: function() {
      return this._performanceMonitor;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "compatibilityMode", {
    get: function() {
      return this._compatibilityMode;
    },
    set: function(t) {
      this._compatibilityMode = !0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getInputElement = function() {
    return this._renderingCanvas;
  }, e.prototype._sharedInit = function(t, r, n) {
    var a = this;
    if (i.prototype._sharedInit.call(this, t, r, n), this._onCanvasFocus = function() {
      a.onCanvasFocusObservable.notifyObservers(a);
    }, this._onCanvasBlur = function() {
      a.onCanvasBlurObservable.notifyObservers(a);
    }, t.addEventListener("focus", this._onCanvasFocus), t.addEventListener("blur", this._onCanvasBlur), this._onBlur = function() {
      a.disablePerformanceMonitorInBackground && a._performanceMonitor.disable(), a._windowIsBackground = !0;
    }, this._onFocus = function() {
      a.disablePerformanceMonitorInBackground && a._performanceMonitor.enable(), a._windowIsBackground = !1;
    }, this._onCanvasPointerOut = function(o) {
      document.elementFromPoint(o.clientX, o.clientY) !== t && a.onCanvasPointerOutObservable.notifyObservers(o);
    }, me()) {
      var s = this.getHostWindow();
      s && (s.addEventListener("blur", this._onBlur), s.addEventListener("focus", this._onFocus));
    }
    t.addEventListener("pointerout", this._onCanvasPointerOut), r || this._disableTouchAction(), !e.audioEngine && n && e.AudioEngineFactory && (e.audioEngine = e.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination()));
  }, e.prototype.getAspectRatio = function(t, r) {
    r === void 0 && (r = !1);
    var n = t.viewport;
    return this.getRenderWidth(r) * n.width / (this.getRenderHeight(r) * n.height);
  }, e.prototype.getScreenAspectRatio = function() {
    return this.getRenderWidth(!0) / this.getRenderHeight(!0);
  }, e.prototype.getRenderingCanvasClientRect = function() {
    return this._renderingCanvas ? this._renderingCanvas.getBoundingClientRect() : null;
  }, e.prototype.getInputElementClientRect = function() {
    return this._renderingCanvas ? this.getInputElement().getBoundingClientRect() : null;
  }, e.prototype.isDeterministicLockStep = function() {
    return this._deterministicLockstep;
  }, e.prototype.getLockstepMaxSteps = function() {
    return this._lockstepMaxSteps;
  }, e.prototype.getTimeStep = function() {
    return this._timeStep * 1e3;
  }, e.prototype.generateMipMapsForCubemap = function(t, r) {
    if (r === void 0 && (r = !0), t.generateMipMaps) {
      var n = this._gl;
      this._bindTextureDirectly(n.TEXTURE_CUBE_MAP, t, !0), n.generateMipmap(n.TEXTURE_CUBE_MAP), r && this._bindTextureDirectly(n.TEXTURE_CUBE_MAP, null);
    }
  }, e.prototype.getDepthBuffer = function() {
    return this._depthCullingState.depthTest;
  }, e.prototype.setDepthBuffer = function(t) {
    this._depthCullingState.depthTest = t;
  }, e.prototype.getDepthWrite = function() {
    return this._depthCullingState.depthMask;
  }, e.prototype.setDepthWrite = function(t) {
    this._depthCullingState.depthMask = t;
  }, e.prototype.getStencilBuffer = function() {
    return this._stencilState.stencilTest;
  }, e.prototype.setStencilBuffer = function(t) {
    this._stencilState.stencilTest = t;
  }, e.prototype.getStencilMask = function() {
    return this._stencilState.stencilMask;
  }, e.prototype.setStencilMask = function(t) {
    this._stencilState.stencilMask = t;
  }, e.prototype.getStencilFunction = function() {
    return this._stencilState.stencilFunc;
  }, e.prototype.getStencilFunctionReference = function() {
    return this._stencilState.stencilFuncRef;
  }, e.prototype.getStencilFunctionMask = function() {
    return this._stencilState.stencilFuncMask;
  }, e.prototype.setStencilFunction = function(t) {
    this._stencilState.stencilFunc = t;
  }, e.prototype.setStencilFunctionReference = function(t) {
    this._stencilState.stencilFuncRef = t;
  }, e.prototype.setStencilFunctionMask = function(t) {
    this._stencilState.stencilFuncMask = t;
  }, e.prototype.getStencilOperationFail = function() {
    return this._stencilState.stencilOpStencilFail;
  }, e.prototype.getStencilOperationDepthFail = function() {
    return this._stencilState.stencilOpDepthFail;
  }, e.prototype.getStencilOperationPass = function() {
    return this._stencilState.stencilOpStencilDepthPass;
  }, e.prototype.setStencilOperationFail = function(t) {
    this._stencilState.stencilOpStencilFail = t;
  }, e.prototype.setStencilOperationDepthFail = function(t) {
    this._stencilState.stencilOpDepthFail = t;
  }, e.prototype.setStencilOperationPass = function(t) {
    this._stencilState.stencilOpStencilDepthPass = t;
  }, e.prototype.setDitheringState = function(t) {
    t ? this._gl.enable(this._gl.DITHER) : this._gl.disable(this._gl.DITHER);
  }, e.prototype.setRasterizerState = function(t) {
    t ? this._gl.disable(this._gl.RASTERIZER_DISCARD) : this._gl.enable(this._gl.RASTERIZER_DISCARD);
  }, e.prototype.getDepthFunction = function() {
    return this._depthCullingState.depthFunc;
  }, e.prototype.setDepthFunction = function(t) {
    this._depthCullingState.depthFunc = t;
  }, e.prototype.setDepthFunctionToGreater = function() {
    this.setDepthFunction(516);
  }, e.prototype.setDepthFunctionToGreaterOrEqual = function() {
    this.setDepthFunction(518);
  }, e.prototype.setDepthFunctionToLess = function() {
    this.setDepthFunction(513);
  }, e.prototype.setDepthFunctionToLessOrEqual = function() {
    this.setDepthFunction(515);
  }, e.prototype.cacheStencilState = function() {
    this._cachedStencilBuffer = this.getStencilBuffer(), this._cachedStencilFunction = this.getStencilFunction(), this._cachedStencilMask = this.getStencilMask(), this._cachedStencilOperationPass = this.getStencilOperationPass(), this._cachedStencilOperationFail = this.getStencilOperationFail(), this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail(), this._cachedStencilReference = this.getStencilFunctionReference();
  }, e.prototype.restoreStencilState = function() {
    this.setStencilFunction(this._cachedStencilFunction), this.setStencilMask(this._cachedStencilMask), this.setStencilBuffer(this._cachedStencilBuffer), this.setStencilOperationPass(this._cachedStencilOperationPass), this.setStencilOperationFail(this._cachedStencilOperationFail), this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail), this.setStencilFunctionReference(this._cachedStencilReference);
  }, e.prototype.setDirectViewport = function(t, r, n, a) {
    var s = this._cachedViewport;
    return this._cachedViewport = null, this._viewport(t, r, n, a), s;
  }, e.prototype.scissorClear = function(t, r, n, a, s) {
    this.enableScissor(t, r, n, a), this.clear(s, !0, !0, !0), this.disableScissor();
  }, e.prototype.enableScissor = function(t, r, n, a) {
    var s = this._gl;
    s.enable(s.SCISSOR_TEST), s.scissor(t, r, n, a);
  }, e.prototype.disableScissor = function() {
    var t = this._gl;
    t.disable(t.SCISSOR_TEST);
  }, e.prototype._reportDrawCall = function(t) {
    t === void 0 && (t = 1), this._drawCalls.addCount(t, !1);
  }, e.prototype.initWebVR = function() {
    throw G("WebVRCamera");
  }, e.prototype._prepareVRComponent = function() {
  }, e.prototype._connectVREvents = function(t, r) {
  }, e.prototype._submitVRFrame = function() {
  }, e.prototype.disableVR = function() {
  }, e.prototype.isVRPresenting = function() {
    return !1;
  }, e.prototype._requestVRFrame = function() {
  }, e.prototype._loadFileAsync = function(t, r, n) {
    var a = this;
    return new Promise(function(s, o) {
      a._loadFile(t, function(u) {
        s(u);
      }, void 0, r, n, function(u, f) {
        o(f);
      });
    });
  }, e.prototype.getVertexShaderSource = function(t) {
    var r = this._gl.getAttachedShaders(t);
    return r ? this._gl.getShaderSource(r[0]) : null;
  }, e.prototype.getFragmentShaderSource = function(t) {
    var r = this._gl.getAttachedShaders(t);
    return r ? this._gl.getShaderSource(r[1]) : null;
  }, e.prototype.setDepthStencilTexture = function(t, r, n, a) {
    t !== void 0 && (r && (this._boundUniforms[t] = r), !n || !n.depthStencilTexture ? this._setTexture(t, null, void 0, void 0, a) : this._setTexture(t, n, !1, !0, a));
  }, e.prototype.setTextureFromPostProcess = function(t, r, n) {
    var a, s = null;
    r && (r._textures.data[r._currentRenderTextureInd] ? s = r._textures.data[r._currentRenderTextureInd] : r._forcedOutputTexture && (s = r._forcedOutputTexture)), this._bindTexture(t, (a = s == null ? void 0 : s.texture) !== null && a !== void 0 ? a : null, n);
  }, e.prototype.setTextureFromPostProcessOutput = function(t, r, n) {
    var a, s;
    this._bindTexture(t, (s = (a = r == null ? void 0 : r._outputTexture) === null || a === void 0 ? void 0 : a.texture) !== null && s !== void 0 ? s : null, n);
  }, e.prototype._rebuildBuffers = function() {
    for (var t = 0, r = this.scenes; t < r.length; t++) {
      var n = r[t];
      n.resetCachedMaterial(), n._rebuildGeometries(), n._rebuildTextures();
    }
    for (var a = 0, s = this._virtualScenes; a < s.length; a++) {
      var n = s[a];
      n.resetCachedMaterial(), n._rebuildGeometries(), n._rebuildTextures();
    }
    i.prototype._rebuildBuffers.call(this);
  }, e.prototype._renderFrame = function() {
    for (var t = 0; t < this._activeRenderLoops.length; t++) {
      var r = this._activeRenderLoops[t];
      r();
    }
  }, e.prototype._renderLoop = function() {
    if (!this._contextWasLost) {
      var t = !0;
      !this.renderEvenInBackground && this._windowIsBackground && (t = !1), t && (this.beginFrame(), this._renderViews() || this._renderFrame(), this.endFrame());
    }
    this._activeRenderLoops.length > 0 ? this.customAnimationFrameRequester ? (this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester), this._frameHandler = this.customAnimationFrameRequester.requestID) : this.isVRPresenting() ? this._requestVRFrame() : this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow()) : this._renderingQueueLaunched = !1;
  }, e.prototype._renderViews = function() {
    return !1;
  }, e.prototype.switchFullscreen = function(t) {
    this.isFullscreen ? this.exitFullscreen() : this.enterFullscreen(t);
  }, e.prototype.enterFullscreen = function(t) {
    this.isFullscreen || (this._pointerLockRequested = t, this._renderingCanvas && e._RequestFullscreen(this._renderingCanvas));
  }, e.prototype.exitFullscreen = function() {
    this.isFullscreen && e._ExitFullscreen();
  }, e.prototype.enterPointerlock = function() {
    this._renderingCanvas && e._RequestPointerlock(this._renderingCanvas);
  }, e.prototype.exitPointerlock = function() {
    e._ExitPointerlock();
  }, e.prototype.beginFrame = function() {
    this._measureFps(), this.onBeginFrameObservable.notifyObservers(this), i.prototype.beginFrame.call(this);
  }, e.prototype.endFrame = function() {
    i.prototype.endFrame.call(this), this._submitVRFrame(), this.onEndFrameObservable.notifyObservers(this);
  }, e.prototype.resize = function(t) {
    t === void 0 && (t = !1), !this.isVRPresenting() && i.prototype.resize.call(this, t);
  }, e.prototype.setSize = function(t, r, n) {
    if (n === void 0 && (n = !1), !this._renderingCanvas || !i.prototype.setSize.call(this, t, r, n))
      return !1;
    if (this.scenes) {
      for (var a = 0; a < this.scenes.length; a++)
        for (var s = this.scenes[a], o = 0; o < s.cameras.length; o++) {
          var u = s.cameras[o];
          u._currentRenderId = 0;
        }
      this.onResizeObservable.hasObservers() && this.onResizeObservable.notifyObservers(this);
    }
    return !0;
  }, e.prototype._deletePipelineContext = function(t) {
    var r = t;
    r && r.program && r.transformFeedback && (this.deleteTransformFeedback(r.transformFeedback), r.transformFeedback = null), i.prototype._deletePipelineContext.call(this, t);
  }, e.prototype.createShaderProgram = function(t, r, n, a, s, o) {
    o === void 0 && (o = null), s = s || this._gl, this.onBeforeShaderCompilationObservable.notifyObservers(this);
    var u = i.prototype.createShaderProgram.call(this, t, r, n, a, s, o);
    return this.onAfterShaderCompilationObservable.notifyObservers(this), u;
  }, e.prototype._createShaderProgram = function(t, r, n, a, s) {
    s === void 0 && (s = null);
    var o = a.createProgram();
    if (t.program = o, !o)
      throw new Error("Unable to create program");
    if (a.attachShader(o, r), a.attachShader(o, n), this.webGLVersion > 1 && s) {
      var u = this.createTransformFeedback();
      this.bindTransformFeedback(u), this.setTranformFeedbackVaryings(o, s), t.transformFeedback = u;
    }
    return a.linkProgram(o), this.webGLVersion > 1 && s && this.bindTransformFeedback(null), t.context = a, t.vertexShader = r, t.fragmentShader = n, t.isParallelCompiled || this._finalizePipelineContext(t), o;
  }, e.prototype._releaseTexture = function(t) {
    i.prototype._releaseTexture.call(this, t);
  }, e.prototype._releaseRenderTargetWrapper = function(t) {
    i.prototype._releaseRenderTargetWrapper.call(this, t), this.scenes.forEach(function(r) {
      r.postProcesses.forEach(function(n) {
        n._outputTexture === t && (n._outputTexture = null);
      }), r.cameras.forEach(function(n) {
        n._postProcesses.forEach(function(a) {
          a && a._outputTexture === t && (a._outputTexture = null);
        });
      });
    });
  }, e.prototype.getRenderPassNames = function() {
    return this._renderPassNames;
  }, e.prototype.getCurrentRenderPassName = function() {
    return this._renderPassNames[this.currentRenderPassId];
  }, e.prototype.createRenderPassId = function(t) {
    var r = ++e._RenderPassIdCounter;
    return this._renderPassNames[r] = t != null ? t : "NONAME", r;
  }, e.prototype.releaseRenderPassId = function(t) {
    this._renderPassNames[t] = void 0;
    for (var r = 0; r < this.scenes.length; ++r)
      for (var n = this.scenes[r], a = 0; a < n.meshes.length; ++a) {
        var s = n.meshes[a];
        if (s.subMeshes)
          for (var o = 0; o < s.subMeshes.length; ++o) {
            var u = s.subMeshes[o];
            u._removeDrawWrapper(t);
          }
      }
  }, e.prototype._rescaleTexture = function(t, r, n, a, s) {
    var o = this;
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
    var u = this.createRenderTargetTexture({
      width: r.width,
      height: r.height
    }, {
      generateMipMaps: !1,
      type: 0,
      samplingMode: 2,
      generateDepthBuffer: !1,
      generateStencilBuffer: !1
    });
    !this._rescalePostProcess && e._RescalePostProcessFactory && (this._rescalePostProcess = e._RescalePostProcessFactory(this)), this._rescalePostProcess.externalTextureSamplerBinding = !0, this._rescalePostProcess.getEffect().executeWhenCompiled(function() {
      o._rescalePostProcess.onApply = function(l) {
        l._bindTexture("textureSampler", t);
      };
      var f = n;
      f || (f = o.scenes[o.scenes.length - 1]), f.postProcessManager.directRender([o._rescalePostProcess], u, !0), o._bindTextureDirectly(o._gl.TEXTURE_2D, r, !0), o._gl.copyTexImage2D(o._gl.TEXTURE_2D, 0, a, 0, 0, r.width, r.height, 0), o.unBindFramebuffer(u), u.dispose(), s && s();
    });
  }, e.prototype.getFps = function() {
    return this._fps;
  }, e.prototype.getDeltaTime = function() {
    return this._deltaTime;
  }, e.prototype._measureFps = function() {
    this._performanceMonitor.sampleFrame(), this._fps = this._performanceMonitor.averageFPS, this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
  }, e.prototype.wrapWebGLTexture = function(t) {
    var r = new en(t, this._gl), n = new Bt(this, ve.Unknown, !0);
    return n._hardwareTexture = r, n.isReady = !0, n;
  }, e.prototype._uploadImageToTexture = function(t, r, n, a) {
    n === void 0 && (n = 0), a === void 0 && (a = 0);
    var s = this._gl, o = this._getWebGLTextureType(t.type), u = this._getInternalFormat(t.format), f = this._getRGBABufferInternalSizedFormat(t.type, u), l = t.isCube ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D;
    this._bindTextureDirectly(l, t, !0), this._unpackFlipY(t.invertY);
    var h = s.TEXTURE_2D;
    t.isCube && (h = s.TEXTURE_CUBE_MAP_POSITIVE_X + n), s.texImage2D(h, a, f, u, o, r), this._bindTextureDirectly(l, null, !0);
  }, e.prototype.updateTextureComparisonFunction = function(t, r) {
    if (this.webGLVersion === 1) {
      k.Error("WebGL 1 does not support texture comparison.");
      return;
    }
    var n = this._gl;
    t.isCube ? (this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, t, !0), r === 0 ? (n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_COMPARE_FUNC, 515), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_COMPARE_MODE, n.NONE)) : (n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_COMPARE_FUNC, r), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE)), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null)) : (this._bindTextureDirectly(this._gl.TEXTURE_2D, t, !0), r === 0 ? (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_COMPARE_FUNC, 515), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_COMPARE_MODE, n.NONE)) : (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_COMPARE_FUNC, r), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE)), this._bindTextureDirectly(this._gl.TEXTURE_2D, null)), t._comparisonFunction = r;
  }, e.prototype.createInstancesBuffer = function(t) {
    var r = this._gl.createBuffer();
    if (!r)
      throw new Error("Unable to create instance buffer");
    var n = new $t(r);
    return n.capacity = t, this.bindArrayBuffer(n), this._gl.bufferData(this._gl.ARRAY_BUFFER, t, this._gl.DYNAMIC_DRAW), n.references = 1, n;
  }, e.prototype.deleteInstancesBuffer = function(t) {
    this._gl.deleteBuffer(t);
  }, e.prototype._clientWaitAsync = function(t, r, n) {
    r === void 0 && (r = 0), n === void 0 && (n = 10);
    var a = this._gl;
    return new Promise(function(s, o) {
      var u = function() {
        var f = a.clientWaitSync(t, r, 0);
        if (f == a.WAIT_FAILED) {
          o();
          return;
        }
        if (f == a.TIMEOUT_EXPIRED) {
          setTimeout(u, n);
          return;
        }
        s();
      };
      u();
    });
  }, e.prototype._readPixelsAsync = function(t, r, n, a, s, o, u) {
    if (this._webGLVersion < 2)
      throw new Error("_readPixelsAsync only work on WebGL2+");
    var f = this._gl, l = f.createBuffer();
    f.bindBuffer(f.PIXEL_PACK_BUFFER, l), f.bufferData(f.PIXEL_PACK_BUFFER, u.byteLength, f.STREAM_READ), f.readPixels(t, r, n, a, s, o, 0), f.bindBuffer(f.PIXEL_PACK_BUFFER, null);
    var h = f.fenceSync(f.SYNC_GPU_COMMANDS_COMPLETE, 0);
    return h ? (f.flush(), this._clientWaitAsync(h, 0, 10).then(function() {
      return f.deleteSync(h), f.bindBuffer(f.PIXEL_PACK_BUFFER, l), f.getBufferSubData(f.PIXEL_PACK_BUFFER, 0, u), f.bindBuffer(f.PIXEL_PACK_BUFFER, null), f.deleteBuffer(l), u;
    })) : null;
  }, e.prototype.dispose = function() {
    for (this.hideLoadingUI(), this.onNewSceneAddedObservable.clear(); this.postProcesses.length; )
      this.postProcesses[0].dispose();
    for (this._rescalePostProcess && this._rescalePostProcess.dispose(); this.scenes.length; )
      this.scenes[0].dispose();
    for (; this._virtualScenes.length; )
      this._virtualScenes[0].dispose();
    e.Instances.length === 1 && e.audioEngine && (e.audioEngine.dispose(), e.audioEngine = null), this.disableVR(), me() && (window.removeEventListener("blur", this._onBlur), window.removeEventListener("focus", this._onFocus), this._renderingCanvas && (this._renderingCanvas.removeEventListener("focus", this._onCanvasFocus), this._renderingCanvas.removeEventListener("blur", this._onCanvasBlur), this._renderingCanvas.removeEventListener("pointerout", this._onCanvasPointerOut)), br() && (document.removeEventListener("fullscreenchange", this._onFullscreenChange), document.removeEventListener("mozfullscreenchange", this._onFullscreenChange), document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange), document.removeEventListener("msfullscreenchange", this._onFullscreenChange), document.removeEventListener("pointerlockchange", this._onPointerLockChange), document.removeEventListener("mspointerlockchange", this._onPointerLockChange), document.removeEventListener("mozpointerlockchange", this._onPointerLockChange), document.removeEventListener("webkitpointerlockchange", this._onPointerLockChange))), i.prototype.dispose.call(this);
    var t = e.Instances.indexOf(this);
    t >= 0 && e.Instances.splice(t, 1), this.onResizeObservable.clear(), this.onCanvasBlurObservable.clear(), this.onCanvasFocusObservable.clear(), this.onCanvasPointerOutObservable.clear(), this.onBeginFrameObservable.clear(), this.onEndFrameObservable.clear();
  }, e.prototype._disableTouchAction = function() {
    !this._renderingCanvas || !this._renderingCanvas.setAttribute || (this._renderingCanvas.setAttribute("touch-action", "none"), this._renderingCanvas.style.touchAction = "none", this._renderingCanvas.style.msTouchAction = "none", this._renderingCanvas.style.webkitTapHighlightColor = "transparent");
  }, e.prototype.displayLoadingUI = function() {
    if (!!me()) {
      var t = this.loadingScreen;
      t && t.displayLoadingUI();
    }
  }, e.prototype.hideLoadingUI = function() {
    if (!!me()) {
      var t = this._loadingScreen;
      t && t.hideLoadingUI();
    }
  }, Object.defineProperty(e.prototype, "loadingScreen", {
    get: function() {
      return !this._loadingScreen && this._renderingCanvas && (this._loadingScreen = e.DefaultLoadingScreenFactory(this._renderingCanvas)), this._loadingScreen;
    },
    set: function(t) {
      this._loadingScreen = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "loadingUIText", {
    set: function(t) {
      this.loadingScreen.loadingUIText = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "loadingUIBackgroundColor", {
    set: function(t) {
      this.loadingScreen.loadingUIBackgroundColor = t;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.createVideoElement = function(t) {
    return document.createElement("video");
  }, e._RequestPointerlock = function(t) {
    t.requestPointerLock = t.requestPointerLock || t.msRequestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock && (t.requestPointerLock(), t.focus());
  }, e._ExitPointerlock = function() {
    var t = document;
    document.exitPointerLock = document.exitPointerLock || t.msExitPointerLock || t.mozExitPointerLock || t.webkitExitPointerLock, document.exitPointerLock && document.exitPointerLock();
  }, e._RequestFullscreen = function(t) {
    var r = t.requestFullscreen || t.msRequestFullscreen || t.webkitRequestFullscreen || t.mozRequestFullScreen;
    !r || r.call(t);
  }, e._ExitFullscreen = function() {
    var t = document;
    document.exitFullscreen ? document.exitFullscreen() : t.mozCancelFullScreen ? t.mozCancelFullScreen() : t.webkitCancelFullScreen ? t.webkitCancelFullScreen() : t.msCancelFullScreen && t.msCancelFullScreen();
  }, e.prototype.getFontOffset = function(t) {
    var r = document.createElement("span");
    r.innerHTML = "Hg", r.setAttribute("style", "font: ".concat(t, " !important"));
    var n = document.createElement("div");
    n.style.display = "inline-block", n.style.width = "1px", n.style.height = "0px", n.style.verticalAlign = "bottom";
    var a = document.createElement("div");
    a.style.whiteSpace = "nowrap", a.appendChild(r), a.appendChild(n), document.body.appendChild(a);
    var s = 0, o = 0;
    try {
      o = n.getBoundingClientRect().top - r.getBoundingClientRect().top, n.style.verticalAlign = "baseline", s = n.getBoundingClientRect().top - r.getBoundingClientRect().top;
    } finally {
      document.body.removeChild(a);
    }
    return { ascent: s, height: o, descent: o - s };
  }, e.ALPHA_DISABLE = 0, e.ALPHA_ADD = 1, e.ALPHA_COMBINE = 2, e.ALPHA_SUBTRACT = 3, e.ALPHA_MULTIPLY = 4, e.ALPHA_MAXIMIZED = 5, e.ALPHA_ONEONE = 6, e.ALPHA_PREMULTIPLIED = 7, e.ALPHA_PREMULTIPLIED_PORTERDUFF = 8, e.ALPHA_INTERPOLATE = 9, e.ALPHA_SCREENMODE = 10, e.DELAYLOADSTATE_NONE = 0, e.DELAYLOADSTATE_LOADED = 1, e.DELAYLOADSTATE_LOADING = 2, e.DELAYLOADSTATE_NOTLOADED = 4, e.NEVER = 512, e.ALWAYS = 519, e.LESS = 513, e.EQUAL = 514, e.LEQUAL = 515, e.GREATER = 516, e.GEQUAL = 518, e.NOTEQUAL = 517, e.KEEP = 7680, e.REPLACE = 7681, e.INCR = 7682, e.DECR = 7683, e.INVERT = 5386, e.INCR_WRAP = 34055, e.DECR_WRAP = 34056, e.TEXTURE_CLAMP_ADDRESSMODE = 0, e.TEXTURE_WRAP_ADDRESSMODE = 1, e.TEXTURE_MIRROR_ADDRESSMODE = 2, e.TEXTUREFORMAT_ALPHA = 0, e.TEXTUREFORMAT_LUMINANCE = 1, e.TEXTUREFORMAT_LUMINANCE_ALPHA = 2, e.TEXTUREFORMAT_RGB = 4, e.TEXTUREFORMAT_RGBA = 5, e.TEXTUREFORMAT_RED = 6, e.TEXTUREFORMAT_R = 6, e.TEXTUREFORMAT_RG = 7, e.TEXTUREFORMAT_RED_INTEGER = 8, e.TEXTUREFORMAT_R_INTEGER = 8, e.TEXTUREFORMAT_RG_INTEGER = 9, e.TEXTUREFORMAT_RGB_INTEGER = 10, e.TEXTUREFORMAT_RGBA_INTEGER = 11, e.TEXTURETYPE_UNSIGNED_BYTE = 0, e.TEXTURETYPE_UNSIGNED_INT = 0, e.TEXTURETYPE_FLOAT = 1, e.TEXTURETYPE_HALF_FLOAT = 2, e.TEXTURETYPE_BYTE = 3, e.TEXTURETYPE_SHORT = 4, e.TEXTURETYPE_UNSIGNED_SHORT = 5, e.TEXTURETYPE_INT = 6, e.TEXTURETYPE_UNSIGNED_INTEGER = 7, e.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8, e.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9, e.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10, e.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11, e.TEXTURETYPE_UNSIGNED_INT_24_8 = 12, e.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13, e.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14, e.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15, e.TEXTURE_NEAREST_SAMPLINGMODE = 1, e.TEXTURE_BILINEAR_SAMPLINGMODE = 2, e.TEXTURE_TRILINEAR_SAMPLINGMODE = 3, e.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8, e.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11, e.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3, e.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4, e.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5, e.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6, e.TEXTURE_NEAREST_LINEAR = 7, e.TEXTURE_NEAREST_NEAREST = 1, e.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9, e.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10, e.TEXTURE_LINEAR_LINEAR = 2, e.TEXTURE_LINEAR_NEAREST = 12, e.TEXTURE_EXPLICIT_MODE = 0, e.TEXTURE_SPHERICAL_MODE = 1, e.TEXTURE_PLANAR_MODE = 2, e.TEXTURE_CUBIC_MODE = 3, e.TEXTURE_PROJECTION_MODE = 4, e.TEXTURE_SKYBOX_MODE = 5, e.TEXTURE_INVCUBIC_MODE = 6, e.TEXTURE_EQUIRECTANGULAR_MODE = 7, e.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8, e.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9, e.SCALEMODE_FLOOR = 1, e.SCALEMODE_NEAREST = 2, e.SCALEMODE_CEILING = 3, e._RescalePostProcessFactory = null, e._RenderPassIdCounter = 0, e;
}(ue);
ue.prototype._debugPushGroup = function(i, e) {
};
ue.prototype._debugPopGroup = function(i) {
};
ue.prototype._debugInsertMarker = function(i, e) {
};
ue.prototype._debugFlushPendingCommands = function() {
};
function Xn(i) {
  return new fe(i, !0, {
    preserveDrawingBuffer: !0,
    stencil: !0
  });
}
var ye = function() {
  function i(e, t, r) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), r === void 0 && (r = 0), this.r = e, this.g = t, this.b = r;
  }
  return i.prototype.toString = function() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}";
  }, i.prototype.getClassName = function() {
    return "Color3";
  }, i.prototype.getHashCode = function() {
    var e = this.r * 255 | 0;
    return e = e * 397 ^ (this.g * 255 | 0), e = e * 397 ^ (this.b * 255 | 0), e;
  }, i.prototype.toArray = function(e, t) {
    return t === void 0 && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, this;
  }, i.prototype.fromArray = function(e, t) {
    return t === void 0 && (t = 0), i.FromArrayToRef(e, t, this), this;
  }, i.prototype.toColor4 = function(e) {
    return e === void 0 && (e = 1), new be(this.r, this.g, this.b, e);
  }, i.prototype.asArray = function() {
    return [this.r, this.g, this.b];
  }, i.prototype.toLuminance = function() {
    return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
  }, i.prototype.multiply = function(e) {
    return new i(this.r * e.r, this.g * e.g, this.b * e.b);
  }, i.prototype.multiplyToRef = function(e, t) {
    return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, this;
  }, i.prototype.equals = function(e) {
    return e && this.r === e.r && this.g === e.g && this.b === e.b;
  }, i.prototype.equalsFloats = function(e, t, r) {
    return this.r === e && this.g === t && this.b === r;
  }, i.prototype.scale = function(e) {
    return new i(this.r * e, this.g * e, this.b * e);
  }, i.prototype.scaleToRef = function(e, t) {
    return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, this;
  }, i.prototype.scaleAndAddToRef = function(e, t) {
    return t.r += this.r * e, t.g += this.g * e, t.b += this.b * e, this;
  }, i.prototype.clampToRef = function(e, t, r) {
    return e === void 0 && (e = 0), t === void 0 && (t = 1), r.r = J.Clamp(this.r, e, t), r.g = J.Clamp(this.g, e, t), r.b = J.Clamp(this.b, e, t), this;
  }, i.prototype.add = function(e) {
    return new i(this.r + e.r, this.g + e.g, this.b + e.b);
  }, i.prototype.addToRef = function(e, t) {
    return t.r = this.r + e.r, t.g = this.g + e.g, t.b = this.b + e.b, this;
  }, i.prototype.subtract = function(e) {
    return new i(this.r - e.r, this.g - e.g, this.b - e.b);
  }, i.prototype.subtractToRef = function(e, t) {
    return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, this;
  }, i.prototype.clone = function() {
    return new i(this.r, this.g, this.b);
  }, i.prototype.copyFrom = function(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }, i.prototype.copyFromFloats = function(e, t, r) {
    return this.r = e, this.g = t, this.b = r, this;
  }, i.prototype.set = function(e, t, r) {
    return this.copyFromFloats(e, t, r);
  }, i.prototype.toHexString = function() {
    var e = Math.round(this.r * 255), t = Math.round(this.g * 255), r = Math.round(this.b * 255);
    return "#" + J.ToHex(e) + J.ToHex(t) + J.ToHex(r);
  }, i.prototype.toLinearSpace = function() {
    var e = new i();
    return this.toLinearSpaceToRef(e), e;
  }, i.prototype.toHSV = function() {
    var e = new i();
    return this.toHSVToRef(e), e;
  }, i.prototype.toHSVToRef = function(e) {
    var t = this.r, r = this.g, n = this.b, a = Math.max(t, r, n), s = Math.min(t, r, n), o = 0, u = 0, f = a, l = a - s;
    a !== 0 && (u = l / a), a != s && (a == t ? (o = (r - n) / l, r < n && (o += 6)) : a == r ? o = (n - t) / l + 2 : a == n && (o = (t - r) / l + 4), o *= 60), e.r = o, e.g = u, e.b = f;
  }, i.prototype.toLinearSpaceToRef = function(e) {
    return e.r = Math.pow(this.r, Nt), e.g = Math.pow(this.g, Nt), e.b = Math.pow(this.b, Nt), this;
  }, i.prototype.toGammaSpace = function() {
    var e = new i();
    return this.toGammaSpaceToRef(e), e;
  }, i.prototype.toGammaSpaceToRef = function(e) {
    return e.r = Math.pow(this.r, Lt), e.g = Math.pow(this.g, Lt), e.b = Math.pow(this.b, Lt), this;
  }, i.HSVtoRGBToRef = function(e, t, r, n) {
    var a = r * t, s = e / 60, o = a * (1 - Math.abs(s % 2 - 1)), u = 0, f = 0, l = 0;
    s >= 0 && s <= 1 ? (u = a, f = o) : s >= 1 && s <= 2 ? (u = o, f = a) : s >= 2 && s <= 3 ? (f = a, l = o) : s >= 3 && s <= 4 ? (f = o, l = a) : s >= 4 && s <= 5 ? (u = o, l = a) : s >= 5 && s <= 6 && (u = a, l = o);
    var h = r - a;
    n.set(u + h, f + h, l + h);
  }, i.FromHexString = function(e) {
    if (e.substring(0, 1) !== "#" || e.length !== 7)
      return new i(0, 0, 0);
    var t = parseInt(e.substring(1, 3), 16), r = parseInt(e.substring(3, 5), 16), n = parseInt(e.substring(5, 7), 16);
    return i.FromInts(t, r, n);
  }, i.FromArray = function(e, t) {
    return t === void 0 && (t = 0), new i(e[t], e[t + 1], e[t + 2]);
  }, i.FromArrayToRef = function(e, t, r) {
    t === void 0 && (t = 0), r.r = e[t], r.g = e[t + 1], r.b = e[t + 2];
  }, i.FromInts = function(e, t, r) {
    return new i(e / 255, t / 255, r / 255);
  }, i.Lerp = function(e, t, r) {
    var n = new i(0, 0, 0);
    return i.LerpToRef(e, t, r, n), n;
  }, i.LerpToRef = function(e, t, r, n) {
    n.r = e.r + (t.r - e.r) * r, n.g = e.g + (t.g - e.g) * r, n.b = e.b + (t.b - e.b) * r;
  }, i.Hermite = function(e, t, r, n, a) {
    var s = a * a, o = a * s, u = 2 * o - 3 * s + 1, f = -2 * o + 3 * s, l = o - 2 * s + a, h = o - s, c = e.r * u + r.r * f + t.r * l + n.r * h, d = e.g * u + r.g * f + t.g * l + n.g * h, p = e.b * u + r.b * f + t.b * l + n.b * h;
    return new i(c, d, p);
  }, i.Hermite1stDerivative = function(e, t, r, n, a) {
    var s = i.Black();
    return this.Hermite1stDerivativeToRef(e, t, r, n, a, s), s;
  }, i.Hermite1stDerivativeToRef = function(e, t, r, n, a, s) {
    var o = a * a;
    s.r = (o - a) * 6 * e.r + (3 * o - 4 * a + 1) * t.r + (-o + a) * 6 * r.r + (3 * o - 2 * a) * n.r, s.g = (o - a) * 6 * e.g + (3 * o - 4 * a + 1) * t.g + (-o + a) * 6 * r.g + (3 * o - 2 * a) * n.g, s.b = (o - a) * 6 * e.b + (3 * o - 4 * a + 1) * t.b + (-o + a) * 6 * r.b + (3 * o - 2 * a) * n.b;
  }, i.Red = function() {
    return new i(1, 0, 0);
  }, i.Green = function() {
    return new i(0, 1, 0);
  }, i.Blue = function() {
    return new i(0, 0, 1);
  }, i.Black = function() {
    return new i(0, 0, 0);
  }, Object.defineProperty(i, "BlackReadOnly", {
    get: function() {
      return i._BlackReadOnly;
    },
    enumerable: !1,
    configurable: !0
  }), i.White = function() {
    return new i(1, 1, 1);
  }, i.Purple = function() {
    return new i(0.5, 0, 0.5);
  }, i.Magenta = function() {
    return new i(1, 0, 1);
  }, i.Yellow = function() {
    return new i(1, 1, 0);
  }, i.Gray = function() {
    return new i(0.5, 0.5, 0.5);
  }, i.Teal = function() {
    return new i(0, 1, 1);
  }, i.Random = function() {
    return new i(Math.random(), Math.random(), Math.random());
  }, i._BlackReadOnly = i.Black(), i;
}(), be = function() {
  function i(e, t, r, n) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), r === void 0 && (r = 0), n === void 0 && (n = 1), this.r = e, this.g = t, this.b = r, this.a = n;
  }
  return i.prototype.addInPlace = function(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this.a += e.a, this;
  }, i.prototype.asArray = function() {
    return [this.r, this.g, this.b, this.a];
  }, i.prototype.toArray = function(e, t) {
    return t === void 0 && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e[t + 3] = this.a, this;
  }, i.prototype.fromArray = function(e, t) {
    return t === void 0 && (t = 0), i.FromArrayToRef(e, t, this), this;
  }, i.prototype.equals = function(e) {
    return e && this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }, i.prototype.add = function(e) {
    return new i(this.r + e.r, this.g + e.g, this.b + e.b, this.a + e.a);
  }, i.prototype.subtract = function(e) {
    return new i(this.r - e.r, this.g - e.g, this.b - e.b, this.a - e.a);
  }, i.prototype.subtractToRef = function(e, t) {
    return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, t.a = this.a - e.a, this;
  }, i.prototype.scale = function(e) {
    return new i(this.r * e, this.g * e, this.b * e, this.a * e);
  }, i.prototype.scaleToRef = function(e, t) {
    return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, t.a = this.a * e, this;
  }, i.prototype.scaleAndAddToRef = function(e, t) {
    return t.r += this.r * e, t.g += this.g * e, t.b += this.b * e, t.a += this.a * e, this;
  }, i.prototype.clampToRef = function(e, t, r) {
    return e === void 0 && (e = 0), t === void 0 && (t = 1), r.r = J.Clamp(this.r, e, t), r.g = J.Clamp(this.g, e, t), r.b = J.Clamp(this.b, e, t), r.a = J.Clamp(this.a, e, t), this;
  }, i.prototype.multiply = function(e) {
    return new i(this.r * e.r, this.g * e.g, this.b * e.b, this.a * e.a);
  }, i.prototype.multiplyToRef = function(e, t) {
    return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, t.a = this.a * e.a, t;
  }, i.prototype.toString = function() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}";
  }, i.prototype.getClassName = function() {
    return "Color4";
  }, i.prototype.getHashCode = function() {
    var e = this.r * 255 | 0;
    return e = e * 397 ^ (this.g * 255 | 0), e = e * 397 ^ (this.b * 255 | 0), e = e * 397 ^ (this.a * 255 | 0), e;
  }, i.prototype.clone = function() {
    return new i(this.r, this.g, this.b, this.a);
  }, i.prototype.copyFrom = function(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this;
  }, i.prototype.copyFromFloats = function(e, t, r, n) {
    return this.r = e, this.g = t, this.b = r, this.a = n, this;
  }, i.prototype.set = function(e, t, r, n) {
    return this.copyFromFloats(e, t, r, n);
  }, i.prototype.toHexString = function(e) {
    e === void 0 && (e = !1);
    var t = Math.round(this.r * 255), r = Math.round(this.g * 255), n = Math.round(this.b * 255);
    if (e)
      return "#" + J.ToHex(t) + J.ToHex(r) + J.ToHex(n);
    var a = Math.round(this.a * 255);
    return "#" + J.ToHex(t) + J.ToHex(r) + J.ToHex(n) + J.ToHex(a);
  }, i.prototype.toLinearSpace = function() {
    var e = new i();
    return this.toLinearSpaceToRef(e), e;
  }, i.prototype.toLinearSpaceToRef = function(e) {
    return e.r = Math.pow(this.r, Nt), e.g = Math.pow(this.g, Nt), e.b = Math.pow(this.b, Nt), e.a = this.a, this;
  }, i.prototype.toGammaSpace = function() {
    var e = new i();
    return this.toGammaSpaceToRef(e), e;
  }, i.prototype.toGammaSpaceToRef = function(e) {
    return e.r = Math.pow(this.r, Lt), e.g = Math.pow(this.g, Lt), e.b = Math.pow(this.b, Lt), e.a = this.a, this;
  }, i.FromHexString = function(e) {
    if (e.substring(0, 1) !== "#" || e.length !== 9 && e.length !== 7)
      return new i(0, 0, 0, 0);
    var t = parseInt(e.substring(1, 3), 16), r = parseInt(e.substring(3, 5), 16), n = parseInt(e.substring(5, 7), 16), a = e.length === 9 ? parseInt(e.substring(7, 9), 16) : 255;
    return i.FromInts(t, r, n, a);
  }, i.Lerp = function(e, t, r) {
    var n = new i(0, 0, 0, 0);
    return i.LerpToRef(e, t, r, n), n;
  }, i.LerpToRef = function(e, t, r, n) {
    n.r = e.r + (t.r - e.r) * r, n.g = e.g + (t.g - e.g) * r, n.b = e.b + (t.b - e.b) * r, n.a = e.a + (t.a - e.a) * r;
  }, i.Hermite = function(e, t, r, n, a) {
    var s = a * a, o = a * s, u = 2 * o - 3 * s + 1, f = -2 * o + 3 * s, l = o - 2 * s + a, h = o - s, c = e.r * u + r.r * f + t.r * l + n.r * h, d = e.g * u + r.g * f + t.g * l + n.g * h, p = e.b * u + r.b * f + t.b * l + n.b * h, g = e.a * u + r.a * f + t.a * l + n.a * h;
    return new i(c, d, p, g);
  }, i.Hermite1stDerivative = function(e, t, r, n, a) {
    var s = new i();
    return this.Hermite1stDerivativeToRef(e, t, r, n, a, s), s;
  }, i.Hermite1stDerivativeToRef = function(e, t, r, n, a, s) {
    var o = a * a;
    s.r = (o - a) * 6 * e.r + (3 * o - 4 * a + 1) * t.r + (-o + a) * 6 * r.r + (3 * o - 2 * a) * n.r, s.g = (o - a) * 6 * e.g + (3 * o - 4 * a + 1) * t.g + (-o + a) * 6 * r.g + (3 * o - 2 * a) * n.g, s.b = (o - a) * 6 * e.b + (3 * o - 4 * a + 1) * t.b + (-o + a) * 6 * r.b + (3 * o - 2 * a) * n.b, s.a = (o - a) * 6 * e.a + (3 * o - 4 * a + 1) * t.a + (-o + a) * 6 * r.a + (3 * o - 2 * a) * n.a;
  }, i.FromColor3 = function(e, t) {
    return t === void 0 && (t = 1), new i(e.r, e.g, e.b, t);
  }, i.FromArray = function(e, t) {
    return t === void 0 && (t = 0), new i(e[t], e[t + 1], e[t + 2], e[t + 3]);
  }, i.FromArrayToRef = function(e, t, r) {
    t === void 0 && (t = 0), r.r = e[t], r.g = e[t + 1], r.b = e[t + 2], r.a = e[t + 3];
  }, i.FromInts = function(e, t, r, n) {
    return new i(e / 255, t / 255, r / 255, n / 255);
  }, i.CheckColors4 = function(e, t) {
    if (e.length === t * 3) {
      for (var r = [], n = 0; n < e.length; n += 3) {
        var a = n / 3 * 4;
        r[a] = e[n], r[a + 1] = e[n + 1], r[a + 2] = e[n + 2], r[a + 3] = 1;
      }
      return r;
    }
    return e;
  }, i;
}(), cr = function() {
  function i() {
  }
  return i.Color3 = xe.BuildArray(3, ye.Black), i.Color4 = xe.BuildArray(3, function() {
    return new be(0, 0, 0, 0);
  }), i;
}();
Ne("BABYLON.Color3", ye);
Ne("BABYLON.Color4", be);
var Ti = function(i, e) {
  return !i || i.getClassName && i.getClassName() === "Mesh" ? null : i.getClassName && i.getClassName() === "SubMesh" ? i.clone(e) : i.clone ? i.clone() : null;
};
function Hn(i) {
  var e = [];
  do
    Object.getOwnPropertyNames(i).forEach(function(t) {
      e.indexOf(t) === -1 && e.push(t);
    });
  while (i = Object.getPrototypeOf(i));
  return e;
}
var hi = function() {
  function i() {
  }
  return i.DeepCopy = function(e, t, r, n) {
    for (var a = Hn(e), s = 0, o = a; s < o.length; s++) {
      var u = o[s];
      if (!(u[0] === "_" && (!n || n.indexOf(u) === -1)) && !u.endsWith("Observable") && !(r && r.indexOf(u) !== -1)) {
        var f = e[u], l = typeof f;
        if (l !== "function")
          try {
            if (l === "object")
              if (f instanceof Array) {
                if (t[u] = [], f.length > 0)
                  if (typeof f[0] == "object")
                    for (var h = 0; h < f.length; h++) {
                      var c = Ti(f[h], t);
                      t[u].indexOf(c) === -1 && t[u].push(c);
                    }
                  else
                    t[u] = f.slice(0);
              } else
                t[u] = Ti(f, t);
            else
              t[u] = f;
          } catch (d) {
            k.Warn(d.message);
          }
      }
    }
  }, i;
}();
function jn() {
  return typeof _native < "u" && _native.XMLHttpRequest ? new _native.XMLHttpRequest() : new XMLHttpRequest();
}
var Er = function() {
  function i() {
    this._xhr = jn(), this._requestURL = "";
  }
  return i.prototype._injectCustomRequestHeaders = function() {
    if (!this._shouldSkipRequestModifications(this._requestURL))
      for (var e in i.CustomRequestHeaders) {
        var t = i.CustomRequestHeaders[e];
        t && this._xhr.setRequestHeader(e, t);
      }
  }, i.prototype._shouldSkipRequestModifications = function(e) {
    return i.SkipRequestModificationForBabylonCDN && (e.includes("preview.babylonjs.com") || e.includes("cdn.babylonjs.com"));
  }, Object.defineProperty(i.prototype, "onprogress", {
    get: function() {
      return this._xhr.onprogress;
    },
    set: function(e) {
      this._xhr.onprogress = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "readyState", {
    get: function() {
      return this._xhr.readyState;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "status", {
    get: function() {
      return this._xhr.status;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "statusText", {
    get: function() {
      return this._xhr.statusText;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "response", {
    get: function() {
      return this._xhr.response;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "responseURL", {
    get: function() {
      return this._xhr.responseURL;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "responseText", {
    get: function() {
      return this._xhr.responseText;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "responseType", {
    get: function() {
      return this._xhr.responseType;
    },
    set: function(e) {
      this._xhr.responseType = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "timeout", {
    get: function() {
      return this._xhr.timeout;
    },
    set: function(e) {
      this._xhr.timeout = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.addEventListener = function(e, t, r) {
    this._xhr.addEventListener(e, t, r);
  }, i.prototype.removeEventListener = function(e, t, r) {
    this._xhr.removeEventListener(e, t, r);
  }, i.prototype.abort = function() {
    this._xhr.abort();
  }, i.prototype.send = function(e) {
    i.CustomRequestHeaders && this._injectCustomRequestHeaders(), this._xhr.send(e);
  }, i.prototype.open = function(e, t) {
    for (var r = 0, n = i.CustomRequestModifiers; r < n.length; r++) {
      var a = n[r];
      if (this._shouldSkipRequestModifications(t))
        return;
      a(this._xhr, t);
    }
    return t = t.replace("file:http:", "http:"), t = t.replace("file:https:", "https:"), this._requestURL = t, this._xhr.open(e, t, !0);
  }, i.prototype.setRequestHeader = function(e, t) {
    this._xhr.setRequestHeader(e, t);
  }, i.prototype.getResponseHeader = function(e) {
    return this._xhr.getResponseHeader(e);
  }, i.CustomRequestHeaders = {}, i.CustomRequestModifiers = new Array(), i.SkipRequestModificationForBabylonCDN = !0, i;
}(), gr = function() {
  function i() {
  }
  return i.FilesToLoad = {}, i;
}(), Kn = function() {
  function i() {
  }
  return i.ExponentialBackoff = function(e, t) {
    return e === void 0 && (e = 3), t === void 0 && (t = 500), function(r, n, a) {
      return n.status !== 0 || a >= e || r.indexOf("file:") !== -1 ? -1 : Math.pow(2, a) * t;
    };
  }, i;
}(), Jt = function(i) {
  K(e, i);
  function e() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return e._setPrototypeOf = Object.setPrototypeOf || function(t, r) {
    return t.__proto__ = r, t;
  }, e;
}(Error), Rt = {
  MeshInvalidPositionsError: 0,
  UnsupportedTextureError: 1e3,
  GLTFLoaderUnexpectedMagicError: 2e3,
  SceneLoaderError: 3e3,
  LoadFileError: 4e3,
  RequestFileError: 4001,
  ReadFileError: 4002
}, Pt = function(i) {
  K(e, i);
  function e(t, r, n) {
    var a = i.call(this, t) || this;
    return a.errorCode = r, a.innerError = n, a.name = "RuntimeError", Jt._setPrototypeOf(a, e.prototype), a;
  }
  return e;
}(Jt), tn = function(i) {
  for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", t = "", r, n, a, s, o, u, f, l = 0, h = ArrayBuffer.isView(i) ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : new Uint8Array(i); l < h.length; )
    r = h[l++], n = l < h.length ? h[l++] : Number.NaN, a = l < h.length ? h[l++] : Number.NaN, s = r >> 2, o = (r & 3) << 4 | n >> 4, u = (n & 15) << 2 | a >> 6, f = a & 63, isNaN(n) ? u = f = 64 : isNaN(a) && (f = 64), t += e.charAt(s) + e.charAt(o) + e.charAt(u) + e.charAt(f);
  return t;
}, rn = function(i) {
  return atob(i);
}, Yn = function(i) {
  for (var e = rn(i), t = e.length, r = new Uint8Array(new ArrayBuffer(t)), n = 0; n < t; n++)
    r[n] = e.charCodeAt(n);
  return r.buffer;
}, Tr = function() {
  function i() {
  }
  return i.SetImmediate = function(e) {
    me() && window.setImmediate ? window.setImmediate(e) : setTimeout(e, 1);
  }, i;
}(), Zn = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i), Si = function(i) {
  K(e, i);
  function e(t, r) {
    var n = i.call(this, t, Rt.LoadFileError) || this;
    return n.name = "LoadFileError", Jt._setPrototypeOf(n, e.prototype), r instanceof Er ? n.request = r : n.file = r, n;
  }
  return e;
}(Pt), Mi = function(i) {
  K(e, i);
  function e(t, r) {
    var n = i.call(this, t, Rt.RequestFileError) || this;
    return n.request = r, n.name = "RequestFileError", Jt._setPrototypeOf(n, e.prototype), n;
  }
  return e;
}(Pt), qn = function(i) {
  K(e, i);
  function e(t, r) {
    var n = i.call(this, t, Rt.ReadFileError) || this;
    return n.file = r, n.name = "ReadFileError", Jt._setPrototypeOf(n, e.prototype), n;
  }
  return e;
}(Pt), Me = {
  DefaultRetryStrategy: Kn.ExponentialBackoff(),
  BaseUrl: "",
  CorsBehavior: "anonymous",
  PreprocessUrl: function(i) {
    return i;
  }
}, nn = function(i) {
  return i = i.replace(/#/gm, "%23"), i;
}, ci = function(i, e) {
  if (!(i && i.indexOf("data:") === 0) && Me.CorsBehavior)
    if (typeof Me.CorsBehavior == "string" || Me.CorsBehavior instanceof String)
      e.crossOrigin = Me.CorsBehavior;
    else {
      var t = Me.CorsBehavior(i);
      t && (e.crossOrigin = t);
    }
}, di = function(i, e, t, r, n, a) {
  var s;
  n === void 0 && (n = "");
  var o, u = !1;
  i instanceof ArrayBuffer || ArrayBuffer.isView(i) ? typeof Blob < "u" ? (o = URL.createObjectURL(new Blob([i], { type: n })), u = !0) : o = "data:".concat(n, ";base64,") + tn(i) : i instanceof Blob ? (o = URL.createObjectURL(i), u = !0) : (o = nn(i), o = Me.PreprocessUrl(i));
  var f = re.LastCreatedEngine, l = function(y) {
    if (t) {
      var E = o || i.toString();
      t("Error while trying to load image: ".concat(E.indexOf("http") === 0 || E.length <= 128 ? E : E.slice(0, 128) + "..."), y);
    }
  };
  if (typeof Image > "u" || ((s = f == null ? void 0 : f._features.forceBitmapOverHTMLImageElement) !== null && s !== void 0 ? s : !1))
    return xt(o, function(y) {
      f.createImageBitmap(new Blob([y], { type: n }), Tt({ premultiplyAlpha: "none" }, a)).then(function(E) {
        e(E), u && URL.revokeObjectURL(o);
      }).catch(function(E) {
        t && t("Error while trying to load image: " + i, E);
      });
    }, void 0, r || void 0, !0, function(y, E) {
      l(E);
    }), null;
  var h = new Image();
  ci(o, h);
  var c = function() {
    h.removeEventListener("load", c), h.removeEventListener("error", d), e(h), u && h.src && URL.revokeObjectURL(h.src);
  }, d = function(y) {
    h.removeEventListener("load", c), h.removeEventListener("error", d), l(y), u && h.src && URL.revokeObjectURL(h.src);
  };
  h.addEventListener("load", c), h.addEventListener("error", d);
  var p = function() {
    h.src = o;
  }, g = function() {
    r && r.loadImage(o, h);
  };
  if (o.substr(0, 5) !== "blob:" && o.substr(0, 5) !== "data:" && r && r.enableTexturesOffline)
    r.open(g, p);
  else {
    if (o.indexOf("file:") !== -1) {
      var _ = decodeURIComponent(o.substring(5).toLowerCase());
      if (gr.FilesToLoad[_]) {
        try {
          var v = void 0;
          try {
            v = URL.createObjectURL(gr.FilesToLoad[_]);
          } catch {
            v = URL.createObjectURL(gr.FilesToLoad[_]);
          }
          h.src = v, u = !0;
        } catch {
          h.src = "";
        }
        return h;
      }
    }
    p();
  }
  return h;
}, er = function(i, e, t, r, n) {
  var a = new FileReader(), s = {
    onCompleteObservable: new O(),
    abort: function() {
      return a.abort();
    }
  };
  return a.onloadend = function() {
    return s.onCompleteObservable.notifyObservers(s);
  }, n && (a.onerror = function() {
    n(new qn("Unable to read ".concat(i.name), i));
  }), a.onload = function(o) {
    e(o.target.result);
  }, t && (a.onprogress = t), r ? a.readAsArrayBuffer(i) : a.readAsText(i), s;
}, xt = function(i, e, t, r, n, a, s) {
  if (i.name)
    return er(i, e, t, n, a ? function(h) {
      a(void 0, h);
    } : void 0);
  var o = i;
  if (o.indexOf("file:") !== -1) {
    var u = decodeURIComponent(o.substring(5).toLowerCase());
    u.indexOf("./") === 0 && (u = u.substring(2));
    var f = gr.FilesToLoad[u];
    if (f)
      return er(f, e, t, n, a ? function(h) {
        return a(void 0, new Si(h.message, h.file));
      } : void 0);
  }
  if (Or(o)) {
    var l = {
      onCompleteObservable: new O(),
      abort: function() {
        return function() {
        };
      }
    };
    try {
      e(n ? _i(o) : sn(o));
    } catch (h) {
      a ? a(void 0, h) : k.Error(h.message || "Failed to parse the Data URL");
    }
    return Tr.SetImmediate(function() {
      l.onCompleteObservable.notifyObservers(l);
    }), l;
  }
  return pi(o, function(h, c) {
    e(h, c ? c.responseURL : void 0);
  }, t, r, n, a ? function(h) {
    a(h.request, new Si(h.message, h.request));
  } : void 0, s);
}, pi = function(i, e, t, r, n, a, s) {
  i = nn(i), i = Me.PreprocessUrl(i);
  var o = Me.BaseUrl + i, u = !1, f = {
    onCompleteObservable: new O(),
    abort: function() {
      return u = !0;
    }
  }, l = function() {
    var d = new Er(), p = null, g, _ = function() {
      !d || (t && d.removeEventListener("progress", t), g && d.removeEventListener("readystatechange", g), d.removeEventListener("loadend", v));
    }, v = function() {
      _(), f.onCompleteObservable.notifyObservers(f), f.onCompleteObservable.clear(), t = void 0, g = null, v = null, a = void 0, s = void 0, e = void 0;
    };
    f.abort = function() {
      u = !0, v && v(), d && d.readyState !== (XMLHttpRequest.DONE || 4) && d.abort(), p !== null && (clearTimeout(p), p = null), d = null;
    };
    var y = function(R) {
      var M = R.message || "Unknown error";
      a && d ? a(new Mi(M, d)) : k.Error(M);
    }, E = function(R) {
      if (!!d) {
        if (d.open("GET", o), s)
          try {
            s(d);
          } catch (M) {
            y(M);
            return;
          }
        n && (d.responseType = "arraybuffer"), t && d.addEventListener("progress", t), v && d.addEventListener("loadend", v), g = function() {
          if (!(u || !d) && d.readyState === (XMLHttpRequest.DONE || 4)) {
            if (g && d.removeEventListener("readystatechange", g), d.status >= 200 && d.status < 300 || d.status === 0 && (!me() || an())) {
              try {
                e && e(n ? d.response : d.responseText, d);
              } catch (S) {
                y(S);
              }
              return;
            }
            var M = Me.DefaultRetryStrategy;
            if (M) {
              var C = M(o, d, R);
              if (C !== -1) {
                _(), d = new Er(), p = setTimeout(function() {
                  return E(R + 1);
                }, C);
                return;
              }
            }
            var A = new Mi("Error status: " + d.status + " " + d.statusText + " - Unable to load " + o, d);
            a && a(A);
          }
        }, d.addEventListener("readystatechange", g), d.send();
      }
    };
    E(0);
  };
  if (r && r.enableSceneOffline) {
    var h = function(d) {
      d && d.status > 400 ? a && a(d) : l();
    }, c = function() {
      r && r.loadFile(Me.BaseUrl + i, function(d) {
        !u && e && e(d), f.onCompleteObservable.notifyObservers(f);
      }, t ? function(d) {
        !u && t && t(d);
      } : void 0, h, n);
    };
    r.open(c, h);
  } else
    l();
  return f;
}, an = function() {
  return typeof location < "u" && location.protocol === "file:";
}, Or = function(i) {
  return Zn.test(i);
};
function _i(i) {
  return Yn(i.split(",")[1]);
}
var sn = function(i) {
  return rn(i.split(",")[1]);
}, Qn = function() {
  ue._FileToolsLoadImage = di, ue._FileToolsLoadFile = xt, Zt._FileToolsLoadFile = xt;
};
Qn();
var Ht, $n = function(i, e, t, r, n, a, s, o, u, f) {
  Ht = {
    DecodeBase64UrlToBinary: i,
    DecodeBase64UrlToString: e,
    DefaultRetryStrategy: t.DefaultRetryStrategy,
    BaseUrl: t.BaseUrl,
    CorsBehavior: t.CorsBehavior,
    PreprocessUrl: t.PreprocessUrl,
    IsBase64DataUrl: r,
    IsFileURL: n,
    LoadFile: a,
    LoadImage: s,
    ReadFile: o,
    RequestFile: u,
    SetCorsBehavior: f
  }, Object.defineProperty(Ht, "DefaultRetryStrategy", {
    get: function() {
      return t.DefaultRetryStrategy;
    },
    set: function(l) {
      t.DefaultRetryStrategy = l;
    }
  }), Object.defineProperty(Ht, "BaseUrl", {
    get: function() {
      return t.BaseUrl;
    },
    set: function(l) {
      t.BaseUrl = l;
    }
  }), Object.defineProperty(Ht, "PreprocessUrl", {
    get: function() {
      return t.PreprocessUrl;
    },
    set: function(l) {
      t.PreprocessUrl = l;
    }
  }), Object.defineProperty(Ht, "CorsBehavior", {
    get: function() {
      return t.CorsBehavior;
    },
    set: function(l) {
      t.CorsBehavior = l;
    }
  });
};
$n(_i, sn, Me, Or, an, xt, di, er, pi, ci);
var vr = function() {
  function i() {
  }
  return i.Instantiate = function(e) {
    if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[e])
      return this.RegisteredExternalClasses[e];
    var t = Ct(e);
    if (t)
      return t;
    k.Warn(e + " not found, you may have missed an import.");
    for (var r = e.split("."), n = window || this, a = 0, s = r.length; a < s; a++)
      n = n[r[a]];
    return typeof n != "function" ? null : n;
  }, i.RegisteredExternalClasses = {}, i;
}();
function on() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(i) {
    var e = Math.random() * 16 | 0, t = i === "x" ? e : e & 3 | 8;
    return t.toString(16);
  });
}
var de = function() {
  function i() {
  }
  return Object.defineProperty(i, "BaseUrl", {
    get: function() {
      return Me.BaseUrl;
    },
    set: function(e) {
      Me.BaseUrl = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "DefaultRetryStrategy", {
    get: function() {
      return Me.DefaultRetryStrategy;
    },
    set: function(e) {
      Me.DefaultRetryStrategy = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "CorsBehavior", {
    get: function() {
      return Me.CorsBehavior;
    },
    set: function(e) {
      Me.CorsBehavior = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "UseFallbackTexture", {
    get: function() {
      return re.UseFallbackTexture;
    },
    set: function(e) {
      re.UseFallbackTexture = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "RegisteredExternalClasses", {
    get: function() {
      return vr.RegisteredExternalClasses;
    },
    set: function(e) {
      vr.RegisteredExternalClasses = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "fallbackTexture", {
    get: function() {
      return re.FallbackTexture;
    },
    set: function(e) {
      re.FallbackTexture = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.FetchToRef = function(e, t, r, n, a, s) {
    var o = Math.abs(e) * r % r | 0, u = Math.abs(t) * n % n | 0, f = (o + u * r) * 4;
    s.r = a[f] / 255, s.g = a[f + 1] / 255, s.b = a[f + 2] / 255, s.a = a[f + 3] / 255;
  }, i.Mix = function(e, t, r) {
    return e * (1 - r) + t * r;
  }, i.Instantiate = function(e) {
    return vr.Instantiate(e);
  }, i.SetImmediate = function(e) {
    Tr.SetImmediate(e);
  }, i.IsExponentOfTwo = function(e) {
    var t = 1;
    do
      t *= 2;
    while (t < e);
    return t === e;
  }, i.FloatRound = function(e) {
    return Math.fround ? Math.fround(e) : (i._TmpFloatArray[0] = e, i._TmpFloatArray[0]);
  }, i.GetFilename = function(e) {
    var t = e.lastIndexOf("/");
    return t < 0 ? e : e.substring(t + 1);
  }, i.GetFolderPath = function(e, t) {
    t === void 0 && (t = !1);
    var r = e.lastIndexOf("/");
    return r < 0 ? t ? e : "" : e.substring(0, r + 1);
  }, i.ToDegrees = function(e) {
    return e * 180 / Math.PI;
  }, i.ToRadians = function(e) {
    return e * Math.PI / 180;
  }, i.MakeArray = function(e, t) {
    return t !== !0 && (e === void 0 || e == null) ? null : Array.isArray(e) ? e : [e];
  }, i.GetPointerPrefix = function(e) {
    var t = "pointer";
    return me() && !window.PointerEvent && (t = "mouse"), e._badDesktopOS && !e._badOS && !(document && "ontouchend" in document) && (t = "mouse"), t;
  }, i.SetCorsBehavior = function(e, t) {
    ci(e, t);
  }, i.CleanUrl = function(e) {
    return e = e.replace(/#/gm, "%23"), e;
  }, Object.defineProperty(i, "PreprocessUrl", {
    get: function() {
      return Me.PreprocessUrl;
    },
    set: function(e) {
      Me.PreprocessUrl = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.LoadImage = function(e, t, r, n, a, s) {
    return di(e, t, r, n, a, s);
  }, i.LoadFile = function(e, t, r, n, a, s) {
    return xt(e, t, r, n, a, s);
  }, i.LoadFileAsync = function(e, t) {
    return t === void 0 && (t = !0), new Promise(function(r, n) {
      xt(e, function(a) {
        r(a);
      }, void 0, void 0, t, function(a, s) {
        n(s);
      });
    });
  }, i.LoadScript = function(e, t, r, n) {
    if (!!me()) {
      var a = document.getElementsByTagName("head")[0], s = document.createElement("script");
      s.setAttribute("type", "text/javascript"), s.setAttribute("src", e), n && (s.id = n), s.onload = function() {
        t && t();
      }, s.onerror = function(o) {
        r && r("Unable to load script '".concat(e, "'"), o);
      }, a.appendChild(s);
    }
  }, i.LoadScriptAsync = function(e) {
    var t = this;
    return new Promise(function(r, n) {
      t.LoadScript(e, function() {
        r();
      }, function(a, s) {
        n(s);
      });
    });
  }, i.ReadFileAsDataURL = function(e, t, r) {
    var n = new FileReader(), a = {
      onCompleteObservable: new O(),
      abort: function() {
        return n.abort();
      }
    };
    return n.onloadend = function() {
      a.onCompleteObservable.notifyObservers(a);
    }, n.onload = function(s) {
      t(s.target.result);
    }, n.onprogress = r, n.readAsDataURL(e), a;
  }, i.ReadFile = function(e, t, r, n, a) {
    return er(e, t, r, n, a);
  }, i.FileAsURL = function(e) {
    var t = new Blob([e]), r = window.URL || window.webkitURL, n = r.createObjectURL(t);
    return n;
  }, i.Format = function(e, t) {
    return t === void 0 && (t = 2), e.toFixed(t);
  }, i.DeepCopy = function(e, t, r, n) {
    hi.DeepCopy(e, t, r, n);
  }, i.IsEmpty = function(e) {
    for (var t in e)
      if (Object.prototype.hasOwnProperty.call(e, t))
        return !1;
    return !0;
  }, i.RegisterTopRootEvents = function(e, t) {
    for (var r = 0; r < t.length; r++) {
      var n = t[r];
      e.addEventListener(n.name, n.handler, !1);
      try {
        window.parent && window.parent.addEventListener(n.name, n.handler, !1);
      } catch {
      }
    }
  }, i.UnregisterTopRootEvents = function(e, t) {
    for (var r = 0; r < t.length; r++) {
      var n = t[r];
      e.removeEventListener(n.name, n.handler);
      try {
        e.parent && e.parent.removeEventListener(n.name, n.handler);
      } catch {
      }
    }
  }, i.DumpFramebuffer = function(e, t, r, n, a, s) {
    return a === void 0 && (a = "image/png"), fi(this, void 0, void 0, function() {
      var o, u;
      return Gt(this, function(f) {
        switch (f.label) {
          case 0:
            return [4, r.readPixels(0, 0, e, t)];
          case 1:
            return o = f.sent(), u = new Uint8Array(o.buffer), i.DumpData(e, t, u, n, a, s, !0), [2];
        }
      });
    });
  }, i.DumpData = function(e, t, r, n, a, s, o, u, f) {
    a === void 0 && (a = "image/png"), o === void 0 && (o = !1), u === void 0 && (u = !1), i._ScreenshotCanvas || (i._ScreenshotCanvas = document.createElement("canvas")), i._ScreenshotCanvas.width = e, i._ScreenshotCanvas.height = t;
    var l = i._ScreenshotCanvas.getContext("2d");
    if (l) {
      if (r instanceof Float32Array) {
        for (var h = new Uint8Array(r.length), c = r.length; c--; ) {
          var d = r[c];
          h[c] = d < 0 ? 0 : d > 1 ? 1 : Math.round(d * 255);
        }
        r = h;
      }
      var p = l.createImageData(e, t), g = p.data;
      g.set(r), l.putImageData(p, 0, 0);
      var _ = i._ScreenshotCanvas;
      if (o) {
        var v = document.createElement("canvas");
        v.width = e, v.height = t;
        var y = v.getContext("2d");
        if (!y)
          return;
        y.translate(0, t), y.scale(1, -1), y.drawImage(i._ScreenshotCanvas, 0, 0), _ = v;
      }
      u ? i.ToBlob(_, function(E) {
        var R = new FileReader();
        R.onload = function(M) {
          var C = M.target.result;
          n && n(C);
        }, R.readAsArrayBuffer(E);
      }, a, f) : i.EncodeScreenshotCanvasData(n, a, s, _, f);
    }
  }, i.DumpDataAsync = function(e, t, r, n, a, s, o, u) {
    return n === void 0 && (n = "image/png"), s === void 0 && (s = !1), o === void 0 && (o = !1), new Promise(function(f) {
      i.DumpData(e, t, r, function(l) {
        return f(l);
      }, n, a, s, o, u);
    });
  }, i.ToBlob = function(e, t, r, n) {
    r === void 0 && (r = "image/png"), e.toBlob || (e.toBlob = function(a, s, o) {
      var u = this;
      setTimeout(function() {
        for (var f = atob(u.toDataURL(s, o).split(",")[1]), l = f.length, h = new Uint8Array(l), c = 0; c < l; c++)
          h[c] = f.charCodeAt(c);
        a(new Blob([h]));
      });
    }), e.toBlob(function(a) {
      t(a);
    }, r, n);
  }, i.EncodeScreenshotCanvasData = function(e, t, r, n, a) {
    if (t === void 0 && (t = "image/png"), e) {
      var s = (n != null ? n : i._ScreenshotCanvas).toDataURL(t, a);
      e(s);
    } else
      this.ToBlob(n != null ? n : i._ScreenshotCanvas, function(o) {
        if ("download" in document.createElement("a")) {
          if (!r) {
            var u = new Date(), f = (u.getFullYear() + "-" + (u.getMonth() + 1)).slice(2) + "-" + u.getDate() + "_" + u.getHours() + "-" + ("0" + u.getMinutes()).slice(-2);
            r = "screenshot_" + f + ".png";
          }
          i.Download(o, r);
        } else if (o) {
          var l = URL.createObjectURL(o), h = window.open("");
          if (!h)
            return;
          var c = h.document.createElement("img");
          c.onload = function() {
            URL.revokeObjectURL(l);
          }, c.src = l, h.document.body.appendChild(c);
        }
      }, t, a);
  }, i.Download = function(e, t) {
    if (navigator && navigator.msSaveBlob) {
      navigator.msSaveBlob(e, t);
      return;
    }
    var r = window.URL.createObjectURL(e), n = document.createElement("a");
    document.body.appendChild(n), n.style.display = "none", n.href = r, n.download = t, n.addEventListener("click", function() {
      n.parentElement && n.parentElement.removeChild(n);
    }), n.click(), window.URL.revokeObjectURL(r);
  }, i.BackCompatCameraNoPreventDefault = function(e) {
    return typeof e[0] == "boolean" ? e[0] : typeof e[1] == "boolean" ? e[1] : !1;
  }, i.CreateScreenshot = function(e, t, r, n, a) {
    throw G("ScreenshotTools");
  }, i.CreateScreenshotAsync = function(e, t, r, n) {
    throw G("ScreenshotTools");
  }, i.CreateScreenshotUsingRenderTarget = function(e, t, r, n, a, s, o, u) {
    throw G("ScreenshotTools");
  }, i.CreateScreenshotUsingRenderTargetAsync = function(e, t, r, n, a, s, o) {
    throw G("ScreenshotTools");
  }, i.RandomId = function() {
    return on();
  }, i.IsBase64 = function(e) {
    return Or(e);
  }, i.DecodeBase64 = function(e) {
    return _i(e);
  }, Object.defineProperty(i, "errorsCount", {
    get: function() {
      return k.errorsCount;
    },
    enumerable: !1,
    configurable: !0
  }), i.Log = function(e) {
    k.Log(e);
  }, i.Warn = function(e) {
    k.Warn(e);
  }, i.Error = function(e) {
    k.Error(e);
  }, Object.defineProperty(i, "LogCache", {
    get: function() {
      return k.LogCache;
    },
    enumerable: !1,
    configurable: !0
  }), i.ClearLogCache = function() {
    k.ClearLogCache();
  }, Object.defineProperty(i, "LogLevels", {
    set: function(e) {
      k.LogLevels = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "PerformanceLogLevel", {
    set: function(e) {
      if ((e & i.PerformanceUserMarkLogLevel) === i.PerformanceUserMarkLogLevel) {
        i.StartPerformanceCounter = i._StartUserMark, i.EndPerformanceCounter = i._EndUserMark;
        return;
      }
      if ((e & i.PerformanceConsoleLogLevel) === i.PerformanceConsoleLogLevel) {
        i.StartPerformanceCounter = i._StartPerformanceConsole, i.EndPerformanceCounter = i._EndPerformanceConsole;
        return;
      }
      i.StartPerformanceCounter = i._StartPerformanceCounterDisabled, i.EndPerformanceCounter = i._EndPerformanceCounterDisabled;
    },
    enumerable: !1,
    configurable: !0
  }), i._StartPerformanceCounterDisabled = function(e, t) {
  }, i._EndPerformanceCounterDisabled = function(e, t) {
  }, i._StartUserMark = function(e, t) {
    if (t === void 0 && (t = !0), !i._Performance) {
      if (!me())
        return;
      i._Performance = window.performance;
    }
    !t || !i._Performance.mark || i._Performance.mark(e + "-Begin");
  }, i._EndUserMark = function(e, t) {
    t === void 0 && (t = !0), !(!t || !i._Performance.mark) && (i._Performance.mark(e + "-End"), i._Performance.measure(e, e + "-Begin", e + "-End"));
  }, i._StartPerformanceConsole = function(e, t) {
    t === void 0 && (t = !0), t && (i._StartUserMark(e, t), console.time && console.time(e));
  }, i._EndPerformanceConsole = function(e, t) {
    t === void 0 && (t = !0), t && (i._EndUserMark(e, t), console.timeEnd(e));
  }, Object.defineProperty(i, "Now", {
    get: function() {
      return Ut.Now;
    },
    enumerable: !1,
    configurable: !0
  }), i.GetClassName = function(e, t) {
    t === void 0 && (t = !1);
    var r = null;
    if (!t && e.getClassName)
      r = e.getClassName();
    else {
      if (e instanceof Object) {
        var n = t ? e : Object.getPrototypeOf(e);
        r = n.constructor.__bjsclassName__;
      }
      r || (r = typeof e);
    }
    return r;
  }, i.First = function(e, t) {
    for (var r = 0, n = e; r < n.length; r++) {
      var a = n[r];
      if (t(a))
        return a;
    }
    return null;
  }, i.getFullClassName = function(e, t) {
    t === void 0 && (t = !1);
    var r = null, n = null;
    if (!t && e.getClassName)
      r = e.getClassName();
    else {
      if (e instanceof Object) {
        var a = t ? e : Object.getPrototypeOf(e);
        r = a.constructor.__bjsclassName__, n = a.constructor.__bjsmoduleName__;
      }
      r || (r = typeof e);
    }
    return r ? (n != null ? n + "." : "") + r : null;
  }, i.DelayAsync = function(e) {
    return new Promise(function(t) {
      setTimeout(function() {
        t();
      }, e);
    });
  }, i.IsSafari = function() {
    return $i() ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1;
  }, i.UseCustomRequestHeaders = !1, i.CustomRequestHeaders = Er.CustomRequestHeaders, i._TmpFloatArray = new Float32Array(1), i.GetDOMTextContent = li, i.GetAbsoluteUrl = typeof document == "object" ? function(e) {
    var t = document.createElement("a");
    return t.href = e, t.href;
  } : typeof URL == "function" && typeof location == "object" ? function(e) {
    return new URL(e, location.origin).href;
  } : function() {
    throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.");
  }, i.NoneLogLevel = k.NoneLogLevel, i.MessageLogLevel = k.MessageLogLevel, i.WarningLogLevel = k.WarningLogLevel, i.ErrorLogLevel = k.ErrorLogLevel, i.AllLogLevel = k.AllLogLevel, i.IsWindowObjectExist = me, i.PerformanceNoneLogLevel = 0, i.PerformanceUserMarkLogLevel = 1, i.PerformanceConsoleLogLevel = 2, i.StartPerformanceCounter = i._StartPerformanceCounterDisabled, i.EndPerformanceCounter = i._EndPerformanceCounterDisabled, i;
}(), Jn = function() {
  function i(e, t, r, n) {
    n === void 0 && (n = 0), this.iterations = e, this.index = n - 1, this._done = !1, this._fn = t, this._successCallback = r;
  }
  return i.prototype.executeNext = function() {
    this._done || (this.index + 1 < this.iterations ? (++this.index, this._fn(this)) : this.breakLoop());
  }, i.prototype.breakLoop = function() {
    this._done = !0, this._successCallback();
  }, i.Run = function(e, t, r, n) {
    n === void 0 && (n = 0);
    var a = new i(e, t, r, n);
    return a.executeNext(), a;
  }, i.SyncAsyncForLoop = function(e, t, r, n, a, s) {
    return s === void 0 && (s = 0), i.Run(Math.ceil(e / t), function(o) {
      a && a() ? o.breakLoop() : setTimeout(function() {
        for (var u = 0; u < t; ++u) {
          var f = o.index * t + u;
          if (f >= e)
            break;
          if (r(f), a && a()) {
            o.breakLoop();
            break;
          }
        }
        o.executeNext();
      }, s);
    }, n);
  }, i;
}();
re.FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";
var ke = function() {
  function i(e) {
    this.length = 0, this.data = new Array(e), this._id = i._GlobalId++;
  }
  return i.prototype.push = function(e) {
    this.data[this.length++] = e, this.length > this.data.length && (this.data.length *= 2);
  }, i.prototype.forEach = function(e) {
    for (var t = 0; t < this.length; t++)
      e(this.data[t]);
  }, i.prototype.sort = function(e) {
    this.data.sort(e);
  }, i.prototype.reset = function() {
    this.length = 0;
  }, i.prototype.dispose = function() {
    this.reset(), this.data && (this.data.length = 0, this.data = []);
  }, i.prototype.concat = function(e) {
    if (e.length !== 0) {
      this.length + e.length > this.data.length && (this.data.length = (this.length + e.length) * 2);
      for (var t = 0; t < e.length; t++)
        this.data[this.length++] = (e.data || e)[t];
    }
  }, i.prototype.indexOf = function(e) {
    var t = this.data.indexOf(e);
    return t >= this.length ? -1 : t;
  }, i.prototype.contains = function(e) {
    return this.indexOf(e) !== -1;
  }, i._GlobalId = 0, i;
}(), Mt = function(i) {
  K(e, i);
  function e() {
    var t = i !== null && i.apply(this, arguments) || this;
    return t._duplicateId = 0, t;
  }
  return e.prototype.push = function(t) {
    i.prototype.push.call(this, t), t.__smartArrayFlags || (t.__smartArrayFlags = {}), t.__smartArrayFlags[this._id] = this._duplicateId;
  }, e.prototype.pushNoDuplicate = function(t) {
    return t.__smartArrayFlags && t.__smartArrayFlags[this._id] === this._duplicateId ? !1 : (this.push(t), !0);
  }, e.prototype.reset = function() {
    i.prototype.reset.call(this), this._duplicateId++;
  }, e.prototype.concatWithNoDuplicate = function(t) {
    if (t.length !== 0) {
      this.length + t.length > this.data.length && (this.data.length = (this.length + t.length) * 2);
      for (var r = 0; r < t.length; r++) {
        var n = (t.data || t)[r];
        this.pushNoDuplicate(n);
      }
    }
  }, e;
}(ke), Ai = function() {
  function i() {
    this._count = 0, this._data = {};
  }
  return i.prototype.copyFrom = function(e) {
    var t = this;
    this.clear(), e.forEach(function(r, n) {
      return t.add(r, n);
    });
  }, i.prototype.get = function(e) {
    var t = this._data[e];
    if (t !== void 0)
      return t;
  }, i.prototype.getOrAddWithFactory = function(e, t) {
    var r = this.get(e);
    return r !== void 0 || (r = t(e), r && this.add(e, r)), r;
  }, i.prototype.getOrAdd = function(e, t) {
    var r = this.get(e);
    return r !== void 0 ? r : (this.add(e, t), t);
  }, i.prototype.contains = function(e) {
    return this._data[e] !== void 0;
  }, i.prototype.add = function(e, t) {
    return this._data[e] !== void 0 ? !1 : (this._data[e] = t, ++this._count, !0);
  }, i.prototype.set = function(e, t) {
    return this._data[e] === void 0 ? !1 : (this._data[e] = t, !0);
  }, i.prototype.getAndRemove = function(e) {
    var t = this.get(e);
    return t !== void 0 ? (delete this._data[e], --this._count, t) : null;
  }, i.prototype.remove = function(e) {
    return this.contains(e) ? (delete this._data[e], --this._count, !0) : !1;
  }, i.prototype.clear = function() {
    this._data = {}, this._count = 0;
  }, Object.defineProperty(i.prototype, "count", {
    get: function() {
      return this._count;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.forEach = function(e) {
    for (var t in this._data) {
      var r = this._data[t];
      e(t, r);
    }
  }, i.prototype.first = function(e) {
    for (var t in this._data) {
      var r = this._data[t], n = e(t, r);
      if (n)
        return n;
    }
    return null;
  }, i;
}(), ea = function() {
  function i() {
  }
  return i.Eval = function(e, t) {
    return e.match(/\([^()]*\)/g) ? e = e.replace(/\([^()]*\)/g, function(r) {
      return r = r.slice(1, r.length - 1), i._HandleParenthesisContent(r, t);
    }) : e = i._HandleParenthesisContent(e, t), e === "true" ? !0 : e === "false" ? !1 : i.Eval(e, t);
  }, i._HandleParenthesisContent = function(e, t) {
    t = t || function(l) {
      return l === "true";
    };
    var r, n = e.split("||");
    for (var a in n)
      if (Object.prototype.hasOwnProperty.call(n, a)) {
        var s = i._SimplifyNegation(n[a].trim()), o = s.split("&&");
        if (o.length > 1)
          for (var u = 0; u < o.length; ++u) {
            var f = i._SimplifyNegation(o[u].trim());
            if (f !== "true" && f !== "false" ? f[0] === "!" ? r = !t(f.substring(1)) : r = t(f) : r = f === "true", !r) {
              s = "false";
              break;
            }
          }
        if (r || s === "true") {
          r = !0;
          break;
        }
        s !== "true" && s !== "false" ? s[0] === "!" ? r = !t(s.substring(1)) : r = t(s) : r = s === "true";
      }
    return r ? "true" : "false";
  }, i._SimplifyNegation = function(e) {
    return e = e.replace(/^[\s!]+/, function(t) {
      return t = t.replace(/[\s]/g, function() {
        return "";
      }), t.length % 2 ? "!" : "";
    }), e = e.trim(), e === "!true" ? e = "false" : e === "!false" && (e = "true"), e;
  }, i;
}(), le = function() {
  function i() {
  }
  return i.EnableFor = function(e) {
    e._tags = e._tags || {}, e.hasTags = function() {
      return i.HasTags(e);
    }, e.addTags = function(t) {
      return i.AddTagsTo(e, t);
    }, e.removeTags = function(t) {
      return i.RemoveTagsFrom(e, t);
    }, e.matchesTagsQuery = function(t) {
      return i.MatchesQuery(e, t);
    };
  }, i.DisableFor = function(e) {
    delete e._tags, delete e.hasTags, delete e.addTags, delete e.removeTags, delete e.matchesTagsQuery;
  }, i.HasTags = function(e) {
    if (!e._tags)
      return !1;
    var t = e._tags;
    for (var r in t)
      if (Object.prototype.hasOwnProperty.call(t, r))
        return !0;
    return !1;
  }, i.GetTags = function(e, t) {
    if (t === void 0 && (t = !0), !e._tags)
      return null;
    if (t) {
      var r = [];
      for (var n in e._tags)
        Object.prototype.hasOwnProperty.call(e._tags, n) && e._tags[n] === !0 && r.push(n);
      return r.join(" ");
    } else
      return e._tags;
  }, i.AddTagsTo = function(e, t) {
    if (!!t && typeof t == "string") {
      var r = t.split(" ");
      r.forEach(function(n) {
        i._AddTagTo(e, n);
      });
    }
  }, i._AddTagTo = function(e, t) {
    t = t.trim(), !(t === "" || t === "true" || t === "false") && (t.match(/[\s]/) || t.match(/^([!]|([|]|[&]){2})/) || (i.EnableFor(e), e._tags[t] = !0));
  }, i.RemoveTagsFrom = function(e, t) {
    if (!!i.HasTags(e)) {
      var r = t.split(" ");
      for (var n in r)
        i._RemoveTagFrom(e, r[n]);
    }
  }, i._RemoveTagFrom = function(e, t) {
    delete e._tags[t];
  }, i.MatchesQuery = function(e, t) {
    return t === void 0 ? !0 : t === "" ? i.HasTags(e) : ea.Eval(t, function(r) {
      return i.HasTags(e) && e._tags[r];
    });
  }, i;
}(), un = function() {
  function i() {
    this.rootNodes = new Array(), this.cameras = new Array(), this.lights = new Array(), this.meshes = new Array(), this.skeletons = new Array(), this.particleSystems = new Array(), this.animations = [], this.animationGroups = new Array(), this.multiMaterials = new Array(), this.materials = new Array(), this.morphTargetManagers = new Array(), this.geometries = new Array(), this.transformNodes = new Array(), this.actionManagers = new Array(), this.textures = new Array(), this._environmentTexture = null, this.postProcesses = new Array();
  }
  return i.AddParser = function(e, t) {
    this._BabylonFileParsers[e] = t;
  }, i.GetParser = function(e) {
    return this._BabylonFileParsers[e] ? this._BabylonFileParsers[e] : null;
  }, i.AddIndividualParser = function(e, t) {
    this._IndividualBabylonFileParsers[e] = t;
  }, i.GetIndividualParser = function(e) {
    return this._IndividualBabylonFileParsers[e] ? this._IndividualBabylonFileParsers[e] : null;
  }, i.Parse = function(e, t, r, n) {
    for (var a in this._BabylonFileParsers)
      Object.prototype.hasOwnProperty.call(this._BabylonFileParsers, a) && this._BabylonFileParsers[a](e, t, r, n);
  }, Object.defineProperty(i.prototype, "environmentTexture", {
    get: function() {
      return this._environmentTexture;
    },
    set: function(e) {
      this._environmentTexture = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getNodes = function() {
    var e = new Array();
    return e = e.concat(this.meshes), e = e.concat(this.lights), e = e.concat(this.cameras), e = e.concat(this.transformNodes), this.skeletons.forEach(function(t) {
      return e = e.concat(t.bones);
    }), e;
  }, i._BabylonFileParsers = {}, i._IndividualBabylonFileParsers = {}, i;
}(), mr = {}, dr = {}, Ri = function(i, e, t) {
  var r = i();
  le && le.AddTagsTo(r, e.tags);
  var n = ri(r);
  for (var a in n) {
    var s = n[a], o = e[a], u = s.type;
    if (o != null && (a !== "uniqueId" || $.AllowLoadingUniqueId))
      switch (u) {
        case 0:
        case 6:
        case 11:
          r[a] = o;
          break;
        case 1:
          r[a] = t || o.isRenderTarget ? o : o.clone();
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 7:
        case 10:
        case 12:
          r[a] = t ? o : o.clone();
          break;
      }
  }
  return r;
};
function ta(i) {
  var e = i.getClassName();
  return mr[e] || (mr[e] = {}), mr[e];
}
function ri(i) {
  var e = i.getClassName();
  if (dr[e])
    return dr[e];
  dr[e] = {};
  for (var t = dr[e], r = i, n = e; n; ) {
    var a = mr[n];
    for (var s in a)
      t[s] = a[s];
    var o = void 0, u = !1;
    do {
      if (o = Object.getPrototypeOf(r), !o.getClassName) {
        u = !0;
        break;
      }
      if (o.getClassName() !== n)
        break;
      r = o;
    } while (o);
    if (u)
      break;
    n = o.getClassName(), r = o;
  }
  return t;
}
function at(i, e) {
  return function(t, r) {
    var n = ta(t);
    n[r] || (n[r] = { type: i, sourceName: e });
  };
}
function ra(i, e) {
  return e === void 0 && (e = null), function(t, r) {
    var n = e || "_" + r;
    Object.defineProperty(t, r, {
      get: function() {
        return this[n];
      },
      set: function(a) {
        typeof this.equals == "function" && this.equals(a) || this[n] !== a && (this[n] = a, t[i].apply(this));
      },
      enumerable: !0,
      configurable: !0
    });
  };
}
function ne(i, e) {
  return e === void 0 && (e = null), ra(i, e);
}
function P(i) {
  return at(0, i);
}
function je(i) {
  return at(1, i);
}
function At(i) {
  return at(2, i);
}
function jt(i) {
  return at(3, i);
}
function ia(i) {
  return at(4, i);
}
function dt(i) {
  return at(5, i);
}
function na(i) {
  return at(6, i);
}
function aa(i) {
  return at(7, i);
}
function fn(i) {
  return at(8, i);
}
function sa(i) {
  return at(10, i);
}
var $ = function() {
  function i() {
  }
  return i.AppendSerializedAnimations = function(e, t) {
    if (e.animations) {
      t.animations = [];
      for (var r = 0; r < e.animations.length; r++) {
        var n = e.animations[r];
        t.animations.push(n.serialize());
      }
    }
  }, i.Serialize = function(e, t) {
    t || (t = {}), le && (t.tags = le.GetTags(e));
    var r = ri(e);
    for (var n in r) {
      var a = r[n], s = a.sourceName || n, o = a.type, u = e[n];
      if (u != null && (n !== "uniqueId" || i.AllowLoadingUniqueId))
        switch (o) {
          case 0:
            t[s] = u;
            break;
          case 1:
            t[s] = u.serialize();
            break;
          case 2:
            t[s] = u.asArray();
            break;
          case 3:
            t[s] = u.serialize();
            break;
          case 4:
            t[s] = u.asArray();
            break;
          case 5:
            t[s] = u.asArray();
            break;
          case 6:
            t[s] = u.id;
            break;
          case 7:
            t[s] = u.serialize();
            break;
          case 8:
            t[s] = u.asArray();
            break;
          case 9:
            t[s] = u.serialize();
            break;
          case 10:
            t[s] = u.asArray();
            break;
          case 11:
            t[s] = u.id;
            break;
          case 12:
            t[s] = u.asArray();
            break;
        }
    }
    return t;
  }, i.Parse = function(e, t, r, n) {
    n === void 0 && (n = null);
    var a = e();
    n || (n = ""), le && le.AddTagsTo(a, t.tags);
    var s = ri(a);
    for (var o in s) {
      var u = s[o], f = t[u.sourceName || o], l = u.type;
      if (f != null && (o !== "uniqueId" || i.AllowLoadingUniqueId)) {
        var h = a;
        switch (l) {
          case 0:
            h[o] = f;
            break;
          case 1:
            r && (h[o] = i._TextureParser(f, r, n));
            break;
          case 2:
            h[o] = ye.FromArray(f);
            break;
          case 3:
            h[o] = i._FresnelParametersParser(f);
            break;
          case 4:
            h[o] = Ee.FromArray(f);
            break;
          case 5:
            h[o] = b.FromArray(f);
            break;
          case 6:
            r && (h[o] = r.getLastMeshById(f));
            break;
          case 7:
            h[o] = i._ColorCurvesParser(f);
            break;
          case 8:
            h[o] = be.FromArray(f);
            break;
          case 9:
            h[o] = i._ImageProcessingConfigurationParser(f);
            break;
          case 10:
            h[o] = ie.FromArray(f);
            break;
          case 11:
            r && (h[o] = r.getCameraById(f));
            break;
          case 12:
            h[o] = I.FromArray(f);
            break;
        }
      }
    }
    return a;
  }, i.Clone = function(e, t) {
    return Ri(e, t, !1);
  }, i.Instanciate = function(e, t) {
    return Ri(e, t, !0);
  }, i.AllowLoadingUniqueId = !1, i._ImageProcessingConfigurationParser = function(e) {
    throw G("ImageProcessingConfiguration");
  }, i._FresnelParametersParser = function(e) {
    throw G("FresnelParameters");
  }, i._ColorCurvesParser = function(e) {
    throw G("ColorCurves");
  }, i._TextureParser = function(e, t, r) {
    throw G("Texture");
  }, i;
}();
function bt(i, e, t, r) {
  var n = t.value;
  t.value = function() {
    for (var a = [], s = 0; s < arguments.length; s++)
      a[s] = arguments[s];
    var o = n;
    if (typeof _native < "u" && _native[e]) {
      var u = _native[e];
      r ? o = function() {
        for (var f = [], l = 0; l < arguments.length; l++)
          f[l] = arguments[l];
        return r.apply(void 0, f) ? u.apply(void 0, f) : n.apply(void 0, f);
      } : o = u;
    }
    return i[e] = o, o.apply(void 0, a);
  };
}
bt.filter = function(i) {
  return function(e, t, r) {
    return bt(e, t, r, i);
  };
};
var Fr = function() {
  function i(e) {
    if (this._isDirty = !0, this._areLightsDirty = !0, this._areLightsDisposed = !1, this._areAttributesDirty = !0, this._areTexturesDirty = !0, this._areFresnelDirty = !0, this._areMiscDirty = !0, this._arePrePassDirty = !0, this._areImageProcessingDirty = !0, this._normals = !1, this._uvs = !1, this._needNormals = !1, this._needUVs = !1, this._externalProperties = e, e)
      for (var t in e)
        Object.prototype.hasOwnProperty.call(e, t) && this._setDefaultValue(t);
  }
  return Object.defineProperty(i.prototype, "isDirty", {
    get: function() {
      return this._isDirty;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.markAsProcessed = function() {
    this._isDirty = !1, this._areAttributesDirty = !1, this._areTexturesDirty = !1, this._areFresnelDirty = !1, this._areLightsDirty = !1, this._areLightsDisposed = !1, this._areMiscDirty = !1, this._arePrePassDirty = !1, this._areImageProcessingDirty = !1;
  }, i.prototype.markAsUnprocessed = function() {
    this._isDirty = !0;
  }, i.prototype.markAllAsDirty = function() {
    this._areTexturesDirty = !0, this._areAttributesDirty = !0, this._areLightsDirty = !0, this._areFresnelDirty = !0, this._areMiscDirty = !0, this._areImageProcessingDirty = !0, this._isDirty = !0;
  }, i.prototype.markAsImageProcessingDirty = function() {
    this._areImageProcessingDirty = !0, this._isDirty = !0;
  }, i.prototype.markAsLightDirty = function(e) {
    e === void 0 && (e = !1), this._areLightsDirty = !0, this._areLightsDisposed = this._areLightsDisposed || e, this._isDirty = !0;
  }, i.prototype.markAsAttributesDirty = function() {
    this._areAttributesDirty = !0, this._isDirty = !0;
  }, i.prototype.markAsTexturesDirty = function() {
    this._areTexturesDirty = !0, this._isDirty = !0;
  }, i.prototype.markAsFresnelDirty = function() {
    this._areFresnelDirty = !0, this._isDirty = !0;
  }, i.prototype.markAsMiscDirty = function() {
    this._areMiscDirty = !0, this._isDirty = !0;
  }, i.prototype.markAsPrePassDirty = function() {
    this._arePrePassDirty = !0, this._isDirty = !0;
  }, i.prototype.rebuild = function() {
    this._keys = [];
    for (var e = 0, t = Object.keys(this); e < t.length; e++) {
      var r = t[e];
      r[0] !== "_" && this._keys.push(r);
    }
    if (this._externalProperties)
      for (var n in this._externalProperties)
        this._keys.indexOf(n) === -1 && this._keys.push(n);
  }, i.prototype.isEqual = function(e) {
    if (this._keys.length !== e._keys.length)
      return !1;
    for (var t = 0; t < this._keys.length; t++) {
      var r = this._keys[t];
      if (this[r] !== e[r])
        return !1;
    }
    return !0;
  }, i.prototype.cloneTo = function(e) {
    this._keys.length !== e._keys.length && (e._keys = this._keys.slice(0));
    for (var t = 0; t < this._keys.length; t++) {
      var r = this._keys[t];
      e[r] = this[r];
    }
  }, i.prototype.reset = function() {
    var e = this;
    this._keys.forEach(function(t) {
      return e._setDefaultValue(t);
    });
  }, i.prototype._setDefaultValue = function(e) {
    var t, r, n, a, s, o = (n = (r = (t = this._externalProperties) === null || t === void 0 ? void 0 : t[e]) === null || r === void 0 ? void 0 : r.type) !== null && n !== void 0 ? n : typeof this[e], u = (s = (a = this._externalProperties) === null || a === void 0 ? void 0 : a[e]) === null || s === void 0 ? void 0 : s.default;
    switch (o) {
      case "number":
        this[e] = u != null ? u : 0;
        break;
      case "string":
        this[e] = u != null ? u : "";
        break;
      default:
        this[e] = u != null ? u : !1;
        break;
    }
  }, i.prototype.toString = function() {
    for (var e = "", t = 0; t < this._keys.length; t++) {
      var r = this._keys[t], n = this[r], a = typeof n;
      switch (a) {
        case "number":
        case "string":
          e += "#define " + r + " " + n + `
`;
          break;
        default:
          n && (e += "#define " + r + `
`);
          break;
      }
    }
    return e;
  }, i;
}(), yr = function() {
  function i() {
    this._dirty = !0, this._tempColor = new be(0, 0, 0, 0), this._globalCurve = new be(0, 0, 0, 0), this._highlightsCurve = new be(0, 0, 0, 0), this._midtonesCurve = new be(0, 0, 0, 0), this._shadowsCurve = new be(0, 0, 0, 0), this._positiveCurve = new be(0, 0, 0, 0), this._negativeCurve = new be(0, 0, 0, 0), this._globalHue = 30, this._globalDensity = 0, this._globalSaturation = 0, this._globalExposure = 0, this._highlightsHue = 30, this._highlightsDensity = 0, this._highlightsSaturation = 0, this._highlightsExposure = 0, this._midtonesHue = 30, this._midtonesDensity = 0, this._midtonesSaturation = 0, this._midtonesExposure = 0, this._shadowsHue = 30, this._shadowsDensity = 0, this._shadowsSaturation = 0, this._shadowsExposure = 0;
  }
  return Object.defineProperty(i.prototype, "globalHue", {
    get: function() {
      return this._globalHue;
    },
    set: function(e) {
      this._globalHue = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "globalDensity", {
    get: function() {
      return this._globalDensity;
    },
    set: function(e) {
      this._globalDensity = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "globalSaturation", {
    get: function() {
      return this._globalSaturation;
    },
    set: function(e) {
      this._globalSaturation = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "globalExposure", {
    get: function() {
      return this._globalExposure;
    },
    set: function(e) {
      this._globalExposure = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "highlightsHue", {
    get: function() {
      return this._highlightsHue;
    },
    set: function(e) {
      this._highlightsHue = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "highlightsDensity", {
    get: function() {
      return this._highlightsDensity;
    },
    set: function(e) {
      this._highlightsDensity = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "highlightsSaturation", {
    get: function() {
      return this._highlightsSaturation;
    },
    set: function(e) {
      this._highlightsSaturation = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "highlightsExposure", {
    get: function() {
      return this._highlightsExposure;
    },
    set: function(e) {
      this._highlightsExposure = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "midtonesHue", {
    get: function() {
      return this._midtonesHue;
    },
    set: function(e) {
      this._midtonesHue = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "midtonesDensity", {
    get: function() {
      return this._midtonesDensity;
    },
    set: function(e) {
      this._midtonesDensity = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "midtonesSaturation", {
    get: function() {
      return this._midtonesSaturation;
    },
    set: function(e) {
      this._midtonesSaturation = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "midtonesExposure", {
    get: function() {
      return this._midtonesExposure;
    },
    set: function(e) {
      this._midtonesExposure = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "shadowsHue", {
    get: function() {
      return this._shadowsHue;
    },
    set: function(e) {
      this._shadowsHue = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "shadowsDensity", {
    get: function() {
      return this._shadowsDensity;
    },
    set: function(e) {
      this._shadowsDensity = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "shadowsSaturation", {
    get: function() {
      return this._shadowsSaturation;
    },
    set: function(e) {
      this._shadowsSaturation = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "shadowsExposure", {
    get: function() {
      return this._shadowsExposure;
    },
    set: function(e) {
      this._shadowsExposure = e, this._dirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getClassName = function() {
    return "ColorCurves";
  }, i.Bind = function(e, t, r, n, a) {
    r === void 0 && (r = "vCameraColorCurvePositive"), n === void 0 && (n = "vCameraColorCurveNeutral"), a === void 0 && (a = "vCameraColorCurveNegative"), e._dirty && (e._dirty = !1, e._getColorGradingDataToRef(e._globalHue, e._globalDensity, e._globalSaturation, e._globalExposure, e._globalCurve), e._getColorGradingDataToRef(e._highlightsHue, e._highlightsDensity, e._highlightsSaturation, e._highlightsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._highlightsCurve), e._getColorGradingDataToRef(e._midtonesHue, e._midtonesDensity, e._midtonesSaturation, e._midtonesExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._midtonesCurve), e._getColorGradingDataToRef(e._shadowsHue, e._shadowsDensity, e._shadowsSaturation, e._shadowsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._shadowsCurve), e._highlightsCurve.subtractToRef(e._midtonesCurve, e._positiveCurve), e._midtonesCurve.subtractToRef(e._shadowsCurve, e._negativeCurve)), t && (t.setFloat4(r, e._positiveCurve.r, e._positiveCurve.g, e._positiveCurve.b, e._positiveCurve.a), t.setFloat4(n, e._midtonesCurve.r, e._midtonesCurve.g, e._midtonesCurve.b, e._midtonesCurve.a), t.setFloat4(a, e._negativeCurve.r, e._negativeCurve.g, e._negativeCurve.b, e._negativeCurve.a));
  }, i.PrepareUniforms = function(e) {
    e.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative");
  }, i.prototype._getColorGradingDataToRef = function(e, t, r, n, a) {
    e != null && (e = i._Clamp(e, 0, 360), t = i._Clamp(t, -100, 100), r = i._Clamp(r, -100, 100), n = i._Clamp(n, -100, 100), t = i._ApplyColorGradingSliderNonlinear(t), t *= 0.5, n = i._ApplyColorGradingSliderNonlinear(n), t < 0 && (t *= -1, e = (e + 180) % 360), i._FromHSBToRef(e, t, 50 + 0.25 * n, a), a.scaleToRef(2, a), a.a = 1 + 0.01 * r);
  }, i._ApplyColorGradingSliderNonlinear = function(e) {
    e /= 100;
    var t = Math.abs(e);
    return t = Math.pow(t, 2), e < 0 && (t *= -1), t *= 100, t;
  }, i._FromHSBToRef = function(e, t, r, n) {
    var a = i._Clamp(e, 0, 360), s = i._Clamp(t / 100, 0, 1), o = i._Clamp(r / 100, 0, 1);
    if (s === 0)
      n.r = o, n.g = o, n.b = o;
    else {
      a /= 60;
      var u = Math.floor(a), f = a - u, l = o * (1 - s), h = o * (1 - s * f), c = o * (1 - s * (1 - f));
      switch (u) {
        case 0:
          n.r = o, n.g = c, n.b = l;
          break;
        case 1:
          n.r = h, n.g = o, n.b = l;
          break;
        case 2:
          n.r = l, n.g = o, n.b = c;
          break;
        case 3:
          n.r = l, n.g = h, n.b = o;
          break;
        case 4:
          n.r = c, n.g = l, n.b = o;
          break;
        default:
          n.r = o, n.g = l, n.b = h;
          break;
      }
    }
    n.a = 1;
  }, i._Clamp = function(e, t, r) {
    return Math.min(Math.max(e, t), r);
  }, i.prototype.clone = function() {
    return $.Clone(function() {
      return new i();
    }, this);
  }, i.prototype.serialize = function() {
    return $.Serialize(this);
  }, i.Parse = function(e) {
    return $.Parse(function() {
      return new i();
    }, e, null, null);
  }, T([
    P()
  ], i.prototype, "_globalHue", void 0), T([
    P()
  ], i.prototype, "_globalDensity", void 0), T([
    P()
  ], i.prototype, "_globalSaturation", void 0), T([
    P()
  ], i.prototype, "_globalExposure", void 0), T([
    P()
  ], i.prototype, "_highlightsHue", void 0), T([
    P()
  ], i.prototype, "_highlightsDensity", void 0), T([
    P()
  ], i.prototype, "_highlightsSaturation", void 0), T([
    P()
  ], i.prototype, "_highlightsExposure", void 0), T([
    P()
  ], i.prototype, "_midtonesHue", void 0), T([
    P()
  ], i.prototype, "_midtonesDensity", void 0), T([
    P()
  ], i.prototype, "_midtonesSaturation", void 0), T([
    P()
  ], i.prototype, "_midtonesExposure", void 0), i;
}();
$._ColorCurvesParser = yr.Parse;
(function(i) {
  K(e, i);
  function e() {
    var t = i.call(this) || this;
    return t.IMAGEPROCESSING = !1, t.VIGNETTE = !1, t.VIGNETTEBLENDMODEMULTIPLY = !1, t.VIGNETTEBLENDMODEOPAQUE = !1, t.TONEMAPPING = !1, t.TONEMAPPING_ACES = !1, t.CONTRAST = !1, t.COLORCURVES = !1, t.COLORGRADING = !1, t.COLORGRADING3D = !1, t.SAMPLER3DGREENDEPTH = !1, t.SAMPLER3DBGRMAP = !1, t.IMAGEPROCESSINGPOSTPROCESS = !1, t.EXPOSURE = !1, t.SKIPFINALCOLORCLAMP = !1, t.rebuild(), t;
  }
  return e;
})(Fr);
var Vt = function() {
  function i() {
    this.colorCurves = new yr(), this._colorCurvesEnabled = !1, this._colorGradingEnabled = !1, this._colorGradingWithGreenDepth = !0, this._colorGradingBGR = !0, this._exposure = 1, this._toneMappingEnabled = !1, this._toneMappingType = i.TONEMAPPING_STANDARD, this._contrast = 1, this.vignetteStretch = 0, this.vignetteCentreX = 0, this.vignetteCentreY = 0, this.vignetteWeight = 1.5, this.vignetteColor = new be(0, 0, 0, 0), this.vignetteCameraFov = 0.5, this._vignetteBlendMode = i.VIGNETTEMODE_MULTIPLY, this._vignetteEnabled = !1, this._skipFinalColorClamp = !1, this._applyByPostProcess = !1, this._isEnabled = !0, this.onUpdateParameters = new O();
  }
  return Object.defineProperty(i.prototype, "colorCurvesEnabled", {
    get: function() {
      return this._colorCurvesEnabled;
    },
    set: function(e) {
      this._colorCurvesEnabled !== e && (this._colorCurvesEnabled = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "colorGradingTexture", {
    get: function() {
      return this._colorGradingTexture;
    },
    set: function(e) {
      this._colorGradingTexture !== e && (this._colorGradingTexture = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "colorGradingEnabled", {
    get: function() {
      return this._colorGradingEnabled;
    },
    set: function(e) {
      this._colorGradingEnabled !== e && (this._colorGradingEnabled = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "colorGradingWithGreenDepth", {
    get: function() {
      return this._colorGradingWithGreenDepth;
    },
    set: function(e) {
      this._colorGradingWithGreenDepth !== e && (this._colorGradingWithGreenDepth = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "colorGradingBGR", {
    get: function() {
      return this._colorGradingBGR;
    },
    set: function(e) {
      this._colorGradingBGR !== e && (this._colorGradingBGR = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "exposure", {
    get: function() {
      return this._exposure;
    },
    set: function(e) {
      this._exposure !== e && (this._exposure = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "toneMappingEnabled", {
    get: function() {
      return this._toneMappingEnabled;
    },
    set: function(e) {
      this._toneMappingEnabled !== e && (this._toneMappingEnabled = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "toneMappingType", {
    get: function() {
      return this._toneMappingType;
    },
    set: function(e) {
      this._toneMappingType !== e && (this._toneMappingType = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "contrast", {
    get: function() {
      return this._contrast;
    },
    set: function(e) {
      this._contrast !== e && (this._contrast = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "vignetteBlendMode", {
    get: function() {
      return this._vignetteBlendMode;
    },
    set: function(e) {
      this._vignetteBlendMode !== e && (this._vignetteBlendMode = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "vignetteEnabled", {
    get: function() {
      return this._vignetteEnabled;
    },
    set: function(e) {
      this._vignetteEnabled !== e && (this._vignetteEnabled = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "skipFinalColorClamp", {
    get: function() {
      return this._skipFinalColorClamp;
    },
    set: function(e) {
      this._skipFinalColorClamp !== e && (this._skipFinalColorClamp = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "applyByPostProcess", {
    get: function() {
      return this._applyByPostProcess;
    },
    set: function(e) {
      this._applyByPostProcess !== e && (this._applyByPostProcess = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "isEnabled", {
    get: function() {
      return this._isEnabled;
    },
    set: function(e) {
      this._isEnabled !== e && (this._isEnabled = e, this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._updateParameters = function() {
    this.onUpdateParameters.notifyObservers(this);
  }, i.prototype.getClassName = function() {
    return "ImageProcessingConfiguration";
  }, i.PrepareUniforms = function(e, t) {
    t.EXPOSURE && e.push("exposureLinear"), t.CONTRAST && e.push("contrast"), t.COLORGRADING && e.push("colorTransformSettings"), t.VIGNETTE && (e.push("vInverseScreenSize"), e.push("vignetteSettings1"), e.push("vignetteSettings2")), t.COLORCURVES && yr.PrepareUniforms(e);
  }, i.PrepareSamplers = function(e, t) {
    t.COLORGRADING && e.push("txColorTransform");
  }, i.prototype.prepareDefines = function(e, t) {
    if (t === void 0 && (t = !1), t !== this.applyByPostProcess || !this._isEnabled) {
      e.VIGNETTE = !1, e.TONEMAPPING = !1, e.TONEMAPPING_ACES = !1, e.CONTRAST = !1, e.EXPOSURE = !1, e.COLORCURVES = !1, e.COLORGRADING = !1, e.COLORGRADING3D = !1, e.IMAGEPROCESSING = !1, e.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp, e.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;
      return;
    }
    switch (e.VIGNETTE = this.vignetteEnabled, e.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === i._VIGNETTEMODE_MULTIPLY, e.VIGNETTEBLENDMODEOPAQUE = !e.VIGNETTEBLENDMODEMULTIPLY, e.TONEMAPPING = this.toneMappingEnabled, this._toneMappingType) {
      case i.TONEMAPPING_ACES:
        e.TONEMAPPING_ACES = !0;
        break;
      default:
        e.TONEMAPPING_ACES = !1;
        break;
    }
    e.CONTRAST = this.contrast !== 1, e.EXPOSURE = this.exposure !== 1, e.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves, e.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture, e.COLORGRADING ? e.COLORGRADING3D = this.colorGradingTexture.is3D : e.COLORGRADING3D = !1, e.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth, e.SAMPLER3DBGRMAP = this.colorGradingBGR, e.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess, e.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp, e.IMAGEPROCESSING = e.VIGNETTE || e.TONEMAPPING || e.CONTRAST || e.EXPOSURE || e.COLORCURVES || e.COLORGRADING;
  }, i.prototype.isReady = function() {
    return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();
  }, i.prototype.bind = function(e, t) {
    if (this._colorCurvesEnabled && this.colorCurves && yr.Bind(this.colorCurves, e), this._vignetteEnabled) {
      var r = 1 / e.getEngine().getRenderWidth(), n = 1 / e.getEngine().getRenderHeight();
      e.setFloat2("vInverseScreenSize", r, n);
      var a = t != null ? t : n / r, s = Math.tan(this.vignetteCameraFov * 0.5), o = s * a, u = Math.sqrt(o * s);
      o = de.Mix(o, u, this.vignetteStretch), s = de.Mix(s, u, this.vignetteStretch), e.setFloat4("vignetteSettings1", o, s, -o * this.vignetteCentreX, -s * this.vignetteCentreY);
      var f = -2 * this.vignetteWeight;
      e.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, f);
    }
    if (e.setFloat("exposureLinear", this.exposure), e.setFloat("contrast", this.contrast), this.colorGradingTexture) {
      e.setTexture("txColorTransform", this.colorGradingTexture);
      var l = this.colorGradingTexture.getSize().height;
      e.setFloat4(
        "colorTransformSettings",
        (l - 1) / l,
        0.5 / l,
        l,
        this.colorGradingTexture.level
      );
    }
  }, i.prototype.clone = function() {
    return $.Clone(function() {
      return new i();
    }, this);
  }, i.prototype.serialize = function() {
    return $.Serialize(this);
  }, i.Parse = function(e) {
    return $.Parse(function() {
      return new i();
    }, e, null, null);
  }, Object.defineProperty(i, "VIGNETTEMODE_MULTIPLY", {
    get: function() {
      return this._VIGNETTEMODE_MULTIPLY;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "VIGNETTEMODE_OPAQUE", {
    get: function() {
      return this._VIGNETTEMODE_OPAQUE;
    },
    enumerable: !1,
    configurable: !0
  }), i.TONEMAPPING_STANDARD = 0, i.TONEMAPPING_ACES = 1, i._VIGNETTEMODE_MULTIPLY = 0, i._VIGNETTEMODE_OPAQUE = 1, T([
    aa()
  ], i.prototype, "colorCurves", void 0), T([
    P()
  ], i.prototype, "_colorCurvesEnabled", void 0), T([
    je("colorGradingTexture")
  ], i.prototype, "_colorGradingTexture", void 0), T([
    P()
  ], i.prototype, "_colorGradingEnabled", void 0), T([
    P()
  ], i.prototype, "_colorGradingWithGreenDepth", void 0), T([
    P()
  ], i.prototype, "_colorGradingBGR", void 0), T([
    P()
  ], i.prototype, "_exposure", void 0), T([
    P()
  ], i.prototype, "_toneMappingEnabled", void 0), T([
    P()
  ], i.prototype, "_toneMappingType", void 0), T([
    P()
  ], i.prototype, "_contrast", void 0), T([
    P()
  ], i.prototype, "vignetteStretch", void 0), T([
    P()
  ], i.prototype, "vignetteCentreX", void 0), T([
    P()
  ], i.prototype, "vignetteCentreY", void 0), T([
    P()
  ], i.prototype, "vignetteWeight", void 0), T([
    fn()
  ], i.prototype, "vignetteColor", void 0), T([
    P()
  ], i.prototype, "vignetteCameraFov", void 0), T([
    P()
  ], i.prototype, "_vignetteBlendMode", void 0), T([
    P()
  ], i.prototype, "_vignetteEnabled", void 0), T([
    P()
  ], i.prototype, "_skipFinalColorClamp", void 0), T([
    P()
  ], i.prototype, "_applyByPostProcess", void 0), T([
    P()
  ], i.prototype, "_isEnabled", void 0), i;
}();
$._ImageProcessingConfigurationParser = Vt.Parse;
ue.prototype.createUniformBuffer = function(i) {
  var e = this._gl.createBuffer();
  if (!e)
    throw new Error("Unable to create uniform buffer");
  var t = new $t(e);
  return this.bindUniformBuffer(t), i instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, i, this._gl.STATIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(i), this._gl.STATIC_DRAW), this.bindUniformBuffer(null), t.references = 1, t;
};
ue.prototype.createDynamicUniformBuffer = function(i) {
  var e = this._gl.createBuffer();
  if (!e)
    throw new Error("Unable to create dynamic uniform buffer");
  var t = new $t(e);
  return this.bindUniformBuffer(t), i instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, i, this._gl.DYNAMIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(i), this._gl.DYNAMIC_DRAW), this.bindUniformBuffer(null), t.references = 1, t;
};
ue.prototype.updateUniformBuffer = function(i, e, t, r) {
  this.bindUniformBuffer(i), t === void 0 && (t = 0), r === void 0 ? e instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, t, e) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, t, new Float32Array(e)) : e instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, e.subarray(t, t + r)) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(e).subarray(t, t + r)), this.bindUniformBuffer(null);
};
ue.prototype.bindUniformBuffer = function(i) {
  this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, i ? i.underlyingResource : null);
};
ue.prototype.bindUniformBufferBase = function(i, e, t) {
  this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, e, i ? i.underlyingResource : null);
};
ue.prototype.bindUniformBlock = function(i, e, t) {
  var r = i.program, n = this._gl.getUniformBlockIndex(r, e);
  n !== 4294967295 && this._gl.uniformBlockBinding(r, n, t);
};
var wr = function() {
  function i(e, t, r, n, a) {
    a === void 0 && (a = !1), this._valueCache = {}, this._engine = e, this._noUBO = !e.supportsUniformBuffers || a, this._dynamic = r, this._name = n != null ? n : "no-name", this._data = t || [], this._uniformLocations = {}, this._uniformSizes = {}, this._uniformArraySizes = {}, this._uniformLocationPointer = 0, this._needSync = !1, this._engine._features.trackUbosInFrame && (this._buffers = [], this._bufferIndex = -1, this._createBufferOnWrite = !1, this._currentFrameId = 0), this._noUBO ? (this.updateMatrix3x3 = this._updateMatrix3x3ForEffect, this.updateMatrix2x2 = this._updateMatrix2x2ForEffect, this.updateFloat = this._updateFloatForEffect, this.updateFloat2 = this._updateFloat2ForEffect, this.updateFloat3 = this._updateFloat3ForEffect, this.updateFloat4 = this._updateFloat4ForEffect, this.updateFloatArray = this._updateFloatArrayForEffect, this.updateArray = this._updateArrayForEffect, this.updateIntArray = this._updateIntArrayForEffect, this.updateMatrix = this._updateMatrixForEffect, this.updateMatrices = this._updateMatricesForEffect, this.updateVector3 = this._updateVector3ForEffect, this.updateVector4 = this._updateVector4ForEffect, this.updateColor3 = this._updateColor3ForEffect, this.updateColor4 = this._updateColor4ForEffect, this.updateDirectColor4 = this._updateDirectColor4ForEffect, this.updateInt = this._updateIntForEffect, this.updateInt2 = this._updateInt2ForEffect, this.updateInt3 = this._updateInt3ForEffect, this.updateInt4 = this._updateInt4ForEffect) : (this._engine._uniformBuffers.push(this), this.updateMatrix3x3 = this._updateMatrix3x3ForUniform, this.updateMatrix2x2 = this._updateMatrix2x2ForUniform, this.updateFloat = this._updateFloatForUniform, this.updateFloat2 = this._updateFloat2ForUniform, this.updateFloat3 = this._updateFloat3ForUniform, this.updateFloat4 = this._updateFloat4ForUniform, this.updateFloatArray = this._updateFloatArrayForUniform, this.updateArray = this._updateArrayForUniform, this.updateIntArray = this._updateIntArrayForUniform, this.updateMatrix = this._updateMatrixForUniform, this.updateMatrices = this._updateMatricesForUniform, this.updateVector3 = this._updateVector3ForUniform, this.updateVector4 = this._updateVector4ForUniform, this.updateColor3 = this._updateColor3ForUniform, this.updateColor4 = this._updateColor4ForUniform, this.updateDirectColor4 = this._updateDirectColor4ForUniform, this.updateInt = this._updateIntForUniform, this.updateInt2 = this._updateInt2ForUniform, this.updateInt3 = this._updateInt3ForUniform, this.updateInt4 = this._updateInt4ForUniform);
  }
  return Object.defineProperty(i.prototype, "useUbo", {
    get: function() {
      return !this._noUBO;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "isSync", {
    get: function() {
      return !this._needSync;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.isDynamic = function() {
    return this._dynamic !== void 0;
  }, i.prototype.getData = function() {
    return this._bufferData;
  }, i.prototype.getBuffer = function() {
    return this._buffer;
  }, i.prototype._fillAlignment = function(e) {
    var t;
    if (e <= 2 ? t = e : t = 4, this._uniformLocationPointer % t !== 0) {
      var r = this._uniformLocationPointer;
      this._uniformLocationPointer += t - this._uniformLocationPointer % t;
      for (var n = this._uniformLocationPointer - r, a = 0; a < n; a++)
        this._data.push(0);
    }
  }, i.prototype.addUniform = function(e, t, r) {
    if (r === void 0 && (r = 0), !this._noUBO && this._uniformLocations[e] === void 0) {
      var n;
      if (r > 0) {
        if (t instanceof Array)
          throw "addUniform should not be use with Array in UBO: " + e;
        if (this._fillAlignment(4), this._uniformArraySizes[e] = { strideSize: t, arraySize: r }, t == 16)
          t = t * r;
        else {
          var a = 4 - t, s = a * r;
          t = t * r + s;
        }
        n = [];
        for (var o = 0; o < t; o++)
          n.push(0);
      } else {
        if (t instanceof Array)
          n = t, t = n.length;
        else {
          t = t, n = [];
          for (var o = 0; o < t; o++)
            n.push(0);
        }
        this._fillAlignment(t);
      }
      this._uniformSizes[e] = t, this._uniformLocations[e] = this._uniformLocationPointer, this._uniformLocationPointer += t;
      for (var o = 0; o < t; o++)
        this._data.push(n[o]);
      this._needSync = !0;
    }
  }, i.prototype.addMatrix = function(e, t) {
    this.addUniform(e, Array.prototype.slice.call(t.toArray()));
  }, i.prototype.addFloat2 = function(e, t, r) {
    var n = [t, r];
    this.addUniform(e, n);
  }, i.prototype.addFloat3 = function(e, t, r, n) {
    var a = [t, r, n];
    this.addUniform(e, a);
  }, i.prototype.addColor3 = function(e, t) {
    var r = [t.r, t.g, t.b];
    this.addUniform(e, r);
  }, i.prototype.addColor4 = function(e, t, r) {
    var n = [t.r, t.g, t.b, r];
    this.addUniform(e, n);
  }, i.prototype.addVector3 = function(e, t) {
    var r = [t.x, t.y, t.z];
    this.addUniform(e, r);
  }, i.prototype.addMatrix3x3 = function(e) {
    this.addUniform(e, 12);
  }, i.prototype.addMatrix2x2 = function(e) {
    this.addUniform(e, 8);
  }, i.prototype.create = function() {
    this._noUBO || this._buffer || (this._fillAlignment(4), this._bufferData = new Float32Array(this._data), this._rebuild(), this._needSync = !0);
  }, i.prototype._rebuild = function() {
    this._noUBO || !this._bufferData || (this._dynamic ? this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData) : this._buffer = this._engine.createUniformBuffer(this._bufferData), this._engine._features.trackUbosInFrame && (this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : void 0]), this._bufferIndex = this._buffers.length - 1, this._createBufferOnWrite = !1));
  }, Object.defineProperty(i.prototype, "_numBuffers", {
    get: function() {
      return this._buffers.length;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "_indexBuffer", {
    get: function() {
      return this._bufferIndex;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "name", {
    get: function() {
      return this._name;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._buffersEqual = function(e, t) {
    for (var r = 0; r < e.length; ++r)
      if (e[r] !== t[r])
        return !1;
    return !0;
  }, i.prototype._copyBuffer = function(e, t) {
    for (var r = 0; r < e.length; ++r)
      t[r] = e[r];
  }, i.prototype.update = function() {
    if (!this._noUBO) {
      if (this.bindUniformBuffer(), !this._buffer) {
        this.create();
        return;
      }
      if (!this._dynamic && !this._needSync) {
        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
        return;
      }
      if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1])
        if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) {
          this._needSync = !1, this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
          return;
        } else
          this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]);
      this._engine.updateUniformBuffer(this._buffer, this._bufferData), this._engine._features._collectUbosUpdatedInFrame && (i._UpdatedUbosInFrame[this._name] || (i._UpdatedUbosInFrame[this._name] = 0), i._UpdatedUbosInFrame[this._name]++), this._needSync = !1, this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
    }
  }, i.prototype._createNewBuffer = function() {
    this._bufferIndex + 1 < this._buffers.length ? (this._bufferIndex++, this._buffer = this._buffers[this._bufferIndex][0], this._createBufferOnWrite = !1, this._needSync = !0) : this._rebuild();
  }, i.prototype._checkNewFrame = function() {
    this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId && (this._currentFrameId = this._engine.frameId, this._createBufferOnWrite = !1, this._buffers && this._buffers.length > 0 ? (this._needSync = this._bufferIndex !== 0, this._bufferIndex = 0, this._buffer = this._buffers[this._bufferIndex][0]) : this._bufferIndex = -1);
  }, i.prototype.updateUniform = function(e, t, r) {
    this._checkNewFrame();
    var n = this._uniformLocations[e];
    if (n === void 0) {
      if (this._buffer) {
        k.Error("Cannot add an uniform after UBO has been created.");
        return;
      }
      this.addUniform(e, r), n = this._uniformLocations[e];
    }
    if (this._buffer || this.create(), this._dynamic)
      for (var s = 0; s < r; s++)
        this._bufferData[n + s] = t[s];
    else {
      for (var a = !1, s = 0; s < r; s++)
        (r === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[n + s] !== de.FloatRound(t[s])) && (a = !0, this._createBufferOnWrite && this._createNewBuffer(), this._bufferData[n + s] = t[s]);
      this._needSync = this._needSync || a;
    }
  }, i.prototype.updateUniformArray = function(e, t, r) {
    this._checkNewFrame();
    var n = this._uniformLocations[e];
    if (n === void 0) {
      k.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform.");
      return;
    }
    this._buffer || this.create();
    var a = this._uniformArraySizes[e];
    if (this._dynamic)
      for (var f = 0; f < r; f++)
        this._bufferData[n + f] = t[f];
    else {
      for (var s = !1, o = 0, u = 0, f = 0; f < r; f++)
        if (this._bufferData[n + u * 4 + o] !== de.FloatRound(t[f]) && (s = !0, this._createBufferOnWrite && this._createNewBuffer(), this._bufferData[n + u * 4 + o] = t[f]), o++, o === a.strideSize) {
          for (; o < 4; o++)
            this._bufferData[n + u * 4 + o] = 0;
          o = 0, u++;
        }
      this._needSync = this._needSync || s;
    }
  }, i.prototype._cacheMatrix = function(e, t) {
    this._checkNewFrame();
    var r = this._valueCache[e], n = t.updateFlag;
    return r !== void 0 && r === n ? !1 : (this._valueCache[e] = n, !0);
  }, i.prototype._updateMatrix3x3ForUniform = function(e, t) {
    for (var r = 0; r < 3; r++)
      i._TempBuffer[r * 4] = t[r * 3], i._TempBuffer[r * 4 + 1] = t[r * 3 + 1], i._TempBuffer[r * 4 + 2] = t[r * 3 + 2], i._TempBuffer[r * 4 + 3] = 0;
    this.updateUniform(e, i._TempBuffer, 12);
  }, i.prototype._updateMatrix3x3ForEffect = function(e, t) {
    this._currentEffect.setMatrix3x3(e, t);
  }, i.prototype._updateMatrix2x2ForEffect = function(e, t) {
    this._currentEffect.setMatrix2x2(e, t);
  }, i.prototype._updateMatrix2x2ForUniform = function(e, t) {
    for (var r = 0; r < 2; r++)
      i._TempBuffer[r * 4] = t[r * 2], i._TempBuffer[r * 4 + 1] = t[r * 2 + 1], i._TempBuffer[r * 4 + 2] = 0, i._TempBuffer[r * 4 + 3] = 0;
    this.updateUniform(e, i._TempBuffer, 8);
  }, i.prototype._updateFloatForEffect = function(e, t) {
    this._currentEffect.setFloat(e, t);
  }, i.prototype._updateFloatForUniform = function(e, t) {
    i._TempBuffer[0] = t, this.updateUniform(e, i._TempBuffer, 1);
  }, i.prototype._updateFloat2ForEffect = function(e, t, r, n) {
    n === void 0 && (n = ""), this._currentEffect.setFloat2(e + n, t, r);
  }, i.prototype._updateFloat2ForUniform = function(e, t, r) {
    i._TempBuffer[0] = t, i._TempBuffer[1] = r, this.updateUniform(e, i._TempBuffer, 2);
  }, i.prototype._updateFloat3ForEffect = function(e, t, r, n, a) {
    a === void 0 && (a = ""), this._currentEffect.setFloat3(e + a, t, r, n);
  }, i.prototype._updateFloat3ForUniform = function(e, t, r, n) {
    i._TempBuffer[0] = t, i._TempBuffer[1] = r, i._TempBuffer[2] = n, this.updateUniform(e, i._TempBuffer, 3);
  }, i.prototype._updateFloat4ForEffect = function(e, t, r, n, a, s) {
    s === void 0 && (s = ""), this._currentEffect.setFloat4(e + s, t, r, n, a);
  }, i.prototype._updateFloat4ForUniform = function(e, t, r, n, a) {
    i._TempBuffer[0] = t, i._TempBuffer[1] = r, i._TempBuffer[2] = n, i._TempBuffer[3] = a, this.updateUniform(e, i._TempBuffer, 4);
  }, i.prototype._updateFloatArrayForEffect = function(e, t) {
    this._currentEffect.setFloatArray(e, t);
  }, i.prototype._updateFloatArrayForUniform = function(e, t) {
    this.updateUniformArray(e, t, t.length);
  }, i.prototype._updateArrayForEffect = function(e, t) {
    this._currentEffect.setArray(e, t);
  }, i.prototype._updateArrayForUniform = function(e, t) {
    this.updateUniformArray(e, t, t.length);
  }, i.prototype._updateIntArrayForEffect = function(e, t) {
    this._currentEffect.setIntArray(e, t);
  }, i.prototype._updateIntArrayForUniform = function(e, t) {
    i._TempBufferInt32View.set(t), this.updateUniformArray(e, i._TempBuffer, t.length);
  }, i.prototype._updateMatrixForEffect = function(e, t) {
    this._currentEffect.setMatrix(e, t);
  }, i.prototype._updateMatrixForUniform = function(e, t) {
    this._cacheMatrix(e, t) && this.updateUniform(e, t.toArray(), 16);
  }, i.prototype._updateMatricesForEffect = function(e, t) {
    this._currentEffect.setMatrices(e, t);
  }, i.prototype._updateMatricesForUniform = function(e, t) {
    this.updateUniform(e, t, t.length);
  }, i.prototype._updateVector3ForEffect = function(e, t) {
    this._currentEffect.setVector3(e, t);
  }, i.prototype._updateVector3ForUniform = function(e, t) {
    i._TempBuffer[0] = t.x, i._TempBuffer[1] = t.y, i._TempBuffer[2] = t.z, this.updateUniform(e, i._TempBuffer, 3);
  }, i.prototype._updateVector4ForEffect = function(e, t) {
    this._currentEffect.setVector4(e, t);
  }, i.prototype._updateVector4ForUniform = function(e, t) {
    i._TempBuffer[0] = t.x, i._TempBuffer[1] = t.y, i._TempBuffer[2] = t.z, i._TempBuffer[3] = t.w, this.updateUniform(e, i._TempBuffer, 4);
  }, i.prototype._updateColor3ForEffect = function(e, t, r) {
    r === void 0 && (r = ""), this._currentEffect.setColor3(e + r, t);
  }, i.prototype._updateColor3ForUniform = function(e, t) {
    i._TempBuffer[0] = t.r, i._TempBuffer[1] = t.g, i._TempBuffer[2] = t.b, this.updateUniform(e, i._TempBuffer, 3);
  }, i.prototype._updateColor4ForEffect = function(e, t, r, n) {
    n === void 0 && (n = ""), this._currentEffect.setColor4(e + n, t, r);
  }, i.prototype._updateDirectColor4ForEffect = function(e, t, r) {
    r === void 0 && (r = ""), this._currentEffect.setDirectColor4(e + r, t);
  }, i.prototype._updateColor4ForUniform = function(e, t, r) {
    i._TempBuffer[0] = t.r, i._TempBuffer[1] = t.g, i._TempBuffer[2] = t.b, i._TempBuffer[3] = r, this.updateUniform(e, i._TempBuffer, 4);
  }, i.prototype._updateDirectColor4ForUniform = function(e, t) {
    i._TempBuffer[0] = t.r, i._TempBuffer[1] = t.g, i._TempBuffer[2] = t.b, i._TempBuffer[3] = t.a, this.updateUniform(e, i._TempBuffer, 4);
  }, i.prototype._updateIntForEffect = function(e, t, r) {
    r === void 0 && (r = ""), this._currentEffect.setInt(e + r, t);
  }, i.prototype._updateIntForUniform = function(e, t) {
    i._TempBufferInt32View[0] = t, this.updateUniform(e, i._TempBuffer, 1);
  }, i.prototype._updateInt2ForEffect = function(e, t, r, n) {
    n === void 0 && (n = ""), this._currentEffect.setInt2(e + n, t, r);
  }, i.prototype._updateInt2ForUniform = function(e, t, r) {
    i._TempBufferInt32View[0] = t, i._TempBufferInt32View[1] = r, this.updateUniform(e, i._TempBuffer, 2);
  }, i.prototype._updateInt3ForEffect = function(e, t, r, n, a) {
    a === void 0 && (a = ""), this._currentEffect.setInt3(e + a, t, r, n);
  }, i.prototype._updateInt3ForUniform = function(e, t, r, n) {
    i._TempBufferInt32View[0] = t, i._TempBufferInt32View[1] = r, i._TempBufferInt32View[2] = n, this.updateUniform(e, i._TempBuffer, 3);
  }, i.prototype._updateInt4ForEffect = function(e, t, r, n, a, s) {
    s === void 0 && (s = ""), this._currentEffect.setInt4(e + s, t, r, n, a);
  }, i.prototype._updateInt4ForUniform = function(e, t, r, n, a) {
    i._TempBufferInt32View[0] = t, i._TempBufferInt32View[1] = r, i._TempBufferInt32View[2] = n, i._TempBufferInt32View[3] = a, this.updateUniform(e, i._TempBuffer, 4);
  }, i.prototype.setTexture = function(e, t) {
    this._currentEffect.setTexture(e, t);
  }, i.prototype.updateUniformDirectly = function(e, t) {
    this.updateUniform(e, t, t.length), this.update();
  }, i.prototype.bindToEffect = function(e, t) {
    this._currentEffect = e, this._currentEffectName = t;
  }, i.prototype.bindUniformBuffer = function() {
    !this._noUBO && this._buffer && this._currentEffect && this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);
  }, i.prototype.unbindEffect = function() {
    this._currentEffect = void 0, this._currentEffectName = void 0;
  }, i.prototype.setDataBuffer = function(e) {
    if (!this._buffers)
      return this._buffer === e;
    for (var t = 0; t < this._buffers.length; ++t) {
      var r = this._buffers[t];
      if (r[0] === e)
        return this._bufferIndex = t, this._buffer = e, this._createBufferOnWrite = !1, this._currentEffect = void 0, !0;
    }
    return !1;
  }, i.prototype.dispose = function() {
    if (!this._noUBO) {
      var e = this._engine._uniformBuffers, t = e.indexOf(this);
      if (t !== -1 && (e[t] = e[e.length - 1], e.pop()), this._engine._features.trackUbosInFrame && this._buffers)
        for (var r = 0; r < this._buffers.length; ++r) {
          var n = this._buffers[r][0];
          this._engine._releaseBuffer(n);
        }
      else
        this._buffer && this._engine._releaseBuffer(this._buffer) && (this._buffer = null);
    }
  }, i._UpdatedUbosInFrame = {}, i._MAX_UNIFORM_SIZE = 256, i._TempBuffer = new Float32Array(i._MAX_UNIFORM_SIZE), i._TempBufferInt32View = new Uint32Array(i._TempBuffer.buffer), i;
}(), Sr = function() {
  function i(e, t, r, n, a, s, o, u) {
    n === void 0 && (n = 0), a === void 0 && (a = !1), s === void 0 && (s = !1), o === void 0 && (o = !1), this._isAlreadyOwned = !1, e.getScene ? this._engine = e.getScene().getEngine() : this._engine = e, this._updatable = r, this._instanced = s, this._divisor = u || 1, t instanceof Ji ? (this._data = null, this._buffer = t) : (this._data = t, this._buffer = null), this.byteStride = o ? n : n * Float32Array.BYTES_PER_ELEMENT, a || this.create();
  }
  return i.prototype.createVertexBuffer = function(e, t, r, n, a, s, o) {
    s === void 0 && (s = !1);
    var u = s ? t : t * Float32Array.BYTES_PER_ELEMENT, f = n ? s ? n : n * Float32Array.BYTES_PER_ELEMENT : this.byteStride;
    return new m(this._engine, this, e, this._updatable, !0, f, a === void 0 ? this._instanced : a, u, r, void 0, void 0, !0, this._divisor || o);
  }, i.prototype.isUpdatable = function() {
    return this._updatable;
  }, i.prototype.getData = function() {
    return this._data;
  }, i.prototype.getBuffer = function() {
    return this._buffer;
  }, i.prototype.getStrideSize = function() {
    return this.byteStride / Float32Array.BYTES_PER_ELEMENT;
  }, i.prototype.create = function(e) {
    e === void 0 && (e = null), !(!e && this._buffer) && (e = e || this._data, e && (this._buffer ? this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e), this._data = e) : this._updatable ? (this._buffer = this._engine.createDynamicVertexBuffer(e), this._data = e) : this._buffer = this._engine.createVertexBuffer(e)));
  }, i.prototype._rebuild = function() {
    this._buffer = null, this.create(this._data);
  }, i.prototype.update = function(e) {
    this.create(e);
  }, i.prototype.updateDirectly = function(e, t, r, n) {
    n === void 0 && (n = !1), !!this._buffer && this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e, n ? t : t * Float32Array.BYTES_PER_ELEMENT, r ? r * this.byteStride : void 0), t === 0 && r === void 0 ? this._data = e : this._data = null);
  }, i.prototype._increaseReferences = function() {
    if (!!this._buffer) {
      if (!this._isAlreadyOwned) {
        this._isAlreadyOwned = !0;
        return;
      }
      this._buffer.references++;
    }
  }, i.prototype.dispose = function() {
    !this._buffer || this._engine._releaseBuffer(this._buffer) && (this._buffer = null, this._data = null);
  }, i;
}(), m = function() {
  function i(e, t, r, n, a, s, o, u, f, l, h, c, d, p) {
    if (h === void 0 && (h = !1), c === void 0 && (c = !1), d === void 0 && (d = 1), p === void 0 && (p = !1), t instanceof Sr ? (this._buffer = t, this._ownsBuffer = p) : (this._buffer = new Sr(e, t, n, s, a, o, c), this._ownsBuffer = !0), this.uniqueId = i._Counter++, this._kind = r, l == null) {
      var g = this.getData();
      this.type = i.FLOAT, g instanceof Int8Array ? this.type = i.BYTE : g instanceof Uint8Array ? this.type = i.UNSIGNED_BYTE : g instanceof Int16Array ? this.type = i.SHORT : g instanceof Uint16Array ? this.type = i.UNSIGNED_SHORT : g instanceof Int32Array ? this.type = i.INT : g instanceof Uint32Array && (this.type = i.UNSIGNED_INT);
    } else
      this.type = l;
    var _ = i.GetTypeByteLength(this.type);
    c ? (this._size = f || (s ? s / _ : i.DeduceStride(r)), this.byteStride = s || this._buffer.byteStride || this._size * _, this.byteOffset = u || 0) : (this._size = f || s || i.DeduceStride(r), this.byteStride = s ? s * _ : this._buffer.byteStride || this._size * _, this.byteOffset = (u || 0) * _), this.normalized = h, this._instanced = o !== void 0 ? o : !1, this._instanceDivisor = o ? d : 0, this._computeHashCode();
  }
  return Object.defineProperty(i.prototype, "instanceDivisor", {
    get: function() {
      return this._instanceDivisor;
    },
    set: function(e) {
      this._instanceDivisor = e, e == 0 ? this._instanced = !1 : this._instanced = !0, this._computeHashCode();
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._computeHashCode = function() {
    this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + (this.byteStride << 12);
  }, i.prototype._rebuild = function() {
    !this._buffer || this._buffer._rebuild();
  }, i.prototype.getKind = function() {
    return this._kind;
  }, i.prototype.isUpdatable = function() {
    return this._buffer.isUpdatable();
  }, i.prototype.getData = function() {
    return this._buffer.getData();
  }, i.prototype.getFloatData = function(e, t) {
    var r = this.getData();
    if (!r)
      return null;
    var n = this.getSize() * i.GetTypeByteLength(this.type), a = e * this.getSize();
    if (this.type !== i.FLOAT || this.byteStride !== n) {
      var s = new Float32Array(a);
      return this.forEach(a, function(h, c) {
        return s[c] = h;
      }), s;
    }
    if (!(r instanceof Array || r instanceof Float32Array) || this.byteOffset !== 0 || r.length !== a)
      if (r instanceof Array) {
        var o = this.byteOffset / 4;
        return r.slice(o, o + a);
      } else {
        if (r instanceof ArrayBuffer)
          return new Float32Array(r, this.byteOffset, a);
        var o = r.byteOffset + this.byteOffset;
        if (t) {
          var u = new Float32Array(a), f = new Float32Array(r.buffer, o, a);
          return u.set(f), u;
        }
        var l = o % 4;
        return l && (o = Math.max(0, o - l)), new Float32Array(r.buffer, o, a);
      }
    return t ? r.slice() : r;
  }, i.prototype.getBuffer = function() {
    return this._buffer.getBuffer();
  }, i.prototype.getStrideSize = function() {
    return this.byteStride / i.GetTypeByteLength(this.type);
  }, i.prototype.getOffset = function() {
    return this.byteOffset / i.GetTypeByteLength(this.type);
  }, i.prototype.getSize = function(e) {
    return e === void 0 && (e = !1), e ? this._size * i.GetTypeByteLength(this.type) : this._size;
  }, i.prototype.getIsInstanced = function() {
    return this._instanced;
  }, i.prototype.getInstanceDivisor = function() {
    return this._instanceDivisor;
  }, i.prototype.create = function(e) {
    this._buffer.create(e);
  }, i.prototype.update = function(e) {
    this._buffer.update(e);
  }, i.prototype.updateDirectly = function(e, t, r) {
    r === void 0 && (r = !1), this._buffer.updateDirectly(e, t, void 0, r);
  }, i.prototype.dispose = function() {
    this._ownsBuffer && this._buffer.dispose();
  }, i.prototype.forEach = function(e, t) {
    i.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, e, this.normalized, t);
  }, i.DeduceStride = function(e) {
    switch (e) {
      case i.UVKind:
      case i.UV2Kind:
      case i.UV3Kind:
      case i.UV4Kind:
      case i.UV5Kind:
      case i.UV6Kind:
        return 2;
      case i.NormalKind:
      case i.PositionKind:
        return 3;
      case i.ColorKind:
      case i.MatricesIndicesKind:
      case i.MatricesIndicesExtraKind:
      case i.MatricesWeightsKind:
      case i.MatricesWeightsExtraKind:
      case i.TangentKind:
        return 4;
      default:
        throw new Error("Invalid kind '" + e + "'");
    }
  }, i.GetTypeByteLength = function(e) {
    switch (e) {
      case i.BYTE:
      case i.UNSIGNED_BYTE:
        return 1;
      case i.SHORT:
      case i.UNSIGNED_SHORT:
        return 2;
      case i.INT:
      case i.UNSIGNED_INT:
      case i.FLOAT:
        return 4;
      default:
        throw new Error("Invalid type '".concat(e, "'"));
    }
  }, i.ForEach = function(e, t, r, n, a, s, o, u) {
    if (e instanceof Array)
      for (var f = t / 4, l = r / 4, h = 0; h < s; h += n) {
        for (var c = 0; c < n; c++)
          u(e[f + c], h + c);
        f += l;
      }
    else
      for (var d = e instanceof ArrayBuffer ? new DataView(e) : new DataView(e.buffer, e.byteOffset, e.byteLength), p = i.GetTypeByteLength(a), h = 0; h < s; h += n) {
        for (var g = t, c = 0; c < n; c++) {
          var _ = i._GetFloatValue(d, a, g, o);
          u(_, h + c), g += p;
        }
        t += r;
      }
  }, i._GetFloatValue = function(e, t, r, n) {
    switch (t) {
      case i.BYTE: {
        var a = e.getInt8(r);
        return n && (a = Math.max(a / 127, -1)), a;
      }
      case i.UNSIGNED_BYTE: {
        var a = e.getUint8(r);
        return n && (a = a / 255), a;
      }
      case i.SHORT: {
        var a = e.getInt16(r, !0);
        return n && (a = Math.max(a / 32767, -1)), a;
      }
      case i.UNSIGNED_SHORT: {
        var a = e.getUint16(r, !0);
        return n && (a = a / 65535), a;
      }
      case i.INT:
        return e.getInt32(r, !0);
      case i.UNSIGNED_INT:
        return e.getUint32(r, !0);
      case i.FLOAT:
        return e.getFloat32(r, !0);
      default:
        throw new Error("Invalid component type ".concat(t));
    }
  }, i._Counter = 0, i.BYTE = 5120, i.UNSIGNED_BYTE = 5121, i.SHORT = 5122, i.UNSIGNED_SHORT = 5123, i.INT = 5124, i.UNSIGNED_INT = 5125, i.FLOAT = 5126, i.PositionKind = "position", i.NormalKind = "normal", i.TangentKind = "tangent", i.UVKind = "uv", i.UV2Kind = "uv2", i.UV3Kind = "uv3", i.UV4Kind = "uv4", i.UV5Kind = "uv5", i.UV6Kind = "uv6", i.ColorKind = "color", i.ColorInstanceKind = "instanceColor", i.MatricesIndicesKind = "matricesIndices", i.MatricesWeightsKind = "matricesWeights", i.MatricesIndicesExtraKind = "matricesIndicesExtra", i.MatricesWeightsExtraKind = "matricesWeightsExtra", i;
}(), et = function() {
  function i() {
    this._pickingUnavailable = !1, this.hit = !1, this.distance = 0, this.pickedPoint = null, this.pickedMesh = null, this.bu = 0, this.bv = 0, this.faceId = -1, this.subMeshFaceId = -1, this.subMeshId = 0, this.pickedSprite = null, this.thinInstanceIndex = -1, this.ray = null, this.originMesh = null, this.aimTransform = null, this.gripTransform = null;
  }
  return i.prototype.getNormal = function(e, t) {
    if (e === void 0 && (e = !1), t === void 0 && (t = !0), !this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(m.NormalKind))
      return null;
    var r = this.pickedMesh.getIndices();
    if (!r)
      return null;
    var n;
    if (t) {
      var a = this.pickedMesh.getVerticesData(m.NormalKind), s = b.FromArray(a, r[this.faceId * 3] * 3), o = b.FromArray(a, r[this.faceId * 3 + 1] * 3), u = b.FromArray(a, r[this.faceId * 3 + 2] * 3);
      s = s.scale(this.bu), o = o.scale(this.bv), u = u.scale(1 - this.bu - this.bv), n = new b(s.x + o.x + u.x, s.y + o.y + u.y, s.z + o.z + u.z);
    } else {
      var f = this.pickedMesh.getVerticesData(m.PositionKind), l = b.FromArray(f, r[this.faceId * 3] * 3), h = b.FromArray(f, r[this.faceId * 3 + 1] * 3), c = b.FromArray(f, r[this.faceId * 3 + 2] * 3), d = l.subtract(h), p = c.subtract(h);
      n = b.Cross(d, p);
    }
    if (e) {
      var g = this.pickedMesh.getWorldMatrix();
      this.pickedMesh.nonUniformScaling && (D.Matrix[0].copyFrom(g), g = D.Matrix[0], g.setTranslationFromFloats(0, 0, 0), g.invert(), g.transposeToRef(D.Matrix[1]), g = D.Matrix[1]), n = b.TransformNormal(n, g);
    }
    return n.normalize(), n;
  }, i.prototype.getTextureCoordinates = function() {
    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(m.UVKind))
      return null;
    var e = this.pickedMesh.getIndices();
    if (!e)
      return null;
    var t = this.pickedMesh.getVerticesData(m.UVKind);
    if (!t)
      return null;
    var r = Ee.FromArray(t, e[this.faceId * 3] * 2), n = Ee.FromArray(t, e[this.faceId * 3 + 1] * 2), a = Ee.FromArray(t, e[this.faceId * 3 + 2] * 2);
    return r = r.scale(this.bu), n = n.scale(this.bv), a = a.scale(1 - this.bu - this.bv), new Ee(r.x + n.x + a.x, r.y + n.y + a.y);
  }, i;
}(), we = function() {
  function i(e, t, r, n, a, s) {
    this.source = e, this.pointerX = t, this.pointerY = r, this.meshUnderPointer = n, this.sourceEvent = a, this.additionalData = s;
  }
  return i.CreateNew = function(e, t, r) {
    var n = e.getScene();
    return new i(e, n.pointerX, n.pointerY, n.meshUnderPointer || e, t, r);
  }, i.CreateNewFromSprite = function(e, t, r, n) {
    return new i(e, t.pointerX, t.pointerY, t.meshUnderPointer, r, n);
  }, i.CreateNewFromScene = function(e, t) {
    return new i(null, e.pointerX, e.pointerY, e.meshUnderPointer, t);
  }, i.CreateNewFromPrimitive = function(e, t, r, n) {
    return new i(e, t.x, t.y, null, r, n);
  }, i;
}(), Mr = function() {
  function i(e) {
    this._vertexBuffers = {}, this._scene = e;
  }
  return i.prototype._prepareBuffers = function() {
    if (!this._vertexBuffers[m.PositionKind]) {
      var e = [];
      e.push(1, 1), e.push(-1, 1), e.push(-1, -1), e.push(1, -1), this._vertexBuffers[m.PositionKind] = new m(this._scene.getEngine(), e, m.PositionKind, !1, !1, 2), this._buildIndexBuffer();
    }
  }, i.prototype._buildIndexBuffer = function() {
    var e = [];
    e.push(0), e.push(1), e.push(2), e.push(0), e.push(2), e.push(3), this._indexBuffer = this._scene.getEngine().createIndexBuffer(e);
  }, i.prototype._rebuild = function() {
    var e = this._vertexBuffers[m.PositionKind];
    !e || (e._rebuild(), this._buildIndexBuffer());
  }, i.prototype._prepareFrame = function(e, t) {
    e === void 0 && (e = null), t === void 0 && (t = null);
    var r = this._scene.activeCamera;
    return !r || (t = t || r._postProcesses.filter(function(n) {
      return n != null;
    }), !t || t.length === 0 || !this._scene.postProcessesEnabled) ? !1 : (t[0].activate(r, e, t != null), !0);
  }, i.prototype.directRender = function(e, t, r, n, a, s) {
    var o;
    t === void 0 && (t = null), r === void 0 && (r = !1), n === void 0 && (n = 0), a === void 0 && (a = 0), s === void 0 && (s = !1);
    for (var u = this._scene.getEngine(), f = 0; f < e.length; f++) {
      f < e.length - 1 ? e[f + 1].activate(this._scene.activeCamera, t == null ? void 0 : t.texture) : (t ? u.bindFramebuffer(t, n, void 0, void 0, r, a) : s || u.restoreDefaultFramebuffer(), (o = u._debugInsertMarker) === null || o === void 0 || o.call(u, "post process ".concat(e[f].name, " output")));
      var l = e[f], h = l.apply();
      h && (l.onBeforeRenderObservable.notifyObservers(h), this._prepareBuffers(), u.bindBuffers(this._vertexBuffers, this._indexBuffer, h), u.drawElementsType(0, 0, 6), l.onAfterRenderObservable.notifyObservers(h));
    }
    u.setDepthBuffer(!0), u.setDepthWrite(!0);
  }, i.prototype._finalizeFrame = function(e, t, r, n, a) {
    var s;
    a === void 0 && (a = !1);
    var o = this._scene.activeCamera;
    if (!!o && (n = n || o._postProcesses.filter(function(d) {
      return d != null;
    }), !(n.length === 0 || !this._scene.postProcessesEnabled))) {
      for (var u = this._scene.getEngine(), f = 0, l = n.length; f < l; f++) {
        var h = n[f];
        if (f < l - 1 ? h._outputTexture = n[f + 1].activate(o, t == null ? void 0 : t.texture) : (t ? (u.bindFramebuffer(t, r, void 0, void 0, a), h._outputTexture = t) : (u.restoreDefaultFramebuffer(), h._outputTexture = null), (s = u._debugInsertMarker) === null || s === void 0 || s.call(u, "post process ".concat(n[f].name, " output"))), e)
          break;
        var c = h.apply();
        c && (h.onBeforeRenderObservable.notifyObservers(c), this._prepareBuffers(), u.bindBuffers(this._vertexBuffers, this._indexBuffer, c), u.drawElementsType(0, 0, 6), h.onAfterRenderObservable.notifyObservers(c));
      }
      u.setDepthBuffer(!0), u.setDepthWrite(!0), u.setAlphaMode(0);
    }
  }, i.prototype.dispose = function() {
    var e = this._vertexBuffers[m.PositionKind];
    e && (e.dispose(), this._vertexBuffers[m.PositionKind] = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null);
  }, i;
}(), oa = function() {
  function i(e, t, r, n, a) {
    r === void 0 && (r = null), n === void 0 && (n = null), a === void 0 && (a = null), this.index = e, this._opaqueSubMeshes = new ke(256), this._transparentSubMeshes = new ke(256), this._alphaTestSubMeshes = new ke(256), this._depthOnlySubMeshes = new ke(256), this._particleSystems = new ke(256), this._spriteManagers = new ke(256), this._empty = !0, this._edgesRenderers = new Mt(16), this._scene = t, this.opaqueSortCompareFn = r, this.alphaTestSortCompareFn = n, this.transparentSortCompareFn = a;
  }
  return Object.defineProperty(i.prototype, "opaqueSortCompareFn", {
    set: function(e) {
      e ? this._opaqueSortCompareFn = e : this._opaqueSortCompareFn = i.PainterSortCompare, this._renderOpaque = this._renderOpaqueSorted;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "alphaTestSortCompareFn", {
    set: function(e) {
      e ? this._alphaTestSortCompareFn = e : this._alphaTestSortCompareFn = i.PainterSortCompare, this._renderAlphaTest = this._renderAlphaTestSorted;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "transparentSortCompareFn", {
    set: function(e) {
      e ? this._transparentSortCompareFn = e : this._transparentSortCompareFn = i.defaultTransparentSortCompare, this._renderTransparent = this._renderTransparentSorted;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.render = function(e, t, r, n) {
    if (e) {
      e(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);
      return;
    }
    var a = this._scene.getEngine();
    this._depthOnlySubMeshes.length !== 0 && (a.setColorWrite(!1), this._renderAlphaTest(this._depthOnlySubMeshes), a.setColorWrite(!0)), this._opaqueSubMeshes.length !== 0 && this._renderOpaque(this._opaqueSubMeshes), this._alphaTestSubMeshes.length !== 0 && this._renderAlphaTest(this._alphaTestSubMeshes);
    var s = a.getStencilBuffer();
    if (a.setStencilBuffer(!1), t && this._renderSprites(), r && this._renderParticles(n), this.onBeforeTransparentRendering && this.onBeforeTransparentRendering(), this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {
      if (a.setStencilBuffer(s), this._scene.useOrderIndependentTransparency) {
        var o = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);
        o.length && this._renderTransparent(o);
      } else
        this._renderTransparent(this._transparentSubMeshes);
      a.setAlphaMode(0);
    }
    if (a.setStencilBuffer(!1), this._edgesRenderers.length) {
      for (var u = 0; u < this._edgesRenderers.length; u++)
        this._edgesRenderers.data[u].render();
      a.setAlphaMode(0);
    }
    a.setStencilBuffer(s);
  }, i.prototype._renderOpaqueSorted = function(e) {
    return i._RenderSorted(e, this._opaqueSortCompareFn, this._scene.activeCamera, !1);
  }, i.prototype._renderAlphaTestSorted = function(e) {
    return i._RenderSorted(e, this._alphaTestSortCompareFn, this._scene.activeCamera, !1);
  }, i.prototype._renderTransparentSorted = function(e) {
    return i._RenderSorted(e, this._transparentSortCompareFn, this._scene.activeCamera, !0);
  }, i._RenderSorted = function(e, t, r, n) {
    var a = 0, s, o = r ? r.globalPosition : i._ZeroVector;
    if (n)
      for (; a < e.length; a++)
        s = e.data[a], s._alphaIndex = s.getMesh().alphaIndex, s._distanceToCamera = b.Distance(s.getBoundingInfo().boundingSphere.centerWorld, o);
    var u = e.length === e.data.length ? e.data : e.data.slice(0, e.length);
    t && u.sort(t);
    var f = u[0].getMesh().getScene();
    for (a = 0; a < u.length; a++)
      if (s = u[a], !(f._activeMeshesFrozenButKeepClipping && !s.isInFrustum(f._frustumPlanes))) {
        if (n) {
          var l = s.getMaterial();
          if (l && l.needDepthPrePass) {
            var h = l.getScene().getEngine();
            h.setColorWrite(!1), h.setAlphaMode(0), s.render(!1), h.setColorWrite(!0);
          }
        }
        s.render(n);
      }
  }, i.defaultTransparentSortCompare = function(e, t) {
    return e._alphaIndex > t._alphaIndex ? 1 : e._alphaIndex < t._alphaIndex ? -1 : i.backToFrontSortCompare(e, t);
  }, i.backToFrontSortCompare = function(e, t) {
    return e._distanceToCamera < t._distanceToCamera ? 1 : e._distanceToCamera > t._distanceToCamera ? -1 : 0;
  }, i.frontToBackSortCompare = function(e, t) {
    return e._distanceToCamera < t._distanceToCamera ? -1 : e._distanceToCamera > t._distanceToCamera ? 1 : 0;
  }, i.PainterSortCompare = function(e, t) {
    var r = e.getMesh(), n = t.getMesh();
    return r.material && n.material ? r.material.uniqueId - n.material.uniqueId : r.uniqueId - n.uniqueId;
  }, i.prototype.prepare = function() {
    this._opaqueSubMeshes.reset(), this._transparentSubMeshes.reset(), this._alphaTestSubMeshes.reset(), this._depthOnlySubMeshes.reset(), this._particleSystems.reset(), this._spriteManagers.reset(), this._edgesRenderers.reset(), this._empty = !0;
  }, i.prototype.dispose = function() {
    this._opaqueSubMeshes.dispose(), this._transparentSubMeshes.dispose(), this._alphaTestSubMeshes.dispose(), this._depthOnlySubMeshes.dispose(), this._particleSystems.dispose(), this._spriteManagers.dispose(), this._edgesRenderers.dispose();
  }, i.prototype.dispatch = function(e, t, r) {
    t === void 0 && (t = e.getMesh()), r === void 0 && (r = e.getMaterial()), r != null && (r.needAlphaBlendingForMesh(t) ? this._transparentSubMeshes.push(e) : r.needAlphaTesting() ? (r.needDepthPrePass && this._depthOnlySubMeshes.push(e), this._alphaTestSubMeshes.push(e)) : (r.needDepthPrePass && this._depthOnlySubMeshes.push(e), this._opaqueSubMeshes.push(e)), t._renderingGroup = this, t._edgesRenderer && t._edgesRenderer.isEnabled && this._edgesRenderers.pushNoDuplicate(t._edgesRenderer), this._empty = !1);
  }, i.prototype.dispatchSprites = function(e) {
    this._spriteManagers.push(e), this._empty = !1;
  }, i.prototype.dispatchParticles = function(e) {
    this._particleSystems.push(e), this._empty = !1;
  }, i.prototype._renderParticles = function(e) {
    if (this._particleSystems.length !== 0) {
      var t = this._scene.activeCamera;
      this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);
      for (var r = 0; r < this._particleSystems.length; r++) {
        var n = this._particleSystems.data[r];
        if ((t && t.layerMask & n.layerMask) !== 0) {
          var a = n.emitter;
          (!a.position || !e || e.indexOf(a) !== -1) && this._scene._activeParticles.addCount(n.render(), !1);
        }
      }
      this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);
    }
  }, i.prototype._renderSprites = function() {
    if (!(!this._scene.spritesEnabled || this._spriteManagers.length === 0)) {
      var e = this._scene.activeCamera;
      this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);
      for (var t = 0; t < this._spriteManagers.length; t++) {
        var r = this._spriteManagers.data[t];
        (e && e.layerMask & r.layerMask) !== 0 && r.render();
      }
      this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);
    }
  }, i._ZeroVector = b.Zero(), i;
}(), ua = function() {
  function i() {
  }
  return i;
}(), Ar = function() {
  function i(e) {
    this._useSceneAutoClearSetup = !1, this._renderingGroups = new Array(), this._autoClearDepthStencil = {}, this._customOpaqueSortCompareFn = {}, this._customAlphaTestSortCompareFn = {}, this._customTransparentSortCompareFn = {}, this._renderingGroupInfo = new ua(), this._scene = e;
    for (var t = i.MIN_RENDERINGGROUPS; t < i.MAX_RENDERINGGROUPS; t++)
      this._autoClearDepthStencil[t] = { autoClear: !0, depth: !0, stencil: !0 };
  }
  return i.prototype._clearDepthStencilBuffer = function(e, t) {
    e === void 0 && (e = !0), t === void 0 && (t = !0), !this._depthStencilBufferAlreadyCleaned && (this._scene.getEngine().clear(null, !1, e, t), this._depthStencilBufferAlreadyCleaned = !0);
  }, i.prototype.render = function(e, t, r, n) {
    var a = this._renderingGroupInfo;
    if (a.scene = this._scene, a.camera = this._scene.activeCamera, this._scene.spriteManagers && n)
      for (var s = 0; s < this._scene.spriteManagers.length; s++) {
        var o = this._scene.spriteManagers[s];
        this.dispatchSprites(o);
      }
    for (var s = i.MIN_RENDERINGGROUPS; s < i.MAX_RENDERINGGROUPS; s++) {
      this._depthStencilBufferAlreadyCleaned = s === i.MIN_RENDERINGGROUPS;
      var u = this._renderingGroups[s];
      if (!(!u || u._empty)) {
        var f = Math.pow(2, s);
        if (a.renderingGroupId = s, this._scene.onBeforeRenderingGroupObservable.notifyObservers(a, f), i.AUTOCLEAR) {
          var l = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(s) : this._autoClearDepthStencil[s];
          l && l.autoClear && this._clearDepthStencilBuffer(l.depth, l.stencil);
        }
        for (var h = 0, c = this._scene._beforeRenderingGroupDrawStage; h < c.length; h++) {
          var d = c[h];
          d.action(s);
        }
        u.render(e, n, r, t);
        for (var p = 0, g = this._scene._afterRenderingGroupDrawStage; p < g.length; p++) {
          var d = g[p];
          d.action(s);
        }
        this._scene.onAfterRenderingGroupObservable.notifyObservers(a, f);
      }
    }
  }, i.prototype.reset = function() {
    for (var e = i.MIN_RENDERINGGROUPS; e < i.MAX_RENDERINGGROUPS; e++) {
      var t = this._renderingGroups[e];
      t && t.prepare();
    }
  }, i.prototype.dispose = function() {
    this.freeRenderingGroups(), this._renderingGroups.length = 0, this._renderingGroupInfo = null;
  }, i.prototype.freeRenderingGroups = function() {
    for (var e = i.MIN_RENDERINGGROUPS; e < i.MAX_RENDERINGGROUPS; e++) {
      var t = this._renderingGroups[e];
      t && t.dispose();
    }
  }, i.prototype._prepareRenderingGroup = function(e) {
    this._renderingGroups[e] === void 0 && (this._renderingGroups[e] = new oa(e, this._scene, this._customOpaqueSortCompareFn[e], this._customAlphaTestSortCompareFn[e], this._customTransparentSortCompareFn[e]));
  }, i.prototype.dispatchSprites = function(e) {
    var t = e.renderingGroupId || 0;
    this._prepareRenderingGroup(t), this._renderingGroups[t].dispatchSprites(e);
  }, i.prototype.dispatchParticles = function(e) {
    var t = e.renderingGroupId || 0;
    this._prepareRenderingGroup(t), this._renderingGroups[t].dispatchParticles(e);
  }, i.prototype.dispatch = function(e, t, r) {
    t === void 0 && (t = e.getMesh());
    var n = t.renderingGroupId || 0;
    this._prepareRenderingGroup(n), this._renderingGroups[n].dispatch(e, t, r);
  }, i.prototype.setRenderingOrder = function(e, t, r, n) {
    if (t === void 0 && (t = null), r === void 0 && (r = null), n === void 0 && (n = null), this._customOpaqueSortCompareFn[e] = t, this._customAlphaTestSortCompareFn[e] = r, this._customTransparentSortCompareFn[e] = n, this._renderingGroups[e]) {
      var a = this._renderingGroups[e];
      a.opaqueSortCompareFn = this._customOpaqueSortCompareFn[e], a.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[e], a.transparentSortCompareFn = this._customTransparentSortCompareFn[e];
    }
  }, i.prototype.setRenderingAutoClearDepthStencil = function(e, t, r, n) {
    r === void 0 && (r = !0), n === void 0 && (n = !0), this._autoClearDepthStencil[e] = {
      autoClear: t,
      depth: r,
      stencil: n
    };
  }, i.prototype.getAutoClearDepthStencilSetup = function(e) {
    return this._autoClearDepthStencil[e];
  }, i.MAX_RENDERINGGROUPS = 4, i.MIN_RENDERINGGROUPS = 0, i.AUTOCLEAR = !0, i;
}(), Xt = function() {
  function i() {
  }
  return i.NAME_EFFECTLAYER = "EffectLayer", i.NAME_LAYER = "Layer", i.NAME_LENSFLARESYSTEM = "LensFlareSystem", i.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer", i.NAME_PARTICLESYSTEM = "ParticleSystem", i.NAME_GAMEPAD = "Gamepad", i.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue", i.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer", i.NAME_PREPASSRENDERER = "PrePassRenderer", i.NAME_DEPTHRENDERER = "DepthRenderer", i.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer", i.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager", i.NAME_SPRITE = "Sprite", i.NAME_SUBSURFACE = "SubSurface", i.NAME_OUTLINERENDERER = "Outline", i.NAME_PROCEDURALTEXTURE = "ProceduralTexture", i.NAME_SHADOWGENERATOR = "ShadowGenerator", i.NAME_OCTREE = "Octree", i.NAME_PHYSICSENGINE = "PhysicsEngine", i.NAME_AUDIO = "Audio", i.STEP_ISREADYFORMESH_EFFECTLAYER = 0, i.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0, i.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0, i.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0, i.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1, i.STEP_BEFORECAMERADRAW_PREPASS = 0, i.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1, i.STEP_BEFORECAMERADRAW_LAYER = 2, i.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0, i.STEP_BEFORERENDERTARGETDRAW_LAYER = 1, i.STEP_BEFORERENDERINGMESH_PREPASS = 0, i.STEP_BEFORERENDERINGMESH_OUTLINE = 1, i.STEP_AFTERRENDERINGMESH_PREPASS = 0, i.STEP_AFTERRENDERINGMESH_OUTLINE = 1, i.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0, i.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1, i.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0, i.STEP_BEFORECAMERAUPDATE_GAMEPAD = 1, i.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0, i.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0, i.STEP_AFTERRENDERTARGETDRAW_LAYER = 1, i.STEP_AFTERCAMERADRAW_PREPASS = 0, i.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1, i.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2, i.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3, i.STEP_AFTERCAMERADRAW_LAYER = 4, i.STEP_AFTERRENDER_AUDIO = 0, i.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0, i.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1, i.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2, i.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3, i.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0, i.STEP_BEFORECLEARSTAGE_PREPASS = 0, i.STEP_BEFORERENDERTARGETCLEARSTAGE_PREPASS = 0, i.STEP_POINTERMOVE_SPRITE = 0, i.STEP_POINTERDOWN_SPRITE = 0, i.STEP_POINTERUP_SPRITE = 0, i;
}(), ge = function(i) {
  K(e, i);
  function e(t) {
    return i.apply(this, t) || this;
  }
  return e.Create = function() {
    return Object.create(e.prototype);
  }, e.prototype.registerStep = function(t, r, n) {
    for (var a = 0, s = Number.MAX_VALUE; a < this.length; a++) {
      var o = this[a];
      if (s = o.index, t < s)
        break;
    }
    this.splice(a, 0, { index: t, component: r, action: n.bind(r) });
  }, e.prototype.clear = function() {
    this.length = 0;
  }, e;
}(Array), oe = function() {
  function i() {
  }
  return i.POINTERDOWN = 1, i.POINTERUP = 2, i.POINTERMOVE = 4, i.POINTERWHEEL = 8, i.POINTERPICK = 16, i.POINTERTAP = 32, i.POINTERDOUBLETAP = 64, i;
}(), ln = function() {
  function i(e, t) {
    this.type = e, this.event = t;
  }
  return i;
}(), fa = function(i) {
  K(e, i);
  function e(t, r, n, a) {
    var s = i.call(this, t, r) || this;
    return s.ray = null, s.skipOnPointerObservable = !1, s.localPosition = new Ee(n, a), s;
  }
  return e;
}(ln), Kt = function(i) {
  K(e, i);
  function e(t, r, n) {
    var a = i.call(this, t, r) || this;
    return a.pickInfo = n, a;
  }
  return e;
}(ln), Yt = function() {
  function i() {
    this.hoverCursor = "", this.actions = new Array(), this.isRecursive = !1;
  }
  return Object.defineProperty(i, "HasTriggers", {
    get: function() {
      for (var e in i.Triggers)
        if (Object.prototype.hasOwnProperty.call(i.Triggers, e))
          return !0;
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "HasPickTriggers", {
    get: function() {
      for (var e in i.Triggers)
        if (Object.prototype.hasOwnProperty.call(i.Triggers, e)) {
          var t = parseInt(e);
          if (t >= 1 && t <= 7)
            return !0;
        }
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), i.HasSpecificTrigger = function(e) {
    for (var t in i.Triggers)
      if (Object.prototype.hasOwnProperty.call(i.Triggers, t)) {
        var r = parseInt(t);
        if (r === e)
          return !0;
      }
    return !1;
  }, i.Triggers = {}, i;
}(), Pi = function() {
  function i() {
  }
  return i.KEYDOWN = 1, i.KEYUP = 2, i;
}(), ii = function() {
  function i(e, t) {
    this.type = e, this.event = t;
  }
  return i;
}(), Ci = function(i) {
  K(e, i);
  function e(t, r) {
    var n = i.call(this, t, r) || this;
    return n.type = t, n.event = r, n.skipOnKeyboardObservable = !1, n;
  }
  return Object.defineProperty(e.prototype, "skipOnPointerObservable", {
    get: function() {
      return this.skipOnKeyboardObservable;
    },
    set: function(t) {
      this.skipOnKeyboardObservable = t;
    },
    enumerable: !1,
    configurable: !0
  }), e;
}(ii), B;
(function(i) {
  i[i.Generic = 0] = "Generic", i[i.Keyboard = 1] = "Keyboard", i[i.Mouse = 2] = "Mouse", i[i.Touch = 3] = "Touch", i[i.DualShock = 4] = "DualShock", i[i.Xbox = 5] = "Xbox", i[i.Switch = 6] = "Switch", i[i.DualSense = 7] = "DualSense";
})(B || (B = {}));
var X;
(function(i) {
  i[i.Horizontal = 0] = "Horizontal", i[i.Vertical = 1] = "Vertical", i[i.LeftClick = 2] = "LeftClick", i[i.MiddleClick = 3] = "MiddleClick", i[i.RightClick = 4] = "RightClick", i[i.BrowserBack = 5] = "BrowserBack", i[i.BrowserForward = 6] = "BrowserForward", i[i.MouseWheelX = 7] = "MouseWheelX", i[i.MouseWheelY = 8] = "MouseWheelY", i[i.MouseWheelZ = 9] = "MouseWheelZ", i[i.Move = 12] = "Move";
})(X || (X = {}));
var Rr;
(function(i) {
  i[i.Horizontal = 0] = "Horizontal", i[i.Vertical = 1] = "Vertical", i[i.LeftClick = 2] = "LeftClick", i[i.MiddleClick = 3] = "MiddleClick", i[i.RightClick = 4] = "RightClick", i[i.BrowserBack = 5] = "BrowserBack", i[i.BrowserForward = 6] = "BrowserForward", i[i.MouseWheelX = 7] = "MouseWheelX", i[i.MouseWheelY = 8] = "MouseWheelY", i[i.MouseWheelZ = 9] = "MouseWheelZ", i[i.DeltaHorizontal = 10] = "DeltaHorizontal", i[i.DeltaVertical = 11] = "DeltaVertical";
})(Rr || (Rr = {}));
var xi;
(function(i) {
  i[i.Cross = 0] = "Cross", i[i.Circle = 1] = "Circle", i[i.Square = 2] = "Square", i[i.Triangle = 3] = "Triangle", i[i.L1 = 4] = "L1", i[i.R1 = 5] = "R1", i[i.L2 = 6] = "L2", i[i.R2 = 7] = "R2", i[i.Share = 8] = "Share", i[i.Options = 9] = "Options", i[i.L3 = 10] = "L3", i[i.R3 = 11] = "R3", i[i.DPadUp = 12] = "DPadUp", i[i.DPadDown = 13] = "DPadDown", i[i.DPadLeft = 14] = "DPadLeft", i[i.DPadRight = 15] = "DPadRight", i[i.Home = 16] = "Home", i[i.TouchPad = 17] = "TouchPad", i[i.LStickXAxis = 18] = "LStickXAxis", i[i.LStickYAxis = 19] = "LStickYAxis", i[i.RStickXAxis = 20] = "RStickXAxis", i[i.RStickYAxis = 21] = "RStickYAxis";
})(xi || (xi = {}));
var Di;
(function(i) {
  i[i.Cross = 0] = "Cross", i[i.Circle = 1] = "Circle", i[i.Square = 2] = "Square", i[i.Triangle = 3] = "Triangle", i[i.L1 = 4] = "L1", i[i.R1 = 5] = "R1", i[i.L2 = 6] = "L2", i[i.R2 = 7] = "R2", i[i.Create = 8] = "Create", i[i.Options = 9] = "Options", i[i.L3 = 10] = "L3", i[i.R3 = 11] = "R3", i[i.DPadUp = 12] = "DPadUp", i[i.DPadDown = 13] = "DPadDown", i[i.DPadLeft = 14] = "DPadLeft", i[i.DPadRight = 15] = "DPadRight", i[i.Home = 16] = "Home", i[i.TouchPad = 17] = "TouchPad", i[i.LStickXAxis = 18] = "LStickXAxis", i[i.LStickYAxis = 19] = "LStickYAxis", i[i.RStickXAxis = 20] = "RStickXAxis", i[i.RStickYAxis = 21] = "RStickYAxis";
})(Di || (Di = {}));
var Ii;
(function(i) {
  i[i.A = 0] = "A", i[i.B = 1] = "B", i[i.X = 2] = "X", i[i.Y = 3] = "Y", i[i.LB = 4] = "LB", i[i.RB = 5] = "RB", i[i.LT = 6] = "LT", i[i.RT = 7] = "RT", i[i.Back = 8] = "Back", i[i.Start = 9] = "Start", i[i.LS = 10] = "LS", i[i.RS = 11] = "RS", i[i.DPadUp = 12] = "DPadUp", i[i.DPadDown = 13] = "DPadDown", i[i.DPadLeft = 14] = "DPadLeft", i[i.DPadRight = 15] = "DPadRight", i[i.Home = 16] = "Home", i[i.LStickXAxis = 17] = "LStickXAxis", i[i.LStickYAxis = 18] = "LStickYAxis", i[i.RStickXAxis = 19] = "RStickXAxis", i[i.RStickYAxis = 20] = "RStickYAxis";
})(Ii || (Ii = {}));
var Oi;
(function(i) {
  i[i.B = 0] = "B", i[i.A = 1] = "A", i[i.Y = 2] = "Y", i[i.X = 3] = "X", i[i.L = 4] = "L", i[i.R = 5] = "R", i[i.ZL = 6] = "ZL", i[i.ZR = 7] = "ZR", i[i.Minus = 8] = "Minus", i[i.Plus = 9] = "Plus", i[i.LS = 10] = "LS", i[i.RS = 11] = "RS", i[i.DPadUp = 12] = "DPadUp", i[i.DPadDown = 13] = "DPadDown", i[i.DPadLeft = 14] = "DPadLeft", i[i.DPadRight = 15] = "DPadRight", i[i.Home = 16] = "Home", i[i.Capture = 17] = "Capture", i[i.LStickXAxis = 18] = "LStickXAxis", i[i.LStickYAxis = 19] = "LStickYAxis", i[i.RStickXAxis = 20] = "RStickXAxis", i[i.RStickYAxis = 21] = "RStickYAxis";
})(Oi || (Oi = {}));
var Fi;
(function(i) {
  i[i.PointerMove = 0] = "PointerMove", i[i.PointerDown = 1] = "PointerDown", i[i.PointerUp = 2] = "PointerUp";
})(Fi || (Fi = {}));
var la = function() {
  function i() {
  }
  return i.DOM_DELTA_PIXEL = 0, i.DOM_DELTA_LINE = 1, i.DOM_DELTA_PAGE = 2, i;
}(), Ft = function() {
  function i() {
  }
  return i.CreateDeviceEvent = function(e, t, r, n, a, s) {
    switch (e) {
      case B.Keyboard:
        return this._CreateKeyboardEvent(r, n, a, s);
      case B.Mouse:
        if (r === X.MouseWheelX || r === X.MouseWheelY || r === X.MouseWheelZ)
          return this._CreateWheelEvent(e, t, r, n, a, s);
      case B.Touch:
        return this._CreatePointerEvent(e, t, r, n, a, s);
      default:
        throw "Unable to generate event for device ".concat(B[e]);
    }
  }, i._CreatePointerEvent = function(e, t, r, n, a, s) {
    var o = this._CreateMouseEvent(e, t, r, n, a, s);
    return e === B.Mouse ? (o.deviceType = B.Mouse, o.pointerId = 1, o.pointerType = "mouse") : (o.deviceType = B.Touch, o.pointerId = t, o.pointerType = "touch"), r === X.Move ? o.type = "pointermove" : r >= X.LeftClick && r <= X.RightClick && (o.type = n === 1 ? "pointerdown" : "pointerup", o.button = r - 2), o;
  }, i._CreateWheelEvent = function(e, t, r, n, a, s) {
    var o = this._CreateMouseEvent(e, t, r, n, a, s);
    switch (o.type = "wheel", o.deltaMode = la.DOM_DELTA_PIXEL, o.deltaX = 0, o.deltaY = 0, o.deltaZ = 0, r) {
      case X.MouseWheelX:
        o.deltaX = n;
        break;
      case X.MouseWheelY:
        o.deltaY = n;
        break;
      case X.MouseWheelZ:
        o.deltaZ = n;
        break;
    }
    return o;
  }, i._CreateMouseEvent = function(e, t, r, n, a, s) {
    var o = this._CreateEvent(s), u = a.pollInput(e, t, X.Horizontal), f = a.pollInput(e, t, X.Vertical);
    return s ? (o.movementX = 0, o.movementY = 0, o.offsetX = o.movementX - s.getBoundingClientRect().x, o.offsetY = o.movementY - s.getBoundingClientRect().y) : (o.movementX = a.pollInput(e, t, Rr.DeltaHorizontal), o.movementY = a.pollInput(e, t, Rr.DeltaVertical), o.offsetX = 0, o.offsetY = 0), this._CheckNonCharacterKeys(o, a), o.clientX = u, o.clientY = f, o.x = u, o.y = f, o.deviceType = e, o.deviceSlot = t, o.inputIndex = r, o;
  }, i._CreateKeyboardEvent = function(e, t, r, n) {
    var a = this._CreateEvent(n);
    return this._CheckNonCharacterKeys(a, r), a.deviceType = B.Keyboard, a.deviceSlot = 0, a.inputIndex = e, a.type = t === 1 ? "keydown" : "keyup", a.key = String.fromCharCode(e), a.keyCode = e, a;
  }, i._CheckNonCharacterKeys = function(e, t) {
    var r = t.isDeviceAvailable(B.Keyboard), n = r && t.pollInput(B.Keyboard, 0, 18) === 1, a = r && t.pollInput(B.Keyboard, 0, 17) === 1, s = r && (t.pollInput(B.Keyboard, 0, 91) === 1 || t.pollInput(B.Keyboard, 0, 92) === 1 || t.pollInput(B.Keyboard, 0, 93) === 1), o = r && t.pollInput(B.Keyboard, 0, 16) === 1;
    e.altKey = n, e.ctrlKey = a, e.metaKey = s, e.shiftKey = o;
  }, i._CreateEvent = function(e) {
    var t = {};
    return t.preventDefault = function() {
    }, t.target = e, t;
  }, i;
}(), ha = function() {
  function i(e, t, r) {
    var n = this;
    this._nativeInput = _native.DeviceInputSystem ? new _native.DeviceInputSystem(e, t, function(a, s, o, u) {
      var f = Ft.CreateDeviceEvent(a, s, o, u, n);
      r(a, s, f);
    }) : this._createDummyNativeInput();
  }
  return i.prototype.pollInput = function(e, t, r) {
    return this._nativeInput.pollInput(e, t, r);
  }, i.prototype.isDeviceAvailable = function(e) {
    return e === B.Mouse || e === B.Touch;
  }, i.prototype.dispose = function() {
    this._nativeInput.dispose();
  }, i.prototype._createDummyNativeInput = function() {
    var e = {
      pollInput: function() {
        return 0;
      },
      isDeviceAvailable: function() {
        return !1;
      },
      dispose: function() {
      }
    };
    return e;
  }, i;
}(), wi = 255, Li = Object.keys(X).length / 2, ca = function() {
  function i(e, t, r, n) {
    var a = this;
    this._inputs = [], this._keyboardActive = !1, this._pointerActive = !1, this._usingSafari = de.IsSafari(), this._keyboardDownEvent = function(s) {
    }, this._keyboardUpEvent = function(s) {
    }, this._keyboardBlurEvent = function(s) {
    }, this._pointerMoveEvent = function(s) {
    }, this._pointerDownEvent = function(s) {
    }, this._pointerUpEvent = function(s) {
    }, this._pointerCancelEvent = function(s) {
    }, this._pointerWheelEvent = function(s) {
    }, this._pointerBlurEvent = function(s) {
    }, this._eventsAttached = !1, this._mouseId = -1, this._isUsingFirefox = ti.IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1, this._maxTouchPoints = 0, this._pointerInputClearObserver = null, this._gamepadConnectedEvent = function(s) {
    }, this._gamepadDisconnectedEvent = function(s) {
    }, this._eventPrefix = de.GetPointerPrefix(e), this._engine = e, this._onDeviceConnected = t, this._onDeviceDisconnected = r, this._onInputChanged = n, this._enableEvents(), this._engine._onEngineViewChanged || (this._engine._onEngineViewChanged = function() {
      a._enableEvents();
    });
  }
  return i.prototype.pollInput = function(e, t, r) {
    var n = this._inputs[e][t];
    if (!n)
      throw "Unable to find device ".concat(B[e]);
    e >= B.DualShock && e <= B.DualSense && navigator.getGamepads && this._updateDevice(e, t, r);
    var a = n[r];
    if (a === void 0)
      throw "Unable to find input ".concat(r, " for device ").concat(B[e], " in slot ").concat(t);
    return r === X.Move && de.Warn("Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data."), a;
  }, i.prototype.isDeviceAvailable = function(e) {
    return this._inputs[e] !== void 0;
  }, i.prototype.dispose = function() {
    this._onDeviceConnected = function() {
    }, this._onDeviceDisconnected = function() {
    }, this._onInputChanged = function() {
    }, delete this._engine._onEngineViewChanged, this._elementToAttachTo && this._disableEvents();
  }, i.prototype._enableEvents = function() {
    var e = this === null || this === void 0 ? void 0 : this._engine.getInputElement();
    if (e && (!this._eventsAttached || this._elementToAttachTo !== e)) {
      if (this._disableEvents(), this._inputs)
        for (var t = 0, r = this._inputs; t < r.length; t++) {
          var n = r[t];
          if (n)
            for (var a in n) {
              var s = +a, o = n[s];
              if (o)
                for (var u = 0; u < o.length; u++)
                  o[u] = 0;
            }
        }
      this._elementToAttachTo = e, this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex, this._handleKeyActions(), this._handlePointerActions(), this._handleGamepadActions(), this._eventsAttached = !0, this._checkForConnectedDevices();
    }
  }, i.prototype._disableEvents = function() {
    this._elementToAttachTo && (this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent), this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent), this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent), this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent), this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent), window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent), window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent)), this._pointerInputClearObserver && this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver), this._eventsAttached = !1;
  }, i.prototype._checkForConnectedDevices = function() {
    if (navigator.getGamepads)
      for (var e = navigator.getGamepads(), t = 0, r = e; t < r.length; t++) {
        var n = r[t];
        n && this._addGamePad(n);
      }
    typeof matchMedia == "function" && matchMedia("(pointer:fine)").matches && this._addPointerDevice(B.Mouse, 0, 0, 0);
  }, i.prototype._addGamePad = function(e) {
    var t = this._getGamepadDeviceType(e.id), r = e.index;
    this._gamepads = this._gamepads || new Array(e.index + 1), this._registerDevice(t, r, e.buttons.length + e.axes.length), this._gamepads[r] = t;
  }, i.prototype._addPointerDevice = function(e, t, r, n) {
    this._pointerActive || (this._pointerActive = !0), this._registerDevice(e, t, Li);
    var a = this._inputs[e][t];
    a[0] = r, a[1] = n;
  }, i.prototype._registerDevice = function(e, t, r) {
    if (t === void 0)
      throw "Unable to register device ".concat(B[e], " to undefined slot.");
    if (this._inputs[e] || (this._inputs[e] = {}), !this._inputs[e][t]) {
      for (var n = new Array(r), a = 0; a < r; a++)
        n[a] = 0;
      this._inputs[e][t] = n, this._onDeviceConnected(e, t);
    }
  }, i.prototype._unregisterDevice = function(e, t) {
    this._inputs[e][t] && (delete this._inputs[e][t], this._onDeviceDisconnected(e, t));
  }, i.prototype._handleKeyActions = function() {
    var e = this;
    this._keyboardDownEvent = function(t) {
      e._keyboardActive || (e._keyboardActive = !0, e._registerDevice(B.Keyboard, 0, wi));
      var r = e._inputs[B.Keyboard][0];
      if (r) {
        r[t.keyCode] = 1;
        var n = t;
        n.inputIndex = t.keyCode, e._onInputChanged(B.Keyboard, 0, n);
      }
    }, this._keyboardUpEvent = function(t) {
      e._keyboardActive || (e._keyboardActive = !0, e._registerDevice(B.Keyboard, 0, wi));
      var r = e._inputs[B.Keyboard][0];
      if (r) {
        r[t.keyCode] = 0;
        var n = t;
        n.inputIndex = t.keyCode, e._onInputChanged(B.Keyboard, 0, n);
      }
    }, this._keyboardBlurEvent = function() {
      if (e._keyboardActive) {
        for (var t = e._inputs[B.Keyboard][0], r = 0; r < t.length; r++)
          if (t[r] !== 0) {
            t[r] = 0;
            var n = Ft.CreateDeviceEvent(B.Keyboard, 0, r, 0, e, e._elementToAttachTo);
            e._onInputChanged(B.Keyboard, 0, n);
          }
      }
    }, this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent), this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent), this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent);
  }, i.prototype._handlePointerActions = function() {
    var e = this;
    this._maxTouchPoints = ti.IsNavigatorAvailable() && navigator.maxTouchPoints || 2, this._activeTouchIds || (this._activeTouchIds = new Array(this._maxTouchPoints));
    for (var t = 0; t < this._maxTouchPoints; t++)
      this._activeTouchIds[t] = -1;
    this._pointerMoveEvent = function(s) {
      var o = e._getPointerType(s), u = o === B.Mouse ? 0 : e._activeTouchIds.indexOf(s.pointerId);
      e._inputs[o] || (e._inputs[o] = {}), e._inputs[o][u] || e._addPointerDevice(o, u, s.clientX, s.clientY);
      var f = e._inputs[o][u];
      if (f) {
        f[X.Horizontal] = s.clientX, f[X.Vertical] = s.clientY;
        var l = s;
        l.inputIndex = X.Move, e._onInputChanged(o, u, l), !e._usingSafari && s.button !== -1 && (l.inputIndex = s.button + 2, f[s.button + 2] = f[s.button + 2] ? 0 : 1, e._onInputChanged(o, u, l));
      }
    }, this._pointerDownEvent = function(s) {
      var o = e._getPointerType(s), u = o === B.Mouse ? 0 : s.pointerId;
      if (o === B.Touch) {
        var f = e._activeTouchIds.indexOf(-1);
        if (f >= 0)
          u = f, e._activeTouchIds[f] = s.pointerId;
        else {
          de.Warn("Max number of touches exceeded.  Ignoring touches in excess of ".concat(e._maxTouchPoints));
          return;
        }
      }
      e._inputs[o] || (e._inputs[o] = {}), e._inputs[o][u] ? o === B.Touch && e._onDeviceConnected(o, u) : e._addPointerDevice(o, u, s.clientX, s.clientY);
      var l = e._inputs[o][u];
      if (l) {
        var h = l[X.Horizontal], c = l[X.Vertical];
        if (o === B.Mouse) {
          if (e._mouseId === -1 && (s.pointerId === void 0 ? e._mouseId = e._isUsingFirefox ? 0 : 1 : e._mouseId = s.pointerId), !document.pointerLockElement && e._elementToAttachTo.hasPointerCapture)
            try {
              e._elementToAttachTo.setPointerCapture(e._mouseId);
            } catch {
            }
        } else if (s.pointerId && !document.pointerLockElement && e._elementToAttachTo.hasPointerCapture)
          try {
            e._elementToAttachTo.setPointerCapture(s.pointerId);
          } catch {
          }
        l[X.Horizontal] = s.clientX, l[X.Vertical] = s.clientY, l[s.button + 2] = 1;
        var d = s;
        d.inputIndex = s.button + 2, e._onInputChanged(o, u, d), (h !== s.clientX || c !== s.clientY) && (d.inputIndex = X.Move, e._onInputChanged(o, u, d));
      }
    }, this._pointerUpEvent = function(s) {
      var o, u, f, l, h, c = e._getPointerType(s), d = c === B.Mouse ? 0 : e._activeTouchIds.indexOf(s.pointerId);
      if (c === B.Touch) {
        if (d === -1)
          return;
        e._activeTouchIds[d] = -1;
      }
      var p = (o = e._inputs[c]) === null || o === void 0 ? void 0 : o[d];
      if (p && p[s.button + 2] !== 0) {
        var g = p[X.Horizontal], _ = p[X.Vertical];
        p[X.Horizontal] = s.clientX, p[X.Vertical] = s.clientY, p[s.button + 2] = 0;
        var v = s;
        (g !== s.clientX || _ !== s.clientY) && (v.inputIndex = X.Move, e._onInputChanged(c, d, v)), v.inputIndex = s.button + 2, c === B.Mouse && e._mouseId >= 0 && ((f = (u = e._elementToAttachTo).hasPointerCapture) === null || f === void 0 ? void 0 : f.call(u, e._mouseId)) ? e._elementToAttachTo.releasePointerCapture(e._mouseId) : s.pointerId && ((h = (l = e._elementToAttachTo).hasPointerCapture) === null || h === void 0 ? void 0 : h.call(l, s.pointerId)) && e._elementToAttachTo.releasePointerCapture(s.pointerId), e._onInputChanged(c, d, v), c === B.Touch && e._onDeviceDisconnected(c, d);
      }
    }, this._pointerCancelEvent = function(s) {
      var o, u, f, l;
      if (s.pointerType === "mouse") {
        var h = e._inputs[B.Mouse][0];
        e._mouseId >= 0 && ((u = (o = e._elementToAttachTo).hasPointerCapture) === null || u === void 0 ? void 0 : u.call(o, e._mouseId)) && e._elementToAttachTo.releasePointerCapture(e._mouseId);
        for (var c = X.LeftClick; c <= X.BrowserForward; c++)
          if (h[c] === 1) {
            h[c] = 0;
            var d = Ft.CreateDeviceEvent(B.Mouse, 0, c, 0, e, e._elementToAttachTo);
            e._onInputChanged(B.Mouse, 0, d);
          }
      } else {
        var p = e._activeTouchIds.indexOf(s.pointerId);
        !((l = (f = e._elementToAttachTo).hasPointerCapture) === null || l === void 0) && l.call(f, s.pointerId) && e._elementToAttachTo.releasePointerCapture(s.pointerId), e._inputs[B.Touch][p][X.LeftClick] = 0;
        var d = Ft.CreateDeviceEvent(B.Touch, p, X.LeftClick, 0, e, e._elementToAttachTo);
        e._onInputChanged(B.Touch, p, d), e._activeTouchIds[p] = -1, e._onDeviceDisconnected(B.Touch, p);
      }
    }, this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
    var r = !1, n = function() {
    };
    try {
      var a = {
        passive: {
          get: function() {
            r = !0;
          }
        }
      };
      this._elementToAttachTo.addEventListener("test", n, a), this._elementToAttachTo.removeEventListener("test", n, a);
    } catch {
    }
    this._pointerBlurEvent = function() {
      var s, o, u, f, l;
      if (e.isDeviceAvailable(B.Mouse)) {
        var h = e._inputs[B.Mouse][0];
        e._mouseId >= 0 && ((o = (s = e._elementToAttachTo).hasPointerCapture) === null || o === void 0 ? void 0 : o.call(s, e._mouseId)) && e._elementToAttachTo.releasePointerCapture(e._mouseId);
        for (var c = X.LeftClick; c <= X.BrowserForward; c++)
          if (h[c] === 1) {
            h[c] = 0;
            var d = Ft.CreateDeviceEvent(B.Mouse, 0, c, 0, e, e._elementToAttachTo);
            e._onInputChanged(B.Mouse, 0, d);
          }
      }
      if (e.isDeviceAvailable(B.Touch))
        for (var h = e._inputs[B.Touch], p = 0; p < e._activeTouchIds.length; p++) {
          var g = e._activeTouchIds[p];
          if (!((f = (u = e._elementToAttachTo).hasPointerCapture) === null || f === void 0) && f.call(u, g) && e._elementToAttachTo.releasePointerCapture(g), g !== -1 && ((l = h[p]) === null || l === void 0 ? void 0 : l[X.LeftClick]) === 1) {
            h[p][X.LeftClick] = 0;
            var d = Ft.CreateDeviceEvent(B.Touch, p, X.LeftClick, 0, e, e._elementToAttachTo);
            e._onInputChanged(B.Touch, p, d), e._activeTouchIds[p] = -1, e._onDeviceDisconnected(B.Touch, p);
          }
        }
    }, this._pointerWheelEvent = function(s) {
      var o = B.Mouse, u = 0;
      e._inputs[o] || (e._inputs[o] = []), e._inputs[o][u] || (e._pointerActive = !0, e._registerDevice(o, u, Li));
      var f = e._inputs[o][u];
      if (f) {
        f[X.MouseWheelX] = s.deltaX || 0, f[X.MouseWheelY] = s.deltaY || s.wheelDelta || 0, f[X.MouseWheelZ] = s.deltaZ || 0;
        var l = s;
        f[X.MouseWheelX] !== 0 && (l.inputIndex = X.MouseWheelX, e._onInputChanged(o, u, l)), f[X.MouseWheelY] !== 0 && (l.inputIndex = X.MouseWheelY, e._onInputChanged(o, u, l)), f[X.MouseWheelZ] !== 0 && (l.inputIndex = X.MouseWheelZ, e._onInputChanged(o, u, l));
      }
    }, this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent), this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent), this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, r ? { passive: !1 } : !1), this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(function() {
      if (e.isDeviceAvailable(B.Mouse)) {
        var s = e._inputs[B.Mouse][0];
        s[X.MouseWheelX] = 0, s[X.MouseWheelY] = 0, s[X.MouseWheelZ] = 0;
      }
    });
  }, i.prototype._handleGamepadActions = function() {
    var e = this;
    this._gamepadConnectedEvent = function(t) {
      e._addGamePad(t.gamepad);
    }, this._gamepadDisconnectedEvent = function(t) {
      if (e._gamepads) {
        var r = e._getGamepadDeviceType(t.gamepad.id), n = t.gamepad.index;
        e._unregisterDevice(r, n), delete e._gamepads[n];
      }
    }, window.addEventListener("gamepadconnected", this._gamepadConnectedEvent), window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
  }, i.prototype._updateDevice = function(e, t, r) {
    var n = navigator.getGamepads()[t];
    if (n && e === this._gamepads[t]) {
      var a = this._inputs[e][t];
      r >= n.buttons.length ? a[r] = n.axes[r - n.buttons.length].valueOf() : a[r] = n.buttons[r].value;
    }
  }, i.prototype._getGamepadDeviceType = function(e) {
    return e.indexOf("054c") !== -1 ? e.indexOf("0ce6") !== -1 ? B.DualSense : B.DualShock : e.indexOf("Xbox One") !== -1 || e.search("Xbox 360") !== -1 || e.search("xinput") !== -1 ? B.Xbox : e.indexOf("057e") !== -1 ? B.Switch : B.Generic;
  }, i.prototype._getPointerType = function(e) {
    var t = B.Mouse;
    return (e.pointerType === "touch" || e.pointerType === "pen" || e.touches) && (t = B.Touch), t;
  }, i;
}(), Ni = function() {
  function i(e, t, r) {
    r === void 0 && (r = 0), this.deviceType = t, this.deviceSlot = r, this.onInputChangedObservable = new O(), this._deviceInputSystem = e;
  }
  return i.prototype.getInput = function(e) {
    return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, e);
  }, i;
}(), da = function() {
  function i(e) {
    var t = this;
    this._registeredManagers = new Array(), this._refCount = 0, this.registerManager = function(o) {
      for (var u = 0; u < t._devices.length; u++) {
        var f = t._devices[u];
        for (var l in f) {
          var h = +l;
          o._addDevice(new Ni(t._deviceInputSystem, u, h));
        }
      }
      t._registeredManagers.push(o);
    }, this.unregisterManager = function(o) {
      var u = t._registeredManagers.indexOf(o);
      u > -1 && t._registeredManagers.splice(u, 1);
    };
    var r = Object.keys(B).length / 2;
    this._devices = new Array(r);
    var n = function(o, u) {
      t._devices[o] || (t._devices[o] = new Array()), t._devices[o][u] || (t._devices[o][u] = u);
      for (var f = 0, l = t._registeredManagers; f < l.length; f++) {
        var h = l[f], c = new Ni(t._deviceInputSystem, o, u);
        h._addDevice(c);
      }
    }, a = function(o, u) {
      var f;
      !((f = t._devices[o]) === null || f === void 0) && f[u] && delete t._devices[o][u];
      for (var l = 0, h = t._registeredManagers; l < h.length; l++) {
        var c = h[l];
        c._removeDevice(o, u);
      }
    }, s = function(o, u, f) {
      if (f)
        for (var l = 0, h = t._registeredManagers; l < h.length; l++) {
          var c = h[l];
          c._onInputChanged(o, u, f);
        }
    };
    typeof _native < "u" ? this._deviceInputSystem = new ha(n, a, s) : this._deviceInputSystem = new ca(e, n, a, s);
  }
  return i.prototype.dispose = function() {
    this._deviceInputSystem.dispose();
  }, i;
}(), pa = function() {
  function i(e) {
    var t = this, r = Object.keys(B).length / 2;
    this._devices = new Array(r), this._firstDevice = new Array(r), this._engine = e, this._engine._deviceSourceManager || (this._engine._deviceSourceManager = new da(e)), this._engine._deviceSourceManager._refCount++, this.onDeviceConnectedObservable = new O(function(n) {
      for (var a = 0, s = t._devices; a < s.length; a++) {
        var o = s[a];
        if (o)
          for (var u = 0, f = o; u < f.length; u++) {
            var l = f[u];
            l && t.onDeviceConnectedObservable.notifyObserver(n, l);
          }
      }
    }), this.onDeviceDisconnectedObservable = new O(), this._engine._deviceSourceManager.registerManager(this), this._onDisposeObserver = e.onDisposeObservable.add(function() {
      t.dispose();
    });
  }
  return i.prototype.getDeviceSource = function(e, t) {
    if (t === void 0) {
      if (this._firstDevice[e] === void 0)
        return null;
      t = this._firstDevice[e];
    }
    return !this._devices[e] || this._devices[e][t] === void 0 ? null : this._devices[e][t];
  }, i.prototype.getDeviceSources = function(e) {
    return this._devices[e].filter(function(t) {
      return !!t;
    });
  }, i.prototype.dispose = function() {
    this.onDeviceConnectedObservable.clear(), this.onDeviceDisconnectedObservable.clear(), this._engine._deviceSourceManager && (this._engine._deviceSourceManager.unregisterManager(this), --this._engine._deviceSourceManager._refCount < 1 && (this._engine._deviceSourceManager.dispose(), delete this._engine._deviceSourceManager)), this._engine.onDisposeObservable.remove(this._onDisposeObserver);
  }, i.prototype._addDevice = function(e) {
    this._devices[e.deviceType] || (this._devices[e.deviceType] = new Array()), this._devices[e.deviceType][e.deviceSlot] || (this._devices[e.deviceType][e.deviceSlot] = e, this._updateFirstDevices(e.deviceType)), this.onDeviceConnectedObservable.notifyObservers(e);
  }, i.prototype._removeDevice = function(e, t) {
    var r, n, a = (r = this._devices[e]) === null || r === void 0 ? void 0 : r[t];
    this.onDeviceDisconnectedObservable.notifyObservers(a), !((n = this._devices[e]) === null || n === void 0) && n[t] && delete this._devices[e][t], this._updateFirstDevices(e);
  }, i.prototype._onInputChanged = function(e, t, r) {
    var n, a;
    (a = (n = this._devices[e]) === null || n === void 0 ? void 0 : n[t]) === null || a === void 0 || a.onInputChangedObservable.notifyObservers(r);
  }, i.prototype._updateFirstDevices = function(e) {
    switch (e) {
      case B.Keyboard:
      case B.Mouse:
        this._firstDevice[e] = 0;
        break;
      case B.Touch:
      case B.DualSense:
      case B.DualShock:
      case B.Xbox:
      case B.Switch:
      case B.Generic: {
        delete this._firstDevice[e];
        var t = this._devices[e];
        if (t) {
          for (var r = 0; r < t.length; r++)
            if (t[r]) {
              this._firstDevice[e] = r;
              break;
            }
        }
        break;
      }
    }
  }, i;
}(), Bi = function() {
  function i() {
    this._singleClick = !1, this._doubleClick = !1, this._hasSwiped = !1, this._ignore = !1;
  }
  return Object.defineProperty(i.prototype, "singleClick", {
    get: function() {
      return this._singleClick;
    },
    set: function(e) {
      this._singleClick = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "doubleClick", {
    get: function() {
      return this._doubleClick;
    },
    set: function(e) {
      this._doubleClick = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "hasSwiped", {
    get: function() {
      return this._hasSwiped;
    },
    set: function(e) {
      this._hasSwiped = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "ignore", {
    get: function() {
      return this._ignore;
    },
    set: function(e) {
      this._ignore = e;
    },
    enumerable: !1,
    configurable: !0
  }), i;
}(), lt = function() {
  function i(e) {
    this._alreadyAttached = !1, this._meshPickProceed = !1, this._currentPickResult = null, this._previousPickResult = null, this._totalPointersPressed = 0, this._doubleClickOccured = !1, this._pointerX = 0, this._pointerY = 0, this._startingPointerPosition = new Ee(0, 0), this._previousStartingPointerPosition = new Ee(0, 0), this._startingPointerTime = 0, this._previousStartingPointerTime = 0, this._pointerCaptures = {}, this._meshUnderPointerId = {}, this._deviceSourceManager = null, this._scene = e || re.LastCreatedScene, this._scene;
  }
  return Object.defineProperty(i.prototype, "meshUnderPointer", {
    get: function() {
      return this._pointerOverMesh;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getMeshUnderPointerByPointerId = function(e) {
    return this._meshUnderPointerId[e] || null;
  }, Object.defineProperty(i.prototype, "unTranslatedPointer", {
    get: function() {
      return new Ee(this._unTranslatedPointerX, this._unTranslatedPointerY);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "pointerX", {
    get: function() {
      return this._pointerX;
    },
    set: function(e) {
      this._pointerX = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "pointerY", {
    get: function() {
      return this._pointerY;
    },
    set: function(e) {
      this._pointerY = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._updatePointerPosition = function(e) {
    var t = this._scene.getEngine().getInputElementClientRect();
    !t || (this._pointerX = e.clientX - t.left, this._pointerY = e.clientY - t.top, this._unTranslatedPointerX = this._pointerX, this._unTranslatedPointerY = this._pointerY);
  }, i.prototype._processPointerMove = function(e, t) {
    var r = this._scene, n = r.getEngine(), a = n.getInputElement();
    a && (a.tabIndex = n.canvasTabIndex, r.doNotHandleCursors || (a.style.cursor = r.defaultCursor));
    var s = !!(e && e.hit && e.pickedMesh);
    if (s) {
      if (r.setPointerOverMesh(e.pickedMesh, t.pointerId, e), !r.doNotHandleCursors && a && this._pointerOverMesh) {
        var o = this._pointerOverMesh._getActionManagerForTrigger();
        o && o.hasPointerTriggers && (a.style.cursor = o.hoverCursor || r.hoverCursor);
      }
    } else
      r.setPointerOverMesh(null, t.pointerId, e);
    for (var u = 0, f = r._pointerMoveStage; u < f.length; u++) {
      var l = f[u];
      e = l.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, s, a);
    }
    if (e) {
      var h = t.type === "wheel" || t.type === "mousewheel" || t.type === "DOMMouseScroll" ? oe.POINTERWHEEL : oe.POINTERMOVE;
      if (r.onPointerMove && r.onPointerMove(t, e, h), r.onPointerObservable.hasObservers()) {
        var c = new Kt(h, t, e);
        this._setRayOnPointerInfo(c), r.onPointerObservable.notifyObservers(c, h);
      }
    }
  }, i.prototype._setRayOnPointerInfo = function(e) {
    var t = this._scene;
    e.pickInfo && !e.pickInfo._pickingUnavailable && (e.pickInfo.ray || (e.pickInfo.ray = t.createPickingRay(e.event.offsetX, e.event.offsetY, I.Identity(), t.activeCamera)));
  }, i.prototype._checkPrePointerObservable = function(e, t, r) {
    var n = this._scene, a = new fa(r, t, this._unTranslatedPointerX, this._unTranslatedPointerY);
    return e && (a.ray = e.ray, e.originMesh && (a.nearInteractionPickingInfo = e)), n.onPrePointerObservable.notifyObservers(a, r), !!a.skipOnPointerObservable;
  }, i.prototype.simulatePointerMove = function(e, t) {
    var r = new PointerEvent("pointermove", t);
    r.inputIndex = X.Move, !this._checkPrePointerObservable(e, r, oe.POINTERMOVE) && this._processPointerMove(e, r);
  }, i.prototype.simulatePointerDown = function(e, t) {
    var r = new PointerEvent("pointerdown", t);
    r.inputIndex = r.button + 2, !this._checkPrePointerObservable(e, r, oe.POINTERDOWN) && this._processPointerDown(e, r);
  }, i.prototype._processPointerDown = function(e, t) {
    var r = this, n = this._scene;
    if (e && e.hit && e.pickedMesh) {
      this._pickedDownMesh = e.pickedMesh;
      var a = e.pickedMesh._getActionManagerForTrigger();
      if (a) {
        if (a.hasPickTriggers)
          switch (a.processTrigger(5, we.CreateNew(e.pickedMesh, t)), t.button) {
            case 0:
              a.processTrigger(2, we.CreateNew(e.pickedMesh, t));
              break;
            case 1:
              a.processTrigger(4, we.CreateNew(e.pickedMesh, t));
              break;
            case 2:
              a.processTrigger(3, we.CreateNew(e.pickedMesh, t));
              break;
          }
        a.hasSpecificTrigger(8) && window.setTimeout(function() {
          var h = n.pick(r._unTranslatedPointerX, r._unTranslatedPointerY, function(c) {
            return c.isPickable && c.isVisible && c.isReady() && c.actionManager && c.actionManager.hasSpecificTrigger(8) && c === r._pickedDownMesh;
          }, !1, n.cameraToUseForPointers);
          h && h.hit && h.pickedMesh && a && r._totalPointersPressed !== 0 && Date.now() - r._startingPointerTime > i.LongPressDelay && !r._isPointerSwiping() && (r._startingPointerTime = 0, a.processTrigger(8, we.CreateNew(h.pickedMesh, t)));
        }, i.LongPressDelay);
      }
    } else
      for (var s = 0, o = n._pointerDownStage; s < o.length; s++) {
        var u = o[s];
        e = u.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, t);
      }
    if (e) {
      var f = oe.POINTERDOWN;
      if (n.onPointerDown && n.onPointerDown(t, e, f), n.onPointerObservable.hasObservers()) {
        var l = new Kt(f, t, e);
        this._setRayOnPointerInfo(l), n.onPointerObservable.notifyObservers(l, f);
      }
    }
  }, i.prototype._isPointerSwiping = function() {
    return Math.abs(this._startingPointerPosition.x - this._pointerX) > i.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > i.DragMovementThreshold;
  }, i.prototype.simulatePointerUp = function(e, t, r) {
    var n = new PointerEvent("pointerup", t);
    n.inputIndex = X.Move;
    var a = new Bi();
    r ? a.doubleClick = !0 : a.singleClick = !0, !this._checkPrePointerObservable(e, n, oe.POINTERUP) && this._processPointerUp(e, n, a);
  }, i.prototype._processPointerUp = function(e, t, r) {
    var n = this._scene;
    if (e && e.hit && e.pickedMesh) {
      if (this._pickedUpMesh = e.pickedMesh, this._pickedDownMesh === this._pickedUpMesh && (n.onPointerPick && n.onPointerPick(t, e), r.singleClick && !r.ignore && n.onPointerObservable.hasObservers())) {
        var a = oe.POINTERPICK, s = new Kt(a, t, e);
        this._setRayOnPointerInfo(s), n.onPointerObservable.notifyObservers(s, a);
      }
      var o = e.pickedMesh._getActionManagerForTrigger();
      if (o && !r.ignore) {
        o.processTrigger(7, we.CreateNew(e.pickedMesh, t, e)), !r.hasSwiped && r.singleClick && o.processTrigger(1, we.CreateNew(e.pickedMesh, t, e));
        var u = e.pickedMesh._getActionManagerForTrigger(6);
        r.doubleClick && u && u.processTrigger(6, we.CreateNew(e.pickedMesh, t, e));
      }
    } else if (!r.ignore)
      for (var f = 0, l = n._pointerUpStage; f < l.length; f++) {
        var h = l[f];
        e = h.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, t);
      }
    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {
      var c = this._pickedDownMesh._getActionManagerForTrigger(16);
      c && c.processTrigger(16, we.CreateNew(this._pickedDownMesh, t));
    }
    var d = 0;
    if (n.onPointerObservable.hasObservers()) {
      if (!r.ignore && !r.hasSwiped && (r.singleClick && n.onPointerObservable.hasSpecificMask(oe.POINTERTAP) ? d = oe.POINTERTAP : r.doubleClick && n.onPointerObservable.hasSpecificMask(oe.POINTERDOUBLETAP) && (d = oe.POINTERDOUBLETAP), d)) {
        var s = new Kt(d, t, e);
        this._setRayOnPointerInfo(s), n.onPointerObservable.notifyObservers(s, d);
      }
      if (!r.ignore) {
        d = oe.POINTERUP;
        var s = new Kt(d, t, e);
        this._setRayOnPointerInfo(s), n.onPointerObservable.notifyObservers(s, d);
      }
    }
    n.onPointerUp && !r.ignore && n.onPointerUp(t, e, d);
  }, i.prototype.isPointerCaptured = function(e) {
    return e === void 0 && (e = 0), this._pointerCaptures[e];
  }, i.prototype.attachControl = function(e, t, r, n) {
    var a = this;
    e === void 0 && (e = !0), t === void 0 && (t = !0), r === void 0 && (r = !0), n === void 0 && (n = null);
    var s = this._scene, o = s.getEngine();
    n || (n = o.getInputElement()), this._alreadyAttached && this.detachControl(), n && (this._alreadyAttachedTo = n), this._deviceSourceManager = new pa(o), this._initActionManager = function(u) {
      if (!a._meshPickProceed) {
        var f = s.skipPointerUpPicking ? null : s.pick(a._unTranslatedPointerX, a._unTranslatedPointerY, s.pointerUpPredicate, !1, s.cameraToUseForPointers);
        a._currentPickResult = f, f && (u = f.hit && f.pickedMesh ? f.pickedMesh._getActionManagerForTrigger() : null), a._meshPickProceed = !0;
      }
      return u;
    }, this._delayedSimpleClick = function(u, f, l) {
      (Date.now() - a._previousStartingPointerTime > i.DoubleClickDelay && !a._doubleClickOccured || u !== a._previousButtonPressed) && (a._doubleClickOccured = !1, f.singleClick = !0, f.ignore = !1, l(f, a._currentPickResult));
    }, this._initClickEvent = function(u, f, l, h) {
      var c = new Bi();
      a._currentPickResult = null;
      var d = null, p = u.hasSpecificMask(oe.POINTERPICK) || f.hasSpecificMask(oe.POINTERPICK) || u.hasSpecificMask(oe.POINTERTAP) || f.hasSpecificMask(oe.POINTERTAP) || u.hasSpecificMask(oe.POINTERDOUBLETAP) || f.hasSpecificMask(oe.POINTERDOUBLETAP);
      !p && Yt && (d = a._initActionManager(d, c), d && (p = d.hasPickTriggers));
      var g = !1;
      if (p) {
        var _ = l.button;
        if (c.hasSwiped = a._isPointerSwiping(), !c.hasSwiped) {
          var v = !i.ExclusiveDoubleClickMode;
          v || (v = !u.hasSpecificMask(oe.POINTERDOUBLETAP) && !f.hasSpecificMask(oe.POINTERDOUBLETAP), v && !Yt.HasSpecificTrigger(6) && (d = a._initActionManager(d, c), d && (v = !d.hasSpecificTrigger(6)))), v ? (Date.now() - a._previousStartingPointerTime > i.DoubleClickDelay || _ !== a._previousButtonPressed) && (c.singleClick = !0, h(c, a._currentPickResult), g = !0) : (a._previousDelayedSimpleClickTimeout = a._delayedSimpleClickTimeout, a._delayedSimpleClickTimeout = window.setTimeout(a._delayedSimpleClick.bind(a, _, c, h), i.DoubleClickDelay));
          var y = u.hasSpecificMask(oe.POINTERDOUBLETAP) || f.hasSpecificMask(oe.POINTERDOUBLETAP);
          !y && Yt.HasSpecificTrigger(6) && (d = a._initActionManager(d, c), d && (y = d.hasSpecificTrigger(6))), y && (_ === a._previousButtonPressed && Date.now() - a._previousStartingPointerTime < i.DoubleClickDelay && !a._doubleClickOccured ? (!c.hasSwiped && !a._isPointerSwiping() ? (a._previousStartingPointerTime = 0, a._doubleClickOccured = !0, c.doubleClick = !0, c.ignore = !1, i.ExclusiveDoubleClickMode && a._previousDelayedSimpleClickTimeout && clearTimeout(a._previousDelayedSimpleClickTimeout), a._previousDelayedSimpleClickTimeout = a._delayedSimpleClickTimeout, h(c, a._currentPickResult)) : (a._doubleClickOccured = !1, a._previousStartingPointerTime = a._startingPointerTime, a._previousStartingPointerPosition.x = a._startingPointerPosition.x, a._previousStartingPointerPosition.y = a._startingPointerPosition.y, a._previousButtonPressed = _, i.ExclusiveDoubleClickMode ? (a._previousDelayedSimpleClickTimeout && clearTimeout(a._previousDelayedSimpleClickTimeout), a._previousDelayedSimpleClickTimeout = a._delayedSimpleClickTimeout, h(c, a._previousPickResult)) : h(c, a._currentPickResult)), g = !0) : (a._doubleClickOccured = !1, a._previousStartingPointerTime = a._startingPointerTime, a._previousStartingPointerPosition.x = a._startingPointerPosition.x, a._previousStartingPointerPosition.y = a._startingPointerPosition.y, a._previousButtonPressed = _));
        }
      }
      g || h(c, a._currentPickResult);
    }, this._onPointerMove = function(u) {
      if (u.pointerId === void 0 && (u.pointerId = 0), a._updatePointerPosition(u), !a._checkPrePointerObservable(null, u, u.type === "wheel" || u.type === "mousewheel" || u.type === "DOMMouseScroll" ? oe.POINTERWHEEL : oe.POINTERMOVE) && !(!s.cameraToUseForPointers && !s.activeCamera)) {
        if (s.skipPointerMovePicking) {
          a._processPointerMove(new et(), u);
          return;
        }
        s.pointerMovePredicate || (s.pointerMovePredicate = function(l) {
          return l.isPickable && l.isVisible && l.isReady() && l.isEnabled() && (l.enablePointerMoveEvents || s.constantlyUpdateMeshUnderPointer || l._getActionManagerForTrigger() !== null) && (!s.cameraToUseForPointers || (s.cameraToUseForPointers.layerMask & l.layerMask) !== 0);
        });
        var f = s.pick(a._unTranslatedPointerX, a._unTranslatedPointerY, s.pointerMovePredicate, !1, s.cameraToUseForPointers, s.pointerMoveTrianglePredicate);
        a._processPointerMove(f, u);
      }
    }, this._onPointerDown = function(u) {
      if (a._totalPointersPressed++, a._pickedDownMesh = null, a._meshPickProceed = !1, u.pointerId === void 0 && (u.pointerId = 0), a._updatePointerPosition(u), s.preventDefaultOnPointerDown && n && (u.preventDefault(), n.focus()), a._startingPointerPosition.x = a._pointerX, a._startingPointerPosition.y = a._pointerY, a._startingPointerTime = Date.now(), !a._checkPrePointerObservable(null, u, oe.POINTERDOWN) && !(!s.cameraToUseForPointers && !s.activeCamera)) {
        a._pointerCaptures[u.pointerId] = !0, s.pointerDownPredicate || (s.pointerDownPredicate = function(l) {
          return l.isPickable && l.isVisible && l.isReady() && l.isEnabled() && (!s.cameraToUseForPointers || (s.cameraToUseForPointers.layerMask & l.layerMask) !== 0);
        }), a._pickedDownMesh = null;
        var f;
        s.skipPointerDownPicking ? f = new et() : f = s.pick(a._unTranslatedPointerX, a._unTranslatedPointerY, s.pointerDownPredicate, !1, s.cameraToUseForPointers), a._processPointerDown(f, u);
      }
    }, this._onPointerUp = function(u) {
      a._totalPointersPressed !== 0 && (a._totalPointersPressed--, a._pickedUpMesh = null, a._meshPickProceed = !1, u.pointerId === void 0 && (u.pointerId = 0), a._updatePointerPosition(u), s.preventDefaultOnPointerUp && n && (u.preventDefault(), n.focus()), a._initClickEvent(s.onPrePointerObservable, s.onPointerObservable, u, function(f, l) {
        s.onPrePointerObservable.hasObservers() && !f.ignore && (!f.hasSwiped && (f.singleClick && s.onPrePointerObservable.hasSpecificMask(oe.POINTERTAP) && a._checkPrePointerObservable(null, u, oe.POINTERTAP) || f.doubleClick && s.onPrePointerObservable.hasSpecificMask(oe.POINTERDOUBLETAP) && a._checkPrePointerObservable(null, u, oe.POINTERDOUBLETAP)) || a._checkPrePointerObservable(null, u, oe.POINTERUP)) || !a._pointerCaptures[u.pointerId] && u.buttons > 0 || (a._pointerCaptures[u.pointerId] = !1, !(!s.cameraToUseForPointers && !s.activeCamera) && (s.pointerUpPredicate || (s.pointerUpPredicate = function(h) {
          return h.isPickable && h.isVisible && h.isReady() && h.isEnabled() && (!s.cameraToUseForPointers || (s.cameraToUseForPointers.layerMask & h.layerMask) !== 0);
        }), !a._meshPickProceed && (Yt && Yt.HasTriggers || s.onPointerObservable.hasObservers()) && a._initActionManager(null, f), l || (l = a._currentPickResult), a._processPointerUp(l, u, f), a._previousPickResult = a._currentPickResult));
      }));
    }, this._onKeyDown = function(u) {
      var f = Pi.KEYDOWN;
      if (s.onPreKeyboardObservable.hasObservers()) {
        var l = new Ci(f, u);
        if (s.onPreKeyboardObservable.notifyObservers(l, f), l.skipOnKeyboardObservable)
          return;
      }
      if (s.onKeyboardObservable.hasObservers()) {
        var l = new ii(f, u);
        s.onKeyboardObservable.notifyObservers(l, f);
      }
      s.actionManager && s.actionManager.processTrigger(14, we.CreateNewFromScene(s, u));
    }, this._onKeyUp = function(u) {
      var f = Pi.KEYUP;
      if (s.onPreKeyboardObservable.hasObservers()) {
        var l = new Ci(f, u);
        if (s.onPreKeyboardObservable.notifyObservers(l, f), l.skipOnKeyboardObservable)
          return;
      }
      if (s.onKeyboardObservable.hasObservers()) {
        var l = new ii(f, u);
        s.onKeyboardObservable.notifyObservers(l, f);
      }
      s.actionManager && s.actionManager.processTrigger(15, we.CreateNewFromScene(s, u));
    }, this._deviceSourceManager.onDeviceConnectedObservable.add(function(u) {
      u.deviceType === B.Mouse ? u.onInputChangedObservable.add(function(f) {
        f.inputIndex === X.LeftClick || f.inputIndex === X.MiddleClick || f.inputIndex === X.RightClick ? t && u.getInput(f.inputIndex) === 1 ? a._onPointerDown(f) : e && u.getInput(f.inputIndex) === 0 && a._onPointerUp(f) : r && (f.inputIndex === X.Move || f.inputIndex === X.MouseWheelX || f.inputIndex === X.MouseWheelY || f.inputIndex === X.MouseWheelZ) && a._onPointerMove(f);
      }) : u.deviceType === B.Touch ? u.onInputChangedObservable.add(function(f) {
        f.inputIndex === X.LeftClick && (t && u.getInput(f.inputIndex) === 1 ? a._onPointerDown(f) : e && u.getInput(f.inputIndex) === 0 && a._onPointerUp(f)), r && f.inputIndex === X.Move && a._onPointerMove(f);
      }) : u.deviceType === B.Keyboard && u.onInputChangedObservable.add(function(f) {
        f.type === "keydown" ? a._onKeyDown(f) : f.type === "keyup" && a._onKeyUp(f);
      });
    }), this._alreadyAttached = !0;
  }, i.prototype.detachControl = function() {
    this._alreadyAttached && (this._deviceSourceManager.dispose(), this._deviceSourceManager = null, this._alreadyAttachedTo && !this._scene.doNotHandleCursors && (this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor), this._alreadyAttached = !1, this._alreadyAttachedTo = null);
  }, i.prototype.setPointerOverMesh = function(e, t, r) {
    if (t === void 0 && (t = 0), this._meshUnderPointerId[t] !== e) {
      var n = this._meshUnderPointerId[t], a;
      n && (a = n._getActionManagerForTrigger(10), a && a.processTrigger(10, we.CreateNew(n, void 0, { pointerId: t }))), e ? (this._meshUnderPointerId[t] = e, this._pointerOverMesh = e, a = e._getActionManagerForTrigger(9), a && a.processTrigger(9, we.CreateNew(e, void 0, { pointerId: t, pickResult: r }))) : (delete this._meshUnderPointerId[t], this._pointerOverMesh = null);
    }
  }, i.prototype.getPointerOverMesh = function() {
    return this._pointerOverMesh;
  }, i.prototype._invalidateMesh = function(e) {
    this._pointerOverMesh === e && (this._pointerOverMesh = null), this._pickedDownMesh === e && (this._pickedDownMesh = null), this._pickedUpMesh === e && (this._pickedUpMesh = null);
    for (var t in this._meshUnderPointerId)
      this._meshUnderPointerId[t] === e && delete this._meshUnderPointerId[t];
  }, i.DragMovementThreshold = 10, i.LongPressDelay = 500, i.DoubleClickDelay = 300, i.ExclusiveDoubleClickMode = !1, i;
}(), gi = function() {
  function i(e, t, r, n) {
    this.normal = new b(e, t, r), this.d = n;
  }
  return i.prototype.asArray = function() {
    return [this.normal.x, this.normal.y, this.normal.z, this.d];
  }, i.prototype.clone = function() {
    return new i(this.normal.x, this.normal.y, this.normal.z, this.d);
  }, i.prototype.getClassName = function() {
    return "Plane";
  }, i.prototype.getHashCode = function() {
    var e = this.normal.getHashCode();
    return e = e * 397 ^ (this.d | 0), e;
  }, i.prototype.normalize = function() {
    var e = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z), t = 0;
    return e !== 0 && (t = 1 / e), this.normal.x *= t, this.normal.y *= t, this.normal.z *= t, this.d *= t, this;
  }, i.prototype.transform = function(e) {
    var t = i._TmpMatrix;
    e.invertToRef(t);
    var r = t.m, n = this.normal.x, a = this.normal.y, s = this.normal.z, o = this.d, u = n * r[0] + a * r[1] + s * r[2] + o * r[3], f = n * r[4] + a * r[5] + s * r[6] + o * r[7], l = n * r[8] + a * r[9] + s * r[10] + o * r[11], h = n * r[12] + a * r[13] + s * r[14] + o * r[15];
    return new i(u, f, l, h);
  }, i.prototype.dotCoordinate = function(e) {
    return this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z + this.d;
  }, i.prototype.copyFromPoints = function(e, t, r) {
    var n = t.x - e.x, a = t.y - e.y, s = t.z - e.z, o = r.x - e.x, u = r.y - e.y, f = r.z - e.z, l = a * f - s * u, h = s * o - n * f, c = n * u - a * o, d = Math.sqrt(l * l + h * h + c * c), p;
    return d !== 0 ? p = 1 / d : p = 0, this.normal.x = l * p, this.normal.y = h * p, this.normal.z = c * p, this.d = -(this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z), this;
  }, i.prototype.isFrontFacingTo = function(e, t) {
    var r = b.Dot(this.normal, e);
    return r <= t;
  }, i.prototype.signedDistanceTo = function(e) {
    return b.Dot(e, this.normal) + this.d;
  }, i.FromArray = function(e) {
    return new i(e[0], e[1], e[2], e[3]);
  }, i.FromPoints = function(e, t, r) {
    var n = new i(0, 0, 0, 0);
    return n.copyFromPoints(e, t, r), n;
  }, i.FromPositionAndNormal = function(e, t) {
    var r = new i(0, 0, 0, 0);
    return t.normalize(), r.normal = t, r.d = -(t.x * e.x + t.y * e.y + t.z * e.z), r;
  }, i.SignedDistanceToPlaneFromPositionAndNormal = function(e, t, r) {
    var n = -(t.x * e.x + t.y * e.y + t.z * e.z);
    return b.Dot(r, t) + n;
  }, i._TmpMatrix = I.Identity(), i;
}(), Pr = function() {
  function i() {
  }
  return i.GetPlanes = function(e) {
    for (var t = [], r = 0; r < 6; r++)
      t.push(new gi(0, 0, 0, 0));
    return i.GetPlanesToRef(e, t), t;
  }, i.GetNearPlaneToRef = function(e, t) {
    var r = e.m;
    t.normal.x = r[3] + r[2], t.normal.y = r[7] + r[6], t.normal.z = r[11] + r[10], t.d = r[15] + r[14], t.normalize();
  }, i.GetFarPlaneToRef = function(e, t) {
    var r = e.m;
    t.normal.x = r[3] - r[2], t.normal.y = r[7] - r[6], t.normal.z = r[11] - r[10], t.d = r[15] - r[14], t.normalize();
  }, i.GetLeftPlaneToRef = function(e, t) {
    var r = e.m;
    t.normal.x = r[3] + r[0], t.normal.y = r[7] + r[4], t.normal.z = r[11] + r[8], t.d = r[15] + r[12], t.normalize();
  }, i.GetRightPlaneToRef = function(e, t) {
    var r = e.m;
    t.normal.x = r[3] - r[0], t.normal.y = r[7] - r[4], t.normal.z = r[11] - r[8], t.d = r[15] - r[12], t.normalize();
  }, i.GetTopPlaneToRef = function(e, t) {
    var r = e.m;
    t.normal.x = r[3] - r[1], t.normal.y = r[7] - r[5], t.normal.z = r[11] - r[9], t.d = r[15] - r[13], t.normalize();
  }, i.GetBottomPlaneToRef = function(e, t) {
    var r = e.m;
    t.normal.x = r[3] + r[1], t.normal.y = r[7] + r[5], t.normal.z = r[11] + r[9], t.d = r[15] + r[13], t.normalize();
  }, i.GetPlanesToRef = function(e, t) {
    i.GetNearPlaneToRef(e, t[0]), i.GetFarPlaneToRef(e, t[1]), i.GetLeftPlaneToRef(e, t[2]), i.GetRightPlaneToRef(e, t[3]), i.GetTopPlaneToRef(e, t[4]), i.GetBottomPlaneToRef(e, t[5]);
  }, i;
}(), _a = function() {
  function i() {
  }
  return Object.defineProperty(i, "UniqueId", {
    get: function() {
      var e = this._UniqueIdCounter;
      return this._UniqueIdCounter++, e;
    },
    enumerable: !1,
    configurable: !0
  }), i._UniqueIdCounter = 1, i;
}(), Re = function() {
  function i() {
  }
  return i.CompareLightsPriority = function(e, t) {
    return e.shadowEnabled !== t.shadowEnabled ? (t.shadowEnabled ? 1 : 0) - (e.shadowEnabled ? 1 : 0) : t.renderPriority - e.renderPriority;
  }, i.FALLOFF_DEFAULT = 0, i.FALLOFF_PHYSICAL = 1, i.FALLOFF_GLTF = 2, i.FALLOFF_STANDARD = 3, i.LIGHTMAP_DEFAULT = 0, i.LIGHTMAP_SPECULAR = 1, i.LIGHTMAP_SHADOWSONLY = 2, i.INTENSITYMODE_AUTOMATIC = 0, i.INTENSITYMODE_LUMINOUSPOWER = 1, i.INTENSITYMODE_LUMINOUSINTENSITY = 2, i.INTENSITYMODE_ILLUMINANCE = 3, i.INTENSITYMODE_LUMINANCE = 4, i.LIGHTTYPEID_POINTLIGHT = 0, i.LIGHTTYPEID_DIRECTIONALLIGHT = 1, i.LIGHTTYPEID_SPOTLIGHT = 2, i.LIGHTTYPEID_HEMISPHERICLIGHT = 3, i;
}(), Ui = function() {
  function i(e, t) {
    i.IsAvailable && (this._observer = new window.ComputePressureObserver(e, t));
  }
  return Object.defineProperty(i, "IsAvailable", {
    get: function() {
      return me() && "ComputePressureObserver" in window;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.observe = function() {
    var e, t;
    !((e = this._observer) === null || e === void 0) && e.observe && ((t = this._observer) === null || t === void 0 || t.observe().catch(function() {
    }));
  }, i.prototype.unobserve = function() {
    var e, t;
    !((e = this._observer) === null || e === void 0) && e.unobserve && ((t = this._observer) === null || t === void 0 || t.unobserve());
  }, i;
}(), te = function(i) {
  K(e, i);
  function e(t, r) {
    var n = i.call(this) || this;
    n._inputManager = new lt(n), n.cameraToUseForPointers = null, n._isScene = !0, n._blockEntityCollection = !1, n.autoClear = !0, n.autoClearDepthAndStencil = !0, n.clearColor = new be(0.2, 0.2, 0.3, 1), n.ambientColor = new ye(0, 0, 0), n.environmentIntensity = 1, n._forceWireframe = !1, n._skipFrustumClipping = !1, n._forcePointsCloud = !1, n.animationsEnabled = !0, n._animationPropertiesOverride = null, n.useConstantAnimationDeltaTime = !1, n.constantlyUpdateMeshUnderPointer = !1, n.hoverCursor = "pointer", n.defaultCursor = "", n.doNotHandleCursors = !1, n.preventDefaultOnPointerDown = !0, n.preventDefaultOnPointerUp = !0, n.metadata = null, n.reservedDataStore = null, n.disableOfflineSupportExceptionRules = new Array(), n.onDisposeObservable = new O(), n._onDisposeObserver = null, n.onBeforeRenderObservable = new O(), n._onBeforeRenderObserver = null, n.onAfterRenderObservable = new O(), n.onAfterRenderCameraObservable = new O(), n._onAfterRenderObserver = null, n.onBeforeAnimationsObservable = new O(), n.onAfterAnimationsObservable = new O(), n.onBeforeDrawPhaseObservable = new O(), n.onAfterDrawPhaseObservable = new O(), n.onReadyObservable = new O(), n.onBeforeCameraRenderObservable = new O(), n._onBeforeCameraRenderObserver = null, n.onAfterCameraRenderObservable = new O(), n._onAfterCameraRenderObserver = null, n.onBeforeActiveMeshesEvaluationObservable = new O(), n.onAfterActiveMeshesEvaluationObservable = new O(), n.onBeforeParticlesRenderingObservable = new O(), n.onAfterParticlesRenderingObservable = new O(), n.onDataLoadedObservable = new O(), n.onNewCameraAddedObservable = new O(), n.onCameraRemovedObservable = new O(), n.onNewLightAddedObservable = new O(), n.onLightRemovedObservable = new O(), n.onNewGeometryAddedObservable = new O(), n.onGeometryRemovedObservable = new O(), n.onNewTransformNodeAddedObservable = new O(), n.onTransformNodeRemovedObservable = new O(), n.onNewMeshAddedObservable = new O(), n.onMeshRemovedObservable = new O(), n.onNewSkeletonAddedObservable = new O(), n.onSkeletonRemovedObservable = new O(), n.onNewMaterialAddedObservable = new O(), n.onNewMultiMaterialAddedObservable = new O(), n.onMaterialRemovedObservable = new O(), n.onMultiMaterialRemovedObservable = new O(), n.onNewTextureAddedObservable = new O(), n.onTextureRemovedObservable = new O(), n.onBeforeRenderTargetsRenderObservable = new O(), n.onAfterRenderTargetsRenderObservable = new O(), n.onBeforeStepObservable = new O(), n.onAfterStepObservable = new O(), n.onActiveCameraChanged = new O(), n.onBeforeRenderingGroupObservable = new O(), n.onAfterRenderingGroupObservable = new O(), n.onMeshImportedObservable = new O(), n.onAnimationFileImportedObservable = new O(), n._registeredForLateAnimationBindings = new Mt(256), n.skipPointerMovePicking = !1, n.skipPointerDownPicking = !1, n.skipPointerUpPicking = !1, n.onPrePointerObservable = new O(), n.onPointerObservable = new O(), n.onPreKeyboardObservable = new O(), n.onKeyboardObservable = new O(), n._useRightHandedSystem = !1, n._timeAccumulator = 0, n._currentStepId = 0, n._currentInternalStep = 0, n._fogEnabled = !0, n._fogMode = e.FOGMODE_NONE, n.fogColor = new ye(0.2, 0.2, 0.3), n.fogDensity = 0.1, n.fogStart = 0, n.fogEnd = 1e3, n.needsPreviousWorldMatrices = !1, n._shadowsEnabled = !0, n._lightsEnabled = !0, n.activeCameras = new Array(), n._texturesEnabled = !0, n.physicsEnabled = !0, n.particlesEnabled = !0, n.spritesEnabled = !0, n._skeletonsEnabled = !0, n.lensFlaresEnabled = !0, n.collisionsEnabled = !0, n.gravity = new b(0, -9.807, 0), n.postProcessesEnabled = !0, n.renderTargetsEnabled = !0, n.dumpNextRenderTargets = !1, n.customRenderTargets = new Array(), n.importedMeshesFiles = new Array(), n.probesEnabled = !0, n._meshesForIntersections = new Mt(256), n.proceduralTexturesEnabled = !0, n._totalVertices = new qt(), n._activeIndices = new qt(), n._activeParticles = new qt(), n._activeBones = new qt(), n._animationTime = 0, n.animationTimeScale = 1, n._renderId = 0, n._frameId = 0, n._executeWhenReadyTimeoutId = null, n._intermediateRendering = !1, n._defaultFrameBufferCleared = !1, n._viewUpdateFlag = -1, n._projectionUpdateFlag = -1, n._toBeDisposed = new Array(256), n._activeRequests = new Array(), n._pendingData = new Array(), n._isDisposed = !1, n.dispatchAllSubMeshesOfActiveMeshes = !1, n._activeMeshes = new ke(256), n._processedMaterials = new ke(256), n._renderTargets = new Mt(256), n._materialsRenderTargets = new Mt(256), n._activeParticleSystems = new ke(256), n._activeSkeletons = new Mt(32), n._softwareSkinnedMeshes = new Mt(32), n._activeAnimatables = new Array(), n._transformMatrix = I.Zero(), n.requireLightSorting = !1, n._components = [], n._serializableComponents = [], n._transientComponents = [], n._beforeCameraUpdateStage = ge.Create(), n._beforeClearStage = ge.Create(), n._beforeRenderTargetClearStage = ge.Create(), n._gatherRenderTargetsStage = ge.Create(), n._gatherActiveCameraRenderTargetsStage = ge.Create(), n._isReadyForMeshStage = ge.Create(), n._beforeEvaluateActiveMeshStage = ge.Create(), n._evaluateSubMeshStage = ge.Create(), n._preActiveMeshStage = ge.Create(), n._cameraDrawRenderTargetStage = ge.Create(), n._beforeCameraDrawStage = ge.Create(), n._beforeRenderTargetDrawStage = ge.Create(), n._beforeRenderingGroupDrawStage = ge.Create(), n._beforeRenderingMeshStage = ge.Create(), n._afterRenderingMeshStage = ge.Create(), n._afterRenderingGroupDrawStage = ge.Create(), n._afterCameraDrawStage = ge.Create(), n._afterRenderTargetDrawStage = ge.Create(), n._afterRenderStage = ge.Create(), n._pointerMoveStage = ge.Create(), n._pointerDownStage = ge.Create(), n._pointerUpStage = ge.Create(), n._geometriesByUniqueId = null, n._defaultMeshCandidates = {
      data: [],
      length: 0
    }, n._defaultSubMeshCandidates = {
      data: [],
      length: 0
    }, n._preventFreeActiveMeshesAndRenderingGroups = !1, n._activeMeshesFrozen = !1, n._activeMeshesFrozenButKeepClipping = !1, n._skipEvaluateActiveMeshesCompletely = !1, n._allowPostProcessClearColor = !0, n.getDeterministicFrameTime = function() {
      return n._engine.getTimeStep();
    }, n._blockMaterialDirtyMechanism = !1, n._perfCollector = null, n.onComputePressureChanged = new O();
    var a = Tt({ useGeometryUniqueIdsMap: !0, useMaterialMeshMap: !0, useClonedMeshMap: !0, virtual: !1 }, r);
    return n._engine = t || re.LastCreatedEngine, a.virtual ? n._engine._virtualScenes.push(n) : (re._LastCreatedScene = n, n._engine.scenes.push(n)), n._uid = null, n._renderingManager = new Ar(n), Mr && (n.postProcessManager = new Mr(n)), me() && n.attachControl(), n._createUbo(), Vt && (n._imageProcessingConfiguration = new Vt()), n.setDefaultCandidateProviders(), a.useGeometryUniqueIdsMap && (n._geometriesByUniqueId = {}), n.useMaterialMeshMap = a.useMaterialMeshMap, n.useClonedMeshMap = a.useClonedMeshMap, (!r || !r.virtual) && n._engine.onNewSceneAddedObservable.notifyObservers(n), Ui.IsAvailable && (n._computePressureObserver = new Ui(function(s) {
      n.onComputePressureChanged.notifyObservers(s);
    }, {
      cpuUtilizationThresholds: [0.25, 0.5, 0.75, 0.9],
      cpuSpeedThresholds: [0.5]
    }), n._computePressureObserver.observe()), n;
  }
  return e.DefaultMaterialFactory = function(t) {
    throw G("StandardMaterial");
  }, e.CollisionCoordinatorFactory = function() {
    throw G("DefaultCollisionCoordinator");
  }, Object.defineProperty(e.prototype, "environmentTexture", {
    get: function() {
      return this._environmentTexture;
    },
    set: function(t) {
      this._environmentTexture !== t && (this._environmentTexture = t, this.markAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "imageProcessingConfiguration", {
    get: function() {
      return this._imageProcessingConfiguration;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "forceWireframe", {
    get: function() {
      return this._forceWireframe;
    },
    set: function(t) {
      this._forceWireframe !== t && (this._forceWireframe = t, this.markAllMaterialsAsDirty(16));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "skipFrustumClipping", {
    get: function() {
      return this._skipFrustumClipping;
    },
    set: function(t) {
      this._skipFrustumClipping !== t && (this._skipFrustumClipping = t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "forcePointsCloud", {
    get: function() {
      return this._forcePointsCloud;
    },
    set: function(t) {
      this._forcePointsCloud !== t && (this._forcePointsCloud = t, this.markAllMaterialsAsDirty(16));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "animationPropertiesOverride", {
    get: function() {
      return this._animationPropertiesOverride;
    },
    set: function(t) {
      this._animationPropertiesOverride = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "onDispose", {
    set: function(t) {
      this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "beforeRender", {
    set: function(t) {
      this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), t && (this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(t));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "afterRender", {
    set: function(t) {
      this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), t && (this._onAfterRenderObserver = this.onAfterRenderObservable.add(t));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "beforeCameraRender", {
    set: function(t) {
      this._onBeforeCameraRenderObserver && this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver), this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "afterCameraRender", {
    set: function(t) {
      this._onAfterCameraRenderObserver && this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver), this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "unTranslatedPointer", {
    get: function() {
      return this._inputManager.unTranslatedPointer;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "DragMovementThreshold", {
    get: function() {
      return lt.DragMovementThreshold;
    },
    set: function(t) {
      lt.DragMovementThreshold = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "LongPressDelay", {
    get: function() {
      return lt.LongPressDelay;
    },
    set: function(t) {
      lt.LongPressDelay = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "DoubleClickDelay", {
    get: function() {
      return lt.DoubleClickDelay;
    },
    set: function(t) {
      lt.DoubleClickDelay = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "ExclusiveDoubleClickMode", {
    get: function() {
      return lt.ExclusiveDoubleClickMode;
    },
    set: function(t) {
      lt.ExclusiveDoubleClickMode = t;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.bindEyePosition = function(t, r, n) {
    var a;
    r === void 0 && (r = "vEyePosition"), n === void 0 && (n = !1);
    var s = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : (a = this.activeCamera.globalPosition) !== null && a !== void 0 ? a : this.activeCamera.devicePosition, o = this.useRightHandedSystem === (this._mirroredCameraPosition != null);
    return D.Vector4[0].set(s.x, s.y, s.z, o ? -1 : 1), t && (n ? t.setFloat3(r, D.Vector4[0].x, D.Vector4[0].y, D.Vector4[0].z) : t.setVector4(r, D.Vector4[0])), D.Vector4[0];
  }, e.prototype.finalizeSceneUbo = function() {
    var t = this.getSceneUniformBuffer(), r = this.bindEyePosition(null);
    return t.updateFloat4("vEyePosition", r.x, r.y, r.z, r.w), t.update(), t;
  }, Object.defineProperty(e.prototype, "useRightHandedSystem", {
    get: function() {
      return this._useRightHandedSystem;
    },
    set: function(t) {
      this._useRightHandedSystem !== t && (this._useRightHandedSystem = t, this.markAllMaterialsAsDirty(16));
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.setStepId = function(t) {
    this._currentStepId = t;
  }, e.prototype.getStepId = function() {
    return this._currentStepId;
  }, e.prototype.getInternalStep = function() {
    return this._currentInternalStep;
  }, Object.defineProperty(e.prototype, "fogEnabled", {
    get: function() {
      return this._fogEnabled;
    },
    set: function(t) {
      this._fogEnabled !== t && (this._fogEnabled = t, this.markAllMaterialsAsDirty(16));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "fogMode", {
    get: function() {
      return this._fogMode;
    },
    set: function(t) {
      this._fogMode !== t && (this._fogMode = t, this.markAllMaterialsAsDirty(16));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "prePass", {
    get: function() {
      return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "shadowsEnabled", {
    get: function() {
      return this._shadowsEnabled;
    },
    set: function(t) {
      this._shadowsEnabled !== t && (this._shadowsEnabled = t, this.markAllMaterialsAsDirty(2));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "lightsEnabled", {
    get: function() {
      return this._lightsEnabled;
    },
    set: function(t) {
      this._lightsEnabled !== t && (this._lightsEnabled = t, this.markAllMaterialsAsDirty(2));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "activeCamera", {
    get: function() {
      return this._activeCamera;
    },
    set: function(t) {
      t !== this._activeCamera && (this._activeCamera = t, this.onActiveCameraChanged.notifyObservers(this));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "defaultMaterial", {
    get: function() {
      return this._defaultMaterial || (this._defaultMaterial = e.DefaultMaterialFactory(this)), this._defaultMaterial;
    },
    set: function(t) {
      this._defaultMaterial = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "texturesEnabled", {
    get: function() {
      return this._texturesEnabled;
    },
    set: function(t) {
      this._texturesEnabled !== t && (this._texturesEnabled = t, this.markAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "skeletonsEnabled", {
    get: function() {
      return this._skeletonsEnabled;
    },
    set: function(t) {
      this._skeletonsEnabled !== t && (this._skeletonsEnabled = t, this.markAllMaterialsAsDirty(8));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "collisionCoordinator", {
    get: function() {
      return this._collisionCoordinator || (this._collisionCoordinator = e.CollisionCoordinatorFactory(), this._collisionCoordinator.init(this)), this._collisionCoordinator;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "frustumPlanes", {
    get: function() {
      return this._frustumPlanes;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._registerTransientComponents = function() {
    if (this._transientComponents.length > 0) {
      for (var t = 0, r = this._transientComponents; t < r.length; t++) {
        var n = r[t];
        n.register();
      }
      this._transientComponents = [];
    }
  }, e.prototype._addComponent = function(t) {
    this._components.push(t), this._transientComponents.push(t);
    var r = t;
    r.addFromContainer && r.serialize && this._serializableComponents.push(r);
  }, e.prototype._getComponent = function(t) {
    for (var r = 0, n = this._components; r < n.length; r++) {
      var a = n[r];
      if (a.name === t)
        return a;
    }
    return null;
  }, e.prototype.getClassName = function() {
    return "Scene";
  }, e.prototype._getDefaultMeshCandidates = function() {
    return this._defaultMeshCandidates.data = this.meshes, this._defaultMeshCandidates.length = this.meshes.length, this._defaultMeshCandidates;
  }, e.prototype._getDefaultSubMeshCandidates = function(t) {
    return this._defaultSubMeshCandidates.data = t.subMeshes, this._defaultSubMeshCandidates.length = t.subMeshes.length, this._defaultSubMeshCandidates;
  }, e.prototype.setDefaultCandidateProviders = function() {
    this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this), this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this), this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this), this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
  }, Object.defineProperty(e.prototype, "meshUnderPointer", {
    get: function() {
      return this._inputManager.meshUnderPointer;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "pointerX", {
    get: function() {
      return this._inputManager.pointerX;
    },
    set: function(t) {
      this._inputManager.pointerX = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "pointerY", {
    get: function() {
      return this._inputManager.pointerY;
    },
    set: function(t) {
      this._inputManager.pointerY = t;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getCachedMaterial = function() {
    return this._cachedMaterial;
  }, e.prototype.getCachedEffect = function() {
    return this._cachedEffect;
  }, e.prototype.getCachedVisibility = function() {
    return this._cachedVisibility;
  }, e.prototype.isCachedMaterialInvalid = function(t, r, n) {
    return n === void 0 && (n = 1), this._cachedEffect !== r || this._cachedMaterial !== t || this._cachedVisibility !== n;
  }, e.prototype.getEngine = function() {
    return this._engine;
  }, e.prototype.getTotalVertices = function() {
    return this._totalVertices.current;
  }, Object.defineProperty(e.prototype, "totalVerticesPerfCounter", {
    get: function() {
      return this._totalVertices;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getActiveIndices = function() {
    return this._activeIndices.current;
  }, Object.defineProperty(e.prototype, "totalActiveIndicesPerfCounter", {
    get: function() {
      return this._activeIndices;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getActiveParticles = function() {
    return this._activeParticles.current;
  }, Object.defineProperty(e.prototype, "activeParticlesPerfCounter", {
    get: function() {
      return this._activeParticles;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getActiveBones = function() {
    return this._activeBones.current;
  }, Object.defineProperty(e.prototype, "activeBonesPerfCounter", {
    get: function() {
      return this._activeBones;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getActiveMeshes = function() {
    return this._activeMeshes;
  }, e.prototype.getAnimationRatio = function() {
    return this._animationRatio !== void 0 ? this._animationRatio : 1;
  }, e.prototype.getRenderId = function() {
    return this._renderId;
  }, e.prototype.getFrameId = function() {
    return this._frameId;
  }, e.prototype.incrementRenderId = function() {
    this._renderId++;
  }, e.prototype._createUbo = function() {
    this.setSceneUniformBuffer(this.createSceneUniformBuffer());
  }, e.prototype.simulatePointerMove = function(t, r) {
    return this._inputManager.simulatePointerMove(t, r), this;
  }, e.prototype.simulatePointerDown = function(t, r) {
    return this._inputManager.simulatePointerDown(t, r), this;
  }, e.prototype.simulatePointerUp = function(t, r, n) {
    return this._inputManager.simulatePointerUp(t, r, n), this;
  }, e.prototype.isPointerCaptured = function(t) {
    return t === void 0 && (t = 0), this._inputManager.isPointerCaptured(t);
  }, e.prototype.attachControl = function(t, r, n) {
    t === void 0 && (t = !0), r === void 0 && (r = !0), n === void 0 && (n = !0), this._inputManager.attachControl(t, r, n);
  }, e.prototype.detachControl = function() {
    this._inputManager.detachControl();
  }, e.prototype.isReady = function(t) {
    if (t === void 0 && (t = !0), this._isDisposed)
      return !1;
    var r, n = this.getEngine(), a = !0;
    for (this._pendingData.length > 0 && (a = !1), t && (this._processedMaterials.reset(), this._materialsRenderTargets.reset()), r = 0; r < this.meshes.length; r++) {
      var s = this.meshes[r];
      if (!(!s.subMeshes || s.subMeshes.length === 0)) {
        if (!s.isReady(!0)) {
          a = !1;
          continue;
        }
        for (var o = s.hasThinInstances || s.getClassName() === "InstancedMesh" || s.getClassName() === "InstancedLinesMesh" || n.getCaps().instancedArrays && s.instances.length > 0, u = 0, f = this._isReadyForMeshStage; u < f.length; u++) {
          var l = f[u];
          l.action(s, o) || (a = !1);
        }
        if (!!t) {
          var h = s.material || this.defaultMaterial;
          if (h)
            if (h._storeEffectOnSubMeshes)
              for (var c = 0, d = s.subMeshes; c < d.length; c++) {
                var p = d[c], g = p.getMaterial();
                g && g.hasRenderTargetTextures && g.getRenderTargetTextures != null && this._processedMaterials.indexOf(g) === -1 && (this._processedMaterials.push(g), this._materialsRenderTargets.concatWithNoDuplicate(g.getRenderTargetTextures()));
              }
            else
              h.hasRenderTargetTextures && h.getRenderTargetTextures != null && this._processedMaterials.indexOf(h) === -1 && (this._processedMaterials.push(h), this._materialsRenderTargets.concatWithNoDuplicate(h.getRenderTargetTextures()));
        }
      }
    }
    if (!a || !n.areAllEffectsReady())
      return !1;
    if (t)
      for (r = 0; r < this._materialsRenderTargets.length; ++r) {
        var _ = this._materialsRenderTargets.data[r];
        if (!_.isReadyForRendering())
          return !1;
      }
    for (r = 0; r < this.geometries.length; r++) {
      var v = this.geometries[r];
      if (v.delayLoadState === 2)
        return !1;
    }
    if (this.activeCameras && this.activeCameras.length > 0)
      for (var y = 0, E = this.activeCameras; y < E.length; y++) {
        var R = E[y];
        if (!R.isReady(!0))
          return !1;
      }
    else if (this.activeCamera && !this.activeCamera.isReady(!0))
      return !1;
    for (var M = 0, C = this.particleSystems; M < C.length; M++) {
      var A = C[M];
      if (!A.isReady())
        return !1;
    }
    return !0;
  }, e.prototype.resetCachedMaterial = function() {
    this._cachedMaterial = null, this._cachedEffect = null, this._cachedVisibility = null;
  }, e.prototype.registerBeforeRender = function(t) {
    this.onBeforeRenderObservable.add(t);
  }, e.prototype.unregisterBeforeRender = function(t) {
    this.onBeforeRenderObservable.removeCallback(t);
  }, e.prototype.registerAfterRender = function(t) {
    this.onAfterRenderObservable.add(t);
  }, e.prototype.unregisterAfterRender = function(t) {
    this.onAfterRenderObservable.removeCallback(t);
  }, e.prototype._executeOnceBeforeRender = function(t) {
    var r = this, n = function() {
      t(), setTimeout(function() {
        r.unregisterBeforeRender(n);
      });
    };
    this.registerBeforeRender(n);
  }, e.prototype.executeOnceBeforeRender = function(t, r) {
    var n = this;
    r !== void 0 ? setTimeout(function() {
      n._executeOnceBeforeRender(t);
    }, r) : this._executeOnceBeforeRender(t);
  }, e.prototype._addPendingData = function(t) {
    this._pendingData.push(t);
  }, e.prototype._removePendingData = function(t) {
    var r = this.isLoading, n = this._pendingData.indexOf(t);
    n !== -1 && this._pendingData.splice(n, 1), r && !this.isLoading && this.onDataLoadedObservable.notifyObservers(this);
  }, e.prototype.getWaitingItemsCount = function() {
    return this._pendingData.length;
  }, Object.defineProperty(e.prototype, "isLoading", {
    get: function() {
      return this._pendingData.length > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.executeWhenReady = function(t, r) {
    r === void 0 && (r = !1), this.onReadyObservable.add(t), this._executeWhenReadyTimeoutId === null && this._checkIsReady(r);
  }, e.prototype.whenReadyAsync = function(t) {
    var r = this;
    return t === void 0 && (t = !1), new Promise(function(n) {
      r.executeWhenReady(function() {
        n();
      }, t);
    });
  }, e.prototype._checkIsReady = function(t) {
    var r = this;
    if (t === void 0 && (t = !1), this._registerTransientComponents(), this.isReady(t)) {
      this.onReadyObservable.notifyObservers(this), this.onReadyObservable.clear(), this._executeWhenReadyTimeoutId = null;
      return;
    }
    if (this._isDisposed) {
      this.onReadyObservable.clear(), this._executeWhenReadyTimeoutId = null;
      return;
    }
    this._executeWhenReadyTimeoutId = setTimeout(function() {
      r._checkIsReady(t);
    }, 100);
  }, Object.defineProperty(e.prototype, "animatables", {
    get: function() {
      return this._activeAnimatables;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.resetLastAnimationTimeFrame = function() {
    this._animationTimeLast = Ut.Now;
  }, e.prototype.getViewMatrix = function() {
    return this._viewMatrix;
  }, e.prototype.getProjectionMatrix = function() {
    return this._projectionMatrix;
  }, e.prototype.getTransformMatrix = function() {
    return this._transformMatrix;
  }, e.prototype.setTransformMatrix = function(t, r, n, a) {
    !n && !a && this._multiviewSceneUbo && (this._multiviewSceneUbo.dispose(), this._multiviewSceneUbo = null), !(this._viewUpdateFlag === t.updateFlag && this._projectionUpdateFlag === r.updateFlag) && (this._viewUpdateFlag = t.updateFlag, this._projectionUpdateFlag = r.updateFlag, this._viewMatrix = t, this._projectionMatrix = r, this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._frustumPlanes ? Pr.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = Pr.GetPlanes(this._transformMatrix), this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo ? this._updateMultiviewUbo(n, a) : this._sceneUbo.useUbo && (this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix), this._sceneUbo.updateMatrix("view", this._viewMatrix), this._sceneUbo.updateMatrix("projection", this._projectionMatrix)));
  }, e.prototype.getSceneUniformBuffer = function() {
    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;
  }, e.prototype.createSceneUniformBuffer = function(t) {
    var r = new wr(this._engine, void 0, !1, t != null ? t : "scene");
    return r.addUniform("viewProjection", 16), r.addUniform("view", 16), r.addUniform("projection", 16), r.addUniform("vEyePosition", 4), r;
  }, e.prototype.setSceneUniformBuffer = function(t) {
    this._sceneUbo = t, this._viewUpdateFlag = -1, this._projectionUpdateFlag = -1;
  }, e.prototype.getUniqueId = function() {
    return _a.UniqueId;
  }, e.prototype.addMesh = function(t, r) {
    var n = this;
    r === void 0 && (r = !1), !this._blockEntityCollection && (this.meshes.push(t), t._resyncLightSources(), t.parent || t._addToSceneRootNodes(), this.onNewMeshAddedObservable.notifyObservers(t), r && t.getChildMeshes().forEach(function(a) {
      n.addMesh(a);
    }));
  }, e.prototype.removeMesh = function(t, r) {
    var n = this;
    r === void 0 && (r = !1);
    var a = this.meshes.indexOf(t);
    return a !== -1 && (this.meshes[a] = this.meshes[this.meshes.length - 1], this.meshes.pop(), t.parent || t._removeFromSceneRootNodes()), this._inputManager._invalidateMesh(t), this.onMeshRemovedObservable.notifyObservers(t), r && t.getChildMeshes().forEach(function(s) {
      n.removeMesh(s);
    }), a;
  }, e.prototype.addTransformNode = function(t) {
    this._blockEntityCollection || t.getScene() === this && t._indexInSceneTransformNodesArray !== -1 || (t._indexInSceneTransformNodesArray = this.transformNodes.length, this.transformNodes.push(t), t.parent || t._addToSceneRootNodes(), this.onNewTransformNodeAddedObservable.notifyObservers(t));
  }, e.prototype.removeTransformNode = function(t) {
    var r = t._indexInSceneTransformNodesArray;
    if (r !== -1) {
      if (r !== this.transformNodes.length - 1) {
        var n = this.transformNodes[this.transformNodes.length - 1];
        this.transformNodes[r] = n, n._indexInSceneTransformNodesArray = r;
      }
      t._indexInSceneTransformNodesArray = -1, this.transformNodes.pop(), t.parent || t._removeFromSceneRootNodes();
    }
    return this.onTransformNodeRemovedObservable.notifyObservers(t), r;
  }, e.prototype.removeSkeleton = function(t) {
    var r = this.skeletons.indexOf(t);
    return r !== -1 && (this.skeletons.splice(r, 1), this.onSkeletonRemovedObservable.notifyObservers(t), this._executeActiveContainerCleanup(this._activeSkeletons)), r;
  }, e.prototype.removeMorphTargetManager = function(t) {
    var r = this.morphTargetManagers.indexOf(t);
    return r !== -1 && this.morphTargetManagers.splice(r, 1), r;
  }, e.prototype.removeLight = function(t) {
    var r = this.lights.indexOf(t);
    if (r !== -1) {
      for (var n = 0, a = this.meshes; n < a.length; n++) {
        var s = a[n];
        s._removeLightSource(t, !1);
      }
      this.lights.splice(r, 1), this.sortLightsByPriority(), t.parent || t._removeFromSceneRootNodes();
    }
    return this.onLightRemovedObservable.notifyObservers(t), r;
  }, e.prototype.removeCamera = function(t) {
    var r = this.cameras.indexOf(t);
    if (r !== -1 && (this.cameras.splice(r, 1), t.parent || t._removeFromSceneRootNodes()), this.activeCameras) {
      var n = this.activeCameras.indexOf(t);
      n !== -1 && this.activeCameras.splice(n, 1);
    }
    return this.activeCamera === t && (this.cameras.length > 0 ? this.activeCamera = this.cameras[0] : this.activeCamera = null), this.onCameraRemovedObservable.notifyObservers(t), r;
  }, e.prototype.removeParticleSystem = function(t) {
    var r = this.particleSystems.indexOf(t);
    return r !== -1 && (this.particleSystems.splice(r, 1), this._executeActiveContainerCleanup(this._activeParticleSystems)), r;
  }, e.prototype.removeAnimation = function(t) {
    var r = this.animations.indexOf(t);
    return r !== -1 && this.animations.splice(r, 1), r;
  }, e.prototype.stopAnimation = function(t, r, n) {
  }, e.prototype.removeAnimationGroup = function(t) {
    var r = this.animationGroups.indexOf(t);
    return r !== -1 && this.animationGroups.splice(r, 1), r;
  }, e.prototype.removeMultiMaterial = function(t) {
    var r = this.multiMaterials.indexOf(t);
    return r !== -1 && this.multiMaterials.splice(r, 1), this.onMultiMaterialRemovedObservable.notifyObservers(t), r;
  }, e.prototype.removeMaterial = function(t) {
    var r = t._indexInSceneMaterialArray;
    if (r !== -1 && r < this.materials.length) {
      if (r !== this.materials.length - 1) {
        var n = this.materials[this.materials.length - 1];
        this.materials[r] = n, n._indexInSceneMaterialArray = r;
      }
      t._indexInSceneMaterialArray = -1, this.materials.pop();
    }
    return this.onMaterialRemovedObservable.notifyObservers(t), r;
  }, e.prototype.removeActionManager = function(t) {
    var r = this.actionManagers.indexOf(t);
    return r !== -1 && this.actionManagers.splice(r, 1), r;
  }, e.prototype.removeTexture = function(t) {
    var r = this.textures.indexOf(t);
    return r !== -1 && this.textures.splice(r, 1), this.onTextureRemovedObservable.notifyObservers(t), r;
  }, e.prototype.addLight = function(t) {
    if (!this._blockEntityCollection) {
      this.lights.push(t), this.sortLightsByPriority(), t.parent || t._addToSceneRootNodes();
      for (var r = 0, n = this.meshes; r < n.length; r++) {
        var a = n[r];
        a.lightSources.indexOf(t) === -1 && (a.lightSources.push(t), a._resyncLightSources());
      }
      this.onNewLightAddedObservable.notifyObservers(t);
    }
  }, e.prototype.sortLightsByPriority = function() {
    this.requireLightSorting && this.lights.sort(Re.CompareLightsPriority);
  }, e.prototype.addCamera = function(t) {
    this._blockEntityCollection || (this.cameras.push(t), this.onNewCameraAddedObservable.notifyObservers(t), t.parent || t._addToSceneRootNodes());
  }, e.prototype.addSkeleton = function(t) {
    this._blockEntityCollection || (this.skeletons.push(t), this.onNewSkeletonAddedObservable.notifyObservers(t));
  }, e.prototype.addParticleSystem = function(t) {
    this._blockEntityCollection || this.particleSystems.push(t);
  }, e.prototype.addAnimation = function(t) {
    this._blockEntityCollection || this.animations.push(t);
  }, e.prototype.addAnimationGroup = function(t) {
    this._blockEntityCollection || this.animationGroups.push(t);
  }, e.prototype.addMultiMaterial = function(t) {
    this._blockEntityCollection || (this.multiMaterials.push(t), this.onNewMultiMaterialAddedObservable.notifyObservers(t));
  }, e.prototype.addMaterial = function(t) {
    this._blockEntityCollection || t.getScene() === this && t._indexInSceneMaterialArray !== -1 || (t._indexInSceneMaterialArray = this.materials.length, this.materials.push(t), this.onNewMaterialAddedObservable.notifyObservers(t));
  }, e.prototype.addMorphTargetManager = function(t) {
    this._blockEntityCollection || this.morphTargetManagers.push(t);
  }, e.prototype.addGeometry = function(t) {
    this._blockEntityCollection || (this._geometriesByUniqueId && (this._geometriesByUniqueId[t.uniqueId] = this.geometries.length), this.geometries.push(t));
  }, e.prototype.addActionManager = function(t) {
    this.actionManagers.push(t);
  }, e.prototype.addTexture = function(t) {
    this._blockEntityCollection || (this.textures.push(t), this.onNewTextureAddedObservable.notifyObservers(t));
  }, e.prototype.switchActiveCamera = function(t, r) {
    r === void 0 && (r = !0);
    var n = this._engine.getInputElement();
    !n || (this.activeCamera && this.activeCamera.detachControl(), this.activeCamera = t, r && t.attachControl());
  }, e.prototype.setActiveCameraById = function(t) {
    var r = this.getCameraById(t);
    return r ? (this.activeCamera = r, r) : null;
  }, e.prototype.setActiveCameraByName = function(t) {
    var r = this.getCameraByName(t);
    return r ? (this.activeCamera = r, r) : null;
  }, e.prototype.getAnimationGroupByName = function(t) {
    for (var r = 0; r < this.animationGroups.length; r++)
      if (this.animationGroups[r].name === t)
        return this.animationGroups[r];
    return null;
  }, e.prototype.getMaterialByUniqueID = function(t) {
    for (var r = 0; r < this.materials.length; r++)
      if (this.materials[r].uniqueId === t)
        return this.materials[r];
    return null;
  }, e.prototype.getMaterialById = function(t) {
    for (var r = 0; r < this.materials.length; r++)
      if (this.materials[r].id === t)
        return this.materials[r];
    return null;
  }, e.prototype.getLastMaterialById = function(t, r) {
    r === void 0 && (r = !1);
    for (var n = this.materials.length - 1; n >= 0; n--)
      if (this.materials[n].id === t)
        return this.materials[n];
    if (r) {
      for (var n = this.multiMaterials.length - 1; n >= 0; n--)
        if (this.multiMaterials[n].id === t)
          return this.multiMaterials[n];
    }
    return null;
  }, e.prototype.getMaterialByName = function(t) {
    for (var r = 0; r < this.materials.length; r++)
      if (this.materials[r].name === t)
        return this.materials[r];
    return null;
  }, e.prototype.getTextureByUniqueId = function(t) {
    for (var r = 0; r < this.textures.length; r++)
      if (this.textures[r].uniqueId === t)
        return this.textures[r];
    return null;
  }, e.prototype.getTextureByName = function(t) {
    for (var r = 0; r < this.textures.length; r++)
      if (this.textures[r].name === t)
        return this.textures[r];
    return null;
  }, e.prototype.getCameraById = function(t) {
    for (var r = 0; r < this.cameras.length; r++)
      if (this.cameras[r].id === t)
        return this.cameras[r];
    return null;
  }, e.prototype.getCameraByUniqueId = function(t) {
    for (var r = 0; r < this.cameras.length; r++)
      if (this.cameras[r].uniqueId === t)
        return this.cameras[r];
    return null;
  }, e.prototype.getCameraByName = function(t) {
    for (var r = 0; r < this.cameras.length; r++)
      if (this.cameras[r].name === t)
        return this.cameras[r];
    return null;
  }, e.prototype.getBoneById = function(t) {
    for (var r = 0; r < this.skeletons.length; r++)
      for (var n = this.skeletons[r], a = 0; a < n.bones.length; a++)
        if (n.bones[a].id === t)
          return n.bones[a];
    return null;
  }, e.prototype.getBoneByName = function(t) {
    for (var r = 0; r < this.skeletons.length; r++)
      for (var n = this.skeletons[r], a = 0; a < n.bones.length; a++)
        if (n.bones[a].name === t)
          return n.bones[a];
    return null;
  }, e.prototype.getLightByName = function(t) {
    for (var r = 0; r < this.lights.length; r++)
      if (this.lights[r].name === t)
        return this.lights[r];
    return null;
  }, e.prototype.getLightById = function(t) {
    for (var r = 0; r < this.lights.length; r++)
      if (this.lights[r].id === t)
        return this.lights[r];
    return null;
  }, e.prototype.getLightByUniqueId = function(t) {
    for (var r = 0; r < this.lights.length; r++)
      if (this.lights[r].uniqueId === t)
        return this.lights[r];
    return null;
  }, e.prototype.getParticleSystemById = function(t) {
    for (var r = 0; r < this.particleSystems.length; r++)
      if (this.particleSystems[r].id === t)
        return this.particleSystems[r];
    return null;
  }, e.prototype.getGeometryById = function(t) {
    for (var r = 0; r < this.geometries.length; r++)
      if (this.geometries[r].id === t)
        return this.geometries[r];
    return null;
  }, e.prototype._getGeometryByUniqueId = function(t) {
    if (this._geometriesByUniqueId) {
      var r = this._geometriesByUniqueId[t];
      if (r !== void 0)
        return this.geometries[r];
    } else
      for (var r = 0; r < this.geometries.length; r++)
        if (this.geometries[r].uniqueId === t)
          return this.geometries[r];
    return null;
  }, e.prototype.pushGeometry = function(t, r) {
    return !r && this._getGeometryByUniqueId(t.uniqueId) ? !1 : (this.addGeometry(t), this.onNewGeometryAddedObservable.notifyObservers(t), !0);
  }, e.prototype.removeGeometry = function(t) {
    var r;
    if (this._geometriesByUniqueId) {
      if (r = this._geometriesByUniqueId[t.uniqueId], r === void 0)
        return !1;
    } else if (r = this.geometries.indexOf(t), r < 0)
      return !1;
    if (r !== this.geometries.length - 1) {
      var n = this.geometries[this.geometries.length - 1];
      n && (this.geometries[r] = n, this._geometriesByUniqueId && (this._geometriesByUniqueId[n.uniqueId] = r, this._geometriesByUniqueId[t.uniqueId] = void 0));
    }
    return this.geometries.pop(), this.onGeometryRemovedObservable.notifyObservers(t), !0;
  }, e.prototype.getGeometries = function() {
    return this.geometries;
  }, e.prototype.getMeshById = function(t) {
    for (var r = 0; r < this.meshes.length; r++)
      if (this.meshes[r].id === t)
        return this.meshes[r];
    return null;
  }, e.prototype.getMeshesById = function(t) {
    return this.meshes.filter(function(r) {
      return r.id === t;
    });
  }, e.prototype.getTransformNodeById = function(t) {
    for (var r = 0; r < this.transformNodes.length; r++)
      if (this.transformNodes[r].id === t)
        return this.transformNodes[r];
    return null;
  }, e.prototype.getTransformNodeByUniqueId = function(t) {
    for (var r = 0; r < this.transformNodes.length; r++)
      if (this.transformNodes[r].uniqueId === t)
        return this.transformNodes[r];
    return null;
  }, e.prototype.getTransformNodesById = function(t) {
    return this.transformNodes.filter(function(r) {
      return r.id === t;
    });
  }, e.prototype.getMeshByUniqueId = function(t) {
    for (var r = 0; r < this.meshes.length; r++)
      if (this.meshes[r].uniqueId === t)
        return this.meshes[r];
    return null;
  }, e.prototype.getLastMeshById = function(t) {
    for (var r = this.meshes.length - 1; r >= 0; r--)
      if (this.meshes[r].id === t)
        return this.meshes[r];
    return null;
  }, e.prototype.getLastEntryById = function(t) {
    var r;
    for (r = this.meshes.length - 1; r >= 0; r--)
      if (this.meshes[r].id === t)
        return this.meshes[r];
    for (r = this.transformNodes.length - 1; r >= 0; r--)
      if (this.transformNodes[r].id === t)
        return this.transformNodes[r];
    for (r = this.cameras.length - 1; r >= 0; r--)
      if (this.cameras[r].id === t)
        return this.cameras[r];
    for (r = this.lights.length - 1; r >= 0; r--)
      if (this.lights[r].id === t)
        return this.lights[r];
    return null;
  }, e.prototype.getNodeById = function(t) {
    var r = this.getMeshById(t);
    if (r)
      return r;
    var n = this.getTransformNodeById(t);
    if (n)
      return n;
    var a = this.getLightById(t);
    if (a)
      return a;
    var s = this.getCameraById(t);
    if (s)
      return s;
    var o = this.getBoneById(t);
    return o || null;
  }, e.prototype.getNodeByName = function(t) {
    var r = this.getMeshByName(t);
    if (r)
      return r;
    var n = this.getTransformNodeByName(t);
    if (n)
      return n;
    var a = this.getLightByName(t);
    if (a)
      return a;
    var s = this.getCameraByName(t);
    if (s)
      return s;
    var o = this.getBoneByName(t);
    return o || null;
  }, e.prototype.getMeshByName = function(t) {
    for (var r = 0; r < this.meshes.length; r++)
      if (this.meshes[r].name === t)
        return this.meshes[r];
    return null;
  }, e.prototype.getTransformNodeByName = function(t) {
    for (var r = 0; r < this.transformNodes.length; r++)
      if (this.transformNodes[r].name === t)
        return this.transformNodes[r];
    return null;
  }, e.prototype.getLastSkeletonById = function(t) {
    for (var r = this.skeletons.length - 1; r >= 0; r--)
      if (this.skeletons[r].id === t)
        return this.skeletons[r];
    return null;
  }, e.prototype.getSkeletonByUniqueId = function(t) {
    for (var r = 0; r < this.skeletons.length; r++)
      if (this.skeletons[r].uniqueId === t)
        return this.skeletons[r];
    return null;
  }, e.prototype.getSkeletonById = function(t) {
    for (var r = 0; r < this.skeletons.length; r++)
      if (this.skeletons[r].id === t)
        return this.skeletons[r];
    return null;
  }, e.prototype.getSkeletonByName = function(t) {
    for (var r = 0; r < this.skeletons.length; r++)
      if (this.skeletons[r].name === t)
        return this.skeletons[r];
    return null;
  }, e.prototype.getMorphTargetManagerById = function(t) {
    for (var r = 0; r < this.morphTargetManagers.length; r++)
      if (this.morphTargetManagers[r].uniqueId === t)
        return this.morphTargetManagers[r];
    return null;
  }, e.prototype.getMorphTargetById = function(t) {
    for (var r = 0; r < this.morphTargetManagers.length; ++r)
      for (var n = this.morphTargetManagers[r], a = 0; a < n.numTargets; ++a) {
        var s = n.getTarget(a);
        if (s.id === t)
          return s;
      }
    return null;
  }, e.prototype.getMorphTargetByName = function(t) {
    for (var r = 0; r < this.morphTargetManagers.length; ++r)
      for (var n = this.morphTargetManagers[r], a = 0; a < n.numTargets; ++a) {
        var s = n.getTarget(a);
        if (s.name === t)
          return s;
      }
    return null;
  }, e.prototype.getPostProcessByName = function(t) {
    for (var r = 0; r < this.postProcesses.length; ++r) {
      var n = this.postProcesses[r];
      if (n.name === t)
        return n;
    }
    return null;
  }, e.prototype.isActiveMesh = function(t) {
    return this._activeMeshes.indexOf(t) !== -1;
  }, Object.defineProperty(e.prototype, "uid", {
    get: function() {
      return this._uid || (this._uid = de.RandomId()), this._uid;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.addExternalData = function(t, r) {
    return this._externalData || (this._externalData = new Ai()), this._externalData.add(t, r);
  }, e.prototype.getExternalData = function(t) {
    return this._externalData ? this._externalData.get(t) : null;
  }, e.prototype.getOrAddExternalDataWithFactory = function(t, r) {
    return this._externalData || (this._externalData = new Ai()), this._externalData.getOrAddWithFactory(t, r);
  }, e.prototype.removeExternalData = function(t) {
    return this._externalData.remove(t);
  }, e.prototype._evaluateSubMesh = function(t, r, n) {
    if (n.hasInstances || n.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || r.alwaysSelectAsActiveMesh || r.subMeshes.length === 1 || t.isInFrustum(this._frustumPlanes)) {
      for (var a = 0, s = this._evaluateSubMeshStage; a < s.length; a++) {
        var o = s[a];
        o.action(r, t);
      }
      var u = t.getMaterial();
      u != null && (u.hasRenderTargetTextures && u.getRenderTargetTextures != null && this._processedMaterials.indexOf(u) === -1 && (this._processedMaterials.push(u), this._materialsRenderTargets.concatWithNoDuplicate(u.getRenderTargetTextures())), this._renderingManager.dispatch(t, r, u));
    }
  }, e.prototype.freeProcessedMaterials = function() {
    this._processedMaterials.dispose();
  }, Object.defineProperty(e.prototype, "blockfreeActiveMeshesAndRenderingGroups", {
    get: function() {
      return this._preventFreeActiveMeshesAndRenderingGroups;
    },
    set: function(t) {
      this._preventFreeActiveMeshesAndRenderingGroups !== t && (t && (this.freeActiveMeshes(), this.freeRenderingGroups()), this._preventFreeActiveMeshesAndRenderingGroups = t);
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.freeActiveMeshes = function() {
    if (!this.blockfreeActiveMeshesAndRenderingGroups && (this._activeMeshes.dispose(), this.activeCamera && this.activeCamera._activeMeshes && this.activeCamera._activeMeshes.dispose(), this.activeCameras))
      for (var t = 0; t < this.activeCameras.length; t++) {
        var r = this.activeCameras[t];
        r && r._activeMeshes && r._activeMeshes.dispose();
      }
  }, e.prototype.freeRenderingGroups = function() {
    if (!this.blockfreeActiveMeshesAndRenderingGroups && (this._renderingManager && this._renderingManager.freeRenderingGroups(), this.textures))
      for (var t = 0; t < this.textures.length; t++) {
        var r = this.textures[t];
        r && r.renderList && r.freeRenderingGroups();
      }
  }, e.prototype._isInIntermediateRendering = function() {
    return this._intermediateRendering;
  }, e.prototype.freezeActiveMeshes = function(t, r, n, a, s) {
    var o = this;
    return t === void 0 && (t = !1), a === void 0 && (a = !0), s === void 0 && (s = !1), this.executeWhenReady(function() {
      if (!o.activeCamera) {
        n && n("No active camera found");
        return;
      }
      if (o._frustumPlanes || o.updateTransformMatrix(), o._evaluateActiveMeshes(), o._activeMeshesFrozen = !0, o._activeMeshesFrozenButKeepClipping = s, o._skipEvaluateActiveMeshesCompletely = t, a)
        for (var u = 0; u < o._activeMeshes.length; u++)
          o._activeMeshes.data[u]._freeze();
      r && r();
    }), this;
  }, e.prototype.unfreezeActiveMeshes = function() {
    for (var t = 0; t < this.meshes.length; t++) {
      var r = this.meshes[t];
      r._internalAbstractMeshDataInfo && (r._internalAbstractMeshDataInfo._isActive = !1);
    }
    for (var t = 0; t < this._activeMeshes.length; t++)
      this._activeMeshes.data[t]._unFreeze();
    return this._activeMeshesFrozen = !1, this;
  }, e.prototype._executeActiveContainerCleanup = function(t) {
    var r = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;
    !r && this._activeMeshesFrozen && this._activeMeshes.length || this.onBeforeRenderObservable.addOnce(function() {
      return t.dispose();
    });
  }, e.prototype._evaluateActiveMeshes = function() {
    var t;
    if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {
      this._activeMeshes.length > 0 && ((t = this.activeCamera) === null || t === void 0 || t._activeMeshes.reset(), this._activeMeshes.reset(), this._renderingManager.reset(), this._processedMaterials.reset(), this._activeParticleSystems.reset(), this._activeSkeletons.reset(), this._softwareSkinnedMeshes.reset());
      return;
    }
    if (this._activeMeshesFrozen && this._activeMeshes.length) {
      if (!this._skipEvaluateActiveMeshesCompletely)
        for (var r = this._activeMeshes.length, n = 0; n < r; n++) {
          var a = this._activeMeshes.data[n];
          a.computeWorldMatrix();
        }
      if (this._activeParticleSystems)
        for (var s = this._activeParticleSystems.length, n = 0; n < s; n++)
          this._activeParticleSystems.data[n].animate();
      return;
    }
    if (!!this.activeCamera) {
      this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this), this.activeCamera._activeMeshes.reset(), this._activeMeshes.reset(), this._renderingManager.reset(), this._processedMaterials.reset(), this._activeParticleSystems.reset(), this._activeSkeletons.reset(), this._softwareSkinnedMeshes.reset(), this._materialsRenderTargets.reset();
      for (var o = 0, u = this._beforeEvaluateActiveMeshStage; o < u.length; o++) {
        var f = u[o];
        f.action();
      }
      for (var l = this.getActiveMeshCandidates(), h = l.length, n = 0; n < h; n++) {
        var a = l.data[n];
        if (a._internalAbstractMeshDataInfo._currentLODIsUpToDate = !1, !a.isBlocked && (this._totalVertices.addCount(a.getTotalVertices(), !1), !(!a.isReady() || !a.isEnabled() || a.scaling.hasAZeroComponent))) {
          a.computeWorldMatrix(), a.actionManager && a.actionManager.hasSpecificTriggers2(12, 13) && this._meshesForIntersections.pushNoDuplicate(a);
          var c = this.customLODSelector ? this.customLODSelector(a, this.activeCamera) : a.getLOD(this.activeCamera);
          if (a._internalAbstractMeshDataInfo._currentLOD = c, a._internalAbstractMeshDataInfo._currentLODIsUpToDate = !0, c != null && (c !== a && c.billboardMode !== 0 && c.computeWorldMatrix(), a._preActivate(), a.isVisible && a.visibility > 0 && (a.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || a.alwaysSelectAsActiveMesh || a.isInFrustum(this._frustumPlanes)))) {
            this._activeMeshes.push(a), this.activeCamera._activeMeshes.push(a), c !== a && c._activate(this._renderId, !1);
            for (var d = 0, p = this._preActiveMeshStage; d < p.length; d++) {
              var f = p[d];
              f.action(a);
            }
            a._activate(this._renderId, !1) && (a.isAnInstance ? a._internalAbstractMeshDataInfo._actAsRegularMesh && (c = a) : c._internalAbstractMeshDataInfo._onlyForInstances = !1, c._internalAbstractMeshDataInfo._isActive = !0, this._activeMesh(a, c)), a._postActivate();
          }
        }
      }
      if (this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this), this.particlesEnabled) {
        this.onBeforeParticlesRenderingObservable.notifyObservers(this);
        for (var g = 0; g < this.particleSystems.length; g++) {
          var _ = this.particleSystems[g];
          if (!(!_.isStarted() || !_.emitter)) {
            var v = _.emitter;
            (!v.position || v.isEnabled()) && (this._activeParticleSystems.push(_), _.animate(), this._renderingManager.dispatchParticles(_));
          }
        }
        this.onAfterParticlesRenderingObservable.notifyObservers(this);
      }
    }
  }, e.prototype._activeMesh = function(t, r) {
    if (this._skeletonsEnabled && r.skeleton !== null && r.skeleton !== void 0 && (this._activeSkeletons.pushNoDuplicate(r.skeleton) && (r.skeleton.prepare(), this._activeBones.addCount(r.skeleton.bones.length, !1)), r.computeBonesUsingShaders || this._softwareSkinnedMeshes.pushNoDuplicate(r)), r && r.subMeshes && r.subMeshes.length > 0)
      for (var n = this.getActiveSubMeshCandidates(r), a = n.length, s = 0; s < a; s++) {
        var o = n.data[s];
        this._evaluateSubMesh(o, r, t);
      }
  }, e.prototype.updateTransformMatrix = function(t) {
    if (!!this.activeCamera)
      if (this.activeCamera._renderingMultiview) {
        var r = this.activeCamera._rigCameras[0], n = this.activeCamera._rigCameras[1];
        this.setTransformMatrix(r.getViewMatrix(), r.getProjectionMatrix(t), n.getViewMatrix(), n.getProjectionMatrix(t));
      } else
        this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(t));
  }, e.prototype._bindFrameBuffer = function(t, r) {
    r === void 0 && (r = !0), t && t._multiviewTexture ? t._multiviewTexture._bindFrameBuffer() : t && t.outputRenderTarget ? t.outputRenderTarget._bindFrameBuffer() : this._engine._currentFrameBufferIsDefaultFrameBuffer() || this._engine.restoreDefaultFramebuffer(), r && this._clearFrameBuffer(t);
  }, e.prototype._clearFrameBuffer = function(t) {
    if (!(t && t._multiviewTexture))
      if (t && t.outputRenderTarget) {
        var r = t.outputRenderTarget;
        r.onClearObservable.hasObservers() ? r.onClearObservable.notifyObservers(this._engine) : r.skipInitialClear || (this._engine.clear(r.clearColor || this.clearColor, !r._cleared, !0, !0), r._cleared = !0);
      } else
        this._defaultFrameBufferCleared ? this._engine.clear(null, !1, !0, !0) : (this._defaultFrameBufferCleared = !0, this._clear());
  }, e.prototype._renderForCamera = function(t, r, n) {
    var a, s, o;
    if (n === void 0 && (n = !0), !(t && t._skipRendering)) {
      var u = this._engine;
      if (this._activeCamera = t, !this.activeCamera)
        throw new Error("Active camera not set");
      if (u.setViewport(this.activeCamera.viewport), this.resetCachedMaterial(), this._renderId++, !this.prePass && n) {
        var f = !0;
        t._renderingMultiview && t.outputRenderTarget && (f = t.outputRenderTarget.skipInitialClear, this.autoClear && (t.outputRenderTarget.skipInitialClear = !1)), this._bindFrameBuffer(this._activeCamera), t._renderingMultiview && t.outputRenderTarget && (t.outputRenderTarget.skipInitialClear = f);
      }
      this.updateTransformMatrix(), this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera), this._evaluateActiveMeshes();
      for (var l = 0; l < this._softwareSkinnedMeshes.length; l++) {
        var h = this._softwareSkinnedMeshes.data[l];
        h.applySkeleton(h.skeleton);
      }
      this.onBeforeRenderTargetsRenderObservable.notifyObservers(this), this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets), t.customRenderTargets && t.customRenderTargets.length > 0 && this._renderTargets.concatWithNoDuplicate(t.customRenderTargets), r && r.customRenderTargets && r.customRenderTargets.length > 0 && this._renderTargets.concatWithNoDuplicate(r.customRenderTargets), this.environmentTexture && this.environmentTexture.isRenderTarget && this._renderTargets.pushNoDuplicate(this.environmentTexture);
      for (var c = 0, d = this._gatherActiveCameraRenderTargetsStage; c < d.length; c++) {
        var p = d[c];
        p.action(this._renderTargets);
      }
      var g = !1;
      if (this.renderTargetsEnabled) {
        if (this._intermediateRendering = !0, this._renderTargets.length > 0) {
          de.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
          for (var _ = 0; _ < this._renderTargets.length; _++) {
            var v = this._renderTargets.data[_];
            if (v._shouldRender()) {
              this._renderId++;
              var y = v.activeCamera && v.activeCamera !== this.activeCamera;
              v.render(y, this.dumpNextRenderTargets), g = !0;
            }
          }
          de.EndPerformanceCounter("Render targets", this._renderTargets.length > 0), this._renderId++;
        }
        for (var E = 0, R = this._cameraDrawRenderTargetStage; E < R.length; E++) {
          var p = R[E];
          g = p.action(this.activeCamera) || g;
        }
        this._intermediateRendering = !1;
      }
      this._engine.currentRenderPassId = (o = (s = (a = t.outputRenderTarget) === null || a === void 0 ? void 0 : a.renderPassId) !== null && s !== void 0 ? s : t.renderPassId) !== null && o !== void 0 ? o : 0, g && !this.prePass && this._bindFrameBuffer(this._activeCamera, !1), this.onAfterRenderTargetsRenderObservable.notifyObservers(this), this.postProcessManager && !t._multiviewTexture && !this.prePass && this.postProcessManager._prepareFrame();
      for (var M = 0, C = this._beforeCameraDrawStage; M < C.length; M++) {
        var p = C[M];
        p.action(this.activeCamera);
      }
      this.onBeforeDrawPhaseObservable.notifyObservers(this), u.snapshotRendering && u.snapshotRenderingMode === 1 && this.finalizeSceneUbo(), this._renderingManager.render(null, null, !0, !0), this.onAfterDrawPhaseObservable.notifyObservers(this);
      for (var A = 0, S = this._afterCameraDrawStage; A < S.length; A++) {
        var p = S[A];
        p.action(this.activeCamera);
      }
      if (this.postProcessManager && !t._multiviewTexture) {
        var w = t.outputRenderTarget ? t.outputRenderTarget.renderTarget : void 0;
        this.postProcessManager._finalizeFrame(t.isIntermediate, w);
      }
      this._renderTargets.reset(), this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);
    }
  }, e.prototype._processSubCameras = function(t, r) {
    if (r === void 0 && (r = !0), t.cameraRigMode === 0 || t._renderingMultiview) {
      t._renderingMultiview && !this._multiviewSceneUbo && this._createMultiviewUbo(), this._renderForCamera(t, void 0, r), this.onAfterRenderCameraObservable.notifyObservers(t);
      return;
    }
    if (t._useMultiviewToSingleView)
      this._renderMultiviewToSingleView(t);
    else {
      this.onBeforeCameraRenderObservable.notifyObservers(t);
      for (var n = 0; n < t._rigCameras.length; n++)
        this._renderForCamera(t._rigCameras[n], t);
    }
    this._activeCamera = t, this.updateTransformMatrix(), this.onAfterRenderCameraObservable.notifyObservers(t);
  }, e.prototype._checkIntersections = function() {
    for (var t = 0; t < this._meshesForIntersections.length; t++) {
      var r = this._meshesForIntersections.data[t];
      if (!!r.actionManager)
        for (var n = function(s) {
          var o = r.actionManager.actions[s];
          if (o.trigger === 12 || o.trigger === 13) {
            var u = o.getTriggerParameter(), f = u.mesh ? u.mesh : u, l = f.intersectsMesh(r, u.usePreciseIntersection), h = r._intersectionsInProgress.indexOf(f);
            l && h === -1 ? o.trigger === 12 ? (o._executeCurrent(we.CreateNew(r, void 0, f)), r._intersectionsInProgress.push(f)) : o.trigger === 13 && r._intersectionsInProgress.push(f) : !l && h > -1 && (o.trigger === 13 && o._executeCurrent(we.CreateNew(r, void 0, f)), (!r.actionManager.hasSpecificTrigger(13, function(c) {
              var d = c.mesh ? c.mesh : c;
              return f === d;
            }) || o.trigger === 13) && r._intersectionsInProgress.splice(h, 1));
          }
        }, a = 0; r.actionManager && a < r.actionManager.actions.length; a++)
          n(a);
    }
  }, e.prototype._advancePhysicsEngineStep = function(t) {
  }, e.prototype._animate = function() {
  }, e.prototype.animate = function() {
    if (this._engine.isDeterministicLockStep()) {
      var t = Math.max(e.MinDeltaTime, Math.min(this._engine.getDeltaTime(), e.MaxDeltaTime)) + this._timeAccumulator, r = this._engine.getTimeStep(), n = 1e3 / r / 1e3, a = 0, s = this._engine.getLockstepMaxSteps(), o = Math.floor(t / r);
      for (o = Math.min(o, s); t > 0 && a < o; )
        this.onBeforeStepObservable.notifyObservers(this), this._animationRatio = r * n, this._animate(), this.onAfterAnimationsObservable.notifyObservers(this), this.physicsEnabled && this._advancePhysicsEngineStep(r), this.onAfterStepObservable.notifyObservers(this), this._currentStepId++, a++, t -= r;
      this._timeAccumulator = t < 0 ? 0 : t;
    } else {
      var t = this.useConstantAnimationDeltaTime ? 16 : Math.max(e.MinDeltaTime, Math.min(this._engine.getDeltaTime(), e.MaxDeltaTime));
      this._animationRatio = t * (60 / 1e3), this._animate(), this.onAfterAnimationsObservable.notifyObservers(this), this.physicsEnabled && this._advancePhysicsEngineStep(t);
    }
  }, e.prototype._clear = function() {
    (this.autoClearDepthAndStencil || this.autoClear) && this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);
  }, e.prototype._checkCameraRenderTarget = function(t) {
    var r;
    if ((t == null ? void 0 : t.outputRenderTarget) && !(t != null && t.isRigCamera) && (t.outputRenderTarget._cleared = !1), !((r = t == null ? void 0 : t.rigCameras) === null || r === void 0) && r.length)
      for (var n = 0; n < t.rigCameras.length; ++n) {
        var a = t.rigCameras[n].outputRenderTarget;
        a && (a._cleared = !1);
      }
  }, e.prototype.resetDrawCache = function(t) {
    if (!!this.meshes)
      for (var r = 0, n = this.meshes; r < n.length; r++) {
        var a = n[r];
        a.resetDrawCache(t);
      }
  }, e.prototype.render = function(t, r) {
    var n, a, s;
    if (t === void 0 && (t = !0), r === void 0 && (r = !1), !this.isDisposed) {
      this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null && this._checkIsReady(), this._frameId++, this._defaultFrameBufferCleared = !1, this._checkCameraRenderTarget(this.activeCamera), !((n = this.activeCameras) === null || n === void 0) && n.length && this.activeCameras.forEach(this._checkCameraRenderTarget), this._registerTransientComponents(), this._activeParticles.fetchNewFrame(), this._totalVertices.fetchNewFrame(), this._activeIndices.fetchNewFrame(), this._activeBones.fetchNewFrame(), this._meshesForIntersections.reset(), this.resetCachedMaterial(), this.onBeforeAnimationsObservable.notifyObservers(this), this.actionManager && this.actionManager.processTrigger(11), r || this.animate();
      for (var o = 0, u = this._beforeCameraUpdateStage; o < u.length; o++) {
        var f = u[o];
        f.action();
      }
      if (t) {
        if (this.activeCameras && this.activeCameras.length > 0)
          for (var l = 0; l < this.activeCameras.length; l++) {
            var h = this.activeCameras[l];
            if (h.update(), h.cameraRigMode !== 0)
              for (var c = 0; c < h._rigCameras.length; c++)
                h._rigCameras[c].update();
          }
        else if (this.activeCamera && (this.activeCamera.update(), this.activeCamera.cameraRigMode !== 0))
          for (var c = 0; c < this.activeCamera._rigCameras.length; c++)
            this.activeCamera._rigCameras[c].update();
      }
      this.onBeforeRenderObservable.notifyObservers(this);
      var d = this.getEngine();
      this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
      var p = !((a = this.activeCameras) === null || a === void 0) && a.length ? this.activeCameras[0] : this.activeCamera;
      if (this.renderTargetsEnabled) {
        de.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0), this._intermediateRendering = !0;
        for (var g = 0; g < this.customRenderTargets.length; g++) {
          var _ = this.customRenderTargets[g];
          if (_._shouldRender()) {
            if (this._renderId++, this.activeCamera = _.activeCamera || this.activeCamera, !this.activeCamera)
              throw new Error("Active camera not set");
            d.setViewport(this.activeCamera.viewport), this.updateTransformMatrix(), _.render(p !== this.activeCamera, this.dumpNextRenderTargets);
          }
        }
        de.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0), this._intermediateRendering = !1, this._renderId++;
      }
      this._engine.currentRenderPassId = (s = p == null ? void 0 : p.renderPassId) !== null && s !== void 0 ? s : 0, this.activeCamera = p, this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass && this._bindFrameBuffer(this._activeCamera, !1), this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
      for (var v = 0, y = this._beforeClearStage; v < y.length; v++) {
        var f = y[v];
        f.action();
      }
      this._clearFrameBuffer(this.activeCamera);
      for (var E = 0, R = this._gatherRenderTargetsStage; E < R.length; E++) {
        var f = R[E];
        f.action(this._renderTargets);
      }
      if (this.activeCameras && this.activeCameras.length > 0)
        for (var l = 0; l < this.activeCameras.length; l++)
          this._processSubCameras(this.activeCameras[l], l > 0);
      else {
        if (!this.activeCamera)
          throw new Error("No camera defined");
        this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);
      }
      this._checkIntersections();
      for (var M = 0, C = this._afterRenderStage; M < C.length; M++) {
        var f = C[M];
        f.action();
      }
      if (this.afterRender && this.afterRender(), this.onAfterRenderObservable.notifyObservers(this), this._toBeDisposed.length) {
        for (var c = 0; c < this._toBeDisposed.length; c++) {
          var A = this._toBeDisposed[c];
          A && A.dispose();
        }
        this._toBeDisposed = [];
      }
      this.dumpNextRenderTargets && (this.dumpNextRenderTargets = !1), this._activeBones.addCount(0, !0), this._activeIndices.addCount(0, !0), this._activeParticles.addCount(0, !0), this._engine.restoreDefaultFramebuffer();
    }
  }, e.prototype.freezeMaterials = function() {
    for (var t = 0; t < this.materials.length; t++)
      this.materials[t].freeze();
  }, e.prototype.unfreezeMaterials = function() {
    for (var t = 0; t < this.materials.length; t++)
      this.materials[t].unfreeze();
  }, e.prototype.dispose = function() {
    var t;
    if (!this.isDisposed) {
      this.beforeRender = null, this.afterRender = null, this.metadata = null, this.skeletons = [], this.morphTargetManagers = [], this._transientComponents = [], this._isReadyForMeshStage.clear(), this._beforeEvaluateActiveMeshStage.clear(), this._evaluateSubMeshStage.clear(), this._preActiveMeshStage.clear(), this._cameraDrawRenderTargetStage.clear(), this._beforeCameraDrawStage.clear(), this._beforeRenderTargetDrawStage.clear(), this._beforeRenderingGroupDrawStage.clear(), this._beforeRenderingMeshStage.clear(), this._afterRenderingMeshStage.clear(), this._afterRenderingGroupDrawStage.clear(), this._afterCameraDrawStage.clear(), this._afterRenderTargetDrawStage.clear(), this._afterRenderStage.clear(), this._beforeCameraUpdateStage.clear(), this._beforeClearStage.clear(), this._gatherRenderTargetsStage.clear(), this._gatherActiveCameraRenderTargetsStage.clear(), this._pointerMoveStage.clear(), this._pointerDownStage.clear(), this._pointerUpStage.clear(), this.importedMeshesFiles = new Array(), this.stopAllAnimations && this.stopAllAnimations(), this.resetCachedMaterial(), this.activeCamera && (this.activeCamera._activeMeshes.dispose(), this.activeCamera = null), this._activeMeshes.dispose(), this._renderingManager.dispose(), this._processedMaterials.dispose(), this._activeParticleSystems.dispose(), this._activeSkeletons.dispose(), this._softwareSkinnedMeshes.dispose(), this._renderTargets.dispose(), this._materialsRenderTargets.dispose(), this._registeredForLateAnimationBindings.dispose(), this._meshesForIntersections.dispose(), this._toBeDisposed = [];
      for (var r = this._activeRequests.slice(), n = 0, a = r; n < a.length; n++) {
        var s = a[n];
        s.abort();
      }
      this._activeRequests = [], this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onBeforeRenderObservable.clear(), this.onAfterRenderObservable.clear(), this.onBeforeRenderTargetsRenderObservable.clear(), this.onAfterRenderTargetsRenderObservable.clear(), this.onAfterStepObservable.clear(), this.onBeforeStepObservable.clear(), this.onBeforeActiveMeshesEvaluationObservable.clear(), this.onAfterActiveMeshesEvaluationObservable.clear(), this.onBeforeParticlesRenderingObservable.clear(), this.onAfterParticlesRenderingObservable.clear(), this.onBeforeDrawPhaseObservable.clear(), this.onAfterDrawPhaseObservable.clear(), this.onBeforeAnimationsObservable.clear(), this.onAfterAnimationsObservable.clear(), this.onDataLoadedObservable.clear(), this.onBeforeRenderingGroupObservable.clear(), this.onAfterRenderingGroupObservable.clear(), this.onMeshImportedObservable.clear(), this.onBeforeCameraRenderObservable.clear(), this.onAfterCameraRenderObservable.clear(), this.onReadyObservable.clear(), this.onNewCameraAddedObservable.clear(), this.onCameraRemovedObservable.clear(), this.onNewLightAddedObservable.clear(), this.onLightRemovedObservable.clear(), this.onNewGeometryAddedObservable.clear(), this.onGeometryRemovedObservable.clear(), this.onNewTransformNodeAddedObservable.clear(), this.onTransformNodeRemovedObservable.clear(), this.onNewMeshAddedObservable.clear(), this.onMeshRemovedObservable.clear(), this.onNewSkeletonAddedObservable.clear(), this.onSkeletonRemovedObservable.clear(), this.onNewMaterialAddedObservable.clear(), this.onNewMultiMaterialAddedObservable.clear(), this.onMaterialRemovedObservable.clear(), this.onMultiMaterialRemovedObservable.clear(), this.onNewTextureAddedObservable.clear(), this.onTextureRemovedObservable.clear(), this.onPrePointerObservable.clear(), this.onPointerObservable.clear(), this.onPreKeyboardObservable.clear(), this.onKeyboardObservable.clear(), this.onActiveCameraChanged.clear(), this.onComputePressureChanged.clear(), (t = this._computePressureObserver) === null || t === void 0 || t.unobserve(), this._computePressureObserver = void 0, this.detachControl();
      var o = this._engine.getInputElement();
      if (o)
        for (var u = 0; u < this.cameras.length; u++)
          this.cameras[u].detachControl();
      this._disposeList(this.animationGroups), this._disposeList(this.lights), this._disposeList(this.meshes, function(l) {
        return l.dispose(!0);
      }), this._disposeList(this.transformNodes, function(l) {
        return l.dispose(!0);
      }), this._disposeList(this.cameras), this._defaultMaterial && this._defaultMaterial.dispose(), this._disposeList(this.multiMaterials), this._disposeList(this.materials), this._disposeList(this.particleSystems), this._disposeList(this.postProcesses), this._disposeList(this.textures), this._disposeList(this.morphTargetManagers), this._sceneUbo.dispose(), this._multiviewSceneUbo && this._multiviewSceneUbo.dispose(), this.postProcessManager.dispose(), this._disposeList(this._components);
      var f = this._engine.scenes.indexOf(this);
      f > -1 && this._engine.scenes.splice(f, 1), re._LastCreatedScene === this && (this._engine.scenes.length > 0 ? re._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1] : re._LastCreatedScene = null), f = this._engine._virtualScenes.indexOf(this), f > -1 && this._engine._virtualScenes.splice(f, 1), this._engine.wipeCaches(!0), this._isDisposed = !0;
    }
  }, e.prototype._disposeList = function(t, r) {
    var n = t.slice(0);
    r = r != null ? r : function(u) {
      return u.dispose();
    };
    for (var a = 0, s = n; a < s.length; a++) {
      var o = s[a];
      r(o);
    }
    t.length = 0;
  }, Object.defineProperty(e.prototype, "isDisposed", {
    get: function() {
      return this._isDisposed;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.clearCachedVertexData = function() {
    for (var t = 0; t < this.meshes.length; t++) {
      var r = this.meshes[t], n = r.geometry;
      n && n.clearCachedData();
    }
  }, e.prototype.cleanCachedTextureBuffer = function() {
    for (var t = 0, r = this.textures; t < r.length; t++) {
      var n = r[t], a = n._buffer;
      a && (n._buffer = null);
    }
  }, e.prototype.getWorldExtends = function(t) {
    var r = new b(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n = new b(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    return t = t || function() {
      return !0;
    }, this.meshes.filter(t).forEach(function(a) {
      if (a.computeWorldMatrix(!0), !(!a.subMeshes || a.subMeshes.length === 0 || a.infiniteDistance)) {
        var s = a.getBoundingInfo(), o = s.boundingBox.minimumWorld, u = s.boundingBox.maximumWorld;
        b.CheckExtends(o, r, n), b.CheckExtends(u, r, n);
      }
    }), {
      min: r,
      max: n
    };
  }, e.prototype.createPickingRay = function(t, r, n, a, s) {
    throw G("Ray");
  }, e.prototype.createPickingRayToRef = function(t, r, n, a, s, o, u) {
    throw G("Ray");
  }, e.prototype.createPickingRayInCameraSpace = function(t, r, n) {
    throw G("Ray");
  }, e.prototype.createPickingRayInCameraSpaceToRef = function(t, r, n, a) {
    throw G("Ray");
  }, e.prototype.pick = function(t, r, n, a, s, o) {
    var u = new et();
    return u._pickingUnavailable = !0, u;
  }, e.prototype.pickWithBoundingInfo = function(t, r, n, a, s) {
    var o = new et();
    return o._pickingUnavailable = !0, o;
  }, e.prototype.pickWithRay = function(t, r, n, a) {
    throw G("Ray");
  }, e.prototype.multiPick = function(t, r, n, a, s) {
    throw G("Ray");
  }, e.prototype.multiPickWithRay = function(t, r, n) {
    throw G("Ray");
  }, e.prototype.setPointerOverMesh = function(t, r, n) {
    this._inputManager.setPointerOverMesh(t, r, n);
  }, e.prototype.getPointerOverMesh = function() {
    return this._inputManager.getPointerOverMesh();
  }, e.prototype._rebuildGeometries = function() {
    for (var t = 0, r = this.geometries; t < r.length; t++) {
      var n = r[t];
      n._rebuild();
    }
    for (var a = 0, s = this.meshes; a < s.length; a++) {
      var o = s[a];
      o._rebuild();
    }
    this.postProcessManager && this.postProcessManager._rebuild();
    for (var u = 0, f = this._components; u < f.length; u++) {
      var l = f[u];
      l.rebuild();
    }
    for (var h = 0, c = this.particleSystems; h < c.length; h++) {
      var d = c[h];
      d.rebuild();
    }
    if (this.spriteManagers)
      for (var p = 0, g = this.spriteManagers; p < g.length; p++) {
        var _ = g[p];
        _.rebuild();
      }
  }, e.prototype._rebuildTextures = function() {
    for (var t = 0, r = this.textures; t < r.length; t++) {
      var n = r[t];
      n._rebuild();
    }
    this.markAllMaterialsAsDirty(1);
  }, e.prototype._getByTags = function(t, r, n) {
    if (r === void 0)
      return t;
    var a = [];
    n = n || function(u) {
    };
    for (var s in t) {
      var o = t[s];
      le && le.MatchesQuery(o, r) && (a.push(o), n(o));
    }
    return a;
  }, e.prototype.getMeshesByTags = function(t, r) {
    return this._getByTags(this.meshes, t, r);
  }, e.prototype.getCamerasByTags = function(t, r) {
    return this._getByTags(this.cameras, t, r);
  }, e.prototype.getLightsByTags = function(t, r) {
    return this._getByTags(this.lights, t, r);
  }, e.prototype.getMaterialByTags = function(t, r) {
    return this._getByTags(this.materials, t, r).concat(this._getByTags(this.multiMaterials, t, r));
  }, e.prototype.getTransformNodesByTags = function(t, r) {
    return this._getByTags(this.transformNodes, t, r);
  }, e.prototype.setRenderingOrder = function(t, r, n, a) {
    r === void 0 && (r = null), n === void 0 && (n = null), a === void 0 && (a = null), this._renderingManager.setRenderingOrder(t, r, n, a);
  }, e.prototype.setRenderingAutoClearDepthStencil = function(t, r, n, a) {
    n === void 0 && (n = !0), a === void 0 && (a = !0), this._renderingManager.setRenderingAutoClearDepthStencil(t, r, n, a);
  }, e.prototype.getAutoClearDepthStencilSetup = function(t) {
    return this._renderingManager.getAutoClearDepthStencilSetup(t);
  }, Object.defineProperty(e.prototype, "blockMaterialDirtyMechanism", {
    get: function() {
      return this._blockMaterialDirtyMechanism;
    },
    set: function(t) {
      this._blockMaterialDirtyMechanism !== t && (this._blockMaterialDirtyMechanism = t, t || this.markAllMaterialsAsDirty(63));
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.markAllMaterialsAsDirty = function(t, r) {
    if (!this._blockMaterialDirtyMechanism)
      for (var n = 0, a = this.materials; n < a.length; n++) {
        var s = a[n];
        r && !r(s) || s.markAsDirty(t);
      }
  }, e.prototype._loadFile = function(t, r, n, a, s, o, u) {
    var f = this, l = xt(t, r, n, a ? this.offlineProvider : void 0, s, o, u);
    return this._activeRequests.push(l), l.onCompleteObservable.add(function(h) {
      f._activeRequests.splice(f._activeRequests.indexOf(h), 1);
    }), l;
  }, e.prototype._loadFileAsync = function(t, r, n, a, s) {
    var o = this;
    return new Promise(function(u, f) {
      o._loadFile(t, function(l) {
        u(l);
      }, r, n, a, function(l, h) {
        f(h);
      }, s);
    });
  }, e.prototype._requestFile = function(t, r, n, a, s, o, u) {
    var f = this, l = pi(t, r, n, a ? this.offlineProvider : void 0, s, o, u);
    return this._activeRequests.push(l), l.onCompleteObservable.add(function(h) {
      f._activeRequests.splice(f._activeRequests.indexOf(h), 1);
    }), l;
  }, e.prototype._requestFileAsync = function(t, r, n, a, s) {
    var o = this;
    return new Promise(function(u, f) {
      o._requestFile(t, function(l) {
        u(l);
      }, r, n, a, function(l) {
        f(l);
      }, s);
    });
  }, e.prototype._readFile = function(t, r, n, a, s) {
    var o = this, u = er(t, r, n, a, s);
    return this._activeRequests.push(u), u.onCompleteObservable.add(function(f) {
      o._activeRequests.splice(o._activeRequests.indexOf(f), 1);
    }), u;
  }, e.prototype._readFileAsync = function(t, r, n) {
    var a = this;
    return new Promise(function(s, o) {
      a._readFile(t, function(u) {
        s(u);
      }, r, n, function(u) {
        o(u);
      });
    });
  }, e.prototype.getPerfCollector = function() {
    throw G("performanceViewerSceneExtension");
  }, e.FOGMODE_NONE = 0, e.FOGMODE_EXP = 1, e.FOGMODE_EXP2 = 2, e.FOGMODE_LINEAR = 3, e.MinDeltaTime = 1, e.MaxDeltaTime = 1e3, e;
}(un);
te.prototype.setActiveCameraByID = function(i) {
  return this.setActiveCameraById(i);
};
te.prototype.getLastMaterialByID = function(i) {
  return this.getLastMaterialById(i);
};
te.prototype.getMaterialByID = function(i) {
  return this.getMaterialById(i);
};
te.prototype.getTextureByUniqueID = function(i) {
  return this.getTextureByUniqueId(i);
};
te.prototype.getCameraByID = function(i) {
  return this.getCameraById(i);
};
te.prototype.getCameraByUniqueID = function(i) {
  return this.getCameraByUniqueId(i);
};
te.prototype.getBoneByID = function(i) {
  return this.getBoneById(i);
};
te.prototype.getLightByID = function(i) {
  return this.getLightById(i);
};
te.prototype.getLightByUniqueID = function(i) {
  return this.getLightByUniqueId(i);
};
te.prototype.getParticleSystemByID = function(i) {
  return this.getParticleSystemById(i);
};
te.prototype.getGeometryByID = function(i) {
  return this.getGeometryById(i);
};
te.prototype.getMeshByID = function(i) {
  return this.getMeshById(i);
};
te.prototype.getMeshesByID = function(i) {
  return this.getMeshesById(i);
};
te.prototype.getTransformNodeByID = function(i) {
  return this.getTransformNodeById(i);
};
te.prototype.getTransformNodeByUniqueID = function(i) {
  return this.getTransformNodeByUniqueId(i);
};
te.prototype.getTransformNodesByID = function(i) {
  return this.getTransformNodesById(i);
};
te.prototype.getMeshByUniqueID = function(i) {
  return this.getMeshByUniqueId(i);
};
te.prototype.getLastMeshByID = function(i) {
  return this.getLastMeshById(i);
};
te.prototype.getLastEntryByID = function(i) {
  return this.getLastEntryById(i);
};
te.prototype.getNodeByID = function(i) {
  return this.getNodeById(i);
};
te.prototype.getLastSkeletonByID = function(i) {
  return this.getLastSkeletonById(i);
};
function ni(i, e, t) {
  try {
    var r = i.next();
    r.done ? e(r) : r.value ? r.value.then(function() {
      r.value = void 0, e(r);
    }, t) : e(r);
  } catch (n) {
    t(n);
  }
}
function ga(i) {
  i === void 0 && (i = 25);
  var e;
  return function(t, r, n) {
    var a = performance.now();
    e === void 0 || a - e > i ? (e = a, setTimeout(function() {
      ni(t, r, n);
    }, 0)) : ni(t, r, n);
  };
}
function hn(i, e, t, r, n) {
  var a = function() {
    var s, o = function(u) {
      u.done ? t(u.value) : s === void 0 ? s = !0 : a();
    };
    do
      s = void 0, !n || !n.aborted ? e(i, o, r) : r(new Error("Aborted")), s === void 0 && (s = !1);
    while (s);
  };
  a();
}
function vi(i, e) {
  var t;
  return hn(i, ni, function(r) {
    return t = r;
  }, function(r) {
    throw r;
  }, e), t;
}
function va(i, e, t) {
  return new Promise(function(r, n) {
    hn(i, e, r, n, t);
  });
}
function ma(i, e) {
  return function() {
    for (var t = [], r = 0; r < arguments.length; r++)
      t[r] = arguments[r];
    return vi(i.apply(void 0, t), e);
  };
}
var ya = function() {
  function i() {
    this._doNotSerialize = !1, this._isDisposed = !1, this._sceneRootNodesIndex = -1, this._isEnabled = !0, this._isParentEnabled = !0, this._isReady = !0, this._onEnabledStateChangedObservable = new O(), this._onClonedObservable = new O();
  }
  return i;
}(), Je = function() {
  function i(e, t) {
    t === void 0 && (t = null), this._isDirty = !1, this._nodeDataStorage = new ya(), this.state = "", this.metadata = null, this.reservedDataStore = null, this._parentContainer = null, this.animations = new Array(), this._ranges = {}, this.onReady = null, this._currentRenderId = -1, this._parentUpdateId = -1, this._childUpdateId = -1, this._waitingParentId = null, this._cache = {}, this._parentNode = null, this._children = null, this._worldMatrix = I.Identity(), this._worldMatrixDeterminant = 0, this._worldMatrixDeterminantIsDirty = !0, this._animationPropertiesOverride = null, this._isNode = !0, this.onDisposeObservable = new O(), this._onDisposeObserver = null, this._behaviors = new Array(), this.name = e, this.id = e, this._scene = t || re.LastCreatedScene, this.uniqueId = this._scene.getUniqueId(), this._initCache();
  }
  return i.AddNodeConstructor = function(e, t) {
    this._NodeConstructors[e] = t;
  }, i.Construct = function(e, t, r, n) {
    var a = this._NodeConstructors[e];
    return a ? a(t, r, n) : null;
  }, Object.defineProperty(i.prototype, "doNotSerialize", {
    get: function() {
      return this._nodeDataStorage._doNotSerialize ? !0 : this._parentNode ? this._parentNode.doNotSerialize : !1;
    },
    set: function(e) {
      this._nodeDataStorage._doNotSerialize = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.isDisposed = function() {
    return this._nodeDataStorage._isDisposed;
  }, Object.defineProperty(i.prototype, "parent", {
    get: function() {
      return this._parentNode;
    },
    set: function(e) {
      if (this._parentNode !== e) {
        var t = this._parentNode;
        if (this._parentNode && this._parentNode._children !== void 0 && this._parentNode._children !== null) {
          var r = this._parentNode._children.indexOf(this);
          r !== -1 && this._parentNode._children.splice(r, 1), !e && !this._nodeDataStorage._isDisposed && this._addToSceneRootNodes();
        }
        this._parentNode = e, this._parentNode && ((this._parentNode._children === void 0 || this._parentNode._children === null) && (this._parentNode._children = new Array()), this._parentNode._children.push(this), t || this._removeFromSceneRootNodes()), this._syncParentEnabledState();
      }
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._addToSceneRootNodes = function() {
    this._nodeDataStorage._sceneRootNodesIndex === -1 && (this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length, this._scene.rootNodes.push(this));
  }, i.prototype._removeFromSceneRootNodes = function() {
    if (this._nodeDataStorage._sceneRootNodesIndex !== -1) {
      var e = this._scene.rootNodes, t = e.length - 1;
      e[this._nodeDataStorage._sceneRootNodesIndex] = e[t], e[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex, this._scene.rootNodes.pop(), this._nodeDataStorage._sceneRootNodesIndex = -1;
    }
  }, Object.defineProperty(i.prototype, "animationPropertiesOverride", {
    get: function() {
      return this._animationPropertiesOverride ? this._animationPropertiesOverride : this._scene.animationPropertiesOverride;
    },
    set: function(e) {
      this._animationPropertiesOverride = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getClassName = function() {
    return "Node";
  }, Object.defineProperty(i.prototype, "onDispose", {
    set: function(e) {
      this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "onEnabledStateChangedObservable", {
    get: function() {
      return this._nodeDataStorage._onEnabledStateChangedObservable;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "onClonedObservable", {
    get: function() {
      return this._nodeDataStorage._onClonedObservable;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getScene = function() {
    return this._scene;
  }, i.prototype.getEngine = function() {
    return this._scene.getEngine();
  }, i.prototype.addBehavior = function(e, t) {
    var r = this;
    t === void 0 && (t = !1);
    var n = this._behaviors.indexOf(e);
    return n !== -1 ? this : (e.init(), this._scene.isLoading && !t ? this._scene.onDataLoadedObservable.addOnce(function() {
      e.attach(r);
    }) : e.attach(this), this._behaviors.push(e), this);
  }, i.prototype.removeBehavior = function(e) {
    var t = this._behaviors.indexOf(e);
    return t === -1 ? this : (this._behaviors[t].detach(), this._behaviors.splice(t, 1), this);
  }, Object.defineProperty(i.prototype, "behaviors", {
    get: function() {
      return this._behaviors;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getBehaviorByName = function(e) {
    for (var t = 0, r = this._behaviors; t < r.length; t++) {
      var n = r[t];
      if (n.name === e)
        return n;
    }
    return null;
  }, i.prototype.getWorldMatrix = function() {
    return this._currentRenderId !== this._scene.getRenderId() && this.computeWorldMatrix(), this._worldMatrix;
  }, i.prototype._getWorldMatrixDeterminant = function() {
    return this._worldMatrixDeterminantIsDirty && (this._worldMatrixDeterminantIsDirty = !1, this._worldMatrixDeterminant = this._worldMatrix.determinant()), this._worldMatrixDeterminant;
  }, Object.defineProperty(i.prototype, "worldMatrixFromCache", {
    get: function() {
      return this._worldMatrix;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._initCache = function() {
    this._cache = {}, this._cache.parent = void 0;
  }, i.prototype.updateCache = function(e) {
    !e && this.isSynchronized() || (this._cache.parent = this.parent, this._updateCache());
  }, i.prototype._getActionManagerForTrigger = function(e, t) {
    return this.parent ? this.parent._getActionManagerForTrigger(e, !1) : null;
  }, i.prototype._updateCache = function(e) {
  }, i.prototype._isSynchronized = function() {
    return !0;
  }, i.prototype._markSyncedWithParent = function() {
    this._parentNode && (this._parentUpdateId = this._parentNode._childUpdateId);
  }, i.prototype.isSynchronizedWithParent = function() {
    return this._parentNode ? this._parentNode._isDirty || this._parentUpdateId !== this._parentNode._childUpdateId ? !1 : this._parentNode.isSynchronized() : !0;
  }, i.prototype.isSynchronized = function() {
    return this._cache.parent !== this._parentNode ? (this._cache.parent = this._parentNode, !1) : this._parentNode && !this.isSynchronizedWithParent() ? !1 : this._isSynchronized();
  }, i.prototype.isReady = function(e) {
    return this._nodeDataStorage._isReady;
  }, i.prototype.markAsDirty = function(e) {
    return this._currentRenderId = Number.MAX_VALUE, this._isDirty = !0, this;
  }, i.prototype.isEnabled = function(e) {
    return e === void 0 && (e = !0), e === !1 ? this._nodeDataStorage._isEnabled : this._nodeDataStorage._isEnabled ? this._nodeDataStorage._isParentEnabled : !1;
  }, i.prototype._syncParentEnabledState = function() {
    this._nodeDataStorage._isParentEnabled = this._parentNode ? this._parentNode.isEnabled() : !0, this._children && this._children.forEach(function(e) {
      e._syncParentEnabledState();
    });
  }, i.prototype.setEnabled = function(e) {
    this._nodeDataStorage._isEnabled !== e && (this._nodeDataStorage._isEnabled = e, this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(e), this._syncParentEnabledState());
  }, i.prototype.isDescendantOf = function(e) {
    return this.parent ? this.parent === e ? !0 : this.parent.isDescendantOf(e) : !1;
  }, i.prototype._getDescendants = function(e, t, r) {
    if (t === void 0 && (t = !1), !!this._children)
      for (var n = 0; n < this._children.length; n++) {
        var a = this._children[n];
        (!r || r(a)) && e.push(a), t || a._getDescendants(e, !1, r);
      }
  }, i.prototype.getDescendants = function(e, t) {
    var r = new Array();
    return this._getDescendants(r, e, t), r;
  }, i.prototype.getChildMeshes = function(e, t) {
    var r = [];
    return this._getDescendants(r, e, function(n) {
      return (!t || t(n)) && n.cullingStrategy !== void 0;
    }), r;
  }, i.prototype.getChildren = function(e, t) {
    return t === void 0 && (t = !0), this.getDescendants(t, e);
  }, i.prototype._setReady = function(e) {
    if (e !== this._nodeDataStorage._isReady) {
      if (!e) {
        this._nodeDataStorage._isReady = !1;
        return;
      }
      this.onReady && this.onReady(this), this._nodeDataStorage._isReady = !0;
    }
  }, i.prototype.getAnimationByName = function(e) {
    for (var t = 0; t < this.animations.length; t++) {
      var r = this.animations[t];
      if (r.name === e)
        return r;
    }
    return null;
  }, i.prototype.createAnimationRange = function(e, t, r) {
    if (!this._ranges[e]) {
      this._ranges[e] = i._AnimationRangeFactory(e, t, r);
      for (var n = 0, a = this.animations.length; n < a; n++)
        this.animations[n] && this.animations[n].createRange(e, t, r);
    }
  }, i.prototype.deleteAnimationRange = function(e, t) {
    t === void 0 && (t = !0);
    for (var r = 0, n = this.animations.length; r < n; r++)
      this.animations[r] && this.animations[r].deleteRange(e, t);
    this._ranges[e] = null;
  }, i.prototype.getAnimationRange = function(e) {
    return this._ranges[e] || null;
  }, i.prototype.getAnimationRanges = function() {
    var e = [], t;
    for (t in this._ranges)
      e.push(this._ranges[t]);
    return e;
  }, i.prototype.beginAnimation = function(e, t, r, n) {
    var a = this.getAnimationRange(e);
    return a ? this._scene.beginAnimation(this, a.from, a.to, t, r, n) : null;
  }, i.prototype.serializeAnimationRanges = function() {
    var e = [];
    for (var t in this._ranges) {
      var r = this._ranges[t];
      if (!!r) {
        var n = {};
        n.name = t, n.from = r.from, n.to = r.to, e.push(n);
      }
    }
    return e;
  }, i.prototype.computeWorldMatrix = function(e) {
    return this._worldMatrix || (this._worldMatrix = I.Identity()), this._worldMatrix;
  }, i.prototype.dispose = function(e, t) {
    if (t === void 0 && (t = !1), this._nodeDataStorage._isDisposed = !0, !e)
      for (var r = this.getDescendants(!0), n = 0, a = r; n < a.length; n++) {
        var s = a[n];
        s.dispose(e, t);
      }
    this.parent ? this.parent = null : this._removeFromSceneRootNodes(), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onEnabledStateChangedObservable.clear(), this.onClonedObservable.clear();
    for (var o = 0, u = this._behaviors; o < u.length; o++) {
      var f = u[o];
      f.detach();
    }
    this._behaviors = [], this.metadata = null;
  }, i.ParseAnimationRanges = function(e, t, r) {
    if (t.ranges)
      for (var n = 0; n < t.ranges.length; n++) {
        var a = t.ranges[n];
        e.createAnimationRange(a.name, a.from, a.to);
      }
  }, i.prototype.getHierarchyBoundingVectors = function(e, t) {
    e === void 0 && (e = !0), t === void 0 && (t = null), this.getScene().incrementRenderId(), this.computeWorldMatrix(!0);
    var r, n, a = this;
    if (a.getBoundingInfo && a.subMeshes) {
      var s = a.getBoundingInfo();
      r = s.boundingBox.minimumWorld.clone(), n = s.boundingBox.maximumWorld.clone();
    } else
      r = new b(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n = new b(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    if (e)
      for (var o = this.getDescendants(!1), u = 0, f = o; u < f.length; u++) {
        var l = f[u], h = l;
        if (h.computeWorldMatrix(!0), !(t && !t(h)) && !(!h.getBoundingInfo || h.getTotalVertices() === 0)) {
          var c = h.getBoundingInfo(), d = c.boundingBox, p = d.minimumWorld, g = d.maximumWorld;
          b.CheckExtends(p, r, n), b.CheckExtends(g, r, n);
        }
      }
    return {
      min: r,
      max: n
    };
  }, i._AnimationRangeFactory = function(e, t, r) {
    throw G("AnimationRange");
  }, i._NodeConstructors = {}, T([
    P()
  ], i.prototype, "name", void 0), T([
    P()
  ], i.prototype, "id", void 0), T([
    P()
  ], i.prototype, "uniqueId", void 0), T([
    P()
  ], i.prototype, "state", void 0), T([
    P()
  ], i.prototype, "metadata", void 0), i;
}(), _e = function() {
  function i() {
    this._applyTo = ma(this._applyToCoroutine.bind(this));
  }
  return i.prototype.set = function(e, t) {
    switch (e.length || k.Warn("Setting vertex data kind '".concat(t, "' with an empty array")), t) {
      case m.PositionKind:
        this.positions = e;
        break;
      case m.NormalKind:
        this.normals = e;
        break;
      case m.TangentKind:
        this.tangents = e;
        break;
      case m.UVKind:
        this.uvs = e;
        break;
      case m.UV2Kind:
        this.uvs2 = e;
        break;
      case m.UV3Kind:
        this.uvs3 = e;
        break;
      case m.UV4Kind:
        this.uvs4 = e;
        break;
      case m.UV5Kind:
        this.uvs5 = e;
        break;
      case m.UV6Kind:
        this.uvs6 = e;
        break;
      case m.ColorKind:
        this.colors = e;
        break;
      case m.MatricesIndicesKind:
        this.matricesIndices = e;
        break;
      case m.MatricesWeightsKind:
        this.matricesWeights = e;
        break;
      case m.MatricesIndicesExtraKind:
        this.matricesIndicesExtra = e;
        break;
      case m.MatricesWeightsExtraKind:
        this.matricesWeightsExtra = e;
        break;
    }
  }, i.prototype.applyToMesh = function(e, t) {
    return this._applyTo(e, t, !1), this;
  }, i.prototype.applyToGeometry = function(e, t) {
    return this._applyTo(e, t, !1), this;
  }, i.prototype.updateMesh = function(e) {
    return this._update(e), this;
  }, i.prototype.updateGeometry = function(e) {
    return this._update(e), this;
  }, i.prototype._applyToCoroutine = function(e, t, r) {
    return t === void 0 && (t = !1), Gt(this, function(n) {
      switch (n.label) {
        case 0:
          return this.positions ? (e.setVerticesData(m.PositionKind, this.positions, t), r ? [4] : [3, 2]) : [3, 2];
        case 1:
          n.sent(), n.label = 2;
        case 2:
          return this.normals ? (e.setVerticesData(m.NormalKind, this.normals, t), r ? [4] : [3, 4]) : [3, 4];
        case 3:
          n.sent(), n.label = 4;
        case 4:
          return this.tangents ? (e.setVerticesData(m.TangentKind, this.tangents, t), r ? [4] : [3, 6]) : [3, 6];
        case 5:
          n.sent(), n.label = 6;
        case 6:
          return this.uvs ? (e.setVerticesData(m.UVKind, this.uvs, t), r ? [4] : [3, 8]) : [3, 8];
        case 7:
          n.sent(), n.label = 8;
        case 8:
          return this.uvs2 ? (e.setVerticesData(m.UV2Kind, this.uvs2, t), r ? [4] : [3, 10]) : [3, 10];
        case 9:
          n.sent(), n.label = 10;
        case 10:
          return this.uvs3 ? (e.setVerticesData(m.UV3Kind, this.uvs3, t), r ? [4] : [3, 12]) : [3, 12];
        case 11:
          n.sent(), n.label = 12;
        case 12:
          return this.uvs4 ? (e.setVerticesData(m.UV4Kind, this.uvs4, t), r ? [4] : [3, 14]) : [3, 14];
        case 13:
          n.sent(), n.label = 14;
        case 14:
          return this.uvs5 ? (e.setVerticesData(m.UV5Kind, this.uvs5, t), r ? [4] : [3, 16]) : [3, 16];
        case 15:
          n.sent(), n.label = 16;
        case 16:
          return this.uvs6 ? (e.setVerticesData(m.UV6Kind, this.uvs6, t), r ? [4] : [3, 18]) : [3, 18];
        case 17:
          n.sent(), n.label = 18;
        case 18:
          return this.colors ? (e.setVerticesData(m.ColorKind, this.colors, t), r ? [4] : [3, 20]) : [3, 20];
        case 19:
          n.sent(), n.label = 20;
        case 20:
          return this.matricesIndices ? (e.setVerticesData(m.MatricesIndicesKind, this.matricesIndices, t), r ? [4] : [3, 22]) : [3, 22];
        case 21:
          n.sent(), n.label = 22;
        case 22:
          return this.matricesWeights ? (e.setVerticesData(m.MatricesWeightsKind, this.matricesWeights, t), r ? [4] : [3, 24]) : [3, 24];
        case 23:
          n.sent(), n.label = 24;
        case 24:
          return this.matricesIndicesExtra ? (e.setVerticesData(m.MatricesIndicesExtraKind, this.matricesIndicesExtra, t), r ? [4] : [3, 26]) : [3, 26];
        case 25:
          n.sent(), n.label = 26;
        case 26:
          return this.matricesWeightsExtra ? (e.setVerticesData(m.MatricesWeightsExtraKind, this.matricesWeightsExtra, t), r ? [4] : [3, 28]) : [3, 28];
        case 27:
          n.sent(), n.label = 28;
        case 28:
          return this.indices ? (e.setIndices(this.indices, null, t), r ? [4] : [3, 30]) : [3, 31];
        case 29:
          n.sent(), n.label = 30;
        case 30:
          return [3, 32];
        case 31:
          e.setIndices([], null), n.label = 32;
        case 32:
          return [2, this];
      }
    });
  }, i.prototype._update = function(e, t, r) {
    return this.positions && e.updateVerticesData(m.PositionKind, this.positions, t, r), this.normals && e.updateVerticesData(m.NormalKind, this.normals, t, r), this.tangents && e.updateVerticesData(m.TangentKind, this.tangents, t, r), this.uvs && e.updateVerticesData(m.UVKind, this.uvs, t, r), this.uvs2 && e.updateVerticesData(m.UV2Kind, this.uvs2, t, r), this.uvs3 && e.updateVerticesData(m.UV3Kind, this.uvs3, t, r), this.uvs4 && e.updateVerticesData(m.UV4Kind, this.uvs4, t, r), this.uvs5 && e.updateVerticesData(m.UV5Kind, this.uvs5, t, r), this.uvs6 && e.updateVerticesData(m.UV6Kind, this.uvs6, t, r), this.colors && e.updateVerticesData(m.ColorKind, this.colors, t, r), this.matricesIndices && e.updateVerticesData(m.MatricesIndicesKind, this.matricesIndices, t, r), this.matricesWeights && e.updateVerticesData(m.MatricesWeightsKind, this.matricesWeights, t, r), this.matricesIndicesExtra && e.updateVerticesData(m.MatricesIndicesExtraKind, this.matricesIndicesExtra, t, r), this.matricesWeightsExtra && e.updateVerticesData(m.MatricesWeightsExtraKind, this.matricesWeightsExtra, t, r), this.indices && e.setIndices(this.indices, null), this;
  }, i._TransformVector3Coordinates = function(e, t, r, n) {
    r === void 0 && (r = 0), n === void 0 && (n = e.length);
    for (var a = D.Vector3[0], s = D.Vector3[1], o = r; o < r + n; o += 3)
      b.FromArrayToRef(e, o, a), b.TransformCoordinatesToRef(a, t, s), e[o] = s.x, e[o + 1] = s.y, e[o + 2] = s.z;
  }, i._TransformVector3Normals = function(e, t, r, n) {
    r === void 0 && (r = 0), n === void 0 && (n = e.length);
    for (var a = D.Vector3[0], s = D.Vector3[1], o = r; o < r + n; o += 3)
      b.FromArrayToRef(e, o, a), b.TransformNormalToRef(a, t, s), e[o] = s.x, e[o + 1] = s.y, e[o + 2] = s.z;
  }, i._TransformVector4Normals = function(e, t, r, n) {
    r === void 0 && (r = 0), n === void 0 && (n = e.length);
    for (var a = D.Vector4[0], s = D.Vector4[1], o = r; o < r + n; o += 4)
      yt.FromArrayToRef(e, o, a), yt.TransformNormalToRef(a, t, s), e[o] = s.x, e[o + 1] = s.y, e[o + 2] = s.z, e[o + 3] = s.w;
  }, i._FlipFaces = function(e, t, r) {
    t === void 0 && (t = 0), r === void 0 && (r = e.length);
    for (var n = t; n < t + r; n += 3) {
      var a = e[n + 1];
      e[n + 1] = e[n + 2], e[n + 2] = a;
    }
  }, i.prototype.transform = function(e) {
    var t = e.determinant() < 0;
    return this.positions && i._TransformVector3Coordinates(this.positions, e), this.normals && i._TransformVector3Normals(this.normals, e), this.tangents && i._TransformVector4Normals(this.tangents, e), t && this.indices && i._FlipFaces(this.indices), this;
  }, i.prototype.merge = function(e, t, r) {
    t === void 0 && (t = !1), r === void 0 && (r = !1);
    var n = Array.isArray(e) ? e.map(function(a) {
      return [a, void 0];
    }) : [[e, void 0]];
    return vi(this._mergeCoroutine(void 0, n, t, !1, r));
  }, i.prototype._mergeCoroutine = function(e, t, r, n, a) {
    var s, o, u, y, f, l, h, c, d, p, g, _, v, y, E, R, M = this, C, A, S, w;
    return r === void 0 && (r = !1), Gt(this, function(F) {
      switch (F.label) {
        case 0:
          for (this._validate(), s = t.map(function(x) {
            return x[0];
          }), o = 0, u = s; o < u.length; o++)
            if (y = u[o], y._validate(), !this.normals != !y.normals || !this.tangents != !y.tangents || !this.uvs != !y.uvs || !this.uvs2 != !y.uvs2 || !this.uvs3 != !y.uvs3 || !this.uvs4 != !y.uvs4 || !this.uvs5 != !y.uvs5 || !this.uvs6 != !y.uvs6 || !this.colors != !y.colors || !this.matricesIndices != !y.matricesIndices || !this.matricesWeights != !y.matricesWeights || !this.matricesIndicesExtra != !y.matricesIndicesExtra || !this.matricesWeightsExtra != !y.matricesWeightsExtra)
              throw new Error("Cannot merge vertex data that do not have the same set of attributes");
          if (f = s.reduce(function(x, z) {
            var W, N;
            return x + ((N = (W = z.indices) === null || W === void 0 ? void 0 : W.length) !== null && N !== void 0 ? N : 0);
          }, (A = (C = this.indices) === null || C === void 0 ? void 0 : C.length) !== null && A !== void 0 ? A : 0), l = a || s.some(function(x) {
            return x.indices === M.indices;
          }), h = l ? (S = this.indices) === null || S === void 0 ? void 0 : S.slice() : this.indices, !(f > 0))
            return [3, 4];
          c = (w = h == null ? void 0 : h.length) !== null && w !== void 0 ? w : 0, h || (h = new Array(f)), h.length !== f && (Array.isArray(h) ? h.length = f : (d = r || h instanceof Uint32Array ? new Uint32Array(f) : new Uint16Array(f), d.set(h), h = d), e && e.determinant() < 0 && i._FlipFaces(h, 0, c)), p = this.positions ? this.positions.length / 3 : 0, g = 0, _ = t, F.label = 1;
        case 1:
          if (!(g < _.length))
            return [3, 4];
          if (v = _[g], y = v[0], E = v[1], !y.indices)
            return [3, 3];
          for (R = 0; R < y.indices.length; R++)
            h[c + R] = y.indices[R] + p;
          return E && E.determinant() < 0 && i._FlipFaces(h, c, y.indices.length), p += y.positions.length / 3, c += y.indices.length, n ? [4] : [3, 3];
        case 2:
          F.sent(), F.label = 3;
        case 3:
          return g++, [3, 1];
        case 4:
          return this.indices = h, this.positions = i._MergeElement(m.PositionKind, this.positions, e, t.map(function(x) {
            return [x[0].positions, x[1]];
          })), n ? [4] : [3, 6];
        case 5:
          F.sent(), F.label = 6;
        case 6:
          return this.normals = i._MergeElement(m.NormalKind, this.normals, e, t.map(function(x) {
            return [x[0].normals, x[1]];
          })), n ? [4] : [3, 8];
        case 7:
          F.sent(), F.label = 8;
        case 8:
          return this.tangents = i._MergeElement(m.TangentKind, this.tangents, e, t.map(function(x) {
            return [x[0].tangents, x[1]];
          })), n ? [4] : [3, 10];
        case 9:
          F.sent(), F.label = 10;
        case 10:
          return this.uvs = i._MergeElement(m.UVKind, this.uvs, e, t.map(function(x) {
            return [x[0].uvs, x[1]];
          })), n ? [4] : [3, 12];
        case 11:
          F.sent(), F.label = 12;
        case 12:
          return this.uvs2 = i._MergeElement(m.UV2Kind, this.uvs2, e, t.map(function(x) {
            return [x[0].uvs2, x[1]];
          })), n ? [4] : [3, 14];
        case 13:
          F.sent(), F.label = 14;
        case 14:
          return this.uvs3 = i._MergeElement(m.UV3Kind, this.uvs3, e, t.map(function(x) {
            return [x[0].uvs3, x[1]];
          })), n ? [4] : [3, 16];
        case 15:
          F.sent(), F.label = 16;
        case 16:
          return this.uvs4 = i._MergeElement(m.UV4Kind, this.uvs4, e, t.map(function(x) {
            return [x[0].uvs4, x[1]];
          })), n ? [4] : [3, 18];
        case 17:
          F.sent(), F.label = 18;
        case 18:
          return this.uvs5 = i._MergeElement(m.UV5Kind, this.uvs5, e, t.map(function(x) {
            return [x[0].uvs5, x[1]];
          })), n ? [4] : [3, 20];
        case 19:
          F.sent(), F.label = 20;
        case 20:
          return this.uvs6 = i._MergeElement(m.UV6Kind, this.uvs6, e, t.map(function(x) {
            return [x[0].uvs6, x[1]];
          })), n ? [4] : [3, 22];
        case 21:
          F.sent(), F.label = 22;
        case 22:
          return this.colors = i._MergeElement(m.ColorKind, this.colors, e, t.map(function(x) {
            return [x[0].colors, x[1]];
          })), n ? [4] : [3, 24];
        case 23:
          F.sent(), F.label = 24;
        case 24:
          return this.matricesIndices = i._MergeElement(m.MatricesIndicesKind, this.matricesIndices, e, t.map(function(x) {
            return [x[0].matricesIndices, x[1]];
          })), n ? [4] : [3, 26];
        case 25:
          F.sent(), F.label = 26;
        case 26:
          return this.matricesWeights = i._MergeElement(m.MatricesWeightsKind, this.matricesWeights, e, t.map(function(x) {
            return [x[0].matricesWeights, x[1]];
          })), n ? [4] : [3, 28];
        case 27:
          F.sent(), F.label = 28;
        case 28:
          return this.matricesIndicesExtra = i._MergeElement(m.MatricesIndicesExtraKind, this.matricesIndicesExtra, e, t.map(function(x) {
            return [x[0].matricesIndicesExtra, x[1]];
          })), n ? [4] : [3, 30];
        case 29:
          F.sent(), F.label = 30;
        case 30:
          return this.matricesWeightsExtra = i._MergeElement(m.MatricesWeightsExtraKind, this.matricesWeightsExtra, e, t.map(function(x) {
            return [x[0].matricesWeightsExtra, x[1]];
          })), [2, this];
      }
    });
  }, i._MergeElement = function(e, t, r, n) {
    var a = n.filter(function(M) {
      return M[0] !== null && M[0] !== void 0;
    });
    if (!t && a.length == 0)
      return t;
    if (!t)
      return this._MergeElement(e, a[0][0], a[0][1], a.slice(1));
    var s = a.reduce(function(M, C) {
      return M + C[0].length;
    }, t.length), o = e === m.PositionKind ? i._TransformVector3Coordinates : e === m.NormalKind ? i._TransformVector3Normals : e === m.TangentKind ? i._TransformVector4Normals : function() {
    };
    if (t instanceof Float32Array) {
      var u = new Float32Array(s);
      u.set(t), r && o(u, r, 0, t.length);
      for (var f = t.length, l = 0, h = a; l < h.length; l++) {
        var c = h[l], d = c[0], p = c[1];
        u.set(d, f), p && o(u, p, f, d.length), f += d.length;
      }
      return u;
    } else {
      for (var g = new Array(s), _ = 0; _ < t.length; _++)
        g[_] = t[_];
      r && o(g, r, 0, t.length);
      for (var f = t.length, v = 0, y = a; v < y.length; v++) {
        for (var E = y[v], d = E[0], R = E[1], _ = 0; _ < d.length; _++)
          g[f + _] = d[_];
        R && o(g, R, f, d.length), f += d.length;
      }
      return g;
    }
  }, i.prototype._validate = function() {
    if (!this.positions)
      throw new Pt("Positions are required", Rt.MeshInvalidPositionsError);
    var e = function(n, a) {
      var s = m.DeduceStride(n);
      if (a.length % s !== 0)
        throw new Error("The " + n + "s array count must be a multiple of " + s);
      return a.length / s;
    }, t = e(m.PositionKind, this.positions), r = function(n, a) {
      var s = e(n, a);
      if (s !== t)
        throw new Error("The " + n + "s element count (" + s + ") does not match the positions count (" + t + ")");
    };
    this.normals && r(m.NormalKind, this.normals), this.tangents && r(m.TangentKind, this.tangents), this.uvs && r(m.UVKind, this.uvs), this.uvs2 && r(m.UV2Kind, this.uvs2), this.uvs3 && r(m.UV3Kind, this.uvs3), this.uvs4 && r(m.UV4Kind, this.uvs4), this.uvs5 && r(m.UV5Kind, this.uvs5), this.uvs6 && r(m.UV6Kind, this.uvs6), this.colors && r(m.ColorKind, this.colors), this.matricesIndices && r(m.MatricesIndicesKind, this.matricesIndices), this.matricesWeights && r(m.MatricesWeightsKind, this.matricesWeights), this.matricesIndicesExtra && r(m.MatricesIndicesExtraKind, this.matricesIndicesExtra), this.matricesWeightsExtra && r(m.MatricesWeightsExtraKind, this.matricesWeightsExtra);
  }, i.prototype.serialize = function() {
    var e = {};
    return this.positions && (e.positions = this.positions), this.normals && (e.normals = this.normals), this.tangents && (e.tangents = this.tangents), this.uvs && (e.uvs = this.uvs), this.uvs2 && (e.uvs2 = this.uvs2), this.uvs3 && (e.uvs3 = this.uvs3), this.uvs4 && (e.uvs4 = this.uvs4), this.uvs5 && (e.uvs5 = this.uvs5), this.uvs6 && (e.uvs6 = this.uvs6), this.colors && (e.colors = this.colors), this.matricesIndices && (e.matricesIndices = this.matricesIndices, e.matricesIndices._isExpanded = !0), this.matricesWeights && (e.matricesWeights = this.matricesWeights), this.matricesIndicesExtra && (e.matricesIndicesExtra = this.matricesIndicesExtra, e.matricesIndicesExtra._isExpanded = !0), this.matricesWeightsExtra && (e.matricesWeightsExtra = this.matricesWeightsExtra), e.indices = this.indices, e;
  }, i.ExtractFromMesh = function(e, t, r) {
    return i._ExtractFrom(e, t, r);
  }, i.ExtractFromGeometry = function(e, t, r) {
    return i._ExtractFrom(e, t, r);
  }, i._ExtractFrom = function(e, t, r) {
    var n = new i();
    return e.isVerticesDataPresent(m.PositionKind) && (n.positions = e.getVerticesData(m.PositionKind, t, r)), e.isVerticesDataPresent(m.NormalKind) && (n.normals = e.getVerticesData(m.NormalKind, t, r)), e.isVerticesDataPresent(m.TangentKind) && (n.tangents = e.getVerticesData(m.TangentKind, t, r)), e.isVerticesDataPresent(m.UVKind) && (n.uvs = e.getVerticesData(m.UVKind, t, r)), e.isVerticesDataPresent(m.UV2Kind) && (n.uvs2 = e.getVerticesData(m.UV2Kind, t, r)), e.isVerticesDataPresent(m.UV3Kind) && (n.uvs3 = e.getVerticesData(m.UV3Kind, t, r)), e.isVerticesDataPresent(m.UV4Kind) && (n.uvs4 = e.getVerticesData(m.UV4Kind, t, r)), e.isVerticesDataPresent(m.UV5Kind) && (n.uvs5 = e.getVerticesData(m.UV5Kind, t, r)), e.isVerticesDataPresent(m.UV6Kind) && (n.uvs6 = e.getVerticesData(m.UV6Kind, t, r)), e.isVerticesDataPresent(m.ColorKind) && (n.colors = e.getVerticesData(m.ColorKind, t, r)), e.isVerticesDataPresent(m.MatricesIndicesKind) && (n.matricesIndices = e.getVerticesData(m.MatricesIndicesKind, t, r)), e.isVerticesDataPresent(m.MatricesWeightsKind) && (n.matricesWeights = e.getVerticesData(m.MatricesWeightsKind, t, r)), e.isVerticesDataPresent(m.MatricesIndicesExtraKind) && (n.matricesIndicesExtra = e.getVerticesData(m.MatricesIndicesExtraKind, t, r)), e.isVerticesDataPresent(m.MatricesWeightsExtraKind) && (n.matricesWeightsExtra = e.getVerticesData(m.MatricesWeightsExtraKind, t, r)), n.indices = e.getIndices(t, r), n;
  }, i.CreateRibbon = function(e) {
    throw G("ribbonBuilder");
  }, i.CreateBox = function(e) {
    throw G("boxBuilder");
  }, i.CreateTiledBox = function(e) {
    throw G("tiledBoxBuilder");
  }, i.CreateTiledPlane = function(e) {
    throw G("tiledPlaneBuilder");
  }, i.CreateSphere = function(e) {
    throw G("sphereBuilder");
  }, i.CreateCylinder = function(e) {
    throw G("cylinderBuilder");
  }, i.CreateTorus = function(e) {
    throw G("torusBuilder");
  }, i.CreateLineSystem = function(e) {
    throw G("linesBuilder");
  }, i.CreateDashedLines = function(e) {
    throw G("linesBuilder");
  }, i.CreateGround = function(e) {
    throw G("groundBuilder");
  }, i.CreateTiledGround = function(e) {
    throw G("groundBuilder");
  }, i.CreateGroundFromHeightMap = function(e) {
    throw G("groundBuilder");
  }, i.CreatePlane = function(e) {
    throw G("planeBuilder");
  }, i.CreateDisc = function(e) {
    throw G("discBuilder");
  }, i.CreatePolygon = function(e, t, r, n, a, s, o) {
    throw G("polygonBuilder");
  }, i.CreateIcoSphere = function(e) {
    throw G("icoSphereBuilder");
  }, i.CreatePolyhedron = function(e) {
    throw G("polyhedronBuilder");
  }, i.CreateCapsule = function(e) {
    throw e === void 0 && (e = {
      orientation: b.Up(),
      subdivisions: 2,
      tessellation: 16,
      height: 1,
      radius: 0.25,
      capSubdivisions: 6
    }), G("capsuleBuilder");
  }, i.CreateTorusKnot = function(e) {
    throw G("torusKnotBuilder");
  }, i.ComputeNormals = function(e, t, r, n) {
    var a = 0, s = 0, o = 0, u = 0, f = 0, l = 0, h = 0, c = 0, d = 0, p = 0, g = 0, _ = 0, v = 0, y = 0, E = 0, R = 0, M = 0, C = 0, A = 0, S = 0, w = !1, F = !1, x = !1, z = !1, W = 1, N = 0, Z = null;
    n && (w = !!n.facetNormals, F = !!n.facetPositions, x = !!n.facetPartitioning, W = n.useRightHandedSystem === !0 ? -1 : 1, N = n.ratio || 0, z = !!n.depthSort, Z = n.distanceTo, z && Z === void 0 && (Z = b.Zero()));
    var q = 0, ae = 0, Y = 0, H = 0;
    for (x && n && n.bbSize && (q = n.subDiv.X * N / n.bbSize.x, ae = n.subDiv.Y * N / n.bbSize.y, Y = n.subDiv.Z * N / n.bbSize.z, H = n.subDiv.max * n.subDiv.max, n.facetPartitioning.length = 0), a = 0; a < e.length; a++)
      r[a] = 0;
    var se = t.length / 3 | 0;
    for (a = 0; a < se; a++) {
      if (_ = t[a * 3] * 3, v = _ + 1, y = _ + 2, E = t[a * 3 + 1] * 3, R = E + 1, M = E + 2, C = t[a * 3 + 2] * 3, A = C + 1, S = C + 2, s = e[_] - e[E], o = e[v] - e[R], u = e[y] - e[M], f = e[C] - e[E], l = e[A] - e[R], h = e[S] - e[M], c = W * (o * h - u * l), d = W * (u * f - s * h), p = W * (s * l - o * f), g = Math.sqrt(c * c + d * d + p * p), g = g === 0 ? 1 : g, c /= g, d /= g, p /= g, w && n && (n.facetNormals[a].x = c, n.facetNormals[a].y = d, n.facetNormals[a].z = p), F && n && (n.facetPositions[a].x = (e[_] + e[E] + e[C]) / 3, n.facetPositions[a].y = (e[v] + e[R] + e[A]) / 3, n.facetPositions[a].z = (e[y] + e[M] + e[S]) / 3), x && n) {
        var Se = Math.floor((n.facetPositions[a].x - n.bInfo.minimum.x * N) * q), Be = Math.floor((n.facetPositions[a].y - n.bInfo.minimum.y * N) * ae), Ge = Math.floor((n.facetPositions[a].z - n.bInfo.minimum.z * N) * Y), Dt = Math.floor((e[_] - n.bInfo.minimum.x * N) * q), ur = Math.floor((e[v] - n.bInfo.minimum.y * N) * ae), fr = Math.floor((e[y] - n.bInfo.minimum.z * N) * Y), Lr = Math.floor((e[E] - n.bInfo.minimum.x * N) * q), Nr = Math.floor((e[R] - n.bInfo.minimum.y * N) * ae), Br = Math.floor((e[M] - n.bInfo.minimum.z * N) * Y), Ur = Math.floor((e[C] - n.bInfo.minimum.x * N) * q), Vr = Math.floor((e[A] - n.bInfo.minimum.y * N) * ae), kr = Math.floor((e[S] - n.bInfo.minimum.z * N) * Y), st = Dt + n.subDiv.max * ur + H * fr, ot = Lr + n.subDiv.max * Nr + H * Br, ut = Ur + n.subDiv.max * Vr + H * kr, ft = Se + n.subDiv.max * Be + H * Ge;
        n.facetPartitioning[ft] = n.facetPartitioning[ft] ? n.facetPartitioning[ft] : new Array(), n.facetPartitioning[st] = n.facetPartitioning[st] ? n.facetPartitioning[st] : new Array(), n.facetPartitioning[ot] = n.facetPartitioning[ot] ? n.facetPartitioning[ot] : new Array(), n.facetPartitioning[ut] = n.facetPartitioning[ut] ? n.facetPartitioning[ut] : new Array(), n.facetPartitioning[st].push(a), ot != st && n.facetPartitioning[ot].push(a), ut == ot || ut == st || n.facetPartitioning[ut].push(a), ft == st || ft == ot || ft == ut || n.facetPartitioning[ft].push(a);
      }
      if (z && n && n.facetPositions) {
        var lr = n.depthSortedFacets[a];
        lr.ind = a * 3, lr.sqDistance = b.DistanceSquared(n.facetPositions[a], Z);
      }
      r[_] += c, r[v] += d, r[y] += p, r[E] += c, r[R] += d, r[M] += p, r[C] += c, r[A] += d, r[S] += p;
    }
    for (a = 0; a < r.length / 3; a++)
      c = r[a * 3], d = r[a * 3 + 1], p = r[a * 3 + 2], g = Math.sqrt(c * c + d * d + p * p), g = g === 0 ? 1 : g, c /= g, d /= g, p /= g, r[a * 3] = c, r[a * 3 + 1] = d, r[a * 3 + 2] = p;
  }, i._ComputeSides = function(e, t, r, n, a, s, o) {
    var u = r.length, f = n.length, l, h;
    switch (e = e || i.DEFAULTSIDE, e) {
      case i.FRONTSIDE:
        break;
      case i.BACKSIDE:
        for (l = 0; l < u; l += 3) {
          var c = r[l];
          r[l] = r[l + 2], r[l + 2] = c;
        }
        for (h = 0; h < f; h++)
          n[h] = -n[h];
        break;
      case i.DOUBLESIDE: {
        for (var d = t.length, p = d / 3, g = 0; g < d; g++)
          t[d + g] = t[g];
        for (l = 0; l < u; l += 3)
          r[l + u] = r[l + 2] + p, r[l + 1 + u] = r[l + 1] + p, r[l + 2 + u] = r[l] + p;
        for (h = 0; h < f; h++)
          n[f + h] = -n[h];
        var _ = a.length, v = 0;
        for (v = 0; v < _; v++)
          a[v + _] = a[v];
        for (s = s || new yt(0, 0, 1, 1), o = o || new yt(0, 0, 1, 1), v = 0, l = 0; l < _ / 2; l++)
          a[v] = s.x + (s.z - s.x) * a[v], a[v + 1] = s.y + (s.w - s.y) * a[v + 1], a[v + _] = o.x + (o.z - o.x) * a[v + _], a[v + _ + 1] = o.y + (o.w - o.y) * a[v + _ + 1], v += 2;
        break;
      }
    }
  }, i.ImportVertexData = function(e, t) {
    var r = new i(), n = e.positions;
    n && r.set(n, m.PositionKind);
    var a = e.normals;
    a && r.set(a, m.NormalKind);
    var s = e.tangents;
    s && r.set(s, m.TangentKind);
    var o = e.uvs;
    o && r.set(o, m.UVKind);
    var u = e.uv2s;
    u && r.set(u, m.UV2Kind);
    var f = e.uv3s;
    f && r.set(f, m.UV3Kind);
    var l = e.uv4s;
    l && r.set(l, m.UV4Kind);
    var h = e.uv5s;
    h && r.set(h, m.UV5Kind);
    var c = e.uv6s;
    c && r.set(c, m.UV6Kind);
    var d = e.colors;
    d && r.set(be.CheckColors4(d, n.length / 3), m.ColorKind);
    var p = e.matricesIndices;
    p && r.set(p, m.MatricesIndicesKind);
    var g = e.matricesWeights;
    g && r.set(g, m.MatricesWeightsKind);
    var _ = e.indices;
    _ && (r.indices = _), t.setAllVerticesData(r, e.updatable);
  }, i.FRONTSIDE = 0, i.BACKSIDE = 1, i.DOUBLESIDE = 2, i.DEFAULTSIDE = 0, T([
    bt.filter(function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      var r = e[0];
      return !Array.isArray(r);
    })
  ], i, "_TransformVector3Coordinates", null), T([
    bt.filter(function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      var r = e[0];
      return !Array.isArray(r);
    })
  ], i, "_TransformVector3Normals", null), T([
    bt.filter(function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      var r = e[0];
      return !Array.isArray(r);
    })
  ], i, "_TransformVector4Normals", null), T([
    bt.filter(function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      var r = e[0];
      return !Array.isArray(r);
    })
  ], i, "_FlipFaces", null), i;
}(), ai = function() {
  function i(e, t, r) {
    this.bu = e, this.bv = t, this.distance = r, this.faceId = 0, this.subMeshId = 0;
  }
  return i;
}(), Vi = function() {
  function i(e, t, r) {
    this.vectors = xe.BuildArray(8, b.Zero), this.center = b.Zero(), this.centerWorld = b.Zero(), this.extendSize = b.Zero(), this.extendSizeWorld = b.Zero(), this.directions = xe.BuildArray(3, b.Zero), this.vectorsWorld = xe.BuildArray(8, b.Zero), this.minimumWorld = b.Zero(), this.maximumWorld = b.Zero(), this.minimum = b.Zero(), this.maximum = b.Zero(), this._drawWrapperFront = null, this._drawWrapperBack = null, this.reConstruct(e, t, r);
  }
  return i.prototype.reConstruct = function(e, t, r) {
    var n = e.x, a = e.y, s = e.z, o = t.x, u = t.y, f = t.z, l = this.vectors;
    this.minimum.copyFromFloats(n, a, s), this.maximum.copyFromFloats(o, u, f), l[0].copyFromFloats(n, a, s), l[1].copyFromFloats(o, u, f), l[2].copyFromFloats(o, a, s), l[3].copyFromFloats(n, u, s), l[4].copyFromFloats(n, a, f), l[5].copyFromFloats(o, u, s), l[6].copyFromFloats(n, u, f), l[7].copyFromFloats(o, a, f), t.addToRef(e, this.center).scaleInPlace(0.5), t.subtractToRef(e, this.extendSize).scaleInPlace(0.5), this._worldMatrix = r || I.IdentityReadOnly, this._update(this._worldMatrix);
  }, i.prototype.scale = function(e) {
    var t = i._TmpVector3, r = this.maximum.subtractToRef(this.minimum, t[0]), n = r.length();
    r.normalizeFromLength(n);
    var a = n * e, s = r.scaleInPlace(a * 0.5), o = this.center.subtractToRef(s, t[1]), u = this.center.addToRef(s, t[2]);
    return this.reConstruct(o, u, this._worldMatrix), this;
  }, i.prototype.getWorldMatrix = function() {
    return this._worldMatrix;
  }, i.prototype._update = function(e) {
    var t = this.minimumWorld, r = this.maximumWorld, n = this.directions, a = this.vectorsWorld, s = this.vectors;
    if (e.isIdentity()) {
      t.copyFrom(this.minimum), r.copyFrom(this.maximum);
      for (var o = 0; o < 8; ++o)
        a[o].copyFrom(s[o]);
      this.extendSizeWorld.copyFrom(this.extendSize), this.centerWorld.copyFrom(this.center);
    } else {
      t.setAll(Number.MAX_VALUE), r.setAll(-Number.MAX_VALUE);
      for (var o = 0; o < 8; ++o) {
        var u = a[o];
        b.TransformCoordinatesToRef(s[o], e, u), t.minimizeInPlace(u), r.maximizeInPlace(u);
      }
      r.subtractToRef(t, this.extendSizeWorld).scaleInPlace(0.5), r.addToRef(t, this.centerWorld).scaleInPlace(0.5);
    }
    b.FromArrayToRef(e.m, 0, n[0]), b.FromArrayToRef(e.m, 4, n[1]), b.FromArrayToRef(e.m, 8, n[2]), this._worldMatrix = e;
  }, i.prototype.isInFrustum = function(e) {
    return i.IsInFrustum(this.vectorsWorld, e);
  }, i.prototype.isCompletelyInFrustum = function(e) {
    return i.IsCompletelyInFrustum(this.vectorsWorld, e);
  }, i.prototype.intersectsPoint = function(e) {
    var t = this.minimumWorld, r = this.maximumWorld, n = t.x, a = t.y, s = t.z, o = r.x, u = r.y, f = r.z, l = e.x, h = e.y, c = e.z, d = -ce;
    return !(o - l < d || d > l - n || u - h < d || d > h - a || f - c < d || d > c - s);
  }, i.prototype.intersectsSphere = function(e) {
    return i.IntersectsSphere(this.minimumWorld, this.maximumWorld, e.centerWorld, e.radiusWorld);
  }, i.prototype.intersectsMinMax = function(e, t) {
    var r = this.minimumWorld, n = this.maximumWorld, a = r.x, s = r.y, o = r.z, u = n.x, f = n.y, l = n.z, h = e.x, c = e.y, d = e.z, p = t.x, g = t.y, _ = t.z;
    return !(u < h || a > p || f < c || s > g || l < d || o > _);
  }, i.prototype.dispose = function() {
    var e, t;
    (e = this._drawWrapperFront) === null || e === void 0 || e.dispose(), (t = this._drawWrapperBack) === null || t === void 0 || t.dispose();
  }, i.Intersects = function(e, t) {
    return e.intersectsMinMax(t.minimumWorld, t.maximumWorld);
  }, i.IntersectsSphere = function(e, t, r, n) {
    var a = i._TmpVector3[0];
    b.ClampToRef(r, e, t, a);
    var s = b.DistanceSquared(r, a);
    return s <= n * n;
  }, i.IsCompletelyInFrustum = function(e, t) {
    for (var r = 0; r < 6; ++r)
      for (var n = t[r], a = 0; a < 8; ++a)
        if (n.dotCoordinate(e[a]) < 0)
          return !1;
    return !0;
  }, i.IsInFrustum = function(e, t) {
    for (var r = 0; r < 6; ++r) {
      for (var n = !0, a = t[r], s = 0; s < 8; ++s)
        if (a.dotCoordinate(e[s]) >= 0) {
          n = !1;
          break;
        }
      if (n)
        return !1;
    }
    return !0;
  }, i._TmpVector3 = xe.BuildArray(3, b.Zero), i;
}(), ki = function() {
  function i(e, t, r) {
    this.center = b.Zero(), this.centerWorld = b.Zero(), this.minimum = b.Zero(), this.maximum = b.Zero(), this.reConstruct(e, t, r);
  }
  return i.prototype.reConstruct = function(e, t, r) {
    this.minimum.copyFrom(e), this.maximum.copyFrom(t);
    var n = b.Distance(e, t);
    t.addToRef(e, this.center).scaleInPlace(0.5), this.radius = n * 0.5, this._update(r || I.IdentityReadOnly);
  }, i.prototype.scale = function(e) {
    var t = this.radius * e, r = i._TmpVector3, n = r[0].setAll(t), a = this.center.subtractToRef(n, r[1]), s = this.center.addToRef(n, r[2]);
    return this.reConstruct(a, s, this._worldMatrix), this;
  }, i.prototype.getWorldMatrix = function() {
    return this._worldMatrix;
  }, i.prototype._update = function(e) {
    if (e.isIdentity())
      this.centerWorld.copyFrom(this.center), this.radiusWorld = this.radius;
    else {
      b.TransformCoordinatesToRef(this.center, e, this.centerWorld);
      var t = i._TmpVector3[0];
      b.TransformNormalFromFloatsToRef(1, 1, 1, e, t), this.radiusWorld = Math.max(Math.abs(t.x), Math.abs(t.y), Math.abs(t.z)) * this.radius;
    }
  }, i.prototype.isInFrustum = function(e) {
    for (var t = this.centerWorld, r = this.radiusWorld, n = 0; n < 6; n++)
      if (e[n].dotCoordinate(t) <= -r)
        return !1;
    return !0;
  }, i.prototype.isCenterInFrustum = function(e) {
    for (var t = this.centerWorld, r = 0; r < 6; r++)
      if (e[r].dotCoordinate(t) < 0)
        return !1;
    return !0;
  }, i.prototype.intersectsPoint = function(e) {
    var t = b.DistanceSquared(this.centerWorld, e);
    return !(this.radiusWorld * this.radiusWorld < t);
  }, i.Intersects = function(e, t) {
    var r = b.DistanceSquared(e.centerWorld, t.centerWorld), n = e.radiusWorld + t.radiusWorld;
    return !(n * n < r);
  }, i.CreateFromCenterAndRadius = function(e, t, r) {
    this._TmpVector3[0].copyFrom(e), this._TmpVector3[1].copyFromFloats(0, 0, t), this._TmpVector3[2].copyFrom(e), this._TmpVector3[0].addInPlace(this._TmpVector3[1]), this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);
    var n = new i(this._TmpVector3[0], this._TmpVector3[2]);
    return r ? n._worldMatrix = r : n._worldMatrix = I.Identity(), n;
  }, i._TmpVector3 = xe.BuildArray(3, b.Zero), i;
}(), Xr = { min: 0, max: 0 }, Hr = { min: 0, max: 0 }, Wi = function(i, e, t) {
  var r = b.Dot(e.centerWorld, i), n = Math.abs(b.Dot(e.directions[0], i)) * e.extendSize.x, a = Math.abs(b.Dot(e.directions[1], i)) * e.extendSize.y, s = Math.abs(b.Dot(e.directions[2], i)) * e.extendSize.z, o = n + a + s;
  t.min = r - o, t.max = r + o;
}, Fe = function(i, e, t) {
  return Wi(i, e, Xr), Wi(i, t, Hr), !(Xr.min > Hr.max || Hr.min > Xr.max);
}, Et = function() {
  function i(e, t, r) {
    this._isLocked = !1, this.boundingBox = new Vi(e, t, r), this.boundingSphere = new ki(e, t, r);
  }
  return i.prototype.reConstruct = function(e, t, r) {
    this.boundingBox.reConstruct(e, t, r), this.boundingSphere.reConstruct(e, t, r);
  }, Object.defineProperty(i.prototype, "minimum", {
    get: function() {
      return this.boundingBox.minimum;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "maximum", {
    get: function() {
      return this.boundingBox.maximum;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "isLocked", {
    get: function() {
      return this._isLocked;
    },
    set: function(e) {
      this._isLocked = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.update = function(e) {
    this._isLocked || (this.boundingBox._update(e), this.boundingSphere._update(e));
  }, i.prototype.centerOn = function(e, t) {
    var r = i._TmpVector3[0].copyFrom(e).subtractInPlace(t), n = i._TmpVector3[1].copyFrom(e).addInPlace(t);
    return this.boundingBox.reConstruct(r, n, this.boundingBox.getWorldMatrix()), this.boundingSphere.reConstruct(r, n, this.boundingBox.getWorldMatrix()), this;
  }, i.prototype.encapsulate = function(e) {
    var t = b.Minimize(this.minimum, e), r = b.Maximize(this.maximum, e);
    return this.reConstruct(t, r, this.boundingBox.getWorldMatrix()), this;
  }, i.prototype.encapsulateBoundingInfo = function(e) {
    return this.encapsulate(e.boundingBox.centerWorld.subtract(e.boundingBox.extendSizeWorld)), this.encapsulate(e.boundingBox.centerWorld.add(e.boundingBox.extendSizeWorld)), this;
  }, i.prototype.scale = function(e) {
    return this.boundingBox.scale(e), this.boundingSphere.scale(e), this;
  }, i.prototype.isInFrustum = function(e, t) {
    t === void 0 && (t = 0);
    var r = t === 2 || t === 3;
    if (r && this.boundingSphere.isCenterInFrustum(e))
      return !0;
    if (!this.boundingSphere.isInFrustum(e))
      return !1;
    var n = t === 1 || t === 3;
    return n ? !0 : this.boundingBox.isInFrustum(e);
  }, Object.defineProperty(i.prototype, "diagonalLength", {
    get: function() {
      var e = this.boundingBox, t = e.maximumWorld.subtractToRef(e.minimumWorld, i._TmpVector3[0]);
      return t.length();
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.isCompletelyInFrustum = function(e) {
    return this.boundingBox.isCompletelyInFrustum(e);
  }, i.prototype._checkCollision = function(e) {
    return e._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);
  }, i.prototype.intersectsPoint = function(e) {
    return !(!this.boundingSphere.centerWorld || !this.boundingSphere.intersectsPoint(e) || !this.boundingBox.intersectsPoint(e));
  }, i.prototype.intersects = function(e, t) {
    if (!ki.Intersects(this.boundingSphere, e.boundingSphere) || !Vi.Intersects(this.boundingBox, e.boundingBox))
      return !1;
    if (!t)
      return !0;
    var r = this.boundingBox, n = e.boundingBox;
    return !(!Fe(r.directions[0], r, n) || !Fe(r.directions[1], r, n) || !Fe(r.directions[2], r, n) || !Fe(n.directions[0], r, n) || !Fe(n.directions[1], r, n) || !Fe(n.directions[2], r, n) || !Fe(b.Cross(r.directions[0], n.directions[0]), r, n) || !Fe(b.Cross(r.directions[0], n.directions[1]), r, n) || !Fe(b.Cross(r.directions[0], n.directions[2]), r, n) || !Fe(b.Cross(r.directions[1], n.directions[0]), r, n) || !Fe(b.Cross(r.directions[1], n.directions[1]), r, n) || !Fe(b.Cross(r.directions[1], n.directions[2]), r, n) || !Fe(b.Cross(r.directions[2], n.directions[0]), r, n) || !Fe(b.Cross(r.directions[2], n.directions[1]), r, n) || !Fe(b.Cross(r.directions[2], n.directions[2]), r, n));
  }, i._TmpVector3 = xe.BuildArray(2, b.Zero), i;
}(), cn = function() {
  function i() {
  }
  return i.extractMinAndMaxIndexed = function(e, t, r, n, a, s) {
    for (var o = r; o < r + n; o++) {
      var u = t[o] * 3, f = e[u], l = e[u + 1], h = e[u + 2];
      a.minimizeInPlaceFromFloats(f, l, h), s.maximizeInPlaceFromFloats(f, l, h);
    }
  }, i.extractMinAndMax = function(e, t, r, n, a, s) {
    for (var o = t, u = t * n; o < t + r; o++, u += n) {
      var f = e[u], l = e[u + 1], h = e[u + 2];
      a.minimizeInPlaceFromFloats(f, l, h), s.maximizeInPlaceFromFloats(f, l, h);
    }
  }, T([
    bt.filter(function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      var r = e[0], n = e[1];
      return !Array.isArray(r) && !Array.isArray(n);
    })
  ], i, "extractMinAndMaxIndexed", null), T([
    bt.filter(function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      var r = e[0];
      return !Array.isArray(r);
    })
  ], i, "extractMinAndMax", null), i;
}();
function ba(i, e, t, r, n) {
  n === void 0 && (n = null);
  var a = new b(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), s = new b(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  return cn.extractMinAndMaxIndexed(i, e, t, r, a, s), n && (a.x -= a.x * n.x + n.y, a.y -= a.y * n.x + n.y, a.z -= a.z * n.x + n.y, s.x += s.x * n.x + n.y, s.y += s.y * n.x + n.y, s.z += s.z * n.x + n.y), {
    minimum: a,
    maximum: s
  };
}
function dn(i, e, t, r, n) {
  r === void 0 && (r = null);
  var a = new b(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), s = new b(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  return n || (n = 3), cn.extractMinAndMax(i, e, t, n, a, s), r && (a.x -= a.x * r.x + r.y, a.y -= a.y * r.x + r.y, a.z -= a.z * r.x + r.y, s.x += s.x * r.x + r.y, s.y += s.y * r.x + r.y, s.z += s.z * r.x + r.y), {
    minimum: a,
    maximum: s
  };
}
var mt = function() {
  function i(e, t, r, n, a, s, o, u, f) {
    u === void 0 && (u = !0), f === void 0 && (f = !0), this.materialIndex = e, this.verticesStart = t, this.verticesCount = r, this.indexStart = n, this.indexCount = a, this._mainDrawWrapperOverride = null, this._linesIndexCount = 0, this._linesIndexBuffer = null, this._lastColliderWorldVertices = null, this._lastColliderTransformMatrix = null, this._renderId = 0, this._alphaIndex = 0, this._distanceToCamera = 0, this._currentMaterial = null, this._mesh = s, this._renderingMesh = o || s, f && s.subMeshes.push(this), this._engine = this._mesh.getScene().getEngine(), this.resetDrawCache(), this._trianglePlanes = [], this._id = s.subMeshes.length - 1, u && (this.refreshBoundingInfo(), s.computeWorldMatrix(!0));
  }
  return Object.defineProperty(i.prototype, "materialDefines", {
    get: function() {
      var e;
      return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (e = this._getDrawWrapper()) === null || e === void 0 ? void 0 : e.defines;
    },
    set: function(e) {
      var t, r = (t = this._mainDrawWrapperOverride) !== null && t !== void 0 ? t : this._getDrawWrapper(void 0, !0);
      r.defines = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._getDrawWrapper = function(e, t) {
    t === void 0 && (t = !1), e = e != null ? e : this._engine.currentRenderPassId;
    var r = this._drawWrappers[e];
    return !r && t && (this._drawWrappers[e] = r = new sr(this._mesh.getScene().getEngine())), r;
  }, i.prototype._removeDrawWrapper = function(e, t) {
    var r;
    t === void 0 && (t = !0), t && ((r = this._drawWrappers[e]) === null || r === void 0 || r.dispose()), this._drawWrappers[e] = void 0;
  }, Object.defineProperty(i.prototype, "effect", {
    get: function() {
      var e, t;
      return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (t = (e = this._getDrawWrapper()) === null || e === void 0 ? void 0 : e.effect) !== null && t !== void 0 ? t : null;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "_drawWrapper", {
    get: function() {
      var e;
      return (e = this._mainDrawWrapperOverride) !== null && e !== void 0 ? e : this._getDrawWrapper(void 0, !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "_drawWrapperOverride", {
    get: function() {
      return this._mainDrawWrapperOverride;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._setMainDrawWrapperOverride = function(e) {
    this._mainDrawWrapperOverride = e;
  }, i.prototype.setEffect = function(e, t, r, n) {
    t === void 0 && (t = null), n === void 0 && (n = !0);
    var a = this._drawWrapper;
    a.setEffect(e, t, n), r !== void 0 && (a.materialContext = r), e || (a.defines = null, a.materialContext = void 0);
  }, i.prototype.resetDrawCache = function(e) {
    if (this._drawWrappers)
      if (e !== void 0) {
        this._removeDrawWrapper(e);
        return;
      } else
        for (var t = 0, r = this._drawWrappers; t < r.length; t++) {
          var n = r[t];
          n == null || n.dispose();
        }
    this._drawWrappers = [];
  }, i.AddToMesh = function(e, t, r, n, a, s, o, u) {
    return u === void 0 && (u = !0), new i(e, t, r, n, a, s, o, u);
  }, Object.defineProperty(i.prototype, "IsGlobal", {
    get: function() {
      return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getBoundingInfo = function() {
    return this.IsGlobal ? this._mesh.getBoundingInfo() : this._boundingInfo;
  }, i.prototype.setBoundingInfo = function(e) {
    return this._boundingInfo = e, this;
  }, i.prototype.getMesh = function() {
    return this._mesh;
  }, i.prototype.getRenderingMesh = function() {
    return this._renderingMesh;
  }, i.prototype.getReplacementMesh = function() {
    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
  }, i.prototype.getEffectiveMesh = function() {
    var e = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
    return e || this._renderingMesh;
  }, i.prototype.getMaterial = function() {
    var e, t = (e = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) !== null && e !== void 0 ? e : this._renderingMesh.material;
    if (t) {
      if (this._isMultiMaterial(t)) {
        var r = t.getSubMaterial(this.materialIndex);
        return this._currentMaterial !== r && (this._currentMaterial = r, this.resetDrawCache()), r;
      }
    } else
      return this._mesh.getScene().defaultMaterial;
    return t;
  }, i.prototype._isMultiMaterial = function(e) {
    return e.getSubMaterial !== void 0;
  }, i.prototype.refreshBoundingInfo = function(e) {
    if (e === void 0 && (e = null), this._lastColliderWorldVertices = null, this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry)
      return this;
    if (e || (e = this._renderingMesh.getVerticesData(m.PositionKind)), !e)
      return this._boundingInfo = this._mesh.getBoundingInfo(), this;
    var t = this._renderingMesh.getIndices(), r;
    if (this.indexStart === 0 && this.indexCount === t.length) {
      var n = this._renderingMesh.getBoundingInfo();
      r = { minimum: n.minimum.clone(), maximum: n.maximum.clone() };
    } else
      r = ba(e, t, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);
    return this._boundingInfo ? this._boundingInfo.reConstruct(r.minimum, r.maximum) : this._boundingInfo = new Et(r.minimum, r.maximum), this;
  }, i.prototype._checkCollision = function(e) {
    var t = this.getBoundingInfo();
    return t._checkCollision(e);
  }, i.prototype.updateBoundingInfo = function(e) {
    var t = this.getBoundingInfo();
    return t || (this.refreshBoundingInfo(), t = this.getBoundingInfo()), t && t.update(e), this;
  }, i.prototype.isInFrustum = function(e) {
    var t = this.getBoundingInfo();
    return t ? t.isInFrustum(e, this._mesh.cullingStrategy) : !1;
  }, i.prototype.isCompletelyInFrustum = function(e) {
    var t = this.getBoundingInfo();
    return t ? t.isCompletelyInFrustum(e) : !1;
  }, i.prototype.render = function(e) {
    return this._renderingMesh.render(this, e, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : void 0), this;
  }, i.prototype._getLinesIndexBuffer = function(e, t) {
    if (!this._linesIndexBuffer) {
      for (var r = [], n = this.indexStart; n < this.indexStart + this.indexCount; n += 3)
        r.push(e[n], e[n + 1], e[n + 1], e[n + 2], e[n + 2], e[n]);
      this._linesIndexBuffer = t.createIndexBuffer(r), this._linesIndexCount = r.length;
    }
    return this._linesIndexBuffer;
  }, i.prototype.canIntersects = function(e) {
    var t = this.getBoundingInfo();
    return t ? e.intersectsBox(t.boundingBox) : !1;
  }, i.prototype.intersects = function(e, t, r, n, a) {
    var s = this.getMaterial();
    if (!s)
      return null;
    var o = 3, u = !1;
    switch (s.fillMode) {
      case 3:
      case 5:
      case 6:
      case 8:
        return null;
      case 7:
        o = 1, u = !0;
        break;
    }
    return s.fillMode === 4 ? r.length ? this._intersectLines(e, t, r, this._mesh.intersectionThreshold, n) : this._intersectUnIndexedLines(e, t, r, this._mesh.intersectionThreshold, n) : !r.length && this._mesh._unIndexed ? this._intersectUnIndexedTriangles(e, t, r, n, a) : this._intersectTriangles(e, t, r, o, u, n, a);
  }, i.prototype._intersectLines = function(e, t, r, n, a) {
    for (var s = null, o = this.indexStart; o < this.indexStart + this.indexCount; o += 2) {
      var u = t[r[o]], f = t[r[o + 1]], l = e.intersectionSegment(u, f, n);
      if (!(l < 0) && (a || !s || l < s.distance) && (s = new ai(null, null, l), s.faceId = o / 2, a))
        break;
    }
    return s;
  }, i.prototype._intersectUnIndexedLines = function(e, t, r, n, a) {
    for (var s = null, o = this.verticesStart; o < this.verticesStart + this.verticesCount; o += 2) {
      var u = t[o], f = t[o + 1], l = e.intersectionSegment(u, f, n);
      if (!(l < 0) && (a || !s || l < s.distance) && (s = new ai(null, null, l), s.faceId = o / 2, a))
        break;
    }
    return s;
  }, i.prototype._intersectTriangles = function(e, t, r, n, a, s, o) {
    for (var u = null, f = -1, l = this.indexStart; l < this.indexStart + this.indexCount - (3 - n); l += n) {
      f++;
      var h = r[l], c = r[l + 1], d = r[l + 2];
      if (a && d === 4294967295) {
        l += 2;
        continue;
      }
      var p = t[h], g = t[c], _ = t[d];
      if (!(!p || !g || !_) && !(o && !o(p, g, _, e))) {
        var v = e.intersectsTriangle(p, g, _);
        if (v) {
          if (v.distance < 0)
            continue;
          if ((s || !u || v.distance < u.distance) && (u = v, u.faceId = f, s))
            break;
        }
      }
    }
    return u;
  }, i.prototype._intersectUnIndexedTriangles = function(e, t, r, n, a) {
    for (var s = null, o = this.verticesStart; o < this.verticesStart + this.verticesCount; o += 3) {
      var u = t[o], f = t[o + 1], l = t[o + 2];
      if (!(a && !a(u, f, l, e))) {
        var h = e.intersectsTriangle(u, f, l);
        if (h) {
          if (h.distance < 0)
            continue;
          if ((n || !s || h.distance < s.distance) && (s = h, s.faceId = o / 3, n))
            break;
        }
      }
    }
    return s;
  }, i.prototype._rebuild = function() {
    this._linesIndexBuffer && (this._linesIndexBuffer = null);
  }, i.prototype.clone = function(e, t) {
    var r = new i(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, e, t, !1);
    if (!this.IsGlobal) {
      var n = this.getBoundingInfo();
      if (!n)
        return r;
      r._boundingInfo = new Et(n.minimum, n.maximum);
    }
    return r;
  }, i.prototype.dispose = function() {
    this._linesIndexBuffer && (this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer), this._linesIndexBuffer = null);
    var e = this._mesh.subMeshes.indexOf(this);
    this._mesh.subMeshes.splice(e, 1), this.resetDrawCache();
  }, i.prototype.getClassName = function() {
    return "SubMesh";
  }, i.CreateFromIndices = function(e, t, r, n, a, s) {
    s === void 0 && (s = !0);
    for (var o = Number.MAX_VALUE, u = -Number.MAX_VALUE, f = a || n, l = f.getIndices(), h = t; h < t + r; h++) {
      var c = l[h];
      c < o && (o = c), c > u && (u = c);
    }
    return new i(e, o, u - o + 1, t, r, n, a, s);
  }, i;
}(), tt = function() {
  function i() {
  }
  return Object.defineProperty(i, "ForceFullSceneLoadingForIncremental", {
    get: function() {
      return i._ForceFullSceneLoadingForIncremental;
    },
    set: function(e) {
      i._ForceFullSceneLoadingForIncremental = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "ShowLoadingScreen", {
    get: function() {
      return i._ShowLoadingScreen;
    },
    set: function(e) {
      i._ShowLoadingScreen = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "loggingLevel", {
    get: function() {
      return i._LoggingLevel;
    },
    set: function(e) {
      i._LoggingLevel = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "CleanBoneMatrixWeights", {
    get: function() {
      return i._CleanBoneMatrixWeights;
    },
    set: function(e) {
      i._CleanBoneMatrixWeights = e;
    },
    enumerable: !1,
    configurable: !0
  }), i._ForceFullSceneLoadingForIncremental = !1, i._ShowLoadingScreen = !0, i._CleanBoneMatrixWeights = !1, i._LoggingLevel = 0, i;
}(), Ye = function() {
  function i() {
  }
  return i.UseOpenGLOrientationForUV = !1, i;
}(), gt = function() {
  function i(e, t, r, n, a) {
    n === void 0 && (n = !1), a === void 0 && (a = null), this.delayLoadState = 0, this._totalVertices = 0, this._isDisposed = !1, this._indexBufferIsUpdatable = !1, this._positionsCache = [], this._parentContainer = null, this.useBoundingInfoFromGeometry = !1, this._scene = t || re.LastCreatedScene, this._scene && (this.id = e, this.uniqueId = this._scene.getUniqueId(), this._engine = this._scene.getEngine(), this._meshes = [], this._vertexBuffers = {}, this._indices = [], this._updatable = n, r ? this.setAllVerticesData(r, n) : (this._totalVertices = 0, this._indices = []), this._engine.getCaps().vertexArrayObject && (this._vertexArrayObjects = {}), a && (this.applyToMesh(a), a.computeWorldMatrix(!0)));
  }
  return Object.defineProperty(i.prototype, "boundingBias", {
    get: function() {
      return this._boundingBias;
    },
    set: function(e) {
      this._boundingBias ? this._boundingBias.copyFrom(e) : this._boundingBias = e.clone(), this._updateBoundingInfo(!0, null);
    },
    enumerable: !1,
    configurable: !0
  }), i.CreateGeometryForMesh = function(e) {
    var t = new i(i.RandomId(), e.getScene());
    return t.applyToMesh(e), t;
  }, Object.defineProperty(i.prototype, "meshes", {
    get: function() {
      return this._meshes;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "extend", {
    get: function() {
      return this._extend;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getScene = function() {
    return this._scene;
  }, i.prototype.getEngine = function() {
    return this._engine;
  }, i.prototype.isReady = function() {
    return this.delayLoadState === 1 || this.delayLoadState === 0;
  }, Object.defineProperty(i.prototype, "doNotSerialize", {
    get: function() {
      for (var e = 0; e < this._meshes.length; e++)
        if (!this._meshes[e].doNotSerialize)
          return !1;
      return !0;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._rebuild = function() {
    this._vertexArrayObjects && (this._vertexArrayObjects = {}), this._meshes.length !== 0 && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable));
    for (var e in this._vertexBuffers) {
      var t = this._vertexBuffers[e];
      t._rebuild();
    }
  }, i.prototype.setAllVerticesData = function(e, t) {
    e.applyToGeometry(this, t), this._notifyUpdate();
  }, i.prototype.setVerticesData = function(e, t, r, n) {
    r === void 0 && (r = !1), r && Array.isArray(t) && (t = new Float32Array(t));
    var a = new m(this._engine, t, e, r, this._meshes.length === 0, n);
    this.setVerticesBuffer(a);
  }, i.prototype.removeVerticesData = function(e) {
    this._vertexBuffers[e] && (this._vertexBuffers[e].dispose(), delete this._vertexBuffers[e]), this._vertexArrayObjects && this._disposeVertexArrayObjects();
  }, i.prototype.setVerticesBuffer = function(e, t, r) {
    t === void 0 && (t = null), r === void 0 && (r = !0);
    var n = e.getKind();
    this._vertexBuffers[n] && r && this._vertexBuffers[n].dispose(), e._buffer && e._buffer._increaseReferences(), this._vertexBuffers[n] = e;
    var a = this._meshes, s = a.length;
    if (n === m.PositionKind) {
      var o = e.getData();
      t != null ? this._totalVertices = t : o != null && (this._totalVertices = o.length / (e.type === m.BYTE ? e.byteStride : e.byteStride / 4)), this._updateExtend(o), this._resetPointsArrayCache();
      for (var u = 0; u < s; u++) {
        var f = a[u];
        f.buildBoundingInfo(this._extend.minimum, this._extend.maximum), f._createGlobalSubMesh(f.isUnIndexed), f.computeWorldMatrix(!0), f.synchronizeInstances();
      }
    }
    this._notifyUpdate(n);
  }, i.prototype.updateVerticesDataDirectly = function(e, t, r, n) {
    n === void 0 && (n = !1);
    var a = this.getVertexBuffer(e);
    !a || (a.updateDirectly(t, r, n), this._notifyUpdate(e));
  }, i.prototype.updateVerticesData = function(e, t, r) {
    r === void 0 && (r = !1);
    var n = this.getVertexBuffer(e);
    !n || (n.update(t), e === m.PositionKind && this._updateBoundingInfo(r, t), this._notifyUpdate(e));
  }, i.prototype._updateBoundingInfo = function(e, t) {
    if (e && this._updateExtend(t), this._resetPointsArrayCache(), e)
      for (var r = this._meshes, n = 0, a = r; n < a.length; n++) {
        var s = a[n];
        s.hasBoundingInfo ? s.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum) : s.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
        for (var o = s.subMeshes, u = 0, f = o; u < f.length; u++) {
          var l = f[u];
          l.refreshBoundingInfo();
        }
      }
  }, i.prototype._bind = function(e, t, r, n) {
    if (!!e) {
      t === void 0 && (t = this._indexBuffer);
      var a = this.getVertexBuffers();
      if (!!a) {
        if (t != this._indexBuffer || !this._vertexArrayObjects && !n) {
          this._engine.bindBuffers(a, t, e, r);
          return;
        }
        var s = n || this._vertexArrayObjects;
        s[e.key] || (s[e.key] = this._engine.recordVertexArrayObject(a, t, e, r)), this._engine.bindVertexArrayObject(s[e.key], t);
      }
    }
  }, i.prototype.getTotalVertices = function() {
    return this.isReady() ? this._totalVertices : 0;
  }, i.prototype.getVerticesData = function(e, t, r) {
    var n = this.getVertexBuffer(e);
    return n ? n.getFloatData(this._totalVertices, r || t && this._meshes.length !== 1) : null;
  }, i.prototype.isVertexBufferUpdatable = function(e) {
    var t = this._vertexBuffers[e];
    return t ? t.isUpdatable() : !1;
  }, i.prototype.getVertexBuffer = function(e) {
    return this.isReady() ? this._vertexBuffers[e] : null;
  }, i.prototype.getVertexBuffers = function() {
    return this.isReady() ? this._vertexBuffers : null;
  }, i.prototype.isVerticesDataPresent = function(e) {
    return this._vertexBuffers ? this._vertexBuffers[e] !== void 0 : this._delayInfo ? this._delayInfo.indexOf(e) !== -1 : !1;
  }, i.prototype.getVerticesDataKinds = function() {
    var e = [], t;
    if (!this._vertexBuffers && this._delayInfo)
      for (t in this._delayInfo)
        e.push(t);
    else
      for (t in this._vertexBuffers)
        e.push(t);
    return e;
  }, i.prototype.updateIndices = function(e, t, r) {
    if (r === void 0 && (r = !1), !!this._indexBuffer)
      if (!this._indexBufferIsUpdatable)
        this.setIndices(e, null, !0);
      else {
        var n = e.length !== this._indices.length;
        if (r || (this._indices = e.slice()), this._engine.updateDynamicIndexBuffer(this._indexBuffer, e, t), n)
          for (var a = 0, s = this._meshes; a < s.length; a++) {
            var o = s[a];
            o._createGlobalSubMesh(!0);
          }
      }
  }, i.prototype.setIndices = function(e, t, r) {
    t === void 0 && (t = null), r === void 0 && (r = !1), this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indices = e, this._indexBufferIsUpdatable = r, this._meshes.length !== 0 && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, r)), t != null && (this._totalVertices = t);
    for (var n = 0, a = this._meshes; n < a.length; n++) {
      var s = a[n];
      s._createGlobalSubMesh(!0), s.synchronizeInstances();
    }
    this._notifyUpdate();
  }, i.prototype.getTotalIndices = function() {
    return this.isReady() ? this._indices.length : 0;
  }, i.prototype.getIndices = function(e, t) {
    if (!this.isReady())
      return null;
    var r = this._indices;
    return !t && (!e || this._meshes.length === 1) ? r : r.slice();
  }, i.prototype.getIndexBuffer = function() {
    return this.isReady() ? this._indexBuffer : null;
  }, i.prototype._releaseVertexArrayObject = function(e) {
    e === void 0 && (e = null), !(!e || !this._vertexArrayObjects) && this._vertexArrayObjects[e.key] && (this._engine.releaseVertexArrayObject(this._vertexArrayObjects[e.key]), delete this._vertexArrayObjects[e.key]);
  }, i.prototype.releaseForMesh = function(e, t) {
    var r = this._meshes, n = r.indexOf(e);
    n !== -1 && (r.splice(n, 1), this._vertexArrayObjects && e._invalidateInstanceVertexArrayObject(), e._geometry = null, r.length === 0 && t && this.dispose());
  }, i.prototype.applyToMesh = function(e) {
    if (e._geometry !== this) {
      var t = e._geometry;
      t && t.releaseForMesh(e), this._vertexArrayObjects && e._invalidateInstanceVertexArrayObject();
      var r = this._meshes;
      e._geometry = this, e._internalAbstractMeshDataInfo._positions = null, this._scene.pushGeometry(this), r.push(e), this.isReady() ? this._applyToMesh(e) : this._boundingInfo && e.setBoundingInfo(this._boundingInfo);
    }
  }, i.prototype._updateExtend = function(e) {
    if (e === void 0 && (e = null), this.useBoundingInfoFromGeometry && this._boundingInfo)
      this._extend = {
        minimum: this._boundingInfo.minimum.clone(),
        maximum: this._boundingInfo.maximum.clone()
      };
    else {
      if (!e && (e = this.getVerticesData(m.PositionKind), !e))
        return;
      this._extend = dn(e, 0, this._totalVertices, this.boundingBias, 3);
    }
  }, i.prototype._applyToMesh = function(e) {
    var t = this._meshes.length;
    for (var r in this._vertexBuffers)
      t === 1 && this._vertexBuffers[r].create(), r === m.PositionKind && (this._extend || this._updateExtend(), e.buildBoundingInfo(this._extend.minimum, this._extend.maximum), e._createGlobalSubMesh(e.isUnIndexed), e._updateBoundingInfo());
    t === 1 && this._indices && this._indices.length > 0 && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable)), e._syncGeometryWithMorphTargetManager(), e.synchronizeInstances();
  }, i.prototype._notifyUpdate = function(e) {
    this.onGeometryUpdated && this.onGeometryUpdated(this, e), this._vertexArrayObjects && this._disposeVertexArrayObjects();
    for (var t = 0, r = this._meshes; t < r.length; t++) {
      var n = r[t];
      n._markSubMeshesAsAttributesDirty();
    }
  }, i.prototype.load = function(e, t) {
    if (this.delayLoadState !== 2) {
      if (this.isReady()) {
        t && t();
        return;
      }
      this.delayLoadState = 2, this._queueLoad(e, t);
    }
  }, i.prototype._queueLoad = function(e, t) {
    var r = this;
    !this.delayLoadingFile || (e._addPendingData(this), e._loadFile(this.delayLoadingFile, function(n) {
      if (!!r._delayLoadingFunction) {
        r._delayLoadingFunction(JSON.parse(n), r), r.delayLoadState = 1, r._delayInfo = [], e._removePendingData(r);
        for (var a = r._meshes, s = a.length, o = 0; o < s; o++)
          r._applyToMesh(a[o]);
        t && t();
      }
    }, void 0, !0));
  }, i.prototype.toLeftHanded = function() {
    var e = this.getIndices(!1);
    if (e != null && e.length > 0) {
      for (var t = 0; t < e.length; t += 3) {
        var r = e[t + 0];
        e[t + 0] = e[t + 2], e[t + 2] = r;
      }
      this.setIndices(e);
    }
    var n = this.getVerticesData(m.PositionKind, !1);
    if (n != null && n.length > 0) {
      for (var t = 0; t < n.length; t += 3)
        n[t + 2] = -n[t + 2];
      this.setVerticesData(m.PositionKind, n, !1);
    }
    var a = this.getVerticesData(m.NormalKind, !1);
    if (a != null && a.length > 0) {
      for (var t = 0; t < a.length; t += 3)
        a[t + 2] = -a[t + 2];
      this.setVerticesData(m.NormalKind, a, !1);
    }
  }, i.prototype._resetPointsArrayCache = function() {
    this._positions = null;
  }, i.prototype._generatePointsArray = function() {
    if (this._positions)
      return !0;
    var e = this.getVerticesData(m.PositionKind);
    if (!e || e.length === 0)
      return !1;
    for (var t = this._positionsCache.length * 3, r = this._positionsCache.length; t < e.length; t += 3, ++r)
      this._positionsCache[r] = b.FromArray(e, t);
    for (var t = 0, r = 0; t < e.length; t += 3, ++r)
      this._positionsCache[r].set(e[0 + t], e[1 + t], e[2 + t]);
    return this._positionsCache.length = e.length / 3, this._positions = this._positionsCache, !0;
  }, i.prototype.isDisposed = function() {
    return this._isDisposed;
  }, i.prototype._disposeVertexArrayObjects = function() {
    if (this._vertexArrayObjects) {
      for (var e in this._vertexArrayObjects)
        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[e]);
      this._vertexArrayObjects = {};
      for (var t = this._meshes, r = t.length, n = 0; n < r; n++)
        t[n]._invalidateInstanceVertexArrayObject();
    }
  }, i.prototype.dispose = function() {
    var e = this._meshes, t = e.length, r;
    for (r = 0; r < t; r++)
      this.releaseForMesh(e[r]);
    this._meshes = [], this._disposeVertexArrayObjects();
    for (var n in this._vertexBuffers)
      this._vertexBuffers[n].dispose();
    if (this._vertexBuffers = {}, this._totalVertices = 0, this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indexBuffer = null, this._indices = [], this.delayLoadState = 0, this.delayLoadingFile = null, this._delayLoadingFunction = null, this._delayInfo = [], this._boundingInfo = null, this._scene.removeGeometry(this), this._parentContainer) {
      var a = this._parentContainer.geometries.indexOf(this);
      a > -1 && this._parentContainer.geometries.splice(a, 1), this._parentContainer = null;
    }
    this._isDisposed = !0;
  }, i.prototype.copy = function(e) {
    var t = new _e();
    t.indices = [];
    var r = this.getIndices();
    if (r)
      for (var n = 0; n < r.length; n++)
        t.indices.push(r[n]);
    var a = !1, s = !1, o;
    for (o in this._vertexBuffers) {
      var u = this.getVerticesData(o);
      if (u && (u instanceof Float32Array ? t.set(new Float32Array(u), o) : t.set(u.slice(0), o), !s)) {
        var f = this.getVertexBuffer(o);
        f && (a = f.isUpdatable(), s = !a);
      }
    }
    var l = new i(e, this._scene, t, a);
    l.delayLoadState = this.delayLoadState, l.delayLoadingFile = this.delayLoadingFile, l._delayLoadingFunction = this._delayLoadingFunction;
    for (o in this._delayInfo)
      l._delayInfo = l._delayInfo || [], l._delayInfo.push(o);
    return l._boundingInfo = new Et(this._extend.minimum, this._extend.maximum), l;
  }, i.prototype.serialize = function() {
    var e = {};
    return e.id = this.id, e.uniqueId = this.uniqueId, e.updatable = this._updatable, le && le.HasTags(this) && (e.tags = le.GetTags(this)), e;
  }, i.prototype._toNumberArray = function(e) {
    return Array.isArray(e) ? e : Array.prototype.slice.call(e);
  }, i.prototype.clearCachedData = function() {
    this._indices = [], this._resetPointsArrayCache();
    for (var e in this._vertexBuffers)
      !Object.prototype.hasOwnProperty.call(this._vertexBuffers, e) || (this._vertexBuffers[e]._buffer._data = null);
  }, i.prototype.serializeVerticeData = function() {
    var e = this.serialize();
    return this.isVerticesDataPresent(m.PositionKind) && (e.positions = this._toNumberArray(this.getVerticesData(m.PositionKind)), this.isVertexBufferUpdatable(m.PositionKind) && (e.positions._updatable = !0)), this.isVerticesDataPresent(m.NormalKind) && (e.normals = this._toNumberArray(this.getVerticesData(m.NormalKind)), this.isVertexBufferUpdatable(m.NormalKind) && (e.normals._updatable = !0)), this.isVerticesDataPresent(m.TangentKind) && (e.tangents = this._toNumberArray(this.getVerticesData(m.TangentKind)), this.isVertexBufferUpdatable(m.TangentKind) && (e.tangents._updatable = !0)), this.isVerticesDataPresent(m.UVKind) && (e.uvs = this._toNumberArray(this.getVerticesData(m.UVKind)), this.isVertexBufferUpdatable(m.UVKind) && (e.uvs._updatable = !0)), this.isVerticesDataPresent(m.UV2Kind) && (e.uv2s = this._toNumberArray(this.getVerticesData(m.UV2Kind)), this.isVertexBufferUpdatable(m.UV2Kind) && (e.uv2s._updatable = !0)), this.isVerticesDataPresent(m.UV3Kind) && (e.uv3s = this._toNumberArray(this.getVerticesData(m.UV3Kind)), this.isVertexBufferUpdatable(m.UV3Kind) && (e.uv3s._updatable = !0)), this.isVerticesDataPresent(m.UV4Kind) && (e.uv4s = this._toNumberArray(this.getVerticesData(m.UV4Kind)), this.isVertexBufferUpdatable(m.UV4Kind) && (e.uv4s._updatable = !0)), this.isVerticesDataPresent(m.UV5Kind) && (e.uv5s = this._toNumberArray(this.getVerticesData(m.UV5Kind)), this.isVertexBufferUpdatable(m.UV5Kind) && (e.uv5s._updatable = !0)), this.isVerticesDataPresent(m.UV6Kind) && (e.uv6s = this._toNumberArray(this.getVerticesData(m.UV6Kind)), this.isVertexBufferUpdatable(m.UV6Kind) && (e.uv6s._updatable = !0)), this.isVerticesDataPresent(m.ColorKind) && (e.colors = this._toNumberArray(this.getVerticesData(m.ColorKind)), this.isVertexBufferUpdatable(m.ColorKind) && (e.colors._updatable = !0)), this.isVerticesDataPresent(m.MatricesIndicesKind) && (e.matricesIndices = this._toNumberArray(this.getVerticesData(m.MatricesIndicesKind)), e.matricesIndices._isExpanded = !0, this.isVertexBufferUpdatable(m.MatricesIndicesKind) && (e.matricesIndices._updatable = !0)), this.isVerticesDataPresent(m.MatricesWeightsKind) && (e.matricesWeights = this._toNumberArray(this.getVerticesData(m.MatricesWeightsKind)), this.isVertexBufferUpdatable(m.MatricesWeightsKind) && (e.matricesWeights._updatable = !0)), e.indices = this._toNumberArray(this.getIndices()), e;
  }, i.ExtractFromMesh = function(e, t) {
    var r = e._geometry;
    return r ? r.copy(t) : null;
  }, i.RandomId = function() {
    return de.RandomId();
  }, i._GetGeometryByLoadedUniqueId = function(e, t) {
    for (var r = 0; r < t.geometries.length; r++)
      if (t.geometries[r]._loadedUniqueId === e)
        return t.geometries[r];
    return null;
  }, i._ImportGeometry = function(e, t) {
    var r = t.getScene(), n = e.geometryUniqueId, a = e.geometryId;
    if (n || a) {
      var s = n ? this._GetGeometryByLoadedUniqueId(n, r) : r.getGeometryById(a);
      s && s.applyToMesh(t);
    } else if (e instanceof ArrayBuffer) {
      var o = t._binaryInfo;
      if (o.positionsAttrDesc && o.positionsAttrDesc.count > 0) {
        var u = new Float32Array(e, o.positionsAttrDesc.offset, o.positionsAttrDesc.count);
        t.setVerticesData(m.PositionKind, u, !1);
      }
      if (o.normalsAttrDesc && o.normalsAttrDesc.count > 0) {
        var f = new Float32Array(e, o.normalsAttrDesc.offset, o.normalsAttrDesc.count);
        t.setVerticesData(m.NormalKind, f, !1);
      }
      if (o.tangetsAttrDesc && o.tangetsAttrDesc.count > 0) {
        var l = new Float32Array(e, o.tangetsAttrDesc.offset, o.tangetsAttrDesc.count);
        t.setVerticesData(m.TangentKind, l, !1);
      }
      if (o.uvsAttrDesc && o.uvsAttrDesc.count > 0) {
        var h = new Float32Array(e, o.uvsAttrDesc.offset, o.uvsAttrDesc.count);
        if (Ye.UseOpenGLOrientationForUV)
          for (var c = 1; c < h.length; c += 2)
            h[c] = 1 - h[c];
        t.setVerticesData(m.UVKind, h, !1);
      }
      if (o.uvs2AttrDesc && o.uvs2AttrDesc.count > 0) {
        var d = new Float32Array(e, o.uvs2AttrDesc.offset, o.uvs2AttrDesc.count);
        if (Ye.UseOpenGLOrientationForUV)
          for (var c = 1; c < d.length; c += 2)
            d[c] = 1 - d[c];
        t.setVerticesData(m.UV2Kind, d, !1);
      }
      if (o.uvs3AttrDesc && o.uvs3AttrDesc.count > 0) {
        var p = new Float32Array(e, o.uvs3AttrDesc.offset, o.uvs3AttrDesc.count);
        if (Ye.UseOpenGLOrientationForUV)
          for (var c = 1; c < p.length; c += 2)
            p[c] = 1 - p[c];
        t.setVerticesData(m.UV3Kind, p, !1);
      }
      if (o.uvs4AttrDesc && o.uvs4AttrDesc.count > 0) {
        var g = new Float32Array(e, o.uvs4AttrDesc.offset, o.uvs4AttrDesc.count);
        if (Ye.UseOpenGLOrientationForUV)
          for (var c = 1; c < g.length; c += 2)
            g[c] = 1 - g[c];
        t.setVerticesData(m.UV4Kind, g, !1);
      }
      if (o.uvs5AttrDesc && o.uvs5AttrDesc.count > 0) {
        var _ = new Float32Array(e, o.uvs5AttrDesc.offset, o.uvs5AttrDesc.count);
        if (Ye.UseOpenGLOrientationForUV)
          for (var c = 1; c < _.length; c += 2)
            _[c] = 1 - _[c];
        t.setVerticesData(m.UV5Kind, _, !1);
      }
      if (o.uvs6AttrDesc && o.uvs6AttrDesc.count > 0) {
        var v = new Float32Array(e, o.uvs6AttrDesc.offset, o.uvs6AttrDesc.count);
        if (Ye.UseOpenGLOrientationForUV)
          for (var c = 1; c < v.length; c += 2)
            v[c] = 1 - v[c];
        t.setVerticesData(m.UV6Kind, v, !1);
      }
      if (o.colorsAttrDesc && o.colorsAttrDesc.count > 0) {
        var y = new Float32Array(e, o.colorsAttrDesc.offset, o.colorsAttrDesc.count);
        t.setVerticesData(m.ColorKind, y, !1, o.colorsAttrDesc.stride);
      }
      if (o.matricesIndicesAttrDesc && o.matricesIndicesAttrDesc.count > 0) {
        for (var E = new Int32Array(e, o.matricesIndicesAttrDesc.offset, o.matricesIndicesAttrDesc.count), R = [], M = 0; M < E.length; M++) {
          var c = E[M];
          R.push(c & 255), R.push((c & 65280) >> 8), R.push((c & 16711680) >> 16), R.push(c >> 24 & 255);
        }
        t.setVerticesData(m.MatricesIndicesKind, R, !1);
      }
      if (o.matricesIndicesExtraAttrDesc && o.matricesIndicesExtraAttrDesc.count > 0) {
        for (var E = new Int32Array(e, o.matricesIndicesExtraAttrDesc.offset, o.matricesIndicesExtraAttrDesc.count), R = [], M = 0; M < E.length; M++) {
          var c = E[M];
          R.push(c & 255), R.push((c & 65280) >> 8), R.push((c & 16711680) >> 16), R.push(c >> 24 & 255);
        }
        t.setVerticesData(m.MatricesIndicesExtraKind, R, !1);
      }
      if (o.matricesWeightsAttrDesc && o.matricesWeightsAttrDesc.count > 0) {
        var C = new Float32Array(e, o.matricesWeightsAttrDesc.offset, o.matricesWeightsAttrDesc.count);
        t.setVerticesData(m.MatricesWeightsKind, C, !1);
      }
      if (o.indicesAttrDesc && o.indicesAttrDesc.count > 0) {
        var A = new Int32Array(e, o.indicesAttrDesc.offset, o.indicesAttrDesc.count);
        t.setIndices(A, null);
      }
      if (o.subMeshesAttrDesc && o.subMeshesAttrDesc.count > 0) {
        var S = new Int32Array(e, o.subMeshesAttrDesc.offset, o.subMeshesAttrDesc.count * 5);
        t.subMeshes = [];
        for (var M = 0; M < o.subMeshesAttrDesc.count; M++) {
          var w = S[M * 5 + 0], F = S[M * 5 + 1], x = S[M * 5 + 2], z = S[M * 5 + 3], W = S[M * 5 + 4];
          mt.AddToMesh(w, F, x, z, W, t);
        }
      }
    } else if (e.positions && e.normals && e.indices) {
      if (t.setVerticesData(m.PositionKind, e.positions, e.positions._updatable), t.setVerticesData(m.NormalKind, e.normals, e.normals._updatable), e.tangents && t.setVerticesData(m.TangentKind, e.tangents, e.tangents._updatable), e.uvs && t.setVerticesData(m.UVKind, e.uvs, e.uvs._updatable), e.uvs2 && t.setVerticesData(m.UV2Kind, e.uvs2, e.uvs2._updatable), e.uvs3 && t.setVerticesData(m.UV3Kind, e.uvs3, e.uvs3._updatable), e.uvs4 && t.setVerticesData(m.UV4Kind, e.uvs4, e.uvs4._updatable), e.uvs5 && t.setVerticesData(m.UV5Kind, e.uvs5, e.uvs5._updatable), e.uvs6 && t.setVerticesData(m.UV6Kind, e.uvs6, e.uvs6._updatable), e.colors && t.setVerticesData(m.ColorKind, be.CheckColors4(e.colors, e.positions.length / 3), e.colors._updatable), e.matricesIndices)
        if (e.matricesIndices._isExpanded)
          delete e.matricesIndices._isExpanded, t.setVerticesData(m.MatricesIndicesKind, e.matricesIndices, e.matricesIndices._updatable);
        else {
          for (var R = [], M = 0; M < e.matricesIndices.length; M++) {
            var N = e.matricesIndices[M];
            R.push(N & 255), R.push((N & 65280) >> 8), R.push((N & 16711680) >> 16), R.push(N >> 24 & 255);
          }
          t.setVerticesData(m.MatricesIndicesKind, R, e.matricesIndices._updatable);
        }
      if (e.matricesIndicesExtra)
        if (e.matricesIndicesExtra._isExpanded)
          delete e.matricesIndices._isExpanded, t.setVerticesData(m.MatricesIndicesExtraKind, e.matricesIndicesExtra, e.matricesIndicesExtra._updatable);
        else {
          for (var R = [], M = 0; M < e.matricesIndicesExtra.length; M++) {
            var N = e.matricesIndicesExtra[M];
            R.push(N & 255), R.push((N & 65280) >> 8), R.push((N & 16711680) >> 16), R.push(N >> 24 & 255);
          }
          t.setVerticesData(m.MatricesIndicesExtraKind, R, e.matricesIndicesExtra._updatable);
        }
      e.matricesWeights && (i._CleanMatricesWeights(e, t), t.setVerticesData(m.MatricesWeightsKind, e.matricesWeights, e.matricesWeights._updatable)), e.matricesWeightsExtra && t.setVerticesData(m.MatricesWeightsExtraKind, e.matricesWeightsExtra, e.matricesWeights._updatable), t.setIndices(e.indices, null);
    }
    if (e.subMeshes) {
      t.subMeshes = [];
      for (var Z = 0; Z < e.subMeshes.length; Z++) {
        var q = e.subMeshes[Z];
        mt.AddToMesh(q.materialIndex, q.verticesStart, q.verticesCount, q.indexStart, q.indexCount, t);
      }
    }
    t._shouldGenerateFlatShading && (t.convertToFlatShadedMesh(), t._shouldGenerateFlatShading = !1), t.computeWorldMatrix(!0), r.onMeshImportedObservable.notifyObservers(t);
  }, i._CleanMatricesWeights = function(e, t) {
    var r = 1e-3;
    if (!!tt.CleanBoneMatrixWeights) {
      var n = 0;
      if (e.skeletonId > -1) {
        var a = t.getScene().getLastSkeletonById(e.skeletonId);
        if (!a)
          return;
        n = a.bones.length;
      } else
        return;
      for (var s = t.getVerticesData(m.MatricesIndicesKind), o = t.getVerticesData(m.MatricesIndicesExtraKind), u = e.matricesWeights, f = e.matricesWeightsExtra, l = e.numBoneInfluencer, h = u.length, c = 0; c < h; c += 4) {
        for (var d = 0, p = -1, g = 0; g < 4; g++) {
          var _ = u[c + g];
          d += _, _ < r && p < 0 && (p = g);
        }
        if (f)
          for (var g = 0; g < 4; g++) {
            var _ = f[c + g];
            d += _, _ < r && p < 0 && (p = g + 4);
          }
        if ((p < 0 || p > l - 1) && (p = l - 1), d > r) {
          for (var v = 1 / d, g = 0; g < 4; g++)
            u[c + g] *= v;
          if (f)
            for (var g = 0; g < 4; g++)
              f[c + g] *= v;
        } else
          p >= 4 ? (f[c + p - 4] = 1 - d, o[c + p - 4] = n) : (u[c + p] = 1 - d, s[c + p] = n);
      }
      t.setVerticesData(m.MatricesIndicesKind, s), e.matricesWeightsExtra && t.setVerticesData(m.MatricesIndicesExtraKind, o);
    }
  }, i.Parse = function(e, t, r) {
    var n = new i(e.id, t, void 0, e.updatable);
    return n._loadedUniqueId = e.uniqueId, le && le.AddTagsTo(n, e.tags), e.delayLoadingFile ? (n.delayLoadState = 4, n.delayLoadingFile = r + e.delayLoadingFile, n._boundingInfo = new Et(b.FromArray(e.boundingBoxMinimum), b.FromArray(e.boundingBoxMaximum)), n._delayInfo = [], e.hasUVs && n._delayInfo.push(m.UVKind), e.hasUVs2 && n._delayInfo.push(m.UV2Kind), e.hasUVs3 && n._delayInfo.push(m.UV3Kind), e.hasUVs4 && n._delayInfo.push(m.UV4Kind), e.hasUVs5 && n._delayInfo.push(m.UV5Kind), e.hasUVs6 && n._delayInfo.push(m.UV6Kind), e.hasColors && n._delayInfo.push(m.ColorKind), e.hasMatricesIndices && n._delayInfo.push(m.MatricesIndicesKind), e.hasMatricesWeights && n._delayInfo.push(m.MatricesWeightsKind), n._delayLoadingFunction = _e.ImportVertexData) : _e.ImportVertexData(e, n), t.pushGeometry(n, !0), n;
  }, i;
}(), ht;
(function(i) {
  i[i.LOCAL = 0] = "LOCAL", i[i.WORLD = 1] = "WORLD", i[i.BONE = 2] = "BONE";
})(ht || (ht = {}));
var Cr = function() {
  function i() {
  }
  return i.X = new b(1, 0, 0), i.Y = new b(0, 1, 0), i.Z = new b(0, 0, 1), i;
}(), zi;
(function(i) {
  i[i.X = 0] = "X", i[i.Y = 1] = "Y", i[i.Z = 2] = "Z";
})(zi || (zi = {}));
var Ze = function(i) {
  K(e, i);
  function e(t, r, n) {
    r === void 0 && (r = null), n === void 0 && (n = !0);
    var a = i.call(this, t, r) || this;
    return a._forward = new b(0, 0, 1), a._up = new b(0, 1, 0), a._right = new b(1, 0, 0), a._position = b.Zero(), a._rotation = b.Zero(), a._rotationQuaternion = null, a._scaling = b.One(), a._transformToBoneReferal = null, a._isAbsoluteSynced = !1, a._billboardMode = e.BILLBOARDMODE_NONE, a._preserveParentRotationForBillboard = !1, a.scalingDeterminant = 1, a._infiniteDistance = !1, a.ignoreNonUniformScaling = !1, a.reIntegrateRotationIntoRotationQuaternion = !1, a._poseMatrix = null, a._localMatrix = I.Zero(), a._usePivotMatrix = !1, a._absolutePosition = b.Zero(), a._absoluteScaling = b.Zero(), a._absoluteRotationQuaternion = ie.Identity(), a._pivotMatrix = I.Identity(), a._postMultiplyPivotMatrix = !1, a._isWorldMatrixFrozen = !1, a._indexInSceneTransformNodesArray = -1, a.onAfterWorldMatrixUpdateObservable = new O(), a._nonUniformScaling = !1, n && a.getScene().addTransformNode(a), a;
  }
  return Object.defineProperty(e.prototype, "billboardMode", {
    get: function() {
      return this._billboardMode;
    },
    set: function(t) {
      this._billboardMode !== t && (this._billboardMode = t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "preserveParentRotationForBillboard", {
    get: function() {
      return this._preserveParentRotationForBillboard;
    },
    set: function(t) {
      t !== this._preserveParentRotationForBillboard && (this._preserveParentRotationForBillboard = t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "infiniteDistance", {
    get: function() {
      return this._infiniteDistance;
    },
    set: function(t) {
      this._infiniteDistance !== t && (this._infiniteDistance = t);
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getClassName = function() {
    return "TransformNode";
  }, Object.defineProperty(e.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(t) {
      this._position = t, this._isDirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.isUsingPivotMatrix = function() {
    return this._usePivotMatrix;
  }, Object.defineProperty(e.prototype, "rotation", {
    get: function() {
      return this._rotation;
    },
    set: function(t) {
      this._rotation = t, this._rotationQuaternion = null, this._isDirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "scaling", {
    get: function() {
      return this._scaling;
    },
    set: function(t) {
      this._scaling = t, this._isDirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "rotationQuaternion", {
    get: function() {
      return this._rotationQuaternion;
    },
    set: function(t) {
      this._rotationQuaternion = t, t && this._rotation.setAll(0), this._isDirty = !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "forward", {
    get: function() {
      return b.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1 : 1, this.getWorldMatrix(), this._forward), this._forward.normalize();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "up", {
    get: function() {
      return b.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up), this._up.normalize();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "right", {
    get: function() {
      return b.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1 : 1, 0, 0, this.getWorldMatrix(), this._right), this._right.normalize();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.updatePoseMatrix = function(t) {
    return this._poseMatrix ? (this._poseMatrix.copyFrom(t), this) : (this._poseMatrix = t.clone(), this);
  }, e.prototype.getPoseMatrix = function() {
    return this._poseMatrix || (this._poseMatrix = I.Identity()), this._poseMatrix;
  }, e.prototype._isSynchronized = function() {
    var t = this._cache;
    return !(this._billboardMode !== t.billboardMode || this._billboardMode !== e.BILLBOARDMODE_NONE || t.pivotMatrixUpdated || this._infiniteDistance || this._position._isDirty || this._scaling._isDirty || this._rotationQuaternion && this._rotationQuaternion._isDirty || this._rotation._isDirty);
  }, e.prototype._initCache = function() {
    i.prototype._initCache.call(this);
    var t = this._cache;
    t.localMatrixUpdated = !1, t.billboardMode = -1, t.infiniteDistance = !1;
  }, Object.defineProperty(e.prototype, "absolutePosition", {
    get: function() {
      return this.getAbsolutePosition();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "absoluteScaling", {
    get: function() {
      return this._syncAbsoluteScalingAndRotation(), this._absoluteScaling;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "absoluteRotationQuaternion", {
    get: function() {
      return this._syncAbsoluteScalingAndRotation(), this._absoluteRotationQuaternion;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.setPreTransformMatrix = function(t) {
    return this.setPivotMatrix(t, !1);
  }, e.prototype.setPivotMatrix = function(t, r) {
    return r === void 0 && (r = !0), this._pivotMatrix.copyFrom(t), this._usePivotMatrix = !this._pivotMatrix.isIdentity(), this._cache.pivotMatrixUpdated = !0, this._postMultiplyPivotMatrix = r, this._postMultiplyPivotMatrix && (this._pivotMatrixInverse ? this._pivotMatrix.invertToRef(this._pivotMatrixInverse) : this._pivotMatrixInverse = I.Invert(this._pivotMatrix)), this;
  }, e.prototype.getPivotMatrix = function() {
    return this._pivotMatrix;
  }, e.prototype.instantiateHierarchy = function(t, r, n) {
    t === void 0 && (t = null);
    var a = this.clone("Clone of " + (this.name || this.id), t || this.parent, !0);
    a && n && n(this, a);
    for (var s = 0, o = this.getChildTransformNodes(!0); s < o.length; s++) {
      var u = o[s];
      u.instantiateHierarchy(a, r, n);
    }
    return a;
  }, e.prototype.freezeWorldMatrix = function(t, r) {
    return t === void 0 && (t = null), r === void 0 && (r = !1), t ? r ? (this._rotation.setAll(0), this._rotationQuaternion = this._rotationQuaternion || ie.Identity(), t.decompose(this._scaling, this._rotationQuaternion, this._position), this.computeWorldMatrix(!0)) : (this._worldMatrix = t, this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]), this._afterComputeWorldMatrix()) : (this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0)), this._isDirty = !1, this._isWorldMatrixFrozen = !0, this;
  }, e.prototype.unfreezeWorldMatrix = function() {
    return this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0), this;
  }, Object.defineProperty(e.prototype, "isWorldMatrixFrozen", {
    get: function() {
      return this._isWorldMatrixFrozen;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getAbsolutePosition = function() {
    return this.computeWorldMatrix(), this._absolutePosition;
  }, e.prototype.setAbsolutePosition = function(t) {
    if (!t)
      return this;
    var r, n, a;
    if (t.x === void 0) {
      if (arguments.length < 3)
        return this;
      r = arguments[0], n = arguments[1], a = arguments[2];
    } else
      r = t.x, n = t.y, a = t.z;
    if (this.parent) {
      var s = D.Matrix[0];
      this.parent.getWorldMatrix().invertToRef(s), b.TransformCoordinatesFromFloatsToRef(r, n, a, s, this.position);
    } else
      this.position.x = r, this.position.y = n, this.position.z = a;
    return this._absolutePosition.copyFrom(t), this;
  }, e.prototype.setPositionWithLocalVector = function(t) {
    return this.computeWorldMatrix(), this.position = b.TransformNormal(t, this._localMatrix), this;
  }, e.prototype.getPositionExpressedInLocalSpace = function() {
    this.computeWorldMatrix();
    var t = D.Matrix[0];
    return this._localMatrix.invertToRef(t), b.TransformNormal(this.position, t);
  }, e.prototype.locallyTranslate = function(t) {
    return this.computeWorldMatrix(!0), this.position = b.TransformCoordinates(t, this._localMatrix), this;
  }, e.prototype.lookAt = function(t, r, n, a, s) {
    r === void 0 && (r = 0), n === void 0 && (n = 0), a === void 0 && (a = 0), s === void 0 && (s = ht.LOCAL);
    var o = e._LookAtVectorCache, u = s === ht.LOCAL ? this.position : this.getAbsolutePosition();
    if (t.subtractToRef(u, o), this.setDirection(o, r, n, a), s === ht.WORLD && this.parent)
      if (this.rotationQuaternion) {
        var f = D.Matrix[0];
        this.rotationQuaternion.toRotationMatrix(f);
        var l = D.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(l), l.invert(), f.multiplyToRef(l, f), this.rotationQuaternion.fromRotationMatrix(f);
      } else {
        var h = D.Quaternion[0];
        ie.FromEulerVectorToRef(this.rotation, h);
        var f = D.Matrix[0];
        h.toRotationMatrix(f);
        var l = D.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(l), l.invert(), f.multiplyToRef(l, f), h.fromRotationMatrix(f), h.toEulerAnglesToRef(this.rotation);
      }
    return this;
  }, e.prototype.getDirection = function(t) {
    var r = b.Zero();
    return this.getDirectionToRef(t, r), r;
  }, e.prototype.getDirectionToRef = function(t, r) {
    return b.TransformNormalToRef(t, this.getWorldMatrix(), r), this;
  }, e.prototype.setDirection = function(t, r, n, a) {
    r === void 0 && (r = 0), n === void 0 && (n = 0), a === void 0 && (a = 0);
    var s = -Math.atan2(t.z, t.x) + Math.PI / 2, o = Math.sqrt(t.x * t.x + t.z * t.z), u = -Math.atan2(t.y, o);
    return this.rotationQuaternion ? ie.RotationYawPitchRollToRef(s + r, u + n, a, this.rotationQuaternion) : (this.rotation.x = u + n, this.rotation.y = s + r, this.rotation.z = a), this;
  }, e.prototype.setPivotPoint = function(t, r) {
    r === void 0 && (r = ht.LOCAL), this.getScene().getRenderId() == 0 && this.computeWorldMatrix(!0);
    var n = this.getWorldMatrix();
    if (r == ht.WORLD) {
      var a = D.Matrix[0];
      n.invertToRef(a), t = b.TransformCoordinates(t, a);
    }
    return this.setPivotMatrix(I.Translation(-t.x, -t.y, -t.z), !0);
  }, e.prototype.getPivotPoint = function() {
    var t = b.Zero();
    return this.getPivotPointToRef(t), t;
  }, e.prototype.getPivotPointToRef = function(t) {
    return t.x = -this._pivotMatrix.m[12], t.y = -this._pivotMatrix.m[13], t.z = -this._pivotMatrix.m[14], this;
  }, e.prototype.getAbsolutePivotPoint = function() {
    var t = b.Zero();
    return this.getAbsolutePivotPointToRef(t), t;
  }, e.prototype.getAbsolutePivotPointToRef = function(t) {
    return this.getPivotPointToRef(t), b.TransformCoordinatesToRef(t, this.getWorldMatrix(), t), this;
  }, e.prototype.markAsDirty = function(t) {
    if (this._children)
      for (var r = 0, n = this._children; r < n.length; r++) {
        var a = n[r];
        a.markAsDirty(t);
      }
    return i.prototype.markAsDirty.call(this, t);
  }, e.prototype.setParent = function(t, r) {
    if (r === void 0 && (r = !1), !t && !this.parent)
      return this;
    var n = D.Quaternion[0], a = D.Vector3[0], s = D.Vector3[1], o = D.Matrix[1];
    I.IdentityToRef(o);
    var u = D.Matrix[0];
    this.computeWorldMatrix(!0);
    var f = this.rotationQuaternion;
    return f || (f = e._TmpRotation, ie.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, f)), I.ComposeToRef(this.scaling, f, this.position, u), this.parent && u.multiplyToRef(this.parent.computeWorldMatrix(!0), u), t && (t.computeWorldMatrix(!0).invertToRef(o), u.multiplyToRef(o, u)), u.decompose(s, n, a, r ? this : void 0), this.rotationQuaternion ? this.rotationQuaternion.copyFrom(n) : n.toEulerAnglesToRef(this.rotation), this.scaling.copyFrom(s), this.position.copyFrom(a), this.parent = t, this;
  }, Object.defineProperty(e.prototype, "nonUniformScaling", {
    get: function() {
      return this._nonUniformScaling;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._updateNonUniformScalingState = function(t) {
    return this._nonUniformScaling === t ? !1 : (this._nonUniformScaling = t, !0);
  }, e.prototype.attachToBone = function(t, r) {
    return this._currentParentWhenAttachingToBone = this.parent, this._transformToBoneReferal = r, this.parent = t, t.getSkeleton().prepare(), t.getWorldMatrix().determinant() < 0 && (this.scalingDeterminant *= -1), this;
  }, e.prototype.detachFromBone = function(t) {
    return t === void 0 && (t = !1), this.parent ? (this.parent.getWorldMatrix().determinant() < 0 && (this.scalingDeterminant *= -1), this._transformToBoneReferal = null, t ? this.parent = this._currentParentWhenAttachingToBone : this.parent = null, this) : (t && (this.parent = this._currentParentWhenAttachingToBone), this);
  }, e.prototype.rotate = function(t, r, n) {
    t.normalize(), this.rotationQuaternion || (this.rotationQuaternion = this.rotation.toQuaternion(), this.rotation.setAll(0));
    var a;
    if (!n || n === ht.LOCAL)
      a = ie.RotationAxisToRef(t, r, e._RotationAxisCache), this.rotationQuaternion.multiplyToRef(a, this.rotationQuaternion);
    else {
      if (this.parent) {
        var s = D.Matrix[0];
        this.parent.getWorldMatrix().invertToRef(s), t = b.TransformNormal(t, s);
      }
      a = ie.RotationAxisToRef(t, r, e._RotationAxisCache), a.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    }
    return this;
  }, e.prototype.rotateAround = function(t, r, n) {
    r.normalize(), this.rotationQuaternion || (this.rotationQuaternion = ie.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z), this.rotation.setAll(0));
    var a = D.Vector3[0], s = D.Vector3[1], o = D.Vector3[2], u = D.Quaternion[0], f = D.Matrix[0], l = D.Matrix[1], h = D.Matrix[2], c = D.Matrix[3];
    return t.subtractToRef(this.position, a), I.TranslationToRef(a.x, a.y, a.z, f), I.TranslationToRef(-a.x, -a.y, -a.z, l), I.RotationAxisToRef(r, n, h), l.multiplyToRef(h, c), c.multiplyToRef(f, c), c.decompose(s, u, o), this.position.addInPlace(o), u.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion), this;
  }, e.prototype.translate = function(t, r, n) {
    var a = t.scale(r);
    if (!n || n === ht.LOCAL) {
      var s = this.getPositionExpressedInLocalSpace().add(a);
      this.setPositionWithLocalVector(s);
    } else
      this.setAbsolutePosition(this.getAbsolutePosition().add(a));
    return this;
  }, e.prototype.addRotation = function(t, r, n) {
    var a;
    this.rotationQuaternion ? a = this.rotationQuaternion : (a = D.Quaternion[1], ie.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, a));
    var s = D.Quaternion[0];
    return ie.RotationYawPitchRollToRef(r, t, n, s), a.multiplyInPlace(s), this.rotationQuaternion || a.toEulerAnglesToRef(this.rotation), this;
  }, e.prototype._getEffectiveParent = function() {
    return this.parent;
  }, e.prototype.computeWorldMatrix = function(t) {
    if (this._isWorldMatrixFrozen && !this._isDirty)
      return this._worldMatrix;
    var r = this.getScene().getRenderId();
    if (!this._isDirty && !t && (this._currentRenderId === r || this.isSynchronized()))
      return this._currentRenderId = r, this._worldMatrix;
    var n = this.getScene().activeCamera, a = (this._billboardMode & e.BILLBOARDMODE_USE_POSITION) !== 0, s = this._billboardMode !== e.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
    this._updateCache();
    var o = this._cache;
    o.pivotMatrixUpdated = !1, o.billboardMode = this.billboardMode, o.infiniteDistance = this.infiniteDistance, o.parent = this._parentNode, this._currentRenderId = r, this._childUpdateId += 1, this._isDirty = !1, this._position._isDirty = !1, this._rotation._isDirty = !1, this._scaling._isDirty = !1;
    var u = this._getEffectiveParent(), f = e._TmpScaling, l = this._position;
    if (this._infiniteDistance && !this.parent && n) {
      var h = n.getWorldMatrix(), c = new b(h.m[12], h.m[13], h.m[14]);
      l = e._TmpTranslation, l.copyFromFloats(this._position.x + c.x, this._position.y + c.y, this._position.z + c.z);
    }
    f.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);
    var d;
    if (this._rotationQuaternion) {
      if (this._rotationQuaternion._isDirty = !1, d = this._rotationQuaternion, this.reIntegrateRotationIntoRotationQuaternion) {
        var p = this.rotation.lengthSquared();
        p && (this._rotationQuaternion.multiplyInPlace(ie.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z)), this._rotation.copyFromFloats(0, 0, 0));
      }
    } else
      d = e._TmpRotation, ie.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, d);
    if (this._usePivotMatrix) {
      var g = D.Matrix[1];
      I.ScalingToRef(f.x, f.y, f.z, g);
      var _ = D.Matrix[0];
      d.toRotationMatrix(_), this._pivotMatrix.multiplyToRef(g, D.Matrix[4]), D.Matrix[4].multiplyToRef(_, this._localMatrix), this._postMultiplyPivotMatrix && this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix), this._localMatrix.addTranslationFromFloats(l.x, l.y, l.z);
    } else
      I.ComposeToRef(f, d, l, this._localMatrix);
    if (u && u.getWorldMatrix) {
      if (t && u.computeWorldMatrix(t), s) {
        this._transformToBoneReferal ? u.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), D.Matrix[7]) : D.Matrix[7].copyFrom(u.getWorldMatrix());
        var v = D.Vector3[5], y = D.Vector3[6];
        D.Matrix[7].decompose(y, void 0, v), I.ScalingToRef(y.x, y.y, y.z, D.Matrix[7]), D.Matrix[7].setTranslation(v), this._localMatrix.multiplyToRef(D.Matrix[7], this._worldMatrix);
      } else
        this._transformToBoneReferal ? (this._localMatrix.multiplyToRef(u.getWorldMatrix(), D.Matrix[6]), D.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix)) : this._localMatrix.multiplyToRef(u.getWorldMatrix(), this._worldMatrix);
      this._markSyncedWithParent();
    } else
      this._worldMatrix.copyFrom(this._localMatrix);
    if (s && n && this.billboardMode && !a) {
      var E = D.Vector3[0];
      if (this._worldMatrix.getTranslationToRef(E), D.Matrix[1].copyFrom(n.getViewMatrix()), D.Matrix[1].setTranslationFromFloats(0, 0, 0), D.Matrix[1].invertToRef(D.Matrix[0]), (this.billboardMode & e.BILLBOARDMODE_ALL) !== e.BILLBOARDMODE_ALL) {
        D.Matrix[0].decompose(void 0, D.Quaternion[0], void 0);
        var R = D.Vector3[1];
        D.Quaternion[0].toEulerAnglesToRef(R), (this.billboardMode & e.BILLBOARDMODE_X) !== e.BILLBOARDMODE_X && (R.x = 0), (this.billboardMode & e.BILLBOARDMODE_Y) !== e.BILLBOARDMODE_Y && (R.y = 0), (this.billboardMode & e.BILLBOARDMODE_Z) !== e.BILLBOARDMODE_Z && (R.z = 0), I.RotationYawPitchRollToRef(R.y, R.x, R.z, D.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0), this._worldMatrix.multiplyToRef(D.Matrix[0], this._worldMatrix), this._worldMatrix.setTranslation(D.Vector3[0]);
    } else if (s && n && this.billboardMode && a) {
      var E = D.Vector3[0];
      this._worldMatrix.getTranslationToRef(E);
      var M = n.globalPosition;
      this._worldMatrix.invertToRef(D.Matrix[1]);
      var C = D.Vector3[1];
      b.TransformCoordinatesToRef(M, D.Matrix[1], C), C.normalize();
      var A = -Math.atan2(C.z, C.x) + Math.PI / 2, p = Math.sqrt(C.x * C.x + C.z * C.z), S = -Math.atan2(C.y, p);
      if (ie.RotationYawPitchRollToRef(A, S, 0, D.Quaternion[0]), (this.billboardMode & e.BILLBOARDMODE_ALL) !== e.BILLBOARDMODE_ALL) {
        var R = D.Vector3[1];
        D.Quaternion[0].toEulerAnglesToRef(R), (this.billboardMode & e.BILLBOARDMODE_X) !== e.BILLBOARDMODE_X && (R.x = 0), (this.billboardMode & e.BILLBOARDMODE_Y) !== e.BILLBOARDMODE_Y && (R.y = 0), (this.billboardMode & e.BILLBOARDMODE_Z) !== e.BILLBOARDMODE_Z && (R.z = 0), I.RotationYawPitchRollToRef(R.y, R.x, R.z, D.Matrix[0]);
      } else
        I.FromQuaternionToRef(D.Quaternion[0], D.Matrix[0]);
      this._worldMatrix.setTranslationFromFloats(0, 0, 0), this._worldMatrix.multiplyToRef(D.Matrix[0], this._worldMatrix), this._worldMatrix.setTranslation(D.Vector3[0]);
    }
    return this.ignoreNonUniformScaling ? this._updateNonUniformScalingState(!1) : this._scaling.isNonUniformWithinEpsilon(1e-6) ? this._updateNonUniformScalingState(!0) : u && u._nonUniformScaling ? this._updateNonUniformScalingState(u._nonUniformScaling) : this._updateNonUniformScalingState(!1), this._afterComputeWorldMatrix(), this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]), this._isAbsoluteSynced = !1, this.onAfterWorldMatrixUpdateObservable.notifyObservers(this), this._poseMatrix || (this._poseMatrix = I.Invert(this._worldMatrix)), this._worldMatrixDeterminantIsDirty = !0, this._worldMatrix;
  }, e.prototype.resetLocalMatrix = function(t) {
    if (t === void 0 && (t = !0), this.computeWorldMatrix(), t)
      for (var r = this.getChildren(), n = 0; n < r.length; ++n) {
        var a = r[n];
        if (a) {
          a.computeWorldMatrix();
          var s = D.Matrix[0];
          a._localMatrix.multiplyToRef(this._localMatrix, s);
          var o = D.Quaternion[0];
          s.decompose(a.scaling, o, a.position), a.rotationQuaternion ? a.rotationQuaternion.copyFrom(o) : o.toEulerAnglesToRef(a.rotation);
        }
      }
    this.scaling.copyFromFloats(1, 1, 1), this.position.copyFromFloats(0, 0, 0), this.rotation.copyFromFloats(0, 0, 0), this.rotationQuaternion && (this.rotationQuaternion = ie.Identity()), this._worldMatrix = I.Identity();
  }, e.prototype._afterComputeWorldMatrix = function() {
  }, e.prototype.registerAfterWorldMatrixUpdate = function(t) {
    return this.onAfterWorldMatrixUpdateObservable.add(t), this;
  }, e.prototype.unregisterAfterWorldMatrixUpdate = function(t) {
    return this.onAfterWorldMatrixUpdateObservable.removeCallback(t), this;
  }, e.prototype.getPositionInCameraSpace = function(t) {
    return t === void 0 && (t = null), t || (t = this.getScene().activeCamera), b.TransformCoordinates(this.getAbsolutePosition(), t.getViewMatrix());
  }, e.prototype.getDistanceToCamera = function(t) {
    return t === void 0 && (t = null), t || (t = this.getScene().activeCamera), this.getAbsolutePosition().subtract(t.globalPosition).length();
  }, e.prototype.clone = function(t, r, n) {
    var a = this, s = $.Clone(function() {
      return new e(t, a.getScene());
    }, this);
    if (s.name = t, s.id = t, r && (s.parent = r), !n)
      for (var o = this.getDescendants(!0), u = 0; u < o.length; u++) {
        var f = o[u];
        f.clone && f.clone(t + "." + f.name, s);
      }
    return s;
  }, e.prototype.serialize = function(t) {
    var r = $.Serialize(this, t);
    return r.type = this.getClassName(), r.uniqueId = this.uniqueId, this.parent && (r.parentId = this.parent.uniqueId), r.localMatrix = this.getPivotMatrix().asArray(), r.isEnabled = this.isEnabled(), this.parent && (r.parentId = this.parent.uniqueId), r;
  }, e.Parse = function(t, r, n) {
    var a = $.Parse(function() {
      return new e(t.name, r);
    }, t, r, n);
    return t.localMatrix ? a.setPreTransformMatrix(I.FromArray(t.localMatrix)) : t.pivotMatrix && a.setPivotMatrix(I.FromArray(t.pivotMatrix)), a.setEnabled(t.isEnabled), t.parentId !== void 0 && (a._waitingParentId = t.parentId), a;
  }, e.prototype.getChildTransformNodes = function(t, r) {
    var n = [];
    return this._getDescendants(n, t, function(a) {
      return (!r || r(a)) && a instanceof e;
    }), n;
  }, e.prototype.dispose = function(t, r) {
    if (r === void 0 && (r = !1), this.getScene().stopAnimation(this), this.getScene().removeTransformNode(this), this._parentContainer) {
      var n = this._parentContainer.transformNodes.indexOf(this);
      n > -1 && this._parentContainer.transformNodes.splice(n, 1), this._parentContainer = null;
    }
    if (this.onAfterWorldMatrixUpdateObservable.clear(), t)
      for (var a = this.getChildTransformNodes(!0), s = 0, o = a; s < o.length; s++) {
        var u = o[s];
        u.parent = null, u.computeWorldMatrix(!0);
      }
    i.prototype.dispose.call(this, t, r);
  }, e.prototype.normalizeToUnitCube = function(t, r, n) {
    t === void 0 && (t = !0), r === void 0 && (r = !1);
    var a = null, s = null;
    r && (this.rotationQuaternion ? (s = this.rotationQuaternion.clone(), this.rotationQuaternion.copyFromFloats(0, 0, 0, 1)) : this.rotation && (a = this.rotation.clone(), this.rotation.copyFromFloats(0, 0, 0)));
    var o = this.getHierarchyBoundingVectors(t, n), u = o.max.subtract(o.min), f = Math.max(u.x, u.y, u.z);
    if (f === 0)
      return this;
    var l = 1 / f;
    return this.scaling.scaleInPlace(l), r && (this.rotationQuaternion && s ? this.rotationQuaternion.copyFrom(s) : this.rotation && a && this.rotation.copyFrom(a)), this;
  }, e.prototype._syncAbsoluteScalingAndRotation = function() {
    this._isAbsoluteSynced || (this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion), this._isAbsoluteSynced = !0);
  }, e.BILLBOARDMODE_NONE = 0, e.BILLBOARDMODE_X = 1, e.BILLBOARDMODE_Y = 2, e.BILLBOARDMODE_Z = 4, e.BILLBOARDMODE_ALL = 7, e.BILLBOARDMODE_USE_POSITION = 128, e._TmpRotation = ie.Zero(), e._TmpScaling = b.Zero(), e._TmpTranslation = b.Zero(), e._LookAtVectorCache = new b(0, 0, 0), e._RotationAxisCache = new ie(), T([
    dt("position")
  ], e.prototype, "_position", void 0), T([
    dt("rotation")
  ], e.prototype, "_rotation", void 0), T([
    sa("rotationQuaternion")
  ], e.prototype, "_rotationQuaternion", void 0), T([
    dt("scaling")
  ], e.prototype, "_scaling", void 0), T([
    P("billboardMode")
  ], e.prototype, "_billboardMode", void 0), T([
    P()
  ], e.prototype, "scalingDeterminant", void 0), T([
    P("infiniteDistance")
  ], e.prototype, "_infiniteDistance", void 0), T([
    P()
  ], e.prototype, "ignoreNonUniformScaling", void 0), T([
    P()
  ], e.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0), e;
}(Je), Ea = function() {
  function i() {
    this._checkCollisions = !1, this._collisionMask = -1, this._collisionGroup = -1, this._surroundingMeshes = null, this._collider = null, this._oldPositionForCollisions = new b(0, 0, 0), this._diffPositionForCollisions = new b(0, 0, 0), this._collisionResponse = !0;
  }
  return i;
}(), Ta = function() {
  function i() {
    this.facetNb = 0, this.partitioningSubdivisions = 10, this.partitioningBBoxRatio = 1.01, this.facetDataEnabled = !1, this.facetParameters = {}, this.bbSize = b.Zero(), this.subDiv = {
      max: 1,
      X: 1,
      Y: 1,
      Z: 1
    }, this.facetDepthSort = !1, this.facetDepthSortEnabled = !1;
  }
  return i;
}(), Sa = function() {
  function i() {
    this._hasVertexAlpha = !1, this._useVertexColors = !0, this._numBoneInfluencers = 4, this._applyFog = !0, this._receiveShadows = !1, this._facetData = new Ta(), this._visibility = 1, this._skeleton = null, this._layerMask = 268435455, this._computeBonesUsingShaders = !0, this._isActive = !1, this._onlyForInstances = !1, this._isActiveIntermediate = !1, this._onlyForInstancesIntermediate = !1, this._actAsRegularMesh = !1, this._currentLOD = null, this._currentLODIsUpToDate = !1, this._collisionRetryCount = 3, this._morphTargetManager = null, this._renderingGroupId = 0, this._bakedVertexAnimationManager = null, this._material = null, this._positions = null, this._meshCollisionData = new Ea(), this._enableDistantPicking = !1;
  }
  return i;
}(), mi = function(i) {
  K(e, i);
  function e(t, r) {
    r === void 0 && (r = null);
    var n = i.call(this, t, r, !1) || this;
    return n._internalAbstractMeshDataInfo = new Sa(), n._waitingMaterialId = null, n.cullingStrategy = e.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY, n.onCollideObservable = new O(), n.onCollisionPositionChangeObservable = new O(), n.onMaterialChangedObservable = new O(), n.definedFacingForward = !0, n._occlusionQuery = null, n._renderingGroup = null, n.alphaIndex = Number.MAX_VALUE, n.isVisible = !0, n.isPickable = !0, n.isNearPickable = !1, n.isNearGrabbable = !1, n.showSubMeshesBoundingBox = !1, n.isBlocker = !1, n.enablePointerMoveEvents = !1, n.outlineColor = ye.Red(), n.outlineWidth = 0.02, n.overlayColor = ye.Red(), n.overlayAlpha = 0.5, n.useOctreeForRenderingSelection = !0, n.useOctreeForPicking = !0, n.useOctreeForCollisions = !0, n.alwaysSelectAsActiveMesh = !1, n.doNotSyncBoundingInfo = !1, n.actionManager = null, n.ellipsoid = new b(0.5, 1, 0.5), n.ellipsoidOffset = new b(0, 0, 0), n.edgesWidth = 1, n.edgesColor = new be(1, 0, 0, 1), n._edgesRenderer = null, n._masterMesh = null, n._boundingInfo = null, n._boundingInfoIsDirty = !0, n._renderId = 0, n._intersectionsInProgress = new Array(), n._unIndexed = !1, n._lightSources = new Array(), n._waitingData = {
      lods: null,
      actions: null,
      freezeWorldMatrix: null
    }, n._bonesTransformMatrices = null, n._transformMatrixTexture = null, n.onRebuildObservable = new O(), n._onCollisionPositionChange = function(a, s, o) {
      o === void 0 && (o = null), s.subtractToRef(n._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, n._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions), n._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > fe.CollisionsEpsilon && n.position.addInPlace(n._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions), o && n.onCollideObservable.notifyObservers(o), n.onCollisionPositionChangeObservable.notifyObservers(n.position);
    }, n.getScene().addMesh(n), n._resyncLightSources(), n._uniformBuffer = new wr(n.getScene().getEngine(), void 0, void 0, t, !n.getScene().getEngine().isWebGPU), n._buildUniformLayout(), n;
  }
  return Object.defineProperty(e, "BILLBOARDMODE_NONE", {
    get: function() {
      return Ze.BILLBOARDMODE_NONE;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "BILLBOARDMODE_X", {
    get: function() {
      return Ze.BILLBOARDMODE_X;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "BILLBOARDMODE_Y", {
    get: function() {
      return Ze.BILLBOARDMODE_Y;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "BILLBOARDMODE_Z", {
    get: function() {
      return Ze.BILLBOARDMODE_Z;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "BILLBOARDMODE_ALL", {
    get: function() {
      return Ze.BILLBOARDMODE_ALL;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "BILLBOARDMODE_USE_POSITION", {
    get: function() {
      return Ze.BILLBOARDMODE_USE_POSITION;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "facetNb", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetNb;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "partitioningSubdivisions", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "partitioningBBoxRatio", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "mustDepthSortFacets", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._facetData.facetDepthSort = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "facetDepthSortFrom", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "collisionRetryCount", {
    get: function() {
      return this._internalAbstractMeshDataInfo._collisionRetryCount;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._collisionRetryCount = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "isFacetDataEnabled", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "morphTargetManager", {
    get: function() {
      return this._internalAbstractMeshDataInfo._morphTargetManager;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._morphTargetManager !== t && (this._internalAbstractMeshDataInfo._morphTargetManager = t, this._syncGeometryWithMorphTargetManager());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "bakedVertexAnimationManager", {
    get: function() {
      return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._bakedVertexAnimationManager !== t && (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = t, this._markSubMeshesAsAttributesDirty());
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._syncGeometryWithMorphTargetManager = function() {
  }, e.prototype._updateNonUniformScalingState = function(t) {
    return i.prototype._updateNonUniformScalingState.call(this, t) ? (this._markSubMeshesAsMiscDirty(), !0) : !1;
  }, Object.defineProperty(e.prototype, "onCollide", {
    set: function(t) {
      this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver && this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver), this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "onCollisionPositionChange", {
    set: function(t) {
      this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver && this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver), this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "visibility", {
    get: function() {
      return this._internalAbstractMeshDataInfo._visibility;
    },
    set: function(t) {
      if (this._internalAbstractMeshDataInfo._visibility !== t) {
        var r = this._internalAbstractMeshDataInfo._visibility;
        this._internalAbstractMeshDataInfo._visibility = t, (r === 1 && t !== 1 || r !== 1 && t === 1) && this._markSubMeshesAsMiscDirty();
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "renderingGroupId", {
    get: function() {
      return this._internalAbstractMeshDataInfo._renderingGroupId;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._renderingGroupId = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "material", {
    get: function() {
      return this._internalAbstractMeshDataInfo._material;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._material !== t && (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap && (this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0), this._internalAbstractMeshDataInfo._material = t, t && t.meshMap && (t.meshMap[this.uniqueId] = this), this.onMaterialChangedObservable.hasObservers() && this.onMaterialChangedObservable.notifyObservers(this), this.subMeshes && (this.resetDrawCache(), this._unBindEffect()));
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getMaterialForRenderPass = function(t) {
    var r;
    return (r = this._internalAbstractMeshDataInfo._materialForRenderPass) === null || r === void 0 ? void 0 : r[t];
  }, e.prototype.setMaterialForRenderPass = function(t, r) {
    this.resetDrawCache(t), this._internalAbstractMeshDataInfo._materialForRenderPass || (this._internalAbstractMeshDataInfo._materialForRenderPass = []), this._internalAbstractMeshDataInfo._materialForRenderPass[t] = r;
  }, Object.defineProperty(e.prototype, "receiveShadows", {
    get: function() {
      return this._internalAbstractMeshDataInfo._receiveShadows;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._receiveShadows !== t && (this._internalAbstractMeshDataInfo._receiveShadows = t, this._markSubMeshesAsLightDirty());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "hasVertexAlpha", {
    get: function() {
      return this._internalAbstractMeshDataInfo._hasVertexAlpha;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._hasVertexAlpha !== t && (this._internalAbstractMeshDataInfo._hasVertexAlpha = t, this._markSubMeshesAsAttributesDirty(), this._markSubMeshesAsMiscDirty());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "useVertexColors", {
    get: function() {
      return this._internalAbstractMeshDataInfo._useVertexColors;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._useVertexColors !== t && (this._internalAbstractMeshDataInfo._useVertexColors = t, this._markSubMeshesAsAttributesDirty());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "computeBonesUsingShaders", {
    get: function() {
      return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._computeBonesUsingShaders !== t && (this._internalAbstractMeshDataInfo._computeBonesUsingShaders = t, this._markSubMeshesAsAttributesDirty());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "numBoneInfluencers", {
    get: function() {
      return this._internalAbstractMeshDataInfo._numBoneInfluencers;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._numBoneInfluencers !== t && (this._internalAbstractMeshDataInfo._numBoneInfluencers = t, this._markSubMeshesAsAttributesDirty());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "applyFog", {
    get: function() {
      return this._internalAbstractMeshDataInfo._applyFog;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._applyFog !== t && (this._internalAbstractMeshDataInfo._applyFog = t, this._markSubMeshesAsMiscDirty());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "enableDistantPicking", {
    get: function() {
      return this._internalAbstractMeshDataInfo._enableDistantPicking;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._enableDistantPicking = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "layerMask", {
    get: function() {
      return this._internalAbstractMeshDataInfo._layerMask;
    },
    set: function(t) {
      t !== this._internalAbstractMeshDataInfo._layerMask && (this._internalAbstractMeshDataInfo._layerMask = t, this._resyncLightSources());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "collisionMask", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = isNaN(t) ? -1 : t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "collisionResponse", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "collisionGroup", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = isNaN(t) ? -1 : t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "surroundingMeshes", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "lightSources", {
    get: function() {
      return this._lightSources;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "_positions", {
    get: function() {
      return null;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "skeleton", {
    get: function() {
      return this._internalAbstractMeshDataInfo._skeleton;
    },
    set: function(t) {
      var r = this._internalAbstractMeshDataInfo._skeleton;
      r && r.needInitialSkinMatrix && r._unregisterMeshWithPoseMatrix(this), t && t.needInitialSkinMatrix && t._registerMeshWithPoseMatrix(this), this._internalAbstractMeshDataInfo._skeleton = t, this._internalAbstractMeshDataInfo._skeleton || (this._bonesTransformMatrices = null), this._markSubMeshesAsAttributesDirty();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._buildUniformLayout = function() {
    this._uniformBuffer.addUniform("world", 16), this._uniformBuffer.addUniform("visibility", 1), this._uniformBuffer.create();
  }, e.prototype.transferToEffect = function(t) {
    var r = this._uniformBuffer;
    r.updateMatrix("world", t), r.updateFloat("visibility", this._internalAbstractMeshDataInfo._visibility), r.update();
  }, e.prototype.getMeshUniformBuffer = function() {
    return this._uniformBuffer;
  }, e.prototype.getClassName = function() {
    return "AbstractMesh";
  }, e.prototype.toString = function(t) {
    var r = "Name: " + this.name + ", isInstance: " + (this.getClassName() !== "InstancedMesh" ? "YES" : "NO");
    r += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0);
    var n = this._internalAbstractMeshDataInfo._skeleton;
    return n && (r += ", skeleton: " + n.name), t && (r += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode], r += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO")), r;
  }, e.prototype._getEffectiveParent = function() {
    return this._masterMesh && this.billboardMode !== Ze.BILLBOARDMODE_NONE ? this._masterMesh : i.prototype._getEffectiveParent.call(this);
  }, e.prototype._getActionManagerForTrigger = function(t, r) {
    if (r === void 0 && (r = !0), this.actionManager && (r || this.actionManager.isRecursive))
      if (t) {
        if (this.actionManager.hasSpecificTrigger(t))
          return this.actionManager;
      } else
        return this.actionManager;
    return this.parent ? this.parent._getActionManagerForTrigger(t, !1) : null;
  }, e.prototype._rebuild = function(t) {
    if (this.onRebuildObservable.notifyObservers(this), this._occlusionQuery !== null && (this._occlusionQuery = null), !!this.subMeshes)
      for (var r = 0, n = this.subMeshes; r < n.length; r++) {
        var a = n[r];
        a._rebuild();
      }
  }, e.prototype._resyncLightSources = function() {
    this._lightSources.length = 0;
    for (var t = 0, r = this.getScene().lights; t < r.length; t++) {
      var n = r[t];
      !n.isEnabled() || n.canAffectMesh(this) && this._lightSources.push(n);
    }
    this._markSubMeshesAsLightDirty();
  }, e.prototype._resyncLightSource = function(t) {
    var r = t.isEnabled() && t.canAffectMesh(this), n = this._lightSources.indexOf(t), a = !1;
    if (n === -1) {
      if (!r)
        return;
      this._lightSources.push(t);
    } else {
      if (r)
        return;
      a = !0, this._lightSources.splice(n, 1);
    }
    this._markSubMeshesAsLightDirty(a);
  }, e.prototype._unBindEffect = function() {
    for (var t = 0, r = this.subMeshes; t < r.length; t++) {
      var n = r[t];
      n.setEffect(null);
    }
  }, e.prototype._removeLightSource = function(t, r) {
    var n = this._lightSources.indexOf(t);
    n !== -1 && (this._lightSources.splice(n, 1), this._markSubMeshesAsLightDirty(r));
  }, e.prototype._markSubMeshesAsDirty = function(t) {
    if (!!this.subMeshes)
      for (var r = 0, n = this.subMeshes; r < n.length; r++)
        for (var a = n[r], s = 0; s < a._drawWrappers.length; ++s) {
          var o = a._drawWrappers[s];
          !o || !o.defines || !o.defines.markAllAsDirty || t(o.defines);
        }
  }, e.prototype._markSubMeshesAsLightDirty = function(t) {
    t === void 0 && (t = !1), this._markSubMeshesAsDirty(function(r) {
      return r.markAsLightDirty(t);
    });
  }, e.prototype._markSubMeshesAsAttributesDirty = function() {
    this._markSubMeshesAsDirty(function(t) {
      return t.markAsAttributesDirty();
    });
  }, e.prototype._markSubMeshesAsMiscDirty = function() {
    this._markSubMeshesAsDirty(function(t) {
      return t.markAsMiscDirty();
    });
  }, e.prototype.markAsDirty = function(t) {
    return this._currentRenderId = Number.MAX_VALUE, this._isDirty = !0, this;
  }, e.prototype.resetDrawCache = function(t) {
    if (!!this.subMeshes)
      for (var r = 0, n = this.subMeshes; r < n.length; r++) {
        var a = n[r];
        a.resetDrawCache(t);
      }
  }, Object.defineProperty(e.prototype, "isBlocked", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getLOD = function(t) {
    return this;
  }, e.prototype.getTotalVertices = function() {
    return 0;
  }, e.prototype.getTotalIndices = function() {
    return 0;
  }, e.prototype.getIndices = function() {
    return null;
  }, e.prototype.getVerticesData = function(t) {
    return null;
  }, e.prototype.setVerticesData = function(t, r, n, a) {
    return this;
  }, e.prototype.updateVerticesData = function(t, r, n, a) {
    return this;
  }, e.prototype.setIndices = function(t, r) {
    return this;
  }, e.prototype.isVerticesDataPresent = function(t) {
    return !1;
  }, e.prototype.getBoundingInfo = function() {
    return this._masterMesh ? this._masterMesh.getBoundingInfo() : (this._boundingInfoIsDirty && (this._boundingInfoIsDirty = !1, this._updateBoundingInfo()), this._boundingInfo);
  }, e.prototype.setBoundingInfo = function(t) {
    return this._boundingInfo = t, this;
  }, Object.defineProperty(e.prototype, "hasBoundingInfo", {
    get: function() {
      return this._boundingInfo !== null;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.buildBoundingInfo = function(t, r, n) {
    return this._boundingInfo = new Et(t, r, n), this._boundingInfo;
  }, e.prototype.normalizeToUnitCube = function(t, r, n) {
    return t === void 0 && (t = !0), r === void 0 && (r = !1), i.prototype.normalizeToUnitCube.call(this, t, r, n);
  }, Object.defineProperty(e.prototype, "useBones", {
    get: function() {
      return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(m.MatricesIndicesKind) && this.isVerticesDataPresent(m.MatricesWeightsKind);
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._preActivate = function() {
  }, e.prototype._preActivateForIntermediateRendering = function(t) {
  }, e.prototype._activate = function(t, r) {
    return this._renderId = t, !0;
  }, e.prototype._postActivate = function() {
  }, e.prototype._freeze = function() {
  }, e.prototype._unFreeze = function() {
  }, e.prototype.getWorldMatrix = function() {
    return this._masterMesh && this.billboardMode === Ze.BILLBOARDMODE_NONE ? this._masterMesh.getWorldMatrix() : i.prototype.getWorldMatrix.call(this);
  }, e.prototype._getWorldMatrixDeterminant = function() {
    return this._masterMesh ? this._masterMesh._getWorldMatrixDeterminant() : i.prototype._getWorldMatrixDeterminant.call(this);
  }, Object.defineProperty(e.prototype, "isAnInstance", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "hasInstances", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "hasThinInstances", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.movePOV = function(t, r, n) {
    return this.position.addInPlace(this.calcMovePOV(t, r, n)), this;
  }, e.prototype.calcMovePOV = function(t, r, n) {
    var a = new I(), s = this.rotationQuaternion ? this.rotationQuaternion : ie.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
    s.toRotationMatrix(a);
    var o = b.Zero(), u = this.definedFacingForward ? -1 : 1;
    return b.TransformCoordinatesFromFloatsToRef(t * u, r, n * u, a, o), o;
  }, e.prototype.rotatePOV = function(t, r, n) {
    return this.rotation.addInPlace(this.calcRotatePOV(t, r, n)), this;
  }, e.prototype.calcRotatePOV = function(t, r, n) {
    var a = this.definedFacingForward ? 1 : -1;
    return new b(t * a, r, n * a);
  }, e.prototype.refreshBoundingInfo = function(t, r) {
    return t === void 0 && (t = !1), r === void 0 && (r = !1), this._boundingInfo && this._boundingInfo.isLocked ? this : (this._refreshBoundingInfo(this._getPositionData(t, r), null), this);
  }, e.prototype._refreshBoundingInfo = function(t, r) {
    if (t) {
      var n = dn(t, 0, this.getTotalVertices(), r);
      this._boundingInfo ? this._boundingInfo.reConstruct(n.minimum, n.maximum) : this._boundingInfo = new Et(n.minimum, n.maximum);
    }
    if (this.subMeshes)
      for (var a = 0; a < this.subMeshes.length; a++)
        this.subMeshes[a].refreshBoundingInfo(t);
    this._updateBoundingInfo();
  }, e.prototype._getData = function(t, r, n, a) {
    if (t === void 0 && (t = !1), r === void 0 && (r = !1), a === void 0 && (a = m.PositionKind), n = n != null ? n : this.getVerticesData(a).slice(), n && r && this.morphTargetManager)
      for (var s = 0, o = 0, u = 0; u < n.length; u++) {
        for (var f = 0; f < this.morphTargetManager.numTargets; f++) {
          var l = this.morphTargetManager.getTarget(f), h = l.influence;
          if (h > 0) {
            var c = l.getPositions();
            c && (n[u] += (c[u] - n[u]) * h);
          }
        }
        if (s++, a === m.PositionKind && this._positions && s === 3) {
          s = 0;
          var d = o * 3;
          this._positions[o++].copyFromFloats(n[d], n[d + 1], n[d + 2]);
        }
      }
    if (n && t && this.skeleton) {
      var p = this.getVerticesData(m.MatricesIndicesKind), g = this.getVerticesData(m.MatricesWeightsKind);
      if (g && p)
        for (var _ = this.numBoneInfluencers > 4, v = _ ? this.getVerticesData(m.MatricesIndicesExtraKind) : null, y = _ ? this.getVerticesData(m.MatricesWeightsExtraKind) : null, E = this.skeleton.getTransformMatrices(this), R = D.Vector3[0], M = D.Matrix[0], C = D.Matrix[1], A = 0, d = 0; d < n.length; d += 3, A += 4) {
          M.reset();
          var S = void 0, w = void 0;
          for (S = 0; S < 4; S++)
            w = g[A + S], w > 0 && (I.FromFloat32ArrayToRefScaled(E, Math.floor(p[A + S] * 16), w, C), M.addToSelf(C));
          if (_)
            for (S = 0; S < 4; S++)
              w = y[A + S], w > 0 && (I.FromFloat32ArrayToRefScaled(E, Math.floor(v[A + S] * 16), w, C), M.addToSelf(C));
          a === m.NormalKind ? b.TransformNormalFromFloatsToRef(n[d], n[d + 1], n[d + 2], M, R) : b.TransformCoordinatesFromFloatsToRef(n[d], n[d + 1], n[d + 2], M, R), R.toArray(n, d), a === m.PositionKind && this._positions && this._positions[d / 3].copyFrom(R);
        }
    }
    return n;
  }, e.prototype.getNormalsData = function(t, r) {
    return t === void 0 && (t = !1), r === void 0 && (r = !1), this._getData(t, r, null, m.NormalKind);
  }, e.prototype.getPositionData = function(t, r, n) {
    return t === void 0 && (t = !1), r === void 0 && (r = !1), this._getData(t, r, n, m.PositionKind);
  }, e.prototype._getPositionData = function(t, r) {
    var n, a = this.getVerticesData(m.PositionKind);
    if (this._internalAbstractMeshDataInfo._positions && (this._internalAbstractMeshDataInfo._positions = null), a && (t && this.skeleton || r && this.morphTargetManager)) {
      if (a = a.slice(), this._generatePointsArray(), this._positions) {
        var s = this._positions;
        this._internalAbstractMeshDataInfo._positions = new Array(s.length);
        for (var o = 0; o < s.length; o++)
          this._internalAbstractMeshDataInfo._positions[o] = ((n = s[o]) === null || n === void 0 ? void 0 : n.clone()) || new b();
      }
      return this.getPositionData(t, r, a);
    }
    return a;
  }, e.prototype._updateBoundingInfo = function() {
    return this._boundingInfo ? this._boundingInfo.update(this.worldMatrixFromCache) : this._boundingInfo = new Et(b.Zero(), b.Zero(), this.worldMatrixFromCache), this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache), this;
  }, e.prototype._updateSubMeshesBoundingInfo = function(t) {
    if (!this.subMeshes)
      return this;
    for (var r = this.subMeshes.length, n = 0; n < r; n++) {
      var a = this.subMeshes[n];
      (r > 1 || !a.IsGlobal) && a.updateBoundingInfo(t);
    }
    return this;
  }, e.prototype._afterComputeWorldMatrix = function() {
    this.doNotSyncBoundingInfo || (this._boundingInfoIsDirty = !0);
  }, e.prototype.isInFrustum = function(t) {
    return this.getBoundingInfo().isInFrustum(t, this.cullingStrategy);
  }, e.prototype.isCompletelyInFrustum = function(t) {
    return this.getBoundingInfo().isCompletelyInFrustum(t);
  }, e.prototype.intersectsMesh = function(t, r, n) {
    r === void 0 && (r = !1);
    var a = this.getBoundingInfo(), s = t.getBoundingInfo();
    if (a.intersects(s, r))
      return !0;
    if (n)
      for (var o = 0, u = this.getChildMeshes(); o < u.length; o++) {
        var f = u[o];
        if (f.intersectsMesh(t, r, !0))
          return !0;
      }
    return !1;
  }, e.prototype.intersectsPoint = function(t) {
    return this.getBoundingInfo().intersectsPoint(t);
  }, Object.defineProperty(e.prototype, "checkCollisions", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "collider", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._collider;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.moveWithCollisions = function(t) {
    var r = this.getAbsolutePosition();
    r.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);
    var n = this.getScene().collisionCoordinator;
    return this._internalAbstractMeshDataInfo._meshCollisionData._collider || (this._internalAbstractMeshDataInfo._meshCollisionData._collider = n.createCollider()), this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid, n.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, t, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId), this;
  }, e.prototype._collideForSubMesh = function(t, r, n) {
    var a;
    if (this._generatePointsArray(), !this._positions)
      return this;
    if (!t._lastColliderWorldVertices || !t._lastColliderTransformMatrix.equals(r)) {
      t._lastColliderTransformMatrix = r.clone(), t._lastColliderWorldVertices = [], t._trianglePlanes = [];
      for (var s = t.verticesStart, o = t.verticesStart + t.verticesCount, u = s; u < o; u++)
        t._lastColliderWorldVertices.push(b.TransformCoordinates(this._positions[u], r));
    }
    return n._collide(t._trianglePlanes, t._lastColliderWorldVertices, this.getIndices(), t.indexStart, t.indexStart + t.indexCount, t.verticesStart, !!t.getMaterial(), this, this._shouldConvertRHS(), ((a = t.getMaterial()) === null || a === void 0 ? void 0 : a.fillMode) === 7), this;
  }, e.prototype._processCollisionsForSubMeshes = function(t, r) {
    for (var n = this._scene.getCollidingSubMeshCandidates(this, t), a = n.length, s = 0; s < a; s++) {
      var o = n.data[s];
      a > 1 && !o._checkCollision(t) || this._collideForSubMesh(o, r, t);
    }
    return this;
  }, e.prototype._shouldConvertRHS = function() {
    return !1;
  }, e.prototype._checkCollision = function(t) {
    if (!this.getBoundingInfo()._checkCollision(t))
      return this;
    var r = D.Matrix[0], n = D.Matrix[1];
    return I.ScalingToRef(1 / t._radius.x, 1 / t._radius.y, 1 / t._radius.z, r), this.worldMatrixFromCache.multiplyToRef(r, n), this._processCollisionsForSubMeshes(t, n), this;
  }, e.prototype._generatePointsArray = function() {
    return !1;
  }, e.prototype.intersects = function(t, r, n, a, s, o) {
    a === void 0 && (a = !1), o === void 0 && (o = !1);
    var u = new et(), f = this.getClassName() === "InstancedLinesMesh" || this.getClassName() === "LinesMesh" ? this.intersectionThreshold : 0, l = this.getBoundingInfo();
    if (!this.subMeshes || !o && (!t.intersectsSphere(l.boundingSphere, f) || !t.intersectsBox(l.boundingBox, f)))
      return u;
    if (a)
      return u.hit = !o, u.pickedMesh = o ? null : this, u.distance = o ? 0 : b.Distance(t.origin, l.boundingSphere.center), u.subMeshId = 0, u;
    if (!this._generatePointsArray())
      return u;
    for (var h = null, c = this._scene.getIntersectingSubMeshCandidates(this, t), d = c.length, p = !1, g = 0; g < d; g++) {
      var _ = c.data[g], v = _.getMaterial();
      if (!!v && (v.fillMode == 7 || v.fillMode == 0 || v.fillMode == 1 || v.fillMode == 2 || v.fillMode == 4)) {
        p = !0;
        break;
      }
    }
    if (!p)
      return u.hit = !0, u.pickedMesh = this, u.distance = b.Distance(t.origin, l.boundingSphere.center), u.subMeshId = -1, u;
    for (var g = 0; g < d; g++) {
      var _ = c.data[g];
      if (!(d > 1 && !_.canIntersects(t))) {
        var y = _.intersects(t, this._positions, this.getIndices(), r, n);
        if (y && (r || !h || y.distance < h.distance) && (h = y, h.subMeshId = g, r))
          break;
      }
    }
    if (h) {
      var E = s != null ? s : this.getWorldMatrix(), R = D.Vector3[0], M = D.Vector3[1];
      b.TransformCoordinatesToRef(t.origin, E, R), t.direction.scaleToRef(h.distance, M);
      var C = b.TransformNormal(M, E), A = C.addInPlace(R);
      return u.hit = !0, u.distance = b.Distance(R, A), u.pickedPoint = A, u.pickedMesh = this, u.bu = h.bu || 0, u.bv = h.bv || 0, u.subMeshFaceId = h.faceId, u.faceId = h.faceId + c.data[h.subMeshId].indexStart / (this.getClassName().indexOf("LinesMesh") !== -1 ? 2 : 3), u.subMeshId = h.subMeshId, u;
    }
    return u;
  }, e.prototype.clone = function(t, r, n) {
    return null;
  }, e.prototype.releaseSubMeshes = function() {
    if (this.subMeshes)
      for (; this.subMeshes.length; )
        this.subMeshes[0].dispose();
    else
      this.subMeshes = new Array();
    return this;
  }, e.prototype.dispose = function(t, r) {
    var n = this;
    r === void 0 && (r = !1);
    var a;
    for (this._scene.useMaterialMeshMap && this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap && (this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0), this.getScene().freeActiveMeshes(), this.getScene().freeRenderingGroups(), this.actionManager !== void 0 && this.actionManager !== null && (this.actionManager.dispose(), this.actionManager = null), this._internalAbstractMeshDataInfo._skeleton = null, this._transformMatrixTexture && (this._transformMatrixTexture.dispose(), this._transformMatrixTexture = null), a = 0; a < this._intersectionsInProgress.length; a++) {
      var s = this._intersectionsInProgress[a], o = s._intersectionsInProgress.indexOf(this);
      s._intersectionsInProgress.splice(o, 1);
    }
    this._intersectionsInProgress = [];
    var u = this.getScene().lights;
    u.forEach(function(h) {
      var c = h.includedOnlyMeshes.indexOf(n);
      c !== -1 && h.includedOnlyMeshes.splice(c, 1), c = h.excludedMeshes.indexOf(n), c !== -1 && h.excludedMeshes.splice(c, 1);
      var d = h.getShadowGenerator();
      if (d) {
        var p = d.getShadowMap();
        p && p.renderList && (c = p.renderList.indexOf(n), c !== -1 && p.renderList.splice(c, 1));
      }
    }), (this.getClassName() !== "InstancedMesh" || this.getClassName() !== "InstancedLinesMesh") && this.releaseSubMeshes();
    var f = this.getScene().getEngine();
    if (this._occlusionQuery !== null && (this.isOcclusionQueryInProgress = !1, f.deleteQuery(this._occlusionQuery), this._occlusionQuery = null), f.wipeCaches(), this.getScene().removeMesh(this), this._parentContainer) {
      var l = this._parentContainer.meshes.indexOf(this);
      l > -1 && this._parentContainer.meshes.splice(l, 1), this._parentContainer = null;
    }
    if (r && this.material && (this.material.getClassName() === "MultiMaterial" ? this.material.dispose(!1, !0, !0) : this.material.dispose(!1, !0)), !t)
      for (a = 0; a < this.getScene().particleSystems.length; a++)
        this.getScene().particleSystems[a].emitter === this && (this.getScene().particleSystems[a].dispose(), a--);
    this._internalAbstractMeshDataInfo._facetData.facetDataEnabled && this.disableFacetData(), this._uniformBuffer.dispose(), this.onAfterWorldMatrixUpdateObservable.clear(), this.onCollideObservable.clear(), this.onCollisionPositionChangeObservable.clear(), this.onRebuildObservable.clear(), i.prototype.dispose.call(this, t, r);
  }, e.prototype.addChild = function(t, r) {
    return r === void 0 && (r = !1), t.setParent(this, r), this;
  }, e.prototype.removeChild = function(t, r) {
    return r === void 0 && (r = !1), t.setParent(null, r), this;
  }, e.prototype._initFacetData = function() {
    var t = this._internalAbstractMeshDataInfo._facetData;
    t.facetNormals || (t.facetNormals = new Array()), t.facetPositions || (t.facetPositions = new Array()), t.facetPartitioning || (t.facetPartitioning = new Array()), t.facetNb = this.getIndices().length / 3 | 0, t.partitioningSubdivisions = t.partitioningSubdivisions ? t.partitioningSubdivisions : 10, t.partitioningBBoxRatio = t.partitioningBBoxRatio ? t.partitioningBBoxRatio : 1.01;
    for (var r = 0; r < t.facetNb; r++)
      t.facetNormals[r] = b.Zero(), t.facetPositions[r] = b.Zero();
    return t.facetDataEnabled = !0, this;
  }, e.prototype.updateFacetData = function() {
    var t = this._internalAbstractMeshDataInfo._facetData;
    t.facetDataEnabled || this._initFacetData();
    var r = this.getVerticesData(m.PositionKind), n = this.getIndices(), a = this.getVerticesData(m.NormalKind), s = this.getBoundingInfo();
    if (t.facetDepthSort && !t.facetDepthSortEnabled) {
      if (t.facetDepthSortEnabled = !0, n instanceof Uint16Array)
        t.depthSortedIndices = new Uint16Array(n);
      else if (n instanceof Uint32Array)
        t.depthSortedIndices = new Uint32Array(n);
      else {
        for (var o = !1, u = 0; u < n.length; u++)
          if (n[u] > 65535) {
            o = !0;
            break;
          }
        o ? t.depthSortedIndices = new Uint32Array(n) : t.depthSortedIndices = new Uint16Array(n);
      }
      if (t.facetDepthSortFunction = function(g, _) {
        return _.sqDistance - g.sqDistance;
      }, !t.facetDepthSortFrom) {
        var f = this.getScene().activeCamera;
        t.facetDepthSortFrom = f ? f.position : b.Zero();
      }
      t.depthSortedFacets = [];
      for (var l = 0; l < t.facetNb; l++) {
        var h = { ind: l * 3, sqDistance: 0 };
        t.depthSortedFacets.push(h);
      }
      t.invertedMatrix = I.Identity(), t.facetDepthSortOrigin = b.Zero();
    }
    t.bbSize.x = s.maximum.x - s.minimum.x > ce ? s.maximum.x - s.minimum.x : ce, t.bbSize.y = s.maximum.y - s.minimum.y > ce ? s.maximum.y - s.minimum.y : ce, t.bbSize.z = s.maximum.z - s.minimum.z > ce ? s.maximum.z - s.minimum.z : ce;
    var c = t.bbSize.x > t.bbSize.y ? t.bbSize.x : t.bbSize.y;
    if (c = c > t.bbSize.z ? c : t.bbSize.z, t.subDiv.max = t.partitioningSubdivisions, t.subDiv.X = Math.floor(t.subDiv.max * t.bbSize.x / c), t.subDiv.Y = Math.floor(t.subDiv.max * t.bbSize.y / c), t.subDiv.Z = Math.floor(t.subDiv.max * t.bbSize.z / c), t.subDiv.X = t.subDiv.X < 1 ? 1 : t.subDiv.X, t.subDiv.Y = t.subDiv.Y < 1 ? 1 : t.subDiv.Y, t.subDiv.Z = t.subDiv.Z < 1 ? 1 : t.subDiv.Z, t.facetParameters.facetNormals = this.getFacetLocalNormals(), t.facetParameters.facetPositions = this.getFacetLocalPositions(), t.facetParameters.facetPartitioning = this.getFacetLocalPartitioning(), t.facetParameters.bInfo = s, t.facetParameters.bbSize = t.bbSize, t.facetParameters.subDiv = t.subDiv, t.facetParameters.ratio = this.partitioningBBoxRatio, t.facetParameters.depthSort = t.facetDepthSort, t.facetDepthSort && t.facetDepthSortEnabled && (this.computeWorldMatrix(!0), this._worldMatrix.invertToRef(t.invertedMatrix), b.TransformCoordinatesToRef(t.facetDepthSortFrom, t.invertedMatrix, t.facetDepthSortOrigin), t.facetParameters.distanceTo = t.facetDepthSortOrigin), t.facetParameters.depthSortedFacets = t.depthSortedFacets, a && _e.ComputeNormals(r, n, a, t.facetParameters), t.facetDepthSort && t.facetDepthSortEnabled) {
      t.depthSortedFacets.sort(t.facetDepthSortFunction);
      for (var d = t.depthSortedIndices.length / 3 | 0, l = 0; l < d; l++) {
        var p = t.depthSortedFacets[l].ind;
        t.depthSortedIndices[l * 3] = n[p], t.depthSortedIndices[l * 3 + 1] = n[p + 1], t.depthSortedIndices[l * 3 + 2] = n[p + 2];
      }
      this.updateIndices(t.depthSortedIndices, void 0, !0);
    }
    return this;
  }, e.prototype.getFacetLocalNormals = function() {
    var t = this._internalAbstractMeshDataInfo._facetData;
    return t.facetNormals || this.updateFacetData(), t.facetNormals;
  }, e.prototype.getFacetLocalPositions = function() {
    var t = this._internalAbstractMeshDataInfo._facetData;
    return t.facetPositions || this.updateFacetData(), t.facetPositions;
  }, e.prototype.getFacetLocalPartitioning = function() {
    var t = this._internalAbstractMeshDataInfo._facetData;
    return t.facetPartitioning || this.updateFacetData(), t.facetPartitioning;
  }, e.prototype.getFacetPosition = function(t) {
    var r = b.Zero();
    return this.getFacetPositionToRef(t, r), r;
  }, e.prototype.getFacetPositionToRef = function(t, r) {
    var n = this.getFacetLocalPositions()[t], a = this.getWorldMatrix();
    return b.TransformCoordinatesToRef(n, a, r), this;
  }, e.prototype.getFacetNormal = function(t) {
    var r = b.Zero();
    return this.getFacetNormalToRef(t, r), r;
  }, e.prototype.getFacetNormalToRef = function(t, r) {
    var n = this.getFacetLocalNormals()[t];
    return b.TransformNormalToRef(n, this.getWorldMatrix(), r), this;
  }, e.prototype.getFacetsAtLocalCoordinates = function(t, r, n) {
    var a = this.getBoundingInfo(), s = this._internalAbstractMeshDataInfo._facetData, o = Math.floor((t - a.minimum.x * s.partitioningBBoxRatio) * s.subDiv.X * s.partitioningBBoxRatio / s.bbSize.x), u = Math.floor((r - a.minimum.y * s.partitioningBBoxRatio) * s.subDiv.Y * s.partitioningBBoxRatio / s.bbSize.y), f = Math.floor((n - a.minimum.z * s.partitioningBBoxRatio) * s.subDiv.Z * s.partitioningBBoxRatio / s.bbSize.z);
    return o < 0 || o > s.subDiv.max || u < 0 || u > s.subDiv.max || f < 0 || f > s.subDiv.max ? null : s.facetPartitioning[o + s.subDiv.max * u + s.subDiv.max * s.subDiv.max * f];
  }, e.prototype.getClosestFacetAtCoordinates = function(t, r, n, a, s, o) {
    s === void 0 && (s = !1), o === void 0 && (o = !0);
    var u = this.getWorldMatrix(), f = D.Matrix[5];
    u.invertToRef(f);
    var l = D.Vector3[8];
    b.TransformCoordinatesFromFloatsToRef(t, r, n, f, l);
    var h = this.getClosestFacetAtLocalCoordinates(l.x, l.y, l.z, a, s, o);
    return a && b.TransformCoordinatesFromFloatsToRef(a.x, a.y, a.z, u, a), h;
  }, e.prototype.getClosestFacetAtLocalCoordinates = function(t, r, n, a, s, o) {
    s === void 0 && (s = !1), o === void 0 && (o = !0);
    var u = null, f = 0, l = 0, h = 0, c = 0, d = 0, p = 0, g = 0, _ = 0, v = this.getFacetLocalPositions(), y = this.getFacetLocalNormals(), E = this.getFacetsAtLocalCoordinates(t, r, n);
    if (!E)
      return null;
    for (var R = Number.MAX_VALUE, M = R, C, A, S, w = 0; w < E.length; w++)
      C = E[w], A = y[C], S = v[C], c = (t - S.x) * A.x + (r - S.y) * A.y + (n - S.z) * A.z, (!s || s && o && c >= 0 || s && !o && c <= 0) && (c = A.x * S.x + A.y * S.y + A.z * S.z, d = -(A.x * t + A.y * r + A.z * n - c) / (A.x * A.x + A.y * A.y + A.z * A.z), p = t + A.x * d, g = r + A.y * d, _ = n + A.z * d, f = p - t, l = g - r, h = _ - n, M = f * f + l * l + h * h, M < R && (R = M, u = C, a && (a.x = p, a.y = g, a.z = _)));
    return u;
  }, e.prototype.getFacetDataParameters = function() {
    return this._internalAbstractMeshDataInfo._facetData.facetParameters;
  }, e.prototype.disableFacetData = function() {
    var t = this._internalAbstractMeshDataInfo._facetData;
    return t.facetDataEnabled && (t.facetDataEnabled = !1, t.facetPositions = new Array(), t.facetNormals = new Array(), t.facetPartitioning = new Array(), t.facetParameters = null, t.depthSortedIndices = new Uint32Array(0)), this;
  }, e.prototype.updateIndices = function(t, r, n) {
    return this;
  }, e.prototype.createNormals = function(t) {
    var r = this.getVerticesData(m.PositionKind), n = this.getIndices(), a;
    return this.isVerticesDataPresent(m.NormalKind) ? a = this.getVerticesData(m.NormalKind) : a = [], _e.ComputeNormals(r, n, a, { useRightHandedSystem: this.getScene().useRightHandedSystem }), this.setVerticesData(m.NormalKind, a, t), this;
  }, e.prototype.alignWithNormal = function(t, r) {
    r || (r = Cr.Y);
    var n = D.Vector3[0], a = D.Vector3[1];
    return b.CrossToRef(r, t, a), b.CrossToRef(t, a, n), this.rotationQuaternion ? ie.RotationQuaternionFromAxisToRef(n, t, a, this.rotationQuaternion) : b.RotationFromAxisToRef(n, t, a, this.rotation), this;
  }, e.prototype._checkOcclusionQuery = function() {
    return !1;
  }, e.prototype.disableEdgesRendering = function() {
    throw G("EdgesRenderer");
  }, e.prototype.enableEdgesRendering = function(t, r, n) {
    throw G("EdgesRenderer");
  }, e.prototype.getConnectedParticleSystems = function() {
    var t = this;
    return this._scene.particleSystems.filter(function(r) {
      return r.emitter === t;
    });
  }, e.OCCLUSION_TYPE_NONE = 0, e.OCCLUSION_TYPE_OPTIMISTIC = 1, e.OCCLUSION_TYPE_STRICT = 2, e.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0, e.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1, e.CULLINGSTRATEGY_STANDARD = 0, e.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1, e.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2, e.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3, e;
}(Ze);
Ne("BABYLON.AbstractMesh", mi);
var Ma = function() {
  function i(e, t, r, n) {
    this.x = e, this.y = t, this.width = r, this.height = n;
  }
  return i.prototype.toGlobal = function(e, t) {
    return new i(this.x * e, this.y * t, this.width * e, this.height * t);
  }, i.prototype.toGlobalToRef = function(e, t, r) {
    return r.x = this.x * e, r.y = this.y * t, r.width = this.width * e, r.height = this.height * t, this;
  }, i.prototype.clone = function() {
    return new i(this.x, this.y, this.width, this.height);
  }, i;
}(), De = function(i) {
  K(e, i);
  function e(t, r, n, a) {
    a === void 0 && (a = !0);
    var s = i.call(this, t, n) || this;
    return s._position = b.Zero(), s._upVector = b.Up(), s.orthoLeft = null, s.orthoRight = null, s.orthoBottom = null, s.orthoTop = null, s.fov = 0.8, s.projectionPlaneTilt = 0, s.minZ = 1, s.maxZ = 1e4, s.inertia = 0.9, s.mode = e.PERSPECTIVE_CAMERA, s.isIntermediate = !1, s.viewport = new Ma(0, 0, 1, 1), s.layerMask = 268435455, s.fovMode = e.FOVMODE_VERTICAL_FIXED, s.cameraRigMode = e.RIG_MODE_NONE, s.customRenderTargets = new Array(), s.outputRenderTarget = null, s.onViewMatrixChangedObservable = new O(), s.onProjectionMatrixChangedObservable = new O(), s.onAfterCheckInputsObservable = new O(), s.onRestoreStateObservable = new O(), s.isRigCamera = !1, s._rigCameras = new Array(), s._webvrViewMatrix = I.Identity(), s._skipRendering = !1, s._projectionMatrix = new I(), s._postProcesses = new Array(), s._activeMeshes = new ke(256), s._globalPosition = b.Zero(), s._computedViewMatrix = I.Identity(), s._doNotComputeProjectionMatrix = !1, s._transformMatrix = I.Zero(), s._refreshFrustumPlanes = !0, s._absoluteRotation = ie.Identity(), s._isCamera = !0, s._isLeftCamera = !1, s._isRightCamera = !1, s.getScene().addCamera(s), a && !s.getScene().activeCamera && (s.getScene().activeCamera = s), s.position = r, s.renderPassId = s.getScene().getEngine().createRenderPassId("Camera ".concat(t)), s;
  }
  return Object.defineProperty(e.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(t) {
      this._position = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "upVector", {
    get: function() {
      return this._upVector;
    },
    set: function(t) {
      this._upVector = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "screenArea", {
    get: function() {
      var t, r, n, a, s = 0, o = 0;
      if (this.mode === e.PERSPECTIVE_CAMERA)
        this.fovMode === e.FOVMODE_VERTICAL_FIXED ? (o = this.minZ * 2 * Math.tan(this.fov / 2), s = this.getEngine().getAspectRatio(this) * o) : (s = this.minZ * 2 * Math.tan(this.fov / 2), o = s / this.getEngine().getAspectRatio(this));
      else {
        var u = this.getEngine().getRenderWidth() / 2, f = this.getEngine().getRenderHeight() / 2;
        s = ((t = this.orthoRight) !== null && t !== void 0 ? t : u) - ((r = this.orthoLeft) !== null && r !== void 0 ? r : -u), o = ((n = this.orthoTop) !== null && n !== void 0 ? n : f) - ((a = this.orthoBottom) !== null && a !== void 0 ? a : -f);
      }
      return s * o;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.storeState = function() {
    return this._stateStored = !0, this._storedFov = this.fov, this;
  }, e.prototype._restoreStateValues = function() {
    return this._stateStored ? (this.fov = this._storedFov, !0) : !1;
  }, e.prototype.restoreState = function() {
    return this._restoreStateValues() ? (this.onRestoreStateObservable.notifyObservers(this), !0) : !1;
  }, e.prototype.getClassName = function() {
    return "Camera";
  }, e.prototype.toString = function(t) {
    var r = "Name: " + this.name;
    if (r += ", type: " + this.getClassName(), this.animations)
      for (var n = 0; n < this.animations.length; n++)
        r += ", animation[0]: " + this.animations[n].toString(t);
    return r;
  }, e.prototype.applyVerticalCorrection = function() {
    var t = this.absoluteRotation.toEulerAngles();
    this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -t.x : t.x;
  }, Object.defineProperty(e.prototype, "globalPosition", {
    get: function() {
      return this._globalPosition;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getActiveMeshes = function() {
    return this._activeMeshes;
  }, e.prototype.isActiveMesh = function(t) {
    return this._activeMeshes.indexOf(t) !== -1;
  }, e.prototype.isReady = function(t) {
    if (t === void 0 && (t = !1), t)
      for (var r = 0, n = this._postProcesses; r < n.length; r++) {
        var a = n[r];
        if (a && !a.isReady())
          return !1;
      }
    return i.prototype.isReady.call(this, t);
  }, e.prototype._initCache = function() {
    i.prototype._initCache.call(this), this._cache.position = new b(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.upVector = new b(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.mode = void 0, this._cache.minZ = void 0, this._cache.maxZ = void 0, this._cache.fov = void 0, this._cache.fovMode = void 0, this._cache.aspectRatio = void 0, this._cache.orthoLeft = void 0, this._cache.orthoRight = void 0, this._cache.orthoBottom = void 0, this._cache.orthoTop = void 0, this._cache.renderWidth = void 0, this._cache.renderHeight = void 0;
  }, e.prototype._updateCache = function(t) {
    t || i.prototype._updateCache.call(this), this._cache.position.copyFrom(this.position), this._cache.upVector.copyFrom(this.upVector);
  }, e.prototype._isSynchronized = function() {
    return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
  }, e.prototype._isSynchronizedViewMatrix = function() {
    return i.prototype._isSynchronized.call(this) ? this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent() : !1;
  }, e.prototype._isSynchronizedProjectionMatrix = function() {
    var t = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
    if (!t)
      return !1;
    var r = this.getEngine();
    return this.mode === e.PERSPECTIVE_CAMERA ? t = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === r.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt : t = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === r.getRenderWidth() && this._cache.renderHeight === r.getRenderHeight(), t;
  }, e.prototype.attachControl = function(t, r) {
  }, e.prototype.detachControl = function(t) {
  }, e.prototype.update = function() {
    this._checkInputs(), this.cameraRigMode !== e.RIG_MODE_NONE && this._updateRigCameras();
  }, e.prototype._checkInputs = function() {
    this.onAfterCheckInputsObservable.notifyObservers(this);
  }, Object.defineProperty(e.prototype, "rigCameras", {
    get: function() {
      return this._rigCameras;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "rigPostProcess", {
    get: function() {
      return this._rigPostProcess;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._getFirstPostProcess = function() {
    for (var t = 0; t < this._postProcesses.length; t++)
      if (this._postProcesses[t] !== null)
        return this._postProcesses[t];
    return null;
  }, e.prototype._cascadePostProcessesToRigCams = function() {
    var t = this._getFirstPostProcess();
    t && t.markTextureDirty();
    for (var r = 0, n = this._rigCameras.length; r < n; r++) {
      var a = this._rigCameras[r], s = a._rigPostProcess;
      if (s) {
        var o = s.getEffectName() === "pass";
        o && (a.isIntermediate = this._postProcesses.length === 0), a._postProcesses = this._postProcesses.slice(0).concat(s), s.markTextureDirty();
      } else
        a._postProcesses = this._postProcesses.slice(0);
    }
  }, e.prototype.attachPostProcess = function(t, r) {
    return r === void 0 && (r = null), !t.isReusable() && this._postProcesses.indexOf(t) > -1 ? (k.Error("You're trying to reuse a post process not defined as reusable."), 0) : (r == null || r < 0 ? this._postProcesses.push(t) : this._postProcesses[r] === null ? this._postProcesses[r] = t : this._postProcesses.splice(r, 0, t), this._cascadePostProcessesToRigCams(), this._scene.prePassRenderer && this._scene.prePassRenderer.markAsDirty(), this._postProcesses.indexOf(t));
  }, e.prototype.detachPostProcess = function(t) {
    var r = this._postProcesses.indexOf(t);
    r !== -1 && (this._postProcesses[r] = null), this._scene.prePassRenderer && this._scene.prePassRenderer.markAsDirty(), this._cascadePostProcessesToRigCams();
  }, e.prototype.getWorldMatrix = function() {
    return this._isSynchronizedViewMatrix() ? this._worldMatrix : (this.getViewMatrix(), this._worldMatrix);
  }, e.prototype._getViewMatrix = function() {
    return I.Identity();
  }, e.prototype.getViewMatrix = function(t) {
    return !t && this._isSynchronizedViewMatrix() ? this._computedViewMatrix : (this.updateCache(), this._computedViewMatrix = this._getViewMatrix(), this._currentRenderId = this.getScene().getRenderId(), this._childUpdateId++, this._refreshFrustumPlanes = !0, this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix && this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix), this.parent && this.parent.onViewMatrixChangedObservable && this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent), this.onViewMatrixChangedObservable.notifyObservers(this), this._computedViewMatrix.invertToRef(this._worldMatrix), this._computedViewMatrix);
  }, e.prototype.freezeProjectionMatrix = function(t) {
    this._doNotComputeProjectionMatrix = !0, t !== void 0 && (this._projectionMatrix = t);
  }, e.prototype.unfreezeProjectionMatrix = function() {
    this._doNotComputeProjectionMatrix = !1;
  }, e.prototype.getProjectionMatrix = function(t) {
    var r, n, a, s, o, u, f, l;
    if (this._doNotComputeProjectionMatrix || !t && this._isSynchronizedProjectionMatrix())
      return this._projectionMatrix;
    this._cache.mode = this.mode, this._cache.minZ = this.minZ, this._cache.maxZ = this.maxZ, this._refreshFrustumPlanes = !0;
    var h = this.getEngine(), c = this.getScene();
    if (this.mode === e.PERSPECTIVE_CAMERA) {
      this._cache.fov = this.fov, this._cache.fovMode = this.fovMode, this._cache.aspectRatio = h.getAspectRatio(this), this._cache.projectionPlaneTilt = this.projectionPlaneTilt, this.minZ <= 0 && (this.minZ = 0.1);
      var d = h.useReverseDepthBuffer, p = void 0;
      c.useRightHandedSystem ? p = I.PerspectiveFovRHToRef : p = I.PerspectiveFovLHToRef, p(this.fov, h.getAspectRatio(this), d ? this.maxZ : this.minZ, d ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === e.FOVMODE_VERTICAL_FIXED, h.isNDCHalfZRange, this.projectionPlaneTilt, h.useReverseDepthBuffer);
    } else {
      var g = h.getRenderWidth() / 2, _ = h.getRenderHeight() / 2;
      c.useRightHandedSystem ? I.OrthoOffCenterRHToRef((r = this.orthoLeft) !== null && r !== void 0 ? r : -g, (n = this.orthoRight) !== null && n !== void 0 ? n : g, (a = this.orthoBottom) !== null && a !== void 0 ? a : -_, (s = this.orthoTop) !== null && s !== void 0 ? s : _, this.minZ, this.maxZ, this._projectionMatrix, h.isNDCHalfZRange) : I.OrthoOffCenterLHToRef((o = this.orthoLeft) !== null && o !== void 0 ? o : -g, (u = this.orthoRight) !== null && u !== void 0 ? u : g, (f = this.orthoBottom) !== null && f !== void 0 ? f : -_, (l = this.orthoTop) !== null && l !== void 0 ? l : _, this.minZ, this.maxZ, this._projectionMatrix, h.isNDCHalfZRange), this._cache.orthoLeft = this.orthoLeft, this._cache.orthoRight = this.orthoRight, this._cache.orthoBottom = this.orthoBottom, this._cache.orthoTop = this.orthoTop, this._cache.renderWidth = h.getRenderWidth(), this._cache.renderHeight = h.getRenderHeight();
    }
    return this.onProjectionMatrixChangedObservable.notifyObservers(this), this._projectionMatrix;
  }, e.prototype.getTransformationMatrix = function() {
    return this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._transformMatrix;
  }, e.prototype._updateFrustumPlanes = function() {
    !this._refreshFrustumPlanes || (this.getTransformationMatrix(), this._frustumPlanes ? Pr.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = Pr.GetPlanes(this._transformMatrix), this._refreshFrustumPlanes = !1);
  }, e.prototype.isInFrustum = function(t, r) {
    if (r === void 0 && (r = !1), this._updateFrustumPlanes(), r && this.rigCameras.length > 0) {
      var n = !1;
      return this.rigCameras.forEach(function(a) {
        a._updateFrustumPlanes(), n = n || t.isInFrustum(a._frustumPlanes);
      }), n;
    } else
      return t.isInFrustum(this._frustumPlanes);
  }, e.prototype.isCompletelyInFrustum = function(t) {
    return this._updateFrustumPlanes(), t.isCompletelyInFrustum(this._frustumPlanes);
  }, e.prototype.getForwardRay = function(t, r, n) {
    throw G("Ray");
  }, e.prototype.getForwardRayToRef = function(t, r, n, a) {
    throw G("Ray");
  }, e.prototype.dispose = function(t, r) {
    for (r === void 0 && (r = !1), this.onViewMatrixChangedObservable.clear(), this.onProjectionMatrixChangedObservable.clear(), this.onAfterCheckInputsObservable.clear(), this.onRestoreStateObservable.clear(), this.inputs && this.inputs.clear(), this.getScene().stopAnimation(this), this.getScene().removeCamera(this); this._rigCameras.length > 0; ) {
      var n = this._rigCameras.pop();
      n && n.dispose();
    }
    if (this._parentContainer) {
      var a = this._parentContainer.cameras.indexOf(this);
      a > -1 && this._parentContainer.cameras.splice(a, 1), this._parentContainer = null;
    }
    if (this._rigPostProcess)
      this._rigPostProcess.dispose(this), this._rigPostProcess = null, this._postProcesses = [];
    else if (this.cameraRigMode !== e.RIG_MODE_NONE)
      this._rigPostProcess = null, this._postProcesses = [];
    else
      for (var s = this._postProcesses.length; --s >= 0; ) {
        var o = this._postProcesses[s];
        o && o.dispose(this);
      }
    for (var u = this.customRenderTargets.length; --u >= 0; )
      this.customRenderTargets[u].dispose();
    this.customRenderTargets = [], this._activeMeshes.dispose(), this.getScene().getEngine().releaseRenderPassId(this.renderPassId), i.prototype.dispose.call(this, t, r);
  }, Object.defineProperty(e.prototype, "isLeftCamera", {
    get: function() {
      return this._isLeftCamera;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "isRightCamera", {
    get: function() {
      return this._isRightCamera;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "leftCamera", {
    get: function() {
      return this._rigCameras.length < 1 ? null : this._rigCameras[0];
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "rightCamera", {
    get: function() {
      return this._rigCameras.length < 2 ? null : this._rigCameras[1];
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getLeftTarget = function() {
    return this._rigCameras.length < 1 ? null : this._rigCameras[0].getTarget();
  }, e.prototype.getRightTarget = function() {
    return this._rigCameras.length < 2 ? null : this._rigCameras[1].getTarget();
  }, e.prototype.setCameraRigMode = function(t, r) {
    if (this.cameraRigMode !== t) {
      for (; this._rigCameras.length > 0; ) {
        var n = this._rigCameras.pop();
        n && n.dispose();
      }
      if (this.cameraRigMode = t, this._cameraRigParams = {}, this._cameraRigParams.interaxialDistance = r.interaxialDistance || 0.0637, this._cameraRigParams.stereoHalfAngle = de.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637), this.cameraRigMode !== e.RIG_MODE_NONE) {
        var a = this.createRigCamera(this.name + "_L", 0);
        a && (a._isLeftCamera = !0);
        var s = this.createRigCamera(this.name + "_R", 1);
        s && (s._isRightCamera = !0), a && s && (this._rigCameras.push(a), this._rigCameras.push(s));
      }
      this._setRigMode(r), this._cascadePostProcessesToRigCams(), this.update();
    }
  }, e.prototype._setRigMode = function(t) {
  }, e.prototype._getVRProjectionMatrix = function() {
    return I.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, !0, this.getEngine().isNDCHalfZRange), this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix), this._projectionMatrix;
  }, e.prototype._updateCameraRotationMatrix = function() {
  }, e.prototype._updateWebVRCameraRotationMatrix = function() {
  }, e.prototype._getWebVRProjectionMatrix = function() {
    return I.Identity();
  }, e.prototype._getWebVRViewMatrix = function() {
    return I.Identity();
  }, e.prototype.setCameraRigParameter = function(t, r) {
    this._cameraRigParams || (this._cameraRigParams = {}), this._cameraRigParams[t] = r, t === "interaxialDistance" && (this._cameraRigParams.stereoHalfAngle = de.ToRadians(r / 0.0637));
  }, e.prototype.createRigCamera = function(t, r) {
    return null;
  }, e.prototype._updateRigCameras = function() {
    for (var t = 0; t < this._rigCameras.length; t++)
      this._rigCameras[t].minZ = this.minZ, this._rigCameras[t].maxZ = this.maxZ, this._rigCameras[t].fov = this.fov, this._rigCameras[t].upVector.copyFrom(this.upVector);
    this.cameraRigMode === e.RIG_MODE_STEREOSCOPIC_ANAGLYPH && (this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport);
  }, e.prototype._setupInputs = function() {
  }, e.prototype.serialize = function() {
    var t = $.Serialize(this);
    return t.uniqueId = this.uniqueId, t.type = this.getClassName(), this.parent && (t.parentId = this.parent.uniqueId), this.inputs && this.inputs.serialize(t), $.AppendSerializedAnimations(this, t), t.ranges = this.serializeAnimationRanges(), t.isEnabled = this.isEnabled(), t;
  }, e.prototype.clone = function(t, r) {
    r === void 0 && (r = null);
    var n = $.Clone(e.GetConstructorFromName(this.getClassName(), t, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
    return n.name = t, n.parent = r, this.onClonedObservable.notifyObservers(n), n;
  }, e.prototype.getDirection = function(t) {
    var r = b.Zero();
    return this.getDirectionToRef(t, r), r;
  }, Object.defineProperty(e.prototype, "absoluteRotation", {
    get: function() {
      return this.getWorldMatrix().decompose(void 0, this._absoluteRotation), this._absoluteRotation;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getDirectionToRef = function(t, r) {
    b.TransformNormalToRef(t, this.getWorldMatrix(), r);
  }, e.GetConstructorFromName = function(t, r, n, a, s) {
    a === void 0 && (a = 0), s === void 0 && (s = !0);
    var o = Je.Construct(t, r, n, {
      interaxial_distance: a,
      isStereoscopicSideBySide: s
    });
    return o || function() {
      return e._CreateDefaultParsedCamera(r, n);
    };
  }, e.prototype.computeWorldMatrix = function() {
    return this.getWorldMatrix();
  }, e.Parse = function(t, r) {
    var n = t.type, a = e.GetConstructorFromName(n, t.name, r, t.interaxial_distance, t.isStereoscopicSideBySide), s = $.Parse(a, t, r);
    if (t.parentId !== void 0 && (s._waitingParentId = t.parentId), s.inputs && (s.inputs.parse(t), s._setupInputs()), t.upVector && (s.upVector = b.FromArray(t.upVector)), s.setPosition && (s.position.copyFromFloats(0, 0, 0), s.setPosition(b.FromArray(t.position))), t.target && s.setTarget && s.setTarget(b.FromArray(t.target)), t.cameraRigMode) {
      var o = t.interaxial_distance ? { interaxialDistance: t.interaxial_distance } : {};
      s.setCameraRigMode(t.cameraRigMode, o);
    }
    if (t.animations) {
      for (var u = 0; u < t.animations.length; u++) {
        var f = t.animations[u], l = Ct("BABYLON.Animation");
        l && s.animations.push(l.Parse(f));
      }
      Je.ParseAnimationRanges(s, t, r);
    }
    return t.autoAnimate && r.beginAnimation(s, t.autoAnimateFrom, t.autoAnimateTo, t.autoAnimateLoop, t.autoAnimateSpeed || 1), t.isEnabled !== void 0 && s.setEnabled(t.isEnabled), s;
  }, e._CreateDefaultParsedCamera = function(t, r) {
    throw G("UniversalCamera");
  }, e.PERSPECTIVE_CAMERA = 0, e.ORTHOGRAPHIC_CAMERA = 1, e.FOVMODE_VERTICAL_FIXED = 0, e.FOVMODE_HORIZONTAL_FIXED = 1, e.RIG_MODE_NONE = 0, e.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10, e.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11, e.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12, e.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13, e.RIG_MODE_STEREOSCOPIC_INTERLACED = 14, e.RIG_MODE_VR = 20, e.RIG_MODE_WEBVR = 21, e.RIG_MODE_CUSTOM = 22, e.ForceAttachControlToAlwaysPreventDefault = !1, T([
    dt("position")
  ], e.prototype, "_position", void 0), T([
    dt("upVector")
  ], e.prototype, "_upVector", void 0), T([
    P()
  ], e.prototype, "orthoLeft", void 0), T([
    P()
  ], e.prototype, "orthoRight", void 0), T([
    P()
  ], e.prototype, "orthoBottom", void 0), T([
    P()
  ], e.prototype, "orthoTop", void 0), T([
    P()
  ], e.prototype, "fov", void 0), T([
    P()
  ], e.prototype, "projectionPlaneTilt", void 0), T([
    P()
  ], e.prototype, "minZ", void 0), T([
    P()
  ], e.prototype, "maxZ", void 0), T([
    P()
  ], e.prototype, "inertia", void 0), T([
    P()
  ], e.prototype, "mode", void 0), T([
    P()
  ], e.prototype, "layerMask", void 0), T([
    P()
  ], e.prototype, "fovMode", void 0), T([
    P()
  ], e.prototype, "cameraRigMode", void 0), T([
    P()
  ], e.prototype, "interaxialDistance", void 0), T([
    P()
  ], e.prototype, "isStereoscopicSideBySide", void 0), e;
}(Je), $e = function(i) {
  K(e, i);
  function e(t, r) {
    var n = i.call(this, t, r) || this;
    return n.diffuse = new ye(1, 1, 1), n.specular = new ye(1, 1, 1), n.falloffType = e.FALLOFF_DEFAULT, n.intensity = 1, n._range = Number.MAX_VALUE, n._inverseSquaredRange = 0, n._photometricScale = 1, n._intensityMode = e.INTENSITYMODE_AUTOMATIC, n._radius = 1e-5, n.renderPriority = 0, n._shadowEnabled = !0, n._excludeWithLayerMask = 0, n._includeOnlyWithLayerMask = 0, n._lightmapMode = 0, n._excludedMeshesIds = new Array(), n._includedOnlyMeshesIds = new Array(), n._isLight = !0, n.getScene().addLight(n), n._uniformBuffer = new wr(n.getScene().getEngine(), void 0, void 0, t), n._buildUniformLayout(), n.includedOnlyMeshes = new Array(), n.excludedMeshes = new Array(), n._resyncMeshes(), n;
  }
  return Object.defineProperty(e.prototype, "range", {
    get: function() {
      return this._range;
    },
    set: function(t) {
      this._range = t, this._inverseSquaredRange = 1 / (this.range * this.range);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "intensityMode", {
    get: function() {
      return this._intensityMode;
    },
    set: function(t) {
      this._intensityMode = t, this._computePhotometricScale();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "radius", {
    get: function() {
      return this._radius;
    },
    set: function(t) {
      this._radius = t, this._computePhotometricScale();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "shadowEnabled", {
    get: function() {
      return this._shadowEnabled;
    },
    set: function(t) {
      this._shadowEnabled !== t && (this._shadowEnabled = t, this._markMeshesAsLightDirty());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "includedOnlyMeshes", {
    get: function() {
      return this._includedOnlyMeshes;
    },
    set: function(t) {
      this._includedOnlyMeshes = t, this._hookArrayForIncludedOnly(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "excludedMeshes", {
    get: function() {
      return this._excludedMeshes;
    },
    set: function(t) {
      this._excludedMeshes = t, this._hookArrayForExcluded(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "excludeWithLayerMask", {
    get: function() {
      return this._excludeWithLayerMask;
    },
    set: function(t) {
      this._excludeWithLayerMask = t, this._resyncMeshes();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "includeOnlyWithLayerMask", {
    get: function() {
      return this._includeOnlyWithLayerMask;
    },
    set: function(t) {
      this._includeOnlyWithLayerMask = t, this._resyncMeshes();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "lightmapMode", {
    get: function() {
      return this._lightmapMode;
    },
    set: function(t) {
      this._lightmapMode !== t && (this._lightmapMode = t, this._markMeshesAsLightDirty());
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.transferTexturesToEffect = function(t, r) {
    return this;
  }, e.prototype._bindLight = function(t, r, n, a, s) {
    s === void 0 && (s = !0);
    var o = t.toString(), u = !1;
    if (this._uniformBuffer.bindToEffect(n, "Light" + o), this._renderId !== r.getRenderId() || this._lastUseSpecular !== a || !this._uniformBuffer.useUbo) {
      this._renderId = r.getRenderId(), this._lastUseSpecular = a;
      var f = this.getScaledIntensity();
      this.transferToEffect(n, o), this.diffuse.scaleToRef(f, cr.Color3[0]), this._uniformBuffer.updateColor4("vLightDiffuse", cr.Color3[0], this.range, o), a && (this.specular.scaleToRef(f, cr.Color3[1]), this._uniformBuffer.updateColor4("vLightSpecular", cr.Color3[1], this.radius, o)), u = !0;
    }
    if (this.transferTexturesToEffect(n, o), r.shadowsEnabled && this.shadowEnabled && s) {
      var l = this.getShadowGenerator();
      l && (l.bindShadowLight(o, n), u = !0);
    }
    u ? this._uniformBuffer.update() : this._uniformBuffer.bindUniformBuffer();
  }, e.prototype.getClassName = function() {
    return "Light";
  }, e.prototype.toString = function(t) {
    var r = "Name: " + this.name;
    if (r += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()], this.animations)
      for (var n = 0; n < this.animations.length; n++)
        r += ", animation[0]: " + this.animations[n].toString(t);
    return r;
  }, e.prototype._syncParentEnabledState = function() {
    i.prototype._syncParentEnabledState.call(this), this.isDisposed() || this._resyncMeshes();
  }, e.prototype.setEnabled = function(t) {
    i.prototype.setEnabled.call(this, t), this._resyncMeshes();
  }, e.prototype.getShadowGenerator = function() {
    return this._shadowGenerator;
  }, e.prototype.getAbsolutePosition = function() {
    return b.Zero();
  }, e.prototype.canAffectMesh = function(t) {
    return t ? !(this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(t) === -1 || this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(t) !== -1 || this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & t.layerMask) === 0 || this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & t.layerMask) : !0;
  }, e.prototype.dispose = function(t, r) {
    if (r === void 0 && (r = !1), this._shadowGenerator && (this._shadowGenerator.dispose(), this._shadowGenerator = null), this.getScene().stopAnimation(this), this._parentContainer) {
      var n = this._parentContainer.lights.indexOf(this);
      n > -1 && this._parentContainer.lights.splice(n, 1), this._parentContainer = null;
    }
    for (var a = 0, s = this.getScene().meshes; a < s.length; a++) {
      var o = s[a];
      o._removeLightSource(this, !0);
    }
    this._uniformBuffer.dispose(), this.getScene().removeLight(this), i.prototype.dispose.call(this, t, r);
  }, e.prototype.getTypeID = function() {
    return 0;
  }, e.prototype.getScaledIntensity = function() {
    return this._photometricScale * this.intensity;
  }, e.prototype.clone = function(t, r) {
    r === void 0 && (r = null);
    var n = e.GetConstructorFromName(this.getTypeID(), t, this.getScene());
    if (!n)
      return null;
    var a = $.Clone(n, this);
    return t && (a.name = t), r && (a.parent = r), a.setEnabled(this.isEnabled()), this.onClonedObservable.notifyObservers(a), a;
  }, e.prototype.serialize = function() {
    var t = $.Serialize(this);
    return t.uniqueId = this.uniqueId, t.type = this.getTypeID(), this.parent && (t.parentId = this.parent.uniqueId), this.excludedMeshes.length > 0 && (t.excludedMeshesIds = [], this.excludedMeshes.forEach(function(r) {
      t.excludedMeshesIds.push(r.id);
    })), this.includedOnlyMeshes.length > 0 && (t.includedOnlyMeshesIds = [], this.includedOnlyMeshes.forEach(function(r) {
      t.includedOnlyMeshesIds.push(r.id);
    })), $.AppendSerializedAnimations(this, t), t.ranges = this.serializeAnimationRanges(), t.isEnabled = this.isEnabled(), t;
  }, e.GetConstructorFromName = function(t, r, n) {
    var a = Je.Construct("Light_Type_" + t, r, n);
    return a || null;
  }, e.Parse = function(t, r) {
    var n = e.GetConstructorFromName(t.type, t.name, r);
    if (!n)
      return null;
    var a = $.Parse(n, t, r);
    if (t.excludedMeshesIds && (a._excludedMeshesIds = t.excludedMeshesIds), t.includedOnlyMeshesIds && (a._includedOnlyMeshesIds = t.includedOnlyMeshesIds), t.parentId !== void 0 && (a._waitingParentId = t.parentId), t.falloffType !== void 0 && (a.falloffType = t.falloffType), t.lightmapMode !== void 0 && (a.lightmapMode = t.lightmapMode), t.animations) {
      for (var s = 0; s < t.animations.length; s++) {
        var o = t.animations[s], u = Ct("BABYLON.Animation");
        u && a.animations.push(u.Parse(o));
      }
      Je.ParseAnimationRanges(a, t, r);
    }
    return t.autoAnimate && r.beginAnimation(a, t.autoAnimateFrom, t.autoAnimateTo, t.autoAnimateLoop, t.autoAnimateSpeed || 1), t.isEnabled !== void 0 && a.setEnabled(t.isEnabled), a;
  }, e.prototype._hookArrayForExcluded = function(t) {
    var r = this, n = t.push;
    t.push = function() {
      for (var f = [], l = 0; l < arguments.length; l++)
        f[l] = arguments[l];
      for (var h = n.apply(t, f), c = 0, d = f; c < d.length; c++) {
        var p = d[c];
        p._resyncLightSource(r);
      }
      return h;
    };
    var a = t.splice;
    t.splice = function(f, l) {
      for (var h = a.apply(t, [f, l]), c = 0, d = h; c < d.length; c++) {
        var p = d[c];
        p._resyncLightSource(r);
      }
      return h;
    };
    for (var s = 0, o = t; s < o.length; s++) {
      var u = o[s];
      u._resyncLightSource(this);
    }
  }, e.prototype._hookArrayForIncludedOnly = function(t) {
    var r = this, n = t.push;
    t.push = function() {
      for (var s = [], o = 0; o < arguments.length; o++)
        s[o] = arguments[o];
      var u = n.apply(t, s);
      return r._resyncMeshes(), u;
    };
    var a = t.splice;
    t.splice = function(s, o) {
      var u = a.apply(t, [s, o]);
      return r._resyncMeshes(), u;
    }, this._resyncMeshes();
  }, e.prototype._resyncMeshes = function() {
    for (var t = 0, r = this.getScene().meshes; t < r.length; t++) {
      var n = r[t];
      n._resyncLightSource(this);
    }
  }, e.prototype._markMeshesAsLightDirty = function() {
    for (var t = 0, r = this.getScene().meshes; t < r.length; t++) {
      var n = r[t];
      n.lightSources.indexOf(this) !== -1 && n._markSubMeshesAsLightDirty();
    }
  }, e.prototype._computePhotometricScale = function() {
    this._photometricScale = this._getPhotometricScale(), this.getScene().resetCachedMaterial();
  }, e.prototype._getPhotometricScale = function() {
    var t = 0, r = this.getTypeID(), n = this.intensityMode;
    switch (n === e.INTENSITYMODE_AUTOMATIC && (r === e.LIGHTTYPEID_DIRECTIONALLIGHT ? n = e.INTENSITYMODE_ILLUMINANCE : n = e.INTENSITYMODE_LUMINOUSINTENSITY), r) {
      case e.LIGHTTYPEID_POINTLIGHT:
      case e.LIGHTTYPEID_SPOTLIGHT:
        switch (n) {
          case e.INTENSITYMODE_LUMINOUSPOWER:
            t = 1 / (4 * Math.PI);
            break;
          case e.INTENSITYMODE_LUMINOUSINTENSITY:
            t = 1;
            break;
          case e.INTENSITYMODE_LUMINANCE:
            t = this.radius * this.radius;
            break;
        }
        break;
      case e.LIGHTTYPEID_DIRECTIONALLIGHT:
        switch (n) {
          case e.INTENSITYMODE_ILLUMINANCE:
            t = 1;
            break;
          case e.INTENSITYMODE_LUMINANCE: {
            var a = this.radius;
            a = Math.max(a, 1e-3);
            var s = 2 * Math.PI * (1 - Math.cos(a));
            t = s;
            break;
          }
        }
        break;
      case e.LIGHTTYPEID_HEMISPHERICLIGHT:
        t = 1;
        break;
    }
    return t;
  }, e.prototype._reorderLightsInScene = function() {
    var t = this.getScene();
    this._renderPriority != 0 && (t.requireLightSorting = !0), this.getScene().sortLightsByPriority();
  }, e.FALLOFF_DEFAULT = Re.FALLOFF_DEFAULT, e.FALLOFF_PHYSICAL = Re.FALLOFF_PHYSICAL, e.FALLOFF_GLTF = Re.FALLOFF_GLTF, e.FALLOFF_STANDARD = Re.FALLOFF_STANDARD, e.LIGHTMAP_DEFAULT = Re.LIGHTMAP_DEFAULT, e.LIGHTMAP_SPECULAR = Re.LIGHTMAP_SPECULAR, e.LIGHTMAP_SHADOWSONLY = Re.LIGHTMAP_SHADOWSONLY, e.INTENSITYMODE_AUTOMATIC = Re.INTENSITYMODE_AUTOMATIC, e.INTENSITYMODE_LUMINOUSPOWER = Re.INTENSITYMODE_LUMINOUSPOWER, e.INTENSITYMODE_LUMINOUSINTENSITY = Re.INTENSITYMODE_LUMINOUSINTENSITY, e.INTENSITYMODE_ILLUMINANCE = Re.INTENSITYMODE_ILLUMINANCE, e.INTENSITYMODE_LUMINANCE = Re.INTENSITYMODE_LUMINANCE, e.LIGHTTYPEID_POINTLIGHT = Re.LIGHTTYPEID_POINTLIGHT, e.LIGHTTYPEID_DIRECTIONALLIGHT = Re.LIGHTTYPEID_DIRECTIONALLIGHT, e.LIGHTTYPEID_SPOTLIGHT = Re.LIGHTTYPEID_SPOTLIGHT, e.LIGHTTYPEID_HEMISPHERICLIGHT = Re.LIGHTTYPEID_HEMISPHERICLIGHT, T([
    At()
  ], e.prototype, "diffuse", void 0), T([
    At()
  ], e.prototype, "specular", void 0), T([
    P()
  ], e.prototype, "falloffType", void 0), T([
    P()
  ], e.prototype, "intensity", void 0), T([
    P()
  ], e.prototype, "range", null), T([
    P()
  ], e.prototype, "intensityMode", null), T([
    P()
  ], e.prototype, "radius", null), T([
    P()
  ], e.prototype, "_renderPriority", void 0), T([
    ne("_reorderLightsInScene")
  ], e.prototype, "renderPriority", void 0), T([
    P("shadowEnabled")
  ], e.prototype, "_shadowEnabled", void 0), T([
    P("excludeWithLayerMask")
  ], e.prototype, "_excludeWithLayerMask", void 0), T([
    P("includeOnlyWithLayerMask")
  ], e.prototype, "_includeOnlyWithLayerMask", void 0), T([
    P("lightmapMode")
  ], e.prototype, "_lightmapMode", void 0), e;
}(Je), Aa = function() {
  function i() {
  }
  return i.BindClipPlane = function(e, t) {
    if (t.clipPlane) {
      var r = t.clipPlane;
      e.setFloat4("vClipPlane", r.normal.x, r.normal.y, r.normal.z, r.d);
    }
    if (t.clipPlane2) {
      var r = t.clipPlane2;
      e.setFloat4("vClipPlane2", r.normal.x, r.normal.y, r.normal.z, r.d);
    }
    if (t.clipPlane3) {
      var r = t.clipPlane3;
      e.setFloat4("vClipPlane3", r.normal.x, r.normal.y, r.normal.z, r.d);
    }
    if (t.clipPlane4) {
      var r = t.clipPlane4;
      e.setFloat4("vClipPlane4", r.normal.x, r.normal.y, r.normal.z, r.d);
    }
    if (t.clipPlane5) {
      var r = t.clipPlane5;
      e.setFloat4("vClipPlane5", r.normal.x, r.normal.y, r.normal.z, r.d);
    }
    if (t.clipPlane6) {
      var r = t.clipPlane6;
      e.setFloat4("vClipPlane6", r.normal.x, r.normal.y, r.normal.z, r.d);
    }
  }, i;
}(), j = function() {
  function i() {
  }
  return i.BindSceneUniformBuffer = function(e, t) {
    t.bindToEffect(e, "Scene");
  }, i.PrepareDefinesForMergedUV = function(e, t, r) {
    t._needUVs = !0, t[r] = !0, e.getTextureMatrix().isIdentityAs3x2() ? (t[r + "DIRECTUV"] = e.coordinatesIndex + 1, t["MAINUV" + (e.coordinatesIndex + 1)] = !0) : t[r + "DIRECTUV"] = 0;
  }, i.BindTextureMatrix = function(e, t, r) {
    var n = e.getTextureMatrix();
    t.updateMatrix(r + "Matrix", n);
  }, i.GetFogState = function(e, t) {
    return t.fogEnabled && e.applyFog && t.fogMode !== te.FOGMODE_NONE;
  }, i.PrepareDefinesForMisc = function(e, t, r, n, a, s, o) {
    o._areMiscDirty && (o.LOGARITHMICDEPTH = r, o.POINTSIZE = n, o.FOG = a && this.GetFogState(e, t), o.NONUNIFORMSCALING = e.nonUniformScaling, o.ALPHATEST = s);
  }, i.PrepareDefinesForFrameBoundValues = function(e, t, r, n, a, s) {
    a === void 0 && (a = null), s === void 0 && (s = !1);
    var o = !1, u = !1, f = !1, l = !1, h = !1, c = !1, d = !1;
    u = a == null ? e.clipPlane !== void 0 && e.clipPlane !== null : a, f = a == null ? e.clipPlane2 !== void 0 && e.clipPlane2 !== null : a, l = a == null ? e.clipPlane3 !== void 0 && e.clipPlane3 !== null : a, h = a == null ? e.clipPlane4 !== void 0 && e.clipPlane4 !== null : a, c = a == null ? e.clipPlane5 !== void 0 && e.clipPlane5 !== null : a, d = a == null ? e.clipPlane6 !== void 0 && e.clipPlane6 !== null : a, r.CLIPPLANE !== u && (r.CLIPPLANE = u, o = !0), r.CLIPPLANE2 !== f && (r.CLIPPLANE2 = f, o = !0), r.CLIPPLANE3 !== l && (r.CLIPPLANE3 = l, o = !0), r.CLIPPLANE4 !== h && (r.CLIPPLANE4 = h, o = !0), r.CLIPPLANE5 !== c && (r.CLIPPLANE5 = c, o = !0), r.CLIPPLANE6 !== d && (r.CLIPPLANE6 = d, o = !0), r.DEPTHPREPASS !== !t.getColorWrite() && (r.DEPTHPREPASS = !r.DEPTHPREPASS, o = !0), r.INSTANCES !== n && (r.INSTANCES = n, o = !0), r.INSTANCESCOLOR && !r.INSTANCES && (r.INSTANCESCOLOR = !1, o = !0), r.THIN_INSTANCES !== s && (r.THIN_INSTANCES = s, o = !0), o && r.markAsUnprocessed();
  }, i.PrepareDefinesForBones = function(e, t) {
    if (e.useBones && e.computeBonesUsingShaders && e.skeleton) {
      t.NUM_BONE_INFLUENCERS = e.numBoneInfluencers;
      var r = t.BONETEXTURE !== void 0;
      if (e.skeleton.isUsingTextureForMatrices && r)
        t.BONETEXTURE = !0;
      else {
        t.BonesPerMesh = e.skeleton.bones.length + 1, t.BONETEXTURE = r ? !1 : void 0;
        var n = e.getScene().prePassRenderer;
        if (n && n.enabled) {
          var a = n.excludedSkinnedMesh.indexOf(e) === -1;
          t.BONES_VELOCITY_ENABLED = a;
        }
      }
    } else
      t.NUM_BONE_INFLUENCERS = 0, t.BonesPerMesh = 0;
  }, i.PrepareDefinesForMorphTargets = function(e, t) {
    var r = e.morphTargetManager;
    r ? (t.MORPHTARGETS_UV = r.supportsUVs && t.UV1, t.MORPHTARGETS_TANGENT = r.supportsTangents && t.TANGENT, t.MORPHTARGETS_NORMAL = r.supportsNormals && t.NORMAL, t.MORPHTARGETS = r.numInfluencers > 0, t.NUM_MORPH_INFLUENCERS = r.numInfluencers, t.MORPHTARGETS_TEXTURE = r.isUsingTextureForTargets) : (t.MORPHTARGETS_UV = !1, t.MORPHTARGETS_TANGENT = !1, t.MORPHTARGETS_NORMAL = !1, t.MORPHTARGETS = !1, t.NUM_MORPH_INFLUENCERS = 0);
  }, i.PrepareDefinesForBakedVertexAnimation = function(e, t) {
    var r = e.bakedVertexAnimationManager;
    t.BAKED_VERTEX_ANIMATION_TEXTURE = !!(r && r.isEnabled);
  }, i.PrepareDefinesForAttributes = function(e, t, r, n, a, s, o) {
    if (a === void 0 && (a = !1), s === void 0 && (s = !0), o === void 0 && (o = !0), !t._areAttributesDirty && t._needNormals === t._normals && t._needUVs === t._uvs)
      return !1;
    t._normals = t._needNormals, t._uvs = t._needUVs, t.NORMAL = t._needNormals && e.isVerticesDataPresent(m.NormalKind), t._needNormals && e.isVerticesDataPresent(m.TangentKind) && (t.TANGENT = !0);
    for (var u = 1; u <= 6; ++u)
      t["UV" + u] = t._needUVs ? e.isVerticesDataPresent("uv".concat(u === 1 ? "" : u)) : !1;
    if (r) {
      var f = e.useVertexColors && e.isVerticesDataPresent(m.ColorKind);
      t.VERTEXCOLOR = f, t.VERTEXALPHA = e.hasVertexAlpha && f && s;
    }
    return e.isVerticesDataPresent(m.ColorInstanceKind) && (e.hasInstances || e.hasThinInstances) && (t.INSTANCESCOLOR = !0), n && this.PrepareDefinesForBones(e, t), a && this.PrepareDefinesForMorphTargets(e, t), o && this.PrepareDefinesForBakedVertexAnimation(e, t), !0;
  }, i.PrepareDefinesForMultiview = function(e, t) {
    if (e.activeCamera) {
      var r = t.MULTIVIEW;
      t.MULTIVIEW = e.activeCamera.outputRenderTarget !== null && e.activeCamera.outputRenderTarget.getViewCount() > 1, t.MULTIVIEW != r && t.markAsUnprocessed();
    }
  }, i.PrepareDefinesForOIT = function(e, t, r) {
    var n = t.ORDER_INDEPENDENT_TRANSPARENCY, a = t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;
    t.ORDER_INDEPENDENT_TRANSPARENCY = e.useOrderIndependentTransparency && r, t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !e.getEngine().getCaps().textureFloatLinearFiltering, (n !== t.ORDER_INDEPENDENT_TRANSPARENCY || a !== t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) && t.markAsUnprocessed();
  }, i.PrepareDefinesForPrePass = function(e, t, r) {
    var n = t.PREPASS;
    if (!!t._arePrePassDirty) {
      var a = [
        {
          type: 1,
          define: "PREPASS_POSITION",
          index: "PREPASS_POSITION_INDEX"
        },
        {
          type: 2,
          define: "PREPASS_VELOCITY",
          index: "PREPASS_VELOCITY_INDEX"
        },
        {
          type: 3,
          define: "PREPASS_REFLECTIVITY",
          index: "PREPASS_REFLECTIVITY_INDEX"
        },
        {
          type: 0,
          define: "PREPASS_IRRADIANCE",
          index: "PREPASS_IRRADIANCE_INDEX"
        },
        {
          type: 7,
          define: "PREPASS_ALBEDO_SQRT",
          index: "PREPASS_ALBEDO_SQRT_INDEX"
        },
        {
          type: 5,
          define: "PREPASS_DEPTH",
          index: "PREPASS_DEPTH_INDEX"
        },
        {
          type: 6,
          define: "PREPASS_NORMAL",
          index: "PREPASS_NORMAL_INDEX"
        }
      ];
      if (e.prePassRenderer && e.prePassRenderer.enabled && r) {
        t.PREPASS = !0, t.SCENE_MRT_COUNT = e.prePassRenderer.mrtCount;
        for (var s = 0; s < a.length; s++) {
          var o = e.prePassRenderer.getIndex(a[s].type);
          o !== -1 ? (t[a[s].define] = !0, t[a[s].index] = o) : t[a[s].define] = !1;
        }
      } else {
        t.PREPASS = !1;
        for (var s = 0; s < a.length; s++)
          t[a[s].define] = !1;
      }
      t.PREPASS != n && (t.markAsUnprocessed(), t.markAsImageProcessingDirty());
    }
  }, i.PrepareDefinesForLight = function(e, t, r, n, a, s, o) {
    switch (o.needNormals = !0, a["LIGHT" + n] === void 0 && (o.needRebuild = !0), a["LIGHT" + n] = !0, a["SPOTLIGHT" + n] = !1, a["HEMILIGHT" + n] = !1, a["POINTLIGHT" + n] = !1, a["DIRLIGHT" + n] = !1, r.prepareLightSpecificDefines(a, n), a["LIGHT_FALLOFF_PHYSICAL" + n] = !1, a["LIGHT_FALLOFF_GLTF" + n] = !1, a["LIGHT_FALLOFF_STANDARD" + n] = !1, r.falloffType) {
      case $e.FALLOFF_GLTF:
        a["LIGHT_FALLOFF_GLTF" + n] = !0;
        break;
      case $e.FALLOFF_PHYSICAL:
        a["LIGHT_FALLOFF_PHYSICAL" + n] = !0;
        break;
      case $e.FALLOFF_STANDARD:
        a["LIGHT_FALLOFF_STANDARD" + n] = !0;
        break;
    }
    if (s && !r.specular.equalsFloats(0, 0, 0) && (o.specularEnabled = !0), a["SHADOW" + n] = !1, a["SHADOWCSM" + n] = !1, a["SHADOWCSMDEBUG" + n] = !1, a["SHADOWCSMNUM_CASCADES" + n] = !1, a["SHADOWCSMUSESHADOWMAXZ" + n] = !1, a["SHADOWCSMNOBLEND" + n] = !1, a["SHADOWCSM_RIGHTHANDED" + n] = !1, a["SHADOWPCF" + n] = !1, a["SHADOWPCSS" + n] = !1, a["SHADOWPOISSON" + n] = !1, a["SHADOWESM" + n] = !1, a["SHADOWCLOSEESM" + n] = !1, a["SHADOWCUBE" + n] = !1, a["SHADOWLOWQUALITY" + n] = !1, a["SHADOWMEDIUMQUALITY" + n] = !1, t && t.receiveShadows && e.shadowsEnabled && r.shadowEnabled) {
      var u = r.getShadowGenerator();
      if (u) {
        var f = u.getShadowMap();
        f && f.renderList && f.renderList.length > 0 && (o.shadowEnabled = !0, u.prepareDefines(a, n));
      }
    }
    r.lightmapMode != $e.LIGHTMAP_DEFAULT ? (o.lightmapMode = !0, a["LIGHTMAPEXCLUDED" + n] = !0, a["LIGHTMAPNOSPECULAR" + n] = r.lightmapMode == $e.LIGHTMAP_SHADOWSONLY) : (a["LIGHTMAPEXCLUDED" + n] = !1, a["LIGHTMAPNOSPECULAR" + n] = !1);
  }, i.PrepareDefinesForLights = function(e, t, r, n, a, s) {
    if (a === void 0 && (a = 4), s === void 0 && (s = !1), !r._areLightsDirty)
      return r._needNormals;
    var o = 0, u = {
      needNormals: !1,
      needRebuild: !1,
      lightmapMode: !1,
      shadowEnabled: !1,
      specularEnabled: !1
    };
    if (e.lightsEnabled && !s)
      for (var f = 0, l = t.lightSources; f < l.length; f++) {
        var h = l[f];
        if (this.PrepareDefinesForLight(e, t, h, o, r, n, u), o++, o === a)
          break;
      }
    r.SPECULARTERM = u.specularEnabled, r.SHADOWS = u.shadowEnabled;
    for (var c = o; c < a; c++)
      r["LIGHT" + c] !== void 0 && (r["LIGHT" + c] = !1, r["HEMILIGHT" + c] = !1, r["POINTLIGHT" + c] = !1, r["DIRLIGHT" + c] = !1, r["SPOTLIGHT" + c] = !1, r["SHADOW" + c] = !1, r["SHADOWCSM" + c] = !1, r["SHADOWCSMDEBUG" + c] = !1, r["SHADOWCSMNUM_CASCADES" + c] = !1, r["SHADOWCSMUSESHADOWMAXZ" + c] = !1, r["SHADOWCSMNOBLEND" + c] = !1, r["SHADOWCSM_RIGHTHANDED" + c] = !1, r["SHADOWPCF" + c] = !1, r["SHADOWPCSS" + c] = !1, r["SHADOWPOISSON" + c] = !1, r["SHADOWESM" + c] = !1, r["SHADOWCLOSEESM" + c] = !1, r["SHADOWCUBE" + c] = !1, r["SHADOWLOWQUALITY" + c] = !1, r["SHADOWMEDIUMQUALITY" + c] = !1);
    var d = e.getEngine().getCaps();
    return r.SHADOWFLOAT === void 0 && (u.needRebuild = !0), r.SHADOWFLOAT = u.shadowEnabled && (d.textureFloatRender && d.textureFloatLinearFiltering || d.textureHalfFloatRender && d.textureHalfFloatLinearFiltering), r.LIGHTMAPEXCLUDED = u.lightmapMode, u.needRebuild && r.rebuild(), u.needNormals;
  }, i.PrepareUniformsAndSamplersForLight = function(e, t, r, n, a, s) {
    a === void 0 && (a = null), s === void 0 && (s = !1), a && a.push("Light" + e), !s && (t.push("vLightData" + e, "vLightDiffuse" + e, "vLightSpecular" + e, "vLightDirection" + e, "vLightFalloff" + e, "vLightGround" + e, "lightMatrix" + e, "shadowsInfo" + e, "depthValues" + e), r.push("shadowSampler" + e), r.push("depthSampler" + e), t.push("viewFrustumZ" + e, "cascadeBlendFactor" + e, "lightSizeUVCorrection" + e, "depthCorrection" + e, "penumbraDarkness" + e, "frustumLengths" + e), n && (r.push("projectionLightSampler" + e), t.push("textureProjectionMatrix" + e)));
  }, i.PrepareUniformsAndSamplersList = function(e, t, r, n) {
    n === void 0 && (n = 4);
    var a, s = null;
    if (e.uniformsNames) {
      var o = e;
      a = o.uniformsNames, s = o.uniformBuffersNames, t = o.samplers, r = o.defines, n = o.maxSimultaneousLights || 0;
    } else
      a = e, t || (t = []);
    for (var u = 0; u < n && r["LIGHT" + u]; u++)
      this.PrepareUniformsAndSamplersForLight(u, a, t, r["PROJECTEDLIGHTTEXTURE" + u], s);
    r.NUM_MORPH_INFLUENCERS && a.push("morphTargetInfluences"), r.BAKED_VERTEX_ANIMATION_TEXTURE && (a.push("bakedVertexAnimationSettings"), a.push("bakedVertexAnimationTextureSizeInverted"), a.push("bakedVertexAnimationTime"), t.push("bakedVertexAnimationTexture"));
  }, i.HandleFallbacksForShadows = function(e, t, r, n) {
    r === void 0 && (r = 4), n === void 0 && (n = 0);
    for (var a = 0, s = 0; s < r && e["LIGHT" + s]; s++)
      s > 0 && (a = n + s, t.addFallback(a, "LIGHT" + s)), e.SHADOWS || (e["SHADOW" + s] && t.addFallback(n, "SHADOW" + s), e["SHADOWPCF" + s] && t.addFallback(n, "SHADOWPCF" + s), e["SHADOWPCSS" + s] && t.addFallback(n, "SHADOWPCSS" + s), e["SHADOWPOISSON" + s] && t.addFallback(n, "SHADOWPOISSON" + s), e["SHADOWESM" + s] && t.addFallback(n, "SHADOWESM" + s), e["SHADOWCLOSEESM" + s] && t.addFallback(n, "SHADOWCLOSEESM" + s));
    return a++;
  }, i.PrepareAttributesForMorphTargetsInfluencers = function(e, t, r) {
    this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = r, this.PrepareAttributesForMorphTargets(e, t, this._TmpMorphInfluencers);
  }, i.PrepareAttributesForMorphTargets = function(e, t, r) {
    var n = r.NUM_MORPH_INFLUENCERS;
    if (n > 0 && re.LastCreatedEngine) {
      var a = re.LastCreatedEngine.getCaps().maxVertexAttribs, s = t.morphTargetManager;
      if (s != null && s.isUsingTextureForTargets)
        return;
      for (var o = s && s.supportsNormals && r.NORMAL, u = s && s.supportsTangents && r.TANGENT, f = s && s.supportsUVs && r.UV1, l = 0; l < n; l++)
        e.push(m.PositionKind + l), o && e.push(m.NormalKind + l), u && e.push(m.TangentKind + l), f && e.push(m.UVKind + "_" + l), e.length > a && k.Error("Cannot add more vertex attributes for mesh " + t.name);
    }
  }, i.PrepareAttributesForBakedVertexAnimation = function(e, t, r) {
    var n = r.BAKED_VERTEX_ANIMATION_TEXTURE && r.INSTANCES;
    n && e.push("bakedVertexAnimationSettingsInstanced");
  }, i.PrepareAttributesForBones = function(e, t, r, n) {
    r.NUM_BONE_INFLUENCERS > 0 && (n.addCPUSkinningFallback(0, t), e.push(m.MatricesIndicesKind), e.push(m.MatricesWeightsKind), r.NUM_BONE_INFLUENCERS > 4 && (e.push(m.MatricesIndicesExtraKind), e.push(m.MatricesWeightsExtraKind)));
  }, i.PrepareAttributesForInstances = function(e, t) {
    (t.INSTANCES || t.THIN_INSTANCES) && this.PushAttributesForInstances(e, !!t.PREPASS_VELOCITY), t.INSTANCESCOLOR && e.push(m.ColorInstanceKind);
  }, i.PushAttributesForInstances = function(e, t) {
    t === void 0 && (t = !1), e.push("world0"), e.push("world1"), e.push("world2"), e.push("world3"), t && (e.push("previousWorld0"), e.push("previousWorld1"), e.push("previousWorld2"), e.push("previousWorld3"));
  }, i.BindLightProperties = function(e, t, r) {
    e.transferToEffect(t, r + "");
  }, i.BindLight = function(e, t, r, n, a, s) {
    s === void 0 && (s = !0), e._bindLight(t, r, n, a, s);
  }, i.BindLights = function(e, t, r, n, a) {
    a === void 0 && (a = 4);
    for (var s = Math.min(t.lightSources.length, a), o = 0; o < s; o++) {
      var u = t.lightSources[o];
      this.BindLight(u, o, e, r, typeof n == "boolean" ? n : n.SPECULARTERM, t.receiveShadows);
    }
  }, i.BindFogParameters = function(e, t, r, n) {
    n === void 0 && (n = !1), e.fogEnabled && t.applyFog && e.fogMode !== te.FOGMODE_NONE && (r.setFloat4("vFogInfos", e.fogMode, e.fogStart, e.fogEnd, e.fogDensity), n ? (e.fogColor.toLinearSpaceToRef(this._TempFogColor), r.setColor3("vFogColor", this._TempFogColor)) : r.setColor3("vFogColor", e.fogColor));
  }, i.BindBonesParameters = function(e, t, r) {
    if (!(!t || !e) && (e.computeBonesUsingShaders && t._bonesComputationForcedToCPU && (e.computeBonesUsingShaders = !1), e.useBones && e.computeBonesUsingShaders && e.skeleton)) {
      var n = e.skeleton;
      if (n.isUsingTextureForMatrices && t.getUniformIndex("boneTextureWidth") > -1) {
        var a = n.getTransformMatrixTexture(e);
        t.setTexture("boneSampler", a), t.setFloat("boneTextureWidth", 4 * (n.bones.length + 1));
      } else {
        var s = n.getTransformMatrices(e);
        s && (t.setMatrices("mBones", s), r && e.getScene().prePassRenderer && e.getScene().prePassRenderer.getIndex(2) && (r.previousBones[e.uniqueId] || (r.previousBones[e.uniqueId] = s.slice()), t.setMatrices("mPreviousBones", r.previousBones[e.uniqueId]), i._CopyBonesTransformationMatrices(s, r.previousBones[e.uniqueId])));
      }
    }
  }, i._CopyBonesTransformationMatrices = function(e, t) {
    return t.set(e), t;
  }, i.BindMorphTargetParameters = function(e, t) {
    var r = e.morphTargetManager;
    !e || !r || t.setFloatArray("morphTargetInfluences", r.influences);
  }, i.BindLogDepth = function(e, t, r) {
    if (!e || e.LOGARITHMICDEPTH) {
      var n = r.activeCamera;
      n.mode === De.ORTHOGRAPHIC_CAMERA && k.Error("Logarithmic depth is not compatible with orthographic cameras!", 20), t.setFloat("logarithmicDepthConstant", 2 / (Math.log(n.maxZ + 1) / Math.LN2));
    }
  }, i.BindClipPlane = function(e, t) {
    Aa.BindClipPlane(e, t);
  }, i._TmpMorphInfluencers = { NUM_MORPH_INFLUENCERS: 0 }, i._TempFogColor = ye.Black(), i;
}(), Ra = function() {
  function i() {
    this.reset();
  }
  return i.prototype.reset = function() {
    this.enabled = !1, this.mask = 255, this.func = 519, this.funcRef = 1, this.funcMask = 255, this.opStencilFail = 7680, this.opDepthFail = 7680, this.opStencilDepthPass = 7681;
  }, Object.defineProperty(i.prototype, "func", {
    get: function() {
      return this._func;
    },
    set: function(e) {
      this._func = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "funcRef", {
    get: function() {
      return this._funcRef;
    },
    set: function(e) {
      this._funcRef = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "funcMask", {
    get: function() {
      return this._funcMask;
    },
    set: function(e) {
      this._funcMask = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "opStencilFail", {
    get: function() {
      return this._opStencilFail;
    },
    set: function(e) {
      this._opStencilFail = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "opDepthFail", {
    get: function() {
      return this._opDepthFail;
    },
    set: function(e) {
      this._opDepthFail = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "opStencilDepthPass", {
    get: function() {
      return this._opStencilDepthPass;
    },
    set: function(e) {
      this._opStencilDepthPass = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "mask", {
    get: function() {
      return this._mask;
    },
    set: function(e) {
      this._mask = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "enabled", {
    get: function() {
      return this._enabled;
    },
    set: function(e) {
      this._enabled = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getClassName = function() {
    return "MaterialStencilState";
  }, i.prototype.copyTo = function(e) {
    $.Clone(function() {
      return e;
    }, this);
  }, i.prototype.serialize = function() {
    return $.Serialize(this);
  }, i.prototype.parse = function(e, t, r) {
    var n = this;
    $.Parse(function() {
      return n;
    }, e, t, r);
  }, T([
    P()
  ], i.prototype, "func", null), T([
    P()
  ], i.prototype, "funcRef", null), T([
    P()
  ], i.prototype, "funcMask", null), T([
    P()
  ], i.prototype, "opStencilFail", null), T([
    P()
  ], i.prototype, "opDepthFail", null), T([
    P()
  ], i.prototype, "opStencilDepthPass", null), T([
    P()
  ], i.prototype, "mask", null), T([
    P()
  ], i.prototype, "enabled", null), i;
}(), Ce;
(function(i) {
  i[i.Created = 1] = "Created", i[i.Disposed = 2] = "Disposed", i[i.GetDefineNames = 4] = "GetDefineNames", i[i.PrepareUniformBuffer = 8] = "PrepareUniformBuffer", i[i.IsReadyForSubMesh = 16] = "IsReadyForSubMesh", i[i.PrepareDefines = 32] = "PrepareDefines", i[i.BindForSubMesh = 64] = "BindForSubMesh", i[i.PrepareEffect = 128] = "PrepareEffect", i[i.GetAnimatables = 256] = "GetAnimatables", i[i.GetActiveTextures = 512] = "GetActiveTextures", i[i.HasTexture = 1024] = "HasTexture", i[i.FillRenderTargetTextures = 2048] = "FillRenderTargetTextures", i[i.HasRenderTargetTextures = 4096] = "HasRenderTargetTextures", i[i.HardBindForSubMesh = 8192] = "HardBindForSubMesh";
})(Ce || (Ce = {}));
var Ie = function() {
  function i(e, t, r) {
    this.shadowDepthWrapper = null, this.allowShaderHotSwapping = !0, this.metadata = null, this.reservedDataStore = null, this.checkReadyOnEveryCall = !1, this.checkReadyOnlyOnce = !1, this.state = "", this._alpha = 1, this._backFaceCulling = !0, this._cullBackFaces = !0, this.onCompiled = null, this.onError = null, this.getRenderTargetTextures = null, this.doNotSerialize = !1, this._storeEffectOnSubMeshes = !1, this.animations = null, this.onDisposeObservable = new O(), this._onDisposeObserver = null, this._onUnBindObservable = null, this._onBindObserver = null, this._alphaMode = 2, this._needDepthPrePass = !1, this.disableDepthWrite = !1, this.disableColorWrite = !1, this.forceDepthWrite = !1, this.depthFunction = 0, this.separateCullingPass = !1, this._fogEnabled = !0, this.pointSize = 1, this.zOffset = 0, this.zOffsetUnits = 0, this.stencil = new Ra(), this._useUBO = !1, this._fillMode = i.TriangleFillMode, this._cachedDepthWriteState = !1, this._cachedColorWriteState = !1, this._cachedDepthFunctionState = 0, this._indexInSceneMaterialArray = -1, this.meshMap = null, this._parentContainer = null, this._uniformBufferLayoutBuilt = !1, this._eventInfo = {}, this._callbackPluginEventGeneric = function() {
    }, this._callbackPluginEventIsReadyForSubMesh = function() {
    }, this._callbackPluginEventPrepareDefines = function() {
    }, this._callbackPluginEventHardBindForSubMesh = function() {
    }, this._callbackPluginEventBindForSubMesh = function() {
    }, this._callbackPluginEventHasRenderTargetTextures = function() {
    }, this._callbackPluginEventFillRenderTargetTextures = function() {
    }, this._forceAlphaTest = !1, this._transparencyMode = null, this.name = e;
    var n = t || re.LastCreatedScene;
    !n || (this._scene = n, this._dirtyCallbacks = {}, this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this), this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this), this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this), this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this), this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this), this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this), this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this), this.id = e || de.RandomId(), this.uniqueId = this._scene.getUniqueId(), this._materialContext = this._scene.getEngine().createMaterialContext(), this._drawWrapper = new sr(this._scene.getEngine(), !1), this._drawWrapper.materialContext = this._materialContext, this._scene.useRightHandedSystem ? this.sideOrientation = i.ClockWiseSideOrientation : this.sideOrientation = i.CounterClockWiseSideOrientation, this._uniformBuffer = new wr(this._scene.getEngine(), void 0, void 0, e), this._useUBO = this.getScene().getEngine().supportsUniformBuffers, r || this._scene.addMaterial(this), this._scene.useMaterialMeshMap && (this.meshMap = {}), i.OnEventObservable.notifyObservers(this, Ce.Created));
  }
  return Object.defineProperty(i.prototype, "canRenderToMRT", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "alpha", {
    get: function() {
      return this._alpha;
    },
    set: function(e) {
      if (this._alpha !== e) {
        var t = this._alpha;
        this._alpha = e, (t === 1 || e === 1) && this.markAsDirty(i.MiscDirtyFlag);
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "backFaceCulling", {
    get: function() {
      return this._backFaceCulling;
    },
    set: function(e) {
      this._backFaceCulling !== e && (this._backFaceCulling = e, this.markAsDirty(i.TextureDirtyFlag));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "cullBackFaces", {
    get: function() {
      return this._cullBackFaces;
    },
    set: function(e) {
      this._cullBackFaces !== e && (this._cullBackFaces = e, this.markAsDirty(i.TextureDirtyFlag));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "hasRenderTargetTextures", {
    get: function() {
      return this._eventInfo.hasRenderTargetTextures = !1, this._callbackPluginEventHasRenderTargetTextures(this._eventInfo), this._eventInfo.hasRenderTargetTextures;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "onDispose", {
    set: function(e) {
      this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "onBindObservable", {
    get: function() {
      return this._onBindObservable || (this._onBindObservable = new O()), this._onBindObservable;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "onBind", {
    set: function(e) {
      this._onBindObserver && this.onBindObservable.remove(this._onBindObserver), this._onBindObserver = this.onBindObservable.add(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "onUnBindObservable", {
    get: function() {
      return this._onUnBindObservable || (this._onUnBindObservable = new O()), this._onUnBindObservable;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "onEffectCreatedObservable", {
    get: function() {
      return this._onEffectCreatedObservable || (this._onEffectCreatedObservable = new O()), this._onEffectCreatedObservable;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "alphaMode", {
    get: function() {
      return this._alphaMode;
    },
    set: function(e) {
      this._alphaMode !== e && (this._alphaMode = e, this.markAsDirty(i.TextureDirtyFlag));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "needDepthPrePass", {
    get: function() {
      return this._needDepthPrePass;
    },
    set: function(e) {
      this._needDepthPrePass !== e && (this._needDepthPrePass = e, this._needDepthPrePass && (this.checkReadyOnEveryCall = !0));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "isPrePassCapable", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "fogEnabled", {
    get: function() {
      return this._fogEnabled;
    },
    set: function(e) {
      this._fogEnabled !== e && (this._fogEnabled = e, this.markAsDirty(i.MiscDirtyFlag));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "wireframe", {
    get: function() {
      switch (this._fillMode) {
        case i.WireFrameFillMode:
        case i.LineListDrawMode:
        case i.LineLoopDrawMode:
        case i.LineStripDrawMode:
          return !0;
      }
      return this._scene.forceWireframe;
    },
    set: function(e) {
      this.fillMode = e ? i.WireFrameFillMode : i.TriangleFillMode;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "pointsCloud", {
    get: function() {
      switch (this._fillMode) {
        case i.PointFillMode:
        case i.PointListDrawMode:
          return !0;
      }
      return this._scene.forcePointsCloud;
    },
    set: function(e) {
      this.fillMode = e ? i.PointFillMode : i.TriangleFillMode;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "fillMode", {
    get: function() {
      return this._fillMode;
    },
    set: function(e) {
      this._fillMode !== e && (this._fillMode = e, this.markAsDirty(i.MiscDirtyFlag));
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._getDrawWrapper = function() {
    return this._drawWrapper;
  }, i.prototype._setDrawWrapper = function(e) {
    this._drawWrapper = e;
  }, i.prototype.toString = function(e) {
    var t = "Name: " + this.name;
    return t;
  }, i.prototype.getClassName = function() {
    return "Material";
  }, Object.defineProperty(i.prototype, "isFrozen", {
    get: function() {
      return this.checkReadyOnlyOnce;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.freeze = function() {
    this.markDirty(), this.checkReadyOnlyOnce = !0;
  }, i.prototype.unfreeze = function() {
    this.markDirty(), this.checkReadyOnlyOnce = !1;
  }, i.prototype.isReady = function(e, t) {
    return !0;
  }, i.prototype.isReadyForSubMesh = function(e, t, r) {
    var n = t.materialDefines;
    return n ? (this._eventInfo.isReadyForSubMesh = !0, this._eventInfo.defines = n, this._callbackPluginEventIsReadyForSubMesh(this._eventInfo), this._eventInfo.isReadyForSubMesh) : !1;
  }, i.prototype.getEffect = function() {
    return this._drawWrapper.effect;
  }, i.prototype.getScene = function() {
    return this._scene;
  }, Object.defineProperty(i.prototype, "transparencyMode", {
    get: function() {
      return this._transparencyMode;
    },
    set: function(e) {
      this._transparencyMode !== e && (this._transparencyMode = e, this._forceAlphaTest = e === i.MATERIAL_ALPHATESTANDBLEND, this._markAllSubMeshesAsTexturesAndMiscDirty());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "_disableAlphaBlending", {
    get: function() {
      return this._transparencyMode === i.MATERIAL_OPAQUE || this._transparencyMode === i.MATERIAL_ALPHATEST;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.needAlphaBlending = function() {
    return this._disableAlphaBlending ? !1 : this.alpha < 1;
  }, i.prototype.needAlphaBlendingForMesh = function(e) {
    return this._disableAlphaBlending && e.visibility >= 1 ? !1 : this.needAlphaBlending() || e.visibility < 1 || e.hasVertexAlpha;
  }, i.prototype.needAlphaTesting = function() {
    return !!this._forceAlphaTest;
  }, i.prototype._shouldTurnAlphaTestOn = function(e) {
    return !this.needAlphaBlendingForMesh(e) && this.needAlphaTesting();
  }, i.prototype.getAlphaTestTexture = function() {
    return null;
  }, i.prototype.markDirty = function() {
    for (var e = this.getScene().meshes, t = 0, r = e; t < r.length; t++) {
      var n = r[t];
      if (!!n.subMeshes)
        for (var a = 0, s = n.subMeshes; a < s.length; a++) {
          var o = s[a];
          o.getMaterial() === this && (!o.effect || (o.effect._wasPreviouslyReady = !1));
        }
    }
  }, i.prototype._preBind = function(e, t) {
    t === void 0 && (t = null);
    var r = this._scene.getEngine(), n = t == null ? this.sideOrientation : t, a = n === i.ClockWiseSideOrientation;
    return r.enableEffect(e || this._getDrawWrapper()), r.setState(this.backFaceCulling, this.zOffset, !1, a, this.cullBackFaces, this.stencil, this.zOffsetUnits), a;
  }, i.prototype.bind = function(e, t) {
  }, i.prototype.buildUniformLayout = function() {
    var e = this._uniformBuffer;
    this._eventInfo.ubo = e, this._callbackPluginEventGeneric(Ce.PrepareUniformBuffer, this._eventInfo), e.create(), this._uniformBufferLayoutBuilt = !0;
  }, i.prototype.bindForSubMesh = function(e, t, r) {
    var n = r.effect;
    !n || (this._eventInfo.subMesh = r, this._callbackPluginEventBindForSubMesh(this._eventInfo));
  }, i.prototype.bindOnlyWorldMatrix = function(e) {
  }, i.prototype.bindView = function(e) {
    this._useUBO ? this._needToBindSceneUbo = !0 : e.setMatrix("view", this.getScene().getViewMatrix());
  }, i.prototype.bindViewProjection = function(e) {
    this._useUBO ? this._needToBindSceneUbo = !0 : (e.setMatrix("viewProjection", this.getScene().getTransformMatrix()), e.setMatrix("projection", this.getScene().getProjectionMatrix()));
  }, i.prototype.bindEyePosition = function(e, t) {
    this._useUBO ? this._needToBindSceneUbo = !0 : this._scene.bindEyePosition(e, t);
  }, i.prototype._afterBind = function(e, t) {
    if (t === void 0 && (t = null), this._scene._cachedMaterial = this, this._needToBindSceneUbo && t && (this._needToBindSceneUbo = !1, j.BindSceneUniformBuffer(t, this.getScene().getSceneUniformBuffer()), this._scene.finalizeSceneUbo()), e ? this._scene._cachedVisibility = e.visibility : this._scene._cachedVisibility = 1, this._onBindObservable && e && this._onBindObservable.notifyObservers(e), this.disableDepthWrite) {
      var r = this._scene.getEngine();
      this._cachedDepthWriteState = r.getDepthWrite(), r.setDepthWrite(!1);
    }
    if (this.disableColorWrite) {
      var r = this._scene.getEngine();
      this._cachedColorWriteState = r.getColorWrite(), r.setColorWrite(!1);
    }
    if (this.depthFunction !== 0) {
      var r = this._scene.getEngine();
      this._cachedDepthFunctionState = r.getDepthFunction() || 0, r.setDepthFunction(this.depthFunction);
    }
  }, i.prototype.unbind = function() {
    if (this._onUnBindObservable && this._onUnBindObservable.notifyObservers(this), this.depthFunction !== 0) {
      var e = this._scene.getEngine();
      e.setDepthFunction(this._cachedDepthFunctionState);
    }
    if (this.disableDepthWrite) {
      var e = this._scene.getEngine();
      e.setDepthWrite(this._cachedDepthWriteState);
    }
    if (this.disableColorWrite) {
      var e = this._scene.getEngine();
      e.setColorWrite(this._cachedColorWriteState);
    }
  }, i.prototype.getAnimatables = function() {
    return this._eventInfo.animatables = [], this._callbackPluginEventGeneric(Ce.GetAnimatables, this._eventInfo), this._eventInfo.animatables;
  }, i.prototype.getActiveTextures = function() {
    return this._eventInfo.activeTextures = [], this._callbackPluginEventGeneric(Ce.GetActiveTextures, this._eventInfo), this._eventInfo.activeTextures;
  }, i.prototype.hasTexture = function(e) {
    return this._eventInfo.hasTexture = !1, this._eventInfo.texture = e, this._callbackPluginEventGeneric(Ce.HasTexture, this._eventInfo), this._eventInfo.hasTexture;
  }, i.prototype.clone = function(e) {
    return null;
  }, i.prototype.getBindedMeshes = function() {
    var e = this;
    if (this.meshMap) {
      var t = new Array();
      for (var r in this.meshMap) {
        var n = this.meshMap[r];
        n && t.push(n);
      }
      return t;
    } else {
      var a = this._scene.meshes;
      return a.filter(function(s) {
        return s.material === e;
      });
    }
  }, i.prototype.forceCompilation = function(e, t, r, n) {
    var a = this, s = Tt({ clipPlane: !1, useInstances: !1 }, r), o = this.getScene(), u = this.allowShaderHotSwapping;
    this.allowShaderHotSwapping = !1;
    var f = function() {
      if (!(!a._scene || !a._scene.getEngine())) {
        var l = o.clipPlane;
        if (s.clipPlane && (o.clipPlane = new gi(0, 0, 0, 1)), a._storeEffectOnSubMeshes) {
          var h = !0, c = null;
          if (e.subMeshes) {
            var d = new mt(0, 0, 0, 0, 0, e, void 0, !1, !1);
            d.materialDefines && (d.materialDefines._renderId = -1), a.isReadyForSubMesh(e, d, s.useInstances) || (d.effect && d.effect.getCompilationError() && d.effect.allFallbacksProcessed() ? c = d.effect.getCompilationError() : (h = !1, setTimeout(f, 16)));
          }
          h && (a.allowShaderHotSwapping = u, c && n && n(c), t && t(a));
        } else
          a.isReady() ? (a.allowShaderHotSwapping = u, t && t(a)) : setTimeout(f, 16);
        s.clipPlane && (o.clipPlane = l);
      }
    };
    f();
  }, i.prototype.forceCompilationAsync = function(e, t) {
    var r = this;
    return new Promise(function(n, a) {
      r.forceCompilation(e, function() {
        n();
      }, t, function(s) {
        a(s);
      });
    });
  }, i.prototype.markAsDirty = function(e) {
    this.getScene().blockMaterialDirtyMechanism || (i._DirtyCallbackArray.length = 0, e & i.TextureDirtyFlag && i._DirtyCallbackArray.push(i._TextureDirtyCallBack), e & i.LightDirtyFlag && i._DirtyCallbackArray.push(i._LightsDirtyCallBack), e & i.FresnelDirtyFlag && i._DirtyCallbackArray.push(i._FresnelDirtyCallBack), e & i.AttributesDirtyFlag && i._DirtyCallbackArray.push(i._AttributeDirtyCallBack), e & i.MiscDirtyFlag && i._DirtyCallbackArray.push(i._MiscDirtyCallBack), e & i.PrePassDirtyFlag && i._DirtyCallbackArray.push(i._PrePassDirtyCallBack), i._DirtyCallbackArray.length && this._markAllSubMeshesAsDirty(i._RunDirtyCallBacks), this.getScene().resetCachedMaterial());
  }, i.prototype.resetDrawCache = function() {
    for (var e = this.getScene().meshes, t = 0, r = e; t < r.length; t++) {
      var n = r[t];
      if (!!n.subMeshes)
        for (var a = 0, s = n.subMeshes; a < s.length; a++) {
          var o = s[a];
          o.getMaterial() === this && o.resetDrawCache();
        }
    }
  }, i.prototype._markAllSubMeshesAsDirty = function(e) {
    if (!this.getScene().blockMaterialDirtyMechanism)
      for (var t = this.getScene().meshes, r = 0, n = t; r < n.length; r++) {
        var a = n[r];
        if (!!a.subMeshes)
          for (var s = 0, o = a.subMeshes; s < o.length; s++) {
            var u = o[s];
            if (!(a._renderId === 0 || u.getMaterial() !== this))
              for (var f = 0, l = u._drawWrappers; f < l.length; f++) {
                var h = l[f];
                !h || !h.defines || !h.defines.markAllAsDirty || this._materialContext === h.materialContext && e(h.defines);
              }
          }
      }
  }, i.prototype._markScenePrePassDirty = function() {
    if (!this.getScene().blockMaterialDirtyMechanism) {
      var e = this.getScene().enablePrePassRenderer();
      e && e.markAsDirty();
    }
  }, i.prototype._markAllSubMeshesAsAllDirty = function() {
    this._markAllSubMeshesAsDirty(i._AllDirtyCallBack);
  }, i.prototype._markAllSubMeshesAsImageProcessingDirty = function() {
    this._markAllSubMeshesAsDirty(i._ImageProcessingDirtyCallBack);
  }, i.prototype._markAllSubMeshesAsTexturesDirty = function() {
    this._markAllSubMeshesAsDirty(i._TextureDirtyCallBack);
  }, i.prototype._markAllSubMeshesAsFresnelDirty = function() {
    this._markAllSubMeshesAsDirty(i._FresnelDirtyCallBack);
  }, i.prototype._markAllSubMeshesAsFresnelAndMiscDirty = function() {
    this._markAllSubMeshesAsDirty(i._FresnelAndMiscDirtyCallBack);
  }, i.prototype._markAllSubMeshesAsLightsDirty = function() {
    this._markAllSubMeshesAsDirty(i._LightsDirtyCallBack);
  }, i.prototype._markAllSubMeshesAsAttributesDirty = function() {
    this._markAllSubMeshesAsDirty(i._AttributeDirtyCallBack);
  }, i.prototype._markAllSubMeshesAsMiscDirty = function() {
    this._markAllSubMeshesAsDirty(i._MiscDirtyCallBack);
  }, i.prototype._markAllSubMeshesAsPrePassDirty = function() {
    this._markAllSubMeshesAsDirty(i._MiscDirtyCallBack);
  }, i.prototype._markAllSubMeshesAsTexturesAndMiscDirty = function() {
    this._markAllSubMeshesAsDirty(i._TextureAndMiscDirtyCallBack);
  }, i.prototype.setPrePassRenderer = function(e) {
    return !1;
  }, i.prototype.dispose = function(e, t, r) {
    var n = this.getScene();
    if (n.stopAnimation(this), n.freeProcessedMaterials(), n.removeMaterial(this), this._eventInfo.forceDisposeTextures = t, this._callbackPluginEventGeneric(Ce.Disposed, this._eventInfo), this._parentContainer) {
      var a = this._parentContainer.materials.indexOf(this);
      a > -1 && this._parentContainer.materials.splice(a, 1), this._parentContainer = null;
    }
    if (r !== !0)
      if (this.meshMap)
        for (var s in this.meshMap) {
          var o = this.meshMap[s];
          o && (o.material = null, this.releaseVertexArrayObject(o, e));
        }
      else
        for (var u = n.meshes, f = 0, l = u; f < l.length; f++) {
          var o = l[f];
          o.material === this && !o.sourceMesh && (o.material = null, this.releaseVertexArrayObject(o, e));
        }
    this._uniformBuffer.dispose(), e && this._drawWrapper.effect && (this._storeEffectOnSubMeshes || this._drawWrapper.effect.dispose(), this._drawWrapper.effect = null), this.metadata = null, this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this._onBindObservable && this._onBindObservable.clear(), this._onUnBindObservable && this._onUnBindObservable.clear(), this._onEffectCreatedObservable && this._onEffectCreatedObservable.clear();
  }, i.prototype.releaseVertexArrayObject = function(e, t) {
    if (e.geometry) {
      var r = e.geometry;
      if (this._storeEffectOnSubMeshes)
        for (var n = 0, a = e.subMeshes; n < a.length; n++) {
          var s = a[n];
          r._releaseVertexArrayObject(s.effect), t && s.effect && s.effect.dispose();
        }
      else
        r._releaseVertexArrayObject(this._drawWrapper.effect);
    }
  }, i.prototype.serialize = function() {
    var e = $.Serialize(this);
    return e.stencil = this.stencil.serialize(), e.uniqueId = this.uniqueId, e;
  }, i.Parse = function(e, t, r) {
    if (!e.customType)
      e.customType = "BABYLON.StandardMaterial";
    else if (e.customType === "BABYLON.PBRMaterial" && e.overloadedAlbedo && (e.customType = "BABYLON.LegacyPBRMaterial", !BABYLON.LegacyPBRMaterial))
      return k.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library."), null;
    var n = de.Instantiate(e.customType), a = n.Parse(e, t, r);
    return a._loadedUniqueId = e.uniqueId, a;
  }, i.TriangleFillMode = 0, i.WireFrameFillMode = 1, i.PointFillMode = 2, i.PointListDrawMode = 3, i.LineListDrawMode = 4, i.LineLoopDrawMode = 5, i.LineStripDrawMode = 6, i.TriangleStripDrawMode = 7, i.TriangleFanDrawMode = 8, i.ClockWiseSideOrientation = 0, i.CounterClockWiseSideOrientation = 1, i.TextureDirtyFlag = 1, i.LightDirtyFlag = 2, i.FresnelDirtyFlag = 4, i.AttributesDirtyFlag = 8, i.MiscDirtyFlag = 16, i.PrePassDirtyFlag = 32, i.AllDirtyFlag = 63, i.MATERIAL_OPAQUE = 0, i.MATERIAL_ALPHATEST = 1, i.MATERIAL_ALPHABLEND = 2, i.MATERIAL_ALPHATESTANDBLEND = 3, i.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0, i.MATERIAL_NORMALBLENDMETHOD_RNM = 1, i.OnEventObservable = new O(), i._AllDirtyCallBack = function(e) {
    return e.markAllAsDirty();
  }, i._ImageProcessingDirtyCallBack = function(e) {
    return e.markAsImageProcessingDirty();
  }, i._TextureDirtyCallBack = function(e) {
    return e.markAsTexturesDirty();
  }, i._FresnelDirtyCallBack = function(e) {
    return e.markAsFresnelDirty();
  }, i._MiscDirtyCallBack = function(e) {
    return e.markAsMiscDirty();
  }, i._PrePassDirtyCallBack = function(e) {
    return e.markAsPrePassDirty();
  }, i._LightsDirtyCallBack = function(e) {
    return e.markAsLightDirty();
  }, i._AttributeDirtyCallBack = function(e) {
    return e.markAsAttributesDirty();
  }, i._FresnelAndMiscDirtyCallBack = function(e) {
    i._FresnelDirtyCallBack(e), i._MiscDirtyCallBack(e);
  }, i._TextureAndMiscDirtyCallBack = function(e) {
    i._TextureDirtyCallBack(e), i._MiscDirtyCallBack(e);
  }, i._DirtyCallbackArray = [], i._RunDirtyCallBacks = function(e) {
    for (var t = 0, r = i._DirtyCallbackArray; t < r.length; t++) {
      var n = r[t];
      n(e);
    }
  }, T([
    P()
  ], i.prototype, "id", void 0), T([
    P()
  ], i.prototype, "uniqueId", void 0), T([
    P()
  ], i.prototype, "name", void 0), T([
    P()
  ], i.prototype, "metadata", void 0), T([
    P()
  ], i.prototype, "checkReadyOnEveryCall", void 0), T([
    P()
  ], i.prototype, "checkReadyOnlyOnce", void 0), T([
    P()
  ], i.prototype, "state", void 0), T([
    P("alpha")
  ], i.prototype, "_alpha", void 0), T([
    P("backFaceCulling")
  ], i.prototype, "_backFaceCulling", void 0), T([
    P("cullBackFaces")
  ], i.prototype, "_cullBackFaces", void 0), T([
    P()
  ], i.prototype, "sideOrientation", void 0), T([
    P("alphaMode")
  ], i.prototype, "_alphaMode", void 0), T([
    P()
  ], i.prototype, "_needDepthPrePass", void 0), T([
    P()
  ], i.prototype, "disableDepthWrite", void 0), T([
    P()
  ], i.prototype, "disableColorWrite", void 0), T([
    P()
  ], i.prototype, "forceDepthWrite", void 0), T([
    P()
  ], i.prototype, "depthFunction", void 0), T([
    P()
  ], i.prototype, "separateCullingPass", void 0), T([
    P("fogEnabled")
  ], i.prototype, "_fogEnabled", void 0), T([
    P()
  ], i.prototype, "pointSize", void 0), T([
    P()
  ], i.prototype, "zOffset", void 0), T([
    P()
  ], i.prototype, "zOffsetUnits", void 0), T([
    P()
  ], i.prototype, "pointsCloud", null), T([
    P()
  ], i.prototype, "fillMode", null), T([
    P()
  ], i.prototype, "transparencyMode", null), i;
}(), si = function(i) {
  K(e, i);
  function e(t, r) {
    var n = i.call(this, t, r, !0) || this;
    return n._waitingSubMaterialsUniqueIds = [], n.getScene().multiMaterials.push(n), n.subMaterials = new Array(), n._storeEffectOnSubMeshes = !0, n;
  }
  return Object.defineProperty(e.prototype, "subMaterials", {
    get: function() {
      return this._subMaterials;
    },
    set: function(t) {
      this._subMaterials = t, this._hookArray(t);
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getChildren = function() {
    return this.subMaterials;
  }, e.prototype._hookArray = function(t) {
    var r = this, n = t.push;
    t.push = function() {
      for (var s = [], o = 0; o < arguments.length; o++)
        s[o] = arguments[o];
      var u = n.apply(t, s);
      return r._markAllSubMeshesAsTexturesDirty(), u;
    };
    var a = t.splice;
    t.splice = function(s, o) {
      var u = a.apply(t, [s, o]);
      return r._markAllSubMeshesAsTexturesDirty(), u;
    };
  }, e.prototype.getSubMaterial = function(t) {
    return t < 0 || t >= this.subMaterials.length ? this.getScene().defaultMaterial : this.subMaterials[t];
  }, e.prototype.getActiveTextures = function() {
    var t;
    return (t = i.prototype.getActiveTextures.call(this)).concat.apply(t, this.subMaterials.map(function(r) {
      return r ? r.getActiveTextures() : [];
    }));
  }, e.prototype.hasTexture = function(t) {
    var r;
    if (i.prototype.hasTexture.call(this, t))
      return !0;
    for (var n = 0; n < this.subMaterials.length; n++)
      if (!((r = this.subMaterials[n]) === null || r === void 0) && r.hasTexture(t))
        return !0;
    return !1;
  }, e.prototype.getClassName = function() {
    return "MultiMaterial";
  }, e.prototype.isReadyForSubMesh = function(t, r, n) {
    for (var a = 0; a < this.subMaterials.length; a++) {
      var s = this.subMaterials[a];
      if (s) {
        if (s._storeEffectOnSubMeshes) {
          if (!s.isReadyForSubMesh(t, r, n))
            return !1;
          continue;
        }
        if (!s.isReady(t))
          return !1;
      }
    }
    return !0;
  }, e.prototype.clone = function(t, r) {
    for (var n = new e(t, this.getScene()), a = 0; a < this.subMaterials.length; a++) {
      var s = null, o = this.subMaterials[a];
      r && o ? s = o.clone(t + "-" + o.name) : s = this.subMaterials[a], n.subMaterials.push(s);
    }
    return n;
  }, e.prototype.serialize = function() {
    var t = {};
    t.name = this.name, t.id = this.id, t.uniqueId = this.uniqueId, le && (t.tags = le.GetTags(this)), t.materialsUniqueIds = [], t.materials = [];
    for (var r = 0; r < this.subMaterials.length; r++) {
      var n = this.subMaterials[r];
      n ? (t.materialsUniqueIds.push(n.uniqueId), t.materials.push(n.id)) : (t.materialsUniqueIds.push(null), t.materials.push(null));
    }
    return t;
  }, e.prototype.dispose = function(t, r, n) {
    var a = this.getScene();
    if (!!a) {
      if (n)
        for (var s = 0; s < this.subMaterials.length; s++) {
          var o = this.subMaterials[s];
          o && o.dispose(t, r);
        }
      var u = a.multiMaterials.indexOf(this);
      u >= 0 && a.multiMaterials.splice(u, 1), i.prototype.dispose.call(this, t, r);
    }
  }, e.ParseMultiMaterial = function(t, r) {
    var n = new e(t.name, r);
    return n.id = t.id, n._loadedUniqueId = t.uniqueId, le && le.AddTagsTo(n, t.tags), t.materialsUniqueIds ? n._waitingSubMaterialsUniqueIds = t.materialsUniqueIds : t.materials.forEach(function(a) {
      return n.subMaterials.push(r.getLastMaterialById(a));
    }), n;
  }, e;
}(Ie);
Ne("BABYLON.MultiMaterial", si);
var Pa = function() {
  function i(e, t) {
    this.distanceOrScreenCoverage = e, this.mesh = t;
  }
  return i;
}(), Ca = function() {
  function i() {
    this.visibleInstances = {}, this.batchCache = new Gi(), this.batchCacheReplacementModeInFrozenMode = new Gi(), this.instancesBufferSize = 32 * 16 * 4;
  }
  return i;
}(), Gi = function() {
  function i() {
    this.mustReturn = !1, this.visibleInstances = new Array(), this.renderSelf = new Array(), this.hardwareInstancedRendering = new Array();
  }
  return i;
}(), xa = function() {
  function i() {
    this.instancesCount = 0, this.matrixBuffer = null, this.previousMatrixBuffer = null, this.matrixBufferSize = 32 * 16, this.matrixData = null, this.boundingVectors = [], this.worldMatrices = null;
  }
  return i;
}(), Da = function() {
  function i() {
    this._areNormalsFrozen = !1, this._source = null, this.meshMap = null, this._preActivateId = -1, this._LODLevels = new Array(), this._useLODScreenCoverage = !1, this._effectiveMaterial = null, this._forcedInstanceCount = 0;
  }
  return i;
}(), Q = function(i) {
  K(e, i);
  function e(t, r, n, a, s, o) {
    r === void 0 && (r = null), n === void 0 && (n = null), a === void 0 && (a = null), o === void 0 && (o = !0);
    var u = i.call(this, t, r) || this;
    if (u._internalMeshDataInfo = new Da(), u.delayLoadState = 0, u.instances = new Array(), u._creationDataStorage = null, u._geometry = null, u._instanceDataStorage = new Ca(), u._thinInstanceDataStorage = new xa(), u._shouldGenerateFlatShading = !1, u._originalBuilderSideOrientation = e.DEFAULTSIDE, u.overrideMaterialSideOrientation = null, u.ignoreCameraMaxZ = !1, r = u.getScene(), u._onBeforeDraw = function(v, y, E) {
      v && E && (u._uniformBuffer ? u.transferToEffect(y) : E.bindOnlyWorldMatrix(y));
    }, a) {
      if (a._geometry && a._geometry.applyToMesh(u), hi.DeepCopy(a, u, [
        "name",
        "material",
        "skeleton",
        "instances",
        "parent",
        "uniqueId",
        "source",
        "metadata",
        "morphTargetManager",
        "hasInstances",
        "worldMatrixInstancedBuffer",
        "previousWorldMatrixInstancedBuffer",
        "hasLODLevels",
        "geometry",
        "isBlocked",
        "areNormalsFrozen",
        "facetNb",
        "isFacetDataEnabled",
        "lightSources",
        "useBones",
        "isAnInstance",
        "collider",
        "edgesRenderer",
        "forward",
        "up",
        "right",
        "absolutePosition",
        "absoluteScaling",
        "absoluteRotationQuaternion",
        "isWorldMatrixFrozen",
        "nonUniformScaling",
        "behaviors",
        "worldMatrixFromCache",
        "hasThinInstances",
        "cloneMeshMap",
        "hasBoundingInfo"
      ], ["_poseMatrix"]), u._internalMeshDataInfo._source = a, r.useClonedMeshMap && (a._internalMeshDataInfo.meshMap || (a._internalMeshDataInfo.meshMap = {}), a._internalMeshDataInfo.meshMap[u.uniqueId] = u), u._originalBuilderSideOrientation = a._originalBuilderSideOrientation, u._creationDataStorage = a._creationDataStorage, a._ranges) {
        var f = a._ranges;
        for (var l in f)
          !Object.prototype.hasOwnProperty.call(f, l) || !f[l] || u.createAnimationRange(l, f[l].from, f[l].to);
      }
      if (a.metadata && a.metadata.clone ? u.metadata = a.metadata.clone() : u.metadata = a.metadata, le && le.HasTags(a) && le.AddTagsTo(u, le.GetTags(a, !0)), u.setEnabled(a.isEnabled()), u.parent = a.parent, u.setPivotMatrix(a.getPivotMatrix()), u.id = t + "." + a.id, u.material = a.material, !s)
        for (var h = a.getDescendants(!0), c = 0; c < h.length; c++) {
          var d = h[c];
          d.clone && d.clone(t + "." + d.name, u);
        }
      if (a.morphTargetManager && (u.morphTargetManager = a.morphTargetManager), r.getPhysicsEngine) {
        var p = r.getPhysicsEngine();
        if (o && p) {
          var g = p.getImpostorForPhysicsObject(a);
          g && (u.physicsImpostor = g.clone(u));
        }
      }
      for (var c = 0; c < r.particleSystems.length; c++) {
        var _ = r.particleSystems[c];
        _.emitter === a && _.clone(_.name, u);
      }
      u.skeleton = a.skeleton, u.refreshBoundingInfo(!0, !0), u.computeWorldMatrix(!0);
    }
    return n !== null && (u.parent = n), u._instanceDataStorage.hardwareInstancedRendering = u.getEngine().getCaps().instancedArrays, u._internalMeshDataInfo._onMeshReadyObserverAdded = function(v) {
      v.unregisterOnNextCall = !0, u.isReady(!0) ? u.onMeshReadyObservable.notifyObservers(u) : u._internalMeshDataInfo._checkReadinessObserver || (u._internalMeshDataInfo._checkReadinessObserver = u._scene.onBeforeRenderObservable.add(function() {
        u.isReady(!0) && (u._scene.onBeforeRenderObservable.remove(u._internalMeshDataInfo._checkReadinessObserver), u._internalMeshDataInfo._checkReadinessObserver = null, u.onMeshReadyObservable.notifyObservers(u));
      }));
    }, u.onMeshReadyObservable = new O(u._internalMeshDataInfo._onMeshReadyObserverAdded), a && a.onClonedObservable.notifyObservers(u), u;
  }
  return e._GetDefaultSideOrientation = function(t) {
    return t || e.FRONTSIDE;
  }, Object.defineProperty(e.prototype, "useLODScreenCoverage", {
    get: function() {
      return this._internalMeshDataInfo._useLODScreenCoverage;
    },
    set: function(t) {
      this._internalMeshDataInfo._useLODScreenCoverage = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "computeBonesUsingShaders", {
    get: function() {
      return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
    },
    set: function(t) {
      this._internalAbstractMeshDataInfo._computeBonesUsingShaders !== t && (t && this._internalMeshDataInfo._sourcePositions && (this.setVerticesData(m.PositionKind, this._internalMeshDataInfo._sourcePositions, !0), this._internalMeshDataInfo._sourceNormals && this.setVerticesData(m.NormalKind, this._internalMeshDataInfo._sourceNormals, !0), this._internalMeshDataInfo._sourcePositions = null, this._internalMeshDataInfo._sourceNormals = null), this._internalAbstractMeshDataInfo._computeBonesUsingShaders = t, this._markSubMeshesAsAttributesDirty());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "onBeforeRenderObservable", {
    get: function() {
      return this._internalMeshDataInfo._onBeforeRenderObservable || (this._internalMeshDataInfo._onBeforeRenderObservable = new O()), this._internalMeshDataInfo._onBeforeRenderObservable;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "onBeforeBindObservable", {
    get: function() {
      return this._internalMeshDataInfo._onBeforeBindObservable || (this._internalMeshDataInfo._onBeforeBindObservable = new O()), this._internalMeshDataInfo._onBeforeBindObservable;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "onAfterRenderObservable", {
    get: function() {
      return this._internalMeshDataInfo._onAfterRenderObservable || (this._internalMeshDataInfo._onAfterRenderObservable = new O()), this._internalMeshDataInfo._onAfterRenderObservable;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "onBetweenPassObservable", {
    get: function() {
      return this._internalMeshDataInfo._onBetweenPassObservable || (this._internalMeshDataInfo._onBetweenPassObservable = new O()), this._internalMeshDataInfo._onBetweenPassObservable;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "onBeforeDrawObservable", {
    get: function() {
      return this._internalMeshDataInfo._onBeforeDrawObservable || (this._internalMeshDataInfo._onBeforeDrawObservable = new O()), this._internalMeshDataInfo._onBeforeDrawObservable;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "onBeforeDraw", {
    set: function(t) {
      this._onBeforeDrawObserver && this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver), this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "hasInstances", {
    get: function() {
      return this.instances.length > 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "hasThinInstances", {
    get: function() {
      var t;
      return ((t = this._thinInstanceDataStorage.instancesCount) !== null && t !== void 0 ? t : 0) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "forcedInstanceCount", {
    get: function() {
      return this._internalMeshDataInfo._forcedInstanceCount;
    },
    set: function(t) {
      this._internalMeshDataInfo._forcedInstanceCount = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "source", {
    get: function() {
      return this._internalMeshDataInfo._source;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "cloneMeshMap", {
    get: function() {
      return this._internalMeshDataInfo.meshMap;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "isUnIndexed", {
    get: function() {
      return this._unIndexed;
    },
    set: function(t) {
      this._unIndexed !== t && (this._unIndexed = t, this._markSubMeshesAsAttributesDirty());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "worldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.instancesData;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "previousWorldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.instancesPreviousData;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "manualUpdateOfWorldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.manualUpdate;
    },
    set: function(t) {
      this._instanceDataStorage.manualUpdate = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "manualUpdateOfPreviousWorldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.previousManualUpdate;
    },
    set: function(t) {
      this._instanceDataStorage.previousManualUpdate = t;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.instantiateHierarchy = function(t, r, n) {
    t === void 0 && (t = null);
    var a = this.getTotalVertices() > 0 && (!r || !r.doNotInstantiate) ? this.createInstance("instance of " + (this.name || this.id)) : this.clone("Clone of " + (this.name || this.id), t || this.parent, !0);
    a.parent = t || this.parent, a.position = this.position.clone(), a.scaling = this.scaling.clone(), this.rotationQuaternion ? a.rotationQuaternion = this.rotationQuaternion.clone() : a.rotation = this.rotation.clone(), n && n(this, a);
    for (var s = 0, o = this.getChildTransformNodes(!0); s < o.length; s++) {
      var u = o[s];
      u.instantiateHierarchy(a, r, n);
    }
    return a;
  }, e.prototype.getClassName = function() {
    return "Mesh";
  }, Object.defineProperty(e.prototype, "_isMesh", {
    get: function() {
      return !0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.toString = function(t) {
    var r = i.prototype.toString.call(this, t);
    if (r += ", n vertices: " + this.getTotalVertices(), r += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE"), this.animations)
      for (var n = 0; n < this.animations.length; n++)
        r += ", animation[0]: " + this.animations[n].toString(t);
    if (t)
      if (this._geometry) {
        var a = this.getIndices(), s = this.getVerticesData(m.PositionKind);
        s && a && (r += ", flat shading: " + (s.length / 3 === a.length ? "YES" : "NO"));
      } else
        r += ", flat shading: UNKNOWN";
    return r;
  }, e.prototype._unBindEffect = function() {
    i.prototype._unBindEffect.call(this);
    for (var t = 0, r = this.instances; t < r.length; t++) {
      var n = r[t];
      n._unBindEffect();
    }
  }, Object.defineProperty(e.prototype, "hasLODLevels", {
    get: function() {
      return this._internalMeshDataInfo._LODLevels.length > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getLODLevels = function() {
    return this._internalMeshDataInfo._LODLevels;
  }, e.prototype._sortLODLevels = function() {
    var t = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;
    this._internalMeshDataInfo._LODLevels.sort(function(r, n) {
      return r.distanceOrScreenCoverage < n.distanceOrScreenCoverage ? t : r.distanceOrScreenCoverage > n.distanceOrScreenCoverage ? -t : 0;
    });
  }, e.prototype.addLODLevel = function(t, r) {
    if (r && r._masterMesh)
      return k.Warn("You cannot use a mesh as LOD level twice"), this;
    var n = new Pa(t, r);
    return this._internalMeshDataInfo._LODLevels.push(n), r && (r._masterMesh = this), this._sortLODLevels(), this;
  }, e.prototype.getLODLevelAtDistance = function(t) {
    for (var r = this._internalMeshDataInfo, n = 0; n < r._LODLevels.length; n++) {
      var a = r._LODLevels[n];
      if (a.distanceOrScreenCoverage === t)
        return a.mesh;
    }
    return null;
  }, e.prototype.removeLODLevel = function(t) {
    for (var r = this._internalMeshDataInfo, n = 0; n < r._LODLevels.length; n++)
      r._LODLevels[n].mesh === t && (r._LODLevels.splice(n, 1), t && (t._masterMesh = null));
    return this._sortLODLevels(), this;
  }, e.prototype.getLOD = function(t, r) {
    var n = this._internalMeshDataInfo;
    if (!n._LODLevels || n._LODLevels.length === 0)
      return this;
    var a;
    if (r)
      a = r;
    else {
      var s = this.getBoundingInfo();
      a = s.boundingSphere;
    }
    var o = a.centerWorld.subtract(t.globalPosition).length(), u = n._useLODScreenCoverage, f = o, l = 1;
    if (u) {
      var h = t.screenArea, c = a.radiusWorld * t.minZ / o;
      c = c * c * Math.PI, f = c / h, l = -1;
    }
    if (l * n._LODLevels[n._LODLevels.length - 1].distanceOrScreenCoverage > l * f)
      return this.onLODLevelSelection && this.onLODLevelSelection(f, this, this), this;
    for (var d = 0; d < n._LODLevels.length; d++) {
      var p = n._LODLevels[d];
      if (l * p.distanceOrScreenCoverage < l * f) {
        if (p.mesh) {
          if (p.mesh.delayLoadState === 4)
            return p.mesh._checkDelayState(), this;
          if (p.mesh.delayLoadState === 2)
            return this;
          p.mesh._preActivate(), p.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
        }
        return this.onLODLevelSelection && this.onLODLevelSelection(f, this, p.mesh), p.mesh;
      }
    }
    return this.onLODLevelSelection && this.onLODLevelSelection(f, this, this), this;
  }, Object.defineProperty(e.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getTotalVertices = function() {
    return this._geometry === null || this._geometry === void 0 ? 0 : this._geometry.getTotalVertices();
  }, e.prototype.getVerticesData = function(t, r, n) {
    var a, s;
    if (!this._geometry)
      return null;
    var o = (s = (a = this._userInstancedBuffersStorage) === null || a === void 0 ? void 0 : a.vertexBuffers[t]) === null || s === void 0 ? void 0 : s.getFloatData(this._geometry.getTotalVertices(), n || r && this._geometry.meshes.length !== 1);
    return o || (o = this._geometry.getVerticesData(t, r, n)), o;
  }, e.prototype.getVertexBuffer = function(t) {
    var r, n;
    return this._geometry ? (n = (r = this._userInstancedBuffersStorage) === null || r === void 0 ? void 0 : r.vertexBuffers[t]) !== null && n !== void 0 ? n : this._geometry.getVertexBuffer(t) : null;
  }, e.prototype.isVerticesDataPresent = function(t) {
    var r;
    return this._geometry ? ((r = this._userInstancedBuffersStorage) === null || r === void 0 ? void 0 : r.vertexBuffers[t]) !== void 0 || this._geometry.isVerticesDataPresent(t) : this._delayInfo ? this._delayInfo.indexOf(t) !== -1 : !1;
  }, e.prototype.isVertexBufferUpdatable = function(t) {
    var r, n;
    return this._geometry ? ((n = (r = this._userInstancedBuffersStorage) === null || r === void 0 ? void 0 : r.vertexBuffers[t]) === null || n === void 0 ? void 0 : n.isUpdatable()) || this._geometry.isVertexBufferUpdatable(t) : this._delayInfo ? this._delayInfo.indexOf(t) !== -1 : !1;
  }, e.prototype.getVerticesDataKinds = function() {
    if (!this._geometry) {
      var t = new Array();
      return this._delayInfo && this._delayInfo.forEach(function(a) {
        t.push(a);
      }), t;
    }
    var r = this._geometry.getVerticesDataKinds();
    if (this._userInstancedBuffersStorage)
      for (var n in this._userInstancedBuffersStorage.vertexBuffers)
        r.push(n);
    return r;
  }, e.prototype.getTotalIndices = function() {
    return this._geometry ? this._geometry.getTotalIndices() : 0;
  }, e.prototype.getIndices = function(t, r) {
    return this._geometry ? this._geometry.getIndices(t, r) : [];
  }, Object.defineProperty(e.prototype, "isBlocked", {
    get: function() {
      return this._masterMesh !== null && this._masterMesh !== void 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.isReady = function(t, r) {
    var n, a, s, o, u, f;
    if (t === void 0 && (t = !1), r === void 0 && (r = !1), this.delayLoadState === 2 || !i.prototype.isReady.call(this, t))
      return !1;
    if (!this.subMeshes || this.subMeshes.length === 0 || !t)
      return !0;
    var l = this.getEngine(), h = this.getScene(), c = r || l.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);
    this.computeWorldMatrix();
    var d = this.material || h.defaultMaterial;
    if (d) {
      if (d._storeEffectOnSubMeshes)
        for (var p = 0, g = this.subMeshes; p < g.length; p++) {
          var _ = g[p], v = _.getMaterial();
          if (v) {
            if (v._storeEffectOnSubMeshes) {
              if (!v.isReadyForSubMesh(this, _, c))
                return !1;
            } else if (!v.isReady(this, c))
              return !1;
          }
        }
      else if (!d.isReady(this, c))
        return !1;
    }
    for (var y = l.currentRenderPassId, E = 0, R = this.lightSources; E < R.length; E++) {
      var M = R[E], C = M.getShadowGenerator();
      if (C && (!(!((n = C.getShadowMap()) === null || n === void 0) && n.renderList) || ((a = C.getShadowMap()) === null || a === void 0 ? void 0 : a.renderList) && ((o = (s = C.getShadowMap()) === null || s === void 0 ? void 0 : s.renderList) === null || o === void 0 ? void 0 : o.indexOf(this)) !== -1)) {
        C.getShadowMap() && (l.currentRenderPassId = C.getShadowMap().renderPassId);
        for (var A = 0, S = this.subMeshes; A < S.length; A++) {
          var _ = S[A];
          if (!C.isReady(_, c, (f = (u = _.getMaterial()) === null || u === void 0 ? void 0 : u.needAlphaBlendingForMesh(this)) !== null && f !== void 0 ? f : !1))
            return l.currentRenderPassId = y, !1;
        }
        l.currentRenderPassId = y;
      }
    }
    for (var w = 0, F = this._internalMeshDataInfo._LODLevels; w < F.length; w++) {
      var x = F[w];
      if (x.mesh && !x.mesh.isReady(c))
        return !1;
    }
    return !0;
  }, Object.defineProperty(e.prototype, "areNormalsFrozen", {
    get: function() {
      return this._internalMeshDataInfo._areNormalsFrozen;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.freezeNormals = function() {
    return this._internalMeshDataInfo._areNormalsFrozen = !0, this;
  }, e.prototype.unfreezeNormals = function() {
    return this._internalMeshDataInfo._areNormalsFrozen = !1, this;
  }, Object.defineProperty(e.prototype, "overridenInstanceCount", {
    set: function(t) {
      this._instanceDataStorage.overridenInstanceCount = t;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._preActivate = function() {
    var t = this._internalMeshDataInfo, r = this.getScene().getRenderId();
    return t._preActivateId === r ? this : (t._preActivateId = r, this._instanceDataStorage.visibleInstances = null, this);
  }, e.prototype._preActivateForIntermediateRendering = function(t) {
    return this._instanceDataStorage.visibleInstances && (this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = t), this;
  }, e.prototype._registerInstanceForRenderId = function(t, r) {
    return this._instanceDataStorage.visibleInstances || (this._instanceDataStorage.visibleInstances = {
      defaultRenderId: r,
      selfDefaultRenderId: this._renderId
    }), this._instanceDataStorage.visibleInstances[r] || (this._instanceDataStorage.previousRenderId !== void 0 && this._instanceDataStorage.isFrozen && (this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null), this._instanceDataStorage.previousRenderId = r, this._instanceDataStorage.visibleInstances[r] = new Array()), this._instanceDataStorage.visibleInstances[r].push(t), this;
  }, e.prototype._afterComputeWorldMatrix = function() {
    i.prototype._afterComputeWorldMatrix.call(this), this.hasThinInstances && (this.doNotSyncBoundingInfo || this.thinInstanceRefreshBoundingInfo(!1));
  }, e.prototype._postActivate = function() {
    this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup && (this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer), this.edgesRenderer.customInstances.push(this.getWorldMatrix()));
  }, e.prototype.refreshBoundingInfo = function(t, r) {
    if (t === void 0 && (t = !1), r === void 0 && (r = !1), this.hasBoundingInfo && this.getBoundingInfo().isLocked)
      return this;
    var n = this.geometry ? this.geometry.boundingBias : null;
    return this._refreshBoundingInfo(this._getPositionData(t, r), n), this;
  }, e.prototype._createGlobalSubMesh = function(t) {
    var r = this.getTotalVertices();
    if (!r || !this.getIndices())
      return null;
    if (this.subMeshes && this.subMeshes.length > 0) {
      var n = this.getIndices();
      if (!n)
        return null;
      var a = n.length, s = !1;
      if (t)
        s = !0;
      else
        for (var o = 0, u = this.subMeshes; o < u.length; o++) {
          var f = u[o];
          if (f.indexStart + f.indexCount > a) {
            s = !0;
            break;
          }
          if (f.verticesStart + f.verticesCount > r) {
            s = !0;
            break;
          }
        }
      if (!s)
        return this.subMeshes[0];
    }
    return this.releaseSubMeshes(), new mt(0, 0, r, 0, this.getTotalIndices(), this);
  }, e.prototype.subdivide = function(t) {
    if (!(t < 1)) {
      for (var r = this.getTotalIndices(), n = r / t | 0, a = 0; n % 3 !== 0; )
        n++;
      this.releaseSubMeshes();
      for (var s = 0; s < t && !(a >= r); s++)
        mt.CreateFromIndices(0, a, s === t - 1 ? r - a : n, this), a += n;
      this.synchronizeInstances();
    }
  }, e.prototype.setVerticesData = function(t, r, n, a) {
    if (n === void 0 && (n = !1), this._geometry)
      this._geometry.setVerticesData(t, r, n, a);
    else {
      var s = new _e();
      s.set(r, t);
      var o = this.getScene();
      new gt(gt.RandomId(), o, s, n, this);
    }
    return this;
  }, e.prototype.removeVerticesData = function(t) {
    !this._geometry || this._geometry.removeVerticesData(t);
  }, e.prototype.markVerticesDataAsUpdatable = function(t, r) {
    r === void 0 && (r = !0);
    var n = this.getVertexBuffer(t);
    !n || n.isUpdatable() === r || this.setVerticesData(t, this.getVerticesData(t), r);
  }, e.prototype.setVerticesBuffer = function(t, r) {
    return r === void 0 && (r = !0), this._geometry || (this._geometry = gt.CreateGeometryForMesh(this)), this._geometry.setVerticesBuffer(t, null, r), this;
  }, e.prototype.updateVerticesData = function(t, r, n, a) {
    return this._geometry ? (a ? (this.makeGeometryUnique(), this.updateVerticesData(t, r, n, !1)) : this._geometry.updateVerticesData(t, r, n), this) : this;
  }, e.prototype.updateMeshPositions = function(t, r) {
    r === void 0 && (r = !0);
    var n = this.getVerticesData(m.PositionKind);
    if (!n)
      return this;
    if (t(n), this.updateVerticesData(m.PositionKind, n, !1, !1), r) {
      var a = this.getIndices(), s = this.getVerticesData(m.NormalKind);
      if (!s)
        return this;
      _e.ComputeNormals(n, a, s), this.updateVerticesData(m.NormalKind, s, !1, !1);
    }
    return this;
  }, e.prototype.makeGeometryUnique = function() {
    if (!this._geometry)
      return this;
    if (this._geometry.meshes.length === 1)
      return this;
    var t = this._geometry, r = this._geometry.copy(gt.RandomId());
    return t.releaseForMesh(this, !0), r.applyToMesh(this), this;
  }, e.prototype.setIndices = function(t, r, n) {
    if (r === void 0 && (r = null), n === void 0 && (n = !1), this._geometry)
      this._geometry.setIndices(t, r, n);
    else {
      var a = new _e();
      a.indices = t;
      var s = this.getScene();
      new gt(gt.RandomId(), s, a, n, this);
    }
    return this;
  }, e.prototype.updateIndices = function(t, r, n) {
    return n === void 0 && (n = !1), this._geometry ? (this._geometry.updateIndices(t, r, n), this) : this;
  }, e.prototype.toLeftHanded = function() {
    return this._geometry ? (this._geometry.toLeftHanded(), this) : this;
  }, e.prototype._bind = function(t, r, n) {
    if (!this._geometry)
      return this;
    var a = this.getScene().getEngine();
    this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets && this.morphTargetManager._bind(r);
    var s;
    if (this._unIndexed)
      s = null;
    else
      switch (n) {
        case Ie.PointFillMode:
          s = null;
          break;
        case Ie.WireFrameFillMode:
          s = t._getLinesIndexBuffer(this.getIndices(), a);
          break;
        default:
        case Ie.TriangleFillMode:
          s = this._geometry.getIndexBuffer();
          break;
      }
    return !this._userInstancedBuffersStorage || this.hasThinInstances ? this._geometry._bind(r, s) : this._geometry._bind(r, s, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects), this;
  }, e.prototype._draw = function(t, r, n) {
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer())
      return this;
    this._internalMeshDataInfo._onBeforeDrawObservable && this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);
    var a = this.getScene(), s = a.getEngine();
    return this._unIndexed || r == Ie.PointFillMode ? s.drawArraysType(r, t.verticesStart, t.verticesCount, this.forcedInstanceCount || n) : r == Ie.WireFrameFillMode ? s.drawElementsType(r, 0, t._linesIndexCount, this.forcedInstanceCount || n) : s.drawElementsType(r, t.indexStart, t.indexCount, this.forcedInstanceCount || n), this;
  }, e.prototype.registerBeforeRender = function(t) {
    return this.onBeforeRenderObservable.add(t), this;
  }, e.prototype.unregisterBeforeRender = function(t) {
    return this.onBeforeRenderObservable.removeCallback(t), this;
  }, e.prototype.registerAfterRender = function(t) {
    return this.onAfterRenderObservable.add(t), this;
  }, e.prototype.unregisterAfterRender = function(t) {
    return this.onAfterRenderObservable.removeCallback(t), this;
  }, e.prototype._getInstancesRenderList = function(t, r) {
    if (r === void 0 && (r = !1), this._instanceDataStorage.isFrozen) {
      if (r)
        return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[t] = !1, this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[t] = !0, this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;
      if (this._instanceDataStorage.previousBatch)
        return this._instanceDataStorage.previousBatch;
    }
    var n = this.getScene(), a = n._isInIntermediateRendering(), s = a ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances, o = this._instanceDataStorage.batchCache;
    if (o.mustReturn = !1, o.renderSelf[t] = r || !s && this.isEnabled() && this.isVisible, o.visibleInstances[t] = null, this._instanceDataStorage.visibleInstances && !r) {
      var u = this._instanceDataStorage.visibleInstances, f = n.getRenderId(), l = a ? u.intermediateDefaultRenderId : u.defaultRenderId;
      o.visibleInstances[t] = u[f], !o.visibleInstances[t] && l && (o.visibleInstances[t] = u[l]);
    }
    return o.hardwareInstancedRendering[t] = !r && this._instanceDataStorage.hardwareInstancedRendering && o.visibleInstances[t] !== null && o.visibleInstances[t] !== void 0, this._instanceDataStorage.previousBatch = o, o;
  }, e.prototype._renderWithInstances = function(t, r, n, a, s) {
    var o, u = n.visibleInstances[t._id];
    if (!u)
      return this;
    for (var f = this._instanceDataStorage, l = f.instancesBufferSize, h = f.instancesBuffer, c = f.instancesPreviousBuffer, d = u.length + 1, p = d * 16 * 4; f.instancesBufferSize < p; )
      f.instancesBufferSize *= 2;
    (!f.instancesData || l != f.instancesBufferSize) && (f.instancesData = new Float32Array(f.instancesBufferSize / 4)), (this._scene.needsPreviousWorldMatrices && !f.instancesPreviousData || l != f.instancesBufferSize) && (f.instancesPreviousData = new Float32Array(f.instancesBufferSize / 4));
    var g = 0, _ = 0, v = n.renderSelf[t._id], y = !h || l !== f.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !f.instancesPreviousBuffer;
    if (!this._instanceDataStorage.manualUpdate && (!f.isFrozen || y)) {
      var E = this.getWorldMatrix();
      if (v && (this._scene.needsPreviousWorldMatrices && (f.masterMeshPreviousWorldMatrix ? (f.masterMeshPreviousWorldMatrix.copyToArray(f.instancesPreviousData, g), f.masterMeshPreviousWorldMatrix.copyFrom(E)) : (f.masterMeshPreviousWorldMatrix = E.clone(), f.masterMeshPreviousWorldMatrix.copyToArray(f.instancesPreviousData, g))), E.copyToArray(f.instancesData, g), g += 16, _++), u) {
        if (e.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && ((o = t.getMaterial()) === null || o === void 0 ? void 0 : o.needAlphaBlendingForMesh(t.getRenderingMesh()))) {
          for (var R = this._scene.activeCamera.globalPosition, M = 0; M < u.length; M++) {
            var C = u[M];
            C._distanceToCamera = b.Distance(C.getBoundingInfo().boundingSphere.centerWorld, R);
          }
          u.sort(function(w, F) {
            return w._distanceToCamera > F._distanceToCamera ? -1 : w._distanceToCamera < F._distanceToCamera ? 1 : 0;
          });
        }
        for (var M = 0; M < u.length; M++) {
          var A = u[M], S = A.getWorldMatrix();
          S.copyToArray(f.instancesData, g), this._scene.needsPreviousWorldMatrices && (A._previousWorldMatrix ? (A._previousWorldMatrix.copyToArray(f.instancesPreviousData, g), A._previousWorldMatrix.copyFrom(S)) : (A._previousWorldMatrix = S.clone(), A._previousWorldMatrix.copyToArray(f.instancesPreviousData, g))), g += 16, _++;
        }
      }
    } else
      _ = (v ? 1 : 0) + u.length;
    return y ? (h && h.dispose(), c && c.dispose(), h = new Sr(s, f.instancesData, !0, 16, !1, !0), f.instancesBuffer = h, this._userInstancedBuffersStorage || (this._userInstancedBuffersStorage = {
      data: {},
      vertexBuffers: {},
      strides: {},
      sizes: {},
      vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
    }), this._userInstancedBuffersStorage.vertexBuffers.world0 = h.createVertexBuffer("world0", 0, 4), this._userInstancedBuffersStorage.vertexBuffers.world1 = h.createVertexBuffer("world1", 4, 4), this._userInstancedBuffersStorage.vertexBuffers.world2 = h.createVertexBuffer("world2", 8, 4), this._userInstancedBuffersStorage.vertexBuffers.world3 = h.createVertexBuffer("world3", 12, 4), this._scene.needsPreviousWorldMatrices && (c = new Sr(s, f.instancesPreviousData, !0, 16, !1, !0), f.instancesPreviousBuffer = c, this._userInstancedBuffersStorage.vertexBuffers.previousWorld0 = c.createVertexBuffer("previousWorld0", 0, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld1 = c.createVertexBuffer("previousWorld1", 4, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld2 = c.createVertexBuffer("previousWorld2", 8, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld3 = c.createVertexBuffer("previousWorld3", 12, 4)), this._invalidateInstanceVertexArrayObject()) : this._instanceDataStorage.isFrozen || (h.updateDirectly(f.instancesData, 0, _), this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate) && c.updateDirectly(f.instancesPreviousData, 0, _)), this._processInstancedBuffers(u, v), this.getScene()._activeIndices.addCount(t.indexCount * _, !1), s._currentDrawContext && (s._currentDrawContext.useInstancing = !0), this._bind(t, a, r), this._draw(t, r, _), this._scene.needsPreviousWorldMatrices && !y && this._instanceDataStorage.manualUpdate && !this._instanceDataStorage.isFrozen && !this._instanceDataStorage.previousManualUpdate && c.updateDirectly(f.instancesData, 0, _), s.unbindInstanceAttributes(), this;
  }, e.prototype._renderWithThinInstances = function(t, r, n, a) {
    var s, o, u = (o = (s = this._thinInstanceDataStorage) === null || s === void 0 ? void 0 : s.instancesCount) !== null && o !== void 0 ? o : 0;
    this.getScene()._activeIndices.addCount(t.indexCount * u, !1), a._currentDrawContext && (a._currentDrawContext.useInstancing = !0), this._bind(t, n, r), this._draw(t, r, u), this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData && (this._thinInstanceDataStorage.previousMatrixBuffer ? this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, u) : this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.matrixData, !1)), a.unbindInstanceAttributes();
  }, e.prototype._processInstancedBuffers = function(t, r) {
  }, e.prototype._processRendering = function(t, r, n, a, s, o, u, f) {
    var l = this.getScene(), h = l.getEngine();
    if (o && r.getRenderingMesh().hasThinInstances)
      return this._renderWithThinInstances(r, a, n, h), this;
    if (o)
      this._renderWithInstances(r, a, s, n, h);
    else {
      h._currentDrawContext && (h._currentDrawContext.useInstancing = !1);
      var c = 0;
      s.renderSelf[r._id] && (u && u(!1, t.getWorldMatrix(), f), c++, this._draw(r, a, this._instanceDataStorage.overridenInstanceCount));
      var d = s.visibleInstances[r._id];
      if (d) {
        var p = d.length;
        c += p;
        for (var g = 0; g < p; g++) {
          var _ = d[g], v = _.getWorldMatrix();
          u && u(!0, v, f), this._draw(r, a);
        }
      }
      l._activeIndices.addCount(r.indexCount * c, !1);
    }
    return this;
  }, e.prototype._rebuild = function(t) {
    if (t === void 0 && (t = !1), this._instanceDataStorage.instancesBuffer && (t && this._instanceDataStorage.instancesBuffer.dispose(), this._instanceDataStorage.instancesBuffer = null), this._userInstancedBuffersStorage) {
      for (var r in this._userInstancedBuffersStorage.vertexBuffers) {
        var n = this._userInstancedBuffersStorage.vertexBuffers[r];
        n && (t && n.dispose(), this._userInstancedBuffersStorage.vertexBuffers[r] = null);
      }
      this._userInstancedBuffersStorage.vertexArrayObjects && (this._userInstancedBuffersStorage.vertexArrayObjects = {});
    }
    this._internalMeshDataInfo._effectiveMaterial = null, i.prototype._rebuild.call(this, t);
  }, e.prototype._freeze = function() {
    if (!!this.subMeshes) {
      for (var t = 0; t < this.subMeshes.length; t++)
        this._getInstancesRenderList(t);
      this._internalMeshDataInfo._effectiveMaterial = null, this._instanceDataStorage.isFrozen = !0;
    }
  }, e.prototype._unFreeze = function() {
    this._instanceDataStorage.isFrozen = !1, this._instanceDataStorage.previousBatch = null;
  }, e.prototype.render = function(t, r, n) {
    var a, s, o, u = this.getScene();
    if (this._internalAbstractMeshDataInfo._isActiveIntermediate ? this._internalAbstractMeshDataInfo._isActiveIntermediate = !1 : this._internalAbstractMeshDataInfo._isActive = !1, this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded)
      return this;
    var f = this._getInstancesRenderList(t._id, !!n);
    if (f.mustReturn)
      return this;
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer())
      return this;
    var l = u.getEngine(), h = 0, c = null;
    this.ignoreCameraMaxZ && u.activeCamera && !u._isInIntermediateRendering() && (h = u.activeCamera.maxZ, c = u.activeCamera, u.activeCamera.maxZ = 0, u.updateTransformMatrix(!0)), this._internalMeshDataInfo._onBeforeRenderObservable && this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);
    var d = f.hardwareInstancedRendering[t._id] || t.getRenderingMesh().hasThinInstances, p = this._instanceDataStorage, g = t.getMaterial();
    if (!g)
      return c && (c.maxZ = h, u.updateTransformMatrix(!0)), this;
    if (!p.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== g) {
      if (g._storeEffectOnSubMeshes) {
        if (!g.isReadyForSubMesh(this, t, d))
          return c && (c.maxZ = h, u.updateTransformMatrix(!0)), this;
      } else if (!g.isReady(this, d))
        return c && (c.maxZ = h, u.updateTransformMatrix(!0)), this;
      this._internalMeshDataInfo._effectiveMaterial = g;
    } else if (g._storeEffectOnSubMeshes && !(!((a = t.effect) === null || a === void 0) && a._wasPreviouslyReady) || !g._storeEffectOnSubMeshes && !(!((s = g.getEffect()) === null || s === void 0) && s._wasPreviouslyReady))
      return c && (c.maxZ = h, u.updateTransformMatrix(!0)), this;
    r && l.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);
    var _;
    this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes ? _ = t._drawWrapper : _ = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();
    for (var v = (o = _ == null ? void 0 : _.effect) !== null && o !== void 0 ? o : null, y = 0, E = u._beforeRenderingMeshStage; y < E.length; y++) {
      var R = E[y];
      R.action(this, t, f, v);
    }
    if (!_ || !v)
      return c && (c.maxZ = h, u.updateTransformMatrix(!0)), this;
    var M = n || this, C;
    if (!p.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {
      var A = M._getWorldMatrixDeterminant();
      C = this.overrideMaterialSideOrientation, C == null && (C = this._internalMeshDataInfo._effectiveMaterial.sideOrientation), A < 0 && (C = C === Ie.ClockWiseSideOrientation ? Ie.CounterClockWiseSideOrientation : Ie.ClockWiseSideOrientation), p.sideOrientation = C;
    } else
      C = p.sideOrientation;
    var S = this._internalMeshDataInfo._effectiveMaterial._preBind(_, C);
    this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite && l.setDepthWrite(!0);
    var w = u.forcePointsCloud ? Ie.PointFillMode : u.forceWireframe ? Ie.WireFrameFillMode : this._internalMeshDataInfo._effectiveMaterial.fillMode;
    this._internalMeshDataInfo._onBeforeBindObservable && this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this), d || this._bind(t, v, w);
    var F = this._internalMeshDataInfo._effectiveMaterial, x = M.getWorldMatrix();
    F._storeEffectOnSubMeshes ? F.bindForSubMesh(x, this, t) : F.bind(x, this), !F.backFaceCulling && F.separateCullingPass && (l.setState(!0, F.zOffset, !1, !S, F.cullBackFaces, F.stencil, F.zOffsetUnits), this._processRendering(this, t, v, w, f, d, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial), l.setState(!0, F.zOffset, !1, S, F.cullBackFaces, F.stencil, F.zOffsetUnits), this._internalMeshDataInfo._onBetweenPassObservable && this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(t)), this._processRendering(this, t, v, w, f, d, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial), this._internalMeshDataInfo._effectiveMaterial.unbind();
    for (var z = 0, W = u._afterRenderingMeshStage; z < W.length; z++) {
      var R = W[z];
      R.action(this, t, f, v);
    }
    return this._internalMeshDataInfo._onAfterRenderObservable && this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this), c && (c.maxZ = h, u.updateTransformMatrix(!0)), this;
  }, e.prototype.cleanMatrixWeights = function() {
    this.isVerticesDataPresent(m.MatricesWeightsKind) && (this.isVerticesDataPresent(m.MatricesWeightsExtraKind) ? this._normalizeSkinWeightsAndExtra() : this._normalizeSkinFourWeights());
  }, e.prototype._normalizeSkinFourWeights = function() {
    for (var t = this.getVerticesData(m.MatricesWeightsKind), r = t.length, n = 0; n < r; n += 4) {
      var a = t[n] + t[n + 1] + t[n + 2] + t[n + 3];
      if (a === 0)
        t[n] = 1;
      else {
        var s = 1 / a;
        t[n] *= s, t[n + 1] *= s, t[n + 2] *= s, t[n + 3] *= s;
      }
    }
    this.setVerticesData(m.MatricesWeightsKind, t);
  }, e.prototype._normalizeSkinWeightsAndExtra = function() {
    for (var t = this.getVerticesData(m.MatricesWeightsExtraKind), r = this.getVerticesData(m.MatricesWeightsKind), n = r.length, a = 0; a < n; a += 4) {
      var s = r[a] + r[a + 1] + r[a + 2] + r[a + 3];
      if (s += t[a] + t[a + 1] + t[a + 2] + t[a + 3], s === 0)
        r[a] = 1;
      else {
        var o = 1 / s;
        r[a] *= o, r[a + 1] *= o, r[a + 2] *= o, r[a + 3] *= o, t[a] *= o, t[a + 1] *= o, t[a + 2] *= o, t[a + 3] *= o;
      }
    }
    this.setVerticesData(m.MatricesWeightsKind, r), this.setVerticesData(m.MatricesWeightsKind, t);
  }, e.prototype.validateSkinning = function() {
    var t = this.getVerticesData(m.MatricesWeightsExtraKind), r = this.getVerticesData(m.MatricesWeightsKind);
    if (r === null || this.skeleton == null)
      return { skinned: !1, valid: !0, report: "not skinned" };
    for (var n = r.length, a = 0, s = 0, o = 0, u = 0, f = t === null ? 4 : 8, l = new Array(), h = 0; h <= f; h++)
      l[h] = 0;
    for (var c = 1e-3, h = 0; h < n; h += 4) {
      for (var d = r[h], p = d, g = p === 0 ? 0 : 1, _ = 1; _ < f; _++) {
        var v = _ < 4 ? r[h + _] : t[h + _ - 4];
        v > d && a++, v !== 0 && g++, p += v, d = v;
      }
      if (l[g]++, g > o && (o = g), p === 0)
        s++;
      else {
        for (var y = 1 / p, E = 0, _ = 0; _ < f; _++)
          _ < 4 ? E += Math.abs(r[h + _] - r[h + _] * y) : E += Math.abs(t[h + _ - 4] - t[h + _ - 4] * y);
        E > c && u++;
      }
    }
    for (var R = this.skeleton.bones.length, M = this.getVerticesData(m.MatricesIndicesKind), C = this.getVerticesData(m.MatricesIndicesExtraKind), A = 0, h = 0; h < n; h += 4)
      for (var _ = 0; _ < f; _++) {
        var S = _ < 4 ? M[h + _] : C[h + _ - 4];
        (S >= R || S < 0) && A++;
      }
    var w = "Number of Weights = " + n / 4 + `
Maximum influences = ` + o + `
Missing Weights = ` + s + `
Not Sorted = ` + a + `
Not Normalized = ` + u + `
WeightCounts = [` + l + `]
Number of bones = ` + R + `
Bad Bone Indices = ` + A;
    return { skinned: !0, valid: s === 0 && u === 0 && A === 0, report: w };
  }, e.prototype._checkDelayState = function() {
    var t = this.getScene();
    return this._geometry ? this._geometry.load(t) : this.delayLoadState === 4 && (this.delayLoadState = 2, this._queueLoad(t)), this;
  }, e.prototype._queueLoad = function(t) {
    var r = this;
    t._addPendingData(this);
    var n = this.delayLoadingFile.indexOf(".babylonbinarymeshdata") !== -1;
    return de.LoadFile(this.delayLoadingFile, function(a) {
      a instanceof ArrayBuffer ? r._delayLoadingFunction(a, r) : r._delayLoadingFunction(JSON.parse(a), r), r.instances.forEach(function(s) {
        s.refreshBoundingInfo(), s._syncSubMeshes();
      }), r.delayLoadState = 1, t._removePendingData(r);
    }, function() {
    }, t.offlineProvider, n), this;
  }, e.prototype.isInFrustum = function(t) {
    return this.delayLoadState === 2 || !i.prototype.isInFrustum.call(this, t) ? !1 : (this._checkDelayState(), !0);
  }, e.prototype.setMaterialById = function(t) {
    var r = this.getScene().materials, n;
    for (n = r.length - 1; n > -1; n--)
      if (r[n].id === t)
        return this.material = r[n], this;
    var a = this.getScene().multiMaterials;
    for (n = a.length - 1; n > -1; n--)
      if (a[n].id === t)
        return this.material = a[n], this;
    return this;
  }, e.prototype.getAnimatables = function() {
    var t = new Array();
    return this.material && t.push(this.material), this.skeleton && t.push(this.skeleton), t;
  }, e.prototype.bakeTransformIntoVertices = function(t) {
    if (!this.isVerticesDataPresent(m.PositionKind))
      return this;
    var r = this.subMeshes.splice(0);
    this._resetPointsArrayCache();
    var n = this.getVerticesData(m.PositionKind), a = new Array(), s;
    for (s = 0; s < n.length; s += 3)
      b.TransformCoordinates(b.FromArray(n, s), t).toArray(a, s);
    if (this.setVerticesData(m.PositionKind, a, this.getVertexBuffer(m.PositionKind).isUpdatable()), this.isVerticesDataPresent(m.NormalKind)) {
      for (n = this.getVerticesData(m.NormalKind), a = [], s = 0; s < n.length; s += 3)
        b.TransformNormal(b.FromArray(n, s), t).normalize().toArray(a, s);
      this.setVerticesData(m.NormalKind, a, this.getVertexBuffer(m.NormalKind).isUpdatable());
    }
    return t.determinant() < 0 && this.flipFaces(), this.releaseSubMeshes(), this.subMeshes = r, this;
  }, e.prototype.bakeCurrentTransformIntoVertices = function(t) {
    return t === void 0 && (t = !0), this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)), this.resetLocalMatrix(t), this;
  }, Object.defineProperty(e.prototype, "_positions", {
    get: function() {
      return this._internalAbstractMeshDataInfo._positions ? this._internalAbstractMeshDataInfo._positions : this._geometry ? this._geometry._positions : null;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._resetPointsArrayCache = function() {
    return this._geometry && this._geometry._resetPointsArrayCache(), this;
  }, e.prototype._generatePointsArray = function() {
    return this._geometry ? this._geometry._generatePointsArray() : !1;
  }, e.prototype.clone = function(t, r, n, a) {
    return t === void 0 && (t = ""), r === void 0 && (r = null), a === void 0 && (a = !0), new e(t, this.getScene(), r, this, n, a);
  }, e.prototype.dispose = function(t, r) {
    r === void 0 && (r = !1), this.morphTargetManager = null, this._geometry && this._geometry.releaseForMesh(this, !0);
    var n = this._internalMeshDataInfo;
    if (n._onBeforeDrawObservable && n._onBeforeDrawObservable.clear(), n._onBeforeBindObservable && n._onBeforeBindObservable.clear(), n._onBeforeRenderObservable && n._onBeforeRenderObservable.clear(), n._onAfterRenderObservable && n._onAfterRenderObservable.clear(), n._onBetweenPassObservable && n._onBetweenPassObservable.clear(), this._scene.useClonedMeshMap) {
      if (n.meshMap)
        for (var a in n.meshMap) {
          var s = n.meshMap[a];
          s && (s._internalMeshDataInfo._source = null, n.meshMap[a] = void 0);
        }
      n._source && n._source._internalMeshDataInfo.meshMap && (n._source._internalMeshDataInfo.meshMap[this.uniqueId] = void 0);
    } else
      for (var o = this.getScene().meshes, u = 0, f = o; u < f.length; u++) {
        var l = f[u], s = l;
        s._internalMeshDataInfo && s._internalMeshDataInfo._source && s._internalMeshDataInfo._source === this && (s._internalMeshDataInfo._source = null);
      }
    n._source = null, this._disposeInstanceSpecificData(), this._disposeThinInstanceSpecificData(), this._internalMeshDataInfo._checkReadinessObserver && this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver), i.prototype.dispose.call(this, t, r);
  }, e.prototype._disposeInstanceSpecificData = function() {
  }, e.prototype._disposeThinInstanceSpecificData = function() {
  }, e.prototype._invalidateInstanceVertexArrayObject = function() {
  }, e.prototype.applyDisplacementMap = function(t, r, n, a, s, o, u) {
    var f = this;
    u === void 0 && (u = !1);
    var l = this.getScene(), h = function(c) {
      var d = c.width, p = c.height, g = f.getEngine().createCanvas(d, p), _ = g.getContext("2d");
      _.drawImage(c, 0, 0);
      var v = _.getImageData(0, 0, d, p).data;
      f.applyDisplacementMapFromBuffer(v, d, p, r, n, s, o, u), a && a(f);
    };
    return de.LoadImage(t, h, function() {
    }, l.offlineProvider), this;
  }, e.prototype.applyDisplacementMapFromBuffer = function(t, r, n, a, s, o, u, f) {
    if (f === void 0 && (f = !1), !this.isVerticesDataPresent(m.PositionKind) || !this.isVerticesDataPresent(m.NormalKind) || !this.isVerticesDataPresent(m.UVKind))
      return k.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing"), this;
    var l = this.getVerticesData(m.PositionKind, !0, !0), h = this.getVerticesData(m.NormalKind), c = this.getVerticesData(m.UVKind), d = b.Zero(), p = b.Zero(), g = Ee.Zero();
    o = o || Ee.Zero(), u = u || new Ee(1, 1);
    for (var _ = 0; _ < l.length; _ += 3) {
      b.FromArrayToRef(l, _, d), b.FromArrayToRef(h, _, p), Ee.FromArrayToRef(c, _ / 3 * 2, g);
      var v = Math.abs(g.x * u.x + o.x % 1) * (r - 1) % r | 0, y = Math.abs(g.y * u.y + o.y % 1) * (n - 1) % n | 0, E = (v + y * r) * 4, R = t[E] / 255, M = t[E + 1] / 255, C = t[E + 2] / 255, A = R * 0.3 + M * 0.59 + C * 0.11;
      p.normalize(), p.scaleInPlace(a + (s - a) * A), d = d.add(p), d.toArray(l, _);
    }
    return _e.ComputeNormals(l, this.getIndices(), h), f ? (this.setVerticesData(m.PositionKind, l), this.setVerticesData(m.NormalKind, h), this.setVerticesData(m.UVKind, c)) : (this.updateVerticesData(m.PositionKind, l), this.updateVerticesData(m.NormalKind, h)), this;
  }, e.prototype.convertToFlatShadedMesh = function() {
    var t = this.getVerticesDataKinds(), r = {}, n = {}, a = {}, s = !1, o, u;
    for (o = 0; o < t.length; o++) {
      u = t[o];
      var f = this.getVertexBuffer(u), l = f.getData();
      if (!((l instanceof Array || l instanceof Float32Array) && l.length === 0)) {
        if (u === m.NormalKind) {
          s = f.isUpdatable(), t.splice(o, 1), o--;
          continue;
        }
        r[u] = f, n[u] = this.getVerticesData(u), a[u] = [];
      }
    }
    var h = this.subMeshes.slice(0), c = this.getIndices(), d = this.getTotalIndices(), p;
    for (p = 0; p < d; p++) {
      var g = c[p];
      for (o = 0; o < t.length; o++)
        if (u = t[o], !!r[u])
          for (var _ = r[u].getStrideSize(), v = 0; v < _; v++)
            a[u].push(n[u][g * _ + v]);
    }
    var y = [], E = a[m.PositionKind], R = this.getScene().useRightHandedSystem, M;
    for (R ? M = this.overrideMaterialSideOrientation === 1 : M = this.overrideMaterialSideOrientation === 0, p = 0; p < d; p += 3) {
      c[p] = p, c[p + 1] = p + 1, c[p + 2] = p + 2;
      var C = b.FromArray(E, p * 3), A = b.FromArray(E, (p + 1) * 3), S = b.FromArray(E, (p + 2) * 3), w = C.subtract(A), F = S.subtract(A), x = b.Normalize(b.Cross(w, F));
      M && x.scaleInPlace(-1);
      for (var z = 0; z < 3; z++)
        y.push(x.x), y.push(x.y), y.push(x.z);
    }
    for (this.setIndices(c), this.setVerticesData(m.NormalKind, y, s), o = 0; o < t.length; o++)
      u = t[o], a[u] && this.setVerticesData(u, a[u], r[u].isUpdatable());
    this.releaseSubMeshes();
    for (var W = 0; W < h.length; W++) {
      var N = h[W];
      mt.AddToMesh(N.materialIndex, N.indexStart, N.indexCount, N.indexStart, N.indexCount, this);
    }
    return this.synchronizeInstances(), this;
  }, e.prototype.convertToUnIndexedMesh = function() {
    var t = this.getVerticesDataKinds(), r = {}, n = {}, a = {}, s, o;
    for (s = 0; s < t.length; s++) {
      o = t[s];
      var u = this.getVertexBuffer(o);
      r[o] = u, n[o] = r[o].getData(), a[o] = [];
    }
    var f = this.subMeshes.slice(0), l = this.getIndices(), h = this.getTotalIndices(), c;
    for (c = 0; c < h; c++) {
      var d = l[c];
      for (s = 0; s < t.length; s++) {
        o = t[s];
        for (var p = r[o].getStrideSize(), g = 0; g < p; g++)
          a[o].push(n[o][d * p + g]);
      }
    }
    for (c = 0; c < h; c += 3)
      l[c] = c, l[c + 1] = c + 1, l[c + 2] = c + 2;
    for (this.setIndices(l), s = 0; s < t.length; s++)
      o = t[s], this.setVerticesData(o, a[o], r[o].isUpdatable());
    this.releaseSubMeshes();
    for (var _ = 0; _ < f.length; _++) {
      var v = f[_];
      mt.AddToMesh(v.materialIndex, v.indexStart, v.indexCount, v.indexStart, v.indexCount, this);
    }
    return this._unIndexed = !0, this.synchronizeInstances(), this;
  }, e.prototype.flipFaces = function(t) {
    t === void 0 && (t = !1);
    var r = _e.ExtractFromMesh(this), n;
    if (t && this.isVerticesDataPresent(m.NormalKind) && r.normals)
      for (n = 0; n < r.normals.length; n++)
        r.normals[n] *= -1;
    if (r.indices) {
      var a = void 0;
      for (n = 0; n < r.indices.length; n += 3)
        a = r.indices[n + 1], r.indices[n + 1] = r.indices[n + 2], r.indices[n + 2] = a;
    }
    return r.applyToMesh(this, this.isVertexBufferUpdatable(m.PositionKind)), this;
  }, e.prototype.increaseVertices = function(t) {
    t === void 0 && (t = 1);
    var r = _e.ExtractFromMesh(this), n = r.indices && !Array.isArray(r.indices) && Array.from ? Array.from(r.indices) : r.indices, a = r.positions && !Array.isArray(r.positions) && Array.from ? Array.from(r.positions) : r.positions, s = r.uvs && !Array.isArray(r.uvs) && Array.from ? Array.from(r.uvs) : r.uvs, o = r.normals && !Array.isArray(r.normals) && Array.from ? Array.from(r.normals) : r.normals;
    if (!n || !a)
      k.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions");
    else {
      r.indices = n, r.positions = a, s && (r.uvs = s), o && (r.normals = o);
      for (var u = t + 1, f = new Array(), l = 0; l < u + 1; l++)
        f[l] = new Array();
      var h = void 0, c = void 0, d = new b(0, 0, 0), p = new b(0, 0, 0), g = new Ee(0, 0), _ = new Array(), v = new Array(), y = new Array(), E = void 0, R = a.length, M = void 0;
      s && (M = s.length);
      var C = void 0;
      o && (C = o.length);
      for (var l = 0; l < n.length; l += 3) {
        v[0] = n[l], v[1] = n[l + 1], v[2] = n[l + 2];
        for (var A = 0; A < 3; A++)
          if (h = v[A], c = v[(A + 1) % 3], y[h] === void 0 && y[c] === void 0 ? (y[h] = new Array(), y[c] = new Array()) : (y[h] === void 0 && (y[h] = new Array()), y[c] === void 0 && (y[c] = new Array())), y[h][c] === void 0 && y[c][h] === void 0) {
            y[h][c] = [], d.x = (a[3 * c] - a[3 * h]) / u, d.y = (a[3 * c + 1] - a[3 * h + 1]) / u, d.z = (a[3 * c + 2] - a[3 * h + 2]) / u, o && (p.x = (o[3 * c] - o[3 * h]) / u, p.y = (o[3 * c + 1] - o[3 * h + 1]) / u, p.z = (o[3 * c + 2] - o[3 * h + 2]) / u), s && (g.x = (s[2 * c] - s[2 * h]) / u, g.y = (s[2 * c + 1] - s[2 * h + 1]) / u), y[h][c].push(h);
            for (var S = 1; S < u; S++)
              y[h][c].push(a.length / 3), a[R++] = a[3 * h] + S * d.x, a[R++] = a[3 * h + 1] + S * d.y, a[R++] = a[3 * h + 2] + S * d.z, o && (o[C++] = o[3 * h] + S * p.x, o[C++] = o[3 * h + 1] + S * p.y, o[C++] = o[3 * h + 2] + S * p.z), s && (s[M++] = s[2 * h] + S * g.x, s[M++] = s[2 * h + 1] + S * g.y);
            y[h][c].push(c), y[c][h] = new Array(), E = y[h][c].length;
            for (var w = 0; w < E; w++)
              y[c][h][w] = y[h][c][E - 1 - w];
          }
        f[0][0] = n[l], f[1][0] = y[n[l]][n[l + 1]][1], f[1][1] = y[n[l]][n[l + 2]][1];
        for (var S = 2; S < u; S++) {
          f[S][0] = y[n[l]][n[l + 1]][S], f[S][S] = y[n[l]][n[l + 2]][S], d.x = (a[3 * f[S][S]] - a[3 * f[S][0]]) / S, d.y = (a[3 * f[S][S] + 1] - a[3 * f[S][0] + 1]) / S, d.z = (a[3 * f[S][S] + 2] - a[3 * f[S][0] + 2]) / S, o && (p.x = (o[3 * f[S][S]] - o[3 * f[S][0]]) / S, p.y = (o[3 * f[S][S] + 1] - o[3 * f[S][0] + 1]) / S, p.z = (o[3 * f[S][S] + 2] - o[3 * f[S][0] + 2]) / S), s && (g.x = (s[2 * f[S][S]] - s[2 * f[S][0]]) / S, g.y = (s[2 * f[S][S] + 1] - s[2 * f[S][0] + 1]) / S);
          for (var A = 1; A < S; A++)
            f[S][A] = a.length / 3, a[R++] = a[3 * f[S][0]] + A * d.x, a[R++] = a[3 * f[S][0] + 1] + A * d.y, a[R++] = a[3 * f[S][0] + 2] + A * d.z, o && (o[C++] = o[3 * f[S][0]] + A * p.x, o[C++] = o[3 * f[S][0] + 1] + A * p.y, o[C++] = o[3 * f[S][0] + 2] + A * p.z), s && (s[M++] = s[2 * f[S][0]] + A * g.x, s[M++] = s[2 * f[S][0] + 1] + A * g.y);
        }
        f[u] = y[n[l + 1]][n[l + 2]], _.push(f[0][0], f[1][0], f[1][1]);
        for (var S = 1; S < u; S++) {
          var A = void 0;
          for (A = 0; A < S; A++)
            _.push(f[S][A], f[S + 1][A], f[S + 1][A + 1]), _.push(f[S][A], f[S + 1][A + 1], f[S][A + 1]);
          _.push(f[S][A], f[S + 1][A], f[S + 1][A + 1]);
        }
      }
      r.indices = _, r.applyToMesh(this, this.isVertexBufferUpdatable(m.PositionKind));
    }
  }, e.prototype.forceSharedVertices = function() {
    var t = _e.ExtractFromMesh(this), r = t.uvs, n = t.indices, a = t.positions, s = t.colors;
    if (n === void 0 || a === void 0 || n === null || a === null)
      k.Warn("VertexData contains empty entries");
    else {
      for (var o = new Array(), u = new Array(), f = new Array(), l = new Array(), h = new Array(), c = 0, d = {}, p = void 0, g = void 0, _ = 0; _ < n.length; _ += 3) {
        g = [n[_], n[_ + 1], n[_ + 2]], h = new Array();
        for (var v = 0; v < 3; v++) {
          h[v] = "";
          for (var y = 0; y < 3; y++)
            Math.abs(a[3 * g[v] + y]) < 1e-8 && (a[3 * g[v] + y] = 0), h[v] += a[3 * g[v] + y] + "|";
        }
        if (!(h[0] == h[1] || h[0] == h[2] || h[1] == h[2]))
          for (var v = 0; v < 3; v++) {
            if (p = d[h[v]], p === void 0) {
              d[h[v]] = c, p = c++;
              for (var y = 0; y < 3; y++)
                o.push(a[3 * g[v] + y]);
              if (s != null)
                for (var y = 0; y < 4; y++)
                  l.push(s[4 * g[v] + y]);
              if (r != null)
                for (var y = 0; y < 2; y++)
                  f.push(r[2 * g[v] + y]);
            }
            u.push(p);
          }
      }
      var E = new Array();
      _e.ComputeNormals(o, u, E), t.positions = o, t.indices = u, t.normals = E, r != null && (t.uvs = f), s != null && (t.colors = l), t.applyToMesh(this, this.isVertexBufferUpdatable(m.PositionKind));
    }
  }, e._instancedMeshFactory = function(t, r) {
    throw G("InstancedMesh");
  }, e._PhysicsImpostorParser = function(t, r, n) {
    throw G("PhysicsImpostor");
  }, e.prototype.createInstance = function(t) {
    return e._instancedMeshFactory(t, this);
  }, e.prototype.synchronizeInstances = function() {
    for (var t = 0; t < this.instances.length; t++) {
      var r = this.instances[t];
      r._syncSubMeshes();
    }
    return this;
  }, e.prototype.optimizeIndices = function(t) {
    var r = this, n = this.getIndices(), a = this.getVerticesData(m.PositionKind);
    if (!a || !n)
      return this;
    for (var s = new Array(), o = 0; o < a.length; o = o + 3)
      s.push(b.FromArray(a, o));
    var u = new Array();
    return Jn.SyncAsyncForLoop(s.length, 40, function(f) {
      for (var l = s.length - 1 - f, h = s[l], c = 0; c < l; ++c) {
        var d = s[c];
        if (h.equals(d)) {
          u[l] = c;
          break;
        }
      }
    }, function() {
      for (var f = 0; f < n.length; ++f)
        n[f] = u[n[f]] || n[f];
      var l = r.subMeshes.slice(0);
      r.setIndices(n), r.subMeshes = l, t && t(r);
    }), this;
  }, e.prototype.serialize = function(t) {
    t.name = this.name, t.id = this.id, t.uniqueId = this.uniqueId, t.type = this.getClassName(), le && le.HasTags(this) && (t.tags = le.GetTags(this)), t.position = this.position.asArray(), this.rotationQuaternion ? t.rotationQuaternion = this.rotationQuaternion.asArray() : this.rotation && (t.rotation = this.rotation.asArray()), t.scaling = this.scaling.asArray(), this._postMultiplyPivotMatrix ? t.pivotMatrix = this.getPivotMatrix().asArray() : t.localMatrix = this.getPivotMatrix().asArray(), t.isEnabled = this.isEnabled(!1), t.isVisible = this.isVisible, t.infiniteDistance = this.infiniteDistance, t.pickable = this.isPickable, t.receiveShadows = this.receiveShadows, t.billboardMode = this.billboardMode, t.visibility = this.visibility, t.checkCollisions = this.checkCollisions, t.isBlocker = this.isBlocker, t.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation, this.parent && (t.parentId = this.parent.uniqueId), t.isUnIndexed = this.isUnIndexed;
    var r = this._geometry;
    if (r && this.subMeshes) {
      t.geometryUniqueId = r.uniqueId, t.geometryId = r.id, t.subMeshes = [];
      for (var n = 0; n < this.subMeshes.length; n++) {
        var a = this.subMeshes[n];
        t.subMeshes.push({
          materialIndex: a.materialIndex,
          verticesStart: a.verticesStart,
          verticesCount: a.verticesCount,
          indexStart: a.indexStart,
          indexCount: a.indexCount
        });
      }
    }
    if (this.material ? this.material.doNotSerialize || (t.materialUniqueId = this.material.uniqueId, t.materialId = this.material.id) : (this.material = null, t.materialUniqueId = this._scene.defaultMaterial.uniqueId, t.materialId = this._scene.defaultMaterial.id), this.morphTargetManager && (t.morphTargetManagerId = this.morphTargetManager.uniqueId), this.skeleton && (t.skeletonId = this.skeleton.id, t.numBoneInfluencers = this.numBoneInfluencers), this.getScene()._getComponent(Xt.NAME_PHYSICSENGINE)) {
      var s = this.getPhysicsImpostor();
      s && (t.physicsMass = s.getParam("mass"), t.physicsFriction = s.getParam("friction"), t.physicsRestitution = s.getParam("mass"), t.physicsImpostor = s.type);
    }
    this.metadata && (t.metadata = this.metadata), t.instances = [];
    for (var o = 0; o < this.instances.length; o++) {
      var u = this.instances[o];
      if (!u.doNotSerialize) {
        var f = {
          name: u.name,
          id: u.id,
          isEnabled: u.isEnabled(!1),
          isVisible: u.isVisible,
          isPickable: u.isPickable,
          checkCollisions: u.checkCollisions,
          position: u.position.asArray(),
          scaling: u.scaling.asArray()
        };
        if (u.parent && (f.parentId = u.parent.uniqueId), u.rotationQuaternion ? f.rotationQuaternion = u.rotationQuaternion.asArray() : u.rotation && (f.rotation = u.rotation.asArray()), this.getScene()._getComponent(Xt.NAME_PHYSICSENGINE)) {
          var s = u.getPhysicsImpostor();
          s && (f.physicsMass = s.getParam("mass"), f.physicsFriction = s.getParam("friction"), f.physicsRestitution = s.getParam("mass"), f.physicsImpostor = s.type);
        }
        u.metadata && (f.metadata = u.metadata), t.instances.push(f), $.AppendSerializedAnimations(u, f), f.ranges = u.serializeAnimationRanges();
      }
    }
    if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData && (t.thinInstances = {
      instancesCount: this._thinInstanceDataStorage.instancesCount,
      matrixData: Array.from(this._thinInstanceDataStorage.matrixData),
      matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,
      enablePicking: this.thinInstanceEnablePicking
    }, this._userThinInstanceBuffersStorage)) {
      var l = {
        data: {},
        sizes: {},
        strides: {}
      };
      for (var h in this._userThinInstanceBuffersStorage.data)
        l.data[h] = Array.from(this._userThinInstanceBuffersStorage.data[h]), l.sizes[h] = this._userThinInstanceBuffersStorage.sizes[h], l.strides[h] = this._userThinInstanceBuffersStorage.strides[h];
      t.thinInstances.userThinInstance = l;
    }
    $.AppendSerializedAnimations(this, t), t.ranges = this.serializeAnimationRanges(), t.layerMask = this.layerMask, t.alphaIndex = this.alphaIndex, t.hasVertexAlpha = this.hasVertexAlpha, t.overlayAlpha = this.overlayAlpha, t.overlayColor = this.overlayColor.asArray(), t.renderOverlay = this.renderOverlay, t.applyFog = this.applyFog, this.actionManager && (t.actions = this.actionManager.serialize(this.name));
  }, e.prototype._syncGeometryWithMorphTargetManager = function() {
    if (!!this.geometry) {
      this._markSubMeshesAsAttributesDirty();
      var t = this._internalAbstractMeshDataInfo._morphTargetManager;
      if (t && t.vertexCount) {
        if (t.vertexCount !== this.getTotalVertices()) {
          k.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count."), this.morphTargetManager = null;
          return;
        }
        if (t.isUsingTextureForTargets)
          return;
        for (var r = 0; r < t.numInfluencers; r++) {
          var n = t.getActiveTarget(r), a = n.getPositions();
          if (!a) {
            k.Error("Invalid morph target. Target must have positions.");
            return;
          }
          this.geometry.setVerticesData(m.PositionKind + r, a, !1, 3);
          var s = n.getNormals();
          s && this.geometry.setVerticesData(m.NormalKind + r, s, !1, 3);
          var o = n.getTangents();
          o && this.geometry.setVerticesData(m.TangentKind + r, o, !1, 3);
          var u = n.getUVs();
          u && this.geometry.setVerticesData(m.UVKind + "_" + r, u, !1, 2);
        }
      } else
        for (var r = 0; this.geometry.isVerticesDataPresent(m.PositionKind + r); )
          this.geometry.removeVerticesData(m.PositionKind + r), this.geometry.isVerticesDataPresent(m.NormalKind + r) && this.geometry.removeVerticesData(m.NormalKind + r), this.geometry.isVerticesDataPresent(m.TangentKind + r) && this.geometry.removeVerticesData(m.TangentKind + r), this.geometry.isVerticesDataPresent(m.UVKind + r) && this.geometry.removeVerticesData(m.UVKind + "_" + r), r++;
    }
  }, e.Parse = function(t, r, n) {
    var a;
    if (t.type && t.type === "LinesMesh" ? a = e._LinesMeshParser(t, r) : t.type && t.type === "GroundMesh" ? a = e._GroundMeshParser(t, r) : t.type && t.type === "GoldbergMesh" ? a = e._GoldbergMeshParser(t, r) : a = new e(t.name, r), a.id = t.id, le && le.AddTagsTo(a, t.tags), a.position = b.FromArray(t.position), t.metadata !== void 0 && (a.metadata = t.metadata), t.rotationQuaternion ? a.rotationQuaternion = ie.FromArray(t.rotationQuaternion) : t.rotation && (a.rotation = b.FromArray(t.rotation)), a.scaling = b.FromArray(t.scaling), t.localMatrix ? a.setPreTransformMatrix(I.FromArray(t.localMatrix)) : t.pivotMatrix && a.setPivotMatrix(I.FromArray(t.pivotMatrix)), a.setEnabled(t.isEnabled), a.isVisible = t.isVisible, a.infiniteDistance = t.infiniteDistance, a.showBoundingBox = t.showBoundingBox, a.showSubMeshesBoundingBox = t.showSubMeshesBoundingBox, t.applyFog !== void 0 && (a.applyFog = t.applyFog), t.pickable !== void 0 && (a.isPickable = t.pickable), t.alphaIndex !== void 0 && (a.alphaIndex = t.alphaIndex), a.receiveShadows = t.receiveShadows, a.billboardMode = t.billboardMode, t.visibility !== void 0 && (a.visibility = t.visibility), a.checkCollisions = t.checkCollisions, a.overrideMaterialSideOrientation = t.overrideMaterialSideOrientation, t.isBlocker !== void 0 && (a.isBlocker = t.isBlocker), a._shouldGenerateFlatShading = t.useFlatShading, t.freezeWorldMatrix && (a._waitingData.freezeWorldMatrix = t.freezeWorldMatrix), t.parentId !== void 0 && (a._waitingParentId = t.parentId), t.actions !== void 0 && (a._waitingData.actions = t.actions), t.overlayAlpha !== void 0 && (a.overlayAlpha = t.overlayAlpha), t.overlayColor !== void 0 && (a.overlayColor = ye.FromArray(t.overlayColor)), t.renderOverlay !== void 0 && (a.renderOverlay = t.renderOverlay), a.isUnIndexed = !!t.isUnIndexed, a.hasVertexAlpha = t.hasVertexAlpha, t.delayLoadingFile ? (a.delayLoadState = 4, a.delayLoadingFile = n + t.delayLoadingFile, a.buildBoundingInfo(b.FromArray(t.boundingBoxMinimum), b.FromArray(t.boundingBoxMaximum)), t._binaryInfo && (a._binaryInfo = t._binaryInfo), a._delayInfo = [], t.hasUVs && a._delayInfo.push(m.UVKind), t.hasUVs2 && a._delayInfo.push(m.UV2Kind), t.hasUVs3 && a._delayInfo.push(m.UV3Kind), t.hasUVs4 && a._delayInfo.push(m.UV4Kind), t.hasUVs5 && a._delayInfo.push(m.UV5Kind), t.hasUVs6 && a._delayInfo.push(m.UV6Kind), t.hasColors && a._delayInfo.push(m.ColorKind), t.hasMatricesIndices && a._delayInfo.push(m.MatricesIndicesKind), t.hasMatricesWeights && a._delayInfo.push(m.MatricesWeightsKind), a._delayLoadingFunction = gt._ImportGeometry, tt.ForceFullSceneLoadingForIncremental && a._checkDelayState()) : gt._ImportGeometry(t, a), t.materialUniqueId ? a._waitingMaterialId = t.materialUniqueId : t.materialId && (a._waitingMaterialId = t.materialId), t.morphTargetManagerId > -1 && (a.morphTargetManager = r.getMorphTargetManagerById(t.morphTargetManagerId)), t.skeletonId !== void 0 && t.skeletonId !== null && (a.skeleton = r.getLastSkeletonById(t.skeletonId), t.numBoneInfluencers && (a.numBoneInfluencers = t.numBoneInfluencers)), t.animations) {
      for (var s = 0; s < t.animations.length; s++) {
        var o = t.animations[s], u = Ct("BABYLON.Animation");
        u && a.animations.push(u.Parse(o));
      }
      Je.ParseAnimationRanges(a, t, r);
    }
    if (t.autoAnimate && r.beginAnimation(a, t.autoAnimateFrom, t.autoAnimateTo, t.autoAnimateLoop, t.autoAnimateSpeed || 1), t.layerMask && !isNaN(t.layerMask) ? a.layerMask = Math.abs(parseInt(t.layerMask)) : a.layerMask = 268435455, t.physicsImpostor && e._PhysicsImpostorParser(r, a, t), t.lodMeshIds && (a._waitingData.lods = {
      ids: t.lodMeshIds,
      distances: t.lodDistances ? t.lodDistances : null,
      coverages: t.lodCoverages ? t.lodCoverages : null
    }), t.instances)
      for (var f = 0; f < t.instances.length; f++) {
        var l = t.instances[f], h = a.createInstance(l.name);
        if (l.id && (h.id = l.id), le && (l.tags ? le.AddTagsTo(h, l.tags) : le.AddTagsTo(h, t.tags)), h.position = b.FromArray(l.position), l.metadata !== void 0 && (h.metadata = l.metadata), l.parentId !== void 0 && (h._waitingParentId = l.parentId), l.isEnabled !== void 0 && l.isEnabled !== null && h.setEnabled(l.isEnabled), l.isVisible !== void 0 && l.isVisible !== null && (h.isVisible = l.isVisible), l.isPickable !== void 0 && l.isPickable !== null && (h.isPickable = l.isPickable), l.rotationQuaternion ? h.rotationQuaternion = ie.FromArray(l.rotationQuaternion) : l.rotation && (h.rotation = b.FromArray(l.rotation)), h.scaling = b.FromArray(l.scaling), l.checkCollisions != null && l.checkCollisions != null && (h.checkCollisions = l.checkCollisions), l.pickable != null && l.pickable != null && (h.isPickable = l.pickable), l.showBoundingBox != null && l.showBoundingBox != null && (h.showBoundingBox = l.showBoundingBox), l.showSubMeshesBoundingBox != null && l.showSubMeshesBoundingBox != null && (h.showSubMeshesBoundingBox = l.showSubMeshesBoundingBox), l.alphaIndex != null && l.showSubMeshesBoundingBox != null && (h.alphaIndex = l.alphaIndex), l.physicsImpostor && e._PhysicsImpostorParser(r, h, l), l.animations) {
          for (var s = 0; s < l.animations.length; s++) {
            var o = l.animations[s], u = Ct("BABYLON.Animation");
            u && h.animations.push(u.Parse(o));
          }
          Je.ParseAnimationRanges(h, l, r), l.autoAnimate && r.beginAnimation(h, l.autoAnimateFrom, l.autoAnimateTo, l.autoAnimateLoop, l.autoAnimateSpeed || 1);
        }
      }
    if (t.thinInstances) {
      var c = t.thinInstances;
      if (a.thinInstanceEnablePicking = !!c.enablePicking, c.matrixData ? (a.thinInstanceSetBuffer("matrix", new Float32Array(c.matrixData), 16, !1), a._thinInstanceDataStorage.matrixBufferSize = c.matrixBufferSize, a._thinInstanceDataStorage.instancesCount = c.instancesCount) : a._thinInstanceDataStorage.matrixBufferSize = c.matrixBufferSize, t.thinInstances.userThinInstance) {
        var d = t.thinInstances.userThinInstance;
        for (var p in d.data)
          a.thinInstanceSetBuffer(p, new Float32Array(d.data[p]), d.strides[p], !1), a._userThinInstanceBuffersStorage.sizes[p] = d.sizes[p];
      }
    }
    return a;
  }, e.prototype.setPositionsForCPUSkinning = function() {
    var t = this._internalMeshDataInfo;
    if (!t._sourcePositions) {
      var r = this.getVerticesData(m.PositionKind);
      if (!r)
        return t._sourcePositions;
      t._sourcePositions = new Float32Array(r), this.isVertexBufferUpdatable(m.PositionKind) || this.setVerticesData(m.PositionKind, r, !0);
    }
    return t._sourcePositions;
  }, e.prototype.setNormalsForCPUSkinning = function() {
    var t = this._internalMeshDataInfo;
    if (!t._sourceNormals) {
      var r = this.getVerticesData(m.NormalKind);
      if (!r)
        return t._sourceNormals;
      t._sourceNormals = new Float32Array(r), this.isVertexBufferUpdatable(m.NormalKind) || this.setVerticesData(m.NormalKind, r, !0);
    }
    return t._sourceNormals;
  }, e.prototype.applySkeleton = function(t) {
    if (!this.geometry)
      return this;
    if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId())
      return this;
    if (this.geometry._softwareSkinningFrameId = this.getScene().getFrameId(), !this.isVerticesDataPresent(m.PositionKind))
      return this;
    if (!this.isVerticesDataPresent(m.MatricesIndicesKind))
      return this;
    if (!this.isVerticesDataPresent(m.MatricesWeightsKind))
      return this;
    var r = this.isVerticesDataPresent(m.NormalKind), n = this._internalMeshDataInfo;
    if (!n._sourcePositions) {
      var a = this.subMeshes.slice();
      this.setPositionsForCPUSkinning(), this.subMeshes = a;
    }
    r && !n._sourceNormals && this.setNormalsForCPUSkinning();
    var s = this.getVerticesData(m.PositionKind);
    if (!s)
      return this;
    s instanceof Float32Array || (s = new Float32Array(s));
    var o = this.getVerticesData(m.NormalKind);
    if (r) {
      if (!o)
        return this;
      o instanceof Float32Array || (o = new Float32Array(o));
    }
    var u = this.getVerticesData(m.MatricesIndicesKind), f = this.getVerticesData(m.MatricesWeightsKind);
    if (!f || !u)
      return this;
    for (var l = this.numBoneInfluencers > 4, h = l ? this.getVerticesData(m.MatricesIndicesExtraKind) : null, c = l ? this.getVerticesData(m.MatricesWeightsExtraKind) : null, d = t.getTransformMatrices(this), p = b.Zero(), g = new I(), _ = new I(), v = 0, y, E = 0; E < s.length; E += 3, v += 4) {
      var R = void 0;
      for (y = 0; y < 4; y++)
        R = f[v + y], R > 0 && (I.FromFloat32ArrayToRefScaled(d, Math.floor(u[v + y] * 16), R, _), g.addToSelf(_));
      if (l)
        for (y = 0; y < 4; y++)
          R = c[v + y], R > 0 && (I.FromFloat32ArrayToRefScaled(d, Math.floor(h[v + y] * 16), R, _), g.addToSelf(_));
      b.TransformCoordinatesFromFloatsToRef(n._sourcePositions[E], n._sourcePositions[E + 1], n._sourcePositions[E + 2], g, p), p.toArray(s, E), r && (b.TransformNormalFromFloatsToRef(n._sourceNormals[E], n._sourceNormals[E + 1], n._sourceNormals[E + 2], g, p), p.toArray(o, E)), g.reset();
    }
    return this.updateVerticesData(m.PositionKind, s), r && this.updateVerticesData(m.NormalKind, o), this;
  }, e.MinMax = function(t) {
    var r = null, n = null;
    return t.forEach(function(a) {
      var s = a.getBoundingInfo(), o = s.boundingBox;
      !r || !n ? (r = o.minimumWorld, n = o.maximumWorld) : (r.minimizeInPlace(o.minimumWorld), n.maximizeInPlace(o.maximumWorld));
    }), !r || !n ? {
      min: b.Zero(),
      max: b.Zero()
    } : {
      min: r,
      max: n
    };
  }, e.Center = function(t) {
    var r = t instanceof Array ? e.MinMax(t) : t;
    return b.Center(r.min, r.max);
  }, e.MergeMeshes = function(t, r, n, a, s, o) {
    return r === void 0 && (r = !0), vi(e._MergeMeshesCoroutine(t, r, n, a, s, o, !1));
  }, e.MergeMeshesAsync = function(t, r, n, a, s, o) {
    return r === void 0 && (r = !0), va(e._MergeMeshesCoroutine(t, r, n, a, s, o, !0), ga());
  }, e._MergeMeshesCoroutine = function(t, r, n, a, s, o, u) {
    var f, l, h, c, d, p, g, _, v, H, H, H, y, E, R, M, C, A, S, w, F, x, z, W, N, Z, q, ae, Y, H;
    return r === void 0 && (r = !0), Gt(this, function(se) {
      switch (se.label) {
        case 0:
          if (t = t.filter(Boolean), t.length === 0)
            return [2, null];
          if (!n) {
            for (l = 0, f = 0; f < t.length; f++)
              if (l += t[f].getTotalVertices(), l >= 65536)
                return k.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"), [2, null];
          }
          for (o && (s = !1), h = new Array(), c = new Array(), d = new Array(), p = t[0].overrideMaterialSideOrientation, f = 0; f < t.length; f++) {
            if (g = t[f], g.isAnInstance)
              return k.Warn("Cannot merge instance meshes."), [2, null];
            if (p !== g.overrideMaterialSideOrientation)
              return k.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values."), [2, null];
            if (s && d.push(g.getTotalIndices()), o)
              if (g.material)
                if (_ = g.material, _ instanceof si) {
                  for (v = 0; v < _.subMaterials.length; v++)
                    h.indexOf(_.subMaterials[v]) < 0 && h.push(_.subMaterials[v]);
                  for (H = 0; H < g.subMeshes.length; H++)
                    c.push(h.indexOf(_.subMaterials[g.subMeshes[H].materialIndex])), d.push(g.subMeshes[H].indexCount);
                } else
                  for (h.indexOf(_) < 0 && h.push(_), H = 0; H < g.subMeshes.length; H++)
                    c.push(h.indexOf(_)), d.push(g.subMeshes[H].indexCount);
              else
                for (H = 0; H < g.subMeshes.length; H++)
                  c.push(0), d.push(g.subMeshes[H].indexCount);
          }
          return y = t[0], E = function(Se) {
            var Be = Se.computeWorldMatrix(!0), Ge = _e.ExtractFromMesh(Se, !1, !1);
            return [Ge, Be];
          }, R = E(y), M = R[0], C = R[1], u ? [4] : [3, 2];
        case 1:
          se.sent(), se.label = 2;
        case 2:
          A = new Array(t.length - 1), S = 1, se.label = 3;
        case 3:
          return S < t.length ? (A[S - 1] = E(t[S]), u ? [4] : [3, 5]) : [3, 6];
        case 4:
          se.sent(), se.label = 5;
        case 5:
          return S++, [3, 3];
        case 6:
          w = M._mergeCoroutine(C, A, n, u, !r), F = w.next(), se.label = 7;
        case 7:
          return F.done ? [3, 10] : u ? [4] : [3, 9];
        case 8:
          se.sent(), se.label = 9;
        case 9:
          return F = w.next(), [3, 7];
        case 10:
          x = F.value, a || (a = new e(y.name + "_merged", y.getScene())), z = x._applyToCoroutine(a, void 0, u), W = z.next(), se.label = 11;
        case 11:
          return W.done ? [3, 14] : u ? [4] : [3, 13];
        case 12:
          se.sent(), se.label = 13;
        case 13:
          return W = z.next(), [3, 11];
        case 14:
          if (a.checkCollisions = y.checkCollisions, a.overrideMaterialSideOrientation = y.overrideMaterialSideOrientation, r)
            for (f = 0; f < t.length; f++)
              t[f].dispose();
          if (s || o) {
            for (a.releaseSubMeshes(), f = 0, N = 0; f < d.length; )
              mt.CreateFromIndices(0, N, d[f], a, void 0, !1), N += d[f], f++;
            for (Z = 0, q = a.subMeshes; Z < q.length; Z++)
              ae = q[Z], ae.refreshBoundingInfo();
            a.computeWorldMatrix(!0);
          }
          if (o) {
            for (Y = new si(y.name + "_merged", y.getScene()), Y.subMaterials = h, H = 0; H < a.subMeshes.length; H++)
              a.subMeshes[H].materialIndex = c[H];
            a.material = Y;
          } else
            a.material = y.material;
          return [2, a];
      }
    });
  }, e.prototype.addInstance = function(t) {
    t._indexInSourceMeshInstanceArray = this.instances.length, this.instances.push(t);
  }, e.prototype.removeInstance = function(t) {
    var r = t._indexInSourceMeshInstanceArray;
    if (r != -1) {
      if (r !== this.instances.length - 1) {
        var n = this.instances[this.instances.length - 1];
        this.instances[r] = n, n._indexInSourceMeshInstanceArray = r;
      }
      t._indexInSourceMeshInstanceArray = -1, this.instances.pop();
    }
  }, e.prototype._shouldConvertRHS = function() {
    return this.overrideMaterialSideOrientation === Ie.CounterClockWiseSideOrientation;
  }, e.FRONTSIDE = _e.FRONTSIDE, e.BACKSIDE = _e.BACKSIDE, e.DOUBLESIDE = _e.DOUBLESIDE, e.DEFAULTSIDE = _e.DEFAULTSIDE, e.NO_CAP = 0, e.CAP_START = 1, e.CAP_END = 2, e.CAP_ALL = 3, e.NO_FLIP = 0, e.FLIP_TILE = 1, e.ROTATE_TILE = 2, e.FLIP_ROW = 3, e.ROTATE_ROW = 4, e.FLIP_N_ROTATE_TILE = 5, e.FLIP_N_ROTATE_ROW = 6, e.CENTER = 0, e.LEFT = 1, e.RIGHT = 2, e.TOP = 3, e.BOTTOM = 4, e.INSTANCEDMESH_SORT_TRANSPARENT = !1, e._GroundMeshParser = function(t, r) {
    throw G("GroundMesh");
  }, e._GoldbergMeshParser = function(t, r) {
    throw G("GoldbergMesh");
  }, e._LinesMeshParser = function(t, r) {
    throw G("LinesMesh");
  }, e;
}(mi);
Ne("BABYLON.Mesh", Q);
Q.prototype.setMaterialByID = function(i) {
  return this.setMaterialById(i);
};
Q.CreateDisc = Q.CreateDisc || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreateBox = Q.CreateBox || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreateSphere = Q.CreateSphere || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreateCylinder = Q.CreateCylinder || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreateTorusKnot = Q.CreateTorusKnot || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreateTorus = Q.CreateTorus || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreatePlane = Q.CreatePlane || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreateGround = Q.CreateGround || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreateTiledGround = Q.CreateTiledGround || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreateGroundFromHeightMap = Q.CreateGroundFromHeightMap || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreateTube = Q.CreateTube || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreatePolyhedron = Q.CreatePolyhedron || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreateIcoSphere = Q.CreateIcoSphere || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreateDecal = Q.CreateDecal || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.CreateCapsule = Q.CreateCapsule || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Q.ExtendToGoldberg = Q.ExtendToGoldberg || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
var pt = function() {
  function i(e) {
    e === void 0 && (e = 0), this.priority = e;
  }
  return i.prototype.getDescription = function() {
    return "";
  }, i.prototype.apply = function(e, t) {
    return !0;
  }, i;
}(), jr = function(i) {
  K(e, i);
  function e(t, r, n) {
    t === void 0 && (t = 0), r === void 0 && (r = 1024), n === void 0 && (n = 0.5);
    var a = i.call(this, t) || this;
    return a.priority = t, a.maximumSize = r, a.step = n, a;
  }
  return e.prototype.getDescription = function() {
    return "Reducing render target texture size to " + this.maximumSize;
  }, e.prototype.apply = function(t, r) {
    for (var n = !0, a = 0; a < t.textures.length; a++) {
      var s = t.textures[a];
      if (!(!s.canRescale || s.getContext)) {
        var o = s.getSize(), u = Math.max(o.width, o.height);
        u > this.maximumSize && (s.scale(this.step), n = !1);
      }
    }
    return n;
  }, e;
}(pt), Xi = function(i) {
  K(e, i);
  function e(t, r, n) {
    t === void 0 && (t = 0), r === void 0 && (r = 2), n === void 0 && (n = 0.25);
    var a = i.call(this, t) || this;
    return a.priority = t, a.maximumScale = r, a.step = n, a._currentScale = -1, a._directionOffset = 1, a;
  }
  return e.prototype.getDescription = function() {
    return "Setting hardware scaling level to " + this._currentScale;
  }, e.prototype.apply = function(t, r) {
    return this._currentScale === -1 && (this._currentScale = t.getEngine().getHardwareScalingLevel(), this._currentScale > this.maximumScale && (this._directionOffset = -1)), this._currentScale += this._directionOffset * this.step, t.getEngine().setHardwareScalingLevel(this._currentScale), this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;
  }, e;
}(pt), Kr = function(i) {
  K(e, i);
  function e() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return e.prototype.getDescription = function() {
    return "Turning shadows on/off";
  }, e.prototype.apply = function(t, r) {
    return t.shadowsEnabled = r.isInImprovementMode, !0;
  }, e;
}(pt), Yr = function(i) {
  K(e, i);
  function e() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return e.prototype.getDescription = function() {
    return "Turning post-processes on/off";
  }, e.prototype.apply = function(t, r) {
    return t.postProcessesEnabled = r.isInImprovementMode, !0;
  }, e;
}(pt), Zr = function(i) {
  K(e, i);
  function e() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return e.prototype.getDescription = function() {
    return "Turning lens flares on/off";
  }, e.prototype.apply = function(t, r) {
    return t.lensFlaresEnabled = r.isInImprovementMode, !0;
  }, e;
}(pt), Ia = function(i) {
  K(e, i);
  function e() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return e.prototype.getDescription = function() {
    return this.onGetDescription ? this.onGetDescription() : "Running user defined callback";
  }, e.prototype.apply = function(t, r) {
    return this.onApply ? this.onApply(t, r) : !0;
  }, e;
}(pt), qr = function(i) {
  K(e, i);
  function e() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return e.prototype.getDescription = function() {
    return "Turning particles on/off";
  }, e.prototype.apply = function(t, r) {
    return t.particlesEnabled = r.isInImprovementMode, !0;
  }, e;
}(pt), Hi = function(i) {
  K(e, i);
  function e() {
    return i !== null && i.apply(this, arguments) || this;
  }
  return e.prototype.getDescription = function() {
    return "Turning render targets off";
  }, e.prototype.apply = function(t, r) {
    return t.renderTargetsEnabled = r.isInImprovementMode, !0;
  }, e;
}(pt), Qr = function(i) {
  K(e, i);
  function e() {
    var t = i !== null && i.apply(this, arguments) || this;
    return t._canBeMerged = function(r) {
      if (!(r instanceof Q))
        return !1;
      var n = r;
      return !(n.isDisposed() || !n.isVisible || !n.isEnabled() || n.instances.length > 0 || n.skeleton || n.hasLODLevels);
    }, t;
  }
  return Object.defineProperty(e, "UpdateSelectionTree", {
    get: function() {
      return e._UpdateSelectionTree;
    },
    set: function(t) {
      e._UpdateSelectionTree = t;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getDescription = function() {
    return "Merging similar meshes together";
  }, e.prototype.apply = function(t, r, n) {
    for (var a = t.meshes.slice(0), s = a.length, o = 0; o < s; o++) {
      var u = new Array(), f = a[o];
      if (!!this._canBeMerged(f)) {
        u.push(f);
        for (var l = o + 1; l < s; l++) {
          var h = a[l];
          !this._canBeMerged(h) || h.material === f.material && h.checkCollisions === f.checkCollisions && (u.push(h), s--, a.splice(l, 1), l--);
        }
        u.length < 2 || Q.MergeMeshes(u, void 0, !0);
      }
    }
    var c = t;
    return c.createOrUpdateSelectionOctree && (n != null ? n && c.createOrUpdateSelectionOctree() : e.UpdateSelectionTree && c.createOrUpdateSelectionOctree()), !0;
  }, e._UpdateSelectionTree = !1, e;
}(pt), oi = function() {
  function i(e, t) {
    e === void 0 && (e = 60), t === void 0 && (t = 2e3), this.targetFrameRate = e, this.trackerDuration = t, this.optimizations = new Array();
  }
  return i.prototype.addOptimization = function(e) {
    return this.optimizations.push(e), this;
  }, i.prototype.addCustomOptimization = function(e, t, r) {
    r === void 0 && (r = 0);
    var n = new Ia(r);
    return n.onApply = e, n.onGetDescription = t, this.optimizations.push(n), this;
  }, i.LowDegradationAllowed = function(e) {
    var t = new i(e), r = 0;
    return t.addOptimization(new Qr(r)), t.addOptimization(new Kr(r)), t.addOptimization(new Zr(r)), r++, t.addOptimization(new Yr(r)), t.addOptimization(new qr(r)), r++, t.addOptimization(new jr(r, 1024)), t;
  }, i.ModerateDegradationAllowed = function(e) {
    var t = new i(e), r = 0;
    return t.addOptimization(new Qr(r)), t.addOptimization(new Kr(r)), t.addOptimization(new Zr(r)), r++, t.addOptimization(new Yr(r)), t.addOptimization(new qr(r)), r++, t.addOptimization(new jr(r, 512)), r++, t.addOptimization(new Hi(r)), r++, t.addOptimization(new Xi(r, 2)), t;
  }, i.HighDegradationAllowed = function(e) {
    var t = new i(e), r = 0;
    return t.addOptimization(new Qr(r)), t.addOptimization(new Kr(r)), t.addOptimization(new Zr(r)), r++, t.addOptimization(new Yr(r)), t.addOptimization(new qr(r)), r++, t.addOptimization(new jr(r, 256)), r++, t.addOptimization(new Hi(r)), r++, t.addOptimization(new Xi(r, 4)), t;
  }, i;
}(), Oa = function() {
  function i(e, t, r, n) {
    r === void 0 && (r = !0), n === void 0 && (n = !1);
    var a = this;
    if (this._isRunning = !1, this._currentPriorityLevel = 0, this._targetFrameRate = 60, this._trackerDuration = 2e3, this._currentFrameRate = 0, this._improvementMode = !1, this.onSuccessObservable = new O(), this.onNewOptimizationAppliedObservable = new O(), this.onFailureObservable = new O(), t ? this._options = t : this._options = new oi(), this._options.targetFrameRate && (this._targetFrameRate = this._options.targetFrameRate), this._options.trackerDuration && (this._trackerDuration = this._options.trackerDuration), r)
      for (var s = 0, o = 0, u = this._options.optimizations; o < u.length; o++) {
        var f = u[o];
        f.priority = s++;
      }
    this._improvementMode = n, this._scene = e || re.LastCreatedScene, this._sceneDisposeObserver = this._scene.onDisposeObservable.add(function() {
      a._sceneDisposeObserver = null, a.dispose();
    });
  }
  return Object.defineProperty(i.prototype, "isInImprovementMode", {
    get: function() {
      return this._improvementMode;
    },
    set: function(e) {
      this._improvementMode = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "currentPriorityLevel", {
    get: function() {
      return this._currentPriorityLevel;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "currentFrameRate", {
    get: function() {
      return this._currentFrameRate;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "targetFrameRate", {
    get: function() {
      return this._targetFrameRate;
    },
    set: function(e) {
      this._targetFrameRate = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "trackerDuration", {
    get: function() {
      return this._trackerDuration;
    },
    set: function(e) {
      this._trackerDuration = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "optimizations", {
    get: function() {
      return this._options.optimizations;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.stop = function() {
    this._isRunning = !1;
  }, i.prototype.reset = function() {
    this._currentPriorityLevel = 0;
  }, i.prototype.start = function() {
    var e = this;
    this._isRunning || (this._isRunning = !0, this._scene.executeWhenReady(function() {
      setTimeout(function() {
        e._checkCurrentState();
      }, e._trackerDuration);
    }));
  }, i.prototype._checkCurrentState = function() {
    var e = this;
    if (!!this._isRunning) {
      var t = this._scene, r = this._options;
      if (this._currentFrameRate = Math.round(t.getEngine().getFps()), this._improvementMode && this._currentFrameRate <= this._targetFrameRate || !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {
        this._isRunning = !1, this.onSuccessObservable.notifyObservers(this);
        return;
      }
      for (var n = !0, a = !0, s = 0; s < r.optimizations.length; s++) {
        var o = r.optimizations[s];
        o.priority === this._currentPriorityLevel && (a = !1, n = n && o.apply(t, this), this.onNewOptimizationAppliedObservable.notifyObservers(o));
      }
      if (a) {
        this._isRunning = !1, this.onFailureObservable.notifyObservers(this);
        return;
      }
      n && this._currentPriorityLevel++, t.executeWhenReady(function() {
        setTimeout(function() {
          e._checkCurrentState();
        }, e._trackerDuration);
      });
    }
  }, i.prototype.dispose = function() {
    this.stop(), this.onSuccessObservable.clear(), this.onFailureObservable.clear(), this.onNewOptimizationAppliedObservable.clear(), this._sceneDisposeObserver && this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);
  }, i.OptimizeAsync = function(e, t, r, n) {
    var a = new i(e, t || oi.ModerateDegradationAllowed(), !1);
    return r && a.onSuccessObservable.add(function() {
      r();
    }), n && a.onFailureObservable.add(function() {
      n();
    }), a.start(), a;
  }, i;
}();
function Fa(i) {
  const { engine: e } = i, t = new te(e);
  t.clearColor = new be(0, 0, 0, 0), t.pointerMovePredicate = () => !1, t.pointerDownPredicate = () => !1, t.pointerUpPredicate = () => !1, t.clearCachedVertexData(), t.themeData = {};
  const r = oi.LowDegradationAllowed();
  return r.optimizations = r.optimizations.splice(1), r.targetFrameRate = 60, Oa.OptimizeAsync(t, r), t;
}
var wa = function(i) {
  K(e, i);
  function e(t, r, n, a) {
    a === void 0 && (a = !0);
    var s = i.call(this, t, r, n, a) || this;
    return s._tmpUpVector = b.Zero(), s._tmpTargetVector = b.Zero(), s.cameraDirection = new b(0, 0, 0), s.cameraRotation = new Ee(0, 0), s.ignoreParentScaling = !1, s.updateUpVectorFromRotation = !1, s._tmpQuaternion = new ie(), s.rotation = new b(0, 0, 0), s.speed = 2, s.noRotationConstraint = !1, s.invertRotation = !1, s.inverseRotationSpeed = 0.2, s.lockedTarget = null, s._currentTarget = b.Zero(), s._initialFocalDistance = 1, s._viewMatrix = I.Zero(), s._camMatrix = I.Zero(), s._cameraTransformMatrix = I.Zero(), s._cameraRotationMatrix = I.Zero(), s._referencePoint = new b(0, 0, 1), s._transformedReferencePoint = b.Zero(), s._defaultUp = b.Up(), s._cachedRotationZ = 0, s._cachedQuaternionRotationZ = 0, s;
  }
  return e.prototype.getFrontPosition = function(t) {
    this.getWorldMatrix();
    var r = this.getTarget().subtract(this.position);
    return r.normalize(), r.scaleInPlace(t), this.globalPosition.add(r);
  }, e.prototype._getLockedTargetPosition = function() {
    return this.lockedTarget ? (this.lockedTarget.absolutePosition && this.lockedTarget.computeWorldMatrix(), this.lockedTarget.absolutePosition || this.lockedTarget) : null;
  }, e.prototype.storeState = function() {
    return this._storedPosition = this.position.clone(), this._storedRotation = this.rotation.clone(), this.rotationQuaternion && (this._storedRotationQuaternion = this.rotationQuaternion.clone()), i.prototype.storeState.call(this);
  }, e.prototype._restoreStateValues = function() {
    return i.prototype._restoreStateValues.call(this) ? (this.position = this._storedPosition.clone(), this.rotation = this._storedRotation.clone(), this.rotationQuaternion && (this.rotationQuaternion = this._storedRotationQuaternion.clone()), this.cameraDirection.copyFromFloats(0, 0, 0), this.cameraRotation.copyFromFloats(0, 0), !0) : !1;
  }, e.prototype._initCache = function() {
    i.prototype._initCache.call(this), this._cache.lockedTarget = new b(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.rotation = new b(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.rotationQuaternion = new ie(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  }, e.prototype._updateCache = function(t) {
    t || i.prototype._updateCache.call(this);
    var r = this._getLockedTargetPosition();
    r ? this._cache.lockedTarget ? this._cache.lockedTarget.copyFrom(r) : this._cache.lockedTarget = r.clone() : this._cache.lockedTarget = null, this._cache.rotation.copyFrom(this.rotation), this.rotationQuaternion && this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);
  }, e.prototype._isSynchronizedViewMatrix = function() {
    if (!i.prototype._isSynchronizedViewMatrix.call(this))
      return !1;
    var t = this._getLockedTargetPosition();
    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(t) : !t) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));
  }, e.prototype._computeLocalCameraSpeed = function() {
    var t = this.getEngine();
    return this.speed * Math.sqrt(t.getDeltaTime() / (t.getFps() * 100));
  }, e.prototype.setTarget = function(t) {
    this.upVector.normalize(), this._initialFocalDistance = t.subtract(this.position).length(), this.position.z === t.z && (this.position.z += ce), this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance), I.LookAtLHToRef(this.position, t, this._defaultUp, this._camMatrix), this._camMatrix.invert(), this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);
    var r = t.subtract(this.position);
    r.x >= 0 ? this.rotation.y = -Math.atan(r.z / r.x) + Math.PI / 2 : this.rotation.y = -Math.atan(r.z / r.x) - Math.PI / 2, this.rotation.z = 0, isNaN(this.rotation.x) && (this.rotation.x = 0), isNaN(this.rotation.y) && (this.rotation.y = 0), isNaN(this.rotation.z) && (this.rotation.z = 0), this.rotationQuaternion && ie.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);
  }, Object.defineProperty(e.prototype, "target", {
    get: function() {
      return this.getTarget();
    },
    set: function(t) {
      this.setTarget(t);
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getTarget = function() {
    return this._currentTarget;
  }, e.prototype._decideIfNeedsToMove = function() {
    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
  }, e.prototype._updatePosition = function() {
    if (this.parent) {
      this.parent.getWorldMatrix().invertToRef(D.Matrix[0]), b.TransformNormalToRef(this.cameraDirection, D.Matrix[0], D.Vector3[0]), this.position.addInPlace(D.Vector3[0]);
      return;
    }
    this.position.addInPlace(this.cameraDirection);
  }, e.prototype._checkInputs = function() {
    var t = this.invertRotation ? -this.inverseRotationSpeed : 1, r = this._decideIfNeedsToMove(), n = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;
    if (r && this._updatePosition(), n) {
      if (this.rotationQuaternion && this.rotationQuaternion.toEulerAnglesToRef(this.rotation), this.rotation.x += this.cameraRotation.x * t, this.rotation.y += this.cameraRotation.y * t, !this.noRotationConstraint) {
        var a = 1.570796;
        this.rotation.x > a && (this.rotation.x = a), this.rotation.x < -a && (this.rotation.x = -a);
      }
      if (this.rotationQuaternion) {
        var s = this.rotation.lengthSquared();
        s && ie.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);
      }
    }
    r && (Math.abs(this.cameraDirection.x) < this.speed * ce && (this.cameraDirection.x = 0), Math.abs(this.cameraDirection.y) < this.speed * ce && (this.cameraDirection.y = 0), Math.abs(this.cameraDirection.z) < this.speed * ce && (this.cameraDirection.z = 0), this.cameraDirection.scaleInPlace(this.inertia)), n && (Math.abs(this.cameraRotation.x) < this.speed * ce && (this.cameraRotation.x = 0), Math.abs(this.cameraRotation.y) < this.speed * ce && (this.cameraRotation.y = 0), this.cameraRotation.scaleInPlace(this.inertia)), i.prototype._checkInputs.call(this);
  }, e.prototype._updateCameraRotationMatrix = function() {
    this.rotationQuaternion ? this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix) : I.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
  }, e.prototype._rotateUpVectorWithCameraRotationMatrix = function() {
    return b.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector), this;
  }, e.prototype._getViewMatrix = function() {
    return this.lockedTarget && this.setTarget(this._getLockedTargetPosition()), this._updateCameraRotationMatrix(), this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z ? (this._rotateUpVectorWithCameraRotationMatrix(), this._cachedQuaternionRotationZ = this.rotationQuaternion.z) : this._cachedRotationZ !== this.rotation.z && (this._rotateUpVectorWithCameraRotationMatrix(), this._cachedRotationZ = this.rotation.z), b.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint), this.position.addToRef(this._transformedReferencePoint, this._currentTarget), this.updateUpVectorFromRotation && (this.rotationQuaternion ? Cr.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector) : (ie.FromEulerVectorToRef(this.rotation, this._tmpQuaternion), Cr.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector))), this._computeViewMatrix(this.position, this._currentTarget, this.upVector), this._viewMatrix;
  }, e.prototype._computeViewMatrix = function(t, r, n) {
    if (this.ignoreParentScaling) {
      if (this.parent) {
        var a = this.parent.getWorldMatrix();
        b.TransformCoordinatesToRef(t, a, this._globalPosition), b.TransformCoordinatesToRef(r, a, this._tmpTargetVector), b.TransformNormalToRef(n, a, this._tmpUpVector), this._markSyncedWithParent();
      } else
        this._globalPosition.copyFrom(t), this._tmpTargetVector.copyFrom(r), this._tmpUpVector.copyFrom(n);
      this.getScene().useRightHandedSystem ? I.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix) : I.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
      return;
    }
    if (this.getScene().useRightHandedSystem ? I.LookAtRHToRef(t, r, n, this._viewMatrix) : I.LookAtLHToRef(t, r, n, this._viewMatrix), this.parent) {
      var a = this.parent.getWorldMatrix();
      this._viewMatrix.invert(), this._viewMatrix.multiplyToRef(a, this._viewMatrix), this._viewMatrix.getTranslationToRef(this._globalPosition), this._viewMatrix.invert(), this._markSyncedWithParent();
    } else
      this._globalPosition.copyFrom(t);
  }, e.prototype.createRigCamera = function(t, r) {
    if (this.cameraRigMode !== De.RIG_MODE_NONE) {
      var n = new e(t, this.position.clone(), this.getScene());
      return n.isRigCamera = !0, n.rigParent = this, (this.cameraRigMode === De.RIG_MODE_VR || this.cameraRigMode === De.RIG_MODE_WEBVR) && (this.rotationQuaternion || (this.rotationQuaternion = new ie()), n._cameraRigParams = {}, n.rotationQuaternion = new ie()), n;
    }
    return null;
  }, e.prototype._updateRigCameras = function() {
    var t = this._rigCameras[0], r = this._rigCameras[1];
    switch (this.computeWorldMatrix(), this.cameraRigMode) {
      case De.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case De.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case De.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
      case De.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case De.RIG_MODE_STEREOSCOPIC_INTERLACED: {
        var n = this.cameraRigMode === De.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1, a = this.cameraRigMode === De.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * n, t), this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * a, r);
        break;
      }
      case De.RIG_MODE_VR:
        t.rotationQuaternion ? (t.rotationQuaternion.copyFrom(this.rotationQuaternion), r.rotationQuaternion.copyFrom(this.rotationQuaternion)) : (t.rotation.copyFrom(this.rotation), r.rotation.copyFrom(this.rotation)), t.position.copyFrom(this.position), r.position.copyFrom(this.position);
        break;
    }
    i.prototype._updateRigCameras.call(this);
  }, e.prototype._getRigCamPositionAndTarget = function(t, r) {
    var n = this.getTarget();
    n.subtractToRef(this.position, e._TargetFocalPoint), e._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);
    var a = e._TargetFocalPoint.addInPlace(this.position);
    I.TranslationToRef(-a.x, -a.y, -a.z, e._TargetTransformMatrix), e._TargetTransformMatrix.multiplyToRef(I.RotationAxis(r.upVector, t), e._RigCamTransformMatrix), I.TranslationToRef(a.x, a.y, a.z, e._TargetTransformMatrix), e._RigCamTransformMatrix.multiplyToRef(e._TargetTransformMatrix, e._RigCamTransformMatrix), b.TransformCoordinatesToRef(this.position, e._RigCamTransformMatrix, r.position), r.setTarget(a);
  }, e.prototype.getClassName = function() {
    return "TargetCamera";
  }, e._RigCamTransformMatrix = new I(), e._TargetTransformMatrix = new I(), e._TargetFocalPoint = new b(), T([
    dt()
  ], e.prototype, "rotation", void 0), T([
    P()
  ], e.prototype, "speed", void 0), T([
    na("lockedTargetId")
  ], e.prototype, "lockedTarget", void 0), e;
}(De);
function La(i) {
  const { scene: e } = i;
  let t;
  const r = 36.5;
  return t = new wa("TargetCamera1", new b(0, r, 0), e), t.fov = 0.25, t.minZ = 5, t.maxZ = r + 1, t.setTarget(b.Zero()), t;
}
var Na = function(i) {
  K(e, i);
  function e() {
    var t = i !== null && i.apply(this, arguments) || this;
    return t._needProjectionMatrixCompute = !0, t;
  }
  return e.prototype._setPosition = function(t) {
    this._position = t;
  }, Object.defineProperty(e.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(t) {
      this._setPosition(t);
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._setDirection = function(t) {
    this._direction = t;
  }, Object.defineProperty(e.prototype, "direction", {
    get: function() {
      return this._direction;
    },
    set: function(t) {
      this._setDirection(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "shadowMinZ", {
    get: function() {
      return this._shadowMinZ;
    },
    set: function(t) {
      this._shadowMinZ = t, this.forceProjectionMatrixCompute();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "shadowMaxZ", {
    get: function() {
      return this._shadowMaxZ;
    },
    set: function(t) {
      this._shadowMaxZ = t, this.forceProjectionMatrixCompute();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.computeTransformedInformation = function() {
    return this.parent && this.parent.getWorldMatrix ? (this.transformedPosition || (this.transformedPosition = b.Zero()), b.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition), this.direction && (this.transformedDirection || (this.transformedDirection = b.Zero()), b.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection)), !0) : !1;
  }, e.prototype.getDepthScale = function() {
    return 50;
  }, e.prototype.getShadowDirection = function(t) {
    return this.transformedDirection ? this.transformedDirection : this.direction;
  }, e.prototype.getAbsolutePosition = function() {
    return this.transformedPosition ? this.transformedPosition : this.position;
  }, e.prototype.setDirectionToTarget = function(t) {
    return this.direction = b.Normalize(t.subtract(this.position)), this.direction;
  }, e.prototype.getRotation = function() {
    this.direction.normalize();
    var t = b.Cross(this.direction, Cr.Y), r = b.Cross(t, this.direction);
    return b.RotationFromAxis(t, r, this.direction);
  }, e.prototype.needCube = function() {
    return !1;
  }, e.prototype.needProjectionMatrixCompute = function() {
    return this._needProjectionMatrixCompute;
  }, e.prototype.forceProjectionMatrixCompute = function() {
    this._needProjectionMatrixCompute = !0;
  }, e.prototype._initCache = function() {
    i.prototype._initCache.call(this), this._cache.position = b.Zero();
  }, e.prototype._isSynchronized = function() {
    return !!this._cache.position.equals(this.position);
  }, e.prototype.computeWorldMatrix = function(t) {
    return !t && this.isSynchronized() ? (this._currentRenderId = this.getScene().getRenderId(), this._worldMatrix) : (this._updateCache(), this._cache.position.copyFrom(this.position), this._worldMatrix || (this._worldMatrix = I.Identity()), I.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix), this.parent && this.parent.getWorldMatrix && (this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix), this._markSyncedWithParent()), this._worldMatrixDeterminantIsDirty = !0, this._worldMatrix);
  }, e.prototype.getDepthMinZ = function(t) {
    return this.shadowMinZ !== void 0 ? this.shadowMinZ : t.minZ;
  }, e.prototype.getDepthMaxZ = function(t) {
    return this.shadowMaxZ !== void 0 ? this.shadowMaxZ : t.maxZ;
  }, e.prototype.setShadowProjectionMatrix = function(t, r, n) {
    return this.customProjectionMatrixBuilder ? this.customProjectionMatrixBuilder(r, n, t) : this._setDefaultShadowProjectionMatrix(t, r, n), this;
  }, e.prototype._syncParentEnabledState = function() {
    i.prototype._syncParentEnabledState.call(this), (!this.parent || !this.parent.getWorldMatrix) && (this.transformedPosition = null, this.transformedDirection = null);
  }, T([
    dt()
  ], e.prototype, "position", null), T([
    dt()
  ], e.prototype, "direction", null), T([
    P()
  ], e.prototype, "shadowMinZ", null), T([
    P()
  ], e.prototype, "shadowMaxZ", null), e;
}($e);
Je.AddNodeConstructor("Light_Type_1", function(i, e) {
  return function() {
    return new pn(i, b.Zero(), e);
  };
});
var pn = function(i) {
  K(e, i);
  function e(t, r, n) {
    var a = i.call(this, t, n) || this;
    return a._shadowFrustumSize = 0, a._shadowOrthoScale = 0.1, a.autoUpdateExtends = !0, a.autoCalcShadowZBounds = !1, a._orthoLeft = Number.MAX_VALUE, a._orthoRight = Number.MIN_VALUE, a._orthoTop = Number.MIN_VALUE, a._orthoBottom = Number.MAX_VALUE, a.position = r.scale(-1), a.direction = r, a;
  }
  return Object.defineProperty(e.prototype, "shadowFrustumSize", {
    get: function() {
      return this._shadowFrustumSize;
    },
    set: function(t) {
      this._shadowFrustumSize = t, this.forceProjectionMatrixCompute();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "shadowOrthoScale", {
    get: function() {
      return this._shadowOrthoScale;
    },
    set: function(t) {
      this._shadowOrthoScale = t, this.forceProjectionMatrixCompute();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "orthoLeft", {
    get: function() {
      return this._orthoLeft;
    },
    set: function(t) {
      this._orthoLeft = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "orthoRight", {
    get: function() {
      return this._orthoRight;
    },
    set: function(t) {
      this._orthoRight = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "orthoTop", {
    get: function() {
      return this._orthoTop;
    },
    set: function(t) {
      this._orthoTop = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "orthoBottom", {
    get: function() {
      return this._orthoBottom;
    },
    set: function(t) {
      this._orthoBottom = t;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getClassName = function() {
    return "DirectionalLight";
  }, e.prototype.getTypeID = function() {
    return $e.LIGHTTYPEID_DIRECTIONALLIGHT;
  }, e.prototype._setDefaultShadowProjectionMatrix = function(t, r, n) {
    this.shadowFrustumSize > 0 ? this._setDefaultFixedFrustumShadowProjectionMatrix(t) : this._setDefaultAutoExtendShadowProjectionMatrix(t, r, n);
  }, e.prototype._setDefaultFixedFrustumShadowProjectionMatrix = function(t) {
    var r = this.getScene().activeCamera;
    !r || I.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== void 0 ? this.shadowMinZ : r.minZ, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : r.maxZ, t, this.getScene().getEngine().isNDCHalfZRange);
  }, e.prototype._setDefaultAutoExtendShadowProjectionMatrix = function(t, r, n) {
    var a = this.getScene().activeCamera;
    if (!!a) {
      if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
        var s = b.Zero();
        this._orthoLeft = Number.MAX_VALUE, this._orthoRight = Number.MIN_VALUE, this._orthoTop = Number.MIN_VALUE, this._orthoBottom = Number.MAX_VALUE;
        for (var o = Number.MAX_VALUE, u = Number.MIN_VALUE, f = 0; f < n.length; f++) {
          var l = n[f];
          if (!!l)
            for (var h = l.getBoundingInfo(), c = h.boundingBox, d = 0; d < c.vectorsWorld.length; d++)
              b.TransformCoordinatesToRef(c.vectorsWorld[d], r, s), s.x < this._orthoLeft && (this._orthoLeft = s.x), s.y < this._orthoBottom && (this._orthoBottom = s.y), s.x > this._orthoRight && (this._orthoRight = s.x), s.y > this._orthoTop && (this._orthoTop = s.y), this.autoCalcShadowZBounds && (s.z < o && (o = s.z), s.z > u && (u = s.z));
        }
        this.autoCalcShadowZBounds && (this._shadowMinZ = o, this._shadowMaxZ = u);
      }
      var p = this._orthoRight - this._orthoLeft, g = this._orthoTop - this._orthoBottom, _ = this.shadowMinZ !== void 0 ? this.shadowMinZ : a.minZ, v = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : a.maxZ, y = this.getScene().getEngine().useReverseDepthBuffer;
      I.OrthoOffCenterLHToRef(this._orthoLeft - p * this.shadowOrthoScale, this._orthoRight + p * this.shadowOrthoScale, this._orthoBottom - g * this.shadowOrthoScale, this._orthoTop + g * this.shadowOrthoScale, y ? v : _, y ? _ : v, t, this.getScene().getEngine().isNDCHalfZRange);
    }
  }, e.prototype._buildUniformLayout = function() {
    this._uniformBuffer.addUniform("vLightData", 4), this._uniformBuffer.addUniform("vLightDiffuse", 4), this._uniformBuffer.addUniform("vLightSpecular", 4), this._uniformBuffer.addUniform("shadowsInfo", 3), this._uniformBuffer.addUniform("depthValues", 2), this._uniformBuffer.create();
  }, e.prototype.transferToEffect = function(t, r) {
    return this.computeTransformedInformation() ? (this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, r), this) : (this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, r), this);
  }, e.prototype.transferToNodeMaterialEffect = function(t, r) {
    return this.computeTransformedInformation() ? (t.setFloat3(r, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z), this) : (t.setFloat3(r, this.direction.x, this.direction.y, this.direction.z), this);
  }, e.prototype.getDepthMinZ = function(t) {
    var r = this._scene.getEngine();
    return !r.useReverseDepthBuffer && r.isNDCHalfZRange ? 0 : 1;
  }, e.prototype.getDepthMaxZ = function(t) {
    var r = this._scene.getEngine();
    return r.useReverseDepthBuffer && r.isNDCHalfZRange ? 0 : 1;
  }, e.prototype.prepareLightSpecificDefines = function(t, r) {
    t["DIRLIGHT" + r] = !0;
  }, T([
    P()
  ], e.prototype, "shadowFrustumSize", null), T([
    P()
  ], e.prototype, "shadowOrthoScale", null), T([
    P()
  ], e.prototype, "autoUpdateExtends", void 0), T([
    P()
  ], e.prototype, "autoCalcShadowZBounds", void 0), T([
    P("orthoLeft")
  ], e.prototype, "_orthoLeft", void 0), T([
    P("orthoRight")
  ], e.prototype, "_orthoRight", void 0), T([
    P("orthoTop")
  ], e.prototype, "_orthoTop", void 0), T([
    P("orthoBottom")
  ], e.prototype, "_orthoBottom", void 0), e;
}(Na);
Je.AddNodeConstructor("Light_Type_3", function(i, e) {
  return function() {
    return new _n(i, b.Zero(), e);
  };
});
var _n = function(i) {
  K(e, i);
  function e(t, r, n) {
    var a = i.call(this, t, n) || this;
    return a.groundColor = new ye(0, 0, 0), a.direction = r || b.Up(), a;
  }
  return e.prototype._buildUniformLayout = function() {
    this._uniformBuffer.addUniform("vLightData", 4), this._uniformBuffer.addUniform("vLightDiffuse", 4), this._uniformBuffer.addUniform("vLightSpecular", 4), this._uniformBuffer.addUniform("vLightGround", 3), this._uniformBuffer.addUniform("shadowsInfo", 3), this._uniformBuffer.addUniform("depthValues", 2), this._uniformBuffer.create();
  }, e.prototype.getClassName = function() {
    return "HemisphericLight";
  }, e.prototype.setDirectionToTarget = function(t) {
    return this.direction = b.Normalize(t.subtract(b.Zero())), this.direction;
  }, e.prototype.getShadowGenerator = function() {
    return null;
  }, e.prototype.transferToEffect = function(t, r) {
    var n = b.Normalize(this.direction);
    return this._uniformBuffer.updateFloat4("vLightData", n.x, n.y, n.z, 0, r), this._uniformBuffer.updateColor3("vLightGround", this.groundColor.scale(this.intensity), r), this;
  }, e.prototype.transferToNodeMaterialEffect = function(t, r) {
    var n = b.Normalize(this.direction);
    return t.setFloat3(r, n.x, n.y, n.z), this;
  }, e.prototype.computeWorldMatrix = function() {
    return this._worldMatrix || (this._worldMatrix = I.Identity()), this._worldMatrix;
  }, e.prototype.getTypeID = function() {
    return $e.LIGHTTYPEID_HEMISPHERICLIGHT;
  }, e.prototype.prepareLightSpecificDefines = function(t, r) {
    t["HEMILIGHT" + r] = !0;
  }, T([
    At()
  ], e.prototype, "groundColor", void 0), T([
    dt()
  ], e.prototype, "direction", void 0), e;
}($e), ji = function() {
  function i(e, t) {
    this.width = e, this.height = t;
  }
  return i.prototype.toString = function() {
    return "{W: ".concat(this.width, ", H: ").concat(this.height, "}");
  }, i.prototype.getClassName = function() {
    return "Size";
  }, i.prototype.getHashCode = function() {
    var e = this.width | 0;
    return e = e * 397 ^ (this.height | 0), e;
  }, i.prototype.copyFrom = function(e) {
    this.width = e.width, this.height = e.height;
  }, i.prototype.copyFromFloats = function(e, t) {
    return this.width = e, this.height = t, this;
  }, i.prototype.set = function(e, t) {
    return this.copyFromFloats(e, t);
  }, i.prototype.multiplyByFloats = function(e, t) {
    return new i(this.width * e, this.height * t);
  }, i.prototype.clone = function() {
    return new i(this.width, this.height);
  }, i.prototype.equals = function(e) {
    return e ? this.width === e.width && this.height === e.height : !1;
  }, Object.defineProperty(i.prototype, "surface", {
    get: function() {
      return this.width * this.height;
    },
    enumerable: !1,
    configurable: !0
  }), i.Zero = function() {
    return new i(0, 0);
  }, i.prototype.add = function(e) {
    var t = new i(this.width + e.width, this.height + e.height);
    return t;
  }, i.prototype.subtract = function(e) {
    var t = new i(this.width - e.width, this.height - e.height);
    return t;
  }, i.Lerp = function(e, t, r) {
    var n = e.width + (t.width - e.width) * r, a = e.height + (t.height - e.height) * r;
    return new i(n, a);
  }, i;
}(), Ba = function() {
  function i(e) {
    this._wrapU = 1, this._wrapV = 1, this.wrapR = 1, this.anisotropicFilteringLevel = 4, this.delayLoadState = 0, this._texture = null, this._engine = null, this._cachedSize = ji.Zero(), this._cachedBaseSize = ji.Zero(), this._initialSamplingMode = 2, this._texture = e, this._texture && (this._engine = this._texture.getEngine());
  }
  return Object.defineProperty(i.prototype, "wrapU", {
    get: function() {
      return this._wrapU;
    },
    set: function(e) {
      this._wrapU = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "wrapV", {
    get: function() {
      return this._wrapV;
    },
    set: function(e) {
      this._wrapV = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "coordinatesMode", {
    get: function() {
      return 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "isCube", {
    get: function() {
      return this._texture ? this._texture.isCube : !1;
    },
    set: function(e) {
      !this._texture || (this._texture.isCube = e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "is3D", {
    get: function() {
      return this._texture ? this._texture.is3D : !1;
    },
    set: function(e) {
      !this._texture || (this._texture.is3D = e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "is2DArray", {
    get: function() {
      return this._texture ? this._texture.is2DArray : !1;
    },
    set: function(e) {
      !this._texture || (this._texture.is2DArray = e);
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getClassName = function() {
    return "ThinTexture";
  }, i.prototype.isReady = function() {
    return this.delayLoadState === 4 ? (this.delayLoad(), !1) : this._texture ? this._texture.isReady : !1;
  }, i.prototype.delayLoad = function() {
  }, i.prototype.getInternalTexture = function() {
    return this._texture;
  }, i.prototype.getSize = function() {
    if (this._texture) {
      if (this._texture.width)
        return this._cachedSize.width = this._texture.width, this._cachedSize.height = this._texture.height, this._cachedSize;
      if (this._texture._size)
        return this._cachedSize.width = this._texture._size, this._cachedSize.height = this._texture._size, this._cachedSize;
    }
    return this._cachedSize;
  }, i.prototype.getBaseSize = function() {
    return !this.isReady() || !this._texture ? (this._cachedBaseSize.width = 0, this._cachedBaseSize.height = 0, this._cachedBaseSize) : this._texture._size ? (this._cachedBaseSize.width = this._texture._size, this._cachedBaseSize.height = this._texture._size, this._cachedBaseSize) : (this._cachedBaseSize.width = this._texture.baseWidth, this._cachedBaseSize.height = this._texture.baseHeight, this._cachedBaseSize);
  }, Object.defineProperty(i.prototype, "samplingMode", {
    get: function() {
      return this._texture ? this._texture.samplingMode : this._initialSamplingMode;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.updateSamplingMode = function(e) {
    this._texture && this._engine && this._engine.updateTextureSamplingMode(e, this._texture);
  }, i.prototype.releaseInternalTexture = function() {
    this._texture && (this._texture.dispose(), this._texture = null);
  }, i.prototype.dispose = function() {
    this._texture && (this.releaseInternalTexture(), this._engine = null);
  }, i;
}(), Ua = function(i) {
  K(e, i);
  function e(t) {
    var r = i.call(this, null) || this;
    return r.metadata = null, r.reservedDataStore = null, r._hasAlpha = !1, r._getAlphaFromRGB = !1, r.level = 1, r._coordinatesIndex = 0, r._coordinatesMode = 0, r.wrapR = 1, r.anisotropicFilteringLevel = e.DEFAULT_ANISOTROPIC_FILTERING_LEVEL, r._isCube = !1, r._gammaSpace = !0, r.invertZ = !1, r.lodLevelInAlpha = !1, r.isRenderTarget = !1, r._prefiltered = !1, r._forceSerialize = !1, r.animations = new Array(), r.onDisposeObservable = new O(), r._onDisposeObserver = null, r._scene = null, r._uid = null, r._parentContainer = null, r._loadingError = !1, t ? e._IsScene(t) ? r._scene = t : r._engine = t : r._scene = re.LastCreatedScene, r._scene && (r.uniqueId = r._scene.getUniqueId(), r._scene.addTexture(r), r._engine = r._scene.getEngine()), r._uid = null, r;
  }
  return Object.defineProperty(e.prototype, "hasAlpha", {
    get: function() {
      return this._hasAlpha;
    },
    set: function(t) {
      var r = this;
      this._hasAlpha !== t && (this._hasAlpha = t, this._scene && this._scene.markAllMaterialsAsDirty(1, function(n) {
        return n.hasTexture(r);
      }));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "getAlphaFromRGB", {
    get: function() {
      return this._getAlphaFromRGB;
    },
    set: function(t) {
      var r = this;
      this._getAlphaFromRGB !== t && (this._getAlphaFromRGB = t, this._scene && this._scene.markAllMaterialsAsDirty(1, function(n) {
        return n.hasTexture(r);
      }));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "coordinatesIndex", {
    get: function() {
      return this._coordinatesIndex;
    },
    set: function(t) {
      var r = this;
      this._coordinatesIndex !== t && (this._coordinatesIndex = t, this._scene && this._scene.markAllMaterialsAsDirty(1, function(n) {
        return n.hasTexture(r);
      }));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "coordinatesMode", {
    get: function() {
      return this._coordinatesMode;
    },
    set: function(t) {
      var r = this;
      this._coordinatesMode !== t && (this._coordinatesMode = t, this._scene && this._scene.markAllMaterialsAsDirty(1, function(n) {
        return n.hasTexture(r);
      }));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "wrapU", {
    get: function() {
      return this._wrapU;
    },
    set: function(t) {
      this._wrapU = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "wrapV", {
    get: function() {
      return this._wrapV;
    },
    set: function(t) {
      this._wrapV = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "isCube", {
    get: function() {
      return this._texture ? this._texture.isCube : this._isCube;
    },
    set: function(t) {
      this._texture ? this._texture.isCube = t : this._isCube = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "is3D", {
    get: function() {
      return this._texture ? this._texture.is3D : !1;
    },
    set: function(t) {
      !this._texture || (this._texture.is3D = t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "is2DArray", {
    get: function() {
      return this._texture ? this._texture.is2DArray : !1;
    },
    set: function(t) {
      !this._texture || (this._texture.is2DArray = t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "gammaSpace", {
    get: function() {
      if (this._texture)
        this._texture._gammaSpace === null && (this._texture._gammaSpace = this._gammaSpace);
      else
        return this._gammaSpace;
      return this._texture._gammaSpace && !this._texture._useSRGBBuffer;
    },
    set: function(t) {
      if (this._texture) {
        if (this._texture._gammaSpace === t)
          return;
        this._texture._gammaSpace = t;
      } else {
        if (this._gammaSpace === t)
          return;
        this._gammaSpace = t;
      }
      this._markAllSubMeshesAsTexturesDirty();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "isRGBD", {
    get: function() {
      return this._texture != null && this._texture._isRGBD;
    },
    set: function(t) {
      this._texture && (this._texture._isRGBD = t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "noMipmap", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "lodGenerationOffset", {
    get: function() {
      return this._texture ? this._texture._lodGenerationOffset : 0;
    },
    set: function(t) {
      this._texture && (this._texture._lodGenerationOffset = t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "lodGenerationScale", {
    get: function() {
      return this._texture ? this._texture._lodGenerationScale : 0;
    },
    set: function(t) {
      this._texture && (this._texture._lodGenerationScale = t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "linearSpecularLOD", {
    get: function() {
      return this._texture ? this._texture._linearSpecularLOD : !1;
    },
    set: function(t) {
      this._texture && (this._texture._linearSpecularLOD = t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "irradianceTexture", {
    get: function() {
      return this._texture ? this._texture._irradianceTexture : null;
    },
    set: function(t) {
      this._texture && (this._texture._irradianceTexture = t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "uid", {
    get: function() {
      return this._uid || (this._uid = on()), this._uid;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.toString = function() {
    return this.name;
  }, e.prototype.getClassName = function() {
    return "BaseTexture";
  }, Object.defineProperty(e.prototype, "onDispose", {
    set: function(t) {
      this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "isBlocking", {
    get: function() {
      return !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "loadingError", {
    get: function() {
      return this._loadingError;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "errorObject", {
    get: function() {
      return this._errorObject;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getScene = function() {
    return this._scene;
  }, e.prototype._getEngine = function() {
    return this._engine;
  }, e.prototype.checkTransformsAreIdentical = function(t) {
    return t !== null;
  }, e.prototype.getTextureMatrix = function() {
    return I.IdentityReadOnly;
  }, e.prototype.getReflectionTextureMatrix = function() {
    return I.IdentityReadOnly;
  }, e.prototype.isReadyOrNotBlocking = function() {
    return !this.isBlocking || this.isReady() || this.loadingError;
  }, e.prototype.scale = function(t) {
  }, Object.defineProperty(e.prototype, "canRescale", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._getFromCache = function(t, r, n, a, s) {
    var o = this._getEngine();
    if (!o)
      return null;
    for (var u = o._getUseSRGBBuffer(!!s, r), f = o.getLoadedTexturesCache(), l = 0; l < f.length; l++) {
      var h = f[l];
      if ((s === void 0 || u === h._useSRGBBuffer) && (a === void 0 || a === h.invertY) && h.url === t && h.generateMipMaps === !r && (!n || n === h.samplingMode))
        return h.incrementReferences(), h;
    }
    return null;
  }, e.prototype._rebuild = function() {
  }, e.prototype.clone = function() {
    return null;
  }, Object.defineProperty(e.prototype, "textureType", {
    get: function() {
      return this._texture && this._texture.type !== void 0 ? this._texture.type : 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "textureFormat", {
    get: function() {
      return this._texture && this._texture.format !== void 0 ? this._texture.format : 5;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._markAllSubMeshesAsTexturesDirty = function() {
    var t = this.getScene();
    !t || t.markAllMaterialsAsDirty(1);
  }, e.prototype.readPixels = function(t, r, n, a, s, o, u, f, l) {
    if (t === void 0 && (t = 0), r === void 0 && (r = 0), n === void 0 && (n = null), a === void 0 && (a = !0), s === void 0 && (s = !1), o === void 0 && (o = 0), u === void 0 && (u = 0), f === void 0 && (f = Number.MAX_VALUE), l === void 0 && (l = Number.MAX_VALUE), !this._texture)
      return null;
    var h = this._getEngine();
    if (!h)
      return null;
    var c = this.getSize(), d = c.width, p = c.height;
    r !== 0 && (d = d / Math.pow(2, r), p = p / Math.pow(2, r), d = Math.round(d), p = Math.round(p)), f = Math.min(d, f), l = Math.min(p, l);
    try {
      return this._texture.isCube ? h._readTexturePixels(this._texture, f, l, t, r, n, a, s, o, u) : h._readTexturePixels(this._texture, f, l, -1, r, n, a, s, o, u);
    } catch {
      return null;
    }
  }, e.prototype._readPixelsSync = function(t, r, n, a, s) {
    if (t === void 0 && (t = 0), r === void 0 && (r = 0), n === void 0 && (n = null), a === void 0 && (a = !0), s === void 0 && (s = !1), !this._texture)
      return null;
    var o = this.getSize(), u = o.width, f = o.height, l = this._getEngine();
    if (!l)
      return null;
    r != 0 && (u = u / Math.pow(2, r), f = f / Math.pow(2, r), u = Math.round(u), f = Math.round(f));
    try {
      return this._texture.isCube ? l._readTexturePixelsSync(this._texture, u, f, t, r, n, a, s) : l._readTexturePixelsSync(this._texture, u, f, -1, r, n, a, s);
    } catch {
      return null;
    }
  }, Object.defineProperty(e.prototype, "_lodTextureHigh", {
    get: function() {
      return this._texture ? this._texture._lodTextureHigh : null;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "_lodTextureMid", {
    get: function() {
      return this._texture ? this._texture._lodTextureMid : null;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "_lodTextureLow", {
    get: function() {
      return this._texture ? this._texture._lodTextureLow : null;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.dispose = function() {
    if (this._scene) {
      this._scene.stopAnimation && this._scene.stopAnimation(this), this._scene._removePendingData(this);
      var t = this._scene.textures.indexOf(this);
      if (t >= 0 && this._scene.textures.splice(t, 1), this._scene.onTextureRemovedObservable.notifyObservers(this), this._scene = null, this._parentContainer) {
        var r = this._parentContainer.textures.indexOf(this);
        r > -1 && this._parentContainer.textures.splice(r, 1), this._parentContainer = null;
      }
    }
    this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.metadata = null, i.prototype.dispose.call(this);
  }, e.prototype.serialize = function() {
    if (!this.name)
      return null;
    var t = $.Serialize(this);
    return $.AppendSerializedAnimations(this, t), t;
  }, e.WhenAllReady = function(t, r) {
    var n = t.length;
    if (n === 0) {
      r();
      return;
    }
    for (var a = 0; a < t.length; a++) {
      var s = t[a];
      if (s.isReady())
        --n === 0 && r();
      else {
        var o = s.onLoadObservable;
        o ? o.addOnce(function() {
          --n === 0 && r();
        }) : --n === 0 && r();
      }
    }
  }, e._IsScene = function(t) {
    return t.getClassName() === "Scene";
  }, e.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4, T([
    P()
  ], e.prototype, "uniqueId", void 0), T([
    P()
  ], e.prototype, "name", void 0), T([
    P()
  ], e.prototype, "metadata", void 0), T([
    P("hasAlpha")
  ], e.prototype, "_hasAlpha", void 0), T([
    P("getAlphaFromRGB")
  ], e.prototype, "_getAlphaFromRGB", void 0), T([
    P()
  ], e.prototype, "level", void 0), T([
    P("coordinatesIndex")
  ], e.prototype, "_coordinatesIndex", void 0), T([
    P("coordinatesMode")
  ], e.prototype, "_coordinatesMode", void 0), T([
    P()
  ], e.prototype, "wrapU", null), T([
    P()
  ], e.prototype, "wrapV", null), T([
    P()
  ], e.prototype, "wrapR", void 0), T([
    P()
  ], e.prototype, "anisotropicFilteringLevel", void 0), T([
    P()
  ], e.prototype, "isCube", null), T([
    P()
  ], e.prototype, "is3D", null), T([
    P()
  ], e.prototype, "is2DArray", null), T([
    P()
  ], e.prototype, "gammaSpace", null), T([
    P()
  ], e.prototype, "invertZ", void 0), T([
    P()
  ], e.prototype, "lodLevelInAlpha", void 0), T([
    P()
  ], e.prototype, "lodGenerationOffset", null), T([
    P()
  ], e.prototype, "lodGenerationScale", null), T([
    P()
  ], e.prototype, "linearSpecularLOD", null), T([
    je()
  ], e.prototype, "irradianceTexture", null), T([
    P()
  ], e.prototype, "isRenderTarget", void 0), e;
}(Ba);
function gn(i, e, t) {
  t === void 0 && (t = !1);
  var r = e.width, n = e.height;
  if (i instanceof Float32Array) {
    for (var a = i.byteLength / i.BYTES_PER_ELEMENT, s = new Uint8Array(a); --a >= 0; ) {
      var o = i[a];
      o < 0 ? o = 0 : o > 1 && (o = 1), s[a] = o * 255;
    }
    i = s;
  }
  var u = document.createElement("canvas");
  u.width = r, u.height = n;
  var f = u.getContext("2d");
  if (!f)
    return null;
  var l = f.createImageData(r, n), h = l.data;
  if (h.set(i), f.putImageData(l, 0, 0), t) {
    var c = document.createElement("canvas");
    c.width = r, c.height = n;
    var d = c.getContext("2d");
    return d ? (d.translate(0, n), d.scale(1, -1), d.drawImage(u, 0, 0), c.toDataURL("image/png")) : null;
  }
  return u.toDataURL("image/png");
}
function Va(i, e, t) {
  e === void 0 && (e = 0), t === void 0 && (t = 0);
  var r = i.getInternalTexture();
  if (!r)
    return null;
  var n = i._readPixelsSync(e, t);
  return n ? gn(n, i.getSize(), r.invertY) : null;
}
function ka(i, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), fi(this, void 0, void 0, function() {
    var r, n;
    return Gt(this, function(a) {
      switch (a.label) {
        case 0:
          return r = i.getInternalTexture(), r ? [4, i.readPixels(e, t)] : [2, null];
        case 1:
          return n = a.sent(), n ? [2, gn(n, i.getSize(), r.invertY)] : [2, null];
      }
    });
  });
}
var ee = function(i) {
  K(e, i);
  function e(t, r, n, a, s, o, u, f, l, h, c, d, p, g) {
    s === void 0 && (s = e.TRILINEAR_SAMPLINGMODE), o === void 0 && (o = null), u === void 0 && (u = null), f === void 0 && (f = null), l === void 0 && (l = !1);
    var _ = this, v, y, E, R, M, C, A, S, w;
    _ = i.call(this, r) || this, _.url = null, _.uOffset = 0, _.vOffset = 0, _.uScale = 1, _.vScale = 1, _.uAng = 0, _.vAng = 0, _.wAng = 0, _.uRotationCenter = 0.5, _.vRotationCenter = 0.5, _.wRotationCenter = 0.5, _.homogeneousRotationInUVTransform = !1, _.inspectableCustomProperties = null, _._noMipmap = !1, _._invertY = !1, _._rowGenerationMatrix = null, _._cachedTextureMatrix = null, _._projectionModeMatrix = null, _._t0 = null, _._t1 = null, _._t2 = null, _._cachedUOffset = -1, _._cachedVOffset = -1, _._cachedUScale = 0, _._cachedVScale = 0, _._cachedUAng = -1, _._cachedVAng = -1, _._cachedWAng = -1, _._cachedProjectionMatrixId = -1, _._cachedURotationCenter = -1, _._cachedVRotationCenter = -1, _._cachedWRotationCenter = -1, _._cachedHomogeneousRotationInUVTransform = !1, _._cachedCoordinatesMode = -1, _._buffer = null, _._deleteBuffer = !1, _._format = null, _._delayedOnLoad = null, _._delayedOnError = null, _.onLoadObservable = new O(), _._isBlocking = !0, _.name = t || "", _.url = t;
    var F, x = !1, z = null;
    typeof n == "object" && n !== null ? (F = (v = n.noMipmap) !== null && v !== void 0 ? v : !1, a = (y = n.invertY) !== null && y !== void 0 ? y : !Ye.UseOpenGLOrientationForUV, s = (E = n.samplingMode) !== null && E !== void 0 ? E : e.TRILINEAR_SAMPLINGMODE, o = (R = n.onLoad) !== null && R !== void 0 ? R : null, u = (M = n.onError) !== null && M !== void 0 ? M : null, f = (C = n.buffer) !== null && C !== void 0 ? C : null, l = (A = n.deleteBuffer) !== null && A !== void 0 ? A : !1, h = n.format, c = n.mimeType, d = n.loaderOptions, p = n.creationFlags, x = (S = n.useSRGBBuffer) !== null && S !== void 0 ? S : !1, z = (w = n.internalTexture) !== null && w !== void 0 ? w : null) : F = !!n, _._noMipmap = F, _._invertY = a === void 0 ? !Ye.UseOpenGLOrientationForUV : a, _._initialSamplingMode = s, _._buffer = f, _._deleteBuffer = l, _._mimeType = c, _._loaderOptions = d, _._creationFlags = p, _._useSRGBBuffer = x, _._forcedExtension = g, h && (_._format = h);
    var W = _.getScene(), N = _._getEngine();
    if (!N)
      return _;
    N.onBeforeTextureInitObservable.notifyObservers(_);
    var Z = function() {
      _._texture && (_._texture._invertVScale && (_.vScale *= -1, _.vOffset += 1), _._texture._cachedWrapU !== null && (_.wrapU = _._texture._cachedWrapU, _._texture._cachedWrapU = null), _._texture._cachedWrapV !== null && (_.wrapV = _._texture._cachedWrapV, _._texture._cachedWrapV = null), _._texture._cachedWrapR !== null && (_.wrapR = _._texture._cachedWrapR, _._texture._cachedWrapR = null)), _.onLoadObservable.hasObservers() && _.onLoadObservable.notifyObservers(_), o && o(), !_.isBlocking && W && W.resetCachedMaterial();
    }, q = function(Y, H) {
      _._loadingError = !0, _._errorObject = { message: Y, exception: H }, u && u(Y, H), e.OnTextureLoadErrorObservable.notifyObservers(_);
    };
    if (!_.url)
      return _._delayedOnLoad = Z, _._delayedOnError = q, _;
    if (_._texture = z != null ? z : _._getFromCache(_.url, F, s, _._invertY, x), _._texture)
      if (_._texture.isReady)
        Tr.SetImmediate(function() {
          return Z();
        });
      else {
        var ae = _._texture.onLoadedObservable.add(Z);
        _._texture.onErrorObservable.add(function(Y) {
          var H;
          q(Y.message, Y.exception), (H = _._texture) === null || H === void 0 || H.onLoadedObservable.remove(ae);
        });
      }
    else if (!W || !W.useDelayedTextureLoading) {
      try {
        _._texture = N.createTexture(_.url, F, _._invertY, W, s, Z, q, _._buffer, void 0, _._format, _._forcedExtension, c, d, p, x);
      } catch (Y) {
        throw q("error loading", Y), Y;
      }
      l && (_._buffer = null);
    } else
      _.delayLoadState = 4, _._delayedOnLoad = Z, _._delayedOnError = q;
    return _;
  }
  return Object.defineProperty(e.prototype, "noMipmap", {
    get: function() {
      return this._noMipmap;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "mimeType", {
    get: function() {
      return this._mimeType;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "isBlocking", {
    get: function() {
      return this._isBlocking;
    },
    set: function(t) {
      this._isBlocking = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "invertY", {
    get: function() {
      return this._invertY;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.updateURL = function(t, r, n, a) {
    r === void 0 && (r = null), this.url && (this.releaseInternalTexture(), this.getScene().markAllMaterialsAsDirty(1)), (!this.name || this.name.startsWith("data:")) && (this.name = t), this.url = t, this._buffer = r, this._forcedExtension = a, this.delayLoadState = 4, n && (this._delayedOnLoad = n), this.delayLoad();
  }, e.prototype.delayLoad = function() {
    if (this.delayLoadState === 4) {
      var t = this.getScene();
      !t || (this.delayLoadState = 1, this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer), this._texture ? this._delayedOnLoad && (this._texture.isReady ? Tr.SetImmediate(this._delayedOnLoad) : this._texture.onLoadedObservable.add(this._delayedOnLoad)) : (this._texture = t.getEngine().createTexture(this.url, this._noMipmap, this._invertY, t, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, this._forcedExtension, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer), this._deleteBuffer && (this._buffer = null)), this._delayedOnLoad = null, this._delayedOnError = null);
    }
  }, e.prototype._prepareRowForTextureGeneration = function(t, r, n, a) {
    t *= this._cachedUScale, r *= this._cachedVScale, t -= this.uRotationCenter * this._cachedUScale, r -= this.vRotationCenter * this._cachedVScale, n -= this.wRotationCenter, b.TransformCoordinatesFromFloatsToRef(t, r, n, this._rowGenerationMatrix, a), a.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset, a.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset, a.z += this.wRotationCenter;
  }, e.prototype.checkTransformsAreIdentical = function(t) {
    return t !== null && this.uOffset === t.uOffset && this.vOffset === t.vOffset && this.uScale === t.uScale && this.vScale === t.vScale && this.uAng === t.uAng && this.vAng === t.vAng && this.wAng === t.wAng;
  }, e.prototype.getTextureMatrix = function(t) {
    var r = this;
    if (t === void 0 && (t = 1), this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * t === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform)
      return this._cachedTextureMatrix;
    this._cachedUOffset = this.uOffset, this._cachedVOffset = this.vOffset, this._cachedUScale = this.uScale * t, this._cachedVScale = this.vScale, this._cachedUAng = this.uAng, this._cachedVAng = this.vAng, this._cachedWAng = this.wAng, this._cachedURotationCenter = this.uRotationCenter, this._cachedVRotationCenter = this.vRotationCenter, this._cachedWRotationCenter = this.wRotationCenter, this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform, (!this._cachedTextureMatrix || !this._rowGenerationMatrix) && (this._cachedTextureMatrix = I.Zero(), this._rowGenerationMatrix = new I(), this._t0 = b.Zero(), this._t1 = b.Zero(), this._t2 = b.Zero()), I.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix), this.homogeneousRotationInUVTransform ? (I.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, D.Matrix[0]), I.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, D.Matrix[1]), I.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, D.Matrix[2]), I.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, D.Matrix[3]), D.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(D.Matrix[1], this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(D.Matrix[2], this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(D.Matrix[3], this._cachedTextureMatrix), this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1)) : (this._prepareRowForTextureGeneration(0, 0, 0, this._t0), this._prepareRowForTextureGeneration(1, 0, 0, this._t1), this._prepareRowForTextureGeneration(0, 1, 0, this._t2), this._t1.subtractInPlace(this._t0), this._t2.subtractInPlace(this._t0), I.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0, this._t2.x, this._t2.y, this._t2.z, 0, this._t0.x, this._t0.y, this._t0.z, 0, 0, 0, 0, 1, this._cachedTextureMatrix));
    var n = this.getScene();
    return n ? (n.markAllMaterialsAsDirty(1, function(a) {
      return a.hasTexture(r);
    }), this._cachedTextureMatrix) : this._cachedTextureMatrix;
  }, e.prototype.getReflectionTextureMatrix = function() {
    var t = this, r = this.getScene();
    if (!r)
      return this._cachedTextureMatrix;
    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale === this._cachedUScale && this.vScale === this._cachedVScale && this.coordinatesMode === this._cachedCoordinatesMode)
      if (this.coordinatesMode === e.PROJECTION_MODE) {
        if (this._cachedProjectionMatrixId === r.getProjectionMatrix().updateFlag)
          return this._cachedTextureMatrix;
      } else
        return this._cachedTextureMatrix;
    this._cachedTextureMatrix || (this._cachedTextureMatrix = I.Zero()), this._projectionModeMatrix || (this._projectionModeMatrix = I.Zero());
    var n = this._cachedCoordinatesMode !== this.coordinatesMode;
    switch (this._cachedUOffset = this.uOffset, this._cachedVOffset = this.vOffset, this._cachedUScale = this.uScale, this._cachedVScale = this.vScale, this._cachedCoordinatesMode = this.coordinatesMode, this.coordinatesMode) {
      case e.PLANAR_MODE: {
        I.IdentityToRef(this._cachedTextureMatrix), this._cachedTextureMatrix[0] = this.uScale, this._cachedTextureMatrix[5] = this.vScale, this._cachedTextureMatrix[12] = this.uOffset, this._cachedTextureMatrix[13] = this.vOffset;
        break;
      }
      case e.PROJECTION_MODE: {
        I.FromValuesToRef(0.5, 0, 0, 0, 0, -0.5, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, this._projectionModeMatrix);
        var a = r.getProjectionMatrix();
        this._cachedProjectionMatrixId = a.updateFlag, a.multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);
        break;
      }
      default:
        I.IdentityToRef(this._cachedTextureMatrix);
        break;
    }
    return n && r.markAllMaterialsAsDirty(1, function(s) {
      return s.getActiveTextures().indexOf(t) !== -1;
    }), this._cachedTextureMatrix;
  }, e.prototype.clone = function() {
    var t = this, r = {
      noMipmap: this._noMipmap,
      invertY: this._invertY,
      samplingMode: this.samplingMode,
      onLoad: void 0,
      onError: void 0,
      buffer: this._texture ? this._texture._buffer : void 0,
      deleteBuffer: this._deleteBuffer,
      format: this.textureFormat,
      mimeType: this.mimeType,
      loaderOptions: this._loaderOptions,
      creationFlags: this._creationFlags,
      useSRGBBuffer: this._useSRGBBuffer
    };
    return $.Clone(function() {
      return new e(t._texture ? t._texture.url : null, t.getScene(), r);
    }, this);
  }, e.prototype.serialize = function() {
    var t = this.name;
    e.SerializeBuffers || this.name.startsWith("data:") && (this.name = ""), this.name.startsWith("data:") && this.url === this.name && (this.url = "");
    var r = i.prototype.serialize.call(this);
    return r ? ((e.SerializeBuffers || e.ForceSerializeBuffers) && (typeof this._buffer == "string" && this._buffer.substr(0, 5) === "data:" ? (r.base64String = this._buffer, r.name = r.name.replace("data:", "")) : this.url && this.url.startsWith("data:") && this._buffer instanceof Uint8Array ? r.base64String = "data:image/png;base64," + tn(this._buffer) : (e.ForceSerializeBuffers || this.url && this.url.startsWith("blob:") || this._forceSerialize) && (r.base64String = !this._engine || this._engine._features.supportSyncTextureRead ? Va(this) : ka(this))), r.invertY = this._invertY, r.samplingMode = this.samplingMode, r._creationFlags = this._creationFlags, r._useSRGBBuffer = this._useSRGBBuffer, this.name = t, r) : null;
  }, e.prototype.getClassName = function() {
    return "Texture";
  }, e.prototype.dispose = function() {
    i.prototype.dispose.call(this), this.onLoadObservable.clear(), this._delayedOnLoad = null, this._delayedOnError = null;
  }, e.Parse = function(t, r, n) {
    if (t.customType) {
      var a = vr.Instantiate(t.customType), s = a.Parse(t, r, n);
      return t.samplingMode && s.updateSamplingMode && s._samplingMode && s._samplingMode !== t.samplingMode && s.updateSamplingMode(t.samplingMode), s;
    }
    if (t.isCube && !t.isRenderTarget)
      return e._CubeTextureParser(t, r, n);
    if (!t.name && !t.isRenderTarget)
      return null;
    var o = function() {
      if (u && u._texture && (u._texture._cachedWrapU = null, u._texture._cachedWrapV = null, u._texture._cachedWrapR = null), t.samplingMode) {
        var f = t.samplingMode;
        u && u.samplingMode !== f && u.updateSamplingMode(f);
      }
      if (u && t.animations)
        for (var l = 0; l < t.animations.length; l++) {
          var h = t.animations[l], c = Ct("BABYLON.Animation");
          c && u.animations.push(c.Parse(h));
        }
    }, u = $.Parse(function() {
      var f, l, h, c = !0;
      if (t.noMipmap && (c = !1), t.mirrorPlane) {
        var d = e._CreateMirror(t.name, t.renderTargetSize, r, c);
        return d._waitingRenderList = t.renderList, d.mirrorPlane = gi.FromArray(t.mirrorPlane), o(), d;
      } else if (t.isRenderTarget) {
        var p = null;
        if (t.isCube) {
          if (r.reflectionProbes)
            for (var g = 0; g < r.reflectionProbes.length; g++) {
              var _ = r.reflectionProbes[g];
              if (_.name === t.name)
                return _.cubeTexture;
            }
        } else
          p = e._CreateRenderTargetTexture(t.name, t.renderTargetSize, r, c, (f = t._creationFlags) !== null && f !== void 0 ? f : 0), p._waitingRenderList = t.renderList;
        return o(), p;
      } else {
        var v;
        if (t.base64String)
          v = e.CreateFromBase64String(t.base64String, t.name, r, !c, t.invertY, t.samplingMode, o, (l = t._creationFlags) !== null && l !== void 0 ? l : 0, (h = t._useSRGBBuffer) !== null && h !== void 0 ? h : !1);
        else {
          var y = void 0;
          t.name && t.name.indexOf("://") > 0 ? y = t.name : y = n + t.name, t.url && (t.url.startsWith("data:") || e.UseSerializedUrlIfAny) && (y = t.url), v = new e(y, r, !c, t.invertY, t.samplingMode, o);
        }
        return v;
      }
    }, t, r);
    return u;
  }, e.CreateFromBase64String = function(t, r, n, a, s, o, u, f, l, h) {
    return o === void 0 && (o = e.TRILINEAR_SAMPLINGMODE), u === void 0 && (u = null), f === void 0 && (f = null), l === void 0 && (l = 5), new e("data:" + r, n, a, s, o, u, f, t, !1, l, void 0, void 0, h);
  }, e.LoadFromDataString = function(t, r, n, a, s, o, u, f, l, h, c) {
    return a === void 0 && (a = !1), o === void 0 && (o = !0), u === void 0 && (u = e.TRILINEAR_SAMPLINGMODE), f === void 0 && (f = null), l === void 0 && (l = null), h === void 0 && (h = 5), t.substr(0, 5) !== "data:" && (t = "data:" + t), new e(t, n, s, o, u, f, l, r, a, h, void 0, void 0, c);
  }, e.SerializeBuffers = !0, e.ForceSerializeBuffers = !1, e.OnTextureLoadErrorObservable = new O(), e._CubeTextureParser = function(t, r, n) {
    throw G("CubeTexture");
  }, e._CreateMirror = function(t, r, n, a) {
    throw G("MirrorTexture");
  }, e._CreateRenderTargetTexture = function(t, r, n, a, s) {
    throw G("RenderTargetTexture");
  }, e.NEAREST_SAMPLINGMODE = 1, e.NEAREST_NEAREST_MIPLINEAR = 8, e.BILINEAR_SAMPLINGMODE = 2, e.LINEAR_LINEAR_MIPNEAREST = 11, e.TRILINEAR_SAMPLINGMODE = 3, e.LINEAR_LINEAR_MIPLINEAR = 3, e.NEAREST_NEAREST_MIPNEAREST = 4, e.NEAREST_LINEAR_MIPNEAREST = 5, e.NEAREST_LINEAR_MIPLINEAR = 6, e.NEAREST_LINEAR = 7, e.NEAREST_NEAREST = 1, e.LINEAR_NEAREST_MIPNEAREST = 9, e.LINEAR_NEAREST_MIPLINEAR = 10, e.LINEAR_LINEAR = 2, e.LINEAR_NEAREST = 12, e.EXPLICIT_MODE = 0, e.SPHERICAL_MODE = 1, e.PLANAR_MODE = 2, e.CUBIC_MODE = 3, e.PROJECTION_MODE = 4, e.SKYBOX_MODE = 5, e.INVCUBIC_MODE = 6, e.EQUIRECTANGULAR_MODE = 7, e.FIXED_EQUIRECTANGULAR_MODE = 8, e.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9, e.CLAMP_ADDRESSMODE = 0, e.WRAP_ADDRESSMODE = 1, e.MIRROR_ADDRESSMODE = 2, e.UseSerializedUrlIfAny = !1, T([
    P()
  ], e.prototype, "url", void 0), T([
    P()
  ], e.prototype, "uOffset", void 0), T([
    P()
  ], e.prototype, "vOffset", void 0), T([
    P()
  ], e.prototype, "uScale", void 0), T([
    P()
  ], e.prototype, "vScale", void 0), T([
    P()
  ], e.prototype, "uAng", void 0), T([
    P()
  ], e.prototype, "vAng", void 0), T([
    P()
  ], e.prototype, "wAng", void 0), T([
    P()
  ], e.prototype, "uRotationCenter", void 0), T([
    P()
  ], e.prototype, "vRotationCenter", void 0), T([
    P()
  ], e.prototype, "wRotationCenter", void 0), T([
    P()
  ], e.prototype, "homogeneousRotationInUVTransform", void 0), T([
    P()
  ], e.prototype, "isBlocking", null), e;
}(Ua);
Ne("BABYLON.Texture", ee);
$._TextureParser = ee.Parse;
var Wa = function() {
  function i(e, t, r, n) {
    this._textures = null, this._attachments = null, this._generateStencilBuffer = !1, this._generateDepthBuffer = !1, this._depthStencilTextureWithStencil = !1, this._isMulti = e, this._isCube = t, this._size = r, this._engine = n, this._depthStencilTexture = null;
  }
  return Object.defineProperty(i.prototype, "depthStencilTexture", {
    get: function() {
      return this._depthStencilTexture;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "depthStencilTextureWithStencil", {
    get: function() {
      return this._depthStencilTextureWithStencil;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "isCube", {
    get: function() {
      return this._isCube;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "isMulti", {
    get: function() {
      return this._isMulti;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "is2DArray", {
    get: function() {
      return this.layers > 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "size", {
    get: function() {
      return this.width;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "width", {
    get: function() {
      return this._size.width || this._size;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "height", {
    get: function() {
      return this._size.height || this._size;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "layers", {
    get: function() {
      return this._size.layers || 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "texture", {
    get: function() {
      var e, t;
      return (t = (e = this._textures) === null || e === void 0 ? void 0 : e[0]) !== null && t !== void 0 ? t : null;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "textures", {
    get: function() {
      return this._textures;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "samples", {
    get: function() {
      var e, t;
      return (t = (e = this.texture) === null || e === void 0 ? void 0 : e.samples) !== null && t !== void 0 ? t : 1;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.setSamples = function(e, t, r) {
    return t === void 0 && (t = !0), r === void 0 && (r = !1), this.samples === e && !r ? e : this._isMulti ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, e, t) : this._engine.updateRenderTargetTextureSampleCount(this, e);
  }, i.prototype.setTextures = function(e) {
    Array.isArray(e) ? this._textures = e : e ? this._textures = [e] : this._textures = null;
  }, i.prototype.setTexture = function(e, t, r) {
    t === void 0 && (t = 0), r === void 0 && (r = !0), this._textures || (this._textures = []), this._textures[t] && r && this._textures[t].dispose(), this._textures[t] = e;
  }, i.prototype.createDepthStencilTexture = function(e, t, r, n, a) {
    var s;
    return e === void 0 && (e = 0), t === void 0 && (t = !0), r === void 0 && (r = !1), n === void 0 && (n = 1), a === void 0 && (a = 14), (s = this._depthStencilTexture) === null || s === void 0 || s.dispose(), this._depthStencilTextureWithStencil = r, this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {
      bilinearFiltering: t,
      comparisonFunction: e,
      generateStencil: r,
      isCube: this._isCube,
      samples: n,
      depthTextureFormat: a
    }, this), this._depthStencilTexture;
  }, i.prototype._shareDepth = function(e) {
    this._depthStencilTexture && (e._depthStencilTexture && e._depthStencilTexture.dispose(), e._depthStencilTexture = this._depthStencilTexture, this._depthStencilTexture.incrementReferences());
  }, i.prototype._swapAndDie = function(e) {
    this.texture && this.texture._swapAndDie(e), this._textures = null, this.dispose(!0);
  }, i.prototype._cloneRenderTargetWrapper = function() {
    var e, t, r, n, a, s, o = null;
    if (this._isMulti) {
      var u = this.textures;
      if (u && u.length > 0) {
        var f = !1, l = u.length, h = u[u.length - 1]._source;
        (h === ve.Depth || h === ve.DepthStencil) && (f = !0, l--);
        for (var c = [], d = [], p = 0; p < l; ++p) {
          var g = u[p];
          c.push(g.samplingMode), d.push(g.type);
        }
        var _ = {
          samplingModes: c,
          generateMipMaps: u[0].generateMipMaps,
          generateDepthBuffer: this._generateDepthBuffer,
          generateStencilBuffer: this._generateStencilBuffer,
          generateDepthTexture: f,
          types: d,
          textureCount: l
        }, v = {
          width: this.width,
          height: this.height
        };
        o = this._engine.createMultipleRenderTarget(v, _);
      }
    } else {
      var y = {};
      if (y.generateDepthBuffer = this._generateDepthBuffer, y.generateMipMaps = (t = (e = this.texture) === null || e === void 0 ? void 0 : e.generateMipMaps) !== null && t !== void 0 ? t : !1, y.generateStencilBuffer = this._generateStencilBuffer, y.samplingMode = (r = this.texture) === null || r === void 0 ? void 0 : r.samplingMode, y.type = (n = this.texture) === null || n === void 0 ? void 0 : n.type, y.format = (a = this.texture) === null || a === void 0 ? void 0 : a.format, this.isCube)
        o = this._engine.createRenderTargetCubeTexture(this.width, y);
      else {
        var v = {
          width: this.width,
          height: this.height,
          layers: this.is2DArray ? (s = this.texture) === null || s === void 0 ? void 0 : s.depth : void 0
        };
        o = this._engine.createRenderTargetTexture(v, y);
      }
      o.texture.isReady = !0;
    }
    return o;
  }, i.prototype._swapRenderTargetWrapper = function(e) {
    if (this._textures && e._textures)
      for (var t = 0; t < this._textures.length; ++t)
        this._textures[t]._swapAndDie(e._textures[t], !1), e._textures[t].isReady = !0;
    this._depthStencilTexture && e._depthStencilTexture && (this._depthStencilTexture._swapAndDie(e._depthStencilTexture), e._depthStencilTexture.isReady = !0), this._textures = null, this._depthStencilTexture = null;
  }, i.prototype._rebuild = function() {
    var e = this._cloneRenderTargetWrapper();
    if (!!e) {
      if (this._depthStencilTexture) {
        var t = this._depthStencilTexture.samplingMode, r = t === 2 || t === 3 || t === 11;
        e.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, r, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);
      }
      this.samples > 1 && e.setSamples(this.samples), e._swapRenderTargetWrapper(this), e.dispose();
    }
  }, i.prototype.releaseTextures = function() {
    var e, t;
    if (this._textures)
      for (var r = 0; (t = r < ((e = this._textures) === null || e === void 0 ? void 0 : e.length)) !== null && t !== void 0 && t; ++r)
        this._textures[r].dispose();
    this._textures = null;
  }, i.prototype.dispose = function(e) {
    var t;
    e === void 0 && (e = !1), e || ((t = this._depthStencilTexture) === null || t === void 0 || t.dispose(), this._depthStencilTexture = null, this.releaseTextures()), this._engine._releaseRenderTargetWrapper(this);
  }, i;
}(), za = function(i) {
  K(e, i);
  function e(t, r, n, a, s) {
    var o = i.call(this, t, r, n, a) || this;
    return o._framebuffer = null, o._depthStencilBuffer = null, o._MSAAFramebuffer = null, o._colorTextureArray = null, o._depthStencilTextureArray = null, o._context = s, o;
  }
  return e.prototype._cloneRenderTargetWrapper = function() {
    var t = null;
    return this._colorTextureArray && this._depthStencilTextureArray ? (t = this._engine.createMultiviewRenderTargetTexture(this.width, this.height), t.texture.isReady = !0) : t = i.prototype._cloneRenderTargetWrapper.call(this), t;
  }, e.prototype._swapRenderTargetWrapper = function(t) {
    i.prototype._swapRenderTargetWrapper.call(this, t), t._framebuffer = this._framebuffer, t._depthStencilBuffer = this._depthStencilBuffer, t._MSAAFramebuffer = this._MSAAFramebuffer, t._colorTextureArray = this._colorTextureArray, t._depthStencilTextureArray = this._depthStencilTextureArray, this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null;
  }, e.prototype._shareDepth = function(t) {
    i.prototype._shareDepth.call(this, t);
    var r = this._context, n = this._depthStencilBuffer, a = t._framebuffer;
    t._depthStencilBuffer && r.deleteRenderbuffer(t._depthStencilBuffer), t._depthStencilBuffer = this._depthStencilBuffer, this._engine._bindUnboundFramebuffer(a), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, n), this._engine._bindUnboundFramebuffer(null);
  }, e.prototype._bindTextureRenderTarget = function(t, r, n, a) {
    if (r === void 0 && (r = 0), n === void 0 && (n = -1), a === void 0 && (a = 0), !!t._hardwareTexture) {
      var s = this._context, o = this._framebuffer, u = this._engine._currentFramebuffer;
      this._engine._bindUnboundFramebuffer(o);
      var f = s[this._engine.webGLVersion > 1 ? "COLOR_ATTACHMENT" + r : "COLOR_ATTACHMENT" + r + "_WEBGL"], l = n !== -1 ? s.TEXTURE_CUBE_MAP_POSITIVE_X + n : s.TEXTURE_2D;
      s.framebufferTexture2D(s.FRAMEBUFFER, f, l, t._hardwareTexture.underlyingResource, a), this._engine._bindUnboundFramebuffer(u);
    }
  }, e.prototype.setTexture = function(t, r, n) {
    r === void 0 && (r = 0), n === void 0 && (n = !0), i.prototype.setTexture.call(this, t, r, n), this._bindTextureRenderTarget(t, r);
  }, e.prototype.dispose = function(t) {
    t === void 0 && (t = !1);
    var r = this._context;
    t || (this._colorTextureArray && (this._context.deleteTexture(this._colorTextureArray), this._colorTextureArray = null), this._depthStencilTextureArray && (this._context.deleteTexture(this._depthStencilTextureArray), this._depthStencilTextureArray = null)), this._framebuffer && (r.deleteFramebuffer(this._framebuffer), this._framebuffer = null), this._depthStencilBuffer && (r.deleteRenderbuffer(this._depthStencilBuffer), this._depthStencilBuffer = null), this._MSAAFramebuffer && (r.deleteFramebuffer(this._MSAAFramebuffer), this._MSAAFramebuffer = null), i.prototype.dispose.call(this, t);
  }, e;
}(Wa);
ue.prototype._createHardwareRenderTargetWrapper = function(i, e, t) {
  var r = new za(i, e, t, this, this._gl);
  return this._renderTargetWrapperCache.push(r), r;
};
ue.prototype.createRenderTargetTexture = function(i, e) {
  var t = this._createHardwareRenderTargetWrapper(!1, !1, i), r = {};
  e !== void 0 && typeof e == "object" ? (r.generateDepthBuffer = !!e.generateDepthBuffer, r.generateStencilBuffer = !!e.generateStencilBuffer, r.noColorTarget = !!e.noColorTarget) : (r.generateDepthBuffer = !0, r.generateStencilBuffer = !1, r.noColorTarget = !1);
  var n = r.noColorTarget ? null : this._createInternalTexture(i, e, !0, ve.RenderTarget), a = i.width || i, s = i.height || i, o = this._currentFramebuffer, u = this._gl, f = u.createFramebuffer();
  return this._bindUnboundFramebuffer(f), t._depthStencilBuffer = this._setupFramebufferDepthAttachments(!!r.generateStencilBuffer, r.generateDepthBuffer, a, s), n && !n.is2DArray && u.framebufferTexture2D(u.FRAMEBUFFER, u.COLOR_ATTACHMENT0, u.TEXTURE_2D, n._hardwareTexture.underlyingResource, 0), this._bindUnboundFramebuffer(o), t._framebuffer = f, t._generateDepthBuffer = r.generateDepthBuffer, t._generateStencilBuffer = !!r.generateStencilBuffer, t.setTextures(n), t;
};
ue.prototype.createDepthStencilTexture = function(i, e, t) {
  if (e.isCube) {
    var r = i.width || i;
    return this._createDepthStencilCubeTexture(r, e, t);
  } else
    return this._createDepthStencilTexture(i, e, t);
};
ue.prototype._createDepthStencilTexture = function(i, e, t) {
  var r = this._gl, n = i.layers || 0, a = n !== 0 ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D, s = new Bt(this, ve.DepthStencil);
  if (!this._caps.depthTextureExtension)
    return k.Error("Depth texture is not supported by your browser or hardware."), s;
  var o = Tt({ bilinearFiltering: !1, comparisonFunction: 0, generateStencil: !1 }, e);
  this._bindTextureDirectly(a, s, !0), this._setupDepthStencilTexture(s, i, o.generateStencil, o.comparisonFunction === 0 ? !1 : o.bilinearFiltering, o.comparisonFunction), s.format = o.generateStencil ? 13 : 16, t._depthStencilTexture = s, t._depthStencilTextureWithStencil = o.generateStencil;
  var u = o.generateStencil ? r.UNSIGNED_INT_24_8 : r.UNSIGNED_INT, f = o.generateStencil ? r.DEPTH_STENCIL : r.DEPTH_COMPONENT, l = f;
  return this.webGLVersion > 1 && (l = o.generateStencil ? r.DEPTH24_STENCIL8 : r.DEPTH_COMPONENT24), s.is2DArray ? r.texImage3D(a, 0, l, s.width, s.height, n, 0, f, u, null) : r.texImage2D(a, 0, l, s.width, s.height, 0, f, u, null), this._bindTextureDirectly(a, null), this._internalTexturesCache.push(s), s;
};
ue.prototype.updateRenderTargetTextureSampleCount = function(i, e) {
  if (this.webGLVersion < 2 || !i || !i.texture)
    return 1;
  if (i.samples === e)
    return e;
  var t = this._gl;
  e = Math.min(e, this.getCaps().maxMSAASamples), i._depthStencilBuffer && (t.deleteRenderbuffer(i._depthStencilBuffer), i._depthStencilBuffer = null), i._MSAAFramebuffer && (t.deleteFramebuffer(i._MSAAFramebuffer), i._MSAAFramebuffer = null);
  var r = i.texture._hardwareTexture;
  if (r._MSAARenderBuffer && (t.deleteRenderbuffer(r._MSAARenderBuffer), r._MSAARenderBuffer = null), e > 1 && t.renderbufferStorageMultisample) {
    var n = t.createFramebuffer();
    if (!n)
      throw new Error("Unable to create multi sampled framebuffer");
    i._MSAAFramebuffer = n, this._bindUnboundFramebuffer(i._MSAAFramebuffer);
    var a = this._createRenderBuffer(i.texture.width, i.texture.height, e, -1, this._getRGBAMultiSampleBufferFormat(i.texture.type), t.COLOR_ATTACHMENT0, !1);
    if (!a)
      throw new Error("Unable to create multi sampled framebuffer");
    r._MSAARenderBuffer = a;
  } else
    this._bindUnboundFramebuffer(i._framebuffer);
  return i.texture.samples = e, i._depthStencilBuffer = this._setupFramebufferDepthAttachments(i._generateStencilBuffer, i._generateDepthBuffer, i.texture.width, i.texture.height, e), this._bindUnboundFramebuffer(null), e;
};
ue.prototype.createRenderTargetCubeTexture = function(i, e) {
  var t = this._createHardwareRenderTargetWrapper(!1, !0, i), r = Tt({ generateMipMaps: !0, generateDepthBuffer: !0, generateStencilBuffer: !1, type: 0, samplingMode: 3, format: 5 }, e);
  r.generateStencilBuffer = r.generateDepthBuffer && r.generateStencilBuffer, (r.type === 1 && !this._caps.textureFloatLinearFiltering || r.type === 2 && !this._caps.textureHalfFloatLinearFiltering) && (r.samplingMode = 1);
  var n = this._gl, a = new Bt(this, ve.RenderTarget);
  this._bindTextureDirectly(n.TEXTURE_CUBE_MAP, a, !0);
  var s = this._getSamplingParameters(r.samplingMode, r.generateMipMaps);
  r.type === 1 && !this._caps.textureFloat && (r.type = 0, k.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type")), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MAG_FILTER, s.mag), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MIN_FILTER, s.min), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);
  for (var o = 0; o < 6; o++)
    n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, this._getRGBABufferInternalSizedFormat(r.type, r.format), i, i, 0, this._getInternalFormat(r.format), this._getWebGLTextureType(r.type), null);
  var u = n.createFramebuffer();
  return this._bindUnboundFramebuffer(u), t._depthStencilBuffer = this._setupFramebufferDepthAttachments(r.generateStencilBuffer, r.generateDepthBuffer, i, i), r.generateMipMaps && n.generateMipmap(n.TEXTURE_CUBE_MAP), this._bindTextureDirectly(n.TEXTURE_CUBE_MAP, null), this._bindUnboundFramebuffer(null), t._framebuffer = u, t._generateDepthBuffer = r.generateDepthBuffer, t._generateStencilBuffer = r.generateStencilBuffer, a.width = i, a.height = i, a.isReady = !0, a.isCube = !0, a.samples = 1, a.generateMipMaps = r.generateMipMaps, a.samplingMode = r.samplingMode, a.type = r.type, a.format = r.format, this._internalTexturesCache.push(a), t.setTextures(a), t;
};
var kt = function(i) {
  K(e, i);
  function e(t, r, n, a, s, o, u, f, l, h, c, d, p, g, _, v, y) {
    s === void 0 && (s = !0), o === void 0 && (o = 0), u === void 0 && (u = !1), f === void 0 && (f = ee.TRILINEAR_SAMPLINGMODE), l === void 0 && (l = !0), h === void 0 && (h = !1), c === void 0 && (c = !1), d === void 0 && (d = 5), p === void 0 && (p = !1), v === void 0 && (v = !1), y === void 0 && (y = !1);
    var E = this, R;
    if (E = i.call(this, null, n, !a, void 0, f, void 0, void 0, void 0, void 0, d) || this, E.renderParticles = !0, E.renderSprites = !1, E.ignoreCameraViewport = !1, E.onBeforeBindObservable = new O(), E.onAfterUnbindObservable = new O(), E.onBeforeRenderObservable = new O(), E.onAfterRenderObservable = new O(), E.onClearObservable = new O(), E.onResizeObservable = new O(), E._cleared = !1, E.skipInitialClear = !1, E._currentRefreshId = -1, E._refreshRate = 1, E._samples = 1, E._canRescale = !0, E._renderTarget = null, E.boundingBoxPosition = b.Zero(), n = E.getScene(), !n)
      return E;
    var M = E.getScene().getEngine();
    return E._coordinatesMode = ee.PROJECTION_MODE, E.renderList = new Array(), E.name = t, E.isRenderTarget = !0, E._initialSizeParameter = r, E._renderPassIds = [], E._isCubeData = u, E._processSizeParameter(r), E.renderPassId = E._renderPassIds[0], E._resizeObserver = M.onResizeObservable.add(function() {
    }), E._generateMipMaps = !!a, E._doNotChangeAspectRatio = s, E._renderingManager = new Ar(n), E._renderingManager._useSceneAutoClearSetup = !0, c || (E._renderTargetOptions = {
      generateMipMaps: a,
      type: o,
      format: (R = E._format) !== null && R !== void 0 ? R : void 0,
      samplingMode: E.samplingMode,
      generateDepthBuffer: l,
      generateStencilBuffer: h,
      samples: g,
      creationFlags: _,
      noColorTarget: v,
      useSRGBBuffer: y
    }, E.samplingMode === ee.NEAREST_SAMPLINGMODE && (E.wrapU = ee.CLAMP_ADDRESSMODE, E.wrapV = ee.CLAMP_ADDRESSMODE), p || (u ? (E._renderTarget = n.getEngine().createRenderTargetCubeTexture(E.getRenderSize(), E._renderTargetOptions), E.coordinatesMode = ee.INVCUBIC_MODE, E._textureMatrix = I.Identity()) : E._renderTarget = n.getEngine().createRenderTargetTexture(E._size, E._renderTargetOptions), E._texture = E._renderTarget.texture, g !== void 0 && (E.samples = g))), E;
  }
  return Object.defineProperty(e.prototype, "renderList", {
    get: function() {
      return this._renderList;
    },
    set: function(t) {
      this._renderList = t, this._renderList && this._hookArray(this._renderList);
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._hookArray = function(t) {
    var r = this, n = t.push;
    t.push = function() {
      for (var s, o = [], u = 0; u < arguments.length; u++)
        o[u] = arguments[u];
      var f = t.length === 0, l = n.apply(t, o);
      return f && ((s = r.getScene()) === null || s === void 0 || s.meshes.forEach(function(h) {
        h._markSubMeshesAsLightDirty();
      })), l;
    };
    var a = t.splice;
    t.splice = function(s, o) {
      var u, f = a.apply(t, [s, o]);
      return t.length === 0 && ((u = r.getScene()) === null || u === void 0 || u.meshes.forEach(function(l) {
        l._markSubMeshesAsLightDirty();
      })), f;
    };
  }, Object.defineProperty(e.prototype, "postProcesses", {
    get: function() {
      return this._postProcesses;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "_prePassEnabled", {
    get: function() {
      return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "onAfterUnbind", {
    set: function(t) {
      this._onAfterUnbindObserver && this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver), this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "onBeforeRender", {
    set: function(t) {
      this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "onAfterRender", {
    set: function(t) {
      this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "onClear", {
    set: function(t) {
      this._onClearObserver && this.onClearObservable.remove(this._onClearObserver), this._onClearObserver = this.onClearObservable.add(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "renderPassIds", {
    get: function() {
      return this._renderPassIds;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "currentRefreshId", {
    get: function() {
      return this._currentRefreshId;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.setMaterialForRendering = function(t, r) {
    var n;
    Array.isArray(t) ? n = t : n = [t];
    for (var a = 0; a < n.length; ++a)
      for (var s = 0; s < this._renderPassIds.length; ++s)
        n[a].setMaterialForRenderPass(this._renderPassIds[s], r !== void 0 ? Array.isArray(r) ? r[s] : r : void 0);
  }, Object.defineProperty(e.prototype, "renderTargetOptions", {
    get: function() {
      return this._renderTargetOptions;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "renderTarget", {
    get: function() {
      return this._renderTarget;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._onRatioRescale = function() {
    this._sizeRatio && this.resize(this._initialSizeParameter);
  }, Object.defineProperty(e.prototype, "boundingBoxSize", {
    get: function() {
      return this._boundingBoxSize;
    },
    set: function(t) {
      if (!(this._boundingBoxSize && this._boundingBoxSize.equals(t))) {
        this._boundingBoxSize = t;
        var r = this.getScene();
        r && r.markAllMaterialsAsDirty(1);
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "depthStencilTexture", {
    get: function() {
      var t, r;
      return (r = (t = this._renderTarget) === null || t === void 0 ? void 0 : t._depthStencilTexture) !== null && r !== void 0 ? r : null;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.createDepthStencilTexture = function(t, r, n, a, s) {
    var o;
    t === void 0 && (t = 0), r === void 0 && (r = !0), n === void 0 && (n = !1), a === void 0 && (a = 1), s === void 0 && (s = 14), (o = this._renderTarget) === null || o === void 0 || o.createDepthStencilTexture(t, r, n, a, s);
  }, e.prototype._releaseRenderPassId = function() {
    if (this._scene)
      for (var t = this._scene.getEngine(), r = 0; r < this._renderPassIds.length; ++r)
        t.releaseRenderPassId(this._renderPassIds[r]);
    this._renderPassIds = [];
  }, e.prototype._createRenderPassId = function() {
    this._releaseRenderPassId();
    for (var t = this._scene.getEngine(), r = this._isCubeData ? 6 : this.getRenderLayers() || 1, n = 0; n < r; ++n)
      this._renderPassIds[n] = t.createRenderPassId("RenderTargetTexture - ".concat(this.name, "#").concat(n));
  }, e.prototype._processSizeParameter = function(t) {
    if (t.ratio) {
      this._sizeRatio = t.ratio;
      var r = this._getEngine();
      this._size = {
        width: this._bestReflectionRenderTargetDimension(r.getRenderWidth(), this._sizeRatio),
        height: this._bestReflectionRenderTargetDimension(r.getRenderHeight(), this._sizeRatio)
      };
    } else
      this._size = t;
    this._createRenderPassId();
  }, Object.defineProperty(e.prototype, "samples", {
    get: function() {
      var t, r;
      return (r = (t = this._renderTarget) === null || t === void 0 ? void 0 : t.samples) !== null && r !== void 0 ? r : this._samples;
    },
    set: function(t) {
      this._renderTarget && (this._samples = this._renderTarget.setSamples(t));
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.resetRefreshCounter = function() {
    this._currentRefreshId = -1;
  }, Object.defineProperty(e.prototype, "refreshRate", {
    get: function() {
      return this._refreshRate;
    },
    set: function(t) {
      this._refreshRate = t, this.resetRefreshCounter();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.addPostProcess = function(t) {
    if (!this._postProcessManager) {
      var r = this.getScene();
      if (!r)
        return;
      this._postProcessManager = new Mr(r), this._postProcesses = new Array();
    }
    this._postProcesses.push(t), this._postProcesses[0].autoClear = !1;
  }, e.prototype.clearPostProcesses = function(t) {
    if (t === void 0 && (t = !1), !!this._postProcesses) {
      if (t)
        for (var r = 0, n = this._postProcesses; r < n.length; r++) {
          var a = n[r];
          a.dispose();
        }
      this._postProcesses = [];
    }
  }, e.prototype.removePostProcess = function(t) {
    if (!!this._postProcesses) {
      var r = this._postProcesses.indexOf(t);
      r !== -1 && (this._postProcesses.splice(r, 1), this._postProcesses.length > 0 && (this._postProcesses[0].autoClear = !1));
    }
  }, e.prototype._shouldRender = function() {
    return this._currentRefreshId === -1 ? (this._currentRefreshId = 1, !0) : this.refreshRate === this._currentRefreshId ? (this._currentRefreshId = 1, !0) : (this._currentRefreshId++, !1);
  }, e.prototype.getRenderSize = function() {
    return this.getRenderWidth();
  }, e.prototype.getRenderWidth = function() {
    return this._size.width ? this._size.width : this._size;
  }, e.prototype.getRenderHeight = function() {
    return this._size.width ? this._size.height : this._size;
  }, e.prototype.getRenderLayers = function() {
    var t = this._size.layers;
    return t || 0;
  }, e.prototype.disableRescaling = function() {
    this._canRescale = !1;
  }, Object.defineProperty(e.prototype, "canRescale", {
    get: function() {
      return this._canRescale;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.scale = function(t) {
    var r = Math.max(1, this.getRenderSize() * t);
    this.resize(r);
  }, e.prototype.getReflectionTextureMatrix = function() {
    return this.isCube ? this._textureMatrix : i.prototype.getReflectionTextureMatrix.call(this);
  }, e.prototype.resize = function(t) {
    var r, n = this.isCube;
    (r = this._renderTarget) === null || r === void 0 || r.dispose(), this._renderTarget = null;
    var a = this.getScene();
    !a || (this._processSizeParameter(t), n ? this._renderTarget = a.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions) : this._renderTarget = a.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions), this._texture = this._renderTarget.texture, this._renderTargetOptions.samples !== void 0 && (this.samples = this._renderTargetOptions.samples), this.onResizeObservable.hasObservers() && this.onResizeObservable.notifyObservers(this));
  }, e.prototype.render = function(t, r) {
    t === void 0 && (t = !1), r === void 0 && (r = !1), this._render(t, r);
  }, e.prototype.isReadyForRendering = function() {
    return this._render(!1, !1, !0);
  }, e.prototype._render = function(t, r, n) {
    var a;
    t === void 0 && (t = !1), r === void 0 && (r = !1), n === void 0 && (n = !1);
    var s = this.getScene();
    if (!s)
      return n;
    var o = s.getEngine();
    if (this.useCameraPostProcesses !== void 0 && (t = this.useCameraPostProcesses), this._waitingRenderList) {
      this.renderList = [];
      for (var u = 0; u < this._waitingRenderList.length; u++) {
        var f = this._waitingRenderList[u], l = s.getMeshById(f);
        l && this.renderList.push(l);
      }
      this._waitingRenderList = void 0;
    }
    if (this.renderListPredicate) {
      this.renderList ? this.renderList.length = 0 : this.renderList = [];
      var h = this.getScene();
      if (!h)
        return n;
      for (var c = h.meshes, u = 0; u < c.length; u++) {
        var l = c[u];
        this.renderListPredicate(l) && this.renderList.push(l);
      }
    }
    var d = o.currentRenderPassId;
    this.onBeforeBindObservable.notifyObservers(this);
    var p = (a = this.activeCamera) !== null && a !== void 0 ? a : s.activeCamera;
    p && (p !== s.activeCamera && s.setTransformMatrix(p.getViewMatrix(), p.getProjectionMatrix(!0)), o.setViewport(p.viewport, this.getRenderWidth(), this.getRenderHeight())), this._defaultRenderListPrepared = !1;
    var g = n;
    if (n) {
      s.getViewMatrix() || s.updateTransformMatrix();
      for (var y = this.is2DArray ? this.getRenderLayers() : this.isCube ? 6 : 1, _ = 0; _ < y && g; _++) {
        var E = null, R = this.renderList ? this.renderList : s.getActiveMeshes().data, M = this.renderList ? this.renderList.length : s.getActiveMeshes().length;
        o.currentRenderPassId = this._renderPassIds[_], this.onBeforeRenderObservable.notifyObservers(_), this.getCustomRenderList && (E = this.getCustomRenderList(_, R, M)), E || (E = R), this._doNotChangeAspectRatio || s.updateTransformMatrix(!0);
        for (var C = 0; C < E.length && g; ++C) {
          var l = E[C];
          if (!(!l.isEnabled() || l.isBlocked || !l.isVisible || !l.subMeshes)) {
            if (this.customIsReadyFunction) {
              if (!this.customIsReadyFunction(l, this.refreshRate)) {
                g = !1;
                break;
              }
            } else if (!l.isReady(!0)) {
              g = !1;
              break;
            }
          }
        }
        this.onAfterRenderObservable.notifyObservers(_);
      }
    } else if (this.is2DArray)
      for (var _ = 0; _ < this.getRenderLayers(); _++)
        this._renderToTarget(0, t, r, _, p), s.incrementRenderId(), s.resetCachedMaterial();
    else if (this.isCube)
      for (var v = 0; v < 6; v++)
        this._renderToTarget(v, t, r, void 0, p), s.incrementRenderId(), s.resetCachedMaterial();
    else
      this._renderToTarget(0, t, r, void 0, p);
    return this.onAfterUnbindObservable.notifyObservers(this), o.currentRenderPassId = d, s.activeCamera && ((s.getEngine().scenes.length > 1 || this.activeCamera && this.activeCamera !== s.activeCamera) && s.setTransformMatrix(s.activeCamera.getViewMatrix(), s.activeCamera.getProjectionMatrix(!0)), o.setViewport(s.activeCamera.viewport)), s.resetCachedMaterial(), g;
  }, e.prototype._bestReflectionRenderTargetDimension = function(t, r) {
    var n = 128, a = t * r, s = fe.NearestPOT(a + n * n / (n + a));
    return Math.min(fe.FloorPOT(t), s);
  }, e.prototype._prepareRenderingManager = function(t, r, n, a) {
    var s = this.getScene();
    if (!!s) {
      this._renderingManager.reset();
      for (var o = s.getRenderId(), u = 0; u < r; u++) {
        var f = t[u];
        if (f && !f.isBlocked) {
          if (this.customIsReadyFunction) {
            if (!this.customIsReadyFunction(f, this.refreshRate)) {
              this.resetRefreshCounter();
              continue;
            }
          } else if (!f.isReady(this.refreshRate === 0)) {
            this.resetRefreshCounter();
            continue;
          }
          if (!f._internalAbstractMeshDataInfo._currentLODIsUpToDate && s.activeCamera && (f._internalAbstractMeshDataInfo._currentLOD = s.customLODSelector ? s.customLODSelector(f, this.activeCamera || s.activeCamera) : f.getLOD(this.activeCamera || s.activeCamera), f._internalAbstractMeshDataInfo._currentLODIsUpToDate = !0), !f._internalAbstractMeshDataInfo._currentLOD)
            continue;
          var l = f._internalAbstractMeshDataInfo._currentLOD;
          l._preActivateForIntermediateRendering(o);
          var h = void 0;
          if (a && n ? h = (f.layerMask & n.layerMask) === 0 : h = !1, f.isEnabled() && f.isVisible && f.subMeshes && !h && (l !== f && l._activate(o, !0), f._activate(o, !0) && f.subMeshes.length)) {
            f.isAnInstance ? f._internalAbstractMeshDataInfo._actAsRegularMesh && (l = f) : l._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = !1, l._internalAbstractMeshDataInfo._isActiveIntermediate = !0;
            for (var c = 0; c < l.subMeshes.length; c++) {
              var d = l.subMeshes[c];
              this._renderingManager.dispatch(d, l);
            }
          }
        }
      }
      for (var p = 0; p < s.particleSystems.length; p++) {
        var g = s.particleSystems[p], _ = g.emitter;
        !g.isStarted() || !_ || !_.position || !_.isEnabled() || t.indexOf(_) >= 0 && this._renderingManager.dispatchParticles(g);
      }
    }
  }, e.prototype._bindFrameBuffer = function(t, r) {
    t === void 0 && (t = 0), r === void 0 && (r = 0);
    var n = this.getScene();
    if (!!n) {
      var a = n.getEngine();
      this._renderTarget && a.bindFramebuffer(this._renderTarget, this.isCube ? t : void 0, void 0, void 0, this.ignoreCameraViewport, 0, r);
    }
  }, e.prototype._unbindFrameBuffer = function(t, r) {
    var n = this;
    !this._renderTarget || t.unBindFramebuffer(this._renderTarget, this.isCube, function() {
      n.onAfterRenderObservable.notifyObservers(r);
    });
  }, e.prototype._prepareFrame = function(t, r, n, a) {
    this._postProcessManager ? this._prePassEnabled || this._postProcessManager._prepareFrame(this._texture, this._postProcesses) : (!a || !t.postProcessManager._prepareFrame(this._texture)) && this._bindFrameBuffer(r, n);
  }, e.prototype._renderToTarget = function(t, r, n, a, s) {
    var o, u, f, l, h, c;
    a === void 0 && (a = 0), s === void 0 && (s = null);
    var d = this.getScene();
    if (!!d) {
      var p = d.getEngine();
      (o = p._debugPushGroup) === null || o === void 0 || o.call(p, "render to face #".concat(t, " layer #").concat(a), 1), this._prepareFrame(d, t, a, r), this.is2DArray ? (p.currentRenderPassId = this._renderPassIds[a], this.onBeforeRenderObservable.notifyObservers(a)) : (p.currentRenderPassId = this._renderPassIds[t], this.onBeforeRenderObservable.notifyObservers(t));
      var g = p.snapshotRendering && p.snapshotRenderingMode === 1;
      if (g)
        this.onClearObservable.hasObservers() ? this.onClearObservable.notifyObservers(p) : this.skipInitialClear || p.clear(this.clearColor || d.clearColor, !0, !0, !0);
      else {
        var _ = null, v = this.renderList ? this.renderList : d.getActiveMeshes().data, y = this.renderList ? this.renderList.length : d.getActiveMeshes().length;
        this.getCustomRenderList && (_ = this.getCustomRenderList(this.is2DArray ? a : t, v, y)), _ ? this._prepareRenderingManager(_, _.length, s, !1) : (this._defaultRenderListPrepared || (this._prepareRenderingManager(v, y, s, !this.renderList), this._defaultRenderListPrepared = !0), _ = v);
        for (var E = 0, R = d._beforeRenderTargetClearStage; E < R.length; E++) {
          var M = R[E];
          M.action(this, t, a);
        }
        this.onClearObservable.hasObservers() ? this.onClearObservable.notifyObservers(p) : this.skipInitialClear || p.clear(this.clearColor || d.clearColor, !0, !0, !0), this._doNotChangeAspectRatio || d.updateTransformMatrix(!0);
        for (var C = 0, A = d._beforeRenderTargetDrawStage; C < A.length; C++) {
          var M = A[C];
          M.action(this, t, a);
        }
        this._renderingManager.render(this.customRenderFunction, _, this.renderParticles, this.renderSprites);
        for (var S = 0, w = d._afterRenderTargetDrawStage; S < w.length; S++) {
          var M = w[S];
          M.action(this, t, a);
        }
        var F = (f = (u = this._texture) === null || u === void 0 ? void 0 : u.generateMipMaps) !== null && f !== void 0 ? f : !1;
        this._texture && (this._texture.generateMipMaps = !1), this._postProcessManager ? this._postProcessManager._finalizeFrame(!1, (l = this._renderTarget) !== null && l !== void 0 ? l : void 0, t, this._postProcesses, this.ignoreCameraViewport) : r && d.postProcessManager._finalizeFrame(!1, (h = this._renderTarget) !== null && h !== void 0 ? h : void 0, t), this._texture && (this._texture.generateMipMaps = F), this._doNotChangeAspectRatio || d.updateTransformMatrix(!0), n && de.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), p);
      }
      this._unbindFrameBuffer(p, t), this._texture && this.isCube && t === 5 && p.generateMipMapsForCubemap(this._texture), (c = p._debugPopGroup) === null || c === void 0 || c.call(p, 1);
    }
  }, e.prototype.setRenderingOrder = function(t, r, n, a) {
    r === void 0 && (r = null), n === void 0 && (n = null), a === void 0 && (a = null), this._renderingManager.setRenderingOrder(t, r, n, a);
  }, e.prototype.setRenderingAutoClearDepthStencil = function(t, r) {
    this._renderingManager.setRenderingAutoClearDepthStencil(t, r), this._renderingManager._useSceneAutoClearSetup = !1;
  }, e.prototype.clone = function() {
    var t = this.getSize(), r = new e(this.name, t, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer, void 0, this._renderTargetOptions.format, void 0, this._renderTargetOptions.samples);
    return r.hasAlpha = this.hasAlpha, r.level = this.level, r.coordinatesMode = this.coordinatesMode, this.renderList && (r.renderList = this.renderList.slice(0)), r;
  }, e.prototype.serialize = function() {
    if (!this.name)
      return null;
    var t = i.prototype.serialize.call(this);
    if (t.renderTargetSize = this.getRenderSize(), t.renderList = [], this.renderList)
      for (var r = 0; r < this.renderList.length; r++)
        t.renderList.push(this.renderList[r].id);
    return t;
  }, e.prototype.disposeFramebufferObjects = function() {
    var t;
    (t = this._renderTarget) === null || t === void 0 || t.dispose(!0);
  }, e.prototype.releaseInternalTexture = function() {
    var t;
    (t = this._renderTarget) === null || t === void 0 || t.releaseTextures(), this._texture = null;
  }, e.prototype.dispose = function() {
    var t;
    this.onResizeObservable.clear(), this.onClearObservable.clear(), this.onAfterRenderObservable.clear(), this.onAfterUnbindObservable.clear(), this.onBeforeBindObservable.clear(), this.onBeforeRenderObservable.clear(), this._postProcessManager && (this._postProcessManager.dispose(), this._postProcessManager = null), this._prePassRenderTarget && this._prePassRenderTarget.dispose(), this._releaseRenderPassId(), this.clearPostProcesses(!0), this._resizeObserver && (this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver), this._resizeObserver = null), this.renderList = null;
    var r = this.getScene();
    if (!!r) {
      var n = r.customRenderTargets.indexOf(this);
      n >= 0 && r.customRenderTargets.splice(n, 1);
      for (var a = 0, s = r.cameras; a < s.length; a++) {
        var o = s[a];
        n = o.customRenderTargets.indexOf(this), n >= 0 && o.customRenderTargets.splice(n, 1);
      }
      (t = this._renderTarget) === null || t === void 0 || t.dispose(), this._renderTarget = null, this._texture = null, i.prototype.dispose.call(this);
    }
  }, e.prototype._rebuild = function() {
    this.refreshRate === e.REFRESHRATE_RENDER_ONCE && (this.refreshRate = e.REFRESHRATE_RENDER_ONCE), this._postProcessManager && this._postProcessManager._rebuild();
  }, e.prototype.freeRenderingGroups = function() {
    this._renderingManager && this._renderingManager.freeRenderingGroups();
  }, e.prototype.getViewCount = function() {
    return 1;
  }, e.REFRESHRATE_RENDER_ONCE = 0, e.REFRESHRATE_RENDER_ONEVERYFRAME = 1, e.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2, e;
}(ee);
ee._CreateRenderTargetTexture = function(i, e, t, r, n) {
  return new kt(i, e, t, r);
};
var Ga = "postprocessVertexShader", Xa = `attribute vec2 position;
uniform vec2 scale;
varying vec2 vUV;
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=(position*madd+madd)*scale;
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
L.ShadersStore[Ga] = Xa;
var tr = function() {
  function i(e, t, r, n, a, s, o, u, f, l, h, c, d, p, g) {
    o === void 0 && (o = 1), l === void 0 && (l = null), h === void 0 && (h = 0), c === void 0 && (c = "postprocess"), p === void 0 && (p = !1), g === void 0 && (g = 5), this._parentContainer = null, this.width = -1, this.height = -1, this.nodeMaterialSource = null, this._outputTexture = null, this.autoClear = !0, this.alphaMode = 0, this.animations = new Array(), this.enablePixelPerfectMode = !1, this.forceFullscreenViewport = !0, this.scaleMode = 1, this.alwaysForcePOT = !1, this._samples = 1, this.adaptScaleToCurrentViewport = !1, this._reusable = !1, this._renderId = 0, this.externalTextureSamplerBinding = !1, this._textures = new ke(2), this._textureCache = [], this._currentRenderTextureInd = 0, this._scaleRatio = new Ee(1, 1), this._texelSize = Ee.Zero(), this.onActivateObservable = new O(), this.onSizeChangedObservable = new O(), this.onApplyObservable = new O(), this.onBeforeRenderObservable = new O(), this.onAfterRenderObservable = new O(), this.name = e, s != null ? (this._camera = s, this._scene = s.getScene(), s.attachPostProcess(this), this._engine = this._scene.getEngine(), this._scene.postProcesses.push(this), this.uniqueId = this._scene.getUniqueId()) : u && (this._engine = u, this._engine.postProcesses.push(this)), this._options = a, this.renderTargetSamplingMode = o || 1, this._reusable = f || !1, this._textureType = h, this._textureFormat = g, this._samplers = n || [], this._samplers.push("textureSampler"), this._fragmentUrl = t, this._vertexUrl = c, this._parameters = r || [], this._parameters.push("scale"), this._indexParameters = d, this._drawWrapper = new sr(this._engine), p || this.updateEffect(l);
  }
  return Object.defineProperty(i.prototype, "samples", {
    get: function() {
      return this._samples;
    },
    set: function(e) {
      var t = this;
      this._samples = Math.min(e, this._engine.getCaps().maxMSAASamples), this._textures.forEach(function(r) {
        r.samples !== t._samples && t._engine.updateRenderTargetTextureSampleCount(r, t._samples);
      });
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getEffectName = function() {
    return this._fragmentUrl;
  }, Object.defineProperty(i.prototype, "onActivate", {
    set: function(e) {
      this._onActivateObserver && this.onActivateObservable.remove(this._onActivateObserver), e && (this._onActivateObserver = this.onActivateObservable.add(e));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "onSizeChanged", {
    set: function(e) {
      this._onSizeChangedObserver && this.onSizeChangedObservable.remove(this._onSizeChangedObserver), this._onSizeChangedObserver = this.onSizeChangedObservable.add(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "onApply", {
    set: function(e) {
      this._onApplyObserver && this.onApplyObservable.remove(this._onApplyObserver), this._onApplyObserver = this.onApplyObservable.add(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "onBeforeRender", {
    set: function(e) {
      this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "onAfterRender", {
    set: function(e) {
      this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "inputTexture", {
    get: function() {
      return this._textures.data[this._currentRenderTextureInd];
    },
    set: function(e) {
      this._forcedOutputTexture = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.restoreDefaultInputTexture = function() {
    this._forcedOutputTexture && (this._forcedOutputTexture = null, this.markTextureDirty());
  }, i.prototype.getCamera = function() {
    return this._camera;
  }, Object.defineProperty(i.prototype, "texelSize", {
    get: function() {
      return this._shareOutputWithPostProcess ? this._shareOutputWithPostProcess.texelSize : (this._forcedOutputTexture && this._texelSize.copyFromFloats(1 / this._forcedOutputTexture.width, 1 / this._forcedOutputTexture.height), this._texelSize);
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getClassName = function() {
    return "PostProcess";
  }, i.prototype.getEngine = function() {
    return this._engine;
  }, i.prototype.getEffect = function() {
    return this._drawWrapper.effect;
  }, i.prototype.shareOutputWith = function(e) {
    return this._disposeTextures(), this._shareOutputWithPostProcess = e, this;
  }, i.prototype.useOwnOutput = function() {
    this._textures.length == 0 && (this._textures = new ke(2)), this._shareOutputWithPostProcess = null;
  }, i.prototype.updateEffect = function(e, t, r, n, a, s, o, u) {
    e === void 0 && (e = null), t === void 0 && (t = null), r === void 0 && (r = null), this._postProcessDefines = e, this._drawWrapper.effect = this._engine.createEffect({ vertex: o != null ? o : this._vertexUrl, fragment: u != null ? u : this._fragmentUrl }, ["position"], t || this._parameters, r || this._samplers, e !== null ? e : "", void 0, a, s, n || this._indexParameters);
  }, i.prototype.isReusable = function() {
    return this._reusable;
  }, i.prototype.markTextureDirty = function() {
    this.width = -1;
  }, i.prototype._createRenderTargetTexture = function(e, t, r) {
    r === void 0 && (r = 0);
    for (var n = 0; n < this._textureCache.length; n++)
      if (this._textureCache[n].texture.width === e.width && this._textureCache[n].texture.height === e.height && this._textureCache[n].postProcessChannel === r && this._textureCache[n].texture._generateDepthBuffer === t.generateDepthBuffer)
        return this._textureCache[n].texture;
    var a = this._engine.createRenderTargetTexture(e, t);
    return this._textureCache.push({ texture: a, postProcessChannel: r, lastUsedRenderId: -1 }), a;
  }, i.prototype._flushTextureCache = function() {
    for (var e = this._renderId, t = this._textureCache.length - 1; t >= 0; t--)
      if (e - this._textureCache[t].lastUsedRenderId > 100) {
        for (var r = !1, n = 0; n < this._textures.length; n++)
          if (this._textures.data[n] === this._textureCache[t].texture) {
            r = !0;
            break;
          }
        r || (this._textureCache[t].texture.dispose(), this._textureCache.splice(t, 1));
      }
  }, i.prototype._resize = function(e, t, r, n, a) {
    this._textures.length > 0 && this._textures.reset(), this.width = e, this.height = t;
    for (var s = null, o = 0; o < r._postProcesses.length; o++)
      if (r._postProcesses[o] !== null) {
        s = r._postProcesses[o];
        break;
      }
    var u = { width: this.width, height: this.height }, f = {
      generateMipMaps: n,
      generateDepthBuffer: a || s === this,
      generateStencilBuffer: (a || s === this) && this._engine.isStencilEnable,
      samplingMode: this.renderTargetSamplingMode,
      type: this._textureType,
      format: this._textureFormat
    };
    this._textures.push(this._createRenderTargetTexture(u, f, 0)), this._reusable && this._textures.push(this._createRenderTargetTexture(u, f, 1)), this._texelSize.copyFromFloats(1 / this.width, 1 / this.height), this.onSizeChangedObservable.notifyObservers(this);
  }, i.prototype.activate = function(e, t, r) {
    var n = this, a, s;
    t === void 0 && (t = null), e = e || this._camera;
    var o = e.getScene(), u = o.getEngine(), f = u.getCaps().maxTextureSize, l = (t ? t.width : this._engine.getRenderWidth(!0)) * this._options | 0, h = (t ? t.height : this._engine.getRenderHeight(!0)) * this._options | 0, c = e.parent;
    c && (c.leftCamera == e || c.rightCamera == e) && (l /= 2);
    var d = this._options.width || l, p = this._options.height || h, g = this.renderTargetSamplingMode !== 7 && this.renderTargetSamplingMode !== 1 && this.renderTargetSamplingMode !== 2;
    if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {
      if (this.adaptScaleToCurrentViewport) {
        var _ = u.currentViewport;
        _ && (d *= _.width, p *= _.height);
      }
      (g || this.alwaysForcePOT) && (this._options.width || (d = u.needPOTTextures ? fe.GetExponentOfTwo(d, f, this.scaleMode) : d), this._options.height || (p = u.needPOTTextures ? fe.GetExponentOfTwo(p, f, this.scaleMode) : p)), (this.width !== d || this.height !== p) && this._resize(d, p, e, g, r), this._textures.forEach(function(R) {
        R.samples !== n.samples && n._engine.updateRenderTargetTextureSampleCount(R, n.samples);
      }), this._flushTextureCache(), this._renderId++;
    }
    var v;
    if (this._shareOutputWithPostProcess)
      v = this._shareOutputWithPostProcess.inputTexture;
    else if (this._forcedOutputTexture)
      v = this._forcedOutputTexture, this.width = this._forcedOutputTexture.width, this.height = this._forcedOutputTexture.height;
    else {
      v = this.inputTexture;
      for (var y = void 0, E = 0; E < this._textureCache.length; E++)
        if (this._textureCache[E].texture === v) {
          y = this._textureCache[E];
          break;
        }
      y && (y.lastUsedRenderId = this._renderId);
    }
    return this.enablePixelPerfectMode ? (this._scaleRatio.copyFromFloats(l / d, h / p), this._engine.bindFramebuffer(v, 0, l, h, this.forceFullscreenViewport)) : (this._scaleRatio.copyFromFloats(1, 1), this._engine.bindFramebuffer(v, 0, void 0, void 0, this.forceFullscreenViewport)), (s = (a = this._engine)._debugInsertMarker) === null || s === void 0 || s.call(a, "post process ".concat(this.name, " input")), this.onActivateObservable.notifyObservers(e), this.autoClear && this.alphaMode === 0 && this._engine.clear(this.clearColor ? this.clearColor : o.clearColor, o._allowPostProcessClearColor, !0, !0), this._reusable && (this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2), v;
  }, Object.defineProperty(i.prototype, "isSupported", {
    get: function() {
      return this._drawWrapper.effect.isSupported;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "aspectRatio", {
    get: function() {
      return this._shareOutputWithPostProcess ? this._shareOutputWithPostProcess.aspectRatio : this._forcedOutputTexture ? this._forcedOutputTexture.width / this._forcedOutputTexture.height : this.width / this.height;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.isReady = function() {
    var e, t;
    return (t = (e = this._drawWrapper.effect) === null || e === void 0 ? void 0 : e.isReady()) !== null && t !== void 0 ? t : !1;
  }, i.prototype.apply = function() {
    var e;
    if (!(!((e = this._drawWrapper.effect) === null || e === void 0) && e.isReady()))
      return null;
    this._engine.enableEffect(this._drawWrapper), this._engine.setState(!1), this._engine.setDepthBuffer(!1), this._engine.setDepthWrite(!1), this._engine.setAlphaMode(this.alphaMode), this.alphaConstants && this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);
    var t;
    return this._shareOutputWithPostProcess ? t = this._shareOutputWithPostProcess.inputTexture : this._forcedOutputTexture ? t = this._forcedOutputTexture : t = this.inputTexture, this.externalTextureSamplerBinding || this._drawWrapper.effect._bindTexture("textureSampler", t == null ? void 0 : t.texture), this._drawWrapper.effect.setVector2("scale", this._scaleRatio), this.onApplyObservable.notifyObservers(this._drawWrapper.effect), this._drawWrapper.effect;
  }, i.prototype._disposeTextures = function() {
    if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {
      this._disposeTextureCache();
      return;
    }
    this._disposeTextureCache(), this._textures.dispose();
  }, i.prototype._disposeTextureCache = function() {
    for (var e = this._textureCache.length - 1; e >= 0; e--)
      this._textureCache[e].texture.dispose();
    this._textureCache.length = 0;
  }, i.prototype.setPrePassRenderer = function(e) {
    return this._prePassEffectConfiguration ? (this._prePassEffectConfiguration = e.addEffectConfiguration(this._prePassEffectConfiguration), this._prePassEffectConfiguration.enabled = !0, !0) : !1;
  }, i.prototype.dispose = function(e) {
    e = e || this._camera, this._disposeTextures();
    var t;
    if (this._scene && (t = this._scene.postProcesses.indexOf(this), t !== -1 && this._scene.postProcesses.splice(t, 1)), this._parentContainer) {
      var r = this._parentContainer.postProcesses.indexOf(this);
      r > -1 && this._parentContainer.postProcesses.splice(r, 1), this._parentContainer = null;
    }
    if (t = this._engine.postProcesses.indexOf(this), t !== -1 && this._engine.postProcesses.splice(t, 1), !!e) {
      if (e.detachPostProcess(this), t = e._postProcesses.indexOf(this), t === 0 && e._postProcesses.length > 0) {
        var n = this._camera._getFirstPostProcess();
        n && n.markTextureDirty();
      }
      this.onActivateObservable.clear(), this.onAfterRenderObservable.clear(), this.onApplyObservable.clear(), this.onBeforeRenderObservable.clear(), this.onSizeChangedObservable.clear();
    }
  }, i.prototype.serialize = function() {
    var e = $.Serialize(this), t = this.getCamera() || this._scene && this._scene.activeCamera;
    return e.customType = "BABYLON." + this.getClassName(), e.cameraId = t ? t.id : null, e.reusable = this._reusable, e.textureType = this._textureType, e.fragmentUrl = this._fragmentUrl, e.parameters = this._parameters, e.samplers = this._samplers, e.options = this._options, e.defines = this._postProcessDefines, e.textureFormat = this._textureFormat, e.vertexUrl = this._vertexUrl, e.indexParameters = this._indexParameters, e;
  }, i.prototype.clone = function() {
    var e = this.serialize();
    e._engine = this._engine, e.cameraId = null;
    var t = i.Parse(e, this._scene, "");
    return t ? (t.onActivateObservable = this.onActivateObservable.clone(), t.onSizeChangedObservable = this.onSizeChangedObservable.clone(), t.onApplyObservable = this.onApplyObservable.clone(), t.onBeforeRenderObservable = this.onBeforeRenderObservable.clone(), t.onAfterRenderObservable = this.onAfterRenderObservable.clone(), t._prePassEffectConfiguration = this._prePassEffectConfiguration, t) : null;
  }, i.Parse = function(e, t, r) {
    var n = Ct(e.customType);
    if (!n || !n._Parse)
      return null;
    var a = t ? t.getCameraById(e.cameraId) : null;
    return n._Parse(e, a, t, r);
  }, i._Parse = function(e, t, r, n) {
    return $.Parse(function() {
      return new i(e.name, e.fragmentUrl, e.parameters, e.samplers, e.options, t, e.renderTargetSamplingMode, e._engine, e.reusable, e.defines, e.textureType, e.vertexUrl, e.indexParameters, !1, e.textureFormat);
    }, e, r, n);
  }, T([
    P()
  ], i.prototype, "uniqueId", void 0), T([
    P()
  ], i.prototype, "name", void 0), T([
    P()
  ], i.prototype, "width", void 0), T([
    P()
  ], i.prototype, "height", void 0), T([
    P()
  ], i.prototype, "renderTargetSamplingMode", void 0), T([
    fn()
  ], i.prototype, "clearColor", void 0), T([
    P()
  ], i.prototype, "autoClear", void 0), T([
    P()
  ], i.prototype, "alphaMode", void 0), T([
    P()
  ], i.prototype, "alphaConstants", void 0), T([
    P()
  ], i.prototype, "enablePixelPerfectMode", void 0), T([
    P()
  ], i.prototype, "forceFullscreenViewport", void 0), T([
    P()
  ], i.prototype, "scaleMode", void 0), T([
    P()
  ], i.prototype, "alwaysForcePOT", void 0), T([
    P("samples")
  ], i.prototype, "_samples", void 0), T([
    P()
  ], i.prototype, "adaptScaleToCurrentViewport", void 0), i;
}();
Ne("BABYLON.PostProcess", tr);
var Ha = "kernelBlurVaryingDeclaration", ja = "varying vec2 sampleCoord{X};";
L.IncludesShadersStore[Ha] = ja;
var Ka = "packingFunctions", Ya = `vec4 pack(float depth)
{
const vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);
const vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);
vec4 res=fract(depth*bit_shift);
res-=res.xxyz*bit_mask;
return res;
}
float unpack(vec4 color)
{
const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);
return dot(color,bit_shift);
}`;
L.IncludesShadersStore[Ka] = Ya;
var Za = "kernelBlurFragment", qa = `#ifdef DOF
factor=sampleCoC(sampleCoord{X}); 
computedWeight=KERNEL_WEIGHT{X}*factor;
sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;
#endif
`;
L.IncludesShadersStore[Za] = qa;
var Qa = "kernelBlurFragment2", $a = `#ifdef DOF
factor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});
computedWeight=KERNEL_DEP_WEIGHT{X}*factor;
sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_DEP_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;
#endif
`;
L.IncludesShadersStore[Qa] = $a;
var Ja = "kernelBlurPixelShader", es = `uniform sampler2D textureSampler;
uniform vec2 delta;
varying vec2 sampleCenter;
#ifdef DOF
uniform sampler2D circleOfConfusionSampler;
uniform vec2 cameraMinMaxZ;
float sampleDistance(in vec2 offset) {
float depth=texture2D(circleOfConfusionSampler,offset).g; 
return cameraMinMaxZ.x+(cameraMinMaxZ.y-cameraMinMaxZ.x)*depth; 
}
float sampleCoC(in vec2 offset) {
float coc=texture2D(circleOfConfusionSampler,offset).r; 
return coc; 
}
#endif
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#ifdef PACKEDFLOAT
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
float computedWeight=0.0;
#ifdef PACKEDFLOAT 
float blend=0.;
#else
vec4 blend=vec4(0.);
#endif
#ifdef DOF
float sumOfWeights=CENTER_WEIGHT; 
float factor=0.0;
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;
#else
blend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;
#endif
#endif
#include<kernelBlurFragment>[0..varyingCount]
#include<kernelBlurFragment2>[0..depCount]
#ifdef PACKEDFLOAT
gl_FragColor=pack(blend);
#else
gl_FragColor=blend;
#endif
#ifdef DOF
gl_FragColor/=sumOfWeights;
#endif
}`;
L.ShadersStore[Ja] = es;
var ts = "kernelBlurVertex", rs = "sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};";
L.IncludesShadersStore[ts] = rs;
var is = "kernelBlurVertexShader", ns = `attribute vec2 position;
uniform vec2 delta;
varying vec2 sampleCenter;
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
sampleCenter=(position*madd+madd);
#include<kernelBlurVertex>[0..varyingCount]
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
L.ShadersStore[is] = ns;
var ui = function(i) {
  K(e, i);
  function e(t, r, n, a, s, o, u, f, l, h, c) {
    o === void 0 && (o = ee.BILINEAR_SAMPLINGMODE), l === void 0 && (l = 0), h === void 0 && (h = ""), c === void 0 && (c = !1);
    var d = i.call(this, t, "kernelBlur", ["delta", "direction", "cameraMinMaxZ"], ["circleOfConfusionSampler"], a, s, o, u, f, null, l, "kernelBlur", { varyingCount: 0, depCount: 0 }, !0) || this;
    return d._blockCompilation = c, d._packedFloat = !1, d._staticDefines = "", d._staticDefines = h, d.direction = r, d.onApplyObservable.add(function(p) {
      d._outputTexture ? p.setFloat2("delta", 1 / d._outputTexture.width * d.direction.x, 1 / d._outputTexture.height * d.direction.y) : p.setFloat2("delta", 1 / d.width * d.direction.x, 1 / d.height * d.direction.y);
    }), d.kernel = n, d;
  }
  return Object.defineProperty(e.prototype, "kernel", {
    get: function() {
      return this._idealKernel;
    },
    set: function(t) {
      this._idealKernel !== t && (t = Math.max(t, 1), this._idealKernel = t, this._kernel = this._nearestBestKernel(t), this._blockCompilation || this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "packedFloat", {
    get: function() {
      return this._packedFloat;
    },
    set: function(t) {
      this._packedFloat !== t && (this._packedFloat = t, this._blockCompilation || this._updateParameters());
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getClassName = function() {
    return "BlurPostProcess";
  }, e.prototype.updateEffect = function(t, r, n, a, s, o) {
    this._updateParameters(s, o);
  }, e.prototype._updateParameters = function(t, r) {
    for (var n = this._kernel, a = (n - 1) / 2, s = [], o = [], u = 0, f = 0; f < n; f++) {
      var l = f / (n - 1), h = this._gaussianWeight(l * 2 - 1);
      s[f] = f - a, o[f] = h, u += h;
    }
    for (var f = 0; f < o.length; f++)
      o[f] /= u;
    for (var c = [], d = [], p = [], f = 0; f <= a; f += 2) {
      var g = Math.min(f + 1, Math.floor(a)), _ = f === g;
      if (_)
        p.push({ o: s[f], w: o[f] });
      else {
        var v = g === a, y = o[f] + o[g] * (v ? 0.5 : 1), E = s[f] + 1 / (1 + o[f] / o[g]);
        E === 0 ? (p.push({ o: s[f], w: o[f] }), p.push({ o: s[f + 1], w: o[f + 1] })) : (p.push({ o: E, w: y }), p.push({ o: -E, w: y }));
      }
    }
    for (var f = 0; f < p.length; f++)
      d[f] = p[f].o, c[f] = p[f].w;
    s = d, o = c;
    var R = this.getEngine().getCaps().maxVaryingVectors, M = Math.max(R, 0) - 1, C = Math.min(s.length, M), A = "";
    A += this._staticDefines, this._staticDefines.indexOf("DOF") != -1 && (A += "#define CENTER_WEIGHT ".concat(this._glslFloat(o[C - 1]), `\r
`), C--);
    for (var f = 0; f < C; f++)
      A += "#define KERNEL_OFFSET".concat(f, " ").concat(this._glslFloat(s[f]), `\r
`), A += "#define KERNEL_WEIGHT".concat(f, " ").concat(this._glslFloat(o[f]), `\r
`);
    for (var S = 0, f = M; f < s.length; f++)
      A += "#define KERNEL_DEP_OFFSET".concat(S, " ").concat(this._glslFloat(s[f]), `\r
`), A += "#define KERNEL_DEP_WEIGHT".concat(S, " ").concat(this._glslFloat(o[f]), `\r
`), S++;
    this.packedFloat && (A += "#define PACKEDFLOAT 1"), this._blockCompilation = !1, i.prototype.updateEffect.call(this, A, null, null, {
      varyingCount: C,
      depCount: S
    }, t, r);
  }, e.prototype._nearestBestKernel = function(t) {
    for (var r = Math.round(t), n = 0, a = [r, r - 1, r + 1, r - 2, r + 2]; n < a.length; n++) {
      var s = a[n];
      if (s % 2 !== 0 && Math.floor(s / 2) % 2 === 0 && s > 0)
        return Math.max(s, 3);
    }
    return Math.max(r, 3);
  }, e.prototype._gaussianWeight = function(t) {
    var r = 0.3333333333333333, n = Math.sqrt(2 * Math.PI) * r, a = -(t * t / (2 * r * r)), s = 1 / n * Math.exp(a);
    return s;
  }, e.prototype._glslFloat = function(t, r) {
    return r === void 0 && (r = 8), t.toFixed(r).replace(/0+$/, "");
  }, e._Parse = function(t, r, n, a) {
    return $.Parse(function() {
      return new e(t.name, t.direction, t.kernel, t.options, r, t.renderTargetSamplingMode, n.getEngine(), t.reusable, t.textureType, void 0, !1);
    }, t, n, a);
  }, T([
    P("kernel")
  ], e.prototype, "_kernel", void 0), T([
    P("packedFloat")
  ], e.prototype, "_packedFloat", void 0), T([
    ia()
  ], e.prototype, "direction", void 0), e;
}(tr);
Ne("BABYLON.BlurPostProcess", ui);
var yi = function() {
  function i() {
    this._defines = {}, this._currentRank = 32, this._maxRank = -1, this._mesh = null;
  }
  return i.prototype.unBindMesh = function() {
    this._mesh = null;
  }, i.prototype.addFallback = function(e, t) {
    this._defines[e] || (e < this._currentRank && (this._currentRank = e), e > this._maxRank && (this._maxRank = e), this._defines[e] = new Array()), this._defines[e].push(t);
  }, i.prototype.addCPUSkinningFallback = function(e, t) {
    this._mesh = t, e < this._currentRank && (this._currentRank = e), e > this._maxRank && (this._maxRank = e);
  }, Object.defineProperty(i.prototype, "hasMoreFallbacks", {
    get: function() {
      return this._currentRank <= this._maxRank;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.reduce = function(e, t) {
    if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {
      this._mesh.computeBonesUsingShaders = !1, e = e.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0"), t._bonesComputationForcedToCPU = !0;
      for (var r = this._mesh.getScene(), n = 0; n < r.meshes.length; n++) {
        var a = r.meshes[n];
        if (!a.material) {
          !this._mesh.material && a.computeBonesUsingShaders && a.numBoneInfluencers > 0 && (a.computeBonesUsingShaders = !1);
          continue;
        }
        if (!(!a.computeBonesUsingShaders || a.numBoneInfluencers === 0)) {
          if (a.material.getEffect() === t)
            a.computeBonesUsingShaders = !1;
          else if (a.subMeshes)
            for (var s = 0, o = a.subMeshes; s < o.length; s++) {
              var u = o[s], f = u.effect;
              if (f === t) {
                a.computeBonesUsingShaders = !1;
                break;
              }
            }
        }
      }
    } else {
      var l = this._defines[this._currentRank];
      if (l)
        for (var n = 0; n < l.length; n++)
          e = e.replace("#define " + l[n], "");
      this._currentRank++;
    }
    return e;
  }, i;
}(), as = "bayerDitherFunctions", ss = `float bayerDither2(vec2 _P) {
return mod(2.0*_P.y+_P.x+1.0,4.0);
}
float bayerDither4(vec2 _P) {
vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5*mod(_P,4.0)); 
return 4.0*bayerDither2(P1)+bayerDither2(P2);
}
float bayerDither8(vec2 _P) {
vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5 *mod(_P,4.0)); 
vec2 P4=floor(0.25*mod(_P,8.0)); 
return 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);
}
`;
L.IncludesShadersStore[as] = ss;
var os = "shadowMapFragmentExtraDeclaration", us = `#if SM_FLOAT==0
#include<packingFunctions>
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#include<bayerDitherFunctions>
uniform float softTransparentShadowSM;
#endif
varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
uniform vec3 lightDataSM;
varying vec3 vPositionWSM;
#endif
uniform vec3 biasAndScaleSM;
uniform vec2 depthValuesSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;
L.IncludesShadersStore[os] = us;
var fs = "clipPlaneFragmentDeclaration", ls = `#ifdef CLIPPLANE
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
varying float fClipDistance6;
#endif
`;
L.IncludesShadersStore[fs] = ls;
var hs = "clipPlaneFragment", cs = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fClipDistance>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE2
else if (fClipDistance2>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE3
else if (fClipDistance3>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE4
else if (fClipDistance4>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE5
else if (fClipDistance5>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE6
else if (fClipDistance6>0.0)
{
discard;
}
#endif
`;
L.IncludesShadersStore[hs] = cs;
var ds = "shadowMapFragment", ps = `float depthSM=vDepthMetricSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
#if SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
depthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
depthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_FragDepth=clamp(1.0-depthSM,0.0,1.0);
#else
gl_FragDepth=clamp(depthSM,0.0,1.0); 
#endif
#elif SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#if SM_ESM==1
depthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);
#endif
#if SM_FLOAT==1
gl_FragColor=vec4(depthSM,1.0,1.0,1.0);
#else
gl_FragColor=pack(depthSM);
#endif
return;`;
L.IncludesShadersStore[ds] = ps;
var _s = "shadowMapPixelShader", gs = `#include<shadowMapFragmentExtraDeclaration>
#ifdef ALPHATEST
varying vec2 vUV;
uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEST
float alphaFromAlphaTexture=texture2D(diffuseSampler,vUV).a;
if (alphaFromAlphaTexture<ALPHATESTVALUE)
discard;
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#ifdef ALPHATEST
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alphaFromAlphaTexture) discard;
#else
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM) discard;
#endif
#endif
#include<shadowMapFragment>
}`;
L.ShadersStore[_s] = gs;
var vs = "bonesDeclaration", ms = `#if NUM_BONE_INFLUENCERS>0
attribute vec4 matricesIndices;
attribute vec4 matricesWeights;
#if NUM_BONE_INFLUENCERS>4
attribute vec4 matricesIndicesExtra;
attribute vec4 matricesWeightsExtra;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
uniform sampler2D boneSampler;
uniform float boneTextureWidth;
#else
uniform mat4 mBones[BonesPerMesh];
#ifdef BONES_VELOCITY_ENABLED
uniform mat4 mPreviousBones[BonesPerMesh];
#endif
#endif
#ifdef BONETEXTURE
#define inline
mat4 readMatrixFromRawSampler(sampler2D smp,float index)
{
float offset=index *4.0;
float dx=1.0/boneTextureWidth;
vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));
vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));
vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));
vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));
return mat4(m0,m1,m2,m3);
}
#endif
#endif
#endif
`;
L.IncludesShadersStore[vs] = ms;
var ys = "bakedVertexAnimationDeclaration", bs = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform float bakedVertexAnimationTime;
uniform vec2 bakedVertexAnimationTextureSizeInverted;
uniform vec4 bakedVertexAnimationSettings;
uniform sampler2D bakedVertexAnimationTexture;
#ifdef INSTANCES
attribute vec4 bakedVertexAnimationSettingsInstanced;
#endif
#define inline
mat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)
{
float offset=index*4.0;
float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;
float dx=bakedVertexAnimationTextureSizeInverted.x;
vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));
vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));
vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));
vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));
return mat4(m0,m1,m2,m3);
}
#endif
`;
L.IncludesShadersStore[ys] = bs;
var Es = "morphTargetsVertexGlobalDeclaration", Ts = `#ifdef MORPHTARGETS
uniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];
#ifdef MORPHTARGETS_TEXTURE 
precision mediump sampler2DArray; 
uniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];
uniform vec3 morphTargetTextureInfo;
uniform sampler2DArray morphTargets;
vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)
{ 
float y=floor(vertexIndex/morphTargetTextureInfo.y);
float x=vertexIndex-y*morphTargetTextureInfo.y;
vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);
return texture(morphTargets,textureUV).xyz;
}
#endif
#endif
`;
L.IncludesShadersStore[Es] = Ts;
var Ss = "morphTargetsVertexDeclaration", Ms = `#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
attribute vec3 position{X};
#ifdef MORPHTARGETS_NORMAL
attribute vec3 normal{X};
#endif
#ifdef MORPHTARGETS_TANGENT
attribute vec3 tangent{X};
#endif
#ifdef MORPHTARGETS_UV
attribute vec2 uv_{X};
#endif
#endif
#endif
`;
L.IncludesShadersStore[Ss] = Ms;
var As = "helperFunctions", Rs = `const float PI=3.1415926535897932384626433832795;
const float HALF_MIN=5.96046448e-08; 
const float LinearEncodePowerApprox=2.2;
const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;
const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);
const float Epsilon=0.0000001;
#define saturate(x) clamp(x,0.0,1.0)
#define absEps(x) abs(x)+Epsilon
#define maxEps(x) max(x,Epsilon)
#define saturateEps(x) clamp(x,Epsilon,1.0)
mat3 transposeMat3(mat3 inMatrix) {
vec3 i0=inMatrix[0];
vec3 i1=inMatrix[1];
vec3 i2=inMatrix[2];
mat3 outMatrix=mat3(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);
return outMatrix;
}
mat3 inverseMat3(mat3 inMatrix) {
float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];
float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];
float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];
float b01=a22*a11-a12*a21;
float b11=-a22*a10+a12*a20;
float b21=a21*a10-a11*a20;
float det=a00*b01+a01*b11+a02*b21;
return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),
b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),
b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;
}
float toLinearSpace(float color)
{
return pow(color,LinearEncodePowerApprox);
}
vec3 toLinearSpace(vec3 color)
{
return pow(color,vec3(LinearEncodePowerApprox));
}
vec4 toLinearSpace(vec4 color)
{
return vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);
}
vec3 toGammaSpace(vec3 color)
{
return pow(color,vec3(GammaEncodePowerApprox));
}
vec4 toGammaSpace(vec4 color)
{
return vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);
}
float toGammaSpace(float color)
{
return pow(color,GammaEncodePowerApprox);
}
float square(float value)
{
return value*value;
}
vec3 square(vec3 value)
{
return value*value;
}
float pow5(float value) {
float sq=value*value;
return sq*sq*value;
}
float getLuminance(vec3 color)
{
return clamp(dot(color,LuminanceEncodeApprox),0.,1.);
}
float getRand(vec2 seed) {
return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);
}
float dither(vec2 seed,float varianceAmount) {
float rand=getRand(seed);
float dither=mix(-varianceAmount/255.0,varianceAmount/255.0,rand);
return dither;
}
const float rgbdMaxRange=255.0;
vec4 toRGBD(vec3 color) {
float maxRGB=maxEps(max(color.r,max(color.g,color.b)));
float D =max(rgbdMaxRange/maxRGB,1.);
D =clamp(floor(D)/255.0,0.,1.);
vec3 rgb=color.rgb*D;
rgb=toGammaSpace(rgb);
return vec4(clamp(rgb,0.,1.),D); 
}
vec3 fromRGBD(vec4 rgbd) {
rgbd.rgb=toLinearSpace(rgbd.rgb);
return rgbd.rgb/rgbd.a;
}
vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {
vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;
vec3 halfSize=cubeSize*0.5;
vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;
vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;
vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);
float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);
vec3 intersectPositionWS=vertexPos+origVec*distance;
return intersectPositionWS-cubePos;
}
`;
L.IncludesShadersStore[As] = Rs;
var Ps = "sceneVertexDeclaration", Cs = `uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
uniform mat4 view;
uniform mat4 projection;
uniform vec4 vEyePosition;
`;
L.IncludesShadersStore[Ps] = Cs;
var xs = "meshVertexDeclaration", Ds = `uniform mat4 world;
uniform float visibility;
`;
L.IncludesShadersStore[xs] = Ds;
var Is = "shadowMapVertexDeclaration", Os = `#include<sceneVertexDeclaration>
#include<meshVertexDeclaration>
`;
L.IncludesShadersStore[Is] = Os;
var Fs = "sceneUboDeclaration", ws = `layout(std140,column_major) uniform;
uniform Scene {
mat4 viewProjection;
#ifdef MULTIVIEW
mat4 viewProjectionR;
#endif 
mat4 view;
mat4 projection;
vec4 vEyePosition;
};
`;
L.IncludesShadersStore[Fs] = ws;
var Ls = "meshUboDeclaration", Ns = `#ifdef WEBGL2
uniform mat4 world;
uniform float visibility;
#else
layout(std140,column_major) uniform;
uniform Mesh
{
mat4 world;
float visibility;
};
#endif
#define WORLD_UBO
`;
L.IncludesShadersStore[Ls] = Ns;
var Bs = "shadowMapUboDeclaration", Us = `layout(std140,column_major) uniform;
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
L.IncludesShadersStore[Bs] = Us;
var Vs = "shadowMapVertexExtraDeclaration", ks = `#if SM_NORMALBIAS==1
uniform vec3 lightDataSM;
#endif
uniform vec3 biasAndScaleSM;
uniform vec2 depthValuesSM;
varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
varying vec3 vPositionWSM;
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;
L.IncludesShadersStore[Vs] = ks;
var Ws = "clipPlaneVertexDeclaration", zs = `#ifdef CLIPPLANE
uniform vec4 vClipPlane;
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;
varying float fClipDistance6;
#endif
`;
L.IncludesShadersStore[Ws] = zs;
var Gs = "morphTargetsVertexGlobal", Xs = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
float vertexID;
#endif
#endif
`;
L.IncludesShadersStore[Gs] = Xs;
var Hs = "morphTargetsVertex", js = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE 
vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;
positionUpdated+=(readVector3FromRawSampler({X},vertexID)-position)*morphTargetInfluences[{X}];
vertexID+=1.0;
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(readVector3FromRawSampler({X},vertexID) -normal)*morphTargetInfluences[{X}];
vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(readVector3FromRawSampler({X},vertexID).xy-uv)*morphTargetInfluences[{X}];
vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*morphTargetInfluences[{X}];
#endif
#else
positionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];
#endif
#endif
#endif
`;
L.IncludesShadersStore[Hs] = js;
var Ks = "instancesVertex", Ys = `#ifdef INSTANCES
mat4 finalWorld=mat4(world0,world1,world2,world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);
#endif
#ifdef THIN_INSTANCES
finalWorld=world*finalWorld;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
finalPreviousWorld=previousWorld*finalPreviousWorld;
#endif
#endif
#else
mat4 finalWorld=world;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=previousWorld;
#endif
#endif
`;
L.IncludesShadersStore[Ks] = Ys;
var Zs = "bonesVertex", qs = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
mat4 influence;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];
#endif
#else
influence=mBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=mBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=mBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=mBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;
L.IncludesShadersStore[Zs] = qs;
var Qs = "bakedVertexAnimation", $s = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
#define BVASNAME bakedVertexAnimationSettingsInstanced
#else
#define BVASNAME bakedVertexAnimationSettings
#endif
float VATStartFrame=BVASNAME.x;
float VATEndFrame=BVASNAME.y;
float VATOffsetFrame=BVASNAME.z;
float VATSpeed=BVASNAME.w;
float totalFrames=VATEndFrame-VATStartFrame+1.0;
float time=bakedVertexAnimationTime*VATSpeed/totalFrames;
float frameCorrection=time<1.0 ? 0.0 : 1.0;
float numOfFrames=totalFrames-frameCorrection;
float VATFrameNum=fract(time)*numOfFrames;
VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);
VATFrameNum=floor(VATFrameNum);
VATFrameNum+=VATStartFrame+frameCorrection;
mat4 VATInfluence;
VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;
}
#endif
`;
L.IncludesShadersStore[Qs] = $s;
var Js = "shadowMapVertexNormalBias", eo = `#if SM_NORMALBIAS==1
#if SM_DIRECTIONINLIGHTDATA==1
vec3 worldLightDirSM=normalize(-lightDataSM.xyz);
#else
vec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;
vec3 worldLightDirSM=normalize(directionToLightSM);
#endif
float ndlSM=dot(vNormalW,worldLightDirSM);
float sinNLSM=sqrt(1.0-ndlSM*ndlSM);
float normalBiasSM=biasAndScaleSM.y*sinNLSM;
worldPos.xyz-=vNormalW*normalBiasSM;
#endif
`;
L.IncludesShadersStore[Js] = eo;
var to = "shadowMapVertexMetric", ro = `#if SM_USEDISTANCE==1
vPositionWSM=worldPos.xyz;
#endif
#if SM_DEPTHTEXTURE==1
#ifdef IS_NDC_HALF_ZRANGE
#define BIASFACTOR 0.5
#else
#define BIASFACTOR 1.0
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#else
gl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#endif
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
zSM=gl_Position.z;
gl_Position.z=0.0;
#elif SM_USEDISTANCE==0
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
vDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
`;
L.IncludesShadersStore[to] = ro;
var io = "clipPlaneVertex", no = `#ifdef CLIPPLANE
fClipDistance=dot(worldPos,vClipPlane);
#endif
#ifdef CLIPPLANE2
fClipDistance2=dot(worldPos,vClipPlane2);
#endif
#ifdef CLIPPLANE3
fClipDistance3=dot(worldPos,vClipPlane3);
#endif
#ifdef CLIPPLANE4
fClipDistance4=dot(worldPos,vClipPlane4);
#endif
#ifdef CLIPPLANE5
fClipDistance5=dot(worldPos,vClipPlane5);
#endif
#ifdef CLIPPLANE6
fClipDistance6=dot(worldPos,vClipPlane6);
#endif
`;
L.IncludesShadersStore[io] = no;
var ao = "shadowMapVertexShader", so = `attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef INSTANCES
attribute vec4 world0;
attribute vec4 world1;
attribute vec4 world2;
attribute vec4 world3;
#endif
#include<helperFunctions>
#include<__decl__shadowMapVertex>
#ifdef ALPHATEST
varying vec2 vUV;
uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#include<shadowMapVertexExtraDeclaration>
#include<clipPlaneVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{
vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normWorldSM=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));
vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
vec3 vNormalW=normalize(normWorldSM*normalUpdated);
#endif
#endif
#include<shadowMapVertexNormalBias>
gl_Position=viewProjection*worldPos;
#include<shadowMapVertexMetric>
#ifdef ALPHATEST
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
#include<clipPlaneVertex>
}`;
L.ShadersStore[ao] = so;
var oo = "depthBoxBlurPixelShader", uo = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform vec2 screenSize;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
vec4 colorDepth=vec4(0.0);
for (int x=-OFFSET; x<=OFFSET; x++)
for (int y=-OFFSET; y<=OFFSET; y++)
colorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);
gl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));
}`;
L.ShadersStore[oo] = uo;
var fo = "shadowMapFragmentSoftTransparentShadow", lo = `#if SM_SOFTTRANSPARENTSHADOW==1
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alpha) discard;
#endif
`;
L.IncludesShadersStore[fo] = lo;
var Ve = function() {
  function i(e, t, r) {
    this.onBeforeShadowMapRenderObservable = new O(), this.onAfterShadowMapRenderObservable = new O(), this.onBeforeShadowMapRenderMeshObservable = new O(), this.onAfterShadowMapRenderMeshObservable = new O(), this._bias = 5e-5, this._normalBias = 0, this._blurBoxOffset = 1, this._blurScale = 2, this._blurKernel = 1, this._useKernelBlur = !1, this._filter = i.FILTER_NONE, this._filteringQuality = i.QUALITY_HIGH, this._contactHardeningLightSizeUVRatio = 0.1, this._darkness = 0, this._transparencyShadow = !1, this.enableSoftTransparentShadow = !1, this.useOpacityTextureForTransparentShadow = !1, this.frustumEdgeFalloff = 0, this.forceBackFacesOnly = !1, this._lightDirection = b.Zero(), this._viewMatrix = I.Zero(), this._projectionMatrix = I.Zero(), this._transformMatrix = I.Zero(), this._cachedPosition = new b(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cachedDirection = new b(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._currentFaceIndex = 0, this._currentFaceIndexCache = 0, this._defaultTextureMatrix = I.Identity(), this._mapSize = e, this._light = t, this._scene = t.getScene(), t._shadowGenerator = this, this.id = t.id, this._useUBO = this._scene.getEngine().supportsUniformBuffers, this._useUBO && (this._sceneUBOs = [], this._sceneUBOs.push(this._scene.createSceneUniformBuffer('Scene for Shadow Generator (light "'.concat(this._light.name, '")')))), i._SceneComponentInitialization(this._scene);
    var n = this._scene.getEngine().getCaps();
    r ? n.textureFloatRender && n.textureFloatLinearFiltering ? this._textureType = 1 : n.textureHalfFloatRender && n.textureHalfFloatLinearFiltering ? this._textureType = 2 : this._textureType = 0 : n.textureHalfFloatRender && n.textureHalfFloatLinearFiltering ? this._textureType = 2 : n.textureFloatRender && n.textureFloatLinearFiltering ? this._textureType = 1 : this._textureType = 0, this._initializeGenerator(), this._applyFilterValues();
  }
  return Object.defineProperty(i.prototype, "bias", {
    get: function() {
      return this._bias;
    },
    set: function(e) {
      this._bias = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "normalBias", {
    get: function() {
      return this._normalBias;
    },
    set: function(e) {
      this._normalBias = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "blurBoxOffset", {
    get: function() {
      return this._blurBoxOffset;
    },
    set: function(e) {
      this._blurBoxOffset !== e && (this._blurBoxOffset = e, this._disposeBlurPostProcesses());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "blurScale", {
    get: function() {
      return this._blurScale;
    },
    set: function(e) {
      this._blurScale !== e && (this._blurScale = e, this._disposeBlurPostProcesses());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "blurKernel", {
    get: function() {
      return this._blurKernel;
    },
    set: function(e) {
      this._blurKernel !== e && (this._blurKernel = e, this._disposeBlurPostProcesses());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "useKernelBlur", {
    get: function() {
      return this._useKernelBlur;
    },
    set: function(e) {
      this._useKernelBlur !== e && (this._useKernelBlur = e, this._disposeBlurPostProcesses());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "depthScale", {
    get: function() {
      return this._depthScale !== void 0 ? this._depthScale : this._light.getDepthScale();
    },
    set: function(e) {
      this._depthScale = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._validateFilter = function(e) {
    return e;
  }, Object.defineProperty(i.prototype, "filter", {
    get: function() {
      return this._filter;
    },
    set: function(e) {
      if (e = this._validateFilter(e), this._light.needCube()) {
        if (e === i.FILTER_BLUREXPONENTIALSHADOWMAP) {
          this.useExponentialShadowMap = !0;
          return;
        } else if (e === i.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
          this.useCloseExponentialShadowMap = !0;
          return;
        } else if (e === i.FILTER_PCF || e === i.FILTER_PCSS) {
          this.usePoissonSampling = !0;
          return;
        }
      }
      if ((e === i.FILTER_PCF || e === i.FILTER_PCSS) && !this._scene.getEngine()._features.supportShadowSamplers) {
        this.usePoissonSampling = !0;
        return;
      }
      this._filter !== e && (this._filter = e, this._disposeBlurPostProcesses(), this._applyFilterValues(), this._light._markMeshesAsLightDirty());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "usePoissonSampling", {
    get: function() {
      return this.filter === i.FILTER_POISSONSAMPLING;
    },
    set: function(e) {
      var t = this._validateFilter(i.FILTER_POISSONSAMPLING);
      !e && this.filter !== i.FILTER_POISSONSAMPLING || (this.filter = e ? t : i.FILTER_NONE);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "useExponentialShadowMap", {
    get: function() {
      return this.filter === i.FILTER_EXPONENTIALSHADOWMAP;
    },
    set: function(e) {
      var t = this._validateFilter(i.FILTER_EXPONENTIALSHADOWMAP);
      !e && this.filter !== i.FILTER_EXPONENTIALSHADOWMAP || (this.filter = e ? t : i.FILTER_NONE);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "useBlurExponentialShadowMap", {
    get: function() {
      return this.filter === i.FILTER_BLUREXPONENTIALSHADOWMAP;
    },
    set: function(e) {
      var t = this._validateFilter(i.FILTER_BLUREXPONENTIALSHADOWMAP);
      !e && this.filter !== i.FILTER_BLUREXPONENTIALSHADOWMAP || (this.filter = e ? t : i.FILTER_NONE);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "useCloseExponentialShadowMap", {
    get: function() {
      return this.filter === i.FILTER_CLOSEEXPONENTIALSHADOWMAP;
    },
    set: function(e) {
      var t = this._validateFilter(i.FILTER_CLOSEEXPONENTIALSHADOWMAP);
      !e && this.filter !== i.FILTER_CLOSEEXPONENTIALSHADOWMAP || (this.filter = e ? t : i.FILTER_NONE);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "useBlurCloseExponentialShadowMap", {
    get: function() {
      return this.filter === i.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
    },
    set: function(e) {
      var t = this._validateFilter(i.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);
      !e && this.filter !== i.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP || (this.filter = e ? t : i.FILTER_NONE);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "usePercentageCloserFiltering", {
    get: function() {
      return this.filter === i.FILTER_PCF;
    },
    set: function(e) {
      var t = this._validateFilter(i.FILTER_PCF);
      !e && this.filter !== i.FILTER_PCF || (this.filter = e ? t : i.FILTER_NONE);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "filteringQuality", {
    get: function() {
      return this._filteringQuality;
    },
    set: function(e) {
      this._filteringQuality !== e && (this._filteringQuality = e, this._disposeBlurPostProcesses(), this._applyFilterValues(), this._light._markMeshesAsLightDirty());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "useContactHardeningShadow", {
    get: function() {
      return this.filter === i.FILTER_PCSS;
    },
    set: function(e) {
      var t = this._validateFilter(i.FILTER_PCSS);
      !e && this.filter !== i.FILTER_PCSS || (this.filter = e ? t : i.FILTER_NONE);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "contactHardeningLightSizeUVRatio", {
    get: function() {
      return this._contactHardeningLightSizeUVRatio;
    },
    set: function(e) {
      this._contactHardeningLightSizeUVRatio = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "darkness", {
    get: function() {
      return this._darkness;
    },
    set: function(e) {
      this.setDarkness(e);
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.getDarkness = function() {
    return this._darkness;
  }, i.prototype.setDarkness = function(e) {
    return e >= 1 ? this._darkness = 1 : e <= 0 ? this._darkness = 0 : this._darkness = e, this;
  }, Object.defineProperty(i.prototype, "transparencyShadow", {
    get: function() {
      return this._transparencyShadow;
    },
    set: function(e) {
      this.setTransparencyShadow(e);
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.setTransparencyShadow = function(e) {
    return this._transparencyShadow = e, this;
  }, i.prototype.getShadowMap = function() {
    return this._shadowMap;
  }, i.prototype.getShadowMapForRendering = function() {
    return this._shadowMap2 ? this._shadowMap2 : this._shadowMap;
  }, i.prototype.getClassName = function() {
    return i.CLASSNAME;
  }, i.prototype.addShadowCaster = function(e, t) {
    if (t === void 0 && (t = !0), !this._shadowMap)
      return this;
    if (this._shadowMap.renderList || (this._shadowMap.renderList = []), this._shadowMap.renderList.indexOf(e) === -1 && this._shadowMap.renderList.push(e), t)
      for (var r = 0, n = e.getChildMeshes(); r < n.length; r++) {
        var a = n[r];
        this._shadowMap.renderList.indexOf(a) === -1 && this._shadowMap.renderList.push(a);
      }
    return this;
  }, i.prototype.removeShadowCaster = function(e, t) {
    if (t === void 0 && (t = !0), !this._shadowMap || !this._shadowMap.renderList)
      return this;
    var r = this._shadowMap.renderList.indexOf(e);
    if (r !== -1 && this._shadowMap.renderList.splice(r, 1), t)
      for (var n = 0, a = e.getChildren(); n < a.length; n++) {
        var s = a[n];
        this.removeShadowCaster(s);
      }
    return this;
  }, i.prototype.getLight = function() {
    return this._light;
  }, Object.defineProperty(i.prototype, "mapSize", {
    get: function() {
      return this._mapSize;
    },
    set: function(e) {
      this._mapSize = e, this._light._markMeshesAsLightDirty(), this.recreateShadowMap();
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype._initializeGenerator = function() {
    this._light._markMeshesAsLightDirty(), this._initializeShadowMap();
  }, i.prototype._createTargetRenderTexture = function() {
    var e = this._scene.getEngine();
    e._features.supportDepthStencilTexture ? (this._shadowMap = new kt(this._light.name + "_shadowMap", this._mapSize, this._scene, !1, !0, this._textureType, this._light.needCube(), void 0, !1, !1), this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer ? 516 : 513, !0)) : this._shadowMap = new kt(this._light.name + "_shadowMap", this._mapSize, this._scene, !1, !0, this._textureType, this._light.needCube());
  }, i.prototype._initializeShadowMap = function() {
    var e = this;
    if (this._createTargetRenderTexture(), this._shadowMap !== null) {
      this._shadowMap.wrapU = ee.CLAMP_ADDRESSMODE, this._shadowMap.wrapV = ee.CLAMP_ADDRESSMODE, this._shadowMap.anisotropicFilteringLevel = 1, this._shadowMap.updateSamplingMode(ee.BILINEAR_SAMPLINGMODE), this._shadowMap.renderParticles = !1, this._shadowMap.ignoreCameraViewport = !0, this._storedUniqueId && (this._shadowMap.uniqueId = this._storedUniqueId), this._shadowMap.customRenderFunction = this._renderForShadowMap.bind(this), this._shadowMap.customIsReadyFunction = function() {
        return !0;
      };
      var t = this._scene.getEngine();
      this._shadowMap.onBeforeBindObservable.add(function() {
        var s;
        e._currentSceneUBO = e._scene.getSceneUniformBuffer(), (s = t._debugPushGroup) === null || s === void 0 || s.call(t, "shadow map generation for pass id ".concat(t.currentRenderPassId), 1);
      }), this._shadowMap.onBeforeRenderObservable.add(function(s) {
        e._sceneUBOs && e._scene.setSceneUniformBuffer(e._sceneUBOs[0]), e._currentFaceIndex = s, e._filter === i.FILTER_PCF && t.setColorWrite(!1), e.getTransformMatrix(), e._scene.setTransformMatrix(e._viewMatrix, e._projectionMatrix), e._useUBO && (e._scene.getSceneUniformBuffer().unbindEffect(), e._scene.finalizeSceneUbo());
      }), this._shadowMap.onAfterUnbindObservable.add(function() {
        var s, o;
        if (e._sceneUBOs && e._scene.setSceneUniformBuffer(e._currentSceneUBO), e._scene.updateTransformMatrix(), e._filter === i.FILTER_PCF && t.setColorWrite(!0), !e.useBlurExponentialShadowMap && !e.useBlurCloseExponentialShadowMap) {
          (s = t._debugPopGroup) === null || s === void 0 || s.call(t, 1);
          return;
        }
        var u = e.getShadowMapForRendering();
        u && (e._scene.postProcessManager.directRender(e._blurPostProcesses, u.renderTarget, !0), t.unBindFramebuffer(u.renderTarget, !0), (o = t._debugPopGroup) === null || o === void 0 || o.call(t, 1));
      });
      var r = new be(0, 0, 0, 0), n = new be(1, 1, 1, 1);
      this._shadowMap.onClearObservable.add(function(s) {
        e._filter === i.FILTER_PCF ? s.clear(n, !1, !0, !1) : e.useExponentialShadowMap || e.useBlurExponentialShadowMap ? s.clear(r, !0, !0, !1) : s.clear(n, !0, !0, !1);
      }), this._shadowMap.onResizeObservable.add(function(s) {
        e._storedUniqueId = e._shadowMap.uniqueId, e._mapSize = s.getRenderSize(), e._light._markMeshesAsLightDirty(), e.recreateShadowMap();
      });
      for (var a = Ar.MIN_RENDERINGGROUPS; a < Ar.MAX_RENDERINGGROUPS; a++)
        this._shadowMap.setRenderingAutoClearDepthStencil(a, !1);
    }
  }, i.prototype._initializeBlurRTTAndPostProcesses = function() {
    var e = this, t = this._scene.getEngine(), r = this._mapSize / this.blurScale;
    (!this.useKernelBlur || this.blurScale !== 1) && (this._shadowMap2 = new kt(this._light.name + "_shadowMap2", r, this._scene, !1, !0, this._textureType, void 0, void 0, !1), this._shadowMap2.wrapU = ee.CLAMP_ADDRESSMODE, this._shadowMap2.wrapV = ee.CLAMP_ADDRESSMODE, this._shadowMap2.updateSamplingMode(ee.BILINEAR_SAMPLINGMODE)), this.useKernelBlur ? (this._kernelBlurXPostprocess = new ui(this._light.name + "KernelBlurX", new Ee(1, 0), this.blurKernel, 1, null, ee.BILINEAR_SAMPLINGMODE, t, !1, this._textureType), this._kernelBlurXPostprocess.width = r, this._kernelBlurXPostprocess.height = r, this._kernelBlurXPostprocess.externalTextureSamplerBinding = !0, this._kernelBlurXPostprocess.onApplyObservable.add(function(n) {
      n.setTexture("textureSampler", e._shadowMap);
    }), this._kernelBlurYPostprocess = new ui(this._light.name + "KernelBlurY", new Ee(0, 1), this.blurKernel, 1, null, ee.BILINEAR_SAMPLINGMODE, t, !1, this._textureType), this._kernelBlurXPostprocess.autoClear = !1, this._kernelBlurYPostprocess.autoClear = !1, this._textureType === 0 && (this._kernelBlurXPostprocess.packedFloat = !0, this._kernelBlurYPostprocess.packedFloat = !0), this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess]) : (this._boxBlurPostprocess = new tr(this._light.name + "DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1, null, ee.BILINEAR_SAMPLINGMODE, t, !1, "#define OFFSET " + this._blurBoxOffset, this._textureType), this._boxBlurPostprocess.externalTextureSamplerBinding = !0, this._boxBlurPostprocess.onApplyObservable.add(function(n) {
      n.setFloat2("screenSize", r, r), n.setTexture("textureSampler", e._shadowMap);
    }), this._boxBlurPostprocess.autoClear = !1, this._blurPostProcesses = [this._boxBlurPostprocess]);
  }, i.prototype._renderForShadowMap = function(e, t, r, n) {
    var a;
    if (n.length)
      for (a = 0; a < n.length; a++)
        this._renderSubMeshForShadowMap(n.data[a]);
    for (a = 0; a < e.length; a++)
      this._renderSubMeshForShadowMap(e.data[a]);
    for (a = 0; a < t.length; a++)
      this._renderSubMeshForShadowMap(t.data[a]);
    if (this._transparencyShadow)
      for (a = 0; a < r.length; a++)
        this._renderSubMeshForShadowMap(r.data[a], !0);
    else
      for (a = 0; a < r.length; a++)
        r.data[a].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = !1;
  }, i.prototype._bindCustomEffectForRenderSubMeshForShadowMap = function(e, t, r) {
    t.setMatrix("viewProjection", this.getTransformMatrix());
  }, i.prototype._renderSubMeshForShadowMap = function(e, t) {
    var r, n;
    t === void 0 && (t = !1);
    var a = e.getRenderingMesh(), s = e.getEffectiveMesh(), o = this._scene, u = o.getEngine(), f = e.getMaterial();
    if (s._internalAbstractMeshDataInfo._isActiveIntermediate = !1, !(!f || e.verticesCount === 0 || e._renderId === o.getRenderId())) {
      var l = s._getWorldMatrixDeterminant() < 0, h = (r = a.overrideMaterialSideOrientation) !== null && r !== void 0 ? r : f.sideOrientation;
      l && (h = h === 0 ? 1 : 0);
      var c = h === 0;
      u.setState(f.backFaceCulling, void 0, void 0, c, f.cullBackFaces);
      var d = a._getInstancesRenderList(e._id, !!e.getReplacementMesh());
      if (!d.mustReturn) {
        var p = u.getCaps().instancedArrays && (d.visibleInstances[e._id] !== null && d.visibleInstances[e._id] !== void 0 || a.hasThinInstances);
        if (!(this.customAllowRendering && !this.customAllowRendering(e)))
          if (this.isReady(e, p, t)) {
            e._renderId = o.getRenderId();
            var g = f.shadowDepthWrapper, _ = (n = g == null ? void 0 : g.getEffect(e, this, u.currentRenderPassId)) !== null && n !== void 0 ? n : e._getDrawWrapper(), v = sr.GetEffect(_);
            if (u.enableEffect(_), p || a._bind(e, v, f.fillMode), this.getTransformMatrix(), v.setFloat3("biasAndScaleSM", this.bias, this.normalBias, this.depthScale), this.getLight().getTypeID() === $e.LIGHTTYPEID_DIRECTIONALLIGHT ? v.setVector3("lightDataSM", this._cachedDirection) : v.setVector3("lightDataSM", this._cachedPosition), o.activeCamera && v.setFloat2("depthValuesSM", this.getLight().getDepthMinZ(o.activeCamera), this.getLight().getDepthMinZ(o.activeCamera) + this.getLight().getDepthMaxZ(o.activeCamera)), t && this.enableSoftTransparentShadow && v.setFloat("softTransparentShadowSM", s.visibility * f.alpha), g)
              e._setMainDrawWrapperOverride(_), g.standalone ? g.baseMaterial.bindForSubMesh(s.getWorldMatrix(), a, e) : f.bindForSubMesh(s.getWorldMatrix(), a, e), e._setMainDrawWrapperOverride(null);
            else {
              if (f && this.useOpacityTextureForTransparentShadow) {
                var y = f.opacityTexture;
                y && (v.setTexture("diffuseSampler", y), v.setMatrix("diffuseMatrix", y.getTextureMatrix() || this._defaultTextureMatrix));
              } else if (f && f.needAlphaTesting()) {
                var E = f.getAlphaTestTexture();
                E && (v.setTexture("diffuseSampler", E), v.setMatrix("diffuseMatrix", E.getTextureMatrix() || this._defaultTextureMatrix));
              }
              if (a.useBones && a.computeBonesUsingShaders && a.skeleton) {
                var R = a.skeleton;
                if (R.isUsingTextureForMatrices) {
                  var M = R.getTransformMatrixTexture(a);
                  if (!M)
                    return;
                  v.setTexture("boneSampler", M), v.setFloat("boneTextureWidth", 4 * (R.bones.length + 1));
                } else
                  v.setMatrices("mBones", R.getTransformMatrices(a));
              }
              j.BindMorphTargetParameters(a, v), a.morphTargetManager && a.morphTargetManager.isUsingTextureForTargets && a.morphTargetManager._bind(v), j.BindClipPlane(v, o);
            }
            !this._useUBO && !g && this._bindCustomEffectForRenderSubMeshForShadowMap(e, v, s), j.BindSceneUniformBuffer(v, this._scene.getSceneUniformBuffer()), this._scene.getSceneUniformBuffer().bindUniformBuffer();
            var C = s.getWorldMatrix();
            p && (s.getMeshUniformBuffer().bindToEffect(v, "Mesh"), s.transferToEffect(C)), this.forceBackFacesOnly && u.setState(!0, 0, !1, !0, f.cullBackFaces), this.onBeforeShadowMapRenderMeshObservable.notifyObservers(a), this.onBeforeShadowMapRenderObservable.notifyObservers(v), a._processRendering(s, e, v, f.fillMode, d, p, function(A, S) {
              s !== a && !A ? (a.getMeshUniformBuffer().bindToEffect(v, "Mesh"), a.transferToEffect(S)) : (s.getMeshUniformBuffer().bindToEffect(v, "Mesh"), s.transferToEffect(A ? S : C));
            }), this.forceBackFacesOnly && u.setState(!0, 0, !1, !1, f.cullBackFaces), this.onAfterShadowMapRenderObservable.notifyObservers(v), this.onAfterShadowMapRenderMeshObservable.notifyObservers(a);
          } else
            this._shadowMap && this._shadowMap.resetRefreshCounter();
      }
    }
  }, i.prototype._applyFilterValues = function() {
    !this._shadowMap || (this.filter === i.FILTER_NONE || this.filter === i.FILTER_PCSS ? this._shadowMap.updateSamplingMode(ee.NEAREST_SAMPLINGMODE) : this._shadowMap.updateSamplingMode(ee.BILINEAR_SAMPLINGMODE));
  }, i.prototype.forceCompilation = function(e, t) {
    var r = this, n = Tt({ useInstances: !1 }, t), a = this.getShadowMap();
    if (!a) {
      e && e(this);
      return;
    }
    var s = a.renderList;
    if (!s) {
      e && e(this);
      return;
    }
    for (var o = new Array(), u = 0, f = s; u < f.length; u++) {
      var l = f[u];
      o.push.apply(o, l.subMeshes);
    }
    if (o.length === 0) {
      e && e(this);
      return;
    }
    var h = 0, c = function() {
      var d, p;
      if (!(!r._scene || !r._scene.getEngine())) {
        for (; r.isReady(o[h], n.useInstances, (p = (d = o[h].getMaterial()) === null || d === void 0 ? void 0 : d.needAlphaBlendingForMesh(o[h].getMesh())) !== null && p !== void 0 ? p : !1); )
          if (h++, h >= o.length) {
            e && e(r);
            return;
          }
        setTimeout(c, 16);
      }
    };
    c();
  }, i.prototype.forceCompilationAsync = function(e) {
    var t = this;
    return new Promise(function(r) {
      t.forceCompilation(function() {
        r();
      }, e);
    });
  }, i.prototype._isReadyCustomDefines = function(e, t, r) {
  }, i.prototype._prepareShadowDefines = function(e, t, r, n) {
    r.push("#define SM_FLOAT " + (this._textureType !== 0 ? "1" : "0")), r.push("#define SM_ESM " + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? "1" : "0")), r.push("#define SM_DEPTHTEXTURE " + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? "1" : "0"));
    var a = e.getMesh();
    return r.push("#define SM_NORMALBIAS " + (this.normalBias && a.isVerticesDataPresent(m.NormalKind) ? "1" : "0")), r.push("#define SM_DIRECTIONINLIGHTDATA " + (this.getLight().getTypeID() === $e.LIGHTTYPEID_DIRECTIONALLIGHT ? "1" : "0")), r.push("#define SM_USEDISTANCE " + (this._light.needCube() ? "1" : "0")), r.push("#define SM_SOFTTRANSPARENTSHADOW " + (this.enableSoftTransparentShadow && n ? "1" : "0")), this._isReadyCustomDefines(r, e, t), r;
  }, i.prototype.isReady = function(e, t, r) {
    var n, a = e.getMaterial(), s = a == null ? void 0 : a.shadowDepthWrapper, o = [];
    if (this._prepareShadowDefines(e, t, o, r), s) {
      if (!s.isReadyForSubMesh(e, o, this, t, this._scene.getEngine().currentRenderPassId))
        return !1;
    } else {
      var u = e._getDrawWrapper(void 0, !0), f = u.effect, l = u.defines, h = [m.PositionKind], c = e.getMesh();
      if (this.normalBias && c.isVerticesDataPresent(m.NormalKind) && (h.push(m.NormalKind), o.push("#define NORMAL"), c.nonUniformScaling && o.push("#define NONUNIFORMSCALING")), a && a.needAlphaTesting()) {
        var d = null;
        if (this.useOpacityTextureForTransparentShadow ? d = a.opacityTexture : d = a.getAlphaTestTexture(), d) {
          if (!d.isReady())
            return !1;
          var p = (n = a.alphaCutOff) !== null && n !== void 0 ? n : i.DEFAULT_ALPHA_CUTOFF;
          o.push("#define ALPHATEST"), o.push("#define ALPHATESTVALUE ".concat(p).concat(p % 1 === 0 ? "." : "")), c.isVerticesDataPresent(m.UVKind) && (h.push(m.UVKind), o.push("#define UV1")), c.isVerticesDataPresent(m.UV2Kind) && d.coordinatesIndex === 1 && (h.push(m.UV2Kind), o.push("#define UV2"));
        }
      }
      var g = new yi();
      if (c.useBones && c.computeBonesUsingShaders && c.skeleton) {
        h.push(m.MatricesIndicesKind), h.push(m.MatricesWeightsKind), c.numBoneInfluencers > 4 && (h.push(m.MatricesIndicesExtraKind), h.push(m.MatricesWeightsExtraKind));
        var _ = c.skeleton;
        o.push("#define NUM_BONE_INFLUENCERS " + c.numBoneInfluencers), c.numBoneInfluencers > 0 && g.addCPUSkinningFallback(0, c), _.isUsingTextureForMatrices ? o.push("#define BONETEXTURE") : o.push("#define BonesPerMesh " + (_.bones.length + 1));
      } else
        o.push("#define NUM_BONE_INFLUENCERS 0");
      var v = c.morphTargetManager, y = 0;
      v && v.numInfluencers > 0 && (o.push("#define MORPHTARGETS"), y = v.numInfluencers, o.push("#define NUM_MORPH_INFLUENCERS " + y), v.isUsingTextureForTargets && o.push("#define MORPHTARGETS_TEXTURE"), j.PrepareAttributesForMorphTargetsInfluencers(h, c, y));
      var E = this._scene;
      if (E.clipPlane && o.push("#define CLIPPLANE"), E.clipPlane2 && o.push("#define CLIPPLANE2"), E.clipPlane3 && o.push("#define CLIPPLANE3"), E.clipPlane4 && o.push("#define CLIPPLANE4"), E.clipPlane5 && o.push("#define CLIPPLANE5"), E.clipPlane6 && o.push("#define CLIPPLANE6"), t && (o.push("#define INSTANCES"), j.PushAttributesForInstances(h), e.getRenderingMesh().hasThinInstances && o.push("#define THIN_INSTANCES")), this.customShaderOptions && this.customShaderOptions.defines)
        for (var R = 0, M = this.customShaderOptions.defines; R < M.length; R++) {
          var C = M[R];
          o.indexOf(C) === -1 && o.push(C);
        }
      var A = o.join(`
`);
      if (l !== A) {
        l = A;
        var S = "shadowMap", w = [
          "world",
          "mBones",
          "viewProjection",
          "diffuseMatrix",
          "lightDataSM",
          "depthValuesSM",
          "biasAndScaleSM",
          "morphTargetInfluences",
          "boneTextureWidth",
          "vClipPlane",
          "vClipPlane2",
          "vClipPlane3",
          "vClipPlane4",
          "vClipPlane5",
          "vClipPlane6",
          "softTransparentShadowSM",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices"
        ], F = ["diffuseSampler", "boneSampler", "morphTargets"], x = ["Scene", "Mesh"];
        if (this.customShaderOptions) {
          if (S = this.customShaderOptions.shaderName, this.customShaderOptions.attributes)
            for (var z = 0, W = this.customShaderOptions.attributes; z < W.length; z++) {
              var N = W[z];
              h.indexOf(N) === -1 && h.push(N);
            }
          if (this.customShaderOptions.uniforms)
            for (var Z = 0, q = this.customShaderOptions.uniforms; Z < q.length; Z++) {
              var ae = q[Z];
              w.indexOf(ae) === -1 && w.push(ae);
            }
          if (this.customShaderOptions.samplers)
            for (var Y = 0, H = this.customShaderOptions.samplers; Y < H.length; Y++) {
              var se = H[Y];
              F.indexOf(se) === -1 && F.push(se);
            }
        }
        var Se = this._scene.getEngine();
        f = Se.createEffect(S, {
          attributes: h,
          uniformsNames: w,
          uniformBuffersNames: x,
          samplers: F,
          defines: A,
          fallbacks: g,
          onCompiled: null,
          onError: null,
          indexParameters: { maxSimultaneousMorphTargets: y }
        }, Se), u.setEffect(f, l);
      }
      if (!f.isReady())
        return !1;
    }
    return (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) && (!this._blurPostProcesses || !this._blurPostProcesses.length) && this._initializeBlurRTTAndPostProcesses(), !(this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady() || this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady() || this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady());
  }, i.prototype.prepareDefines = function(e, t) {
    var r = this._scene, n = this._light;
    !r.shadowsEnabled || !n.shadowEnabled || (e["SHADOW" + t] = !0, this.useContactHardeningShadow ? (e["SHADOWPCSS" + t] = !0, this._filteringQuality === i.QUALITY_LOW ? e["SHADOWLOWQUALITY" + t] = !0 : this._filteringQuality === i.QUALITY_MEDIUM && (e["SHADOWMEDIUMQUALITY" + t] = !0)) : this.usePercentageCloserFiltering ? (e["SHADOWPCF" + t] = !0, this._filteringQuality === i.QUALITY_LOW ? e["SHADOWLOWQUALITY" + t] = !0 : this._filteringQuality === i.QUALITY_MEDIUM && (e["SHADOWMEDIUMQUALITY" + t] = !0)) : this.usePoissonSampling ? e["SHADOWPOISSON" + t] = !0 : this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? e["SHADOWESM" + t] = !0 : (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) && (e["SHADOWCLOSEESM" + t] = !0), n.needCube() && (e["SHADOWCUBE" + t] = !0));
  }, i.prototype.bindShadowLight = function(e, t) {
    var r = this._light, n = this._scene;
    if (!(!n.shadowsEnabled || !r.shadowEnabled)) {
      var a = n.activeCamera;
      if (!!a) {
        var s = this.getShadowMap();
        !s || (r.needCube() || t.setMatrix("lightMatrix" + e, this.getTransformMatrix()), this._filter === i.FILTER_PCF ? (t.setDepthStencilTexture("shadowSampler" + e, this.getShadowMapForRendering()), r._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), s.getSize().width, 1 / s.getSize().width, this.frustumEdgeFalloff, e)) : this._filter === i.FILTER_PCSS ? (t.setDepthStencilTexture("shadowSampler" + e, this.getShadowMapForRendering()), t.setTexture("depthSampler" + e, this.getShadowMapForRendering()), r._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / s.getSize().width, this._contactHardeningLightSizeUVRatio * s.getSize().width, this.frustumEdgeFalloff, e)) : (t.setTexture("shadowSampler" + e, this.getShadowMapForRendering()), r._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), this.blurScale / s.getSize().width, this.depthScale, this.frustumEdgeFalloff, e)), r._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(a), this.getLight().getDepthMinZ(a) + this.getLight().getDepthMaxZ(a), e));
      }
    }
  }, i.prototype.getTransformMatrix = function() {
    var e = this._scene;
    if (this._currentRenderId === e.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex)
      return this._transformMatrix;
    this._currentRenderId = e.getRenderId(), this._currentFaceIndexCache = this._currentFaceIndex;
    var t = this._light.position;
    if (this._light.computeTransformedInformation() && (t = this._light.transformedPosition), b.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection), Math.abs(b.Dot(this._lightDirection, b.Up())) === 1 && (this._lightDirection.z = 1e-13), this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !t.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {
      this._cachedPosition.copyFrom(t), this._cachedDirection.copyFrom(this._lightDirection), I.LookAtLHToRef(t, t.add(this._lightDirection), b.Up(), this._viewMatrix);
      var r = this.getShadowMap();
      if (r) {
        var n = r.renderList;
        n && this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, n);
      }
      this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    }
    return this._transformMatrix;
  }, i.prototype.recreateShadowMap = function() {
    var e = this._shadowMap;
    if (!!e) {
      var t = e.renderList;
      if (this._disposeRTTandPostProcesses(), this._initializeGenerator(), this.filter = this._filter, this._applyFilterValues(), t) {
        this._shadowMap.renderList || (this._shadowMap.renderList = []);
        for (var r = 0, n = t; r < n.length; r++) {
          var a = n[r];
          this._shadowMap.renderList.push(a);
        }
      } else
        this._shadowMap.renderList = null;
    }
  }, i.prototype._disposeBlurPostProcesses = function() {
    this._shadowMap2 && (this._shadowMap2.dispose(), this._shadowMap2 = null), this._boxBlurPostprocess && (this._boxBlurPostprocess.dispose(), this._boxBlurPostprocess = null), this._kernelBlurXPostprocess && (this._kernelBlurXPostprocess.dispose(), this._kernelBlurXPostprocess = null), this._kernelBlurYPostprocess && (this._kernelBlurYPostprocess.dispose(), this._kernelBlurYPostprocess = null), this._blurPostProcesses = [];
  }, i.prototype._disposeRTTandPostProcesses = function() {
    this._shadowMap && (this._shadowMap.dispose(), this._shadowMap = null), this._disposeBlurPostProcesses();
  }, i.prototype._disposeSceneUBOs = function() {
    if (this._sceneUBOs) {
      for (var e = 0, t = this._sceneUBOs; e < t.length; e++) {
        var r = t[e];
        r.dispose();
      }
      this._sceneUBOs = [];
    }
  }, i.prototype.dispose = function() {
    this._disposeRTTandPostProcesses(), this._disposeSceneUBOs(), this._light && (this._light._shadowGenerator = null, this._light._markMeshesAsLightDirty()), this.onBeforeShadowMapRenderMeshObservable.clear(), this.onBeforeShadowMapRenderObservable.clear(), this.onAfterShadowMapRenderMeshObservable.clear(), this.onAfterShadowMapRenderObservable.clear();
  }, i.prototype.serialize = function() {
    var e = {}, t = this.getShadowMap();
    if (!t)
      return e;
    if (e.className = this.getClassName(), e.lightId = this._light.id, e.id = this.id, e.mapSize = t.getRenderSize(), e.forceBackFacesOnly = this.forceBackFacesOnly, e.darkness = this.getDarkness(), e.transparencyShadow = this._transparencyShadow, e.frustumEdgeFalloff = this.frustumEdgeFalloff, e.bias = this.bias, e.normalBias = this.normalBias, e.usePercentageCloserFiltering = this.usePercentageCloserFiltering, e.useContactHardeningShadow = this.useContactHardeningShadow, e.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio, e.filteringQuality = this.filteringQuality, e.useExponentialShadowMap = this.useExponentialShadowMap, e.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap, e.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap, e.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap, e.usePoissonSampling = this.usePoissonSampling, e.depthScale = this.depthScale, e.blurBoxOffset = this.blurBoxOffset, e.blurKernel = this.blurKernel, e.blurScale = this.blurScale, e.useKernelBlur = this.useKernelBlur, e.renderList = [], t.renderList)
      for (var r = 0; r < t.renderList.length; r++) {
        var n = t.renderList[r];
        e.renderList.push(n.id);
      }
    return e;
  }, i.Parse = function(e, t, r) {
    for (var n = t.getLightById(e.lightId), a = r ? r(e.mapSize, n) : new i(e.mapSize, n), s = a.getShadowMap(), o = 0; o < e.renderList.length; o++) {
      var u = t.getMeshesById(e.renderList[o]);
      u.forEach(function(f) {
        !s || (s.renderList || (s.renderList = []), s.renderList.push(f));
      });
    }
    return e.id !== void 0 && (a.id = e.id), a.forceBackFacesOnly = !!e.forceBackFacesOnly, e.darkness !== void 0 && a.setDarkness(e.darkness), e.transparencyShadow && a.setTransparencyShadow(!0), e.frustumEdgeFalloff !== void 0 && (a.frustumEdgeFalloff = e.frustumEdgeFalloff), e.bias !== void 0 && (a.bias = e.bias), e.normalBias !== void 0 && (a.normalBias = e.normalBias), e.usePercentageCloserFiltering ? a.usePercentageCloserFiltering = !0 : e.useContactHardeningShadow ? a.useContactHardeningShadow = !0 : e.usePoissonSampling ? a.usePoissonSampling = !0 : e.useExponentialShadowMap ? a.useExponentialShadowMap = !0 : e.useBlurExponentialShadowMap ? a.useBlurExponentialShadowMap = !0 : e.useCloseExponentialShadowMap ? a.useCloseExponentialShadowMap = !0 : e.useBlurCloseExponentialShadowMap ? a.useBlurCloseExponentialShadowMap = !0 : e.useVarianceShadowMap ? a.useExponentialShadowMap = !0 : e.useBlurVarianceShadowMap && (a.useBlurExponentialShadowMap = !0), e.contactHardeningLightSizeUVRatio !== void 0 && (a.contactHardeningLightSizeUVRatio = e.contactHardeningLightSizeUVRatio), e.filteringQuality !== void 0 && (a.filteringQuality = e.filteringQuality), e.depthScale && (a.depthScale = e.depthScale), e.blurScale && (a.blurScale = e.blurScale), e.blurBoxOffset && (a.blurBoxOffset = e.blurBoxOffset), e.useKernelBlur && (a.useKernelBlur = e.useKernelBlur), e.blurKernel && (a.blurKernel = e.blurKernel), a;
  }, i.CLASSNAME = "ShadowGenerator", i.FILTER_NONE = 0, i.FILTER_EXPONENTIALSHADOWMAP = 1, i.FILTER_POISSONSAMPLING = 2, i.FILTER_BLUREXPONENTIALSHADOWMAP = 3, i.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4, i.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5, i.FILTER_PCF = 6, i.FILTER_PCSS = 7, i.QUALITY_HIGH = 0, i.QUALITY_MEDIUM = 1, i.QUALITY_LOW = 2, i.DEFAULT_ALPHA_CUTOFF = 0.5, i._SceneComponentInitialization = function(e) {
    throw G("ShadowGeneratorSceneComponent");
  }, i;
}(), ho = "depthPixelShader", co = `#ifdef ALPHATEST
varying vec2 vUV;
uniform sampler2D diffuseSampler;
#endif
varying float vDepthMetric;
#ifdef PACKED
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#ifdef ALPHATEST
if (texture2D(diffuseSampler,vUV).a<0.4)
discard;
#endif
#ifdef NONLINEARDEPTH
#ifdef PACKED
gl_FragColor=pack(gl_FragCoord.z);
#else
gl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);
#endif
#else
#ifdef PACKED
gl_FragColor=pack(vDepthMetric);
#else
gl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);
#endif
#endif
}`;
L.ShadersStore[ho] = co;
var po = "instancesDeclaration", _o = `#ifdef INSTANCES
attribute vec4 world0;
attribute vec4 world1;
attribute vec4 world2;
attribute vec4 world3;
#ifdef INSTANCESCOLOR
attribute vec4 instanceColor;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
attribute vec4 previousWorld0;
attribute vec4 previousWorld1;
attribute vec4 previousWorld2;
attribute vec4 previousWorld3;
#ifdef THIN_INSTANCES
uniform mat4 previousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
uniform mat4 previousWorld;
#endif
#endif
`;
L.IncludesShadersStore[po] = _o;
var go = "depthVertexShader", vo = `attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<instancesDeclaration>
uniform mat4 viewProjection;
uniform vec2 depthValues;
#if defined(ALPHATEST) || defined(NEED_UV)
varying vec2 vUV;
uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
varying float vDepthMetric;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{
vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
gl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));
#else
vDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));
#endif
#if defined(ALPHATEST) || defined(BASIC_RENDER)
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
}
`;
L.ShadersStore[go] = vo;
var mo = function() {
  function i(e, t, r, n, a) {
    t === void 0 && (t = 1), r === void 0 && (r = null), n === void 0 && (n = !1), a === void 0 && (a = ee.TRILINEAR_SAMPLINGMODE);
    var s = this;
    this.enabled = !0, this.forceDepthWriteTransparentMeshes = !1, this.useOnlyInActiveCamera = !1, this._scene = e, this._storeNonLinearDepth = n, this.isPacked = t === 0, this.isPacked ? this._clearColor = new be(1, 1, 1, 1) : this._clearColor = new be(1, 0, 0, 1), i._SceneComponentInitialization(this._scene);
    var o = e.getEngine();
    this._camera = r, a !== ee.NEAREST_SAMPLINGMODE && (t === 1 && !o._caps.textureFloatLinearFiltering && (a = ee.NEAREST_SAMPLINGMODE), t === 2 && !o._caps.textureHalfFloatLinearFiltering && (a = ee.NEAREST_SAMPLINGMODE));
    var u = this.isPacked || !o._features.supportExtendedTextureFormats ? 5 : 6;
    this._depthMap = new kt("DepthRenderer", { width: o.getRenderWidth(), height: o.getRenderHeight() }, this._scene, !1, !0, t, !1, a, void 0, void 0, void 0, u), this._depthMap.wrapU = ee.CLAMP_ADDRESSMODE, this._depthMap.wrapV = ee.CLAMP_ADDRESSMODE, this._depthMap.refreshRate = 1, this._depthMap.renderParticles = !1, this._depthMap.renderList = null, this._depthMap.activeCamera = this._camera, this._depthMap.ignoreCameraViewport = !0, this._depthMap.useCameraPostProcesses = !1, this._depthMap.onClearObservable.add(function(l) {
      l.clear(s._clearColor, !0, !0, !0);
    }), this._depthMap.onBeforeBindObservable.add(function() {
      var l;
      (l = o._debugPushGroup) === null || l === void 0 || l.call(o, "depth renderer", 1);
    }), this._depthMap.onAfterUnbindObservable.add(function() {
      var l;
      (l = o._debugPopGroup) === null || l === void 0 || l.call(o, 1);
    }), this._depthMap.customIsReadyFunction = function(l, h) {
      if (!l.isReady(!1))
        return !1;
      if (h === 0 && l.subMeshes)
        for (var c = 0; c < l.subMeshes.length; ++c) {
          var d = l.subMeshes[c], p = d.getRenderingMesh(), g = p._getInstancesRenderList(d._id, !!d.getReplacementMesh()), _ = o.getCaps().instancedArrays && (g.visibleInstances[d._id] !== null && g.visibleInstances[d._id] !== void 0 || p.hasThinInstances);
          if (!s.isReady(d, _))
            return !1;
        }
      return !0;
    };
    var f = function(l) {
      var h, c, d = l.getRenderingMesh(), p = l.getEffectiveMesh(), g = s._scene, _ = g.getEngine(), v = l.getMaterial();
      if (p._internalAbstractMeshDataInfo._isActiveIntermediate = !1, !(!v || p.infiniteDistance || v.disableDepthWrite || l.verticesCount === 0 || l._renderId === g.getRenderId())) {
        var y = p._getWorldMatrixDeterminant() < 0, E = (h = d.overrideMaterialSideOrientation) !== null && h !== void 0 ? h : v.sideOrientation;
        y && (E = E === 0 ? 1 : 0);
        var R = E === 0;
        _.setState(v.backFaceCulling, 0, !1, R, v.cullBackFaces);
        var M = d._getInstancesRenderList(l._id, !!l.getReplacementMesh());
        if (!M.mustReturn) {
          var C = _.getCaps().instancedArrays && (M.visibleInstances[l._id] !== null && M.visibleInstances[l._id] !== void 0 || d.hasThinInstances), A = s._camera || g.activeCamera;
          if (s.isReady(l, C) && A) {
            l._renderId = g.getRenderId();
            var S = (c = p._internalAbstractMeshDataInfo._materialForRenderPass) === null || c === void 0 ? void 0 : c[_.currentRenderPassId], w = l._getDrawWrapper();
            !w && S && (w = S._getDrawWrapper());
            var F = A.mode === De.ORTHOGRAPHIC_CAMERA;
            if (!w)
              return;
            var x = w.effect;
            _.enableEffect(w), C || d._bind(l, x, v.fillMode), S ? S.bindForSubMesh(p.getWorldMatrix(), p, l) : (x.setMatrix("viewProjection", g.getTransformMatrix()), x.setMatrix("world", p.getWorldMatrix()));
            var z = void 0, W = void 0;
            if (F ? (z = !_.useReverseDepthBuffer && _.isNDCHalfZRange ? 0 : 1, W = _.useReverseDepthBuffer && _.isNDCHalfZRange ? 0 : 1) : (z = _.useReverseDepthBuffer && _.isNDCHalfZRange ? A.minZ : _.isNDCHalfZRange ? 0 : A.minZ, W = _.useReverseDepthBuffer && _.isNDCHalfZRange ? 0 : A.maxZ), x.setFloat2("depthValues", z, z + W), !S) {
              if (v && v.needAlphaTesting()) {
                var N = v.getAlphaTestTexture();
                N && (x.setTexture("diffuseSampler", N), x.setMatrix("diffuseMatrix", N.getTextureMatrix()));
              }
              if (d.useBones && d.computeBonesUsingShaders && d.skeleton) {
                var Z = d.skeleton;
                if (Z.isUsingTextureForMatrices) {
                  var q = Z.getTransformMatrixTexture(d);
                  if (!q)
                    return;
                  x.setTexture("boneSampler", q), x.setFloat("boneTextureWidth", 4 * (Z.bones.length + 1));
                } else
                  x.setMatrices("mBones", Z.getTransformMatrices(d));
              }
              j.BindMorphTargetParameters(d, x), d.morphTargetManager && d.morphTargetManager.isUsingTextureForTargets && d.morphTargetManager._bind(x);
            }
            d._processRendering(p, l, x, v.fillMode, M, C, function(ae, Y) {
              return x.setMatrix("world", Y);
            });
          }
        }
      }
    };
    this._depthMap.customRenderFunction = function(l, h, c, d) {
      var p;
      if (d.length)
        for (p = 0; p < d.length; p++)
          f(d.data[p]);
      for (p = 0; p < l.length; p++)
        f(l.data[p]);
      for (p = 0; p < h.length; p++)
        f(h.data[p]);
      if (s.forceDepthWriteTransparentMeshes)
        for (p = 0; p < c.length; p++)
          f(c.data[p]);
      else
        for (p = 0; p < c.length; p++)
          c.data[p].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = !1;
    };
  }
  return i.prototype.setMaterialForRendering = function(e, t) {
    this._depthMap.setMaterialForRendering(e, t);
  }, i.prototype.isReady = function(e, t) {
    var r, n = this._scene.getEngine(), a = e.getMesh(), s = (r = a._internalAbstractMeshDataInfo._materialForRenderPass) === null || r === void 0 ? void 0 : r[n.currentRenderPassId];
    if (s)
      return s.isReadyForSubMesh(a, e, t);
    var o = e.getMaterial();
    if (!o || o.disableDepthWrite)
      return !1;
    var u = [], f = [m.PositionKind];
    if (o && o.needAlphaTesting() && o.getAlphaTestTexture() && (u.push("#define ALPHATEST"), a.isVerticesDataPresent(m.UVKind) && (f.push(m.UVKind), u.push("#define UV1")), a.isVerticesDataPresent(m.UV2Kind) && (f.push(m.UV2Kind), u.push("#define UV2"))), a.useBones && a.computeBonesUsingShaders) {
      f.push(m.MatricesIndicesKind), f.push(m.MatricesWeightsKind), a.numBoneInfluencers > 4 && (f.push(m.MatricesIndicesExtraKind), f.push(m.MatricesWeightsExtraKind)), u.push("#define NUM_BONE_INFLUENCERS " + a.numBoneInfluencers), u.push("#define BonesPerMesh " + (a.skeleton ? a.skeleton.bones.length + 1 : 0));
      var l = e.getRenderingMesh().skeleton;
      l != null && l.isUsingTextureForMatrices && u.push("#define BONETEXTURE");
    } else
      u.push("#define NUM_BONE_INFLUENCERS 0");
    var h = a.morphTargetManager, c = 0;
    h && h.numInfluencers > 0 && (c = h.numInfluencers, u.push("#define MORPHTARGETS"), u.push("#define NUM_MORPH_INFLUENCERS " + c), h.isUsingTextureForTargets && u.push("#define MORPHTARGETS_TEXTURE"), j.PrepareAttributesForMorphTargetsInfluencers(f, a, c)), t && (u.push("#define INSTANCES"), j.PushAttributesForInstances(f), e.getRenderingMesh().hasThinInstances && u.push("#define THIN_INSTANCES")), this._storeNonLinearDepth && u.push("#define NONLINEARDEPTH"), this.isPacked && u.push("#define PACKED");
    var d = e._getDrawWrapper(void 0, !0), p = d.defines, g = u.join(`
`);
    return p !== g && d.setEffect(n.createEffect("depth", f, [
      "world",
      "mBones",
      "boneTextureWidth",
      "viewProjection",
      "diffuseMatrix",
      "depthValues",
      "morphTargetInfluences",
      "morphTargetTextureInfo",
      "morphTargetTextureIndices"
    ], ["diffuseSampler", "morphTargets", "boneSampler"], g, void 0, void 0, void 0, { maxSimultaneousMorphTargets: c }), g), d.effect.isReady();
  }, i.prototype.getDepthMap = function() {
    return this._depthMap;
  }, i.prototype.dispose = function() {
    var e = [];
    for (var t in this._scene._depthRenderer) {
      var r = this._scene._depthRenderer[t];
      r === this && e.push(t);
    }
    if (e.length > 0) {
      this._depthMap.dispose();
      for (var n = 0, a = e; n < a.length; n++) {
        var t = a[n];
        delete this._scene._depthRenderer[t];
      }
    }
  }, i._SceneComponentInitialization = function(e) {
    throw G("DepthRendererSceneComponent");
  }, i;
}(), yo = "minmaxReduxPixelShader", bo = `varying vec2 vUV;
uniform sampler2D textureSampler;
#if defined(INITIAL)
uniform sampler2D sourceTexture;
uniform vec2 texSize;
void main(void)
{
ivec2 coord=ivec2(vUV*(texSize-1.0));
float f1=texelFetch(sourceTexture,coord,0).r;
float f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;
float f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;
float f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;
float minz=min(min(min(f1,f2),f3),f4);
#ifdef DEPTH_REDUX
float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);
#else
float maxz=max(max(max(f1,f2),f3),f4);
#endif
glFragColor=vec4(minz,maxz,0.,0.);
}
#elif defined(MAIN)
uniform vec2 texSize;
void main(void)
{
ivec2 coord=ivec2(vUV*(texSize-1.0));
vec2 f1=texelFetch(textureSampler,coord,0).rg;
vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;
vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;
vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;
float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);
float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);
glFragColor=vec4(minz,maxz,0.,0.);
}
#elif defined(ONEBEFORELAST)
uniform ivec2 texSize;
void main(void)
{
ivec2 coord=ivec2(vUV*vec2(texSize-1));
vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;
vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;
vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;
vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;
float minz=min(f1.x,f2.x);
float maxz=max(f1.y,f2.y);
glFragColor=vec4(minz,maxz,0.,0.);
}
#elif defined(LAST)
void main(void)
{
glFragColor=vec4(0.);
if (true) { 
discard;
}
}
#endif
`;
L.ShadersStore[yo] = bo;
var Eo = function() {
  function i(e) {
    var t = this;
    this.onAfterReductionPerformed = new O(), this._forceFullscreenViewport = !0, this._activated = !1, this._camera = e, this._postProcessManager = new Mr(e.getScene()), this._onContextRestoredObserver = e.getEngine().onContextRestoredObservable.add(function() {
      t._postProcessManager._rebuild();
    });
  }
  return Object.defineProperty(i.prototype, "sourceTexture", {
    get: function() {
      return this._sourceTexture;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.setSourceTexture = function(e, t, r, n) {
    var a = this;
    if (r === void 0 && (r = 2), n === void 0 && (n = !0), e !== this._sourceTexture) {
      this.dispose(!1), this._sourceTexture = e, this._reductionSteps = [], this._forceFullscreenViewport = n;
      var s = this._camera.getScene(), o = new tr(
        "Initial reduction phase",
        "minmaxRedux",
        ["texSize"],
        ["sourceTexture"],
        1,
        null,
        1,
        s.getEngine(),
        !1,
        "#define INITIAL" + (t ? `
#define DEPTH_REDUX` : ""),
        r,
        void 0,
        void 0,
        void 0,
        7
      );
      o.autoClear = !1, o.forceFullscreenViewport = n;
      var u = this._sourceTexture.getRenderWidth(), f = this._sourceTexture.getRenderHeight();
      o.onApply = function(d, p) {
        return function(g) {
          g.setTexture("sourceTexture", a._sourceTexture), g.setFloat2("texSize", d, p);
        };
      }(u, f), this._reductionSteps.push(o);
      for (var l = 1; u > 1 || f > 1; ) {
        u = Math.max(Math.round(u / 2), 1), f = Math.max(Math.round(f / 2), 1);
        var h = new tr(
          "Reduction phase " + l,
          "minmaxRedux",
          ["texSize"],
          null,
          { width: u, height: f },
          null,
          1,
          s.getEngine(),
          !1,
          "#define " + (u == 1 && f == 1 ? "LAST" : u == 1 || f == 1 ? "ONEBEFORELAST" : "MAIN"),
          r,
          void 0,
          void 0,
          void 0,
          7
        );
        if (h.autoClear = !1, h.forceFullscreenViewport = n, h.onApply = function(d, p) {
          return function(g) {
            d == 1 || p == 1 ? g.setInt2("texSize", d, p) : g.setFloat2("texSize", d, p);
          };
        }(u, f), this._reductionSteps.push(h), l++, u == 1 && f == 1) {
          var c = function(d, p, g) {
            var _ = new Float32Array(4 * d * p), v = { min: 0, max: 0 };
            return function() {
              s.getEngine()._readTexturePixels(g.inputTexture.texture, d, p, -1, 0, _, !1), v.min = _[0], v.max = _[1], a.onAfterReductionPerformed.notifyObservers(v);
            };
          };
          h.onAfterRenderObservable.add(c(u, f, h));
        }
      }
    }
  }, Object.defineProperty(i.prototype, "refreshRate", {
    get: function() {
      return this._sourceTexture ? this._sourceTexture.refreshRate : -1;
    },
    set: function(e) {
      this._sourceTexture && (this._sourceTexture.refreshRate = e);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i.prototype, "activated", {
    get: function() {
      return this._activated;
    },
    enumerable: !1,
    configurable: !0
  }), i.prototype.activate = function() {
    var e = this;
    this._onAfterUnbindObserver || !this._sourceTexture || (this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(function() {
      var t, r, n = e._camera.getScene().getEngine();
      (t = n._debugPushGroup) === null || t === void 0 || t.call(n, "min max reduction", 1), e._reductionSteps[0].activate(e._camera), e._postProcessManager.directRender(e._reductionSteps, e._reductionSteps[0].inputTexture, e._forceFullscreenViewport), n.unBindFramebuffer(e._reductionSteps[0].inputTexture, !1), (r = n._debugPopGroup) === null || r === void 0 || r.call(n, 1);
    }), this._activated = !0);
  }, i.prototype.deactivate = function() {
    !this._onAfterUnbindObserver || !this._sourceTexture || (this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver), this._onAfterUnbindObserver = null, this._activated = !1);
  }, i.prototype.dispose = function(e) {
    if (e === void 0 && (e = !0), e && (this.onAfterReductionPerformed.clear(), this._onContextRestoredObserver && (this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver), this._onContextRestoredObserver = null)), this.deactivate(), this._reductionSteps) {
      for (var t = 0; t < this._reductionSteps.length; ++t)
        this._reductionSteps[t].dispose();
      this._reductionSteps = null;
    }
    this._postProcessManager && e && this._postProcessManager.dispose(), this._sourceTexture = null;
  }, i;
}(), To = function(i) {
  K(e, i);
  function e(t) {
    return i.call(this, t) || this;
  }
  return Object.defineProperty(e.prototype, "depthRenderer", {
    get: function() {
      return this._depthRenderer;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.setDepthRenderer = function(t, r, n) {
    t === void 0 && (t = null), r === void 0 && (r = 2), n === void 0 && (n = !0);
    var a = this._camera.getScene();
    this._depthRenderer && (delete a._depthRenderer[this._depthRendererId], this._depthRenderer.dispose(), this._depthRenderer = null), t === null && (a._depthRenderer || (a._depthRenderer = {}), t = this._depthRenderer = new mo(a, r, this._camera, !1, 1), t.enabled = !1, this._depthRendererId = "minmax" + this._camera.id, a._depthRenderer[this._depthRendererId] = t), i.prototype.setSourceTexture.call(this, t.getDepthMap(), !0, r, n);
  }, e.prototype.setSourceTexture = function(t, r, n, a) {
    n === void 0 && (n = 2), a === void 0 && (a = !0), i.prototype.setSourceTexture.call(this, t, r, n, a);
  }, e.prototype.activate = function() {
    this._depthRenderer && (this._depthRenderer.enabled = !0), i.prototype.activate.call(this);
  }, e.prototype.deactivate = function() {
    i.prototype.deactivate.call(this), this._depthRenderer && (this._depthRenderer.enabled = !1);
  }, e.prototype.dispose = function(t) {
    if (t === void 0 && (t = !0), i.prototype.dispose.call(this, t), this._depthRenderer && t) {
      var r = this._depthRenderer.getDepthMap().getScene();
      r && delete r._depthRenderer[this._depthRendererId], this._depthRenderer.dispose(), this._depthRenderer = null;
    }
  }, e;
}(Eo), Ki = b.Up(), So = b.Zero(), pe = new b(), Ot = new b(), pr = new I(), Yi = function(i) {
  K(e, i);
  function e(t, r, n) {
    var a = this;
    return e.IsSupported ? (a = i.call(this, t, r, n) || this, a.usePercentageCloserFiltering = !0, a) : (k.Error("CascadedShadowMap is not supported by the current engine."), a);
  }
  return e.prototype._validateFilter = function(t) {
    return t === Ve.FILTER_NONE || t === Ve.FILTER_PCF || t === Ve.FILTER_PCSS ? t : (console.error('Unsupported filter "' + t + '"!'), Ve.FILTER_NONE);
  }, Object.defineProperty(e.prototype, "numCascades", {
    get: function() {
      return this._numCascades;
    },
    set: function(t) {
      t = Math.min(Math.max(t, e.MIN_CASCADES_COUNT), e.MAX_CASCADES_COUNT), t !== this._numCascades && (this._numCascades = t, this.recreateShadowMap(), this._recreateSceneUBOs());
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "freezeShadowCastersBoundingInfo", {
    get: function() {
      return this._freezeShadowCastersBoundingInfo;
    },
    set: function(t) {
      this._freezeShadowCastersBoundingInfoObservable && t && (this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable), this._freezeShadowCastersBoundingInfoObservable = null), !this._freezeShadowCastersBoundingInfoObservable && !t && (this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(this._computeShadowCastersBoundingInfo.bind(this))), this._freezeShadowCastersBoundingInfo = t, t && this._computeShadowCastersBoundingInfo();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._computeShadowCastersBoundingInfo = function() {
    if (this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._scbiMax.copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE), this._shadowMap && this._shadowMap.renderList) {
      for (var t = this._shadowMap.renderList, r = 0; r < t.length; r++) {
        var n = t[r];
        if (!!n) {
          var a = n.getBoundingInfo(), s = a.boundingBox;
          this._scbiMin.minimizeInPlace(s.minimumWorld), this._scbiMax.maximizeInPlace(s.maximumWorld);
        }
      }
      for (var o = this._scene.meshes, r = 0; r < o.length; r++) {
        var n = o[r];
        if (!(!n || !n.isVisible || !n.isEnabled || !n.receiveShadows)) {
          var a = n.getBoundingInfo(), s = a.boundingBox;
          this._scbiMin.minimizeInPlace(s.minimumWorld), this._scbiMax.maximizeInPlace(s.maximumWorld);
        }
      }
    }
    this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);
  }, Object.defineProperty(e.prototype, "shadowCastersBoundingInfo", {
    get: function() {
      return this._shadowCastersBoundingInfo;
    },
    set: function(t) {
      this._shadowCastersBoundingInfo = t;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.setMinMaxDistance = function(t, r) {
    this._minDistance === t && this._maxDistance === r || (t > r && (t = 0, r = 1), t < 0 && (t = 0), r > 1 && (r = 1), this._minDistance = t, this._maxDistance = r, this._breaksAreDirty = !0);
  }, Object.defineProperty(e.prototype, "minDistance", {
    get: function() {
      return this._minDistance;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "maxDistance", {
    get: function() {
      return this._maxDistance;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getClassName = function() {
    return e.CLASSNAME;
  }, e.prototype.getCascadeMinExtents = function(t) {
    return t >= 0 && t < this._numCascades ? this._cascadeMinExtents[t] : null;
  }, e.prototype.getCascadeMaxExtents = function(t) {
    return t >= 0 && t < this._numCascades ? this._cascadeMaxExtents[t] : null;
  }, Object.defineProperty(e.prototype, "shadowMaxZ", {
    get: function() {
      return !this._scene || !this._scene.activeCamera ? 0 : this._shadowMaxZ;
    },
    set: function(t) {
      if (!this._scene || !this._scene.activeCamera) {
        this._shadowMaxZ = t;
        return;
      }
      this._shadowMaxZ === t || t < this._scene.activeCamera.minZ || t > this._scene.activeCamera.maxZ || (this._shadowMaxZ = t, this._light._markMeshesAsLightDirty(), this._breaksAreDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "debug", {
    get: function() {
      return this._debug;
    },
    set: function(t) {
      this._debug = t, this._light._markMeshesAsLightDirty();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "depthClamp", {
    get: function() {
      return this._depthClamp;
    },
    set: function(t) {
      this._depthClamp = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "cascadeBlendPercentage", {
    get: function() {
      return this._cascadeBlendPercentage;
    },
    set: function(t) {
      this._cascadeBlendPercentage = t, this._light._markMeshesAsLightDirty();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "lambda", {
    get: function() {
      return this._lambda;
    },
    set: function(t) {
      var r = Math.min(Math.max(t, 0), 1);
      this._lambda != r && (this._lambda = r, this._breaksAreDirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getCascadeViewMatrix = function(t) {
    return t >= 0 && t < this._numCascades ? this._viewMatrices[t] : null;
  }, e.prototype.getCascadeProjectionMatrix = function(t) {
    return t >= 0 && t < this._numCascades ? this._projectionMatrices[t] : null;
  }, e.prototype.getCascadeTransformMatrix = function(t) {
    return t >= 0 && t < this._numCascades ? this._transformMatrices[t] : null;
  }, e.prototype.setDepthRenderer = function(t) {
    this._depthRenderer = t, this._depthReducer && this._depthReducer.setDepthRenderer(this._depthRenderer);
  }, Object.defineProperty(e.prototype, "autoCalcDepthBounds", {
    get: function() {
      return this._autoCalcDepthBounds;
    },
    set: function(t) {
      var r = this, n = this._scene.activeCamera;
      if (!!n) {
        if (this._autoCalcDepthBounds = t, !t) {
          this._depthReducer && this._depthReducer.deactivate(), this.setMinMaxDistance(0, 1);
          return;
        }
        this._depthReducer || (this._depthReducer = new To(n), this._depthReducer.onAfterReductionPerformed.add(function(a) {
          var s = a.min, o = a.max;
          s >= o && (s = 0, o = 1), (s != r._minDistance || o != r._maxDistance) && r.setMinMaxDistance(s, o);
        }), this._depthReducer.setDepthRenderer(this._depthRenderer)), this._depthReducer.activate();
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "autoCalcDepthBoundsRefreshRate", {
    get: function() {
      var t, r, n;
      return (n = (r = (t = this._depthReducer) === null || t === void 0 ? void 0 : t.depthRenderer) === null || r === void 0 ? void 0 : r.getDepthMap().refreshRate) !== null && n !== void 0 ? n : -1;
    },
    set: function(t) {
      var r;
      !((r = this._depthReducer) === null || r === void 0) && r.depthRenderer && (this._depthReducer.depthRenderer.getDepthMap().refreshRate = t);
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.splitFrustum = function() {
    this._breaksAreDirty = !0;
  }, e.prototype._splitFrustum = function() {
    var t = this._scene.activeCamera;
    if (!!t) {
      for (var r = t.minZ, n = t.maxZ, a = n - r, s = this._minDistance, o = this._shadowMaxZ < n && this._shadowMaxZ >= r ? Math.min((this._shadowMaxZ - r) / (n - r), this._maxDistance) : this._maxDistance, u = r + s * a, f = r + o * a, l = f - u, h = f / u, c = 0; c < this._cascades.length; ++c) {
        var d = (c + 1) / this._numCascades, p = u * Math.pow(h, d), g = u + l * d, _ = this._lambda * (p - g) + g;
        this._cascades[c].prevBreakDistance = c === 0 ? s : this._cascades[c - 1].breakDistance, this._cascades[c].breakDistance = (_ - r) / a, this._viewSpaceFrustumsZ[c] = _, this._frustumLengths[c] = (this._cascades[c].breakDistance - this._cascades[c].prevBreakDistance) * a;
      }
      this._breaksAreDirty = !1;
    }
  }, e.prototype._computeMatrices = function() {
    var t = this._scene, r = t.activeCamera;
    if (!!r) {
      b.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection), Math.abs(b.Dot(this._lightDirection, b.Up())) === 1 && (this._lightDirection.z = 1e-13), this._cachedDirection.copyFrom(this._lightDirection);
      for (var n = t.getEngine().useReverseDepthBuffer, a = 0; a < this._numCascades; ++a) {
        this._computeFrustumInWorldSpace(a), this._computeCascadeFrustum(a), this._cascadeMaxExtents[a].subtractToRef(this._cascadeMinExtents[a], pe), this._frustumCenter[a].addToRef(this._lightDirection.scale(this._cascadeMinExtents[a].z), this._shadowCameraPos[a]), I.LookAtLHToRef(this._shadowCameraPos[a], this._frustumCenter[a], Ki, this._viewMatrices[a]);
        var s = 0, o = pe.z, u = this._shadowCastersBoundingInfo;
        u.update(this._viewMatrices[a]), o = Math.min(o, u.boundingBox.maximumWorld.z), !this._depthClamp || this.filter === Ve.FILTER_PCSS ? s = Math.min(s, u.boundingBox.minimumWorld.z) : s = Math.max(s, u.boundingBox.minimumWorld.z), I.OrthoOffCenterLHToRef(this._cascadeMinExtents[a].x, this._cascadeMaxExtents[a].x, this._cascadeMinExtents[a].y, this._cascadeMaxExtents[a].y, n ? o : s, n ? s : o, this._projectionMatrices[a], t.getEngine().isNDCHalfZRange), this._cascadeMinExtents[a].z = s, this._cascadeMaxExtents[a].z = o, this._viewMatrices[a].multiplyToRef(this._projectionMatrices[a], this._transformMatrices[a]), b.TransformCoordinatesToRef(So, this._transformMatrices[a], pe), pe.scaleInPlace(this._mapSize / 2), Ot.copyFromFloats(Math.round(pe.x), Math.round(pe.y), Math.round(pe.z)), Ot.subtractInPlace(pe).scaleInPlace(2 / this._mapSize), I.TranslationToRef(Ot.x, Ot.y, 0, pr), this._projectionMatrices[a].multiplyToRef(pr, this._projectionMatrices[a]), this._viewMatrices[a].multiplyToRef(this._projectionMatrices[a], this._transformMatrices[a]), this._transformMatrices[a].copyToArray(this._transformMatricesAsArray, a * 16);
      }
    }
  }, e.prototype._computeFrustumInWorldSpace = function(t) {
    if (!!this._scene.activeCamera) {
      var r = this._cascades[t].prevBreakDistance, n = this._cascades[t].breakDistance, a = this._scene.getEngine().isNDCHalfZRange;
      this._scene.activeCamera.getViewMatrix();
      for (var s = I.Invert(this._scene.activeCamera.getTransformationMatrix()), o = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0, u = 0; u < e._FrustumCornersNDCSpace.length; ++u)
        pe.copyFrom(e._FrustumCornersNDCSpace[(u + o) % e._FrustumCornersNDCSpace.length]), a && pe.z === -1 && (pe.z = 0), b.TransformCoordinatesToRef(pe, s, this._frustumCornersWorldSpace[t][u]);
      for (var u = 0; u < e._FrustumCornersNDCSpace.length / 2; ++u)
        pe.copyFrom(this._frustumCornersWorldSpace[t][u + 4]).subtractInPlace(this._frustumCornersWorldSpace[t][u]), Ot.copyFrom(pe).scaleInPlace(r), pe.scaleInPlace(n), pe.addInPlace(this._frustumCornersWorldSpace[t][u]), this._frustumCornersWorldSpace[t][u + 4].copyFrom(pe), this._frustumCornersWorldSpace[t][u].addInPlace(Ot);
    }
  }, e.prototype._computeCascadeFrustum = function(t) {
    this._cascadeMinExtents[t].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cascadeMaxExtents[t].copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE), this._frustumCenter[t].copyFromFloats(0, 0, 0);
    var r = this._scene.activeCamera;
    if (!!r) {
      for (var n = 0; n < this._frustumCornersWorldSpace[t].length; ++n)
        this._frustumCenter[t].addInPlace(this._frustumCornersWorldSpace[t][n]);
      if (this._frustumCenter[t].scaleInPlace(1 / this._frustumCornersWorldSpace[t].length), this.stabilizeCascades) {
        for (var a = 0, n = 0; n < this._frustumCornersWorldSpace[t].length; ++n) {
          var s = this._frustumCornersWorldSpace[t][n].subtractToRef(this._frustumCenter[t], pe).length();
          a = Math.max(a, s);
        }
        a = Math.ceil(a * 16) / 16, this._cascadeMaxExtents[t].copyFromFloats(a, a, a), this._cascadeMinExtents[t].copyFromFloats(-a, -a, -a);
      } else {
        var o = this._frustumCenter[t];
        this._frustumCenter[t].addToRef(this._lightDirection, pe), I.LookAtLHToRef(o, pe, Ki, pr);
        for (var n = 0; n < this._frustumCornersWorldSpace[t].length; ++n)
          b.TransformCoordinatesToRef(this._frustumCornersWorldSpace[t][n], pr, pe), this._cascadeMinExtents[t].minimizeInPlace(pe), this._cascadeMaxExtents[t].maximizeInPlace(pe);
      }
    }
  }, e.prototype._recreateSceneUBOs = function() {
    if (this._disposeSceneUBOs(), this._sceneUBOs)
      for (var t = 0; t < this._numCascades; ++t)
        this._sceneUBOs.push(this._scene.createSceneUniformBuffer('Scene for CSM Shadow Generator (light "'.concat(this._light.name, '" cascade #').concat(t, ")")));
  }, Object.defineProperty(e, "IsSupported", {
    get: function() {
      var t = re.LastCreatedEngine;
      return t ? t._features.supportCSM : !1;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._initializeGenerator = function() {
    var t, r, n, a, s, o, u, f, l, h, c, d, p, g, _, v, y, E, R, M;
    this.penumbraDarkness = (t = this.penumbraDarkness) !== null && t !== void 0 ? t : 1, this._numCascades = (r = this._numCascades) !== null && r !== void 0 ? r : e.DEFAULT_CASCADES_COUNT, this.stabilizeCascades = (n = this.stabilizeCascades) !== null && n !== void 0 ? n : !1, this._freezeShadowCastersBoundingInfoObservable = (a = this._freezeShadowCastersBoundingInfoObservable) !== null && a !== void 0 ? a : null, this.freezeShadowCastersBoundingInfo = (s = this.freezeShadowCastersBoundingInfo) !== null && s !== void 0 ? s : !1, this._scbiMin = (o = this._scbiMin) !== null && o !== void 0 ? o : new b(0, 0, 0), this._scbiMax = (u = this._scbiMax) !== null && u !== void 0 ? u : new b(0, 0, 0), this._shadowCastersBoundingInfo = (f = this._shadowCastersBoundingInfo) !== null && f !== void 0 ? f : new Et(new b(0, 0, 0), new b(0, 0, 0)), this._breaksAreDirty = (l = this._breaksAreDirty) !== null && l !== void 0 ? l : !0, this._minDistance = (h = this._minDistance) !== null && h !== void 0 ? h : 0, this._maxDistance = (c = this._maxDistance) !== null && c !== void 0 ? c : 1, this._currentLayer = (d = this._currentLayer) !== null && d !== void 0 ? d : 0, this._shadowMaxZ = (_ = (p = this._shadowMaxZ) !== null && p !== void 0 ? p : (g = this._scene.activeCamera) === null || g === void 0 ? void 0 : g.maxZ) !== null && _ !== void 0 ? _ : 1e4, this._debug = (v = this._debug) !== null && v !== void 0 ? v : !1, this._depthClamp = (y = this._depthClamp) !== null && y !== void 0 ? y : !0, this._cascadeBlendPercentage = (E = this._cascadeBlendPercentage) !== null && E !== void 0 ? E : 0.1, this._lambda = (R = this._lambda) !== null && R !== void 0 ? R : 0.5, this._autoCalcDepthBounds = (M = this._autoCalcDepthBounds) !== null && M !== void 0 ? M : !1, this._recreateSceneUBOs(), i.prototype._initializeGenerator.call(this);
  }, e.prototype._createTargetRenderTexture = function() {
    var t = this._scene.getEngine(), r = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };
    this._shadowMap = new kt(this._light.name + "_CSMShadowMap", r, this._scene, !1, !0, this._textureType, !1, void 0, !1, !1, void 0), this._shadowMap.createDepthStencilTexture(t.useReverseDepthBuffer ? 516 : 513, !0);
  }, e.prototype._initializeShadowMap = function() {
    var t = this;
    if (i.prototype._initializeShadowMap.call(this), this._shadowMap !== null) {
      this._transformMatricesAsArray = new Float32Array(this._numCascades * 16), this._viewSpaceFrustumsZ = new Array(this._numCascades), this._frustumLengths = new Array(this._numCascades), this._lightSizeUVCorrection = new Array(this._numCascades * 2), this._depthCorrection = new Array(this._numCascades), this._cascades = [], this._viewMatrices = [], this._projectionMatrices = [], this._transformMatrices = [], this._cascadeMinExtents = [], this._cascadeMaxExtents = [], this._frustumCenter = [], this._shadowCameraPos = [], this._frustumCornersWorldSpace = [];
      for (var r = 0; r < this._numCascades; ++r) {
        this._cascades[r] = {
          prevBreakDistance: 0,
          breakDistance: 0
        }, this._viewMatrices[r] = I.Zero(), this._projectionMatrices[r] = I.Zero(), this._transformMatrices[r] = I.Zero(), this._cascadeMinExtents[r] = new b(), this._cascadeMaxExtents[r] = new b(), this._frustumCenter[r] = new b(), this._shadowCameraPos[r] = new b(), this._frustumCornersWorldSpace[r] = new Array(e._FrustumCornersNDCSpace.length);
        for (var n = 0; n < e._FrustumCornersNDCSpace.length; ++n)
          this._frustumCornersWorldSpace[r][n] = new b();
      }
      var a = this._scene.getEngine();
      this._shadowMap.onBeforeBindObservable.clear(), this._shadowMap.onBeforeRenderObservable.clear(), this._shadowMap.onBeforeRenderObservable.add(function(s) {
        t._sceneUBOs && t._scene.setSceneUniformBuffer(t._sceneUBOs[s]), t._currentLayer = s, t._filter === Ve.FILTER_PCF && a.setColorWrite(!1), t._scene.setTransformMatrix(t.getCascadeViewMatrix(s), t.getCascadeProjectionMatrix(s)), t._useUBO && (t._scene.getSceneUniformBuffer().unbindEffect(), t._scene.finalizeSceneUbo());
      }), this._shadowMap.onBeforeBindObservable.add(function() {
        var s;
        t._currentSceneUBO = t._scene.getSceneUniformBuffer(), (s = a._debugPushGroup) === null || s === void 0 || s.call(a, "cascaded shadow map generation for pass id ".concat(a.currentRenderPassId), 1), t._breaksAreDirty && t._splitFrustum(), t._computeMatrices();
      }), this._splitFrustum();
    }
  }, e.prototype._bindCustomEffectForRenderSubMeshForShadowMap = function(t, r) {
    r.setMatrix("viewProjection", this.getCascadeTransformMatrix(this._currentLayer));
  }, e.prototype._isReadyCustomDefines = function(t) {
    t.push("#define SM_DEPTHCLAMP " + (this._depthClamp && this._filter !== Ve.FILTER_PCSS ? "1" : "0"));
  }, e.prototype.prepareDefines = function(t, r) {
    i.prototype.prepareDefines.call(this, t, r);
    var n = this._scene, a = this._light;
    if (!(!n.shadowsEnabled || !a.shadowEnabled)) {
      t["SHADOWCSM" + r] = !0, t["SHADOWCSMDEBUG" + r] = this.debug, t["SHADOWCSMNUM_CASCADES" + r] = this.numCascades, t["SHADOWCSM_RIGHTHANDED" + r] = n.useRightHandedSystem;
      var s = n.activeCamera;
      s && this._shadowMaxZ < s.maxZ && (t["SHADOWCSMUSESHADOWMAXZ" + r] = !0), this.cascadeBlendPercentage === 0 && (t["SHADOWCSMNOBLEND" + r] = !0);
    }
  }, e.prototype.bindShadowLight = function(t, r) {
    var n = this._light, a = this._scene;
    if (!(!a.shadowsEnabled || !n.shadowEnabled)) {
      var s = a.activeCamera;
      if (!!s) {
        var o = this.getShadowMap();
        if (!!o) {
          var u = o.getSize().width;
          if (r.setMatrices("lightMatrix" + t, this._transformMatricesAsArray), r.setArray("viewFrustumZ" + t, this._viewSpaceFrustumsZ), r.setFloat("cascadeBlendFactor" + t, this.cascadeBlendPercentage === 0 ? 1e4 : 1 / this.cascadeBlendPercentage), r.setArray("frustumLengths" + t, this._frustumLengths), this._filter === Ve.FILTER_PCF)
            r.setDepthStencilTexture("shadowSampler" + t, o), n._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), u, 1 / u, this.frustumEdgeFalloff, t);
          else if (this._filter === Ve.FILTER_PCSS) {
            for (var f = 0; f < this._numCascades; ++f)
              this._lightSizeUVCorrection[f * 2 + 0] = f === 0 ? 1 : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[f].x - this._cascadeMinExtents[f].x), this._lightSizeUVCorrection[f * 2 + 1] = f === 0 ? 1 : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[f].y - this._cascadeMinExtents[f].y), this._depthCorrection[f] = f === 0 ? 1 : (this._cascadeMaxExtents[f].z - this._cascadeMinExtents[f].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);
            r.setDepthStencilTexture("shadowSampler" + t, o), r.setTexture("depthSampler" + t, o), r.setArray2("lightSizeUVCorrection" + t, this._lightSizeUVCorrection), r.setArray("depthCorrection" + t, this._depthCorrection), r.setFloat("penumbraDarkness" + t, this.penumbraDarkness), n._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / u, this._contactHardeningLightSizeUVRatio * u, this.frustumEdgeFalloff, t);
          } else
            r.setTexture("shadowSampler" + t, o), n._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), u, 1 / u, this.frustumEdgeFalloff, t);
          n._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(s), this.getLight().getDepthMinZ(s) + this.getLight().getDepthMaxZ(s), t);
        }
      }
    }
  }, e.prototype.getTransformMatrix = function() {
    return this.getCascadeTransformMatrix(0);
  }, e.prototype.dispose = function() {
    i.prototype.dispose.call(this), this._freezeShadowCastersBoundingInfoObservable && (this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable), this._freezeShadowCastersBoundingInfoObservable = null), this._depthReducer && (this._depthReducer.dispose(), this._depthReducer = null);
  }, e.prototype.serialize = function() {
    var t = i.prototype.serialize.call(this), r = this.getShadowMap();
    if (!r)
      return t;
    if (t.numCascades = this._numCascades, t.debug = this._debug, t.stabilizeCascades = this.stabilizeCascades, t.lambda = this._lambda, t.cascadeBlendPercentage = this.cascadeBlendPercentage, t.depthClamp = this._depthClamp, t.autoCalcDepthBounds = this.autoCalcDepthBounds, t.shadowMaxZ = this._shadowMaxZ, t.penumbraDarkness = this.penumbraDarkness, t.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo, t.minDistance = this.minDistance, t.maxDistance = this.maxDistance, t.renderList = [], r.renderList)
      for (var n = 0; n < r.renderList.length; n++) {
        var a = r.renderList[n];
        t.renderList.push(a.id);
      }
    return t;
  }, e.Parse = function(t, r) {
    var n = Ve.Parse(t, r, function(a, s) {
      return new e(a, s);
    });
    return t.numCascades !== void 0 && (n.numCascades = t.numCascades), t.debug !== void 0 && (n.debug = t.debug), t.stabilizeCascades !== void 0 && (n.stabilizeCascades = t.stabilizeCascades), t.lambda !== void 0 && (n.lambda = t.lambda), t.cascadeBlendPercentage !== void 0 && (n.cascadeBlendPercentage = t.cascadeBlendPercentage), t.depthClamp !== void 0 && (n.depthClamp = t.depthClamp), t.autoCalcDepthBounds !== void 0 && (n.autoCalcDepthBounds = t.autoCalcDepthBounds), t.shadowMaxZ !== void 0 && (n.shadowMaxZ = t.shadowMaxZ), t.penumbraDarkness !== void 0 && (n.penumbraDarkness = t.penumbraDarkness), t.freezeShadowCastersBoundingInfo !== void 0 && (n.freezeShadowCastersBoundingInfo = t.freezeShadowCastersBoundingInfo), t.minDistance !== void 0 && t.maxDistance !== void 0 && n.setMinMaxDistance(t.minDistance, t.maxDistance), n;
  }, e._FrustumCornersNDCSpace = [
    new b(-1, 1, -1),
    new b(1, 1, -1),
    new b(1, -1, -1),
    new b(-1, -1, -1),
    new b(-1, 1, 1),
    new b(1, 1, 1),
    new b(1, -1, 1),
    new b(-1, -1, 1)
  ], e.CLASSNAME = "CascadedShadowGenerator", e.DEFAULT_CASCADES_COUNT = 4, e.MIN_CASCADES_COUNT = 2, e.MAX_CASCADES_COUNT = 4, e._SceneComponentInitialization = function(t) {
    throw G("ShadowGeneratorSceneComponent");
  }, e;
}(Ve);
un.AddParser(Xt.NAME_SHADOWGENERATOR, function(i, e) {
  if (i.shadowGenerators !== void 0 && i.shadowGenerators !== null)
    for (var t = 0, r = i.shadowGenerators.length; t < r; t++) {
      var n = i.shadowGenerators[t];
      n.className === Yi.CLASSNAME ? Yi.Parse(n, e) : Ve.Parse(n, e);
    }
});
var Mo = function() {
  function i(e) {
    this.name = Xt.NAME_SHADOWGENERATOR, this.scene = e;
  }
  return i.prototype.register = function() {
    this.scene._gatherRenderTargetsStage.registerStep(Xt.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);
  }, i.prototype.rebuild = function() {
  }, i.prototype.serialize = function(e) {
    e.shadowGenerators = [];
    for (var t = this.scene.lights, r = 0, n = t; r < n.length; r++) {
      var a = n[r], s = a.getShadowGenerator();
      s && e.shadowGenerators.push(s.serialize());
    }
  }, i.prototype.addFromContainer = function(e) {
  }, i.prototype.removeFromContainer = function(e, t) {
  }, i.prototype.dispose = function() {
  }, i.prototype._gatherRenderTargets = function(e) {
    var t = this.scene;
    if (this.scene.shadowsEnabled)
      for (var r = 0; r < t.lights.length; r++) {
        var n = t.lights[r], a = n.getShadowGenerator();
        if (n.isEnabled() && n.shadowEnabled && a) {
          var s = a.getShadowMap();
          t.textures.indexOf(s) !== -1 && e.push(s);
        }
      }
  }, i;
}();
Ve._SceneComponentInitialization = function(i) {
  var e = i._getComponent(Xt.NAME_SHADOWGENERATOR);
  e || (e = new Mo(i), i._addComponent(e));
};
const Ao = {
  enableShadows: !0
};
function Zi(i = Ao) {
  const { enableShadows: e, shadowTransparency: t, intensity: r, scene: n } = i, a = new pn("DirectionalLight", new b(-0.3, -1, 0.4), n);
  a.position = new b(-50, 65, -50), a.intensity = 0.65 * r;
  const s = new _n("HemisphericLight", new b(1, 1, 0), n);
  return s.intensity = 0.4 * r, e && (a.shadowMinZ = 1, a.shadowMaxZ = 70, a.shadowGenerator = new Ve(2048, a), a.shadowGenerator.useCloseExponentialShadowMap = !0, a.shadowGenerator.darkness = t), { directional: a, hemispheric: s };
}
function vn(i) {
  var e = 6, t = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23], r = [
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0
  ], n = [], a = [], s = i.width || i.size || 1, o = i.height || i.size || 1, u = i.depth || i.size || 1, f = i.wrap || !1, l = i.topBaseAt === void 0 ? 1 : i.topBaseAt, h = i.bottomBaseAt === void 0 ? 0 : i.bottomBaseAt;
  l = (l + 4) % 4, h = (h + 4) % 4;
  var c = [2, 0, 3, 1], d = [2, 0, 1, 3], p = c[l], g = d[h], _ = [
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1
  ];
  if (f) {
    t = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14], _ = [
      -1,
      1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1
    ];
    for (var v = [
      [1, 1, 1],
      [-1, 1, 1],
      [-1, 1, -1],
      [1, 1, -1]
    ], y = [
      [-1, -1, 1],
      [1, -1, 1],
      [1, -1, -1],
      [-1, -1, -1]
    ], E = [17, 18, 19, 16], R = [22, 23, 20, 21]; p > 0; )
      v.unshift(v.pop()), E.unshift(E.pop()), p--;
    for (; g > 0; )
      y.unshift(y.pop()), R.unshift(R.pop()), g--;
    v = v.flat(), y = y.flat(), _ = _.concat(v).concat(y), t.push(E[0], E[2], E[3], E[0], E[1], E[2]), t.push(R[0], R[2], R[3], R[0], R[1], R[2]);
  }
  var M = [s / 2, o / 2, u / 2];
  a = _.reduce(function(Z, q, ae) {
    return Z.concat(q * M[ae % 3]);
  }, []);
  for (var C = i.sideOrientation === 0 ? 0 : i.sideOrientation || _e.DEFAULTSIDE, A = i.faceUV || new Array(6), S = i.faceColors, w = [], F = 0; F < 6; F++)
    A[F] === void 0 && (A[F] = new yt(0, 0, 1, 1)), S && S[F] === void 0 && (S[F] = new be(1, 1, 1, 1));
  for (var x = 0; x < e; x++)
    if (n.push(A[x].z, Ye.UseOpenGLOrientationForUV ? 1 - A[x].w : A[x].w), n.push(A[x].x, Ye.UseOpenGLOrientationForUV ? 1 - A[x].w : A[x].w), n.push(A[x].x, Ye.UseOpenGLOrientationForUV ? 1 - A[x].y : A[x].y), n.push(A[x].z, Ye.UseOpenGLOrientationForUV ? 1 - A[x].y : A[x].y), S)
      for (var z = 0; z < 4; z++)
        w.push(S[x].r, S[x].g, S[x].b, S[x].a);
  _e._ComputeSides(C, a, t, r, n, i.frontUVs, i.backUVs);
  var W = new _e();
  if (W.indices = t, W.positions = a, W.normals = r, W.uvs = n, S) {
    var N = C === _e.DOUBLESIDE ? w.concat(w) : w;
    W.colors = N;
  }
  return W;
}
function wt(i, e, t) {
  e === void 0 && (e = {}), t === void 0 && (t = null);
  var r = new Q(i, t);
  e.sideOrientation = Q._GetDefaultSideOrientation(e.sideOrientation), r._originalBuilderSideOrientation = e.sideOrientation;
  var n = vn(e);
  return n.applyToMesh(r, e.updatable), r;
}
_e.CreateBox = vn;
Q.CreateBox = function(i, e, t, r, n) {
  t === void 0 && (t = null);
  var a = {
    size: e,
    sideOrientation: n,
    updatable: r
  };
  return wt(i, a, t);
};
var $r = function() {
  function i() {
    this.previousWorldMatrices = {}, this.previousBones = {};
  }
  return i.AddUniforms = function(e) {
    e.push("previousWorld", "previousViewProjection", "mPreviousBones");
  }, i.AddSamplers = function(e) {
  }, i.prototype.bindForSubMesh = function(e, t, r, n, a) {
    if (t.prePassRenderer && t.prePassRenderer.enabled && t.prePassRenderer.currentRTisSceneRT && t.prePassRenderer.getIndex(2) !== -1) {
      this.previousWorldMatrices[r.uniqueId] || (this.previousWorldMatrices[r.uniqueId] = n.clone()), this.previousViewProjection || (this.previousViewProjection = t.getTransformMatrix().clone(), this.currentViewProjection = t.getTransformMatrix().clone());
      var s = t.getEngine();
      this.currentViewProjection.updateFlag !== t.getTransformMatrix().updateFlag ? (this._lastUpdateFrameId = s.frameId, this.previousViewProjection.copyFrom(this.currentViewProjection), this.currentViewProjection.copyFrom(t.getTransformMatrix())) : this._lastUpdateFrameId !== s.frameId && (this._lastUpdateFrameId = s.frameId, this.previousViewProjection.copyFrom(this.currentViewProjection)), e.setMatrix("previousWorld", this.previousWorldMatrices[r.uniqueId]), e.setMatrix("previousViewProjection", this.previousViewProjection), this.previousWorldMatrices[r.uniqueId] = n.clone();
    }
  }, i;
}(), mn = function(i) {
  K(e, i);
  function e(t, r, n) {
    n === void 0 && (n = !0);
    var a = i.call(this, t, r) || this;
    return a._normalMatrix = new I(), a._storeEffectOnSubMeshes = n, a;
  }
  return e.prototype.getEffect = function() {
    return this._storeEffectOnSubMeshes ? this._activeEffect : i.prototype.getEffect.call(this);
  }, e.prototype.isReady = function(t, r) {
    return t ? !this._storeEffectOnSubMeshes || !t.subMeshes || t.subMeshes.length === 0 ? !0 : this.isReadyForSubMesh(t, t.subMeshes[0], r) : !1;
  }, e.prototype._isReadyForSubMesh = function(t) {
    var r = t.materialDefines;
    return !!(!this.checkReadyOnEveryCall && t.effect && r && r._renderId === this.getScene().getRenderId());
  }, e.prototype.bindOnlyWorldMatrix = function(t) {
    this._activeEffect.setMatrix("world", t);
  }, e.prototype.bindOnlyNormalMatrix = function(t) {
    this._activeEffect.setMatrix("normalMatrix", t);
  }, e.prototype.bind = function(t, r) {
    !r || this.bindForSubMesh(t, r, r.subMeshes[0]);
  }, e.prototype._afterBind = function(t, r) {
    r === void 0 && (r = null), i.prototype._afterBind.call(this, t, r), this.getScene()._cachedEffect = r;
  }, e.prototype._mustRebind = function(t, r, n) {
    return n === void 0 && (n = 1), t.isCachedMaterialInvalid(this, r, n);
  }, e;
}(Ie), he = function() {
  function i() {
  }
  return Object.defineProperty(i, "DiffuseTextureEnabled", {
    get: function() {
      return this._DiffuseTextureEnabled;
    },
    set: function(e) {
      this._DiffuseTextureEnabled !== e && (this._DiffuseTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "DetailTextureEnabled", {
    get: function() {
      return this._DetailTextureEnabled;
    },
    set: function(e) {
      this._DetailTextureEnabled !== e && (this._DetailTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "AmbientTextureEnabled", {
    get: function() {
      return this._AmbientTextureEnabled;
    },
    set: function(e) {
      this._AmbientTextureEnabled !== e && (this._AmbientTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "OpacityTextureEnabled", {
    get: function() {
      return this._OpacityTextureEnabled;
    },
    set: function(e) {
      this._OpacityTextureEnabled !== e && (this._OpacityTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "ReflectionTextureEnabled", {
    get: function() {
      return this._ReflectionTextureEnabled;
    },
    set: function(e) {
      this._ReflectionTextureEnabled !== e && (this._ReflectionTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "EmissiveTextureEnabled", {
    get: function() {
      return this._EmissiveTextureEnabled;
    },
    set: function(e) {
      this._EmissiveTextureEnabled !== e && (this._EmissiveTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "SpecularTextureEnabled", {
    get: function() {
      return this._SpecularTextureEnabled;
    },
    set: function(e) {
      this._SpecularTextureEnabled !== e && (this._SpecularTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "BumpTextureEnabled", {
    get: function() {
      return this._BumpTextureEnabled;
    },
    set: function(e) {
      this._BumpTextureEnabled !== e && (this._BumpTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "LightmapTextureEnabled", {
    get: function() {
      return this._LightmapTextureEnabled;
    },
    set: function(e) {
      this._LightmapTextureEnabled !== e && (this._LightmapTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "RefractionTextureEnabled", {
    get: function() {
      return this._RefractionTextureEnabled;
    },
    set: function(e) {
      this._RefractionTextureEnabled !== e && (this._RefractionTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "ColorGradingTextureEnabled", {
    get: function() {
      return this._ColorGradingTextureEnabled;
    },
    set: function(e) {
      this._ColorGradingTextureEnabled !== e && (this._ColorGradingTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "FresnelEnabled", {
    get: function() {
      return this._FresnelEnabled;
    },
    set: function(e) {
      this._FresnelEnabled !== e && (this._FresnelEnabled = e, fe.MarkAllMaterialsAsDirty(4));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "ClearCoatTextureEnabled", {
    get: function() {
      return this._ClearCoatTextureEnabled;
    },
    set: function(e) {
      this._ClearCoatTextureEnabled !== e && (this._ClearCoatTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "ClearCoatBumpTextureEnabled", {
    get: function() {
      return this._ClearCoatBumpTextureEnabled;
    },
    set: function(e) {
      this._ClearCoatBumpTextureEnabled !== e && (this._ClearCoatBumpTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "ClearCoatTintTextureEnabled", {
    get: function() {
      return this._ClearCoatTintTextureEnabled;
    },
    set: function(e) {
      this._ClearCoatTintTextureEnabled !== e && (this._ClearCoatTintTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "SheenTextureEnabled", {
    get: function() {
      return this._SheenTextureEnabled;
    },
    set: function(e) {
      this._SheenTextureEnabled !== e && (this._SheenTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "AnisotropicTextureEnabled", {
    get: function() {
      return this._AnisotropicTextureEnabled;
    },
    set: function(e) {
      this._AnisotropicTextureEnabled !== e && (this._AnisotropicTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "ThicknessTextureEnabled", {
    get: function() {
      return this._ThicknessTextureEnabled;
    },
    set: function(e) {
      this._ThicknessTextureEnabled !== e && (this._ThicknessTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "RefractionIntensityTextureEnabled", {
    get: function() {
      return this._ThicknessTextureEnabled;
    },
    set: function(e) {
      this._RefractionIntensityTextureEnabled !== e && (this._RefractionIntensityTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "TranslucencyIntensityTextureEnabled", {
    get: function() {
      return this._ThicknessTextureEnabled;
    },
    set: function(e) {
      this._TranslucencyIntensityTextureEnabled !== e && (this._TranslucencyIntensityTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "IridescenceTextureEnabled", {
    get: function() {
      return this._IridescenceTextureEnabled;
    },
    set: function(e) {
      this._IridescenceTextureEnabled !== e && (this._IridescenceTextureEnabled = e, fe.MarkAllMaterialsAsDirty(1));
    },
    enumerable: !1,
    configurable: !0
  }), i._DiffuseTextureEnabled = !0, i._DetailTextureEnabled = !0, i._AmbientTextureEnabled = !0, i._OpacityTextureEnabled = !0, i._ReflectionTextureEnabled = !0, i._EmissiveTextureEnabled = !0, i._SpecularTextureEnabled = !0, i._BumpTextureEnabled = !0, i._LightmapTextureEnabled = !0, i._RefractionTextureEnabled = !0, i._ColorGradingTextureEnabled = !0, i._FresnelEnabled = !0, i._ClearCoatTextureEnabled = !0, i._ClearCoatBumpTextureEnabled = !0, i._ClearCoatTintTextureEnabled = !0, i._SheenTextureEnabled = !0, i._AnisotropicTextureEnabled = !0, i._ThicknessTextureEnabled = !0, i._RefractionIntensityTextureEnabled = !0, i._TranslucencyIntensityTextureEnabled = !0, i._IridescenceTextureEnabled = !0, i;
}(), Ro = "defaultFragmentDeclaration", Po = `uniform vec4 vEyePosition;
uniform vec4 vDiffuseColor;
#ifdef SPECULARTERM
uniform vec4 vSpecularColor;
#endif
uniform vec3 vEmissiveColor;
uniform vec3 vAmbientColor;
uniform float visibility;
#ifdef DIFFUSE
uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY 
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;
uniform vec2 vTangentSpaceParams;
#endif
#ifdef ALPHATEST
uniform float alphaCutOff;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFRACTION
uniform vec4 vRefractionInfos;
#ifndef REFRACTIONMAP_3D
uniform mat4 refractionMatrix;
#endif
#ifdef REFRACTIONFRESNEL
uniform vec4 refractionLeftColor;
uniform vec4 refractionRightColor;
#endif
#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)
uniform vec3 vRefractionPosition;
uniform vec3 vRefractionSize; 
#endif
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;
#endif
#ifdef DIFFUSEFRESNEL
uniform vec4 diffuseLeftColor;
uniform vec4 diffuseRightColor;
#endif
#ifdef OPACITYFRESNEL
uniform vec4 opacityParts;
#endif
#ifdef EMISSIVEFRESNEL
uniform vec4 emissiveLeftColor;
uniform vec4 emissiveRightColor;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)
uniform mat4 reflectionMatrix;
#endif
#ifndef REFLECTIONMAP_SKYBOX
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;
uniform vec3 vReflectionSize; 
#endif
#endif
#ifdef REFLECTIONFRESNEL
uniform vec4 reflectionLeftColor;
uniform vec4 reflectionRightColor;
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#define ADDITIONAL_FRAGMENT_DECLARATION
`;
L.IncludesShadersStore[Ro] = Po;
var Co = "defaultUboDeclaration", xo = `layout(std140,column_major) uniform;
uniform Material
{
vec4 diffuseLeftColor;
vec4 diffuseRightColor;
vec4 opacityParts;
vec4 reflectionLeftColor;
vec4 reflectionRightColor;
vec4 refractionLeftColor;
vec4 refractionRightColor;
vec4 emissiveLeftColor;
vec4 emissiveRightColor;
vec2 vDiffuseInfos;
vec2 vAmbientInfos;
vec2 vOpacityInfos;
vec2 vReflectionInfos;
vec3 vReflectionPosition;
vec3 vReflectionSize;
vec2 vEmissiveInfos;
vec2 vLightmapInfos;
vec2 vSpecularInfos;
vec3 vBumpInfos;
mat4 diffuseMatrix;
mat4 ambientMatrix;
mat4 opacityMatrix;
mat4 reflectionMatrix;
mat4 emissiveMatrix;
mat4 lightmapMatrix;
mat4 specularMatrix;
mat4 bumpMatrix;
vec2 vTangentSpaceParams;
float pointSize;
float alphaCutOff;
mat4 refractionMatrix;
vec4 vRefractionInfos;
vec3 vRefractionPosition;
vec3 vRefractionSize;
vec4 vSpecularColor;
vec3 vEmissiveColor;
vec4 vDiffuseColor;
vec3 vAmbientColor;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
L.IncludesShadersStore[Co] = xo;
var Do = "prePassDeclaration", Io = `#ifdef PREPASS
#extension GL_EXT_draw_buffers : require
layout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;
#ifdef PREPASS_DEPTH
varying highp vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
varying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;
#endif
#endif
`;
L.IncludesShadersStore[Do] = Io;
var Oo = "oitDeclaration", Fo = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#extension GL_EXT_draw_buffers : require
layout(location=0) out vec2 depth; 
layout(location=1) out vec4 frontColor;
layout(location=2) out vec4 backColor;
#define MAX_DEPTH 99999.0
highp vec4 gl_FragColor;
uniform sampler2D oitDepthSampler;
uniform sampler2D oitFrontColorSampler;
#endif
`;
L.IncludesShadersStore[Oo] = Fo;
var wo = "mainUVVaryingDeclaration", Lo = `#ifdef MAINUV{X}
varying vec2 vMainUV{X};
#endif
`;
L.IncludesShadersStore[wo] = Lo;
var No = "lightFragmentDeclaration", Bo = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};
uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float cascadeBlendFactor{X};
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
uniform highp sampler2DArray depthSampler{X};
uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);
vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X};
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};
uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};
uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};
uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};
uniform sampler2D projectionLightSampler{X};
#endif
#endif
`;
L.IncludesShadersStore[No] = Bo;
var Uo = "lightUboDeclaration", Vo = `#ifdef LIGHT{X}
uniform Light{X}
{
vec4 vLightData;
vec4 vLightDiffuse;
vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;
vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;
vec2 depthValues;
} light{X};
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};
uniform sampler2D projectionLightSampler{X};
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float cascadeBlendFactor{X};
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
uniform highp sampler2DArray depthSampler{X};
uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);
vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X}; 
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};
uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
L.IncludesShadersStore[Uo] = Vo;
var ko = "lightsFragmentFunctions", Wo = `struct lightingInfo
{
vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef NDOTL
float ndl;
#endif
};
lightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {
lightingInfo result;
vec3 lightVectorW;
float attenuation=1.0;
if (lightData.w==0.)
{
vec3 direction=lightData.xyz-vPositionW;
attenuation=max(0.,1.0-length(direction)/range);
lightVectorW=normalize(direction);
}
else
{
lightVectorW=normalize(-lightData.xyz);
}
float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);
float specComp=max(0.,dot(vNormal,angleW));
specComp=pow(specComp,max(1.,glossiness));
result.specular=specComp*specularColor*attenuation;
#endif
return result;
}
lightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {
lightingInfo result;
vec3 direction=lightData.xyz-vPositionW;
vec3 lightVectorW=normalize(direction);
float attenuation=max(0.,1.0-length(direction)/range);
float cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));
if (cosAngle>=lightDirection.w)
{
cosAngle=max(0.,pow(cosAngle,lightData.w));
attenuation*=cosAngle;
float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);
float specComp=max(0.,dot(vNormal,angleW));
specComp=pow(specComp,max(1.,glossiness));
result.specular=specComp*specularColor*attenuation;
#endif
return result;
}
result.diffuse=vec3(0.);
#ifdef SPECULARTERM
result.specular=vec3(0.);
#endif
#ifdef NDOTL
result.ndl=0.;
#endif
return result;
}
lightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {
lightingInfo result;
float ndl=dot(vNormal,lightData.xyz)*0.5+0.5;
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=mix(groundColor,diffuseColor,ndl);
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightData.xyz);
float specComp=max(0.,dot(vNormal,angleW));
specComp=pow(specComp,max(1.,glossiness));
result.specular=specComp*specularColor;
#endif
return result;
}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){
vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);
strq/=strq.w;
vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;
return textureColor;
}`;
L.IncludesShadersStore[ko] = Wo;
var zo = "shadowsFragmentFunctions", Go = `#ifdef SHADOWS
#ifndef SHADOWFLOAT
float unpack(vec4 color)
{
const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);
return dot(color,bit_shift);
}
#endif
float computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)
{
float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));
return mix(value,1.0,mask);
}
#define inline
float computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
depth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadow=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadow=textureCube(shadowSampler,directionToLight).x;
#endif
return depth>shadow ? darkness : 1.0;
}
#define inline
float computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
depth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
float visibility=1.;
vec3 poissonDisk[4];
poissonDisk[0]=vec3(-1.0,1.0,-1.0);
poissonDisk[1]=vec3(1.0,-1.0,-1.0);
poissonDisk[2]=vec3(-1.0,-1.0,-1.0);
poissonDisk[3]=vec3(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;
#else
if (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;
if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;
if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;
if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;
#endif
return min(1.0,visibility+darkness);
}
#define inline
float computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
float shadowPixelDepth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness); 
return esm;
}
#define inline
float computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
float shadowPixelDepth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);
return esm;
}
#if defined(WEBGL2) || defined(WEBGPU)
#define inline
float computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
vec3 uvLayer=vec3(uv.x,uv.y,layer);
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uvLayer));
#else
float shadow=texture2D(shadowSampler,uvLayer).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;
}
#endif
#define inline
float computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uv));
#else
float shadow=texture2D(shadowSampler,uv).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;
}
}
#define inline
float computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
float visibility=1.;
vec2 poissonDisk[4];
poissonDisk[0]=vec2(-0.94201624,-0.39906216);
poissonDisk[1]=vec2(0.94558609,-0.76890725);
poissonDisk[2]=vec2(-0.094184101,-0.92938870);
poissonDisk[3]=vec2(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<shadowPixelDepth) visibility-=0.25;
if (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<shadowPixelDepth) visibility-=0.25;
if (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<shadowPixelDepth) visibility-=0.25;
if (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<shadowPixelDepth) visibility-=0.25;
#else
if (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<shadowPixelDepth) visibility-=0.25;
if (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<shadowPixelDepth) visibility-=0.25;
if (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<shadowPixelDepth) visibility-=0.25;
if (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<shadowPixelDepth) visibility-=0.25;
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(texture2D(shadowSampler,uv));
#else
float shadowMapSample=texture2D(shadowSampler,uv).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);
return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(texture2D(shadowSampler,uv));
#else
float shadowMapSample=texture2D(shadowSampler,uv).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);
return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);
}
}
#ifdef IS_NDC_HALF_ZRANGE
#define ZINCLIP clipSpace.z
#else
#define ZINCLIP uvDepth.z
#endif
#if defined(WEBGL2) || defined(WEBGPU)
#define GREATEST_LESS_THAN_ONE 0.99999994
#define inline
float computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);
float shadow=texture2D(shadowSampler,uvDepthLayer);
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
#define inline
float computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;
vec2 uvw1=1.+2.*st;
vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;
vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));
shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));
shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));
shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));
shadow=shadow/16.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
#define inline
float computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;
vec2 uvw1=vec2(7.);
vec2 uvw2=1.+3.*st;
vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;
vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));
shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));
shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));
shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));
shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));
shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));
shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));
shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));
shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));
shadow=shadow/144.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
#define inline
float computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
float shadow=texture2D(shadowSampler,uvDepth);
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;
vec2 uvw1=1.+2.*st;
vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;
vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));
shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));
shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));
shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));
shadow=shadow/16.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;
vec2 uvw1=vec2(7.);
vec2 uvw2=1.+3.*st;
vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;
vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));
shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));
shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z));
shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));
shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));
shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z));
shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z));
shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z));
shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z));
shadow=shadow/144.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
const vec3 PoissonSamplers32[64]=vec3[64](
vec3(0.06407013,0.05409927,0.),
vec3(0.7366577,0.5789394,0.),
vec3(-0.6270542,-0.5320278,0.),
vec3(-0.4096107,0.8411095,0.),
vec3(0.6849564,-0.4990818,0.),
vec3(-0.874181,-0.04579735,0.),
vec3(0.9989998,0.0009880066,0.),
vec3(-0.004920578,-0.9151649,0.),
vec3(0.1805763,0.9747483,0.),
vec3(-0.2138451,0.2635818,0.),
vec3(0.109845,0.3884785,0.),
vec3(0.06876755,-0.3581074,0.),
vec3(0.374073,-0.7661266,0.),
vec3(0.3079132,-0.1216763,0.),
vec3(-0.3794335,-0.8271583,0.),
vec3(-0.203878,-0.07715034,0.),
vec3(0.5912697,0.1469799,0.),
vec3(-0.88069,0.3031784,0.),
vec3(0.5040108,0.8283722,0.),
vec3(-0.5844124,0.5494877,0.),
vec3(0.6017799,-0.1726654,0.),
vec3(-0.5554981,0.1559997,0.),
vec3(-0.3016369,-0.3900928,0.),
vec3(-0.5550632,-0.1723762,0.),
vec3(0.925029,0.2995041,0.),
vec3(-0.2473137,0.5538505,0.),
vec3(0.9183037,-0.2862392,0.),
vec3(0.2469421,0.6718712,0.),
vec3(0.3916397,-0.4328209,0.),
vec3(-0.03576927,-0.6220032,0.),
vec3(-0.04661255,0.7995201,0.),
vec3(0.4402924,0.3640312,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.)
);
const vec3 PoissonSamplers64[64]=vec3[64](
vec3(-0.613392,0.617481,0.),
vec3(0.170019,-0.040254,0.),
vec3(-0.299417,0.791925,0.),
vec3(0.645680,0.493210,0.),
vec3(-0.651784,0.717887,0.),
vec3(0.421003,0.027070,0.),
vec3(-0.817194,-0.271096,0.),
vec3(-0.705374,-0.668203,0.),
vec3(0.977050,-0.108615,0.),
vec3(0.063326,0.142369,0.),
vec3(0.203528,0.214331,0.),
vec3(-0.667531,0.326090,0.),
vec3(-0.098422,-0.295755,0.),
vec3(-0.885922,0.215369,0.),
vec3(0.566637,0.605213,0.),
vec3(0.039766,-0.396100,0.),
vec3(0.751946,0.453352,0.),
vec3(0.078707,-0.715323,0.),
vec3(-0.075838,-0.529344,0.),
vec3(0.724479,-0.580798,0.),
vec3(0.222999,-0.215125,0.),
vec3(-0.467574,-0.405438,0.),
vec3(-0.248268,-0.814753,0.),
vec3(0.354411,-0.887570,0.),
vec3(0.175817,0.382366,0.),
vec3(0.487472,-0.063082,0.),
vec3(-0.084078,0.898312,0.),
vec3(0.488876,-0.783441,0.),
vec3(0.470016,0.217933,0.),
vec3(-0.696890,-0.549791,0.),
vec3(-0.149693,0.605762,0.),
vec3(0.034211,0.979980,0.),
vec3(0.503098,-0.308878,0.),
vec3(-0.016205,-0.872921,0.),
vec3(0.385784,-0.393902,0.),
vec3(-0.146886,-0.859249,0.),
vec3(0.643361,0.164098,0.),
vec3(0.634388,-0.049471,0.),
vec3(-0.688894,0.007843,0.),
vec3(0.464034,-0.188818,0.),
vec3(-0.440840,0.137486,0.),
vec3(0.364483,0.511704,0.),
vec3(0.034028,0.325968,0.),
vec3(0.099094,-0.308023,0.),
vec3(0.693960,-0.366253,0.),
vec3(0.678884,-0.204688,0.),
vec3(0.001801,0.780328,0.),
vec3(0.145177,-0.898984,0.),
vec3(0.062655,-0.611866,0.),
vec3(0.315226,-0.604297,0.),
vec3(-0.780145,0.486251,0.),
vec3(-0.371868,0.882138,0.),
vec3(0.200476,0.494430,0.),
vec3(-0.494552,-0.711051,0.),
vec3(0.612476,0.705252,0.),
vec3(-0.578845,-0.768792,0.),
vec3(-0.772454,-0.090976,0.),
vec3(0.504440,0.372295,0.),
vec3(0.155736,0.065157,0.),
vec3(0.391522,0.849605,0.),
vec3(-0.620106,-0.328104,0.),
vec3(0.789239,-0.419965,0.),
vec3(-0.545396,0.538133,0.),
vec3(-0.178564,-0.596057,0.)
);
#define inline
float computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);
float blockerDepth=0.0;
float sumBlockerDepth=0.0;
float numBlocker=0.0;
for (int i=0; i<searchTapCount; i ++) {
blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;
if (blockerDepth<depthMetric) {
sumBlockerDepth+=blockerDepth;
numBlocker++;
}
}
if (numBlocker<1.0) {
return 1.0;
}
else
{
float avgBlockerDepth=sumBlockerDepth/numBlocker;
float AAOffset=shadowMapSizeInverse*10.;
float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);
vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);
float random=getRand(vPositionFromLight.xy);
float rotationAngle=random*3.1415926;
vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));
float shadow=0.;
for (int i=0; i<pcfTapCount; i++) {
vec4 offset=vec4(poissonSamplers[i],0.);
offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);
shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);
}
shadow/=float(pcfTapCount);
shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
float blockerDepth=0.0;
float sumBlockerDepth=0.0;
float numBlocker=0.0;
for (int i=0; i<searchTapCount; i ++) {
blockerDepth=texture2D(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy)).r;
if (blockerDepth<depthMetric) {
sumBlockerDepth+=blockerDepth;
numBlocker++;
}
}
if (numBlocker<1.0) {
return 1.0;
}
else
{
float avgBlockerDepth=sumBlockerDepth/numBlocker;
float AAOffset=shadowMapSizeInverse*10.;
float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);
float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;
float random=getRand(vPositionFromLight.xy);
float rotationAngle=random*3.1415926;
vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));
float shadow=0.;
for (int i=0; i<pcfTapCount; i++) {
vec3 offset=poissonSamplers[i];
offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);
shadow+=texture2D(shadowSampler,uvDepth+offset*filterRadius);
}
shadow/=float(pcfTapCount);
shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
}
#define inline
float computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{
return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);
}
#define inline
float computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{
return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);
}
#define inline
float computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{
return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);
}
#define inline
float computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);
}
#define inline
float computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);
}
#define inline
float computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);
}
#endif
#endif
`;
L.IncludesShadersStore[zo] = Go;
var Xo = "samplerFragmentDeclaration", Ho = `#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
uniform sampler2D _SAMPLERNAME_Sampler;
#endif
`;
L.IncludesShadersStore[Xo] = Ho;
var jo = "fresnelFunction", Ko = `#ifdef FRESNEL
float computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)
{
float fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);
return clamp(fresnelTerm,0.,1.);
}
#endif
`;
L.IncludesShadersStore[jo] = Ko;
var Yo = "reflectionFunction", Zo = `vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{
float lon=atan(direction.z,direction.x);
float lat=acos(direction.y);
vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;
float s=sphereCoords.x*0.5+0.5;
float t=sphereCoords.y;
return vec3(s,t,0); 
}
vec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{
float lon=atan(direction.z,direction.x);
float lat=acos(direction.y);
vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;
float s=sphereCoords.x*0.5+0.5;
float t=sphereCoords.y;
return vec3(1.0-s,t,0); 
}
vec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{
vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);
vec3 r=normalize(reflect(cameraToVertex,worldNormal));
r=vec3(reflectionMatrix*vec4(r,0));
float lon=atan(r.z,r.x);
float lat=acos(r.y);
vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;
float s=sphereCoords.x*0.5+0.5;
float t=sphereCoords.y;
return vec3(s,t,0);
}
vec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)
{
vec3 viewDir=normalize(vec3(view*worldPos));
vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));
vec3 r=reflect(viewDir,viewNormal);
r=vec3(reflectionMatrix*vec4(r,0));
r.z=r.z-1.0;
float m=2.0*length(r);
return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);
}
vec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{
vec3 viewDir=worldPos.xyz-eyePosition;
vec3 coords=normalize(reflect(viewDir,worldNormal));
return vec3(reflectionMatrix*vec4(coords,1));
}
vec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{
vec3 viewDir=normalize(worldPos.xyz-eyePosition);
vec3 coords=reflect(viewDir,worldNormal);
coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;
}
vec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)
{
vec3 viewDir=normalize(worldPos.xyz-eyePosition);
vec3 coords=reflect(viewDir,worldNormal);
coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);
coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;
}
vec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)
{
return vec3(reflectionMatrix*(view*worldPos));
}
vec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)
{
return vec3(reflectionMatrix*vec4(positionW,1.));
}
#ifdef REFLECTION
vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);
return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);
return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(vPositionUVW,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3(0,0,0);
#endif
}
#endif
`;
L.IncludesShadersStore[Yo] = Zo;
var qo = "imageProcessingDeclaration", Qo = `#ifdef EXPOSURE
uniform float exposureLinear;
#endif
#ifdef CONTRAST
uniform float contrast;
#endif
#ifdef VIGNETTE
uniform vec2 vInverseScreenSize;
uniform vec4 vignetteSettings1;
uniform vec4 vignetteSettings2;
#endif
#ifdef COLORCURVES
uniform vec4 vCameraColorCurveNegative;
uniform vec4 vCameraColorCurveNeutral;
uniform vec4 vCameraColorCurvePositive;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
uniform highp sampler3D txColorTransform;
#else
uniform sampler2D txColorTransform;
#endif
uniform vec4 colorTransformSettings;
#endif
`;
L.IncludesShadersStore[qo] = Qo;
var $o = "imageProcessingFunctions", Jo = `#if defined(COLORGRADING) && !defined(COLORGRADING3D)
/** 
* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.
* sampler3dSetting.x=textureOffset (0.5/textureSize).
* sampler3dSetting.y=textureSize.
*/
#define inline
vec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)
{
float sliceSize=2.0*sampler3dSetting.x; 
#ifdef SAMPLER3DGREENDEPTH
float sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;
#else
float sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;
#endif
float sliceInteger=floor(sliceContinuous);
float sliceFraction=sliceContinuous-sliceInteger;
#ifdef SAMPLER3DGREENDEPTH
vec2 sliceUV=color.rb;
#else
vec2 sliceUV=color.rg;
#endif
sliceUV.x*=sliceSize;
sliceUV.x+=sliceInteger*sliceSize;
sliceUV=saturate(sliceUV);
vec4 slice0Color=texture2D(colorTransform,sliceUV);
sliceUV.x+=sliceSize;
sliceUV=saturate(sliceUV);
vec4 slice1Color=texture2D(colorTransform,sliceUV);
vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);
#ifdef SAMPLER3DBGRMAP
color.rgb=result.rgb;
#else
color.rgb=result.bgr;
#endif
return color;
}
#endif
#ifdef TONEMAPPING_ACES
const mat3 ACESInputMat=mat3(
vec3(0.59719,0.07600,0.02840),
vec3(0.35458,0.90834,0.13383),
vec3(0.04823,0.01566,0.83777)
);
const mat3 ACESOutputMat=mat3(
vec3( 1.60475,-0.10208,-0.00327),
vec3(-0.53108, 1.10813,-0.07276),
vec3(-0.07367,-0.00605, 1.07602)
);
vec3 RRTAndODTFit(vec3 v)
{
vec3 a=v*(v+0.0245786)-0.000090537;
vec3 b=v*(0.983729*v+0.4329510)+0.238081;
return a/b;
}
vec3 ACESFitted(vec3 color)
{
color=ACESInputMat*color;
color=RRTAndODTFit(color);
color=ACESOutputMat*color;
color=saturate(color);
return color;
}
#endif
vec4 applyImageProcessing(vec4 result) {
#ifdef EXPOSURE
result.rgb*=exposureLinear;
#endif
#ifdef VIGNETTE
vec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;
viewportXY=viewportXY*2.0-1.0;
vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);
float vignetteTerm=dot(vignetteXY1,vignetteXY1);
float vignette=pow(vignetteTerm,vignetteSettings2.w);
vec3 vignetteColor=vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
vec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);
result.rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
result.rgb=mix(vignetteColor,result.rgb,vignette);
#endif
#endif
#ifdef TONEMAPPING
#ifdef TONEMAPPING_ACES
result.rgb=ACESFitted(result.rgb);
#else
const float tonemappingCalibration=1.590579;
result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);
#endif
#endif
result.rgb=toGammaSpace(result.rgb);
result.rgb=saturate(result.rgb);
#ifdef CONTRAST
vec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);
if (contrast<1.0) {
result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);
} else {
result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);
}
#endif
#ifdef COLORGRADING
vec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;
#ifdef COLORGRADING3D
vec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;
#else
vec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;
#endif
result.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);
#endif
#ifdef COLORCURVES
float luma=getLuminance(result.rgb);
vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));
vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;
result.rgb*=colorCurve.rgb;
result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);
#endif
return result;
}`;
L.IncludesShadersStore[$o] = Jo;
var eu = "bumpFragmentMainFunctions", tu = `#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat4 normalMatrix;
#endif
vec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)
{
#ifdef NORMALXYSCALE
normal=normalize(normal*vec3(scale,scale,1.0));
#endif
return normalize(cotangentFrame*normal);
}
vec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)
{
return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);
}
mat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)
{
vec3 dp1=dFdx(p);
vec3 dp2=dFdy(p);
vec2 duv1=dFdx(uv);
vec2 duv2=dFdy(uv);
vec3 dp2perp=cross(dp2,normal);
vec3 dp1perp=cross(normal,dp1);
vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;
vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;
tangent*=tangentSpaceParams.x;
bitangent*=tangentSpaceParams.y;
float invmax=inversesqrt(max(dot(tangent,tangent),dot(bitangent,bitangent)));
return mat3(tangent*invmax,bitangent*invmax,normal);
}
#endif
`;
L.IncludesShadersStore[eu] = tu;
var ru = "bumpFragmentFunctions", iu = `#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const float minSamples=4.;
const float maxSamples=15.;
const int iMaxSamples=15;
vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {
float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;
parallaxLimit*=parallaxScale;
vec2 vOffsetDir=normalize(vViewDirCoT.xy);
vec2 vMaxOffset=vOffsetDir*parallaxLimit;
float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));
float stepSize=1.0/numSamples;
float currRayHeight=1.0;
vec2 vCurrOffset=vec2(0,0);
vec2 vLastOffset=vec2(0,0);
float lastSampledHeight=1.0;
float currSampledHeight=1.0;
for (int i=0; i<iMaxSamples; i++)
{
currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;
if (currSampledHeight>currRayHeight)
{
float delta1=currSampledHeight-currRayHeight;
float delta2=(currRayHeight+stepSize)-lastSampledHeight;
float ratio=delta1/(delta1+delta2);
vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;
break;
}
else
{
currRayHeight-=stepSize;
vLastOffset=vCurrOffset;
vCurrOffset+=stepSize*vMaxOffset;
lastSampledHeight=currSampledHeight;
}
}
return vCurrOffset;
}
vec2 parallaxOffset(vec3 viewDir,float heightScale)
{
float height=texture2D(bumpSampler,vBumpUV).w;
vec2 texCoordOffset=heightScale*viewDir.xy*height;
return -texCoordOffset;
}
#endif
`;
L.IncludesShadersStore[ru] = iu;
var nu = "logDepthDeclaration", au = `#ifdef LOGARITHMICDEPTH
uniform float logarithmicDepthConstant;
varying float vFragmentDepth;
#endif
`;
L.IncludesShadersStore[nu] = au;
var su = "fogFragmentDeclaration", ou = `#ifdef FOG
#define FOGMODE_NONE 0.
#define FOGMODE_EXP 1.
#define FOGMODE_EXP2 2.
#define FOGMODE_LINEAR 3.
#define E 2.71828
uniform vec4 vFogInfos;
uniform vec3 vFogColor;
varying vec3 vFogDistance;
float CalcFogFactor()
{
float fogCoeff=1.0;
float fogStart=vFogInfos.y;
float fogEnd=vFogInfos.z;
float fogDensity=vFogInfos.w;
float fogDistance=length(vFogDistance);
if (FOGMODE_LINEAR==vFogInfos.x)
{
fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);
}
else if (FOGMODE_EXP==vFogInfos.x)
{
fogCoeff=1.0/pow(E,fogDistance*fogDensity);
}
else if (FOGMODE_EXP2==vFogInfos.x)
{
fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);
}
return clamp(fogCoeff,0.0,1.0);
}
#endif
`;
L.IncludesShadersStore[su] = ou;
var uu = "oitFragment", fu = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
float fragDepth=gl_FragCoord.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
uint halfFloat=packHalf2x16(vec2(fragDepth));
vec2 full=unpackHalf2x16(halfFloat);
fragDepth=full.x;
#endif
ivec2 fragCoord=ivec2(gl_FragCoord.xy);
vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;
vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);
depth.rg=vec2(-MAX_DEPTH);
frontColor=lastFrontColor;
backColor=vec4(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
float furthestDepth=-lastDepth.x;
float nearestDepth=lastDepth.y;
#else
float nearestDepth=-lastDepth.x;
float furthestDepth=lastDepth.y;
#endif
float alphaMultiplier=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return;
}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
depth.rg=vec2(-fragDepth,fragDepth);
return;
}
#endif
`;
L.IncludesShadersStore[uu] = fu;
var lu = "bumpFragment", hu = `vec2 uvOffset=vec2(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
float normalScale=1.0;
#elif defined(BUMP)
float normalScale=vBumpInfos.y;
#else
float normalScale=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#elif defined(BUMP)
vec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;
mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);
#else
vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;
mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#else
vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;
mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));
#endif
#endif
#ifdef PARALLAX
mat3 invTBN=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
vec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);
vec2 detailNormalRG=detailColor.wy*2.0-1.0;
float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));
vec3 detailNormal=vec3(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
normalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);
normalW=normalize(mat3(normalMatrix)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);
#else
vec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal.xy*=vDetailInfos.z;
vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal.xy*=vDetailInfos.z;
bumpNormal+=vec3(0.0,0.0,1.0);
detailNormal*=vec3(-1.0,-1.0,1.0);
vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal.xy*=vDetailInfos.z;
normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);
#endif
`;
L.IncludesShadersStore[lu] = hu;
var cu = "depthPrePass", du = `#ifdef DEPTHPREPASS
gl_FragColor=vec4(0.,0.,0.,1.0);
return;
#endif
`;
L.IncludesShadersStore[cu] = du;
var pu = "lightFragment", _u = `#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
#ifdef PBR
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#ifdef HEMILIGHT{X}
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);
#elif defined(SS_TRANSLUCENCY)
info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);
#else
info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);
#endif
#ifdef SPECULARTERM
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#endif
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);
info.diffuse*=absorption;
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) 
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;
#else
diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {
index{X}=i;
break;
}
}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
float frustumLength=frustumLengths{X}[index{X}];
float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};
if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{
index{X}+=1;
float nextShadow=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;
shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else 
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`;
L.IncludesShadersStore[pu] = _u;
var gu = "logDepthFragment", vu = `#ifdef LOGARITHMICDEPTH
gl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;
#endif
`;
L.IncludesShadersStore[gu] = vu;
var mu = "fogFragment", yu = `#ifdef FOG
float fog=CalcFogFactor();
#ifdef PBR
fog=toLinearSpace(fog);
#endif
color.rgb=mix(vFogColor,color.rgb,fog);
#endif
`;
L.IncludesShadersStore[mu] = yu;
var bu = "defaultPixelShader", Eu = `#include<__decl__defaultFragment>
#if defined(BUMP) || !defined(NORMAL)
#extension GL_OES_standard_derivatives : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
#include<oitDeclaration>
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#define RECIPROCAL_PI2 0.15915494
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)
varying vec4 vColor;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#ifdef REFRACTION
#ifdef REFRACTIONMAP_3D
uniform samplerCube refractionCubeSampler;
#else
uniform sampler2D refraction2DSampler;
#endif
#endif
#if defined(SPECULARTERM)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)
#endif
#include<fresnelFunction>
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
uniform samplerCube reflectionCubeSampler;
#else
uniform sampler2D reflection2DSampler;
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#include<reflectionFunction>
#endif
#include<imageProcessingDeclaration>
#include<imageProcessingFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<oitFragment>
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
vec4 baseColor=vec4(1.,1.,1.,1.);
vec3 diffuseColor=vDiffuseColor.rgb;
float alpha=vDiffuseColor.a;
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));
#endif
#include<bumpFragment>
#ifdef TWOSIDEDLIGHTING
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
#ifdef DIFFUSE
baseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);
#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)
if (baseColor.a<alphaCutOff)
discard;
#endif
#ifdef ALPHAFROMDIFFUSE
alpha*=baseColor.a;
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
baseColor.rgb*=vDiffuseInfos.y;
#endif
#include<depthPrePass>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)
baseColor.rgb*=vColor.rgb;
#endif
#ifdef DETAIL
baseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);
#endif
#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE
vec3 baseAmbientColor=vec3(1.,1.,1.);
#ifdef AMBIENT
baseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;
#endif
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
#ifdef SPECULARTERM
float glossiness=vSpecularColor.a;
vec3 specularColor=vSpecularColor.rgb;
#ifdef SPECULAR
vec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);
specularColor=specularMapColor.rgb;
#ifdef GLOSSINESS
glossiness=glossiness*specularMapColor.a;
#endif
#endif
#else
float glossiness=0.;
#endif
vec3 diffuseBase=vec3(0.,0.,0.);
lightingInfo info;
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
float shadow=1.;
#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
#include<lightFragment>[0..maxSimultaneousLights]
vec4 refractionColor=vec4(0.,0.,0.,1.);
#ifdef REFRACTION
vec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));
#ifdef REFRACTIONMAP_3D
#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;
if (dot(refractionVector,viewDirectionW)<1.0) {
refractionColor=textureCube(refractionCubeSampler,refractionVector);
}
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));
vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;
refractionCoords.y=1.0-refractionCoords.y;
refractionColor=texture2D(refraction2DSampler,refractionCoords);
#endif
#ifdef RGBDREFRACTION
refractionColor.rgb=fromRGBD(refractionColor);
#endif
#ifdef IS_REFRACTION_LINEAR
refractionColor.rgb=toGammaSpace(refractionColor.rgb);
#endif
refractionColor.rgb*=vRefractionInfos.x;
#endif
vec4 reflectionColor=vec4(0.,0.,0.,1.);
#ifdef REFLECTION
vec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
vReflectionUVW.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
#ifdef ROUGHNESS
float bias=vReflectionInfos.y;
#ifdef SPECULARTERM
#ifdef SPECULAR
#ifdef GLOSSINESS
bias*=(1.0-specularMapColor.a);
#endif
#endif
#endif
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);
#else
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);
#endif
#else
vec2 coords=vReflectionUVW.xy;
#ifdef REFLECTIONMAP_PROJECTION
coords/=vReflectionUVW.z;
#endif
coords.y=1.0-coords.y;
reflectionColor=texture2D(reflection2DSampler,coords);
#endif
#ifdef RGBDREFLECTION
reflectionColor.rgb=fromRGBD(reflectionColor);
#endif
#ifdef IS_REFLECTION_LINEAR
reflectionColor.rgb=toGammaSpace(reflectionColor.rgb);
#endif
reflectionColor.rgb*=vReflectionInfos.x;
#ifdef REFLECTIONFRESNEL
float reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);
#ifdef REFLECTIONFRESNELFROMSPECULAR
#ifdef SPECULARTERM
reflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#endif
#endif
#ifdef REFRACTIONFRESNEL
float refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);
refractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#ifdef OPACITYRGB
opacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);
alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;
#else
alpha*=opacityMap.a*vOpacityInfos.y;
#endif
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR)
alpha*=vColor.a;
#endif
#ifdef OPACITYFRESNEL
float opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);
alpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;
#endif
#ifdef ALPHATEST
#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS
if (alpha<alphaCutOff)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
vec3 emissiveColor=vEmissiveColor;
#ifdef EMISSIVE
emissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;
#endif
#ifdef EMISSIVEFRESNEL
float emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);
emissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;
#endif
#ifdef DIFFUSEFRESNEL
float diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);
diffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;
#endif
#ifdef EMISSIVEASILLUMINATION
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
#ifdef LINKEMISSIVEWITHDIFFUSE
vec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#endif
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase*specularColor;
#ifdef SPECULAROVERALPHA
alpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#else
vec3 finalSpecular=vec3(0.0);
#endif
#ifdef REFLECTIONOVERALPHA
alpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#ifdef EMISSIVEASILLUMINATION
vec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);
#else
vec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);
#endif
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
color.rgb*=lightmapColor.rgb;
#else
color.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
#define CUSTOM_FRAGMENT_BEFORE_FOG
color.rgb=max(color.rgb,0.);
#include<logDepthFragment>
#include<fogFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
color.rgb=toLinearSpace(color.rgb);
#else
#ifdef IMAGEPROCESSING
color.rgb=toLinearSpace(color.rgb);
color=applyImageProcessing(color);
#endif
#endif
color.a*=visibility;
#ifdef PREMULTIPLYALPHA
color.rgb*=color.a;
#endif
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
float writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;
gl_FragData[0]=color; 
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;
vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;
vec2 velocity=abs(a-b);
velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;
gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_IRRADIANCE
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_NORMAL
gl_FragData[PREPASS_NORMAL_INDEX]=vec4((view*vec4(normalW,0.0)).rgb,writeGeometryInfo); 
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_REFLECTIVITY
#if defined(SPECULARTERM)
#if defined(SPECULAR)
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularMapColor)*writeGeometryInfo; 
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularColor,1.0)*writeGeometryInfo;
#endif
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=color;
#endif
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {
frontColor.rgb+=color.rgb*color.a*alphaMultiplier;
frontColor.a=1.0-alphaMultiplier*(1.0-color.a);
} else {
backColor+=color;
}
#endif
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
L.ShadersStore[bu] = Eu;
var Tu = "defaultVertexDeclaration", Su = `uniform mat4 viewProjection;
uniform mat4 view;
#ifdef DIFFUSE
uniform mat4 diffuseMatrix;
uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;
uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
uniform mat4 lightmapMatrix;
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;
uniform mat4 specularMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;
uniform mat4 bumpMatrix;
#endif
#ifdef REFLECTION
uniform mat4 reflectionMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
uniform mat4 detailMatrix;
#endif
#define ADDITIONAL_VERTEX_DECLARATION
`;
L.IncludesShadersStore[Tu] = Su;
var Mu = "uvAttributeDeclaration", Au = `#ifdef UV{X}
attribute vec2 uv{X};
#endif
`;
L.IncludesShadersStore[Mu] = Au;
var Ru = "prePassVertexDeclaration", Pu = `#ifdef PREPASS
#ifdef PREPASS_DEPTH
varying vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
uniform mat4 previousViewProjection;
varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;
#endif
#endif
`;
L.IncludesShadersStore[Ru] = Pu;
var Cu = "samplerVertexDeclaration", xu = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying vec2 v_VARYINGNAME_UV;
#endif
`;
L.IncludesShadersStore[Cu] = xu;
var Du = "bumpVertexDeclaration", Iu = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#endif
`;
L.IncludesShadersStore[Du] = Iu;
var Ou = "fogVertexDeclaration", Fu = `#ifdef FOG
varying vec3 vFogDistance;
#endif
`;
L.IncludesShadersStore[Ou] = Fu;
var wu = "lightVxFragmentDeclaration", Lu = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};
uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};
uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};
uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#endif
`;
L.IncludesShadersStore[wu] = Lu;
var Nu = "lightVxUboDeclaration", Bu = `#ifdef LIGHT{X}
uniform Light{X}
{
vec4 vLightData;
vec4 vLightDiffuse;
vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;
vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;
vec2 depthValues;
} light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
L.IncludesShadersStore[Nu] = Bu;
var Uu = "prePassVertex", Vu = `#ifdef PREPASS_DEPTH
vViewPos=(view*worldPos).rgb;
#endif
#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;
previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
`;
L.IncludesShadersStore[Uu] = Vu;
var ku = "uvVariableDeclaration", Wu = `#if !defined(UV{X}) && defined(MAINUV{X})
vec2 uv{X}=vec2(0.,0.);
#endif
#ifdef MAINUV{X}
vMainUV{X}=uv{X};
#endif
`;
L.IncludesShadersStore[ku] = Wu;
var zu = "samplerVertexImplementation", Gu = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (v_INFONAME_==0.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));
}
#ifdef UV2
else if (v_INFONAME_==1.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));
}
#endif
#ifdef UV3
else if (v_INFONAME_==2.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));
}
#endif
#ifdef UV4
else if (v_INFONAME_==3.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));
}
#endif
#ifdef UV5
else if (v_INFONAME_==4.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));
}
#endif
#ifdef UV6
else if (v_INFONAME_==5.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));
}
#endif
#endif
`;
L.IncludesShadersStore[zu] = Gu;
var Xu = "bumpVertex", Hu = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
vec3 tbnNormal=normalize(normalUpdated);
vec3 tbnTangent=normalize(tangentUpdated.xyz);
vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;
vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);
#endif
#endif
`;
L.IncludesShadersStore[Xu] = Hu;
var ju = "fogVertex", Ku = `#ifdef FOG
vFogDistance=(view*worldPos).xyz;
#endif
`;
L.IncludesShadersStore[ju] = Ku;
var Yu = "shadowsVertex", Zu = `#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vPositionFromCamera{X}=view*worldPos;
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {
vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
}
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vPositionFromLight{X}=lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`;
L.IncludesShadersStore[Yu] = Zu;
var qu = "vertexColorMixing", Qu = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)
vColor=vec4(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vColor*=color;
#else
vColor.rgb*=color.rgb;
#endif
#endif
#ifdef INSTANCESCOLOR
vColor*=instanceColor;
#endif
#endif
`;
L.IncludesShadersStore[qu] = Qu;
var $u = "pointCloudVertex", Ju = `#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
`;
L.IncludesShadersStore[$u] = Ju;
var ef = "logDepthVertex", tf = `#ifdef LOGARITHMICDEPTH
vFragmentDepth=1.0+gl_Position.w;
gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;
#endif
`;
L.IncludesShadersStore[ef] = tf;
var rf = "defaultVertexShader", nf = `#include<__decl__defaultVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<mainUVVaryingDeclaration>[1..7]
#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#if defined(SPECULARTERM)
#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)
#endif
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));
vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {
gl_Position=viewProjection*worldPos;
} else {
gl_Position=viewProjectionR*worldPos;
}
#else
gl_Position=viewProjection*worldPos;
#endif
vPositionW=vec3(worldPos);
#include<prePassVertex>
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#include<uvVariableDeclaration>[2..7]
#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#if defined(SPECULARTERM)
#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)
#endif
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#include<pointCloudVertex>
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`;
L.ShadersStore[rf] = nf;
var af = function() {
  function i(e) {
    this._plugins = [], this._activePlugins = [], this._activePluginsForExtraEvents = [], this._material = e, this._scene = e.getScene(), this._engine = this._scene.getEngine();
  }
  return i.prototype._addPlugin = function(e) {
    for (var t = 0; t < this._plugins.length; ++t)
      if (this._plugins[t].name === e.name)
        throw 'Plugin "'.concat(e.name, '" already added to the material "').concat(this._material.name, '"!');
    if (this._material._uniformBufferLayoutBuilt)
      throw 'The plugin "'.concat(e.name, `" can't be added to the material "`).concat(this._material.name, '" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.');
    var r = e.getClassName();
    i._MaterialPluginClassToMainDefine[r] || (i._MaterialPluginClassToMainDefine[r] = "MATERIALPLUGIN_" + ++i._MaterialPluginCounter), this._material._callbackPluginEventGeneric = this._handlePluginEvent.bind(this), this._plugins.push(e), this._plugins.sort(function(u, f) {
      return u.priority - f.priority;
    }), this._codeInjectionPoints = {};
    var n = {};
    n[i._MaterialPluginClassToMainDefine[r]] = {
      type: "boolean",
      default: !0
    };
    for (var a = 0, s = this._plugins; a < s.length; a++) {
      var o = s[a];
      o.collectDefines(n), this._collectPointNames("vertex", o.getCustomCode("vertex")), this._collectPointNames("fragment", o.getCustomCode("fragment"));
    }
    this._defineNamesFromPlugins = n;
  }, i.prototype._activatePlugin = function(e) {
    this._activePlugins.indexOf(e) === -1 && (this._activePlugins.push(e), this._activePlugins.sort(function(t, r) {
      return t.priority - r.priority;
    }), this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this), this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this), this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this), e.registerForExtraEvents && (this._activePluginsForExtraEvents.push(e), this._activePluginsForExtraEvents.sort(function(t, r) {
      return t.priority - r.priority;
    }), this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this), this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this), this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this)));
  }, i.prototype.getPlugin = function(e) {
    for (var t = 0; t < this._plugins.length; ++t)
      if (this._plugins[t].name === e)
        return this._plugins[t];
    return null;
  }, i.prototype._handlePluginEventIsReadyForSubMesh = function(e) {
    for (var t = !0, r = 0, n = this._activePlugins; r < n.length; r++) {
      var a = n[r];
      t = t && a.isReadyForSubMesh(e.defines, this._scene, this._engine, e.subMesh);
    }
    e.isReadyForSubMesh = t;
  }, i.prototype._handlePluginEventPrepareDefines = function(e) {
    for (var t = 0, r = this._activePlugins; t < r.length; t++) {
      var n = r[t];
      n.prepareDefines(e.defines, this._scene, e.mesh);
    }
  }, i.prototype._handlePluginEventHardBindForSubMesh = function(e) {
    for (var t = 0, r = this._activePluginsForExtraEvents; t < r.length; t++) {
      var n = r[t];
      n.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, e.subMesh);
    }
  }, i.prototype._handlePluginEventBindForSubMesh = function(e) {
    for (var t = 0, r = this._activePlugins; t < r.length; t++) {
      var n = r[t];
      n.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, e.subMesh);
    }
  }, i.prototype._handlePluginEventHasRenderTargetTextures = function(e) {
    for (var t = !1, r = 0, n = this._activePluginsForExtraEvents; r < n.length; r++) {
      var a = n[r];
      if (t = a.hasRenderTargetTextures(), t)
        break;
    }
    e.hasRenderTargetTextures = t;
  }, i.prototype._handlePluginEventFillRenderTargetTextures = function(e) {
    for (var t = 0, r = this._activePluginsForExtraEvents; t < r.length; t++) {
      var n = r[t];
      n.fillRenderTargetTextures(e.renderTargets);
    }
  }, i.prototype._handlePluginEvent = function(e, t) {
    var r, n, a;
    switch (e) {
      case Ce.GetActiveTextures: {
        for (var s = t, o = 0, u = this._activePlugins; o < u.length; o++) {
          var f = u[o];
          f.getActiveTextures(s.activeTextures);
        }
        break;
      }
      case Ce.GetAnimatables: {
        for (var s = t, l = 0, h = this._activePlugins; l < h.length; l++) {
          var f = h[l];
          f.getAnimatables(s.animatables);
        }
        break;
      }
      case Ce.HasTexture: {
        for (var s = t, c = !1, d = 0, p = this._activePlugins; d < p.length; d++) {
          var f = p[d];
          if (c = f.hasTexture(s.texture), c)
            break;
        }
        s.hasTexture = c;
        break;
      }
      case Ce.Disposed: {
        for (var s = t, g = 0, _ = this._plugins; g < _.length; g++) {
          var f = _[g];
          f.dispose(s.forceDisposeTextures);
        }
        break;
      }
      case Ce.GetDefineNames: {
        var s = t;
        s.defineNames = this._defineNamesFromPlugins;
        break;
      }
      case Ce.PrepareEffect: {
        for (var s = t, v = 0, y = this._activePlugins; v < y.length; v++) {
          var f = y[v];
          s.fallbackRank = f.addFallbacks(s.defines, s.fallbacks, s.fallbackRank);
        }
        this._uniformList.length > 0 && (r = s.uniforms).push.apply(r, this._uniformList), this._samplerList.length > 0 && (n = s.samplers).push.apply(n, this._samplerList), this._uboList.length > 0 && (a = s.uniformBuffersNames).push.apply(a, this._uboList), s.customCode = this._injectCustomCode(s.customCode);
        break;
      }
      case Ce.PrepareUniformBuffer: {
        var s = t;
        this._uboDeclaration = "", this._vertexDeclaration = "", this._fragmentDeclaration = "", this._uniformList = [], this._samplerList = [], this._uboList = [];
        for (var E = 0, R = this._plugins; E < R.length; E++) {
          var f = R[E], M = f.getUniforms();
          if (M) {
            if (M.ubo)
              for (var C = 0, A = M.ubo; C < A.length; C++) {
                var S = A[C];
                s.ubo.addUniform(S.name, S.size), this._uboDeclaration += "".concat(S.type, " ").concat(S.name, `;\r
`), this._uniformList.push(S.name);
              }
            M.vertex && (this._vertexDeclaration += M.vertex + `\r
`), M.fragment && (this._fragmentDeclaration += M.fragment + `\r
`);
          }
          f.getSamplers(this._samplerList), f.getUniformBuffersNames(this._uboList);
        }
        break;
      }
    }
  }, i.prototype._collectPointNames = function(e, t) {
    if (!!t)
      for (var r in t)
        this._codeInjectionPoints[e] || (this._codeInjectionPoints[e] = {}), this._codeInjectionPoints[e][r] = !0;
  }, i.prototype._injectCustomCode = function(e) {
    var t = this;
    return function(r, n) {
      var a;
      e && (n = e(r, n)), t._uboDeclaration && (n = n.replace("#define ADDITIONAL_UBO_DECLARATION", t._uboDeclaration)), t._vertexDeclaration && (n = n.replace("#define ADDITIONAL_VERTEX_DECLARATION", t._vertexDeclaration)), t._fragmentDeclaration && (n = n.replace("#define ADDITIONAL_FRAGMENT_DECLARATION", t._fragmentDeclaration));
      var s = (a = t._codeInjectionPoints) === null || a === void 0 ? void 0 : a[r];
      if (!s)
        return n;
      for (var o in s) {
        for (var u = "", f = 0, l = t._activePlugins; f < l.length; f++) {
          var h = l[f], c = h.getCustomCode(r);
          c != null && c[o] && (u += c[o] + `\r
`);
        }
        if (u.length > 0)
          if (o.charAt(0) === "!")
            for (var d = new RegExp(o.substring(1), "g"), p = d.exec(n); p !== null; )
              n = n.replace(p[0], u), p = d.exec(n);
          else {
            var g = "#define " + o;
            n = n.replace(g, `\r
` + u + `\r
` + g);
          }
      }
      return n;
    };
  }, i._MaterialPluginClassToMainDefine = {}, i._MaterialPluginCounter = 0, i;
}(), sf = function() {
  function i(e, t, r, n, a, s) {
    a === void 0 && (a = !0), s === void 0 && (s = !1), this.priority = 500, this.registerForExtraEvents = !1, this._material = e, this.name = t, this.priority = r, e.pluginManager || (e.pluginManager = new af(e)), this._pluginDefineNames = n, this._pluginManager = e.pluginManager, a && this._pluginManager._addPlugin(this), s && this._enable(!0), this.markAllDefinesAsDirty = e._dirtyCallbacks[63];
  }
  return i.prototype._enable = function(e) {
    e && this._pluginManager._activatePlugin(this);
  }, i.prototype.getClassName = function() {
    return "MaterialPluginBase";
  }, i.prototype.isReadyForSubMesh = function(e, t, r, n) {
    return !0;
  }, i.prototype.hardBindForSubMesh = function(e, t, r, n) {
  }, i.prototype.bindForSubMesh = function(e, t, r, n) {
  }, i.prototype.dispose = function(e) {
  }, i.prototype.getCustomCode = function(e) {
    return null;
  }, i.prototype.collectDefines = function(e) {
    if (!!this._pluginDefineNames)
      for (var t = 0, r = Object.keys(this._pluginDefineNames); t < r.length; t++) {
        var n = r[t];
        if (n[0] !== "_") {
          var a = typeof this._pluginDefineNames[n];
          e[n] = {
            type: a === "number" ? "number" : a === "string" ? "string" : a === "boolean" ? "boolean" : "object",
            default: this._pluginDefineNames[n]
          };
        }
      }
  }, i.prototype.prepareDefines = function(e, t, r) {
  }, i.prototype.hasTexture = function(e) {
    return !1;
  }, i.prototype.hasRenderTargetTextures = function() {
    return !1;
  }, i.prototype.fillRenderTargetTextures = function(e) {
  }, i.prototype.getActiveTextures = function(e) {
  }, i.prototype.getAnimatables = function(e) {
  }, i.prototype.addFallbacks = function(e, t, r) {
    return r;
  }, i.prototype.getSamplers = function(e) {
  }, i.prototype.getUniformBuffersNames = function(e) {
  }, i.prototype.getUniforms = function() {
    return {};
  }, i.prototype.copyTo = function(e) {
    $.Clone(function() {
      return e;
    }, this);
  }, i.prototype.serialize = function() {
    return $.Serialize(this);
  }, i.prototype.parse = function(e, t, r) {
    var n = this;
    $.Parse(function() {
      return n;
    }, e, t, r);
  }, T([
    P()
  ], i.prototype, "name", void 0), T([
    P()
  ], i.prototype, "priority", void 0), T([
    P()
  ], i.prototype, "registerForExtraEvents", void 0), i;
}(), of = function(i) {
  K(e, i);
  function e() {
    var t = i !== null && i.apply(this, arguments) || this;
    return t.DETAIL = !1, t.DETAILDIRECTUV = 0, t.DETAIL_NORMALBLENDMETHOD = 0, t;
  }
  return e;
}(Fr), uf = function(i) {
  K(e, i);
  function e(t, r) {
    r === void 0 && (r = !0);
    var n = i.call(this, t, "DetailMap", 140, new of(), r) || this;
    return n._texture = null, n.diffuseBlendLevel = 1, n.roughnessBlendLevel = 1, n.bumpLevel = 1, n._normalBlendMethod = Ie.MATERIAL_NORMALBLENDMETHOD_WHITEOUT, n._isEnabled = !1, n.isEnabled = !1, n._internalMarkAllSubMeshesAsTexturesDirty = t._dirtyCallbacks[1], n;
  }
  return e.prototype._markAllSubMeshesAsTexturesDirty = function() {
    this._enable(this._isEnabled), this._internalMarkAllSubMeshesAsTexturesDirty();
  }, e.prototype.isReadyForSubMesh = function(t, r, n) {
    return this._isEnabled ? !(t._areTexturesDirty && r.texturesEnabled && n.getCaps().standardDerivatives && this._texture && he.DetailTextureEnabled && !this._texture.isReady()) : !0;
  }, e.prototype.prepareDefines = function(t, r) {
    if (this._isEnabled) {
      t.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
      var n = r.getEngine();
      t._areTexturesDirty && (n.getCaps().standardDerivatives && this._texture && he.DetailTextureEnabled && this._isEnabled ? (j.PrepareDefinesForMergedUV(this._texture, t, "DETAIL"), t.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod) : t.DETAIL = !1);
    } else
      t.DETAIL = !1;
  }, e.prototype.bindForSubMesh = function(t, r) {
    if (!!this._isEnabled) {
      var n = this._material.isFrozen;
      (!t.useUbo || !n || !t.isSync) && this._texture && he.DetailTextureEnabled && (t.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel), j.BindTextureMatrix(this._texture, t, "detail")), r.texturesEnabled && this._texture && he.DetailTextureEnabled && t.setTexture("detailSampler", this._texture);
    }
  }, e.prototype.hasTexture = function(t) {
    return this._texture === t;
  }, e.prototype.getActiveTextures = function(t) {
    this._texture && t.push(this._texture);
  }, e.prototype.getAnimatables = function(t) {
    this._texture && this._texture.animations && this._texture.animations.length > 0 && t.push(this._texture);
  }, e.prototype.dispose = function(t) {
    var r;
    t && ((r = this._texture) === null || r === void 0 || r.dispose());
  }, e.prototype.getClassName = function() {
    return "DetailMapConfiguration";
  }, e.prototype.getSamplers = function(t) {
    t.push("detailSampler");
  }, e.prototype.getUniforms = function() {
    return {
      ubo: [
        { name: "vDetailInfos", size: 4, type: "vec4" },
        { name: "detailMatrix", size: 16, type: "mat4" }
      ]
    };
  }, T([
    je("detailTexture"),
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "texture", void 0), T([
    P()
  ], e.prototype, "diffuseBlendLevel", void 0), T([
    P()
  ], e.prototype, "roughnessBlendLevel", void 0), T([
    P()
  ], e.prototype, "bumpLevel", void 0), T([
    P(),
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "normalBlendMethod", void 0), T([
    P(),
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "isEnabled", void 0), e;
}(sf), Jr = { effect: null, subMesh: null }, ff = function(i) {
  K(e, i);
  function e(t) {
    var r = i.call(this, t) || this;
    return r.MAINUV1 = !1, r.MAINUV2 = !1, r.MAINUV3 = !1, r.MAINUV4 = !1, r.MAINUV5 = !1, r.MAINUV6 = !1, r.DIFFUSE = !1, r.DIFFUSEDIRECTUV = 0, r.BAKED_VERTEX_ANIMATION_TEXTURE = !1, r.AMBIENT = !1, r.AMBIENTDIRECTUV = 0, r.OPACITY = !1, r.OPACITYDIRECTUV = 0, r.OPACITYRGB = !1, r.REFLECTION = !1, r.EMISSIVE = !1, r.EMISSIVEDIRECTUV = 0, r.SPECULAR = !1, r.SPECULARDIRECTUV = 0, r.BUMP = !1, r.BUMPDIRECTUV = 0, r.PARALLAX = !1, r.PARALLAXOCCLUSION = !1, r.SPECULAROVERALPHA = !1, r.CLIPPLANE = !1, r.CLIPPLANE2 = !1, r.CLIPPLANE3 = !1, r.CLIPPLANE4 = !1, r.CLIPPLANE5 = !1, r.CLIPPLANE6 = !1, r.ALPHATEST = !1, r.DEPTHPREPASS = !1, r.ALPHAFROMDIFFUSE = !1, r.POINTSIZE = !1, r.FOG = !1, r.SPECULARTERM = !1, r.DIFFUSEFRESNEL = !1, r.OPACITYFRESNEL = !1, r.REFLECTIONFRESNEL = !1, r.REFRACTIONFRESNEL = !1, r.EMISSIVEFRESNEL = !1, r.FRESNEL = !1, r.NORMAL = !1, r.TANGENT = !1, r.UV1 = !1, r.UV2 = !1, r.UV3 = !1, r.UV4 = !1, r.UV5 = !1, r.UV6 = !1, r.VERTEXCOLOR = !1, r.VERTEXALPHA = !1, r.NUM_BONE_INFLUENCERS = 0, r.BonesPerMesh = 0, r.BONETEXTURE = !1, r.BONES_VELOCITY_ENABLED = !1, r.INSTANCES = !1, r.THIN_INSTANCES = !1, r.INSTANCESCOLOR = !1, r.GLOSSINESS = !1, r.ROUGHNESS = !1, r.EMISSIVEASILLUMINATION = !1, r.LINKEMISSIVEWITHDIFFUSE = !1, r.REFLECTIONFRESNELFROMSPECULAR = !1, r.LIGHTMAP = !1, r.LIGHTMAPDIRECTUV = 0, r.OBJECTSPACE_NORMALMAP = !1, r.USELIGHTMAPASSHADOWMAP = !1, r.REFLECTIONMAP_3D = !1, r.REFLECTIONMAP_SPHERICAL = !1, r.REFLECTIONMAP_PLANAR = !1, r.REFLECTIONMAP_CUBIC = !1, r.USE_LOCAL_REFLECTIONMAP_CUBIC = !1, r.USE_LOCAL_REFRACTIONMAP_CUBIC = !1, r.REFLECTIONMAP_PROJECTION = !1, r.REFLECTIONMAP_SKYBOX = !1, r.REFLECTIONMAP_EXPLICIT = !1, r.REFLECTIONMAP_EQUIRECTANGULAR = !1, r.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, r.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1, r.REFLECTIONMAP_OPPOSITEZ = !1, r.INVERTCUBICMAP = !1, r.LOGARITHMICDEPTH = !1, r.REFRACTION = !1, r.REFRACTIONMAP_3D = !1, r.REFLECTIONOVERALPHA = !1, r.TWOSIDEDLIGHTING = !1, r.SHADOWFLOAT = !1, r.MORPHTARGETS = !1, r.MORPHTARGETS_NORMAL = !1, r.MORPHTARGETS_TANGENT = !1, r.MORPHTARGETS_UV = !1, r.NUM_MORPH_INFLUENCERS = 0, r.MORPHTARGETS_TEXTURE = !1, r.NONUNIFORMSCALING = !1, r.PREMULTIPLYALPHA = !1, r.ALPHATEST_AFTERALLALPHACOMPUTATIONS = !1, r.ALPHABLEND = !0, r.PREPASS = !1, r.PREPASS_IRRADIANCE = !1, r.PREPASS_IRRADIANCE_INDEX = -1, r.PREPASS_ALBEDO_SQRT = !1, r.PREPASS_ALBEDO_SQRT_INDEX = -1, r.PREPASS_DEPTH = !1, r.PREPASS_DEPTH_INDEX = -1, r.PREPASS_NORMAL = !1, r.PREPASS_NORMAL_INDEX = -1, r.PREPASS_POSITION = !1, r.PREPASS_POSITION_INDEX = -1, r.PREPASS_VELOCITY = !1, r.PREPASS_VELOCITY_INDEX = -1, r.PREPASS_REFLECTIVITY = !1, r.PREPASS_REFLECTIVITY_INDEX = -1, r.SCENE_MRT_COUNT = 0, r.RGBDLIGHTMAP = !1, r.RGBDREFLECTION = !1, r.RGBDREFRACTION = !1, r.IMAGEPROCESSING = !1, r.VIGNETTE = !1, r.VIGNETTEBLENDMODEMULTIPLY = !1, r.VIGNETTEBLENDMODEOPAQUE = !1, r.TONEMAPPING = !1, r.TONEMAPPING_ACES = !1, r.CONTRAST = !1, r.COLORCURVES = !1, r.COLORGRADING = !1, r.COLORGRADING3D = !1, r.SAMPLER3DGREENDEPTH = !1, r.SAMPLER3DBGRMAP = !1, r.IMAGEPROCESSINGPOSTPROCESS = !1, r.SKIPFINALCOLORCLAMP = !1, r.MULTIVIEW = !1, r.ORDER_INDEPENDENT_TRANSPARENCY = !1, r.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !1, r.IS_REFLECTION_LINEAR = !1, r.IS_REFRACTION_LINEAR = !1, r.EXPOSURE = !1, r.rebuild(), r;
  }
  return e.prototype.setReflectionMode = function(t) {
    for (var r = [
      "REFLECTIONMAP_CUBIC",
      "REFLECTIONMAP_EXPLICIT",
      "REFLECTIONMAP_PLANAR",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_SKYBOX",
      "REFLECTIONMAP_SPHERICAL",
      "REFLECTIONMAP_EQUIRECTANGULAR",
      "REFLECTIONMAP_EQUIRECTANGULAR_FIXED",
      "REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"
    ], n = 0, a = r; n < a.length; n++) {
      var s = a[n];
      this[s] = s === t;
    }
  }, e;
}(Fr), or = function(i) {
  K(e, i);
  function e(t, r) {
    var n = i.call(this, t, r) || this;
    return n._diffuseTexture = null, n._ambientTexture = null, n._opacityTexture = null, n._reflectionTexture = null, n._emissiveTexture = null, n._specularTexture = null, n._bumpTexture = null, n._lightmapTexture = null, n._refractionTexture = null, n.ambientColor = new ye(0, 0, 0), n.diffuseColor = new ye(1, 1, 1), n.specularColor = new ye(1, 1, 1), n.emissiveColor = new ye(0, 0, 0), n.specularPower = 64, n._useAlphaFromDiffuseTexture = !1, n._useEmissiveAsIllumination = !1, n._linkEmissiveWithDiffuse = !1, n._useSpecularOverAlpha = !1, n._useReflectionOverAlpha = !1, n._disableLighting = !1, n._useObjectSpaceNormalMap = !1, n._useParallax = !1, n._useParallaxOcclusion = !1, n.parallaxScaleBias = 0.05, n._roughness = 0, n.indexOfRefraction = 0.98, n.invertRefractionY = !0, n.alphaCutOff = 0.4, n._useLightmapAsShadowmap = !1, n._useReflectionFresnelFromSpecular = !1, n._useGlossinessFromSpecularMapAlpha = !1, n._maxSimultaneousLights = 4, n._invertNormalMapX = !1, n._invertNormalMapY = !1, n._twoSidedLighting = !1, n._renderTargets = new ke(16), n._worldViewProjectionMatrix = I.Zero(), n._globalAmbientColor = new ye(0, 0, 0), n._cacheHasRenderTargetTextures = !1, n.detailMap = new uf(n), n._attachImageProcessingConfiguration(null), n.prePassConfiguration = new $r(), n.getRenderTargetTextures = function() {
      return n._renderTargets.reset(), e.ReflectionTextureEnabled && n._reflectionTexture && n._reflectionTexture.isRenderTarget && n._renderTargets.push(n._reflectionTexture), e.RefractionTextureEnabled && n._refractionTexture && n._refractionTexture.isRenderTarget && n._renderTargets.push(n._refractionTexture), n._eventInfo.renderTargets = n._renderTargets, n._callbackPluginEventFillRenderTargetTextures(n._eventInfo), n._renderTargets;
    }, n;
  }
  return Object.defineProperty(e.prototype, "imageProcessingConfiguration", {
    get: function() {
      return this._imageProcessingConfiguration;
    },
    set: function(t) {
      this._attachImageProcessingConfiguration(t), this._markAllSubMeshesAsTexturesDirty();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._attachImageProcessingConfiguration = function(t) {
    var r = this;
    t !== this._imageProcessingConfiguration && (this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), t ? this._imageProcessingConfiguration = t : this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration, this._imageProcessingConfiguration && (this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function() {
      r._markAllSubMeshesAsImageProcessingDirty();
    })));
  }, Object.defineProperty(e.prototype, "isPrePassCapable", {
    get: function() {
      return !this.disableDepthWrite;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "cameraColorCurvesEnabled", {
    get: function() {
      return this.imageProcessingConfiguration.colorCurvesEnabled;
    },
    set: function(t) {
      this.imageProcessingConfiguration.colorCurvesEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "cameraColorGradingEnabled", {
    get: function() {
      return this.imageProcessingConfiguration.colorGradingEnabled;
    },
    set: function(t) {
      this.imageProcessingConfiguration.colorGradingEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "cameraToneMappingEnabled", {
    get: function() {
      return this._imageProcessingConfiguration.toneMappingEnabled;
    },
    set: function(t) {
      this._imageProcessingConfiguration.toneMappingEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "cameraExposure", {
    get: function() {
      return this._imageProcessingConfiguration.exposure;
    },
    set: function(t) {
      this._imageProcessingConfiguration.exposure = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "cameraContrast", {
    get: function() {
      return this._imageProcessingConfiguration.contrast;
    },
    set: function(t) {
      this._imageProcessingConfiguration.contrast = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "cameraColorGradingTexture", {
    get: function() {
      return this._imageProcessingConfiguration.colorGradingTexture;
    },
    set: function(t) {
      this._imageProcessingConfiguration.colorGradingTexture = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "cameraColorCurves", {
    get: function() {
      return this._imageProcessingConfiguration.colorCurves;
    },
    set: function(t) {
      this._imageProcessingConfiguration.colorCurves = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "canRenderToMRT", {
    get: function() {
      return !0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "hasRenderTargetTextures", {
    get: function() {
      return e.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget || e.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget ? !0 : this._cacheHasRenderTargetTextures;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getClassName = function() {
    return "StandardMaterial";
  }, Object.defineProperty(e.prototype, "useLogarithmicDepth", {
    get: function() {
      return this._useLogarithmicDepth;
    },
    set: function(t) {
      this._useLogarithmicDepth = t && this.getScene().getEngine().getCaps().fragmentDepthSupported, this._markAllSubMeshesAsMiscDirty();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.needAlphaBlending = function() {
    return this._disableAlphaBlending ? !1 : this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
  }, e.prototype.needAlphaTesting = function() {
    return this._forceAlphaTest ? !0 : this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Ie.MATERIAL_ALPHATEST);
  }, e.prototype._shouldUseAlphaFromDiffuseTexture = function() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Ie.MATERIAL_OPAQUE;
  }, e.prototype._hasAlphaChannel = function() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._opacityTexture != null;
  }, e.prototype.getAlphaTestTexture = function() {
    return this._diffuseTexture;
  }, e.prototype.isReadyForSubMesh = function(t, r, n) {
    if (n === void 0 && (n = !1), this._uniformBufferLayoutBuilt || this.buildUniformLayout(), r.effect && this.isFrozen && r.effect._wasPreviouslyReady)
      return !0;
    r.materialDefines || (this._callbackPluginEventGeneric(Ce.GetDefineNames, this._eventInfo), r.materialDefines = new ff(this._eventInfo.defineNames));
    var a = this.getScene(), s = r.materialDefines;
    if (this._isReadyForSubMesh(r))
      return !0;
    var o = a.getEngine();
    s._needNormals = j.PrepareDefinesForLights(a, t, s, !0, this._maxSimultaneousLights, this._disableLighting), j.PrepareDefinesForMultiview(a, s);
    var u = this.needAlphaBlendingForMesh(t) && this.getScene().useOrderIndependentTransparency;
    if (j.PrepareDefinesForPrePass(a, s, this.canRenderToMRT && !u), j.PrepareDefinesForOIT(a, s, u), s._areTexturesDirty) {
      this._eventInfo.hasRenderTargetTextures = !1, this._callbackPluginEventHasRenderTargetTextures(this._eventInfo), this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures, s._needUVs = !1;
      for (var f = 1; f <= 6; ++f)
        s["MAINUV" + f] = !1;
      if (a.texturesEnabled) {
        if (this._diffuseTexture && e.DiffuseTextureEnabled)
          if (this._diffuseTexture.isReadyOrNotBlocking())
            j.PrepareDefinesForMergedUV(this._diffuseTexture, s, "DIFFUSE");
          else
            return !1;
        else
          s.DIFFUSE = !1;
        if (this._ambientTexture && e.AmbientTextureEnabled)
          if (this._ambientTexture.isReadyOrNotBlocking())
            j.PrepareDefinesForMergedUV(this._ambientTexture, s, "AMBIENT");
          else
            return !1;
        else
          s.AMBIENT = !1;
        if (this._opacityTexture && e.OpacityTextureEnabled)
          if (this._opacityTexture.isReadyOrNotBlocking())
            j.PrepareDefinesForMergedUV(this._opacityTexture, s, "OPACITY"), s.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
          else
            return !1;
        else
          s.OPACITY = !1;
        if (this._reflectionTexture && e.ReflectionTextureEnabled)
          if (this._reflectionTexture.isReadyOrNotBlocking()) {
            switch (s._needNormals = !0, s.REFLECTION = !0, s.ROUGHNESS = this._roughness > 0, s.REFLECTIONOVERALPHA = this._useReflectionOverAlpha, s.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === ee.INVCUBIC_MODE, s.REFLECTIONMAP_3D = this._reflectionTexture.isCube, s.REFLECTIONMAP_OPPOSITEZ = s.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ, s.RGBDREFLECTION = this._reflectionTexture.isRGBD, this._reflectionTexture.coordinatesMode) {
              case ee.EXPLICIT_MODE:
                s.setReflectionMode("REFLECTIONMAP_EXPLICIT");
                break;
              case ee.PLANAR_MODE:
                s.setReflectionMode("REFLECTIONMAP_PLANAR");
                break;
              case ee.PROJECTION_MODE:
                s.setReflectionMode("REFLECTIONMAP_PROJECTION");
                break;
              case ee.SKYBOX_MODE:
                s.setReflectionMode("REFLECTIONMAP_SKYBOX");
                break;
              case ee.SPHERICAL_MODE:
                s.setReflectionMode("REFLECTIONMAP_SPHERICAL");
                break;
              case ee.EQUIRECTANGULAR_MODE:
                s.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR");
                break;
              case ee.FIXED_EQUIRECTANGULAR_MODE:
                s.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
                break;
              case ee.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                s.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
                break;
              case ee.CUBIC_MODE:
              case ee.INVCUBIC_MODE:
              default:
                s.setReflectionMode("REFLECTIONMAP_CUBIC");
                break;
            }
            s.USE_LOCAL_REFLECTIONMAP_CUBIC = !!this._reflectionTexture.boundingBoxSize;
          } else
            return !1;
        else
          s.REFLECTION = !1, s.REFLECTIONMAP_OPPOSITEZ = !1;
        if (this._emissiveTexture && e.EmissiveTextureEnabled)
          if (this._emissiveTexture.isReadyOrNotBlocking())
            j.PrepareDefinesForMergedUV(this._emissiveTexture, s, "EMISSIVE");
          else
            return !1;
        else
          s.EMISSIVE = !1;
        if (this._lightmapTexture && e.LightmapTextureEnabled)
          if (this._lightmapTexture.isReadyOrNotBlocking())
            j.PrepareDefinesForMergedUV(this._lightmapTexture, s, "LIGHTMAP"), s.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap, s.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
          else
            return !1;
        else
          s.LIGHTMAP = !1;
        if (this._specularTexture && e.SpecularTextureEnabled)
          if (this._specularTexture.isReadyOrNotBlocking())
            j.PrepareDefinesForMergedUV(this._specularTexture, s, "SPECULAR"), s.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;
          else
            return !1;
        else
          s.SPECULAR = !1;
        if (a.getEngine().getCaps().standardDerivatives && this._bumpTexture && e.BumpTextureEnabled) {
          if (this._bumpTexture.isReady())
            j.PrepareDefinesForMergedUV(this._bumpTexture, s, "BUMP"), s.PARALLAX = this._useParallax, s.PARALLAXOCCLUSION = this._useParallaxOcclusion;
          else
            return !1;
          s.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
        } else
          s.BUMP = !1;
        if (this._refractionTexture && e.RefractionTextureEnabled)
          if (this._refractionTexture.isReadyOrNotBlocking())
            s._needUVs = !0, s.REFRACTION = !0, s.REFRACTIONMAP_3D = this._refractionTexture.isCube, s.RGBDREFRACTION = this._refractionTexture.isRGBD, s.USE_LOCAL_REFRACTIONMAP_CUBIC = !!this._refractionTexture.boundingBoxSize;
          else
            return !1;
        else
          s.REFRACTION = !1;
        s.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;
      } else
        s.DIFFUSE = !1, s.AMBIENT = !1, s.OPACITY = !1, s.REFLECTION = !1, s.EMISSIVE = !1, s.LIGHTMAP = !1, s.BUMP = !1, s.REFRACTION = !1;
      s.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture(), s.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination, s.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse, s.SPECULAROVERALPHA = this._useSpecularOverAlpha, s.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8, s.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null, s.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(t);
    }
    if (this._eventInfo.isReadyForSubMesh = !0, this._eventInfo.defines = s, this._callbackPluginEventIsReadyForSubMesh(this._eventInfo), !this._eventInfo.isReadyForSubMesh)
      return !1;
    if (s._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady())
        return !1;
      this._imageProcessingConfiguration.prepareDefines(s), s.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace, s.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;
    }
    if (s._areFresnelDirty && (e.FresnelEnabled ? (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) && (s.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled, s.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled, s.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled, s.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular, s.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled, s.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled, s._needNormals = !0, s.FRESNEL = !0) : s.FRESNEL = !1), j.PrepareDefinesForMisc(t, a, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(t) || this._forceAlphaTest, s), j.PrepareDefinesForAttributes(t, s, !0, !0, !0), j.PrepareDefinesForFrameBoundValues(a, o, s, n, null, r.getRenderingMesh().hasThinInstances), this._eventInfo.defines = s, this._eventInfo.mesh = t, this._callbackPluginEventPrepareDefines(this._eventInfo), s.isDirty) {
      var l = s._areLightsDisposed;
      s.markAsProcessed();
      var h = new yi();
      s.REFLECTION && h.addFallback(0, "REFLECTION"), s.SPECULAR && h.addFallback(0, "SPECULAR"), s.BUMP && h.addFallback(0, "BUMP"), s.PARALLAX && h.addFallback(1, "PARALLAX"), s.PARALLAXOCCLUSION && h.addFallback(0, "PARALLAXOCCLUSION"), s.SPECULAROVERALPHA && h.addFallback(0, "SPECULAROVERALPHA"), s.FOG && h.addFallback(1, "FOG"), s.POINTSIZE && h.addFallback(0, "POINTSIZE"), s.LOGARITHMICDEPTH && h.addFallback(0, "LOGARITHMICDEPTH"), j.HandleFallbacksForShadows(s, h, this._maxSimultaneousLights), s.SPECULARTERM && h.addFallback(0, "SPECULARTERM"), s.DIFFUSEFRESNEL && h.addFallback(1, "DIFFUSEFRESNEL"), s.OPACITYFRESNEL && h.addFallback(2, "OPACITYFRESNEL"), s.REFLECTIONFRESNEL && h.addFallback(3, "REFLECTIONFRESNEL"), s.EMISSIVEFRESNEL && h.addFallback(4, "EMISSIVEFRESNEL"), s.FRESNEL && h.addFallback(4, "FRESNEL"), s.MULTIVIEW && h.addFallback(0, "MULTIVIEW");
      var c = [m.PositionKind];
      s.NORMAL && c.push(m.NormalKind), s.TANGENT && c.push(m.TangentKind);
      for (var f = 1; f <= 6; ++f)
        s["UV" + f] && c.push("uv".concat(f === 1 ? "" : f));
      s.VERTEXCOLOR && c.push(m.ColorKind), j.PrepareAttributesForBones(c, t, s, h), j.PrepareAttributesForInstances(c, s), j.PrepareAttributesForMorphTargets(c, t, s), j.PrepareAttributesForBakedVertexAnimation(c, t, s);
      var d = "default", p = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vAmbientColor",
        "vDiffuseColor",
        "vSpecularColor",
        "vEmissiveColor",
        "visibility",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "vAmbientInfos",
        "vOpacityInfos",
        "vReflectionInfos",
        "vEmissiveInfos",
        "vSpecularInfos",
        "vBumpInfos",
        "vLightmapInfos",
        "vRefractionInfos",
        "mBones",
        "vClipPlane",
        "vClipPlane2",
        "vClipPlane3",
        "vClipPlane4",
        "vClipPlane5",
        "vClipPlane6",
        "diffuseMatrix",
        "ambientMatrix",
        "opacityMatrix",
        "reflectionMatrix",
        "emissiveMatrix",
        "specularMatrix",
        "bumpMatrix",
        "normalMatrix",
        "lightmapMatrix",
        "refractionMatrix",
        "diffuseLeftColor",
        "diffuseRightColor",
        "opacityParts",
        "reflectionLeftColor",
        "reflectionRightColor",
        "emissiveLeftColor",
        "emissiveRightColor",
        "refractionLeftColor",
        "refractionRightColor",
        "vReflectionPosition",
        "vReflectionSize",
        "vRefractionPosition",
        "vRefractionSize",
        "logarithmicDepthConstant",
        "vTangentSpaceParams",
        "alphaCutOff",
        "boneTextureWidth",
        "morphTargetTextureInfo",
        "morphTargetTextureIndices"
      ], g = [
        "diffuseSampler",
        "ambientSampler",
        "opacitySampler",
        "reflectionCubeSampler",
        "reflection2DSampler",
        "emissiveSampler",
        "specularSampler",
        "bumpSampler",
        "lightmapSampler",
        "refractionCubeSampler",
        "refraction2DSampler",
        "boneSampler",
        "morphTargets",
        "oitDepthSampler",
        "oitFrontColorSampler"
      ], _ = ["Material", "Scene", "Mesh"];
      this._eventInfo.fallbacks = h, this._eventInfo.fallbackRank = 0, this._eventInfo.defines = s, this._eventInfo.uniforms = p, this._eventInfo.samplers = g, this._eventInfo.uniformBuffersNames = _, this._eventInfo.customCode = void 0, this._callbackPluginEventGeneric(Ce.PrepareEffect, this._eventInfo), $r.AddUniforms(p), $r.AddSamplers(g), Vt && (Vt.PrepareUniforms(p, s), Vt.PrepareSamplers(g, s)), j.PrepareUniformsAndSamplersList({
        uniformsNames: p,
        uniformBuffersNames: _,
        samplers: g,
        defines: s,
        maxSimultaneousLights: this._maxSimultaneousLights
      });
      var v = {};
      this.customShaderNameResolve && (d = this.customShaderNameResolve(d, p, _, g, s, c, v));
      var y = s.toString(), E = r.effect, R = a.getEngine().createEffect(d, {
        attributes: c,
        uniformsNames: p,
        uniformBuffersNames: _,
        samplers: g,
        defines: y,
        fallbacks: h,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: s.NUM_MORPH_INFLUENCERS },
        processFinalCode: v.processFinalCode,
        processCodeAfterIncludes: this._eventInfo.customCode,
        multiTarget: s.PREPASS
      }, o);
      if (R)
        if (this._onEffectCreatedObservable && (Jr.effect = R, Jr.subMesh = r, this._onEffectCreatedObservable.notifyObservers(Jr)), this.allowShaderHotSwapping && E && !R.isReady()) {
          if (R = E, s.markAsUnprocessed(), l)
            return s._areLightsDisposed = !0, !1;
        } else
          a.resetCachedMaterial(), r.setEffect(R, s, this._materialContext);
    }
    return !r.effect || !r.effect.isReady() ? !1 : (s._renderId = a.getRenderId(), r.effect._wasPreviouslyReady = !0, !0);
  }, e.prototype.buildUniformLayout = function() {
    var t = this._uniformBuffer;
    t.addUniform("diffuseLeftColor", 4), t.addUniform("diffuseRightColor", 4), t.addUniform("opacityParts", 4), t.addUniform("reflectionLeftColor", 4), t.addUniform("reflectionRightColor", 4), t.addUniform("refractionLeftColor", 4), t.addUniform("refractionRightColor", 4), t.addUniform("emissiveLeftColor", 4), t.addUniform("emissiveRightColor", 4), t.addUniform("vDiffuseInfos", 2), t.addUniform("vAmbientInfos", 2), t.addUniform("vOpacityInfos", 2), t.addUniform("vReflectionInfos", 2), t.addUniform("vReflectionPosition", 3), t.addUniform("vReflectionSize", 3), t.addUniform("vEmissiveInfos", 2), t.addUniform("vLightmapInfos", 2), t.addUniform("vSpecularInfos", 2), t.addUniform("vBumpInfos", 3), t.addUniform("diffuseMatrix", 16), t.addUniform("ambientMatrix", 16), t.addUniform("opacityMatrix", 16), t.addUniform("reflectionMatrix", 16), t.addUniform("emissiveMatrix", 16), t.addUniform("lightmapMatrix", 16), t.addUniform("specularMatrix", 16), t.addUniform("bumpMatrix", 16), t.addUniform("vTangentSpaceParams", 2), t.addUniform("pointSize", 1), t.addUniform("alphaCutOff", 1), t.addUniform("refractionMatrix", 16), t.addUniform("vRefractionInfos", 4), t.addUniform("vRefractionPosition", 3), t.addUniform("vRefractionSize", 3), t.addUniform("vSpecularColor", 4), t.addUniform("vEmissiveColor", 3), t.addUniform("vDiffuseColor", 4), t.addUniform("vAmbientColor", 3), i.prototype.buildUniformLayout.call(this);
  }, e.prototype.bindForSubMesh = function(t, r, n) {
    var a, s = this.getScene(), o = n.materialDefines;
    if (!!o) {
      var u = n.effect;
      if (!!u) {
        this._activeEffect = u, r.getMeshUniformBuffer().bindToEffect(u, "Mesh"), r.transferToEffect(t), this._uniformBuffer.bindToEffect(u, "Material"), this.prePassConfiguration.bindForSubMesh(this._activeEffect, s, r, t, this.isFrozen), this._eventInfo.subMesh = n, this._callbackPluginEventHardBindForSubMesh(this._eventInfo), o.OBJECTSPACE_NORMALMAP && (t.toNormalMatrix(this._normalMatrix), this.bindOnlyNormalMatrix(this._normalMatrix));
        var f = this._mustRebind(s, u, r.visibility);
        j.BindBonesParameters(r, u);
        var l = this._uniformBuffer;
        if (f) {
          if (this.bindViewProjection(u), !l.useUbo || !this.isFrozen || !l.isSync) {
            if (e.FresnelEnabled && o.FRESNEL && (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled && (l.updateColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power), l.updateColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias)), this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled && l.updateColor4("opacityParts", new ye(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power), this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled && (l.updateColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power), l.updateColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias)), this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled && (l.updateColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power), l.updateColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias)), this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled && (l.updateColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power), l.updateColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias))), s.texturesEnabled) {
              if (this._diffuseTexture && e.DiffuseTextureEnabled && (l.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level), j.BindTextureMatrix(this._diffuseTexture, l, "diffuse")), this._ambientTexture && e.AmbientTextureEnabled && (l.updateFloat2("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level), j.BindTextureMatrix(this._ambientTexture, l, "ambient")), this._opacityTexture && e.OpacityTextureEnabled && (l.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level), j.BindTextureMatrix(this._opacityTexture, l, "opacity")), this._hasAlphaChannel() && l.updateFloat("alphaCutOff", this.alphaCutOff), this._reflectionTexture && e.ReflectionTextureEnabled && (l.updateFloat2("vReflectionInfos", this._reflectionTexture.level, this.roughness), l.updateMatrix("reflectionMatrix", this._reflectionTexture.getReflectionTextureMatrix()), this._reflectionTexture.boundingBoxSize)) {
                var h = this._reflectionTexture;
                l.updateVector3("vReflectionPosition", h.boundingBoxPosition), l.updateVector3("vReflectionSize", h.boundingBoxSize);
              }
              if (this._emissiveTexture && e.EmissiveTextureEnabled && (l.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level), j.BindTextureMatrix(this._emissiveTexture, l, "emissive")), this._lightmapTexture && e.LightmapTextureEnabled && (l.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level), j.BindTextureMatrix(this._lightmapTexture, l, "lightmap")), this._specularTexture && e.SpecularTextureEnabled && (l.updateFloat2("vSpecularInfos", this._specularTexture.coordinatesIndex, this._specularTexture.level), j.BindTextureMatrix(this._specularTexture, l, "specular")), this._bumpTexture && s.getEngine().getCaps().standardDerivatives && e.BumpTextureEnabled && (l.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias), j.BindTextureMatrix(this._bumpTexture, l, "bump"), s._mirroredCameraPosition ? l.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1) : l.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1)), this._refractionTexture && e.RefractionTextureEnabled) {
                var c = 1;
                if (this._refractionTexture.isCube || (l.updateMatrix("refractionMatrix", this._refractionTexture.getReflectionTextureMatrix()), this._refractionTexture.depth && (c = this._refractionTexture.depth)), l.updateFloat4("vRefractionInfos", this._refractionTexture.level, this.indexOfRefraction, c, this.invertRefractionY ? -1 : 1), this._refractionTexture.boundingBoxSize) {
                  var h = this._refractionTexture;
                  l.updateVector3("vRefractionPosition", h.boundingBoxPosition), l.updateVector3("vRefractionSize", h.boundingBoxSize);
                }
              }
            }
            this.pointsCloud && l.updateFloat("pointSize", this.pointSize), o.SPECULARTERM && l.updateColor4("vSpecularColor", this.specularColor, this.specularPower), l.updateColor3("vEmissiveColor", e.EmissiveTextureEnabled ? this.emissiveColor : ye.BlackReadOnly), l.updateColor4("vDiffuseColor", this.diffuseColor, this.alpha), s.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor), l.updateColor3("vAmbientColor", this._globalAmbientColor);
          }
          s.texturesEnabled && (this._diffuseTexture && e.DiffuseTextureEnabled && u.setTexture("diffuseSampler", this._diffuseTexture), this._ambientTexture && e.AmbientTextureEnabled && u.setTexture("ambientSampler", this._ambientTexture), this._opacityTexture && e.OpacityTextureEnabled && u.setTexture("opacitySampler", this._opacityTexture), this._reflectionTexture && e.ReflectionTextureEnabled && (this._reflectionTexture.isCube ? u.setTexture("reflectionCubeSampler", this._reflectionTexture) : u.setTexture("reflection2DSampler", this._reflectionTexture)), this._emissiveTexture && e.EmissiveTextureEnabled && u.setTexture("emissiveSampler", this._emissiveTexture), this._lightmapTexture && e.LightmapTextureEnabled && u.setTexture("lightmapSampler", this._lightmapTexture), this._specularTexture && e.SpecularTextureEnabled && u.setTexture("specularSampler", this._specularTexture), this._bumpTexture && s.getEngine().getCaps().standardDerivatives && e.BumpTextureEnabled && u.setTexture("bumpSampler", this._bumpTexture), this._refractionTexture && e.RefractionTextureEnabled && (this._refractionTexture.isCube ? u.setTexture("refractionCubeSampler", this._refractionTexture) : u.setTexture("refraction2DSampler", this._refractionTexture))), this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(r) && this.getScene().depthPeelingRenderer.bind(u), this._eventInfo.subMesh = n, this._callbackPluginEventBindForSubMesh(this._eventInfo), j.BindClipPlane(u, s), this.bindEyePosition(u);
        } else
          s.getEngine()._features.needToAlwaysBindUniformBuffers && (this._needToBindSceneUbo = !0);
        (f || !this.isFrozen) && (s.lightsEnabled && !this._disableLighting && j.BindLights(s, r, u, o, this._maxSimultaneousLights), (s.fogEnabled && r.applyFog && s.fogMode !== te.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture || r.receiveShadows || o.PREPASS) && this.bindView(u), j.BindFogParameters(s, r, u), o.NUM_MORPH_INFLUENCERS && j.BindMorphTargetParameters(r, u), o.BAKED_VERTEX_ANIMATION_TEXTURE && ((a = r.bakedVertexAnimationManager) === null || a === void 0 || a.bind(u, o.INSTANCES)), this.useLogarithmicDepth && j.BindLogDepth(o, u, s), this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess && this._imageProcessingConfiguration.bind(this._activeEffect)), this._afterBind(r, this._activeEffect), l.update();
      }
    }
  }, e.prototype.getAnimatables = function() {
    var t = i.prototype.getAnimatables.call(this);
    return this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0 && t.push(this._diffuseTexture), this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0 && t.push(this._ambientTexture), this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0 && t.push(this._opacityTexture), this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0 && t.push(this._reflectionTexture), this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0 && t.push(this._emissiveTexture), this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0 && t.push(this._specularTexture), this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0 && t.push(this._bumpTexture), this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0 && t.push(this._lightmapTexture), this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0 && t.push(this._refractionTexture), t;
  }, e.prototype.getActiveTextures = function() {
    var t = i.prototype.getActiveTextures.call(this);
    return this._diffuseTexture && t.push(this._diffuseTexture), this._ambientTexture && t.push(this._ambientTexture), this._opacityTexture && t.push(this._opacityTexture), this._reflectionTexture && t.push(this._reflectionTexture), this._emissiveTexture && t.push(this._emissiveTexture), this._specularTexture && t.push(this._specularTexture), this._bumpTexture && t.push(this._bumpTexture), this._lightmapTexture && t.push(this._lightmapTexture), this._refractionTexture && t.push(this._refractionTexture), t;
  }, e.prototype.hasTexture = function(t) {
    return !!(i.prototype.hasTexture.call(this, t) || this._diffuseTexture === t || this._ambientTexture === t || this._opacityTexture === t || this._reflectionTexture === t || this._emissiveTexture === t || this._specularTexture === t || this._bumpTexture === t || this._lightmapTexture === t || this._refractionTexture === t);
  }, e.prototype.dispose = function(t, r) {
    var n, a, s, o, u, f, l, h, c;
    r && ((n = this._diffuseTexture) === null || n === void 0 || n.dispose(), (a = this._ambientTexture) === null || a === void 0 || a.dispose(), (s = this._opacityTexture) === null || s === void 0 || s.dispose(), (o = this._reflectionTexture) === null || o === void 0 || o.dispose(), (u = this._emissiveTexture) === null || u === void 0 || u.dispose(), (f = this._specularTexture) === null || f === void 0 || f.dispose(), (l = this._bumpTexture) === null || l === void 0 || l.dispose(), (h = this._lightmapTexture) === null || h === void 0 || h.dispose(), (c = this._refractionTexture) === null || c === void 0 || c.dispose()), this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), i.prototype.dispose.call(this, t, r);
  }, e.prototype.clone = function(t) {
    var r = this, n = $.Clone(function() {
      return new e(t, r.getScene());
    }, this);
    return n.name = t, n.id = t, this.stencil.copyTo(n.stencil), n;
  }, e.Parse = function(t, r, n) {
    var a = $.Parse(function() {
      return new e(t.name, r);
    }, t, r, n);
    return t.stencil && a.stencil.parse(t.stencil, r, n), a;
  }, Object.defineProperty(e, "DiffuseTextureEnabled", {
    get: function() {
      return he.DiffuseTextureEnabled;
    },
    set: function(t) {
      he.DiffuseTextureEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "DetailTextureEnabled", {
    get: function() {
      return he.DetailTextureEnabled;
    },
    set: function(t) {
      he.DetailTextureEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "AmbientTextureEnabled", {
    get: function() {
      return he.AmbientTextureEnabled;
    },
    set: function(t) {
      he.AmbientTextureEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "OpacityTextureEnabled", {
    get: function() {
      return he.OpacityTextureEnabled;
    },
    set: function(t) {
      he.OpacityTextureEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "ReflectionTextureEnabled", {
    get: function() {
      return he.ReflectionTextureEnabled;
    },
    set: function(t) {
      he.ReflectionTextureEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "EmissiveTextureEnabled", {
    get: function() {
      return he.EmissiveTextureEnabled;
    },
    set: function(t) {
      he.EmissiveTextureEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "SpecularTextureEnabled", {
    get: function() {
      return he.SpecularTextureEnabled;
    },
    set: function(t) {
      he.SpecularTextureEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "BumpTextureEnabled", {
    get: function() {
      return he.BumpTextureEnabled;
    },
    set: function(t) {
      he.BumpTextureEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "LightmapTextureEnabled", {
    get: function() {
      return he.LightmapTextureEnabled;
    },
    set: function(t) {
      he.LightmapTextureEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "RefractionTextureEnabled", {
    get: function() {
      return he.RefractionTextureEnabled;
    },
    set: function(t) {
      he.RefractionTextureEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "ColorGradingTextureEnabled", {
    get: function() {
      return he.ColorGradingTextureEnabled;
    },
    set: function(t) {
      he.ColorGradingTextureEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e, "FresnelEnabled", {
    get: function() {
      return he.FresnelEnabled;
    },
    set: function(t) {
      he.FresnelEnabled = t;
    },
    enumerable: !1,
    configurable: !0
  }), T([
    je("diffuseTexture")
  ], e.prototype, "_diffuseTexture", void 0), T([
    ne("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], e.prototype, "diffuseTexture", void 0), T([
    je("ambientTexture")
  ], e.prototype, "_ambientTexture", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "ambientTexture", void 0), T([
    je("opacityTexture")
  ], e.prototype, "_opacityTexture", void 0), T([
    ne("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], e.prototype, "opacityTexture", void 0), T([
    je("reflectionTexture")
  ], e.prototype, "_reflectionTexture", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "reflectionTexture", void 0), T([
    je("emissiveTexture")
  ], e.prototype, "_emissiveTexture", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "emissiveTexture", void 0), T([
    je("specularTexture")
  ], e.prototype, "_specularTexture", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "specularTexture", void 0), T([
    je("bumpTexture")
  ], e.prototype, "_bumpTexture", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "bumpTexture", void 0), T([
    je("lightmapTexture")
  ], e.prototype, "_lightmapTexture", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "lightmapTexture", void 0), T([
    je("refractionTexture")
  ], e.prototype, "_refractionTexture", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "refractionTexture", void 0), T([
    At("ambient")
  ], e.prototype, "ambientColor", void 0), T([
    At("diffuse")
  ], e.prototype, "diffuseColor", void 0), T([
    At("specular")
  ], e.prototype, "specularColor", void 0), T([
    At("emissive")
  ], e.prototype, "emissiveColor", void 0), T([
    P()
  ], e.prototype, "specularPower", void 0), T([
    P("useAlphaFromDiffuseTexture")
  ], e.prototype, "_useAlphaFromDiffuseTexture", void 0), T([
    ne("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], e.prototype, "useAlphaFromDiffuseTexture", void 0), T([
    P("useEmissiveAsIllumination")
  ], e.prototype, "_useEmissiveAsIllumination", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "useEmissiveAsIllumination", void 0), T([
    P("linkEmissiveWithDiffuse")
  ], e.prototype, "_linkEmissiveWithDiffuse", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "linkEmissiveWithDiffuse", void 0), T([
    P("useSpecularOverAlpha")
  ], e.prototype, "_useSpecularOverAlpha", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "useSpecularOverAlpha", void 0), T([
    P("useReflectionOverAlpha")
  ], e.prototype, "_useReflectionOverAlpha", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "useReflectionOverAlpha", void 0), T([
    P("disableLighting")
  ], e.prototype, "_disableLighting", void 0), T([
    ne("_markAllSubMeshesAsLightsDirty")
  ], e.prototype, "disableLighting", void 0), T([
    P("useObjectSpaceNormalMap")
  ], e.prototype, "_useObjectSpaceNormalMap", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "useObjectSpaceNormalMap", void 0), T([
    P("useParallax")
  ], e.prototype, "_useParallax", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "useParallax", void 0), T([
    P("useParallaxOcclusion")
  ], e.prototype, "_useParallaxOcclusion", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "useParallaxOcclusion", void 0), T([
    P()
  ], e.prototype, "parallaxScaleBias", void 0), T([
    P("roughness")
  ], e.prototype, "_roughness", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "roughness", void 0), T([
    P()
  ], e.prototype, "indexOfRefraction", void 0), T([
    P()
  ], e.prototype, "invertRefractionY", void 0), T([
    P()
  ], e.prototype, "alphaCutOff", void 0), T([
    P("useLightmapAsShadowmap")
  ], e.prototype, "_useLightmapAsShadowmap", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "useLightmapAsShadowmap", void 0), T([
    jt("diffuseFresnelParameters")
  ], e.prototype, "_diffuseFresnelParameters", void 0), T([
    ne("_markAllSubMeshesAsFresnelDirty")
  ], e.prototype, "diffuseFresnelParameters", void 0), T([
    jt("opacityFresnelParameters")
  ], e.prototype, "_opacityFresnelParameters", void 0), T([
    ne("_markAllSubMeshesAsFresnelAndMiscDirty")
  ], e.prototype, "opacityFresnelParameters", void 0), T([
    jt("reflectionFresnelParameters")
  ], e.prototype, "_reflectionFresnelParameters", void 0), T([
    ne("_markAllSubMeshesAsFresnelDirty")
  ], e.prototype, "reflectionFresnelParameters", void 0), T([
    jt("refractionFresnelParameters")
  ], e.prototype, "_refractionFresnelParameters", void 0), T([
    ne("_markAllSubMeshesAsFresnelDirty")
  ], e.prototype, "refractionFresnelParameters", void 0), T([
    jt("emissiveFresnelParameters")
  ], e.prototype, "_emissiveFresnelParameters", void 0), T([
    ne("_markAllSubMeshesAsFresnelDirty")
  ], e.prototype, "emissiveFresnelParameters", void 0), T([
    P("useReflectionFresnelFromSpecular")
  ], e.prototype, "_useReflectionFresnelFromSpecular", void 0), T([
    ne("_markAllSubMeshesAsFresnelDirty")
  ], e.prototype, "useReflectionFresnelFromSpecular", void 0), T([
    P("useGlossinessFromSpecularMapAlpha")
  ], e.prototype, "_useGlossinessFromSpecularMapAlpha", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "useGlossinessFromSpecularMapAlpha", void 0), T([
    P("maxSimultaneousLights")
  ], e.prototype, "_maxSimultaneousLights", void 0), T([
    ne("_markAllSubMeshesAsLightsDirty")
  ], e.prototype, "maxSimultaneousLights", void 0), T([
    P("invertNormalMapX")
  ], e.prototype, "_invertNormalMapX", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "invertNormalMapX", void 0), T([
    P("invertNormalMapY")
  ], e.prototype, "_invertNormalMapY", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "invertNormalMapY", void 0), T([
    P("twoSidedLighting")
  ], e.prototype, "_twoSidedLighting", void 0), T([
    ne("_markAllSubMeshesAsTexturesDirty")
  ], e.prototype, "twoSidedLighting", void 0), T([
    P()
  ], e.prototype, "useLogarithmicDepth", null), e;
}(mn);
Ne("BABYLON.StandardMaterial", or);
te.DefaultMaterialFactory = function(i) {
  return new or("default material", i);
};
var lf = "imageProcessingCompatibility", hf = `#ifdef IMAGEPROCESSINGPOSTPROCESS
gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(2.2));
#endif
`;
L.IncludesShadersStore[lf] = hf;
var cf = "shadowOnlyPixelShader", df = `precision highp float;
uniform vec4 vEyePosition;
uniform float alpha;
uniform vec3 shadowColor;
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
vec3 diffuseBase=vec3(0.,0.,0.);
lightingInfo info;
float shadow=1.;
float glossiness=0.;
#include<lightFragment>[0..1]
vec4 color=vec4(shadowColor,(1.0-clamp(shadow,0.,1.))*alpha);
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;
L.ShadersStore[cf] = df;
var pf = "shadowOnlyVertexShader", _f = `precision highp float;
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;
uniform mat4 viewProjection;
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);
gl_Position=viewProjection*worldPos;
vPositionW=vec3(worldPos);
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
L.ShadersStore[pf] = _f;
var gf = function(i) {
  K(e, i);
  function e() {
    var t = i.call(this) || this;
    return t.CLIPPLANE = !1, t.CLIPPLANE2 = !1, t.CLIPPLANE3 = !1, t.CLIPPLANE4 = !1, t.CLIPPLANE5 = !1, t.CLIPPLANE6 = !1, t.POINTSIZE = !1, t.FOG = !1, t.NORMAL = !1, t.NUM_BONE_INFLUENCERS = 0, t.BonesPerMesh = 0, t.INSTANCES = !1, t.IMAGEPROCESSINGPOSTPROCESS = !1, t.SKIPFINALCOLORCLAMP = !1, t.rebuild(), t;
  }
  return e;
}(Fr), yn = function(i) {
  K(e, i);
  function e(t, r) {
    var n = i.call(this, t, r) || this;
    return n._needAlphaBlending = !0, n.shadowColor = ye.Black(), n;
  }
  return e.prototype.needAlphaBlending = function() {
    return this._needAlphaBlending;
  }, e.prototype.needAlphaTesting = function() {
    return !1;
  }, e.prototype.getAlphaTestTexture = function() {
    return null;
  }, Object.defineProperty(e.prototype, "activeLight", {
    get: function() {
      return this._activeLight;
    },
    set: function(t) {
      this._activeLight = t;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._getFirstShadowLightForMesh = function(t) {
    for (var r = 0, n = t.lightSources; r < n.length; r++) {
      var a = n[r];
      if (a.shadowEnabled)
        return a;
    }
    return null;
  }, e.prototype.isReadyForSubMesh = function(t, r, n) {
    var a;
    if (this.isFrozen && r.effect && r.effect._wasPreviouslyReady)
      return !0;
    r.materialDefines || (r.materialDefines = new gf());
    var s = r.materialDefines, o = this.getScene();
    if (this._isReadyForSubMesh(r))
      return !0;
    var u = o.getEngine();
    if (this._activeLight)
      for (var f = 0, l = t.lightSources; f < l.length; f++) {
        var h = l[f];
        if (h.shadowEnabled) {
          if (this._activeLight === h)
            break;
          var c = t.lightSources.indexOf(this._activeLight);
          c !== -1 && (t.lightSources.splice(c, 1), t.lightSources.splice(0, 0, this._activeLight));
          break;
        }
      }
    j.PrepareDefinesForFrameBoundValues(o, u, s, !!n), j.PrepareDefinesForMisc(t, o, !1, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(t), s), s._needNormals = j.PrepareDefinesForLights(o, t, s, !1, 1);
    var d = (a = this._getFirstShadowLightForMesh(t)) === null || a === void 0 ? void 0 : a.getShadowGenerator();
    if (this._needAlphaBlending = !0, d && d.getClassName && d.getClassName() === "CascadedShadowGenerator") {
      var p = d;
      this._needAlphaBlending = !p.autoCalcDepthBounds;
    }
    if (j.PrepareDefinesForAttributes(t, s, !1, !0), s.isDirty) {
      s.markAsProcessed(), o.resetCachedMaterial();
      var g = new yi();
      s.FOG && g.addFallback(1, "FOG"), j.HandleFallbacksForShadows(s, g, 1), s.NUM_BONE_INFLUENCERS > 0 && g.addCPUSkinningFallback(0, t), s.IMAGEPROCESSINGPOSTPROCESS = o.imageProcessingConfiguration.applyByPostProcess;
      var _ = [m.PositionKind];
      s.NORMAL && _.push(m.NormalKind), j.PrepareAttributesForBones(_, t, s, g), j.PrepareAttributesForInstances(_, s);
      var v = "shadowOnly", y = s.toString(), E = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "alpha",
        "shadowColor",
        "mBones",
        "vClipPlane",
        "vClipPlane2",
        "vClipPlane3",
        "vClipPlane4",
        "vClipPlane5",
        "vClipPlane6"
      ], R = new Array(), M = new Array();
      j.PrepareUniformsAndSamplersList({
        uniformsNames: E,
        uniformBuffersNames: M,
        samplers: R,
        defines: s,
        maxSimultaneousLights: 1
      }), r.setEffect(o.getEngine().createEffect(v, {
        attributes: _,
        uniformsNames: E,
        uniformBuffersNames: M,
        samplers: R,
        defines: y,
        fallbacks: g,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 1 }
      }, u), s, this._materialContext);
    }
    return !r.effect || !r.effect.isReady() ? !1 : (s._renderId = o.getRenderId(), r.effect._wasPreviouslyReady = !0, !0);
  }, e.prototype.bindForSubMesh = function(t, r, n) {
    var a = this.getScene(), s = n.materialDefines;
    if (!!s) {
      var o = n.effect;
      if (!!o) {
        if (this._activeEffect = o, this.bindOnlyWorldMatrix(t), this._activeEffect.setMatrix("viewProjection", a.getTransformMatrix()), j.BindBonesParameters(r, this._activeEffect), this._mustRebind(a, o) && (j.BindClipPlane(this._activeEffect, a), this.pointsCloud && this._activeEffect.setFloat("pointSize", this.pointSize), this._activeEffect.setFloat("alpha", this.alpha), this._activeEffect.setColor3("shadowColor", this.shadowColor), a.bindEyePosition(o)), a.lightsEnabled) {
          j.BindLights(a, r, this._activeEffect, s, 1);
          var u = this._getFirstShadowLightForMesh(r);
          u && (u._renderId = -1);
        }
        (a.fogEnabled && r.applyFog && a.fogMode !== te.FOGMODE_NONE || s.SHADOWCSM0) && this._activeEffect.setMatrix("view", a.getViewMatrix()), j.BindFogParameters(a, r, this._activeEffect), this._afterBind(r, this._activeEffect);
      }
    }
  }, e.prototype.clone = function(t) {
    var r = this;
    return $.Clone(function() {
      return new e(t, r.getScene());
    }, this);
  }, e.prototype.serialize = function() {
    var t = i.prototype.serialize.call(this);
    return t.customType = "BABYLON.ShadowOnlyMaterial", t;
  }, e.prototype.getClassName = function() {
    return "ShadowOnlyMaterial";
  }, e.Parse = function(t, r, n) {
    return $.Parse(function() {
      return new e(t.name, r);
    }, t, r, n);
  }, e;
}(mn);
Ne("BABYLON.ShadowOnlyMaterial", yn);
const vf = {
  aspect: 300 / 150,
  enableDebugging: !1,
  enableShadows: !0
};
class mf {
  constructor(e) {
    Xe(this, "size", 9.5);
    this.config = { ...vf, ...e }, this.create();
  }
  create(e) {
    this.destroy(), Object.assign(this.config, e);
    const { aspect: t, enableDebugging: r = !0, enableShadows: n } = this.config, a = 30;
    let s;
    this.box = new Ze("diceBox"), r ? (s = new or("diceBox_material"), s.alpha = 0.7, s.diffuseColor = new ye(1, 1, 0)) : n && (s = new yn("shadowOnly", this.config.scene));
    const o = wt("ground", {
      width: this.size * 2,
      height: 1,
      depth: this.size * 2
    }, this.config.scene);
    if (o.scaling = new b(t, 1, 1), o.material = s, o.receiveShadows = !0, o.setParent(this.box), r) {
      const u = wt("wallTop", {
        width: this.size,
        height: a,
        depth: 1
      }, this.config.scene);
      u.position.y = a / 2, u.position.z = this.size / -2, u.scaling = new b(t, 1, 1), u.material = s, u.setParent(this.box);
      const f = wt("wallRight", {
        width: 1,
        height: a,
        depth: this.size
      }, this.config.scene);
      f.position.x = this.size * t / 2, f.position.y = a / 2, f.material = s, f.setParent(this.box);
      const l = wt("wallBottom", {
        width: this.size,
        height: a,
        depth: 1
      }, this.config.scene);
      l.position.y = a / 2, l.position.z = this.size / 2, l.scaling = new b(t, 1, 1), l.material = s, l.setParent(this.box);
      const h = wt("wallLeft", {
        width: 1,
        height: a,
        depth: this.size
      }, this.config.scene);
      h.position.x = this.size * t / -2, h.position.y = a / 2, h.material = s, h.setParent(this.box);
    }
  }
  destroy() {
    this.box && this.box.dispose();
  }
}
var vt;
(function(i) {
  i[i.Clean = 0] = "Clean", i[i.Stop = 1] = "Stop", i[i.Sync = 2] = "Sync", i[i.NoSync = 3] = "NoSync";
})(vt || (vt = {}));
var He = function() {
  function i() {
  }
  return Object.defineProperty(i, "ForceFullSceneLoadingForIncremental", {
    get: function() {
      return tt.ForceFullSceneLoadingForIncremental;
    },
    set: function(e) {
      tt.ForceFullSceneLoadingForIncremental = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "ShowLoadingScreen", {
    get: function() {
      return tt.ShowLoadingScreen;
    },
    set: function(e) {
      tt.ShowLoadingScreen = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "loggingLevel", {
    get: function() {
      return tt.loggingLevel;
    },
    set: function(e) {
      tt.loggingLevel = e;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(i, "CleanBoneMatrixWeights", {
    get: function() {
      return tt.CleanBoneMatrixWeights;
    },
    set: function(e) {
      tt.CleanBoneMatrixWeights = e;
    },
    enumerable: !1,
    configurable: !0
  }), i.GetDefaultPlugin = function() {
    return i._RegisteredPlugins[".babylon"];
  }, i._GetPluginForExtension = function(e) {
    var t = i._RegisteredPlugins[e];
    return t || (k.Warn("Unable to find a plugin to load " + e + " files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/how_to/load_from_any_file_type"), i.GetDefaultPlugin());
  }, i._GetPluginForDirectLoad = function(e) {
    for (var t in i._RegisteredPlugins) {
      var r = i._RegisteredPlugins[t].plugin;
      if (r.canDirectLoad && r.canDirectLoad(e))
        return i._RegisteredPlugins[t];
    }
    return i.GetDefaultPlugin();
  }, i._GetPluginForFilename = function(e) {
    var t = e.indexOf("?");
    t !== -1 && (e = e.substring(0, t));
    var r = e.lastIndexOf("."), n = e.substring(r, e.length).toLowerCase();
    return i._GetPluginForExtension(n);
  }, i._GetDirectLoad = function(e) {
    return e.substr(0, 5) === "data:" ? e.substr(5) : null;
  }, i._FormatErrorMessage = function(e, t, r) {
    var n = "Unable to load from " + e.url;
    return t ? n += ": ".concat(t) : r && (n += ": ".concat(r)), n;
  }, i._LoadData = function(e, t, r, n, a, s, o) {
    var u = i._GetDirectLoad(e.url), f = o ? i._GetPluginForExtension(o) : u ? i._GetPluginForDirectLoad(e.url) : i._GetPluginForFilename(e.url), l;
    if (f.plugin.createPlugin !== void 0 ? l = f.plugin.createPlugin() : l = f.plugin, !l)
      throw "The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";
    if (i.OnPluginActivatedObservable.notifyObservers(l), u && (l.canDirectLoad && l.canDirectLoad(e.url) || !Or(e.url))) {
      if (l.directLoad) {
        var h = l.directLoad(t, u);
        h.then ? h.then(function(S) {
          r(l, S);
        }).catch(function(S) {
          a("Error in directLoad of _loadData: " + S, S);
        }) : r(l, h);
      } else
        r(l, u);
      return l;
    }
    var c = f.isBinary, d = function(S, w) {
      if (t.isDisposed) {
        a("Scene has been disposed");
        return;
      }
      r(l, S, w);
    }, p = null, g = !1, _ = l.onDisposeObservable;
    _ && _.add(function() {
      g = !0, p && (p.abort(), p = null), s();
    });
    var v = function() {
      if (!g) {
        var S = function(F, x) {
          a(F == null ? void 0 : F.statusText, x);
        }, w = e.file || e.url;
        p = l.loadFile ? l.loadFile(t, w, d, n, c, S) : t._loadFile(w, d, n, !0, c, S);
      }
    }, y = t.getEngine(), E = y.enableOfflineSupport;
    if (E) {
      for (var R = !1, M = 0, C = t.disableOfflineSupportExceptionRules; M < C.length; M++) {
        var A = C[M];
        if (A.test(e.url)) {
          R = !0;
          break;
        }
      }
      E = !R;
    }
    return E && fe.OfflineProviderFactory ? t.offlineProvider = fe.OfflineProviderFactory(e.url, v, y.disableManifestCheck) : v(), l;
  }, i._GetFileInfo = function(e, t) {
    var r, n, a = null;
    if (!t)
      r = e, n = de.GetFilename(e), e = de.GetFolderPath(e);
    else if (t.name) {
      var s = t;
      r = "file:".concat(s.name), n = s.name, a = s;
    } else if (typeof t == "string" && t.startsWith("data:"))
      r = t, n = "";
    else {
      var o = t;
      if (o.substr(0, 1) === "/")
        return de.Error("Wrong sceneFilename parameter"), null;
      r = e + o, n = o;
    }
    return {
      url: r,
      rootUrl: e,
      name: n,
      file: a
    };
  }, i.GetPluginForExtension = function(e) {
    return i._GetPluginForExtension(e).plugin;
  }, i.IsPluginForExtensionAvailable = function(e) {
    return !!i._RegisteredPlugins[e];
  }, i.RegisterPlugin = function(e) {
    if (typeof e.extensions == "string") {
      var t = e.extensions;
      i._RegisteredPlugins[t.toLowerCase()] = {
        plugin: e,
        isBinary: !1
      };
    } else {
      var r = e.extensions;
      Object.keys(r).forEach(function(n) {
        i._RegisteredPlugins[n.toLowerCase()] = {
          plugin: e,
          isBinary: r[n].isBinary
        };
      });
    }
  }, i.ImportMesh = function(e, t, r, n, a, s, o, u) {
    if (r === void 0 && (r = ""), n === void 0 && (n = re.LastCreatedScene), a === void 0 && (a = null), s === void 0 && (s = null), o === void 0 && (o = null), u === void 0 && (u = null), !n)
      return k.Error("No scene available to import mesh to"), null;
    var f = i._GetFileInfo(t, r);
    if (!f)
      return null;
    var l = {};
    n._addPendingData(l);
    var h = function() {
      n._removePendingData(l);
    }, c = function(g, _) {
      var v = i._FormatErrorMessage(f, g, _);
      o ? o(n, v, new Pt(v, Rt.SceneLoaderError, _)) : k.Error(v), h();
    }, d = s ? function(g) {
      try {
        s(g);
      } catch (_) {
        c("Error in onProgress callback: " + _, _);
      }
    } : void 0, p = function(g, _, v, y, E, R, M) {
      if (n.importedMeshesFiles.push(f.url), a)
        try {
          a(g, _, v, y, E, R, M);
        } catch (C) {
          c("Error in onSuccess callback: " + C, C);
        }
      n._removePendingData(l);
    };
    return i._LoadData(f, n, function(g, _, v) {
      if (g.rewriteRootURL && (f.rootUrl = g.rewriteRootURL(f.rootUrl, v)), g.importMesh) {
        var y = g, E = new Array(), R = new Array(), M = new Array();
        if (!y.importMesh(e, n, _, f.rootUrl, E, R, M, c))
          return;
        n.loadingPluginName = g.name, p(E, R, M, [], [], [], []);
      } else {
        var C = g;
        C.importMeshAsync(e, n, _, f.rootUrl, d, f.name).then(function(A) {
          n.loadingPluginName = g.name, p(A.meshes, A.particleSystems, A.skeletons, A.animationGroups, A.transformNodes, A.geometries, A.lights);
        }).catch(function(A) {
          c(A.message, A);
        });
      }
    }, d, c, h, u);
  }, i.ImportMeshAsync = function(e, t, r, n, a, s) {
    return r === void 0 && (r = ""), n === void 0 && (n = re.LastCreatedScene), a === void 0 && (a = null), s === void 0 && (s = null), new Promise(function(o, u) {
      i.ImportMesh(e, t, r, n, function(f, l, h, c, d, p, g) {
        o({
          meshes: f,
          particleSystems: l,
          skeletons: h,
          animationGroups: c,
          transformNodes: d,
          geometries: p,
          lights: g
        });
      }, a, function(f, l, h) {
        u(h || new Error(l));
      }, s);
    });
  }, i.Load = function(e, t, r, n, a, s, o) {
    return t === void 0 && (t = ""), r === void 0 && (r = re.LastCreatedEngine), n === void 0 && (n = null), a === void 0 && (a = null), s === void 0 && (s = null), o === void 0 && (o = null), r ? i.Append(e, t, new te(r), n, a, s, o) : (de.Error("No engine available"), null);
  }, i.LoadAsync = function(e, t, r, n, a) {
    return t === void 0 && (t = ""), r === void 0 && (r = re.LastCreatedEngine), n === void 0 && (n = null), a === void 0 && (a = null), new Promise(function(s, o) {
      i.Load(e, t, r, function(u) {
        s(u);
      }, n, function(u, f, l) {
        o(l || new Error(f));
      }, a);
    });
  }, i.Append = function(e, t, r, n, a, s, o) {
    var u = this;
    if (t === void 0 && (t = ""), r === void 0 && (r = re.LastCreatedScene), n === void 0 && (n = null), a === void 0 && (a = null), s === void 0 && (s = null), o === void 0 && (o = null), !r)
      return k.Error("No scene available to append to"), null;
    var f = i._GetFileInfo(e, t);
    if (!f)
      return null;
    i.ShowLoadingScreen && !this._ShowingLoadingScreen && (this._ShowingLoadingScreen = !0, r.getEngine().displayLoadingUI(), r.executeWhenReady(function() {
      r.getEngine().hideLoadingUI(), u._ShowingLoadingScreen = !1;
    }));
    var l = {};
    r._addPendingData(l);
    var h = function() {
      r._removePendingData(l);
    }, c = function(g, _) {
      var v = i._FormatErrorMessage(f, g, _);
      s ? s(r, v, new Pt(v, Rt.SceneLoaderError, _)) : k.Error(v), h();
    }, d = a ? function(g) {
      try {
        a(g);
      } catch (_) {
        c("Error in onProgress callback", _);
      }
    } : void 0, p = function() {
      if (n)
        try {
          n(r);
        } catch (g) {
          c("Error in onSuccess callback", g);
        }
      r._removePendingData(l);
    };
    return i._LoadData(f, r, function(g, _) {
      if (g.load) {
        var v = g;
        if (!v.load(r, _, f.rootUrl, c))
          return;
        r.loadingPluginName = g.name, p();
      } else {
        var y = g;
        y.loadAsync(r, _, f.rootUrl, d, f.name).then(function() {
          r.loadingPluginName = g.name, p();
        }).catch(function(E) {
          c(E.message, E);
        });
      }
    }, d, c, h, o);
  }, i.AppendAsync = function(e, t, r, n, a) {
    return t === void 0 && (t = ""), r === void 0 && (r = re.LastCreatedScene), n === void 0 && (n = null), a === void 0 && (a = null), new Promise(function(s, o) {
      i.Append(e, t, r, function(u) {
        s(u);
      }, n, function(u, f, l) {
        o(l || new Error(f));
      }, a);
    });
  }, i.LoadAssetContainer = function(e, t, r, n, a, s, o) {
    if (t === void 0 && (t = ""), r === void 0 && (r = re.LastCreatedScene), n === void 0 && (n = null), a === void 0 && (a = null), s === void 0 && (s = null), o === void 0 && (o = null), !r)
      return k.Error("No scene available to load asset container to"), null;
    var u = i._GetFileInfo(e, t);
    if (!u)
      return null;
    var f = {};
    r._addPendingData(f);
    var l = function() {
      r._removePendingData(f);
    }, h = function(p, g) {
      var _ = i._FormatErrorMessage(u, p, g);
      s ? s(r, _, new Pt(_, Rt.SceneLoaderError, g)) : k.Error(_), l();
    }, c = a ? function(p) {
      try {
        a(p);
      } catch (g) {
        h("Error in onProgress callback", g);
      }
    } : void 0, d = function(p) {
      if (n)
        try {
          n(p);
        } catch (g) {
          h("Error in onSuccess callback", g);
        }
      r._removePendingData(f);
    };
    return i._LoadData(u, r, function(p, g) {
      if (p.loadAssetContainer) {
        var _ = p, v = _.loadAssetContainer(r, g, u.rootUrl, h);
        if (!v)
          return;
        r.loadingPluginName = p.name, d(v);
      } else if (p.loadAssetContainerAsync) {
        var y = p;
        y.loadAssetContainerAsync(r, g, u.rootUrl, c, u.name).then(function(E) {
          r.loadingPluginName = p.name, d(E);
        }).catch(function(E) {
          h(E.message, E);
        });
      } else
        h("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.");
    }, c, h, l, o);
  }, i.LoadAssetContainerAsync = function(e, t, r, n, a) {
    return t === void 0 && (t = ""), r === void 0 && (r = re.LastCreatedScene), n === void 0 && (n = null), a === void 0 && (a = null), new Promise(function(s, o) {
      i.LoadAssetContainer(e, t, r, function(u) {
        s(u);
      }, n, function(u, f, l) {
        o(l || new Error(f));
      }, a);
    });
  }, i.ImportAnimations = function(e, t, r, n, a, s, o, u, f, l) {
    if (t === void 0 && (t = ""), r === void 0 && (r = re.LastCreatedScene), n === void 0 && (n = !0), a === void 0 && (a = vt.Clean), s === void 0 && (s = null), o === void 0 && (o = null), u === void 0 && (u = null), f === void 0 && (f = null), l === void 0 && (l = null), !r) {
      k.Error("No scene available to load animations to");
      return;
    }
    if (n) {
      for (var h = 0, c = r.animatables; h < c.length; h++) {
        var d = c[h];
        d.reset();
      }
      r.stopAllAnimations(), r.animationGroups.slice().forEach(function(v) {
        v.dispose();
      });
      var p = r.getNodes();
      p.forEach(function(v) {
        v.animations && (v.animations = []);
      });
    } else
      switch (a) {
        case vt.Clean:
          r.animationGroups.slice().forEach(function(v) {
            v.dispose();
          });
          break;
        case vt.Stop:
          r.animationGroups.forEach(function(v) {
            v.stop();
          });
          break;
        case vt.Sync:
          r.animationGroups.forEach(function(v) {
            v.reset(), v.restart();
          });
          break;
        case vt.NoSync:
          break;
        default:
          k.Error("Unknown animation group loading mode value '" + a + "'");
          return;
      }
    var g = r.animatables.length, _ = function(v) {
      v.mergeAnimationsTo(r, r.animatables.slice(g), s), v.dispose(), r.onAnimationFileImportedObservable.notifyObservers(r), o && o(r);
    };
    this.LoadAssetContainer(e, t, r, _, u, f, l);
  }, i.ImportAnimationsAsync = function(e, t, r, n, a, s, o, u, f, l) {
    return t === void 0 && (t = ""), r === void 0 && (r = re.LastCreatedScene), n === void 0 && (n = !0), a === void 0 && (a = vt.Clean), s === void 0 && (s = null), u === void 0 && (u = null), l === void 0 && (l = null), new Promise(function(h, c) {
      i.ImportAnimations(e, t, r, n, a, s, function(d) {
        h(d);
      }, u, function(d, p, g) {
        c(g || new Error(p));
      }, l);
    });
  }, i.NO_LOGGING = 0, i.MINIMAL_LOGGING = 1, i.SUMMARY_LOGGING = 2, i.DETAILED_LOGGING = 3, i.OnPluginActivatedObservable = new O(), i._RegisteredPlugins = {}, i._ShowingLoadingScreen = !1, i;
}(), nt = function() {
  function i(e, t, r) {
    r === void 0 && (r = Number.MAX_VALUE), this.origin = e, this.direction = t, this.length = r;
  }
  return i.prototype.clone = function() {
    return new i(this.origin.clone(), this.direction.clone(), this.length);
  }, i.prototype.intersectsBoxMinMax = function(e, t, r) {
    r === void 0 && (r = 0);
    var n = i._TmpVector3[0].copyFromFloats(e.x - r, e.y - r, e.z - r), a = i._TmpVector3[1].copyFromFloats(t.x + r, t.y + r, t.z + r), s = 0, o = Number.MAX_VALUE, u, f, l, h;
    if (Math.abs(this.direction.x) < 1e-7) {
      if (this.origin.x < n.x || this.origin.x > a.x)
        return !1;
    } else if (u = 1 / this.direction.x, f = (n.x - this.origin.x) * u, l = (a.x - this.origin.x) * u, l === -1 / 0 && (l = 1 / 0), f > l && (h = f, f = l, l = h), s = Math.max(f, s), o = Math.min(l, o), s > o)
      return !1;
    if (Math.abs(this.direction.y) < 1e-7) {
      if (this.origin.y < n.y || this.origin.y > a.y)
        return !1;
    } else if (u = 1 / this.direction.y, f = (n.y - this.origin.y) * u, l = (a.y - this.origin.y) * u, l === -1 / 0 && (l = 1 / 0), f > l && (h = f, f = l, l = h), s = Math.max(f, s), o = Math.min(l, o), s > o)
      return !1;
    if (Math.abs(this.direction.z) < 1e-7) {
      if (this.origin.z < n.z || this.origin.z > a.z)
        return !1;
    } else if (u = 1 / this.direction.z, f = (n.z - this.origin.z) * u, l = (a.z - this.origin.z) * u, l === -1 / 0 && (l = 1 / 0), f > l && (h = f, f = l, l = h), s = Math.max(f, s), o = Math.min(l, o), s > o)
      return !1;
    return !0;
  }, i.prototype.intersectsBox = function(e, t) {
    return t === void 0 && (t = 0), this.intersectsBoxMinMax(e.minimum, e.maximum, t);
  }, i.prototype.intersectsSphere = function(e, t) {
    t === void 0 && (t = 0);
    var r = e.center.x - this.origin.x, n = e.center.y - this.origin.y, a = e.center.z - this.origin.z, s = r * r + n * n + a * a, o = e.radius + t, u = o * o;
    if (s <= u)
      return !0;
    var f = r * this.direction.x + n * this.direction.y + a * this.direction.z;
    if (f < 0)
      return !1;
    var l = s - f * f;
    return l <= u;
  }, i.prototype.intersectsTriangle = function(e, t, r) {
    var n = i._TmpVector3[0], a = i._TmpVector3[1], s = i._TmpVector3[2], o = i._TmpVector3[3], u = i._TmpVector3[4];
    t.subtractToRef(e, n), r.subtractToRef(e, a), b.CrossToRef(this.direction, a, s);
    var f = b.Dot(n, s);
    if (f === 0)
      return null;
    var l = 1 / f;
    this.origin.subtractToRef(e, o);
    var h = b.Dot(o, s) * l;
    if (h < 0 || h > 1)
      return null;
    b.CrossToRef(o, n, u);
    var c = b.Dot(this.direction, u) * l;
    if (c < 0 || h + c > 1)
      return null;
    var d = b.Dot(a, u) * l;
    return d > this.length ? null : new ai(1 - h - c, h, d);
  }, i.prototype.intersectsPlane = function(e) {
    var t, r = b.Dot(e.normal, this.direction);
    if (Math.abs(r) < 999999997475243e-21)
      return null;
    var n = b.Dot(e.normal, this.origin);
    return t = (-e.d - n) / r, t < 0 ? t < -999999997475243e-21 ? null : 0 : t;
  }, i.prototype.intersectsAxis = function(e, t) {
    switch (t === void 0 && (t = 0), e) {
      case "y": {
        var r = (this.origin.y - t) / this.direction.y;
        return r > 0 ? null : new b(this.origin.x + this.direction.x * -r, t, this.origin.z + this.direction.z * -r);
      }
      case "x": {
        var r = (this.origin.x - t) / this.direction.x;
        return r > 0 ? null : new b(t, this.origin.y + this.direction.y * -r, this.origin.z + this.direction.z * -r);
      }
      case "z": {
        var r = (this.origin.z - t) / this.direction.z;
        return r > 0 ? null : new b(this.origin.x + this.direction.x * -r, this.origin.y + this.direction.y * -r, t);
      }
      default:
        return null;
    }
  }, i.prototype.intersectsMesh = function(e, t) {
    var r = D.Matrix[0];
    return e.getWorldMatrix().invertToRef(r), this._tmpRay ? i.TransformToRef(this, r, this._tmpRay) : this._tmpRay = i.Transform(this, r), e.intersects(this._tmpRay, t);
  }, i.prototype.intersectsMeshes = function(e, t, r) {
    r ? r.length = 0 : r = [];
    for (var n = 0; n < e.length; n++) {
      var a = this.intersectsMesh(e[n], t);
      a.hit && r.push(a);
    }
    return r.sort(this._comparePickingInfo), r;
  }, i.prototype._comparePickingInfo = function(e, t) {
    return e.distance < t.distance ? -1 : e.distance > t.distance ? 1 : 0;
  }, i.prototype.intersectionSegment = function(e, t, r) {
    var n = this.origin, a = D.Vector3[0], s = D.Vector3[1], o = D.Vector3[2], u = D.Vector3[3];
    t.subtractToRef(e, a), this.direction.scaleToRef(i._Rayl, o), n.addToRef(o, s), e.subtractToRef(n, u);
    var f = b.Dot(a, a), l = b.Dot(a, o), h = b.Dot(o, o), c = b.Dot(a, u), d = b.Dot(o, u), p = f * h - l * l, g, _ = p, v, y = p;
    p < i._Smallnum ? (g = 0, _ = 1, v = d, y = h) : (g = l * d - h * c, v = f * d - l * c, g < 0 ? (g = 0, v = d, y = h) : g > _ && (g = _, v = d + l, y = h)), v < 0 ? (v = 0, -c < 0 ? g = 0 : -c > f ? g = _ : (g = -c, _ = f)) : v > y && (v = y, -c + l < 0 ? g = 0 : -c + l > f ? g = _ : (g = -c + l, _ = f));
    var E = Math.abs(g) < i._Smallnum ? 0 : g / _, R = Math.abs(v) < i._Smallnum ? 0 : v / y, M = D.Vector3[4];
    o.scaleToRef(R, M);
    var C = D.Vector3[5];
    a.scaleToRef(E, C), C.addInPlace(u);
    var A = D.Vector3[6];
    C.subtractToRef(M, A);
    var S = R > 0 && R <= this.length && A.lengthSquared() < r * r;
    return S ? C.length() : -1;
  }, i.prototype.update = function(e, t, r, n, a, s, o, u) {
    if (u === void 0 && (u = !1), u) {
      i._RayDistant || (i._RayDistant = i.Zero()), i._RayDistant.unprojectRayToRef(e, t, r, n, I.IdentityReadOnly, s, o);
      var f = D.Matrix[0];
      a.invertToRef(f), i.TransformToRef(i._RayDistant, f, this);
    } else
      this.unprojectRayToRef(e, t, r, n, a, s, o);
    return this;
  }, i.Zero = function() {
    return new i(b.Zero(), b.Zero());
  }, i.CreateNew = function(e, t, r, n, a, s, o) {
    var u = i.Zero();
    return u.update(e, t, r, n, a, s, o);
  }, i.CreateNewFromTo = function(e, t, r) {
    r === void 0 && (r = I.IdentityReadOnly);
    var n = t.subtract(e), a = Math.sqrt(n.x * n.x + n.y * n.y + n.z * n.z);
    return n.normalize(), i.Transform(new i(e, n, a), r);
  }, i.Transform = function(e, t) {
    var r = new i(new b(0, 0, 0), new b(0, 0, 0));
    return i.TransformToRef(e, t, r), r;
  }, i.TransformToRef = function(e, t, r) {
    b.TransformCoordinatesToRef(e.origin, t, r.origin), b.TransformNormalToRef(e.direction, t, r.direction), r.length = e.length;
    var n = r.direction, a = n.length();
    if (!(a === 0 || a === 1)) {
      var s = 1 / a;
      n.x *= s, n.y *= s, n.z *= s, r.length *= a;
    }
  }, i.prototype.unprojectRayToRef = function(e, t, r, n, a, s, o) {
    var u, f = D.Matrix[0];
    a.multiplyToRef(s, f), f.multiplyToRef(o, f), f.invert();
    var l = D.Vector3[0];
    l.x = e / r * 2 - 1, l.y = -(t / n * 2 - 1), l.z = !((u = re.LastCreatedEngine) === null || u === void 0) && u.isNDCHalfZRange ? 0 : -1;
    var h = D.Vector3[1].copyFromFloats(l.x, l.y, 1 - 1e-8), c = D.Vector3[2], d = D.Vector3[3];
    b._UnprojectFromInvertedMatrixToRef(l, f, c), b._UnprojectFromInvertedMatrixToRef(h, f, d), this.origin.copyFrom(c), d.subtractToRef(c, this.direction), this.direction.normalize();
  }, i._TmpVector3 = xe.BuildArray(6, b.Zero), i._RayDistant = i.Zero(), i._Smallnum = 1e-8, i._Rayl = 1e9, i;
}();
te.prototype.createPickingRay = function(i, e, t, r, n) {
  n === void 0 && (n = !1);
  var a = nt.Zero();
  return this.createPickingRayToRef(i, e, t, a, r, n), a;
};
te.prototype.createPickingRayToRef = function(i, e, t, r, n, a, s) {
  a === void 0 && (a = !1), s === void 0 && (s = !1);
  var o = this.getEngine();
  if (!n) {
    if (!this.activeCamera)
      return this;
    n = this.activeCamera;
  }
  var u = n.viewport, f = u.toGlobal(o.getRenderWidth(), o.getRenderHeight());
  return i = i / o.getHardwareScalingLevel() - f.x, e = e / o.getHardwareScalingLevel() - (o.getRenderHeight() - f.y - f.height), r.update(i, e, f.width, f.height, t || I.IdentityReadOnly, a ? I.IdentityReadOnly : n.getViewMatrix(), n.getProjectionMatrix(), s), this;
};
te.prototype.createPickingRayInCameraSpace = function(i, e, t) {
  var r = nt.Zero();
  return this.createPickingRayInCameraSpaceToRef(i, e, r, t), r;
};
te.prototype.createPickingRayInCameraSpaceToRef = function(i, e, t, r) {
  if (!et)
    return this;
  var n = this.getEngine();
  if (!r) {
    if (!this.activeCamera)
      throw new Error("Active camera not set");
    r = this.activeCamera;
  }
  var a = r.viewport, s = a.toGlobal(n.getRenderWidth(), n.getRenderHeight()), o = I.Identity();
  return i = i / n.getHardwareScalingLevel() - s.x, e = e / n.getHardwareScalingLevel() - (n.getRenderHeight() - s.y - s.height), t.update(i, e, s.width, s.height, o, o, r.getProjectionMatrix()), this;
};
te.prototype._internalPickForMesh = function(i, e, t, r, n, a, s, o) {
  var u = e(r, t.enableDistantPicking), f = t.intersects(u, n, s, a, r, o);
  return !f || !f.hit || !n && i != null && f.distance >= i.distance ? null : f;
};
te.prototype._internalPick = function(i, e, t, r, n) {
  if (!et)
    return null;
  for (var a = null, s = 0; s < this.meshes.length; s++) {
    var o = this.meshes[s];
    if (e) {
      if (!e(o))
        continue;
    } else if (!o.isEnabled() || !o.isVisible || !o.isPickable)
      continue;
    var u = o.getWorldMatrix();
    if (o.hasThinInstances && o.thinInstanceEnablePicking) {
      var f = this._internalPickForMesh(a, i, o, u, !0, !0, n);
      if (f) {
        if (r)
          return f;
        for (var l = D.Matrix[1], h = o.thinInstanceGetWorldMatrices(), c = 0; c < h.length; c++) {
          var d = h[c];
          d.multiplyToRef(u, l);
          var p = this._internalPickForMesh(a, i, o, l, t, r, n, !0);
          if (p && (a = p, a.thinInstanceIndex = c, t))
            return a;
        }
      }
    } else {
      var f = this._internalPickForMesh(a, i, o, u, t, r, n);
      if (f && (a = f, t))
        return a;
    }
  }
  return a || new et();
};
te.prototype._internalMultiPick = function(i, e, t) {
  if (!et)
    return null;
  for (var r = new Array(), n = 0; n < this.meshes.length; n++) {
    var a = this.meshes[n];
    if (e) {
      if (!e(a))
        continue;
    } else if (!a.isEnabled() || !a.isVisible || !a.isPickable)
      continue;
    var s = a.getWorldMatrix();
    if (a.hasThinInstances && a.thinInstanceEnablePicking) {
      var o = this._internalPickForMesh(null, i, a, s, !0, !0, t);
      if (o)
        for (var u = D.Matrix[1], f = a.thinInstanceGetWorldMatrices(), l = 0; l < f.length; l++) {
          var h = f[l];
          h.multiplyToRef(s, u);
          var c = this._internalPickForMesh(null, i, a, u, !1, !1, t, !0);
          c && (c.thinInstanceIndex = l, r.push(c));
        }
    } else {
      var o = this._internalPickForMesh(null, i, a, s, !1, !1, t);
      o && r.push(o);
    }
  }
  return r;
};
te.prototype.pickWithBoundingInfo = function(i, e, t, r, n) {
  var a = this;
  if (!et)
    return null;
  var s = this._internalPick(function(o) {
    return a._tempPickingRay || (a._tempPickingRay = nt.Zero()), a.createPickingRayToRef(i, e, o, a._tempPickingRay, n || null), a._tempPickingRay;
  }, t, r, !0);
  return s && (s.ray = this.createPickingRay(i, e, I.Identity(), n || null)), s;
};
te.prototype.pick = function(i, e, t, r, n, a, s) {
  var o = this;
  if (!et)
    return null;
  var u = this._internalPick(function(f, l) {
    return o._tempPickingRay || (o._tempPickingRay = nt.Zero()), o.createPickingRayToRef(i, e, f, o._tempPickingRay, n || null, !1, l), o._tempPickingRay;
  }, t, r, !1, a);
  return u && (u.ray = this.createPickingRay(i, e, I.Identity(), n || null)), u;
};
te.prototype.pickWithRay = function(i, e, t, r) {
  var n = this, a = this._internalPick(function(s) {
    return n._pickWithRayInverseMatrix || (n._pickWithRayInverseMatrix = I.Identity()), s.invertToRef(n._pickWithRayInverseMatrix), n._cachedRayForTransform || (n._cachedRayForTransform = nt.Zero()), nt.TransformToRef(i, n._pickWithRayInverseMatrix, n._cachedRayForTransform), n._cachedRayForTransform;
  }, e, t, !1, r);
  return a && (a.ray = i), a;
};
te.prototype.multiPick = function(i, e, t, r, n) {
  var a = this;
  return this._internalMultiPick(function(s) {
    return a.createPickingRay(i, e, s, r || null);
  }, t, n);
};
te.prototype.multiPickWithRay = function(i, e, t) {
  var r = this;
  return this._internalMultiPick(function(n) {
    return r._pickWithRayInverseMatrix || (r._pickWithRayInverseMatrix = I.Identity()), n.invertToRef(r._pickWithRayInverseMatrix), r._cachedRayForTransform || (r._cachedRayForTransform = nt.Zero()), nt.TransformToRef(i, r._pickWithRayInverseMatrix, r._cachedRayForTransform), r._cachedRayForTransform;
  }, e, t);
};
De.prototype.getForwardRay = function(i, e, t) {
  return i === void 0 && (i = 100), this.getForwardRayToRef(new nt(b.Zero(), b.Zero(), i), i, e, t);
};
De.prototype.getForwardRayToRef = function(i, e, t, r) {
  return e === void 0 && (e = 100), t || (t = this.getWorldMatrix()), i.length = e, r ? i.origin.copyFrom(r) : i.origin.copyFrom(this.position), D.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1), b.TransformNormalToRef(D.Vector3[2], t, D.Vector3[3]), b.NormalizeToRef(D.Vector3[3], i.direction), i;
};
var yf = function(i, e, t) {
  for (var r in e)
    if (i.name === e[r])
      return t.push(i.id), !0;
  return i.parentId && t.indexOf(i.parentId) !== -1 ? (t.push(i.id), !0) : !1;
}, _r = function(i, e) {
  return i + " of " + (e ? e.file + " from " + e.name + " version: " + e.version + ", exporter version: " + e.exporter_version : "unknown");
};
He.RegisterPlugin({
  name: "babylon.js",
  extensions: ".json",
  canDirectLoad: function(i) {
    return i.indexOf("json") !== -1, !0;
  },
  importMesh: function(i, e, t, r, n, a, s, o) {
    var u = "importMesh has failed JSON parse";
    try {
      var f = JSON.parse(t);
      f.physicsEnabled = !1, f == null || f.meshes.map((y) => delete y.physicsImpostor), u = "";
      var l = He.loggingLevel === He.DETAILED_LOGGING;
      i ? Array.isArray(i) || (i = [i]) : i = null;
      var h = new Array();
      if (f.meshes !== void 0 && f.meshes !== null) {
        var c, d;
        for (c = 0, d = f.meshes.length; c < d; c++) {
          var p = f.meshes[c];
          if (i === null || yf(p, i, h)) {
            i !== null && delete i[i.indexOf(p.name)];
            var g = Q.Parse(p, e, r);
            n.push(g), u += `
	Mesh ` + g.toString(l);
          }
        }
        var _;
        for (c = 0, d = e.meshes.length; c < d; c++)
          _ = e.meshes[c], _._waitingParentId && (_.parent = e.getLastEntryByID(_._waitingParentId), _._waitingParentId = null), _.computeWorldMatrix(!0);
      }
      return !0;
    } catch (y) {
      var v = _r("importMesh", f ? f.producer : "Unknown") + u;
      if (o)
        o(v, y);
      else
        throw k.Log(v), y;
    } finally {
      u !== null && He.loggingLevel !== He.NO_LOGGING && k.Log(_r("importMesh", f ? f.producer : "Unknown") + (He.loggingLevel !== He.MINIMAL_LOGGING ? u : ""));
    }
    return !1;
  },
  load: function(i, e, t, r) {
    var n = "importScene has failed JSON parse";
    try {
      var a = JSON.parse(e);
      n = "", a.clearColor !== void 0 && a.clearColor !== null && (i.clearColor = Color4.FromArray(a.clearColor));
      var s = loadAssetContainer(i, e, t, r, !0);
      return !!s;
    } catch (u) {
      var o = _r("importScene", a ? a.producer : "Unknown") + n;
      if (r)
        r(o, u);
      else
        throw k.Log(o), u;
    } finally {
      n !== null && He.loggingLevel !== He.NO_LOGGING && k.Log(_r("importScene", a ? a.producer : "Unknown") + (He.loggingLevel !== He.MINIMAL_LOGGING ? n : ""));
    }
    return !1;
  },
  loadAssetContainer: function(i, e, t, r) {
    var n = loadAssetContainer(i, e, t, r);
    return n;
  }
});
Q._instancedMeshFactory = function(i, e) {
  var t = new bf(i, e);
  if (e.instancedBuffers) {
    t.instancedBuffers = {};
    for (var r in e.instancedBuffers)
      t.instancedBuffers[r] = e.instancedBuffers[r];
  }
  return t;
};
var bf = function(i) {
  K(e, i);
  function e(t, r) {
    var n = i.call(this, t, r.getScene()) || this;
    n._indexInSourceMeshInstanceArray = -1, n._distanceToCamera = 0, r.addInstance(n), n._sourceMesh = r, n._unIndexed = r._unIndexed, n.position.copyFrom(r.position), n.rotation.copyFrom(r.rotation), n.scaling.copyFrom(r.scaling), r.rotationQuaternion && (n.rotationQuaternion = r.rotationQuaternion.clone()), n.animations = r.animations.slice();
    for (var a = 0, s = r.getAnimationRanges(); a < s.length; a++) {
      var o = s[a];
      o != null && n.createAnimationRange(o.name, o.from, o.to);
    }
    return n.infiniteDistance = r.infiniteDistance, n.setPivotMatrix(r.getPivotMatrix()), n.refreshBoundingInfo(!0, !0), n._syncSubMeshes(), n;
  }
  return e.prototype.getClassName = function() {
    return "InstancedMesh";
  }, Object.defineProperty(e.prototype, "lightSources", {
    get: function() {
      return this._sourceMesh._lightSources;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._resyncLightSources = function() {
  }, e.prototype._resyncLightSource = function() {
  }, e.prototype._removeLightSource = function() {
  }, Object.defineProperty(e.prototype, "receiveShadows", {
    get: function() {
      return this._sourceMesh.receiveShadows;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "material", {
    get: function() {
      return this._sourceMesh.material;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "visibility", {
    get: function() {
      return this._sourceMesh.visibility;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "skeleton", {
    get: function() {
      return this._sourceMesh.skeleton;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "renderingGroupId", {
    get: function() {
      return this._sourceMesh.renderingGroupId;
    },
    set: function(t) {
      !this._sourceMesh || t === this._sourceMesh.renderingGroupId || k.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene");
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getTotalVertices = function() {
    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;
  }, e.prototype.getTotalIndices = function() {
    return this._sourceMesh.getTotalIndices();
  }, Object.defineProperty(e.prototype, "sourceMesh", {
    get: function() {
      return this._sourceMesh;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.createInstance = function(t) {
    return this._sourceMesh.createInstance(t);
  }, e.prototype.isReady = function(t) {
    return t === void 0 && (t = !1), this._sourceMesh.isReady(t, !0);
  }, e.prototype.getVerticesData = function(t, r) {
    return this._sourceMesh.getVerticesData(t, r);
  }, e.prototype.setVerticesData = function(t, r, n, a) {
    return this.sourceMesh && this.sourceMesh.setVerticesData(t, r, n, a), this.sourceMesh;
  }, e.prototype.updateVerticesData = function(t, r, n, a) {
    return this.sourceMesh && this.sourceMesh.updateVerticesData(t, r, n, a), this.sourceMesh;
  }, e.prototype.setIndices = function(t, r) {
    return r === void 0 && (r = null), this.sourceMesh && this.sourceMesh.setIndices(t, r), this.sourceMesh;
  }, e.prototype.isVerticesDataPresent = function(t) {
    return this._sourceMesh.isVerticesDataPresent(t);
  }, e.prototype.getIndices = function() {
    return this._sourceMesh.getIndices();
  }, Object.defineProperty(e.prototype, "_positions", {
    get: function() {
      return this._sourceMesh._positions;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.refreshBoundingInfo = function(t, r) {
    if (t === void 0 && (t = !1), r === void 0 && (r = !1), this.hasBoundingInfo && this.getBoundingInfo().isLocked)
      return this;
    var n = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
    return this._refreshBoundingInfo(this._sourceMesh._getPositionData(t, r), n), this;
  }, e.prototype._preActivate = function() {
    return this._currentLOD && this._currentLOD._preActivate(), this;
  }, e.prototype._activate = function(t, r) {
    if (i.prototype._activate.call(this, t, r), this._sourceMesh.subMeshes || k.Warn("Instances should only be created for meshes with geometry."), this._currentLOD) {
      var n = this._currentLOD._getWorldMatrixDeterminant() >= 0 != this._getWorldMatrixDeterminant() >= 0;
      if (n)
        return this._internalAbstractMeshDataInfo._actAsRegularMesh = !0, !0;
      if (this._internalAbstractMeshDataInfo._actAsRegularMesh = !1, this._currentLOD._registerInstanceForRenderId(this, t), r) {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate)
          return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = !0, !0;
      } else if (!this._currentLOD._internalAbstractMeshDataInfo._isActive)
        return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = !0, !0;
    }
    return !1;
  }, e.prototype._postActivate = function() {
    this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup ? (this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer), this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())) : this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup && this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);
  }, e.prototype.getWorldMatrix = function() {
    if (this._currentLOD && this._currentLOD.billboardMode !== Ze.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
      this._billboardWorldMatrix || (this._billboardWorldMatrix = new I());
      var t = this._currentLOD._masterMesh;
      return this._currentLOD._masterMesh = this, D.Vector3[7].copyFrom(this._currentLOD.position), this._currentLOD.position.set(0, 0, 0), this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)), this._currentLOD.position.copyFrom(D.Vector3[7]), this._currentLOD._masterMesh = t, this._billboardWorldMatrix;
    }
    return i.prototype.getWorldMatrix.call(this);
  }, Object.defineProperty(e.prototype, "isAnInstance", {
    get: function() {
      return !0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.getLOD = function(t) {
    if (!t)
      return this;
    var r = this.sourceMesh.getLODLevels();
    if (!r || r.length === 0)
      this._currentLOD = this.sourceMesh;
    else {
      var n = this.getBoundingInfo();
      this._currentLOD = this.sourceMesh.getLOD(t, n.boundingSphere);
    }
    return this._currentLOD;
  }, e.prototype._preActivateForIntermediateRendering = function(t) {
    return this.sourceMesh._preActivateForIntermediateRendering(t);
  }, e.prototype._syncSubMeshes = function() {
    if (this.releaseSubMeshes(), this._sourceMesh.subMeshes)
      for (var t = 0; t < this._sourceMesh.subMeshes.length; t++)
        this._sourceMesh.subMeshes[t].clone(this, this._sourceMesh);
    return this;
  }, e.prototype._generatePointsArray = function() {
    return this._sourceMesh._generatePointsArray();
  }, e.prototype._updateBoundingInfo = function() {
    return this.hasBoundingInfo ? this.getBoundingInfo().update(this.worldMatrixFromCache) : this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache), this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache), this;
  }, e.prototype.clone = function(t, r, n) {
    r === void 0 && (r = null);
    var a = this._sourceMesh.createInstance(t);
    if (hi.DeepCopy(this, a, [
      "name",
      "subMeshes",
      "uniqueId",
      "parent",
      "lightSources",
      "receiveShadows",
      "material",
      "visibility",
      "skeleton",
      "sourceMesh",
      "isAnInstance",
      "facetNb",
      "isFacetDataEnabled",
      "isBlocked",
      "useBones",
      "hasInstances",
      "collider",
      "edgesRenderer",
      "forward",
      "up",
      "right",
      "absolutePosition",
      "absoluteScaling",
      "absoluteRotationQuaternion",
      "isWorldMatrixFrozen",
      "nonUniformScaling",
      "behaviors",
      "worldMatrixFromCache",
      "hasThinInstances",
      "hasBoundingInfo"
    ], []), this.refreshBoundingInfo(), r && (a.parent = r), !n)
      for (var s = 0; s < this.getScene().meshes.length; s++) {
        var o = this.getScene().meshes[s];
        o.parent === this && o.clone(o.name, a);
      }
    return a.computeWorldMatrix(!0), this.onClonedObservable.notifyObservers(a), a;
  }, e.prototype.dispose = function(t, r) {
    r === void 0 && (r = !1), this._sourceMesh.removeInstance(this), i.prototype.dispose.call(this, t, r);
  }, e;
}(mi);
Q.prototype.registerInstancedBuffer = function(i, e) {
  var t, r;
  if ((r = (t = this._userInstancedBuffersStorage) === null || t === void 0 ? void 0 : t.vertexBuffers[i]) === null || r === void 0 || r.dispose(), !this.instancedBuffers) {
    this.instancedBuffers = {};
    for (var n = 0, a = this.instances; n < a.length; n++) {
      var s = a[n];
      s.instancedBuffers = {};
    }
    this._userInstancedBuffersStorage || (this._userInstancedBuffersStorage = {
      data: {},
      vertexBuffers: {},
      strides: {},
      sizes: {},
      vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
    });
  }
  this.instancedBuffers[i] = null, this._userInstancedBuffersStorage.strides[i] = e, this._userInstancedBuffersStorage.sizes[i] = e * 32, this._userInstancedBuffersStorage.data[i] = new Float32Array(this._userInstancedBuffersStorage.sizes[i]), this._userInstancedBuffersStorage.vertexBuffers[i] = new m(this.getEngine(), this._userInstancedBuffersStorage.data[i], i, !0, !1, e, !0);
  for (var o = 0, u = this.instances; o < u.length; o++) {
    var s = u[o];
    s.instancedBuffers[i] = null;
  }
  this._invalidateInstanceVertexArrayObject(), this._markSubMeshesAsAttributesDirty();
};
Q.prototype._processInstancedBuffers = function(i, e) {
  var t = i.length;
  for (var r in this.instancedBuffers) {
    for (var n = this._userInstancedBuffersStorage.sizes[r], a = this._userInstancedBuffersStorage.strides[r], s = (t + 1) * a; n < s; )
      n *= 2;
    this._userInstancedBuffersStorage.data[r].length != n && (this._userInstancedBuffersStorage.data[r] = new Float32Array(n), this._userInstancedBuffersStorage.sizes[r] = n, this._userInstancedBuffersStorage.vertexBuffers[r] && (this._userInstancedBuffersStorage.vertexBuffers[r].dispose(), this._userInstancedBuffersStorage.vertexBuffers[r] = null));
    var o = this._userInstancedBuffersStorage.data[r], u = 0;
    if (e) {
      var f = this.instancedBuffers[r];
      f.toArray ? f.toArray(o, u) : f.copyToArray ? f.copyToArray(o, u) : o[u] = f, u += a;
    }
    for (var l = 0; l < t; l++) {
      var h = i[l], f = h.instancedBuffers[r];
      f.toArray ? f.toArray(o, u) : f.copyToArray ? f.copyToArray(o, u) : o[u] = f, u += a;
    }
    this._userInstancedBuffersStorage.vertexBuffers[r] ? this._userInstancedBuffersStorage.vertexBuffers[r].updateDirectly(o, 0) : (this._userInstancedBuffersStorage.vertexBuffers[r] = new m(this.getEngine(), this._userInstancedBuffersStorage.data[r], r, !0, !1, a, !0), this._invalidateInstanceVertexArrayObject());
  }
};
Q.prototype._invalidateInstanceVertexArrayObject = function() {
  if (!(!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === void 0)) {
    for (var i in this._userInstancedBuffersStorage.vertexArrayObjects)
      this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[i]);
    this._userInstancedBuffersStorage.vertexArrayObjects = {};
  }
};
Q.prototype._disposeInstanceSpecificData = function() {
  for (this._instanceDataStorage.instancesBuffer && (this._instanceDataStorage.instancesBuffer.dispose(), this._instanceDataStorage.instancesBuffer = null); this.instances.length; )
    this.instances[0].dispose();
  for (var i in this.instancedBuffers)
    this._userInstancedBuffersStorage.vertexBuffers[i] && this._userInstancedBuffersStorage.vertexBuffers[i].dispose();
  this._invalidateInstanceVertexArrayObject(), this.instancedBuffers = {};
};
const Ef = {
  assetPath: "",
  enableShadows: !1,
  groupId: null,
  id: null,
  lights: [],
  rollId: null,
  scene: null
}, ct = class {
  constructor(e, t) {
    Xe(this, "value", 0);
    Xe(this, "asleep", !1);
    this.config = { ...Ef, ...e }, this.id = this.config.id !== void 0 ? this.config.id : Date.now(), this.dieType = `d${this.config.sides}`, this.comboKey = `${this.config.theme}_${this.dieType}`, this.scene = t, this.createInstance();
  }
  createInstance() {
    const e = `${this.config.meshName}_${this.dieType}_${this.config.theme}${this.config.colorSuffix}`, t = `${e}-instance-${this.id}`, r = this.scene.getMeshByName(e).createInstance(t);
    if (this.config.colorSuffix.length > 0) {
      const n = ye.FromHexString(this.config.themeColor);
      r.instancedBuffers.customColor = n;
    }
    r.position.y = -100, r.scaling = new b(this.config.scale, this.config.scale, this.config.scale), this.config.enableShadows && this.config.lights.directional.shadowGenerator.addShadowCaster(r), this.mesh = r;
  }
  static async loadDie(e, t) {
    const { sides: r, theme: n = "default", meshName: a, colorSuffix: s } = e, o = a + "_d" + r, u = o + "_" + n + s;
    let f = t.getMeshByName(u);
    return f || (f = t.getMeshByName(o).clone(u)), f.material || (f.material = t.getMaterialByName(n + s), s.length > 0 && f.registerInstancedBuffer("customColor", 3)), e;
  }
  static async loadModels(e, t) {
    const { meshFilePath: r, meshName: n, scale: a, d4FaceDown: s = !0 } = e;
    let o = !1, u = !1;
    const f = await fetch(`${r}`).then((l) => {
      if (l.ok) {
        const h = l.headers.get("content-type");
        if (h && h.indexOf("application/json") !== -1)
          return l.json();
        if (l.type && l.type === "basic")
          return l.json();
        throw new Error(`Incorrect contentType: ${h}. Expected "application/json" or "basic"`);
      } else
        throw new Error(`Unable to load 3D mesh file: '${r}'. Request rejected with status ${l.status}: ${l.statusText}`);
    }).catch((l) => console.error(l));
    if (!!f)
      return He.ImportMeshAsync(null, null, "data:" + JSON.stringify(f), t).then((l) => {
        if (l.meshes.forEach((h) => {
          h.name === "__root__" && h.dispose(), h.name.includes("collider") && (h.scaling = new b(0.9, 0.9, 0.9)), o || (o = h.name === "d100"), u || (u = h.name === "d10"), h.setEnabled(!1), h.freezeNormals(), h.freezeWorldMatrix(), h.isPickable = !1, h.doNotSyncBoundingInfo = !0, h.name = n + "_" + h.name;
        }), !o && u && (t.getMeshByName(n + "_d10").clone(n + "_d100"), t.getMeshByName(n + "_d10_collider").clone(n + "_d100_collider"), f.colliderFaceMap && (f.colliderFaceMap.d100 = qi(f.colliderFaceMap.d10), Object.values(f.colliderFaceMap.d100).forEach((h, c) => {
          f.colliderFaceMap.d100[c] = h * (h === 10 ? 0 : 10);
        }))), !f.colliderFaceMap)
          throw new Error(`'colliderFaceMap' data not found in ${r}. Without the colliderFaceMap data dice values can not be resolved.`);
        t.themeData[n] = {}, t.themeData[n].colliderFaceMap = f.colliderFaceMap, t.themeData[n].d4FaceDown = s;
      }).catch((l) => console.error(l)), f.meshes.filter((l) => l.name.includes("collider"));
  }
  updateConfig(e) {
    this.config = { ...this.config, ...e };
  }
  static setVector3(e, t, r) {
    return ct.vector3.set(e, t, r);
  }
  static getVector3() {
    return ct.vector3;
  }
  static async getRollResult(e, t) {
    const r = (n = e) => new Promise((a, s) => {
      const o = e.config.parentMesh || e.config.meshName, u = t.themeData[o].colliderFaceMap, f = t.themeData[o].d4FaceDown;
      if (!u[n.dieType])
        throw new Error(`No colliderFaceMap data for ${n.dieType}`);
      const l = t.getMeshByName(`${o}_${n.dieType}_collider`).createInstance(`${o}_${n.dieType}-hitbox-${n.id}`);
      l.isPickable = !0, l.isVisible = !0, l.setEnabled(!0), l.position = n.mesh.position, l.rotationQuaternion = n.mesh.rotationQuaternion;
      let h = ct.setVector3(0, 1, 0);
      n.dieType === "d4" && f && (h = ct.setVector3(0, -1, 0)), ct.ray.direction = h, ct.ray.origin = e.mesh.position;
      const c = t.pickWithRay(ct.ray);
      if (l.dispose(), n.value = u[n.dieType][c.faceId], n.value === void 0)
        throw new Error(`colliderFaceMap Error: No value found for ${n.dieType} mesh face ${c.faceId}`);
      return a(n.value);
    }).catch((a) => console.error(a));
    return e.mesh ? await r() : e.value;
  }
};
let it = ct;
Xe(it, "ray", new nt(b.Zero(), b.Zero(), 1)), Xe(it, "vector3", new b.Zero());
var Tf = function() {
  function i() {
  }
  return i;
}(), xr = function(i) {
  K(e, i);
  function e(t, r) {
    var n = i.call(this, t, r) || this;
    return n.CustomParts = new Tf(), n.customShaderNameResolve = n.Builder, n.FragmentShader = ze.ShadersStore.defaultPixelShader, n.VertexShader = ze.ShadersStore.defaultVertexShader, n;
  }
  return e.prototype.AttachAfterBind = function(t, r) {
    if (this._newUniformInstances)
      for (var n in this._newUniformInstances) {
        var a = n.toString().split("-");
        a[0] == "vec2" ? r.setVector2(a[1], this._newUniformInstances[n]) : a[0] == "vec3" ? r.setVector3(a[1], this._newUniformInstances[n]) : a[0] == "vec4" ? r.setVector4(a[1], this._newUniformInstances[n]) : a[0] == "mat4" ? r.setMatrix(a[1], this._newUniformInstances[n]) : a[0] == "float" && r.setFloat(a[1], this._newUniformInstances[n]);
      }
    if (this._newSamplerInstances)
      for (var n in this._newSamplerInstances) {
        var a = n.toString().split("-");
        a[0] == "sampler2D" && this._newSamplerInstances[n].isReady && this._newSamplerInstances[n].isReady() && r.setTexture(a[1], this._newSamplerInstances[n]);
      }
  }, e.prototype.ReviewUniform = function(t, r) {
    if (t == "uniform" && this._newUniforms)
      for (var n = 0; n < this._newUniforms.length; n++)
        this._customUniform[n].indexOf("sampler") == -1 && r.push(this._newUniforms[n]);
    if (t == "sampler" && this._newUniforms)
      for (var n = 0; n < this._newUniforms.length; n++)
        this._customUniform[n].indexOf("sampler") != -1 && r.push(this._newUniforms[n]);
    return r;
  }, e.prototype.Builder = function(t, r, n, a, s, o) {
    var u = this;
    if (o && this._customAttributes && this._customAttributes.length > 0 && o.push.apply(o, this._customAttributes), this.ReviewUniform("uniform", r), this.ReviewUniform("sampler", a), this._isCreatedShader)
      return this._createdShaderName;
    this._isCreatedShader = !1, e.ShaderIndexer++;
    var f = "custom_" + e.ShaderIndexer, l = this._afterBind.bind(this);
    return this._afterBind = function(h, c) {
      if (!!c) {
        u.AttachAfterBind(h, c);
        try {
          l(h, c);
        } catch {
        }
      }
    }, ze.ShadersStore[f + "VertexShader"] = this.VertexShader.replace("#define CUSTOM_VERTEX_BEGIN", this.CustomParts.Vertex_Begin ? this.CustomParts.Vertex_Begin : "").replace("#define CUSTOM_VERTEX_DEFINITIONS", (this._customUniform ? this._customUniform.join(`
`) : "") + (this.CustomParts.Vertex_Definitions ? this.CustomParts.Vertex_Definitions : "")).replace("#define CUSTOM_VERTEX_MAIN_BEGIN", this.CustomParts.Vertex_MainBegin ? this.CustomParts.Vertex_MainBegin : "").replace("#define CUSTOM_VERTEX_UPDATE_POSITION", this.CustomParts.Vertex_Before_PositionUpdated ? this.CustomParts.Vertex_Before_PositionUpdated : "").replace("#define CUSTOM_VERTEX_UPDATE_NORMAL", this.CustomParts.Vertex_Before_NormalUpdated ? this.CustomParts.Vertex_Before_NormalUpdated : "").replace("#define CUSTOM_VERTEX_MAIN_END", this.CustomParts.Vertex_MainEnd ? this.CustomParts.Vertex_MainEnd : ""), this.CustomParts.Vertex_After_WorldPosComputed && (ze.ShadersStore[f + "VertexShader"] = ze.ShadersStore[f + "VertexShader"].replace("#define CUSTOM_VERTEX_UPDATE_WORLDPOS", this.CustomParts.Vertex_After_WorldPosComputed)), ze.ShadersStore[f + "PixelShader"] = this.FragmentShader.replace("#define CUSTOM_FRAGMENT_BEGIN", this.CustomParts.Fragment_Begin ? this.CustomParts.Fragment_Begin : "").replace("#define CUSTOM_FRAGMENT_MAIN_BEGIN", this.CustomParts.Fragment_MainBegin ? this.CustomParts.Fragment_MainBegin : "").replace("#define CUSTOM_FRAGMENT_DEFINITIONS", (this._customUniform ? this._customUniform.join(`
`) : "") + (this.CustomParts.Fragment_Definitions ? this.CustomParts.Fragment_Definitions : "")).replace("#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE", this.CustomParts.Fragment_Custom_Diffuse ? this.CustomParts.Fragment_Custom_Diffuse : "").replace("#define CUSTOM_FRAGMENT_UPDATE_ALPHA", this.CustomParts.Fragment_Custom_Alpha ? this.CustomParts.Fragment_Custom_Alpha : "").replace("#define CUSTOM_FRAGMENT_BEFORE_LIGHTS", this.CustomParts.Fragment_Before_Lights ? this.CustomParts.Fragment_Before_Lights : "").replace("#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR", this.CustomParts.Fragment_Before_FragColor ? this.CustomParts.Fragment_Before_FragColor : "").replace("#define CUSTOM_FRAGMENT_MAIN_END", this.CustomParts.Fragment_MainEnd ? this.CustomParts.Fragment_MainEnd : ""), this.CustomParts.Fragment_Before_Fog && (ze.ShadersStore[f + "PixelShader"] = ze.ShadersStore[f + "PixelShader"].replace("#define CUSTOM_FRAGMENT_BEFORE_FOG", this.CustomParts.Fragment_Before_Fog)), this._isCreatedShader = !0, this._createdShaderName = f, f;
  }, e.prototype.AddUniform = function(t, r, n) {
    return this._customUniform || (this._customUniform = new Array(), this._newUniforms = new Array(), this._newSamplerInstances = {}, this._newUniformInstances = {}), n && (r.indexOf("sampler") != -1 ? this._newSamplerInstances[r + "-" + t] = n : this._newUniformInstances[r + "-" + t] = n), this._customUniform.push("uniform " + r + " " + t + ";"), this._newUniforms.push(t), this;
  }, e.prototype.AddAttribute = function(t) {
    return this._customAttributes || (this._customAttributes = []), this._customAttributes.push(t), this;
  }, e.prototype.Fragment_Begin = function(t) {
    return this.CustomParts.Fragment_Begin = t, this;
  }, e.prototype.Fragment_Definitions = function(t) {
    return this.CustomParts.Fragment_Definitions = t, this;
  }, e.prototype.Fragment_MainBegin = function(t) {
    return this.CustomParts.Fragment_MainBegin = t, this;
  }, e.prototype.Fragment_MainEnd = function(t) {
    return this.CustomParts.Fragment_MainEnd = t, this;
  }, e.prototype.Fragment_Custom_Diffuse = function(t) {
    return this.CustomParts.Fragment_Custom_Diffuse = t.replace("result", "diffuseColor"), this;
  }, e.prototype.Fragment_Custom_Alpha = function(t) {
    return this.CustomParts.Fragment_Custom_Alpha = t.replace("result", "alpha"), this;
  }, e.prototype.Fragment_Before_Lights = function(t) {
    return this.CustomParts.Fragment_Before_Lights = t, this;
  }, e.prototype.Fragment_Before_Fog = function(t) {
    return this.CustomParts.Fragment_Before_Fog = t, this;
  }, e.prototype.Fragment_Before_FragColor = function(t) {
    return this.CustomParts.Fragment_Before_FragColor = t.replace("result", "color"), this;
  }, e.prototype.Vertex_Begin = function(t) {
    return this.CustomParts.Vertex_Begin = t, this;
  }, e.prototype.Vertex_Definitions = function(t) {
    return this.CustomParts.Vertex_Definitions = t, this;
  }, e.prototype.Vertex_MainBegin = function(t) {
    return this.CustomParts.Vertex_MainBegin = t, this;
  }, e.prototype.Vertex_Before_PositionUpdated = function(t) {
    return this.CustomParts.Vertex_Before_PositionUpdated = t.replace("result", "positionUpdated"), this;
  }, e.prototype.Vertex_Before_NormalUpdated = function(t) {
    return this.CustomParts.Vertex_Before_NormalUpdated = t.replace("result", "normalUpdated"), this;
  }, e.prototype.Vertex_After_WorldPosComputed = function(t) {
    return this.CustomParts.Vertex_After_WorldPosComputed = t, this;
  }, e.prototype.Vertex_MainEnd = function(t) {
    return this.CustomParts.Vertex_MainEnd = t, this;
  }, e.ShaderIndexer = 1, e;
}(or);
Ne("BABYLON.CustomMaterial", xr);
xr.prototype.clone = function(i) {
  const e = this, t = $.Clone(() => new xr(i, this.getScene()), this);
  return t.name = i, t.id = i, t.CustomParts.Fragment_Begin = e.CustomParts.Fragment_Begin, t.CustomParts.Fragment_Definitions = e.CustomParts.Fragment_Definitions, t.CustomParts.Fragment_MainBegin = e.CustomParts.Fragment_MainBegin, t.CustomParts.Fragment_Custom_Diffuse = e.CustomParts.Fragment_Custom_Diffuse, t.CustomParts.Fragment_Before_Lights = e.CustomParts.Fragment_Before_Lights, t.CustomParts.Fragment_Before_Fog = e.CustomParts.Fragment_Before_Fog, t.CustomParts.Fragment_Custom_Alpha = e.CustomParts.Fragment_Custom_Alpha, t.CustomParts.Fragment_Before_FragColor = e.CustomParts.Fragment_Before_FragColor, t.CustomParts.Vertex_Begin = e.CustomParts.Vertex_Begin, t.CustomParts.Vertex_Definitions = e.CustomParts.Vertex_Definitions, t.CustomParts.Vertex_MainBegin = e.CustomParts.Vertex_MainBegin, t.CustomParts.Vertex_Before_PositionUpdated = e.CustomParts.Vertex_Before_PositionUpdated, t.CustomParts.Vertex_Before_NormalUpdated = e.CustomParts.Vertex_Before_NormalUpdated, t.CustomParts.Vertex_After_WorldPosComputed = e.CustomParts.Vertex_After_WorldPosComputed, t.CustomParts.Vertex_MainEnd = e.CustomParts.Vertex_MainEnd, t;
};
class Sf {
  constructor(e) {
    Xe(this, "loadedThemes", {});
    Xe(this, "themeData", {});
    this.scene = e.scene;
  }
  async loadStandardMaterial(e) {
    const { theme: t, material: r } = e, n = new or(t, this.scene);
    r.diffuseTexture && (n.diffuseTexture = await this.getTexture("diffuse", e)), r.bumpTexture && (n.bumpTexture = await this.getTexture("bump", e)), r.specularTexture && (n.specularTexture = await this.getTexture("specular", e)), n.allowShaderHotSwapping = !1;
  }
  async loadColorMaterial(e) {
    const { theme: t, material: r } = e, n = new xr(t + "_light", this.scene), a = qi(e);
    r.diffuseTexture && r.diffuseTexture.light && (a.material.diffuseTexture = e.material.diffuseTexture.light, n.diffuseTexture = await this.getTexture("diffuse", a)), r.bumpTexture && (n.bumpTexture = await this.getTexture("bump", e)), r.specularTexture && (n.specularTexture = await this.getTexture("specular", e)), n.allowShaderHotSwapping = !1, n.Vertex_Definitions(`
      attribute vec3 customColor;
      varying vec3 vColor;
    `).Vertex_MainEnd(`
      vColor = customColor;
    `).Fragment_Definitions(`
      varying vec3 vColor;
    `).Fragment_Custom_Diffuse(`
      baseColor.rgb = mix(vColor.rgb, baseColor.rgb, baseColor.a);
    `), n.AddAttribute("customColor");
    const s = n.clone(t + "_dark");
    r.diffuseTexture && r.diffuseTexture.dark && (a.material.diffuseTexture = e.material.diffuseTexture.dark, s.diffuseTexture = await this.getTexture("diffuse", a)), s.AddAttribute("customColor");
  }
  async getTexture(e, t) {
    const { basePath: r, material: n, theme: a } = t;
    let s;
    const o = e + "Level", u = e + "Texture";
    try {
      switch (e) {
        case "diffuse":
          s = await this.importTextureAsync(`${r}/${n[u]}`, a), n[o] && (s.level = n[o]);
          break;
        case "bump":
          s = await this.importTextureAsync(`${r}/${n[u]}`, a), n[o] && (s.level = n[o]);
          break;
        case "specular":
          s = await this.importTextureAsync(`${r}/${n[u]}`, a), n.specularPower && (s.specularPower = n.specularPower);
          break;
        default:
          throw new Error(`Texture type: ${e} is not supported`);
      }
    } catch (f) {
      console.error(f);
    }
    return s;
  }
  async importTextureAsync(e, t) {
    return new Promise((r, n) => {
      let a = e.match(/^(.*\/)(.*)$/), s = new ee(
        e,
        this.scene,
        void 0,
        !0,
        void 0,
        () => r(s),
        () => n(`Unable to load texture '${a[2]}' for theme: '${t}'. Check that your assetPath is configured correctly and that the files exist at path: '${a[1]}'`)
      );
    }).catch((r) => console.error(r));
  }
  async load(e) {
    const { material: t } = e;
    t.type === "color" ? await this.loadColorMaterial(e) : t.type === "standard" ? await this.loadStandardMaterial(e) : console.error(`Material type: ${t.type} not supported`);
  }
}
var Te, Wt, rt, zt, qe, Ke, Pe, Dr, Qe, rr, ir, We, nr, Ir, bn;
class Rf {
  constructor(e) {
    Oe(this, Ir);
    Xe(this, "config");
    Xe(this, "initialized", !1);
    Oe(this, Te, {});
    Oe(this, Wt, 0);
    Oe(this, rt, 0);
    Oe(this, zt, []);
    Oe(this, qe, void 0);
    Oe(this, Ke, void 0);
    Oe(this, Pe, void 0);
    Oe(this, Dr, void 0);
    Oe(this, Qe, void 0);
    Oe(this, rr, void 0);
    Oe(this, ir, void 0);
    Oe(this, We, void 0);
    Oe(this, nr, {});
    Xe(this, "noop", () => {
    });
    Xe(this, "diceBufferView", new Float32Array(8e3));
    this.onInitComplete = e.onInitComplete || this.noop, this.onThemeLoaded = e.onThemeLoaded || this.noop, this.onRollResult = e.onRollResult || this.noop, this.onRollComplete = e.onRollComplete || this.noop, this.onDieRemoved = e.onDieRemoved || this.noop, this.initialized = this.initScene(e);
  }
  async initScene(e) {
    Ue(this, qe, e.canvas), V(this, qe).width = e.width, V(this, qe).height = e.height, this.config = e.options, Ue(this, Ke, Xn(V(this, qe))), Ue(this, Pe, Fa({ engine: V(this, Ke) })), Ue(this, Dr, La({ engine: V(this, Ke), scene: V(this, Pe) })), Ue(this, Qe, Zi({
      enableShadows: this.config.enableShadows,
      shadowTransparency: this.config.shadowTransparency,
      intensity: this.config.lightIntensity,
      scene: V(this, Pe)
    })), Ue(this, rr, new mf({
      enableShadows: this.config.enableShadows,
      aspect: V(this, qe).width / V(this, qe).height,
      lights: V(this, Qe),
      scene: V(this, Pe)
    })), Ue(this, ir, new Sf({ scene: V(this, Pe) })), this.onInitComplete();
  }
  connect(e) {
    Ue(this, We, e), V(this, We).postMessage({
      action: "initBuffer",
      diceBuffer: this.diceBufferView.buffer
    }, [this.diceBufferView.buffer]), V(this, We).onmessage = (t) => {
      switch (t.data.action) {
        case "updates":
          this.updatesFromPhysics(t.data.diceBuffer);
          break;
        default:
          console.error("action from physicsWorker not found in offscreen worker");
          break;
      }
    };
  }
  updateConfig(e) {
    const t = this.config;
    this.config = e, t.enableShadows !== this.config.enableShadows && (Object.values(V(this, Qe)).forEach((r) => r.dispose()), Ue(this, Qe, Zi({ enableShadows: this.config.enableShadows }))), t.scale !== this.config.scale && Object.values(V(this, Te)).forEach(({ mesh: r }) => {
      r && (r.scaling = new b(this.config.scale, this.config.scale, this.config.scale));
    }), t.shadowTransparency !== this.config.shadowTransparency && (V(this, Qe).directional.shadowGenerator.darkness = this.config.shadowTransparency), t.lightIntensity !== this.config.lightIntensity && (V(this, Qe).directional.intensity = 0.65 * this.config.lightIntensity, V(this, Qe).hemispheric.intensity = 0.4 * this.config.lightIntensity);
  }
  render(e) {
    V(this, Ke).runRenderLoop(this.renderLoop.bind(this)), V(this, We).postMessage({
      action: "resumeSimulation",
      newStartPoint: e
    });
  }
  renderLoop() {
    V(this, rt) && V(this, rt) === Object.keys(V(this, Te)).length ? (V(this, Ke).stopRenderLoop(), V(this, We).postMessage({
      action: "stopSimulation"
    }), this.onRollComplete()) : V(this, Pe).render();
  }
  async loadTheme(e) {
    const { theme: t, basePath: r, material: n, meshFilePath: a, meshName: s } = e;
    if (await V(this, ir).load({ theme: t, basePath: r, material: n }), !Object.keys(V(this, nr)).includes(s)) {
      V(this, nr)[s] = a;
      const o = await it.loadModels({ meshFilePath: a, meshName: s }, V(this, Pe));
      if (!o)
        throw new Error("No colliders returned from the 3D mesh file. Low poly colliders are expected to be in the same file as the high poly dice and the mesh name contains the word 'collider'");
      V(this, We).postMessage({
        action: "loadModels",
        options: {
          colliders: o,
          meshName: s
        }
      });
    }
    this.onThemeLoaded({ id: t });
  }
  clear() {
    !Object.keys(V(this, Te)).length && !V(this, rt) || (this.diceBufferView.byteLength && this.diceBufferView.fill(0), V(this, zt).forEach((e) => clearTimeout(e)), V(this, Ke).stopRenderLoop(), Object.values(V(this, Te)).forEach((e) => {
      e.mesh && e.mesh.dispose();
    }), Ue(this, Te, {}), Ue(this, Wt, 0), Ue(this, rt, 0), V(this, Pe).render());
  }
  add(e) {
    it.loadDie(e, V(this, Pe)).then((t) => {
      V(this, zt).push(setTimeout(() => {
        bi(this, Ir, bn).call(this, t);
      }, It(this, Wt)._++ * this.config.delay));
    });
  }
  addNonDie(e) {
    V(this, Ke).activeRenderLoops.length === 0 && this.render(!1);
    const { id: t, value: r, ...n } = e, a = {
      id: t,
      value: r,
      config: n
    };
    V(this, Te)[t] = a, setTimeout(() => {
      V(this, zt).push(setTimeout(() => {
        this.handleAsleep(a);
      }, It(this, Wt)._++ * this.config.delay));
    }, 10);
  }
  remove(e) {
    const t = V(this, Te)[e.id];
    t.hasOwnProperty("d10Instance") && (V(this, Te)[t.d10Instance.id].mesh && (V(this, Te)[t.d10Instance.id].mesh.dispose(), V(this, We).postMessage({
      action: "removeDie",
      id: t.d10Instance.id
    })), delete V(this, Te)[t.d10Instance.id], It(this, rt)._--), V(this, Te)[e.id].mesh && V(this, Te)[e.id].mesh.dispose(), delete V(this, Te)[e.id], It(this, rt)._--, V(this, Pe).render(), this.onDieRemoved(e.rollId);
  }
  updatesFromPhysics(e) {
    this.diceBufferView = new Float32Array(e);
    let t = 1;
    for (let r = 0, n = this.diceBufferView[0]; r < n; r++) {
      if (!Object.keys(V(this, Te)).length)
        continue;
      const a = V(this, Te)[`${this.diceBufferView[t]}`];
      if (!a) {
        console.log("Error: die not available in scene to animate");
        break;
      }
      if (this.diceBufferView[t + 1] === -1)
        this.handleAsleep(a);
      else {
        const s = this.diceBufferView[t + 1], o = this.diceBufferView[t + 2], u = this.diceBufferView[t + 3], f = this.diceBufferView[t + 4], l = this.diceBufferView[t + 5], h = this.diceBufferView[t + 6], c = this.diceBufferView[t + 7];
        a.mesh.position.set(s, o, u), a.mesh.rotationQuaternion.set(f, l, h, c);
      }
      t = t + 8;
    }
    requestAnimationFrame(() => {
      V(this, We).postMessage({
        action: "stepSimulation",
        diceBuffer: this.diceBufferView.buffer
      }, [this.diceBufferView.buffer]);
    });
  }
  async handleAsleep(e) {
    var t, r;
    if (e.asleep = !0, await it.getRollResult(e, V(this, Pe)), e.d10Instance || e.dieParent) {
      if (((t = e == null ? void 0 : e.d10Instance) == null ? void 0 : t.asleep) || ((r = e == null ? void 0 : e.dieParent) == null ? void 0 : r.asleep)) {
        const n = e.config.sides === 100 ? e : e.dieParent, a = e.config.sides === 10 ? e : e.d10Instance;
        a.value === 0 && n.value === 0 ? n.value = 100 : n.value = n.value + a.value, this.onRollResult({
          rollId: n.config.rollId,
          value: n.value
        });
      }
    } else
      e.config.sides === 10 && e.value === 0 && (e.value = 10), this.onRollResult({
        rollId: e.config.rollId,
        value: e.value
      });
    It(this, rt)._++;
  }
  resize(e) {
    const t = V(this, qe).width = e.width, r = V(this, qe).height = e.height;
    V(this, rr).create({ aspect: t / r }), V(this, Ke).resize();
  }
}
Te = new WeakMap(), Wt = new WeakMap(), rt = new WeakMap(), zt = new WeakMap(), qe = new WeakMap(), Ke = new WeakMap(), Pe = new WeakMap(), Dr = new WeakMap(), Qe = new WeakMap(), rr = new WeakMap(), ir = new WeakMap(), We = new WeakMap(), nr = new WeakMap(), Ir = new WeakSet(), bn = async function(e) {
  V(this, Ke).activeRenderLoops.length === 0 && this.render(e.newStartPoint);
  const t = {
    ...e,
    assetPath: this.config.assetPath,
    enableShadows: this.config.enableShadows,
    scale: this.config.scale,
    lights: V(this, Qe)
  }, r = new it(t, V(this, Pe));
  return V(this, Te)[r.id] = r, V(this, We).postMessage({
    action: "addDie",
    options: {
      sides: e.sides,
      scale: this.config.scale,
      id: r.id,
      newStartPoint: e.newStartPoint,
      theme: e.theme,
      meshName: e.meshName
    }
  }), e.sides === 100 && (r.d10Instance = await it.loadDie({ ...t, sides: 10, id: r.id + 1e4 }, V(this, Pe)).then((n) => {
    const a = new it(n, V(this, Pe));
    return a.dieParent = r, a;
  }), V(this, Te)[`${r.d10Instance.id}`] = r.d10Instance, V(this, We).postMessage({
    action: "addDie",
    options: {
      sides: 10,
      scale: this.config.scale,
      id: r.d10Instance.id,
      theme: e.theme,
      meshName: e.meshName
    }
  })), r;
};
export {
  Rf as default
};
