var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet(obj, member, value, setter);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  };
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _dieCache, _count, _sleeperCount, _dieRollTimer, _canvas, _engine, _scene, _camera, _lights, _diceBox, _physicsWorkerPort, _add, add_fn;
var Scalar = function() {
  function Scalar2() {
  }
  Scalar2.WithinEpsilon = function(a, b, epsilon) {
    if (epsilon === void 0) {
      epsilon = 1401298e-51;
    }
    return Math.abs(a - b) <= epsilon;
  };
  Scalar2.ToHex = function(i) {
    var str = i.toString(16);
    if (i <= 15) {
      return ("0" + str).toUpperCase();
    }
    return str.toUpperCase();
  };
  Scalar2.Sign = function(value) {
    value = +value;
    if (value === 0 || isNaN(value)) {
      return value;
    }
    return value > 0 ? 1 : -1;
  };
  Scalar2.Clamp = function(value, min, max) {
    if (min === void 0) {
      min = 0;
    }
    if (max === void 0) {
      max = 1;
    }
    return Math.min(max, Math.max(min, value));
  };
  Scalar2.Log2 = function(value) {
    return Math.log(value) * Math.LOG2E;
  };
  Scalar2.ILog2 = function(value) {
    if (Math.log2) {
      return Math.floor(Math.log2(value));
    }
    if (value < 0) {
      return NaN;
    } else if (value === 0) {
      return -Infinity;
    }
    var n = 0;
    if (value < 1) {
      while (value < 1) {
        n++;
        value = value * 2;
      }
      n = -n;
    } else if (value > 1) {
      while (value > 1) {
        n++;
        value = Math.floor(value / 2);
      }
    }
    return n;
  };
  Scalar2.Repeat = function(value, length) {
    return value - Math.floor(value / length) * length;
  };
  Scalar2.Normalize = function(value, min, max) {
    return (value - min) / (max - min);
  };
  Scalar2.Denormalize = function(normalized, min, max) {
    return normalized * (max - min) + min;
  };
  Scalar2.DeltaAngle = function(current, target) {
    var num = Scalar2.Repeat(target - current, 360);
    if (num > 180) {
      num -= 360;
    }
    return num;
  };
  Scalar2.PingPong = function(tx, length) {
    var t = Scalar2.Repeat(tx, length * 2);
    return length - Math.abs(t - length);
  };
  Scalar2.SmoothStep = function(from, to, tx) {
    var t = Scalar2.Clamp(tx);
    t = -2 * t * t * t + 3 * t * t;
    return to * t + from * (1 - t);
  };
  Scalar2.MoveTowards = function(current, target, maxDelta) {
    var result = 0;
    if (Math.abs(target - current) <= maxDelta) {
      result = target;
    } else {
      result = current + Scalar2.Sign(target - current) * maxDelta;
    }
    return result;
  };
  Scalar2.MoveTowardsAngle = function(current, target, maxDelta) {
    var num = Scalar2.DeltaAngle(current, target);
    var result = 0;
    if (-maxDelta < num && num < maxDelta) {
      result = target;
    } else {
      target = current + num;
      result = Scalar2.MoveTowards(current, target, maxDelta);
    }
    return result;
  };
  Scalar2.Lerp = function(start, end, amount) {
    return start + (end - start) * amount;
  };
  Scalar2.LerpAngle = function(start, end, amount) {
    var num = Scalar2.Repeat(end - start, 360);
    if (num > 180) {
      num -= 360;
    }
    return start + num * Scalar2.Clamp(amount);
  };
  Scalar2.InverseLerp = function(a, b, value) {
    var result = 0;
    if (a != b) {
      result = Scalar2.Clamp((value - a) / (b - a));
    } else {
      result = 0;
    }
    return result;
  };
  Scalar2.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;
  };
  Scalar2.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
    var t2 = time * time;
    return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;
  };
  Scalar2.RandomRange = function(min, max) {
    if (min === max) {
      return min;
    }
    return Math.random() * (max - min) + min;
  };
  Scalar2.RangeToPercent = function(number, min, max) {
    return (number - min) / (max - min);
  };
  Scalar2.PercentToRange = function(percent, min, max) {
    return (max - min) * percent + min;
  };
  Scalar2.NormalizeRadians = function(angle) {
    angle -= Scalar2.TwoPi * Math.floor((angle + Math.PI) / Scalar2.TwoPi);
    return angle;
  };
  Scalar2.HCF = function(a, b) {
    var r = a % b;
    if (r === 0) {
      return b;
    }
    return Scalar2.HCF(b, r);
  };
  Scalar2.TwoPi = Math.PI * 2;
  return Scalar2;
}();
var ToGammaSpace = 1 / 2.2;
var ToLinearSpace = 2.2;
var Epsilon = 1e-3;
var ArrayTools = function() {
  function ArrayTools2() {
  }
  ArrayTools2.BuildArray = function(size, itemBuilder) {
    var a = [];
    for (var i = 0; i < size; ++i) {
      a.push(itemBuilder());
    }
    return a;
  };
  ArrayTools2.BuildTuple = function(size, itemBuilder) {
    return ArrayTools2.BuildArray(size, itemBuilder);
  };
  return ArrayTools2;
}();
var _RegisteredTypes = {};
function RegisterClass(className, type) {
  _RegisteredTypes[className] = type;
}
function GetClass(fqdn) {
  return _RegisteredTypes[fqdn];
}
var PerformanceConfigurator = function() {
  function PerformanceConfigurator2() {
  }
  PerformanceConfigurator2.SetMatrixPrecision = function(use64bits) {
    PerformanceConfigurator2.MatrixTrackPrecisionChange = false;
    if (use64bits && !PerformanceConfigurator2.MatrixUse64Bits) {
      if (PerformanceConfigurator2.MatrixTrackedMatrices) {
        for (var m = 0; m < PerformanceConfigurator2.MatrixTrackedMatrices.length; ++m) {
          var matrix = PerformanceConfigurator2.MatrixTrackedMatrices[m];
          var values = matrix._m;
          matrix._m = new Array(16);
          for (var i = 0; i < 16; ++i) {
            matrix._m[i] = values[i];
          }
        }
      }
    }
    PerformanceConfigurator2.MatrixUse64Bits = use64bits;
    PerformanceConfigurator2.MatrixCurrentType = PerformanceConfigurator2.MatrixUse64Bits ? Array : Float32Array;
    PerformanceConfigurator2.MatrixTrackedMatrices = null;
  };
  PerformanceConfigurator2.MatrixUse64Bits = false;
  PerformanceConfigurator2.MatrixTrackPrecisionChange = true;
  PerformanceConfigurator2.MatrixCurrentType = Float32Array;
  PerformanceConfigurator2.MatrixTrackedMatrices = [];
  return PerformanceConfigurator2;
}();
var EngineStore = function() {
  function EngineStore2() {
  }
  Object.defineProperty(EngineStore2, "LastCreatedEngine", {
    get: function() {
      if (this.Instances.length === 0) {
        return null;
      }
      return this.Instances[this.Instances.length - 1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EngineStore2, "LastCreatedScene", {
    get: function() {
      return this._LastCreatedScene;
    },
    enumerable: false,
    configurable: true
  });
  EngineStore2.Instances = new Array();
  EngineStore2._LastCreatedScene = null;
  EngineStore2.UseFallbackTexture = true;
  EngineStore2.FallbackTexture = "";
  return EngineStore2;
}();
var _ExtractAsInt = function(value) {
  return parseInt(value.toString().replace(/\W/g, ""));
};
var Vector2 = function() {
  function Vector22(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this.x = x;
    this.y = y;
  }
  Vector22.prototype.toString = function() {
    return "{X: ".concat(this.x, " Y: ").concat(this.y, "}");
  };
  Vector22.prototype.getClassName = function() {
    return "Vector2";
  };
  Vector22.prototype.getHashCode = function() {
    var x = _ExtractAsInt(this.x);
    var y = _ExtractAsInt(this.y);
    var hash = x;
    hash = hash * 397 ^ y;
    return hash;
  };
  Vector22.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.x;
    array[index + 1] = this.y;
    return this;
  };
  Vector22.prototype.fromArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    Vector22.FromArrayToRef(array, index, this);
    return this;
  };
  Vector22.prototype.asArray = function() {
    var result = new Array();
    this.toArray(result, 0);
    return result;
  };
  Vector22.prototype.copyFrom = function(source) {
    this.x = source.x;
    this.y = source.y;
    return this;
  };
  Vector22.prototype.copyFromFloats = function(x, y) {
    this.x = x;
    this.y = y;
    return this;
  };
  Vector22.prototype.set = function(x, y) {
    return this.copyFromFloats(x, y);
  };
  Vector22.prototype.add = function(otherVector) {
    return new Vector22(this.x + otherVector.x, this.y + otherVector.y);
  };
  Vector22.prototype.addToRef = function(otherVector, result) {
    result.x = this.x + otherVector.x;
    result.y = this.y + otherVector.y;
    return this;
  };
  Vector22.prototype.addInPlace = function(otherVector) {
    this.x += otherVector.x;
    this.y += otherVector.y;
    return this;
  };
  Vector22.prototype.addVector3 = function(otherVector) {
    return new Vector22(this.x + otherVector.x, this.y + otherVector.y);
  };
  Vector22.prototype.subtract = function(otherVector) {
    return new Vector22(this.x - otherVector.x, this.y - otherVector.y);
  };
  Vector22.prototype.subtractToRef = function(otherVector, result) {
    result.x = this.x - otherVector.x;
    result.y = this.y - otherVector.y;
    return this;
  };
  Vector22.prototype.subtractInPlace = function(otherVector) {
    this.x -= otherVector.x;
    this.y -= otherVector.y;
    return this;
  };
  Vector22.prototype.multiplyInPlace = function(otherVector) {
    this.x *= otherVector.x;
    this.y *= otherVector.y;
    return this;
  };
  Vector22.prototype.multiply = function(otherVector) {
    return new Vector22(this.x * otherVector.x, this.y * otherVector.y);
  };
  Vector22.prototype.multiplyToRef = function(otherVector, result) {
    result.x = this.x * otherVector.x;
    result.y = this.y * otherVector.y;
    return this;
  };
  Vector22.prototype.multiplyByFloats = function(x, y) {
    return new Vector22(this.x * x, this.y * y);
  };
  Vector22.prototype.divide = function(otherVector) {
    return new Vector22(this.x / otherVector.x, this.y / otherVector.y);
  };
  Vector22.prototype.divideToRef = function(otherVector, result) {
    result.x = this.x / otherVector.x;
    result.y = this.y / otherVector.y;
    return this;
  };
  Vector22.prototype.divideInPlace = function(otherVector) {
    return this.divideToRef(otherVector, this);
  };
  Vector22.prototype.negate = function() {
    return new Vector22(-this.x, -this.y);
  };
  Vector22.prototype.negateInPlace = function() {
    this.x *= -1;
    this.y *= -1;
    return this;
  };
  Vector22.prototype.negateToRef = function(result) {
    return result.copyFromFloats(this.x * -1, this.y * -1);
  };
  Vector22.prototype.scaleInPlace = function(scale) {
    this.x *= scale;
    this.y *= scale;
    return this;
  };
  Vector22.prototype.scale = function(scale) {
    var result = new Vector22(0, 0);
    this.scaleToRef(scale, result);
    return result;
  };
  Vector22.prototype.scaleToRef = function(scale, result) {
    result.x = this.x * scale;
    result.y = this.y * scale;
    return this;
  };
  Vector22.prototype.scaleAndAddToRef = function(scale, result) {
    result.x += this.x * scale;
    result.y += this.y * scale;
    return this;
  };
  Vector22.prototype.equals = function(otherVector) {
    return otherVector && this.x === otherVector.x && this.y === otherVector.y;
  };
  Vector22.prototype.equalsWithEpsilon = function(otherVector, epsilon) {
    if (epsilon === void 0) {
      epsilon = Epsilon;
    }
    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon);
  };
  Vector22.prototype.floor = function() {
    return new Vector22(Math.floor(this.x), Math.floor(this.y));
  };
  Vector22.prototype.fract = function() {
    return new Vector22(this.x - Math.floor(this.x), this.y - Math.floor(this.y));
  };
  Vector22.prototype.rotateToRef = function(angle, result) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    result.x = cos * this.x - sin * this.y;
    result.y = sin * this.x + cos * this.y;
    return this;
  };
  Vector22.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };
  Vector22.prototype.lengthSquared = function() {
    return this.x * this.x + this.y * this.y;
  };
  Vector22.prototype.normalize = function() {
    Vector22.NormalizeToRef(this, this);
    return this;
  };
  Vector22.prototype.clone = function() {
    return new Vector22(this.x, this.y);
  };
  Vector22.Zero = function() {
    return new Vector22(0, 0);
  };
  Vector22.One = function() {
    return new Vector22(1, 1);
  };
  Vector22.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    return new Vector22(array[offset], array[offset + 1]);
  };
  Vector22.FromArrayToRef = function(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
  };
  Vector22.CatmullRom = function(value1, value2, value3, value4, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var x = 0.5 * (2 * value2.x + (-value1.x + value3.x) * amount + (2 * value1.x - 5 * value2.x + 4 * value3.x - value4.x) * squared + (-value1.x + 3 * value2.x - 3 * value3.x + value4.x) * cubed);
    var y = 0.5 * (2 * value2.y + (-value1.y + value3.y) * amount + (2 * value1.y - 5 * value2.y + 4 * value3.y - value4.y) * squared + (-value1.y + 3 * value2.y - 3 * value3.y + value4.y) * cubed);
    return new Vector22(x, y);
  };
  Vector22.Clamp = function(value, min, max) {
    var x = value.x;
    x = x > max.x ? max.x : x;
    x = x < min.x ? min.x : x;
    var y = value.y;
    y = y > max.y ? max.y : y;
    y = y < min.y ? min.y : y;
    return new Vector22(x, y);
  };
  Vector22.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    var x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;
    var y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;
    return new Vector22(x, y);
  };
  Vector22.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
    var result = Vector22.Zero();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  };
  Vector22.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
    var t2 = time * time;
    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
  };
  Vector22.Lerp = function(start, end, amount) {
    var x = start.x + (end.x - start.x) * amount;
    var y = start.y + (end.y - start.y) * amount;
    return new Vector22(x, y);
  };
  Vector22.Dot = function(left, right) {
    return left.x * right.x + left.y * right.y;
  };
  Vector22.Normalize = function(vector) {
    var newVector = Vector22.Zero();
    this.NormalizeToRef(vector, newVector);
    return newVector;
  };
  Vector22.NormalizeToRef = function(vector, result) {
    var len = vector.length();
    if (len === 0) {
      return;
    }
    result.x = vector.x / len;
    result.y = vector.y / len;
  };
  Vector22.Minimize = function(left, right) {
    var x = left.x < right.x ? left.x : right.x;
    var y = left.y < right.y ? left.y : right.y;
    return new Vector22(x, y);
  };
  Vector22.Maximize = function(left, right) {
    var x = left.x > right.x ? left.x : right.x;
    var y = left.y > right.y ? left.y : right.y;
    return new Vector22(x, y);
  };
  Vector22.Transform = function(vector, transformation) {
    var r = Vector22.Zero();
    Vector22.TransformToRef(vector, transformation, r);
    return r;
  };
  Vector22.TransformToRef = function(vector, transformation, result) {
    var m = transformation.m;
    var x = vector.x * m[0] + vector.y * m[4] + m[12];
    var y = vector.x * m[1] + vector.y * m[5] + m[13];
    result.x = x;
    result.y = y;
  };
  Vector22.PointInTriangle = function(p, p0, p1, p2) {
    var a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
    var sign = a < 0 ? -1 : 1;
    var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
    var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;
    return s > 0 && t > 0 && s + t < 2 * a * sign;
  };
  Vector22.Distance = function(value1, value2) {
    return Math.sqrt(Vector22.DistanceSquared(value1, value2));
  };
  Vector22.DistanceSquared = function(value1, value2) {
    var x = value1.x - value2.x;
    var y = value1.y - value2.y;
    return x * x + y * y;
  };
  Vector22.Center = function(value1, value2) {
    return Vector22.CenterToRef(value1, value2, Vector22.Zero());
  };
  Vector22.CenterToRef = function(value1, value2, ref) {
    return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2);
  };
  Vector22.DistanceOfPointFromSegment = function(p, segA, segB) {
    var l2 = Vector22.DistanceSquared(segA, segB);
    if (l2 === 0) {
      return Vector22.Distance(p, segA);
    }
    var v = segB.subtract(segA);
    var t = Math.max(0, Math.min(1, Vector22.Dot(p.subtract(segA), v) / l2));
    var proj = segA.add(v.multiplyByFloats(t, t));
    return Vector22.Distance(p, proj);
  };
  return Vector22;
}();
var Vector3 = function() {
  function Vector32(x, y, z) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    this._isDirty = true;
    this._x = x;
    this._y = y;
    this._z = z;
  }
  Object.defineProperty(Vector32.prototype, "x", {
    get: function() {
      return this._x;
    },
    set: function(value) {
      this._x = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32.prototype, "y", {
    get: function() {
      return this._y;
    },
    set: function(value) {
      this._y = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32.prototype, "z", {
    get: function() {
      return this._z;
    },
    set: function(value) {
      this._z = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Vector32.prototype.toString = function() {
    return "{X: ".concat(this._x, " Y: ").concat(this._y, " Z: ").concat(this._z, "}");
  };
  Vector32.prototype.getClassName = function() {
    return "Vector3";
  };
  Vector32.prototype.getHashCode = function() {
    var x = _ExtractAsInt(this._x);
    var y = _ExtractAsInt(this._y);
    var z = _ExtractAsInt(this._z);
    var hash = x;
    hash = hash * 397 ^ y;
    hash = hash * 397 ^ z;
    return hash;
  };
  Vector32.prototype.asArray = function() {
    var result = [];
    this.toArray(result, 0);
    return result;
  };
  Vector32.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this._x;
    array[index + 1] = this._y;
    array[index + 2] = this._z;
    return this;
  };
  Vector32.prototype.fromArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    Vector32.FromArrayToRef(array, index, this);
    return this;
  };
  Vector32.prototype.toQuaternion = function() {
    return Quaternion.RotationYawPitchRoll(this._y, this._x, this._z);
  };
  Vector32.prototype.addInPlace = function(otherVector) {
    return this.addInPlaceFromFloats(otherVector._x, otherVector._y, otherVector._z);
  };
  Vector32.prototype.addInPlaceFromFloats = function(x, y, z) {
    this.x += x;
    this.y += y;
    this.z += z;
    return this;
  };
  Vector32.prototype.add = function(otherVector) {
    return new Vector32(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
  };
  Vector32.prototype.addToRef = function(otherVector, result) {
    return result.copyFromFloats(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
  };
  Vector32.prototype.subtractInPlace = function(otherVector) {
    this.x -= otherVector._x;
    this.y -= otherVector._y;
    this.z -= otherVector._z;
    return this;
  };
  Vector32.prototype.subtract = function(otherVector) {
    return new Vector32(this._x - otherVector._x, this._y - otherVector._y, this._z - otherVector._z);
  };
  Vector32.prototype.subtractToRef = function(otherVector, result) {
    return this.subtractFromFloatsToRef(otherVector._x, otherVector._y, otherVector._z, result);
  };
  Vector32.prototype.subtractFromFloats = function(x, y, z) {
    return new Vector32(this._x - x, this._y - y, this._z - z);
  };
  Vector32.prototype.subtractFromFloatsToRef = function(x, y, z, result) {
    return result.copyFromFloats(this._x - x, this._y - y, this._z - z);
  };
  Vector32.prototype.negate = function() {
    return new Vector32(-this._x, -this._y, -this._z);
  };
  Vector32.prototype.negateInPlace = function() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  };
  Vector32.prototype.negateToRef = function(result) {
    return result.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);
  };
  Vector32.prototype.scaleInPlace = function(scale) {
    this.x *= scale;
    this.y *= scale;
    this.z *= scale;
    return this;
  };
  Vector32.prototype.scale = function(scale) {
    return new Vector32(this._x * scale, this._y * scale, this._z * scale);
  };
  Vector32.prototype.scaleToRef = function(scale, result) {
    return result.copyFromFloats(this._x * scale, this._y * scale, this._z * scale);
  };
  Vector32.prototype.scaleAndAddToRef = function(scale, result) {
    return result.addInPlaceFromFloats(this._x * scale, this._y * scale, this._z * scale);
  };
  Vector32.prototype.projectOnPlane = function(plane, origin) {
    var result = Vector32.Zero();
    this.projectOnPlaneToRef(plane, origin, result);
    return result;
  };
  Vector32.prototype.projectOnPlaneToRef = function(plane, origin, result) {
    var n = plane.normal;
    var d = plane.d;
    var V = MathTmp.Vector3[0];
    this.subtractToRef(origin, V);
    V.normalize();
    var denom = Vector32.Dot(V, n);
    var t = -(Vector32.Dot(origin, n) + d) / denom;
    var scaledV = V.scaleInPlace(t);
    origin.addToRef(scaledV, result);
  };
  Vector32.prototype.equals = function(otherVector) {
    return otherVector && this._x === otherVector._x && this._y === otherVector._y && this._z === otherVector._z;
  };
  Vector32.prototype.equalsWithEpsilon = function(otherVector, epsilon) {
    if (epsilon === void 0) {
      epsilon = Epsilon;
    }
    return otherVector && Scalar.WithinEpsilon(this._x, otherVector._x, epsilon) && Scalar.WithinEpsilon(this._y, otherVector._y, epsilon) && Scalar.WithinEpsilon(this._z, otherVector._z, epsilon);
  };
  Vector32.prototype.equalsToFloats = function(x, y, z) {
    return this._x === x && this._y === y && this._z === z;
  };
  Vector32.prototype.multiplyInPlace = function(otherVector) {
    this.x *= otherVector._x;
    this.y *= otherVector._y;
    this.z *= otherVector._z;
    return this;
  };
  Vector32.prototype.multiply = function(otherVector) {
    return this.multiplyByFloats(otherVector._x, otherVector._y, otherVector._z);
  };
  Vector32.prototype.multiplyToRef = function(otherVector, result) {
    return result.copyFromFloats(this._x * otherVector._x, this._y * otherVector._y, this._z * otherVector._z);
  };
  Vector32.prototype.multiplyByFloats = function(x, y, z) {
    return new Vector32(this._x * x, this._y * y, this._z * z);
  };
  Vector32.prototype.divide = function(otherVector) {
    return new Vector32(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
  };
  Vector32.prototype.divideToRef = function(otherVector, result) {
    return result.copyFromFloats(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
  };
  Vector32.prototype.divideInPlace = function(otherVector) {
    return this.divideToRef(otherVector, this);
  };
  Vector32.prototype.minimizeInPlace = function(other) {
    return this.minimizeInPlaceFromFloats(other._x, other._y, other._z);
  };
  Vector32.prototype.maximizeInPlace = function(other) {
    return this.maximizeInPlaceFromFloats(other._x, other._y, other._z);
  };
  Vector32.prototype.minimizeInPlaceFromFloats = function(x, y, z) {
    if (x < this._x) {
      this.x = x;
    }
    if (y < this._y) {
      this.y = y;
    }
    if (z < this._z) {
      this.z = z;
    }
    return this;
  };
  Vector32.prototype.maximizeInPlaceFromFloats = function(x, y, z) {
    if (x > this._x) {
      this.x = x;
    }
    if (y > this._y) {
      this.y = y;
    }
    if (z > this._z) {
      this.z = z;
    }
    return this;
  };
  Vector32.prototype.isNonUniformWithinEpsilon = function(epsilon) {
    var absX = Math.abs(this._x);
    var absY = Math.abs(this._y);
    if (!Scalar.WithinEpsilon(absX, absY, epsilon)) {
      return true;
    }
    var absZ = Math.abs(this._z);
    if (!Scalar.WithinEpsilon(absX, absZ, epsilon)) {
      return true;
    }
    if (!Scalar.WithinEpsilon(absY, absZ, epsilon)) {
      return true;
    }
    return false;
  };
  Object.defineProperty(Vector32.prototype, "isNonUniform", {
    get: function() {
      var absX = Math.abs(this._x);
      var absY = Math.abs(this._y);
      if (absX !== absY) {
        return true;
      }
      var absZ = Math.abs(this._z);
      if (absX !== absZ) {
        return true;
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Vector32.prototype.floor = function() {
    return new Vector32(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));
  };
  Vector32.prototype.fract = function() {
    return new Vector32(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));
  };
  Vector32.prototype.length = function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
  };
  Vector32.prototype.lengthSquared = function() {
    return this._x * this._x + this._y * this._y + this._z * this._z;
  };
  Vector32.prototype.normalize = function() {
    return this.normalizeFromLength(this.length());
  };
  Vector32.prototype.reorderInPlace = function(order) {
    var _this = this;
    order = order.toLowerCase();
    if (order === "xyz") {
      return this;
    }
    MathTmp.Vector3[0].copyFrom(this);
    ["x", "y", "z"].forEach(function(val, i) {
      _this[val] = MathTmp.Vector3[0][order[i]];
    });
    return this;
  };
  Vector32.prototype.rotateByQuaternionToRef = function(quaternion, result) {
    quaternion.toRotationMatrix(MathTmp.Matrix[0]);
    Vector32.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);
    return result;
  };
  Vector32.prototype.rotateByQuaternionAroundPointToRef = function(quaternion, point, result) {
    this.subtractToRef(point, MathTmp.Vector3[0]);
    MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);
    point.addToRef(MathTmp.Vector3[0], result);
    return result;
  };
  Vector32.prototype.cross = function(other) {
    return Vector32.Cross(this, other);
  };
  Vector32.prototype.normalizeFromLength = function(len) {
    if (len === 0 || len === 1) {
      return this;
    }
    return this.scaleInPlace(1 / len);
  };
  Vector32.prototype.normalizeToNew = function() {
    var normalized = new Vector32(0, 0, 0);
    this.normalizeToRef(normalized);
    return normalized;
  };
  Vector32.prototype.normalizeToRef = function(reference) {
    var len = this.length();
    if (len === 0 || len === 1) {
      return reference.copyFromFloats(this._x, this._y, this._z);
    }
    return this.scaleToRef(1 / len, reference);
  };
  Vector32.prototype.clone = function() {
    return new Vector32(this._x, this._y, this._z);
  };
  Vector32.prototype.copyFrom = function(source) {
    return this.copyFromFloats(source._x, source._y, source._z);
  };
  Vector32.prototype.copyFromFloats = function(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  };
  Vector32.prototype.set = function(x, y, z) {
    return this.copyFromFloats(x, y, z);
  };
  Vector32.prototype.setAll = function(v) {
    this.x = this.y = this.z = v;
    return this;
  };
  Vector32.GetClipFactor = function(vector0, vector1, axis, size) {
    var d0 = Vector32.Dot(vector0, axis) - size;
    var d1 = Vector32.Dot(vector1, axis) - size;
    var s = d0 / (d0 - d1);
    return s;
  };
  Vector32.GetAngleBetweenVectors = function(vector0, vector1, normal) {
    var v0 = vector0.normalizeToRef(MathTmp.Vector3[1]);
    var v1 = vector1.normalizeToRef(MathTmp.Vector3[2]);
    var dot = Vector32.Dot(v0, v1);
    var angle = Math.acos(dot);
    var n = MathTmp.Vector3[3];
    Vector32.CrossToRef(v0, v1, n);
    if (Vector32.Dot(n, normal) > 0) {
      return isNaN(angle) ? 0 : angle;
    }
    return isNaN(angle) ? -Math.PI : -Math.acos(dot);
  };
  Vector32.GetAngleBetweenVectorsOnPlane = function(vector0, vector1, normal) {
    MathTmp.Vector3[0].copyFrom(vector0);
    var v0 = MathTmp.Vector3[0];
    MathTmp.Vector3[1].copyFrom(vector1);
    var v1 = MathTmp.Vector3[1];
    MathTmp.Vector3[2].copyFrom(normal);
    var vNormal = MathTmp.Vector3[2];
    var right = MathTmp.Vector3[3];
    var forward = MathTmp.Vector3[4];
    v0.normalize();
    v1.normalize();
    vNormal.normalize();
    Vector32.CrossToRef(vNormal, v0, right);
    Vector32.CrossToRef(right, vNormal, forward);
    var angle = Math.atan2(Vector32.Dot(v1, right), Vector32.Dot(v1, forward));
    return Scalar.NormalizeRadians(angle);
  };
  Vector32.SlerpToRef = function(vector0, vector1, slerp, result) {
    slerp = Scalar.Clamp(slerp, 0, 1);
    var vector0Dir = MathTmp.Vector3[0];
    var vector1Dir = MathTmp.Vector3[1];
    var vector0Length;
    var vector1Length;
    vector0Dir.copyFrom(vector0);
    vector0Length = vector0Dir.length();
    vector0Dir.normalizeFromLength(vector0Length);
    vector1Dir.copyFrom(vector1);
    vector1Length = vector1Dir.length();
    vector1Dir.normalizeFromLength(vector1Length);
    var dot = Vector32.Dot(vector0Dir, vector1Dir);
    var scale0;
    var scale1;
    if (dot < 1 - Epsilon) {
      var omega = Math.acos(dot);
      var invSin = 1 / Math.sin(omega);
      scale0 = Math.sin((1 - slerp) * omega) * invSin;
      scale1 = Math.sin(slerp * omega) * invSin;
    } else {
      scale0 = 1 - slerp;
      scale1 = slerp;
    }
    vector0Dir.scaleInPlace(scale0);
    vector1Dir.scaleInPlace(scale1);
    result.copyFrom(vector0Dir).addInPlace(vector1Dir);
    result.scaleInPlace(Scalar.Lerp(vector0Length, vector1Length, slerp));
  };
  Vector32.SmoothToRef = function(source, goal, deltaTime, lerpTime, result) {
    Vector32.SlerpToRef(source, goal, lerpTime === 0 ? 1 : deltaTime / lerpTime, result);
  };
  Vector32.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    return new Vector32(array[offset], array[offset + 1], array[offset + 2]);
  };
  Vector32.FromFloatArray = function(array, offset) {
    return Vector32.FromArray(array, offset);
  };
  Vector32.FromArrayToRef = function(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    result.z = array[offset + 2];
  };
  Vector32.FromFloatArrayToRef = function(array, offset, result) {
    return Vector32.FromArrayToRef(array, offset, result);
  };
  Vector32.FromFloatsToRef = function(x, y, z, result) {
    result.copyFromFloats(x, y, z);
  };
  Vector32.Zero = function() {
    return new Vector32(0, 0, 0);
  };
  Vector32.One = function() {
    return new Vector32(1, 1, 1);
  };
  Vector32.Up = function() {
    return new Vector32(0, 1, 0);
  };
  Object.defineProperty(Vector32, "UpReadOnly", {
    get: function() {
      return Vector32._UpReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32, "RightReadOnly", {
    get: function() {
      return Vector32._RightReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32, "LeftReadOnly", {
    get: function() {
      return Vector32._LeftReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32, "LeftHandedForwardReadOnly", {
    get: function() {
      return Vector32._LeftHandedForwardReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32, "RightHandedForwardReadOnly", {
    get: function() {
      return Vector32._RightHandedForwardReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32, "ZeroReadOnly", {
    get: function() {
      return Vector32._ZeroReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Vector32.Down = function() {
    return new Vector32(0, -1, 0);
  };
  Vector32.Forward = function(rightHandedSystem) {
    if (rightHandedSystem === void 0) {
      rightHandedSystem = false;
    }
    return new Vector32(0, 0, rightHandedSystem ? -1 : 1);
  };
  Vector32.Backward = function(rightHandedSystem) {
    if (rightHandedSystem === void 0) {
      rightHandedSystem = false;
    }
    return new Vector32(0, 0, rightHandedSystem ? 1 : -1);
  };
  Vector32.Right = function() {
    return new Vector32(1, 0, 0);
  };
  Vector32.Left = function() {
    return new Vector32(-1, 0, 0);
  };
  Vector32.TransformCoordinates = function(vector, transformation) {
    var result = Vector32.Zero();
    Vector32.TransformCoordinatesToRef(vector, transformation, result);
    return result;
  };
  Vector32.TransformCoordinatesToRef = function(vector, transformation, result) {
    Vector32.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
  };
  Vector32.TransformCoordinatesFromFloatsToRef = function(x, y, z, transformation, result) {
    var m = transformation.m;
    var rx = x * m[0] + y * m[4] + z * m[8] + m[12];
    var ry = x * m[1] + y * m[5] + z * m[9] + m[13];
    var rz = x * m[2] + y * m[6] + z * m[10] + m[14];
    var rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);
    result.x = rx * rw;
    result.y = ry * rw;
    result.z = rz * rw;
  };
  Vector32.TransformNormal = function(vector, transformation) {
    var result = Vector32.Zero();
    Vector32.TransformNormalToRef(vector, transformation, result);
    return result;
  };
  Vector32.TransformNormalToRef = function(vector, transformation, result) {
    this.TransformNormalFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
  };
  Vector32.TransformNormalFromFloatsToRef = function(x, y, z, transformation, result) {
    var m = transformation.m;
    result.x = x * m[0] + y * m[4] + z * m[8];
    result.y = x * m[1] + y * m[5] + z * m[9];
    result.z = x * m[2] + y * m[6] + z * m[10];
  };
  Vector32.CatmullRom = function(value1, value2, value3, value4, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var x = 0.5 * (2 * value2._x + (-value1._x + value3._x) * amount + (2 * value1._x - 5 * value2._x + 4 * value3._x - value4._x) * squared + (-value1._x + 3 * value2._x - 3 * value3._x + value4._x) * cubed);
    var y = 0.5 * (2 * value2._y + (-value1._y + value3._y) * amount + (2 * value1._y - 5 * value2._y + 4 * value3._y - value4._y) * squared + (-value1._y + 3 * value2._y - 3 * value3._y + value4._y) * cubed);
    var z = 0.5 * (2 * value2._z + (-value1._z + value3._z) * amount + (2 * value1._z - 5 * value2._z + 4 * value3._z - value4._z) * squared + (-value1._z + 3 * value2._z - 3 * value3._z + value4._z) * cubed);
    return new Vector32(x, y, z);
  };
  Vector32.Clamp = function(value, min, max) {
    var v = new Vector32();
    Vector32.ClampToRef(value, min, max, v);
    return v;
  };
  Vector32.ClampToRef = function(value, min, max, result) {
    var x = value._x;
    x = x > max._x ? max._x : x;
    x = x < min._x ? min._x : x;
    var y = value._y;
    y = y > max._y ? max._y : y;
    y = y < min._y ? min._y : y;
    var z = value._z;
    z = z > max._z ? max._z : z;
    z = z < min._z ? min._z : z;
    result.copyFromFloats(x, y, z);
  };
  Vector32.CheckExtends = function(v, min, max) {
    min.minimizeInPlace(v);
    max.maximizeInPlace(v);
  };
  Vector32.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
    var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
    var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
    return new Vector32(x, y, z);
  };
  Vector32.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
    var result = Vector32.Zero();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  };
  Vector32.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
    var t2 = time * time;
    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
    result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;
  };
  Vector32.Lerp = function(start, end, amount) {
    var result = new Vector32(0, 0, 0);
    Vector32.LerpToRef(start, end, amount, result);
    return result;
  };
  Vector32.LerpToRef = function(start, end, amount, result) {
    result.x = start._x + (end._x - start._x) * amount;
    result.y = start._y + (end._y - start._y) * amount;
    result.z = start._z + (end._z - start._z) * amount;
  };
  Vector32.Dot = function(left, right) {
    return left._x * right._x + left._y * right._y + left._z * right._z;
  };
  Vector32.Cross = function(left, right) {
    var result = Vector32.Zero();
    Vector32.CrossToRef(left, right, result);
    return result;
  };
  Vector32.CrossToRef = function(left, right, result) {
    var x = left._y * right._z - left._z * right._y;
    var y = left._z * right._x - left._x * right._z;
    var z = left._x * right._y - left._y * right._x;
    result.copyFromFloats(x, y, z);
  };
  Vector32.Normalize = function(vector) {
    var result = Vector32.Zero();
    Vector32.NormalizeToRef(vector, result);
    return result;
  };
  Vector32.NormalizeToRef = function(vector, result) {
    vector.normalizeToRef(result);
  };
  Vector32.Project = function(vector, world, transform, viewport) {
    var result = new Vector32();
    Vector32.ProjectToRef(vector, world, transform, viewport, result);
    return result;
  };
  Vector32.ProjectToRef = function(vector, world, transform, viewport, result) {
    var cw = viewport.width;
    var ch = viewport.height;
    var cx = viewport.x;
    var cy = viewport.y;
    var viewportMatrix = MathTmp.Matrix[1];
    Matrix.FromValuesToRef(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, 0.5, 0, cx + cw / 2, ch / 2 + cy, 0.5, 1, viewportMatrix);
    var matrix = MathTmp.Matrix[0];
    world.multiplyToRef(transform, matrix);
    matrix.multiplyToRef(viewportMatrix, matrix);
    Vector32.TransformCoordinatesToRef(vector, matrix, result);
    return result;
  };
  Vector32._UnprojectFromInvertedMatrixToRef = function(source, matrix, result) {
    Vector32.TransformCoordinatesToRef(source, matrix, result);
    var m = matrix.m;
    var num = source._x * m[3] + source._y * m[7] + source._z * m[11] + m[15];
    if (Scalar.WithinEpsilon(num, 1)) {
      result.scaleInPlace(1 / num);
    }
  };
  Vector32.UnprojectFromTransform = function(source, viewportWidth, viewportHeight, world, transform) {
    return this.Unproject(source, viewportWidth, viewportHeight, world, transform, Matrix.IdentityReadOnly);
  };
  Vector32.Unproject = function(source, viewportWidth, viewportHeight, world, view, projection) {
    var result = Vector32.Zero();
    Vector32.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);
    return result;
  };
  Vector32.UnprojectToRef = function(source, viewportWidth, viewportHeight, world, view, projection, result) {
    Vector32.UnprojectFloatsToRef(source._x, source._y, source._z, viewportWidth, viewportHeight, world, view, projection, result);
  };
  Vector32.UnprojectFloatsToRef = function(sourceX, sourceY, sourceZ, viewportWidth, viewportHeight, world, view, projection, result) {
    var _a;
    var matrix = MathTmp.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    matrix.invert();
    var screenSource = MathTmp.Vector3[0];
    screenSource.x = sourceX / viewportWidth * 2 - 1;
    screenSource.y = -(sourceY / viewportHeight * 2 - 1);
    if ((_a = EngineStore.LastCreatedEngine) === null || _a === void 0 ? void 0 : _a.isNDCHalfZRange) {
      screenSource.z = sourceZ;
    } else {
      screenSource.z = 2 * sourceZ - 1;
    }
    Vector32._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);
  };
  Vector32.Minimize = function(left, right) {
    var min = left.clone();
    min.minimizeInPlace(right);
    return min;
  };
  Vector32.Maximize = function(left, right) {
    var max = left.clone();
    max.maximizeInPlace(right);
    return max;
  };
  Vector32.Distance = function(value1, value2) {
    return Math.sqrt(Vector32.DistanceSquared(value1, value2));
  };
  Vector32.DistanceSquared = function(value1, value2) {
    var x = value1._x - value2._x;
    var y = value1._y - value2._y;
    var z = value1._z - value2._z;
    return x * x + y * y + z * z;
  };
  Vector32.ProjectOnTriangleToRef = function(vector, p0, p1, p2, ref) {
    var p1p0 = MathTmp.Vector3[0];
    var p2p0 = MathTmp.Vector3[1];
    var p2p1 = MathTmp.Vector3[2];
    var normal = MathTmp.Vector3[3];
    var vectorp0 = MathTmp.Vector3[4];
    p1.subtractToRef(p0, p1p0);
    p2.subtractToRef(p0, p2p0);
    p2.subtractToRef(p1, p2p1);
    var p1p0L = p1p0.length();
    var p2p0L = p2p0.length();
    var p2p1L = p2p1.length();
    if (p1p0L < Epsilon || p2p0L < Epsilon || p2p1L < Epsilon) {
      ref.copyFrom(p0);
      return Vector32.Distance(vector, p0);
    }
    vector.subtractToRef(p0, vectorp0);
    Vector32.CrossToRef(p1p0, p2p0, normal);
    var nl = normal.length();
    if (nl < Epsilon) {
      ref.copyFrom(p0);
      return Vector32.Distance(vector, p0);
    }
    normal.normalizeFromLength(nl);
    var l = vectorp0.length();
    if (l < Epsilon) {
      ref.copyFrom(p0);
      return 0;
    }
    vectorp0.normalizeFromLength(l);
    var cosA = Vector32.Dot(normal, vectorp0);
    var projVector = MathTmp.Vector3[5];
    var proj = MathTmp.Vector3[6];
    projVector.copyFrom(normal).scaleInPlace(-l * cosA);
    proj.copyFrom(vector).addInPlace(projVector);
    var v0 = MathTmp.Vector3[4];
    var v1 = MathTmp.Vector3[5];
    var v2 = MathTmp.Vector3[7];
    var tmp = MathTmp.Vector3[8];
    v0.copyFrom(p1p0).scaleInPlace(1 / p1p0L);
    tmp.copyFrom(p2p0).scaleInPlace(1 / p2p0L);
    v0.addInPlace(tmp).scaleInPlace(-1);
    v1.copyFrom(p1p0).scaleInPlace(-1 / p1p0L);
    tmp.copyFrom(p2p1).scaleInPlace(1 / p2p1L);
    v1.addInPlace(tmp).scaleInPlace(-1);
    v2.copyFrom(p2p1).scaleInPlace(-1 / p2p1L);
    tmp.copyFrom(p2p0).scaleInPlace(-1 / p2p0L);
    v2.addInPlace(tmp).scaleInPlace(-1);
    var projP = MathTmp.Vector3[9];
    var dot;
    var s0, s1, s2;
    projP.copyFrom(proj).subtractInPlace(p0);
    Vector32.CrossToRef(v0, projP, tmp);
    dot = Vector32.Dot(tmp, normal);
    s0 = dot;
    projP.copyFrom(proj).subtractInPlace(p1);
    Vector32.CrossToRef(v1, projP, tmp);
    dot = Vector32.Dot(tmp, normal);
    s1 = dot;
    projP.copyFrom(proj).subtractInPlace(p2);
    Vector32.CrossToRef(v2, projP, tmp);
    dot = Vector32.Dot(tmp, normal);
    s2 = dot;
    var edge = MathTmp.Vector3[10];
    var e0, e1;
    if (s0 > 0 && s1 < 0) {
      edge.copyFrom(p1p0);
      e0 = p0;
      e1 = p1;
    } else if (s1 > 0 && s2 < 0) {
      edge.copyFrom(p2p1);
      e0 = p1;
      e1 = p2;
    } else {
      edge.copyFrom(p2p0).scaleInPlace(-1);
      e0 = p2;
      e1 = p0;
    }
    var tmp2 = MathTmp.Vector3[9];
    var tmp3 = MathTmp.Vector3[4];
    e0.subtractToRef(proj, tmp);
    e1.subtractToRef(proj, tmp2);
    Vector32.CrossToRef(tmp, tmp2, tmp3);
    var isOutside = Vector32.Dot(tmp3, normal) < 0;
    if (!isOutside) {
      ref.copyFrom(proj);
      return Math.abs(l * cosA);
    }
    var r = MathTmp.Vector3[5];
    Vector32.CrossToRef(edge, tmp3, r);
    r.normalize();
    var e0proj = MathTmp.Vector3[9];
    e0proj.copyFrom(e0).subtractInPlace(proj);
    var e0projL = e0proj.length();
    if (e0projL < Epsilon) {
      ref.copyFrom(e0);
      return Vector32.Distance(vector, e0);
    }
    e0proj.normalizeFromLength(e0projL);
    var cosG = Vector32.Dot(r, e0proj);
    var triProj = MathTmp.Vector3[7];
    triProj.copyFrom(proj).addInPlace(r.scaleInPlace(e0projL * cosG));
    tmp.copyFrom(triProj).subtractInPlace(e0);
    l = edge.length();
    edge.normalizeFromLength(l);
    var t = Vector32.Dot(tmp, edge) / Math.max(l, Epsilon);
    t = Scalar.Clamp(t, 0, 1);
    triProj.copyFrom(e0).addInPlace(edge.scaleInPlace(t * l));
    ref.copyFrom(triProj);
    return Vector32.Distance(vector, triProj);
  };
  Vector32.Center = function(value1, value2) {
    return Vector32.CenterToRef(value1, value2, Vector32.Zero());
  };
  Vector32.CenterToRef = function(value1, value2, ref) {
    return ref.copyFromFloats((value1._x + value2._x) / 2, (value1._y + value2._y) / 2, (value1._z + value2._z) / 2);
  };
  Vector32.RotationFromAxis = function(axis1, axis2, axis3) {
    var rotation = Vector32.Zero();
    Vector32.RotationFromAxisToRef(axis1, axis2, axis3, rotation);
    return rotation;
  };
  Vector32.RotationFromAxisToRef = function(axis1, axis2, axis3, ref) {
    var quat = MathTmp.Quaternion[0];
    Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
    quat.toEulerAnglesToRef(ref);
  };
  Vector32._UpReadOnly = Vector32.Up();
  Vector32._LeftHandedForwardReadOnly = Vector32.Forward(false);
  Vector32._RightHandedForwardReadOnly = Vector32.Forward(true);
  Vector32._RightReadOnly = Vector32.Right();
  Vector32._LeftReadOnly = Vector32.Left();
  Vector32._ZeroReadOnly = Vector32.Zero();
  return Vector32;
}();
var Vector4 = function() {
  function Vector42(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  Vector42.prototype.toString = function() {
    return "{X: ".concat(this.x, " Y: ").concat(this.y, " Z: ").concat(this.z, " W: ").concat(this.w, "}");
  };
  Vector42.prototype.getClassName = function() {
    return "Vector4";
  };
  Vector42.prototype.getHashCode = function() {
    var x = _ExtractAsInt(this.x);
    var y = _ExtractAsInt(this.y);
    var z = _ExtractAsInt(this.z);
    var w = _ExtractAsInt(this.w);
    var hash = x;
    hash = hash * 397 ^ y;
    hash = hash * 397 ^ z;
    hash = hash * 397 ^ w;
    return hash;
  };
  Vector42.prototype.asArray = function() {
    var result = new Array();
    this.toArray(result, 0);
    return result;
  };
  Vector42.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.x;
    array[index + 1] = this.y;
    array[index + 2] = this.z;
    array[index + 3] = this.w;
    return this;
  };
  Vector42.prototype.fromArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    Vector42.FromArrayToRef(array, index, this);
    return this;
  };
  Vector42.prototype.addInPlace = function(otherVector) {
    this.x += otherVector.x;
    this.y += otherVector.y;
    this.z += otherVector.z;
    this.w += otherVector.w;
    return this;
  };
  Vector42.prototype.add = function(otherVector) {
    return new Vector42(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);
  };
  Vector42.prototype.addToRef = function(otherVector, result) {
    result.x = this.x + otherVector.x;
    result.y = this.y + otherVector.y;
    result.z = this.z + otherVector.z;
    result.w = this.w + otherVector.w;
    return this;
  };
  Vector42.prototype.subtractInPlace = function(otherVector) {
    this.x -= otherVector.x;
    this.y -= otherVector.y;
    this.z -= otherVector.z;
    this.w -= otherVector.w;
    return this;
  };
  Vector42.prototype.subtract = function(otherVector) {
    return new Vector42(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);
  };
  Vector42.prototype.subtractToRef = function(otherVector, result) {
    result.x = this.x - otherVector.x;
    result.y = this.y - otherVector.y;
    result.z = this.z - otherVector.z;
    result.w = this.w - otherVector.w;
    return this;
  };
  Vector42.prototype.subtractFromFloats = function(x, y, z, w) {
    return new Vector42(this.x - x, this.y - y, this.z - z, this.w - w);
  };
  Vector42.prototype.subtractFromFloatsToRef = function(x, y, z, w, result) {
    result.x = this.x - x;
    result.y = this.y - y;
    result.z = this.z - z;
    result.w = this.w - w;
    return this;
  };
  Vector42.prototype.negate = function() {
    return new Vector42(-this.x, -this.y, -this.z, -this.w);
  };
  Vector42.prototype.negateInPlace = function() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    this.w *= -1;
    return this;
  };
  Vector42.prototype.negateToRef = function(result) {
    return result.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);
  };
  Vector42.prototype.scaleInPlace = function(scale) {
    this.x *= scale;
    this.y *= scale;
    this.z *= scale;
    this.w *= scale;
    return this;
  };
  Vector42.prototype.scale = function(scale) {
    return new Vector42(this.x * scale, this.y * scale, this.z * scale, this.w * scale);
  };
  Vector42.prototype.scaleToRef = function(scale, result) {
    result.x = this.x * scale;
    result.y = this.y * scale;
    result.z = this.z * scale;
    result.w = this.w * scale;
    return this;
  };
  Vector42.prototype.scaleAndAddToRef = function(scale, result) {
    result.x += this.x * scale;
    result.y += this.y * scale;
    result.z += this.z * scale;
    result.w += this.w * scale;
    return this;
  };
  Vector42.prototype.equals = function(otherVector) {
    return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;
  };
  Vector42.prototype.equalsWithEpsilon = function(otherVector, epsilon) {
    if (epsilon === void 0) {
      epsilon = Epsilon;
    }
    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) && Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) && Scalar.WithinEpsilon(this.w, otherVector.w, epsilon);
  };
  Vector42.prototype.equalsToFloats = function(x, y, z, w) {
    return this.x === x && this.y === y && this.z === z && this.w === w;
  };
  Vector42.prototype.multiplyInPlace = function(otherVector) {
    this.x *= otherVector.x;
    this.y *= otherVector.y;
    this.z *= otherVector.z;
    this.w *= otherVector.w;
    return this;
  };
  Vector42.prototype.multiply = function(otherVector) {
    return new Vector42(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);
  };
  Vector42.prototype.multiplyToRef = function(otherVector, result) {
    result.x = this.x * otherVector.x;
    result.y = this.y * otherVector.y;
    result.z = this.z * otherVector.z;
    result.w = this.w * otherVector.w;
    return this;
  };
  Vector42.prototype.multiplyByFloats = function(x, y, z, w) {
    return new Vector42(this.x * x, this.y * y, this.z * z, this.w * w);
  };
  Vector42.prototype.divide = function(otherVector) {
    return new Vector42(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);
  };
  Vector42.prototype.divideToRef = function(otherVector, result) {
    result.x = this.x / otherVector.x;
    result.y = this.y / otherVector.y;
    result.z = this.z / otherVector.z;
    result.w = this.w / otherVector.w;
    return this;
  };
  Vector42.prototype.divideInPlace = function(otherVector) {
    return this.divideToRef(otherVector, this);
  };
  Vector42.prototype.minimizeInPlace = function(other) {
    if (other.x < this.x) {
      this.x = other.x;
    }
    if (other.y < this.y) {
      this.y = other.y;
    }
    if (other.z < this.z) {
      this.z = other.z;
    }
    if (other.w < this.w) {
      this.w = other.w;
    }
    return this;
  };
  Vector42.prototype.maximizeInPlace = function(other) {
    if (other.x > this.x) {
      this.x = other.x;
    }
    if (other.y > this.y) {
      this.y = other.y;
    }
    if (other.z > this.z) {
      this.z = other.z;
    }
    if (other.w > this.w) {
      this.w = other.w;
    }
    return this;
  };
  Vector42.prototype.floor = function() {
    return new Vector42(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));
  };
  Vector42.prototype.fract = function() {
    return new Vector42(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));
  };
  Vector42.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  };
  Vector42.prototype.lengthSquared = function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  };
  Vector42.prototype.normalize = function() {
    var len = this.length();
    if (len === 0) {
      return this;
    }
    return this.scaleInPlace(1 / len);
  };
  Vector42.prototype.toVector3 = function() {
    return new Vector3(this.x, this.y, this.z);
  };
  Vector42.prototype.clone = function() {
    return new Vector42(this.x, this.y, this.z, this.w);
  };
  Vector42.prototype.copyFrom = function(source) {
    this.x = source.x;
    this.y = source.y;
    this.z = source.z;
    this.w = source.w;
    return this;
  };
  Vector42.prototype.copyFromFloats = function(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  };
  Vector42.prototype.set = function(x, y, z, w) {
    return this.copyFromFloats(x, y, z, w);
  };
  Vector42.prototype.setAll = function(v) {
    this.x = this.y = this.z = this.w = v;
    return this;
  };
  Vector42.FromArray = function(array, offset) {
    if (!offset) {
      offset = 0;
    }
    return new Vector42(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  };
  Vector42.FromArrayToRef = function(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    result.z = array[offset + 2];
    result.w = array[offset + 3];
  };
  Vector42.FromFloatArrayToRef = function(array, offset, result) {
    Vector42.FromArrayToRef(array, offset, result);
  };
  Vector42.FromFloatsToRef = function(x, y, z, w, result) {
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
  };
  Vector42.Zero = function() {
    return new Vector42(0, 0, 0, 0);
  };
  Vector42.One = function() {
    return new Vector42(1, 1, 1, 1);
  };
  Vector42.Normalize = function(vector) {
    var result = Vector42.Zero();
    Vector42.NormalizeToRef(vector, result);
    return result;
  };
  Vector42.NormalizeToRef = function(vector, result) {
    result.copyFrom(vector);
    result.normalize();
  };
  Vector42.Minimize = function(left, right) {
    var min = left.clone();
    min.minimizeInPlace(right);
    return min;
  };
  Vector42.Maximize = function(left, right) {
    var max = left.clone();
    max.maximizeInPlace(right);
    return max;
  };
  Vector42.Distance = function(value1, value2) {
    return Math.sqrt(Vector42.DistanceSquared(value1, value2));
  };
  Vector42.DistanceSquared = function(value1, value2) {
    var x = value1.x - value2.x;
    var y = value1.y - value2.y;
    var z = value1.z - value2.z;
    var w = value1.w - value2.w;
    return x * x + y * y + z * z + w * w;
  };
  Vector42.Center = function(value1, value2) {
    return Vector42.CenterToRef(value1, value2, Vector42.Zero());
  };
  Vector42.CenterToRef = function(value1, value2, ref) {
    return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2, (value1.z + value2.z) / 2, (value1.w + value2.w) / 2);
  };
  Vector42.TransformCoordinates = function(vector, transformation) {
    var result = Vector42.Zero();
    Vector42.TransformCoordinatesToRef(vector, transformation, result);
    return result;
  };
  Vector42.TransformCoordinatesToRef = function(vector, transformation, result) {
    Vector42.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
  };
  Vector42.TransformCoordinatesFromFloatsToRef = function(x, y, z, transformation, result) {
    var m = transformation.m;
    var rx = x * m[0] + y * m[4] + z * m[8] + m[12];
    var ry = x * m[1] + y * m[5] + z * m[9] + m[13];
    var rz = x * m[2] + y * m[6] + z * m[10] + m[14];
    var rw = x * m[3] + y * m[7] + z * m[11] + m[15];
    result.x = rx;
    result.y = ry;
    result.z = rz;
    result.w = rw;
  };
  Vector42.TransformNormal = function(vector, transformation) {
    var result = Vector42.Zero();
    Vector42.TransformNormalToRef(vector, transformation, result);
    return result;
  };
  Vector42.TransformNormalToRef = function(vector, transformation, result) {
    var m = transformation.m;
    var x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];
    var y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];
    var z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = vector.w;
  };
  Vector42.TransformNormalFromFloatsToRef = function(x, y, z, w, transformation, result) {
    var m = transformation.m;
    result.x = x * m[0] + y * m[4] + z * m[8];
    result.y = x * m[1] + y * m[5] + z * m[9];
    result.z = x * m[2] + y * m[6] + z * m[10];
    result.w = w;
  };
  Vector42.FromVector3 = function(source, w) {
    if (w === void 0) {
      w = 0;
    }
    return new Vector42(source._x, source._y, source._z, w);
  };
  return Vector42;
}();
var Quaternion = function() {
  function Quaternion2(x, y, z, w) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (w === void 0) {
      w = 1;
    }
    this._isDirty = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  Object.defineProperty(Quaternion2.prototype, "x", {
    get: function() {
      return this._x;
    },
    set: function(value) {
      this._x = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Quaternion2.prototype, "y", {
    get: function() {
      return this._y;
    },
    set: function(value) {
      this._y = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Quaternion2.prototype, "z", {
    get: function() {
      return this._z;
    },
    set: function(value) {
      this._z = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Quaternion2.prototype, "w", {
    get: function() {
      return this._w;
    },
    set: function(value) {
      this._w = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Quaternion2.prototype.toString = function() {
    return "{X: ".concat(this._x, " Y: ").concat(this._y, " Z: ").concat(this._z, " W: ").concat(this._w, "}");
  };
  Quaternion2.prototype.getClassName = function() {
    return "Quaternion";
  };
  Quaternion2.prototype.getHashCode = function() {
    var x = _ExtractAsInt(this._x);
    var y = _ExtractAsInt(this._y);
    var z = _ExtractAsInt(this._z);
    var w = _ExtractAsInt(this._w);
    var hash = x;
    hash = hash * 397 ^ y;
    hash = hash * 397 ^ z;
    hash = hash * 397 ^ w;
    return hash;
  };
  Quaternion2.prototype.asArray = function() {
    return [this._x, this._y, this._z, this._w];
  };
  Quaternion2.prototype.equals = function(otherQuaternion) {
    return otherQuaternion && this._x === otherQuaternion._x && this._y === otherQuaternion._y && this._z === otherQuaternion._z && this._w === otherQuaternion._w;
  };
  Quaternion2.prototype.equalsWithEpsilon = function(otherQuaternion, epsilon) {
    if (epsilon === void 0) {
      epsilon = Epsilon;
    }
    return otherQuaternion && Scalar.WithinEpsilon(this._x, otherQuaternion._x, epsilon) && Scalar.WithinEpsilon(this._y, otherQuaternion._y, epsilon) && Scalar.WithinEpsilon(this._z, otherQuaternion._z, epsilon) && Scalar.WithinEpsilon(this._w, otherQuaternion._w, epsilon);
  };
  Quaternion2.prototype.clone = function() {
    return new Quaternion2(this._x, this._y, this._z, this._w);
  };
  Quaternion2.prototype.copyFrom = function(other) {
    this.x = other._x;
    this.y = other._y;
    this.z = other._z;
    this.w = other._w;
    return this;
  };
  Quaternion2.prototype.copyFromFloats = function(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  };
  Quaternion2.prototype.set = function(x, y, z, w) {
    return this.copyFromFloats(x, y, z, w);
  };
  Quaternion2.prototype.add = function(other) {
    return new Quaternion2(this._x + other._x, this._y + other._y, this._z + other._z, this._w + other._w);
  };
  Quaternion2.prototype.addInPlace = function(other) {
    this._x += other._x;
    this._y += other._y;
    this._z += other._z;
    this._w += other._w;
    return this;
  };
  Quaternion2.prototype.subtract = function(other) {
    return new Quaternion2(this._x - other._x, this._y - other._y, this._z - other._z, this._w - other._w);
  };
  Quaternion2.prototype.scale = function(value) {
    return new Quaternion2(this._x * value, this._y * value, this._z * value, this._w * value);
  };
  Quaternion2.prototype.scaleToRef = function(scale, result) {
    result.x = this._x * scale;
    result.y = this._y * scale;
    result.z = this._z * scale;
    result.w = this._w * scale;
    return this;
  };
  Quaternion2.prototype.scaleInPlace = function(value) {
    this.x *= value;
    this.y *= value;
    this.z *= value;
    this.w *= value;
    return this;
  };
  Quaternion2.prototype.scaleAndAddToRef = function(scale, result) {
    result.x += this._x * scale;
    result.y += this._y * scale;
    result.z += this._z * scale;
    result.w += this._w * scale;
    return this;
  };
  Quaternion2.prototype.multiply = function(q1) {
    var result = new Quaternion2(0, 0, 0, 1);
    this.multiplyToRef(q1, result);
    return result;
  };
  Quaternion2.prototype.multiplyToRef = function(q1, result) {
    var x = this._x * q1._w + this._y * q1._z - this._z * q1._y + this._w * q1._x;
    var y = -this._x * q1._z + this._y * q1._w + this._z * q1._x + this._w * q1._y;
    var z = this._x * q1._y - this._y * q1._x + this._z * q1._w + this._w * q1._z;
    var w = -this._x * q1._x - this._y * q1._y - this._z * q1._z + this._w * q1._w;
    result.copyFromFloats(x, y, z, w);
    return this;
  };
  Quaternion2.prototype.multiplyInPlace = function(q1) {
    this.multiplyToRef(q1, this);
    return this;
  };
  Quaternion2.prototype.conjugateToRef = function(ref) {
    ref.copyFromFloats(-this._x, -this._y, -this._z, this._w);
    return this;
  };
  Quaternion2.prototype.conjugateInPlace = function() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  };
  Quaternion2.prototype.conjugate = function() {
    var result = new Quaternion2(-this._x, -this._y, -this._z, this._w);
    return result;
  };
  Quaternion2.prototype.length = function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  };
  Quaternion2.prototype.normalize = function() {
    var len = this.length();
    if (len === 0) {
      return this;
    }
    var inv = 1 / len;
    this.x *= inv;
    this.y *= inv;
    this.z *= inv;
    this.w *= inv;
    return this;
  };
  Quaternion2.prototype.toEulerAngles = function() {
    var result = Vector3.Zero();
    this.toEulerAnglesToRef(result);
    return result;
  };
  Quaternion2.prototype.toEulerAnglesToRef = function(result) {
    var qz = this._z;
    var qx = this._x;
    var qy = this._y;
    var qw = this._w;
    var sqw = qw * qw;
    var sqz = qz * qz;
    var sqx = qx * qx;
    var sqy = qy * qy;
    var zAxisY = qy * qz - qx * qw;
    var limit = 0.4999999;
    if (zAxisY < -limit) {
      result.y = 2 * Math.atan2(qy, qw);
      result.x = Math.PI / 2;
      result.z = 0;
    } else if (zAxisY > limit) {
      result.y = 2 * Math.atan2(qy, qw);
      result.x = -Math.PI / 2;
      result.z = 0;
    } else {
      result.z = Math.atan2(2 * (qx * qy + qz * qw), -sqz - sqx + sqy + sqw);
      result.x = Math.asin(-2 * (qz * qy - qx * qw));
      result.y = Math.atan2(2 * (qz * qx + qy * qw), sqz - sqx - sqy + sqw);
    }
    return this;
  };
  Quaternion2.prototype.toRotationMatrix = function(result) {
    Matrix.FromQuaternionToRef(this, result);
    return this;
  };
  Quaternion2.prototype.fromRotationMatrix = function(matrix) {
    Quaternion2.FromRotationMatrixToRef(matrix, this);
    return this;
  };
  Quaternion2.FromRotationMatrix = function(matrix) {
    var result = new Quaternion2();
    Quaternion2.FromRotationMatrixToRef(matrix, result);
    return result;
  };
  Quaternion2.FromRotationMatrixToRef = function(matrix, result) {
    var data = matrix.m;
    var m11 = data[0], m12 = data[4], m13 = data[8];
    var m21 = data[1], m22 = data[5], m23 = data[9];
    var m31 = data[2], m32 = data[6], m33 = data[10];
    var trace = m11 + m22 + m33;
    var s;
    if (trace > 0) {
      s = 0.5 / Math.sqrt(trace + 1);
      result.w = 0.25 / s;
      result.x = (m32 - m23) * s;
      result.y = (m13 - m31) * s;
      result.z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      result.w = (m32 - m23) / s;
      result.x = 0.25 * s;
      result.y = (m12 + m21) / s;
      result.z = (m13 + m31) / s;
    } else if (m22 > m33) {
      s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      result.w = (m13 - m31) / s;
      result.x = (m12 + m21) / s;
      result.y = 0.25 * s;
      result.z = (m23 + m32) / s;
    } else {
      s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      result.w = (m21 - m12) / s;
      result.x = (m13 + m31) / s;
      result.y = (m23 + m32) / s;
      result.z = 0.25 * s;
    }
  };
  Quaternion2.Dot = function(left, right) {
    return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
  };
  Quaternion2.AreClose = function(quat0, quat1) {
    var dot = Quaternion2.Dot(quat0, quat1);
    return dot >= 0;
  };
  Quaternion2.SmoothToRef = function(source, goal, deltaTime, lerpTime, result) {
    var slerp = lerpTime === 0 ? 1 : deltaTime / lerpTime;
    slerp = Scalar.Clamp(slerp, 0, 1);
    Quaternion2.SlerpToRef(source, goal, slerp, result);
  };
  Quaternion2.Zero = function() {
    return new Quaternion2(0, 0, 0, 0);
  };
  Quaternion2.Inverse = function(q) {
    return new Quaternion2(-q._x, -q._y, -q._z, q._w);
  };
  Quaternion2.InverseToRef = function(q, result) {
    result.set(-q._x, -q._y, -q._z, q._w);
    return result;
  };
  Quaternion2.Identity = function() {
    return new Quaternion2(0, 0, 0, 1);
  };
  Quaternion2.IsIdentity = function(quaternion) {
    return quaternion && quaternion._x === 0 && quaternion._y === 0 && quaternion._z === 0 && quaternion._w === 1;
  };
  Quaternion2.RotationAxis = function(axis, angle) {
    return Quaternion2.RotationAxisToRef(axis, angle, new Quaternion2());
  };
  Quaternion2.RotationAxisToRef = function(axis, angle, result) {
    var sin = Math.sin(angle / 2);
    axis.normalize();
    result.w = Math.cos(angle / 2);
    result.x = axis._x * sin;
    result.y = axis._y * sin;
    result.z = axis._z * sin;
    return result;
  };
  Quaternion2.FromArray = function(array, offset) {
    if (!offset) {
      offset = 0;
    }
    return new Quaternion2(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  };
  Quaternion2.FromArrayToRef = function(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    result.z = array[offset + 2];
    result.w = array[offset + 3];
  };
  Quaternion2.FromEulerAngles = function(x, y, z) {
    var q = new Quaternion2();
    Quaternion2.RotationYawPitchRollToRef(y, x, z, q);
    return q;
  };
  Quaternion2.FromEulerAnglesToRef = function(x, y, z, result) {
    Quaternion2.RotationYawPitchRollToRef(y, x, z, result);
    return result;
  };
  Quaternion2.FromEulerVector = function(vec) {
    var q = new Quaternion2();
    Quaternion2.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, q);
    return q;
  };
  Quaternion2.FromEulerVectorToRef = function(vec, result) {
    Quaternion2.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, result);
    return result;
  };
  Quaternion2.FromUnitVectorsToRef = function(vecFrom, vecTo, result) {
    var r = Vector3.Dot(vecFrom, vecTo) + 1;
    if (r < Epsilon) {
      if (Math.abs(vecFrom.x) > Math.abs(vecFrom.z)) {
        result.set(-vecFrom.y, vecFrom.x, 0, 0);
      } else {
        result.set(0, -vecFrom.z, vecFrom.y, 0);
      }
    } else {
      Vector3.CrossToRef(vecFrom, vecTo, TmpVectors.Vector3[0]);
      result.set(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z, r);
    }
    return result.normalize();
  };
  Quaternion2.RotationYawPitchRoll = function(yaw, pitch, roll) {
    var q = new Quaternion2();
    Quaternion2.RotationYawPitchRollToRef(yaw, pitch, roll, q);
    return q;
  };
  Quaternion2.RotationYawPitchRollToRef = function(yaw, pitch, roll, result) {
    var halfRoll = roll * 0.5;
    var halfPitch = pitch * 0.5;
    var halfYaw = yaw * 0.5;
    var sinRoll = Math.sin(halfRoll);
    var cosRoll = Math.cos(halfRoll);
    var sinPitch = Math.sin(halfPitch);
    var cosPitch = Math.cos(halfPitch);
    var sinYaw = Math.sin(halfYaw);
    var cosYaw = Math.cos(halfYaw);
    result.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
    result.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
    result.z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
    result.w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;
  };
  Quaternion2.RotationAlphaBetaGamma = function(alpha, beta, gamma) {
    var result = new Quaternion2();
    Quaternion2.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);
    return result;
  };
  Quaternion2.RotationAlphaBetaGammaToRef = function(alpha, beta, gamma, result) {
    var halfGammaPlusAlpha = (gamma + alpha) * 0.5;
    var halfGammaMinusAlpha = (gamma - alpha) * 0.5;
    var halfBeta = beta * 0.5;
    result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);
    result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);
    result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);
    result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);
  };
  Quaternion2.RotationQuaternionFromAxis = function(axis1, axis2, axis3) {
    var quat = new Quaternion2(0, 0, 0, 0);
    Quaternion2.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
    return quat;
  };
  Quaternion2.RotationQuaternionFromAxisToRef = function(axis1, axis2, axis3, ref) {
    var rotMat = MathTmp.Matrix[0];
    Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);
    Quaternion2.FromRotationMatrixToRef(rotMat, ref);
  };
  Quaternion2.FromLookDirectionLH = function(forward, up) {
    var quat = new Quaternion2();
    Quaternion2.FromLookDirectionLHToRef(forward, up, quat);
    return quat;
  };
  Quaternion2.FromLookDirectionLHToRef = function(forward, up, ref) {
    var rotMat = MathTmp.Matrix[0];
    Matrix.LookDirectionLHToRef(forward, up, rotMat);
    Quaternion2.FromRotationMatrixToRef(rotMat, ref);
  };
  Quaternion2.FromLookDirectionRH = function(forward, up) {
    var quat = new Quaternion2();
    Quaternion2.FromLookDirectionRHToRef(forward, up, quat);
    return quat;
  };
  Quaternion2.FromLookDirectionRHToRef = function(forward, up, ref) {
    var rotMat = MathTmp.Matrix[0];
    Matrix.LookDirectionRHToRef(forward, up, rotMat);
    return Quaternion2.FromRotationMatrixToRef(rotMat, ref);
  };
  Quaternion2.Slerp = function(left, right, amount) {
    var result = Quaternion2.Identity();
    Quaternion2.SlerpToRef(left, right, amount, result);
    return result;
  };
  Quaternion2.SlerpToRef = function(left, right, amount, result) {
    var num2;
    var num3;
    var num4 = left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
    var flag = false;
    if (num4 < 0) {
      flag = true;
      num4 = -num4;
    }
    if (num4 > 0.999999) {
      num3 = 1 - amount;
      num2 = flag ? -amount : amount;
    } else {
      var num5 = Math.acos(num4);
      var num6 = 1 / Math.sin(num5);
      num3 = Math.sin((1 - amount) * num5) * num6;
      num2 = flag ? -Math.sin(amount * num5) * num6 : Math.sin(amount * num5) * num6;
    }
    result.x = num3 * left._x + num2 * right._x;
    result.y = num3 * left._y + num2 * right._y;
    result.z = num3 * left._z + num2 * right._z;
    result.w = num3 * left._w + num2 * right._w;
  };
  Quaternion2.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
    var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
    var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
    var w = value1._w * part1 + value2._w * part2 + tangent1._w * part3 + tangent2._w * part4;
    return new Quaternion2(x, y, z, w);
  };
  Quaternion2.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
    var result = Quaternion2.Zero();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  };
  Quaternion2.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
    var t2 = time * time;
    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
    result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;
    result.w = (t2 - time) * 6 * value1.w + (3 * t2 - 4 * time + 1) * tangent1.w + (-t2 + time) * 6 * value2.w + (3 * t2 - 2 * time) * tangent2.w;
  };
  return Quaternion2;
}();
var Matrix = function() {
  function Matrix2() {
    this._isIdentity = false;
    this._isIdentityDirty = true;
    this._isIdentity3x2 = true;
    this._isIdentity3x2Dirty = true;
    this.updateFlag = -1;
    if (PerformanceConfigurator.MatrixTrackPrecisionChange) {
      PerformanceConfigurator.MatrixTrackedMatrices.push(this);
    }
    this._m = new PerformanceConfigurator.MatrixCurrentType(16);
    this.markAsUpdated();
  }
  Object.defineProperty(Matrix2, "Use64Bits", {
    get: function() {
      return PerformanceConfigurator.MatrixUse64Bits;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Matrix2.prototype, "m", {
    get: function() {
      return this._m;
    },
    enumerable: false,
    configurable: true
  });
  Matrix2.prototype.markAsUpdated = function() {
    this.updateFlag = Matrix2._updateFlagSeed++;
    this._isIdentity = false;
    this._isIdentity3x2 = false;
    this._isIdentityDirty = true;
    this._isIdentity3x2Dirty = true;
  };
  Matrix2.prototype._updateIdentityStatus = function(isIdentity, isIdentityDirty, isIdentity3x2, isIdentity3x2Dirty) {
    if (isIdentityDirty === void 0) {
      isIdentityDirty = false;
    }
    if (isIdentity3x2 === void 0) {
      isIdentity3x2 = false;
    }
    if (isIdentity3x2Dirty === void 0) {
      isIdentity3x2Dirty = true;
    }
    this._isIdentity = isIdentity;
    this._isIdentity3x2 = isIdentity || isIdentity3x2;
    this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;
    this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;
  };
  Matrix2.prototype.isIdentity = function() {
    if (this._isIdentityDirty) {
      this._isIdentityDirty = false;
      var m = this._m;
      this._isIdentity = m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
    }
    return this._isIdentity;
  };
  Matrix2.prototype.isIdentityAs3x2 = function() {
    if (this._isIdentity3x2Dirty) {
      this._isIdentity3x2Dirty = false;
      if (this._m[0] !== 1 || this._m[5] !== 1 || this._m[15] !== 1) {
        this._isIdentity3x2 = false;
      } else if (this._m[1] !== 0 || this._m[2] !== 0 || this._m[3] !== 0 || this._m[4] !== 0 || this._m[6] !== 0 || this._m[7] !== 0 || this._m[8] !== 0 || this._m[9] !== 0 || this._m[10] !== 0 || this._m[11] !== 0 || this._m[12] !== 0 || this._m[13] !== 0 || this._m[14] !== 0) {
        this._isIdentity3x2 = false;
      } else {
        this._isIdentity3x2 = true;
      }
    }
    return this._isIdentity3x2;
  };
  Matrix2.prototype.determinant = function() {
    if (this._isIdentity === true) {
      return 1;
    }
    var m = this._m;
    var m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
    var m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
    var m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
    var m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
    var det_22_33 = m22 * m33 - m32 * m23;
    var det_21_33 = m21 * m33 - m31 * m23;
    var det_21_32 = m21 * m32 - m31 * m22;
    var det_20_33 = m20 * m33 - m30 * m23;
    var det_20_32 = m20 * m32 - m22 * m30;
    var det_20_31 = m20 * m31 - m30 * m21;
    var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
    var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
    var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
    var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
    return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
  };
  Matrix2.prototype.toArray = function() {
    return this._m;
  };
  Matrix2.prototype.asArray = function() {
    return this._m;
  };
  Matrix2.prototype.invert = function() {
    this.invertToRef(this);
    return this;
  };
  Matrix2.prototype.reset = function() {
    Matrix2.FromValuesToRef(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this);
    this._updateIdentityStatus(false);
    return this;
  };
  Matrix2.prototype.add = function(other) {
    var result = new Matrix2();
    this.addToRef(other, result);
    return result;
  };
  Matrix2.prototype.addToRef = function(other, result) {
    var m = this._m;
    var resultM = result._m;
    var otherM = other.m;
    for (var index = 0; index < 16; index++) {
      resultM[index] = m[index] + otherM[index];
    }
    result.markAsUpdated();
    return this;
  };
  Matrix2.prototype.addToSelf = function(other) {
    var m = this._m;
    var otherM = other.m;
    for (var index = 0; index < 16; index++) {
      m[index] += otherM[index];
    }
    this.markAsUpdated();
    return this;
  };
  Matrix2.prototype.invertToRef = function(other) {
    if (this._isIdentity === true) {
      Matrix2.IdentityToRef(other);
      return this;
    }
    var m = this._m;
    var m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
    var m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
    var m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
    var m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
    var det_22_33 = m22 * m33 - m32 * m23;
    var det_21_33 = m21 * m33 - m31 * m23;
    var det_21_32 = m21 * m32 - m31 * m22;
    var det_20_33 = m20 * m33 - m30 * m23;
    var det_20_32 = m20 * m32 - m22 * m30;
    var det_20_31 = m20 * m31 - m30 * m21;
    var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
    var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
    var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
    var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
    var det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
    if (det === 0) {
      other.copyFrom(this);
      return this;
    }
    var detInv = 1 / det;
    var det_12_33 = m12 * m33 - m32 * m13;
    var det_11_33 = m11 * m33 - m31 * m13;
    var det_11_32 = m11 * m32 - m31 * m12;
    var det_10_33 = m10 * m33 - m30 * m13;
    var det_10_32 = m10 * m32 - m30 * m12;
    var det_10_31 = m10 * m31 - m30 * m11;
    var det_12_23 = m12 * m23 - m22 * m13;
    var det_11_23 = m11 * m23 - m21 * m13;
    var det_11_22 = m11 * m22 - m21 * m12;
    var det_10_23 = m10 * m23 - m20 * m13;
    var det_10_22 = m10 * m22 - m20 * m12;
    var det_10_21 = m10 * m21 - m20 * m11;
    var cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);
    var cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);
    var cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);
    var cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);
    var cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);
    var cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);
    var cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);
    var cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);
    var cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);
    var cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);
    var cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);
    var cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);
    Matrix2.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);
    return this;
  };
  Matrix2.prototype.addAtIndex = function(index, value) {
    this._m[index] += value;
    this.markAsUpdated();
    return this;
  };
  Matrix2.prototype.multiplyAtIndex = function(index, value) {
    this._m[index] *= value;
    this.markAsUpdated();
    return this;
  };
  Matrix2.prototype.setTranslationFromFloats = function(x, y, z) {
    this._m[12] = x;
    this._m[13] = y;
    this._m[14] = z;
    this.markAsUpdated();
    return this;
  };
  Matrix2.prototype.addTranslationFromFloats = function(x, y, z) {
    this._m[12] += x;
    this._m[13] += y;
    this._m[14] += z;
    this.markAsUpdated();
    return this;
  };
  Matrix2.prototype.setTranslation = function(vector3) {
    return this.setTranslationFromFloats(vector3._x, vector3._y, vector3._z);
  };
  Matrix2.prototype.getTranslation = function() {
    return new Vector3(this._m[12], this._m[13], this._m[14]);
  };
  Matrix2.prototype.getTranslationToRef = function(result) {
    result.x = this._m[12];
    result.y = this._m[13];
    result.z = this._m[14];
    return this;
  };
  Matrix2.prototype.removeRotationAndScaling = function() {
    var m = this.m;
    Matrix2.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, m[12], m[13], m[14], m[15], this);
    this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);
    return this;
  };
  Matrix2.prototype.multiply = function(other) {
    var result = new Matrix2();
    this.multiplyToRef(other, result);
    return result;
  };
  Matrix2.prototype.copyFrom = function(other) {
    other.copyToArray(this._m);
    var o = other;
    this.updateFlag = o.updateFlag;
    this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);
    return this;
  };
  Matrix2.prototype.copyToArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var source = this._m;
    array[offset] = source[0];
    array[offset + 1] = source[1];
    array[offset + 2] = source[2];
    array[offset + 3] = source[3];
    array[offset + 4] = source[4];
    array[offset + 5] = source[5];
    array[offset + 6] = source[6];
    array[offset + 7] = source[7];
    array[offset + 8] = source[8];
    array[offset + 9] = source[9];
    array[offset + 10] = source[10];
    array[offset + 11] = source[11];
    array[offset + 12] = source[12];
    array[offset + 13] = source[13];
    array[offset + 14] = source[14];
    array[offset + 15] = source[15];
    return this;
  };
  Matrix2.prototype.multiplyToRef = function(other, result) {
    if (this._isIdentity) {
      result.copyFrom(other);
      return this;
    }
    if (other._isIdentity) {
      result.copyFrom(this);
      return this;
    }
    this.multiplyToArray(other, result._m, 0);
    result.markAsUpdated();
    return this;
  };
  Matrix2.prototype.multiplyToArray = function(other, result, offset) {
    var m = this._m;
    var otherM = other.m;
    var tm0 = m[0], tm1 = m[1], tm2 = m[2], tm3 = m[3];
    var tm4 = m[4], tm5 = m[5], tm6 = m[6], tm7 = m[7];
    var tm8 = m[8], tm9 = m[9], tm10 = m[10], tm11 = m[11];
    var tm12 = m[12], tm13 = m[13], tm14 = m[14], tm15 = m[15];
    var om0 = otherM[0], om1 = otherM[1], om2 = otherM[2], om3 = otherM[3];
    var om4 = otherM[4], om5 = otherM[5], om6 = otherM[6], om7 = otherM[7];
    var om8 = otherM[8], om9 = otherM[9], om10 = otherM[10], om11 = otherM[11];
    var om12 = otherM[12], om13 = otherM[13], om14 = otherM[14], om15 = otherM[15];
    result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;
    result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;
    result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;
    result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;
    result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;
    result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;
    result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;
    result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;
    result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;
    result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;
    result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;
    result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;
    result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;
    result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;
    result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;
    result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;
    return this;
  };
  Matrix2.prototype.equals = function(value) {
    var other = value;
    if (!other) {
      return false;
    }
    if (this._isIdentity || other._isIdentity) {
      if (!this._isIdentityDirty && !other._isIdentityDirty) {
        return this._isIdentity && other._isIdentity;
      }
    }
    var m = this.m;
    var om = other.m;
    return m[0] === om[0] && m[1] === om[1] && m[2] === om[2] && m[3] === om[3] && m[4] === om[4] && m[5] === om[5] && m[6] === om[6] && m[7] === om[7] && m[8] === om[8] && m[9] === om[9] && m[10] === om[10] && m[11] === om[11] && m[12] === om[12] && m[13] === om[13] && m[14] === om[14] && m[15] === om[15];
  };
  Matrix2.prototype.clone = function() {
    var matrix = new Matrix2();
    matrix.copyFrom(this);
    return matrix;
  };
  Matrix2.prototype.getClassName = function() {
    return "Matrix";
  };
  Matrix2.prototype.getHashCode = function() {
    var hash = _ExtractAsInt(this._m[0]);
    for (var i = 1; i < 16; i++) {
      hash = hash * 397 ^ _ExtractAsInt(this._m[i]);
    }
    return hash;
  };
  Matrix2.prototype.decomposeToTransformNode = function(node) {
    node.rotationQuaternion = node.rotationQuaternion || new Quaternion();
    return this.decompose(node.scaling, node.rotationQuaternion, node.position);
  };
  Matrix2.prototype.decompose = function(scale, rotation, translation, preserveScalingNode) {
    if (this._isIdentity) {
      if (translation) {
        translation.setAll(0);
      }
      if (scale) {
        scale.setAll(1);
      }
      if (rotation) {
        rotation.copyFromFloats(0, 0, 0, 1);
      }
      return true;
    }
    var m = this._m;
    if (translation) {
      translation.copyFromFloats(m[12], m[13], m[14]);
    }
    scale = scale || MathTmp.Vector3[0];
    scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
    scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);
    scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);
    if (preserveScalingNode) {
      var signX = preserveScalingNode.scaling.x < 0 ? -1 : 1;
      var signY = preserveScalingNode.scaling.y < 0 ? -1 : 1;
      var signZ = preserveScalingNode.scaling.z < 0 ? -1 : 1;
      scale.x *= signX;
      scale.y *= signY;
      scale.z *= signZ;
    } else {
      if (this.determinant() <= 0) {
        scale.y *= -1;
      }
    }
    if (scale._x === 0 || scale._y === 0 || scale._z === 0) {
      if (rotation) {
        rotation.copyFromFloats(0, 0, 0, 1);
      }
      return false;
    }
    if (rotation) {
      var sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
      Matrix2.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, MathTmp.Matrix[0]);
      Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);
    }
    return true;
  };
  Matrix2.prototype.getRow = function(index) {
    if (index < 0 || index > 3) {
      return null;
    }
    var i = index * 4;
    return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);
  };
  Matrix2.prototype.setRow = function(index, row) {
    return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);
  };
  Matrix2.prototype.transpose = function() {
    return Matrix2.Transpose(this);
  };
  Matrix2.prototype.transposeToRef = function(result) {
    Matrix2.TransposeToRef(this, result);
    return this;
  };
  Matrix2.prototype.setRowFromFloats = function(index, x, y, z, w) {
    if (index < 0 || index > 3) {
      return this;
    }
    var i = index * 4;
    this._m[i + 0] = x;
    this._m[i + 1] = y;
    this._m[i + 2] = z;
    this._m[i + 3] = w;
    this.markAsUpdated();
    return this;
  };
  Matrix2.prototype.scale = function(scale) {
    var result = new Matrix2();
    this.scaleToRef(scale, result);
    return result;
  };
  Matrix2.prototype.scaleToRef = function(scale, result) {
    for (var index = 0; index < 16; index++) {
      result._m[index] = this._m[index] * scale;
    }
    result.markAsUpdated();
    return this;
  };
  Matrix2.prototype.scaleAndAddToRef = function(scale, result) {
    for (var index = 0; index < 16; index++) {
      result._m[index] += this._m[index] * scale;
    }
    result.markAsUpdated();
    return this;
  };
  Matrix2.prototype.toNormalMatrix = function(ref) {
    var tmp = MathTmp.Matrix[0];
    this.invertToRef(tmp);
    tmp.transposeToRef(ref);
    var m = ref._m;
    Matrix2.FromValuesToRef(m[0], m[1], m[2], 0, m[4], m[5], m[6], 0, m[8], m[9], m[10], 0, 0, 0, 0, 1, ref);
  };
  Matrix2.prototype.getRotationMatrix = function() {
    var result = new Matrix2();
    this.getRotationMatrixToRef(result);
    return result;
  };
  Matrix2.prototype.getRotationMatrixToRef = function(result) {
    var scale = MathTmp.Vector3[0];
    if (!this.decompose(scale)) {
      Matrix2.IdentityToRef(result);
      return this;
    }
    var m = this._m;
    var sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
    Matrix2.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, result);
    return this;
  };
  Matrix2.prototype.toggleModelMatrixHandInPlace = function() {
    var m = this._m;
    m[2] *= -1;
    m[6] *= -1;
    m[8] *= -1;
    m[9] *= -1;
    m[14] *= -1;
    this.markAsUpdated();
  };
  Matrix2.prototype.toggleProjectionMatrixHandInPlace = function() {
    var m = this._m;
    m[8] *= -1;
    m[9] *= -1;
    m[10] *= -1;
    m[11] *= -1;
    this.markAsUpdated();
  };
  Matrix2.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var result = new Matrix2();
    Matrix2.FromArrayToRef(array, offset, result);
    return result;
  };
  Matrix2.FromArrayToRef = function(array, offset, result) {
    for (var index = 0; index < 16; index++) {
      result._m[index] = array[index + offset];
    }
    result.markAsUpdated();
  };
  Matrix2.FromFloat32ArrayToRefScaled = function(array, offset, scale, result) {
    for (var index = 0; index < 16; index++) {
      result._m[index] = array[index + offset] * scale;
    }
    result.markAsUpdated();
  };
  Object.defineProperty(Matrix2, "IdentityReadOnly", {
    get: function() {
      return Matrix2._identityReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Matrix2.FromValuesToRef = function(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {
    var m = result._m;
    m[0] = initialM11;
    m[1] = initialM12;
    m[2] = initialM13;
    m[3] = initialM14;
    m[4] = initialM21;
    m[5] = initialM22;
    m[6] = initialM23;
    m[7] = initialM24;
    m[8] = initialM31;
    m[9] = initialM32;
    m[10] = initialM33;
    m[11] = initialM34;
    m[12] = initialM41;
    m[13] = initialM42;
    m[14] = initialM43;
    m[15] = initialM44;
    result.markAsUpdated();
  };
  Matrix2.FromValues = function(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {
    var result = new Matrix2();
    var m = result._m;
    m[0] = initialM11;
    m[1] = initialM12;
    m[2] = initialM13;
    m[3] = initialM14;
    m[4] = initialM21;
    m[5] = initialM22;
    m[6] = initialM23;
    m[7] = initialM24;
    m[8] = initialM31;
    m[9] = initialM32;
    m[10] = initialM33;
    m[11] = initialM34;
    m[12] = initialM41;
    m[13] = initialM42;
    m[14] = initialM43;
    m[15] = initialM44;
    result.markAsUpdated();
    return result;
  };
  Matrix2.Compose = function(scale, rotation, translation) {
    var result = new Matrix2();
    Matrix2.ComposeToRef(scale, rotation, translation, result);
    return result;
  };
  Matrix2.ComposeToRef = function(scale, rotation, translation, result) {
    var m = result._m;
    var x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;
    var sx = scale._x, sy = scale._y, sz = scale._z;
    m[0] = (1 - (yy + zz)) * sx;
    m[1] = (xy + wz) * sx;
    m[2] = (xz - wy) * sx;
    m[3] = 0;
    m[4] = (xy - wz) * sy;
    m[5] = (1 - (xx + zz)) * sy;
    m[6] = (yz + wx) * sy;
    m[7] = 0;
    m[8] = (xz + wy) * sz;
    m[9] = (yz - wx) * sz;
    m[10] = (1 - (xx + yy)) * sz;
    m[11] = 0;
    m[12] = translation._x;
    m[13] = translation._y;
    m[14] = translation._z;
    m[15] = 1;
    result.markAsUpdated();
  };
  Matrix2.Identity = function() {
    var identity = Matrix2.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    identity._updateIdentityStatus(true);
    return identity;
  };
  Matrix2.IdentityToRef = function(result) {
    Matrix2.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(true);
  };
  Matrix2.Zero = function() {
    var zero = Matrix2.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    zero._updateIdentityStatus(false);
    return zero;
  };
  Matrix2.RotationX = function(angle) {
    var result = new Matrix2();
    Matrix2.RotationXToRef(angle, result);
    return result;
  };
  Matrix2.Invert = function(source) {
    var result = new Matrix2();
    source.invertToRef(result);
    return result;
  };
  Matrix2.RotationXToRef = function(angle, result) {
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    Matrix2.FromValuesToRef(1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
  };
  Matrix2.RotationY = function(angle) {
    var result = new Matrix2();
    Matrix2.RotationYToRef(angle, result);
    return result;
  };
  Matrix2.RotationYToRef = function(angle, result) {
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    Matrix2.FromValuesToRef(c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
  };
  Matrix2.RotationZ = function(angle) {
    var result = new Matrix2();
    Matrix2.RotationZToRef(angle, result);
    return result;
  };
  Matrix2.RotationZToRef = function(angle, result) {
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    Matrix2.FromValuesToRef(c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
  };
  Matrix2.RotationAxis = function(axis, angle) {
    var result = new Matrix2();
    Matrix2.RotationAxisToRef(axis, angle, result);
    return result;
  };
  Matrix2.RotationAxisToRef = function(axis, angle, result) {
    var s = Math.sin(-angle);
    var c = Math.cos(-angle);
    var c1 = 1 - c;
    axis.normalize();
    var m = result._m;
    m[0] = axis._x * axis._x * c1 + c;
    m[1] = axis._x * axis._y * c1 - axis._z * s;
    m[2] = axis._x * axis._z * c1 + axis._y * s;
    m[3] = 0;
    m[4] = axis._y * axis._x * c1 + axis._z * s;
    m[5] = axis._y * axis._y * c1 + c;
    m[6] = axis._y * axis._z * c1 - axis._x * s;
    m[7] = 0;
    m[8] = axis._z * axis._x * c1 - axis._y * s;
    m[9] = axis._z * axis._y * c1 + axis._x * s;
    m[10] = axis._z * axis._z * c1 + c;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    result.markAsUpdated();
  };
  Matrix2.RotationAlignToRef = function(from, to, result) {
    var c = Vector3.Dot(to, from);
    var m = result._m;
    if (c < -1 + Epsilon) {
      m[0] = -1;
      m[1] = 0;
      m[2] = 0;
      m[3] = 0;
      m[4] = 0;
      m[5] = -1;
      m[6] = 0;
      m[7] = 0;
      m[8] = 0;
      m[9] = 0;
      m[10] = 1;
      m[11] = 0;
    } else {
      var v = Vector3.Cross(to, from);
      var k = 1 / (1 + c);
      m[0] = v._x * v._x * k + c;
      m[1] = v._y * v._x * k - v._z;
      m[2] = v._z * v._x * k + v._y;
      m[3] = 0;
      m[4] = v._x * v._y * k + v._z;
      m[5] = v._y * v._y * k + c;
      m[6] = v._z * v._y * k - v._x;
      m[7] = 0;
      m[8] = v._x * v._z * k - v._y;
      m[9] = v._y * v._z * k + v._x;
      m[10] = v._z * v._z * k + c;
      m[11] = 0;
    }
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    result.markAsUpdated();
  };
  Matrix2.RotationYawPitchRoll = function(yaw, pitch, roll) {
    var result = new Matrix2();
    Matrix2.RotationYawPitchRollToRef(yaw, pitch, roll, result);
    return result;
  };
  Matrix2.RotationYawPitchRollToRef = function(yaw, pitch, roll, result) {
    Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);
    MathTmp.Quaternion[0].toRotationMatrix(result);
  };
  Matrix2.Scaling = function(x, y, z) {
    var result = new Matrix2();
    Matrix2.ScalingToRef(x, y, z, result);
    return result;
  };
  Matrix2.ScalingToRef = function(x, y, z, result) {
    Matrix2.FromValuesToRef(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(x === 1 && y === 1 && z === 1);
  };
  Matrix2.Translation = function(x, y, z) {
    var result = new Matrix2();
    Matrix2.TranslationToRef(x, y, z, result);
    return result;
  };
  Matrix2.TranslationToRef = function(x, y, z, result) {
    Matrix2.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1, result);
    result._updateIdentityStatus(x === 0 && y === 0 && z === 0);
  };
  Matrix2.Lerp = function(startValue, endValue, gradient) {
    var result = new Matrix2();
    Matrix2.LerpToRef(startValue, endValue, gradient, result);
    return result;
  };
  Matrix2.LerpToRef = function(startValue, endValue, gradient, result) {
    var resultM = result._m;
    var startM = startValue.m;
    var endM = endValue.m;
    for (var index = 0; index < 16; index++) {
      resultM[index] = startM[index] * (1 - gradient) + endM[index] * gradient;
    }
    result.markAsUpdated();
  };
  Matrix2.DecomposeLerp = function(startValue, endValue, gradient) {
    var result = new Matrix2();
    Matrix2.DecomposeLerpToRef(startValue, endValue, gradient, result);
    return result;
  };
  Matrix2.DecomposeLerpToRef = function(startValue, endValue, gradient, result) {
    var startScale = MathTmp.Vector3[0];
    var startRotation = MathTmp.Quaternion[0];
    var startTranslation = MathTmp.Vector3[1];
    startValue.decompose(startScale, startRotation, startTranslation);
    var endScale = MathTmp.Vector3[2];
    var endRotation = MathTmp.Quaternion[1];
    var endTranslation = MathTmp.Vector3[3];
    endValue.decompose(endScale, endRotation, endTranslation);
    var resultScale = MathTmp.Vector3[4];
    Vector3.LerpToRef(startScale, endScale, gradient, resultScale);
    var resultRotation = MathTmp.Quaternion[2];
    Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);
    var resultTranslation = MathTmp.Vector3[5];
    Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);
    Matrix2.ComposeToRef(resultScale, resultRotation, resultTranslation, result);
  };
  Matrix2.LookAtLH = function(eye, target, up) {
    var result = new Matrix2();
    Matrix2.LookAtLHToRef(eye, target, up, result);
    return result;
  };
  Matrix2.LookAtLHToRef = function(eye, target, up, result) {
    var xAxis = MathTmp.Vector3[0];
    var yAxis = MathTmp.Vector3[1];
    var zAxis = MathTmp.Vector3[2];
    target.subtractToRef(eye, zAxis);
    zAxis.normalize();
    Vector3.CrossToRef(up, zAxis, xAxis);
    var xSquareLength = xAxis.lengthSquared();
    if (xSquareLength === 0) {
      xAxis.x = 1;
    } else {
      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
    }
    Vector3.CrossToRef(zAxis, xAxis, yAxis);
    yAxis.normalize();
    var ex = -Vector3.Dot(xAxis, eye);
    var ey = -Vector3.Dot(yAxis, eye);
    var ez = -Vector3.Dot(zAxis, eye);
    Matrix2.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
  };
  Matrix2.LookAtRH = function(eye, target, up) {
    var result = new Matrix2();
    Matrix2.LookAtRHToRef(eye, target, up, result);
    return result;
  };
  Matrix2.LookAtRHToRef = function(eye, target, up, result) {
    var xAxis = MathTmp.Vector3[0];
    var yAxis = MathTmp.Vector3[1];
    var zAxis = MathTmp.Vector3[2];
    eye.subtractToRef(target, zAxis);
    zAxis.normalize();
    Vector3.CrossToRef(up, zAxis, xAxis);
    var xSquareLength = xAxis.lengthSquared();
    if (xSquareLength === 0) {
      xAxis.x = 1;
    } else {
      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
    }
    Vector3.CrossToRef(zAxis, xAxis, yAxis);
    yAxis.normalize();
    var ex = -Vector3.Dot(xAxis, eye);
    var ey = -Vector3.Dot(yAxis, eye);
    var ez = -Vector3.Dot(zAxis, eye);
    Matrix2.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
  };
  Matrix2.LookDirectionLH = function(forward, up) {
    var result = new Matrix2();
    Matrix2.LookDirectionLHToRef(forward, up, result);
    return result;
  };
  Matrix2.LookDirectionLHToRef = function(forward, up, result) {
    var back = MathTmp.Vector3[0];
    back.copyFrom(forward);
    back.scaleInPlace(-1);
    var left = MathTmp.Vector3[1];
    Vector3.CrossToRef(up, back, left);
    Matrix2.FromValuesToRef(left._x, left._y, left._z, 0, up._x, up._y, up._z, 0, back._x, back._y, back._z, 0, 0, 0, 0, 1, result);
  };
  Matrix2.LookDirectionRH = function(forward, up) {
    var result = new Matrix2();
    Matrix2.LookDirectionRHToRef(forward, up, result);
    return result;
  };
  Matrix2.LookDirectionRHToRef = function(forward, up, result) {
    var right = MathTmp.Vector3[2];
    Vector3.CrossToRef(up, forward, right);
    Matrix2.FromValuesToRef(right._x, right._y, right._z, 0, up._x, up._y, up._z, 0, forward._x, forward._y, forward._z, 0, 0, 0, 0, 1, result);
  };
  Matrix2.OrthoLH = function(width, height, znear, zfar, halfZRange) {
    var matrix = new Matrix2();
    Matrix2.OrthoLHToRef(width, height, znear, zfar, matrix, halfZRange);
    return matrix;
  };
  Matrix2.OrthoLHToRef = function(width, height, znear, zfar, result, halfZRange) {
    var n = znear;
    var f = zfar;
    var a = 2 / width;
    var b = 2 / height;
    var c = 2 / (f - n);
    var d = -(f + n) / (f - n);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, d, 1, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);
  };
  Matrix2.OrthoOffCenterLH = function(left, right, bottom, top, znear, zfar, halfZRange) {
    var matrix = new Matrix2();
    Matrix2.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);
    return matrix;
  };
  Matrix2.OrthoOffCenterLHToRef = function(left, right, bottom, top, znear, zfar, result, halfZRange) {
    var n = znear;
    var f = zfar;
    var a = 2 / (right - left);
    var b = 2 / (top - bottom);
    var c = 2 / (f - n);
    var d = -(f + n) / (f - n);
    var i0 = (left + right) / (left - right);
    var i1 = (top + bottom) / (bottom - top);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, i0, i1, d, 1, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result.markAsUpdated();
  };
  Matrix2.OrthoOffCenterRH = function(left, right, bottom, top, znear, zfar, halfZRange) {
    var matrix = new Matrix2();
    Matrix2.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);
    return matrix;
  };
  Matrix2.OrthoOffCenterRHToRef = function(left, right, bottom, top, znear, zfar, result, halfZRange) {
    Matrix2.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange);
    result._m[10] *= -1;
  };
  Matrix2.PerspectiveLH = function(width, height, znear, zfar, halfZRange, projectionPlaneTilt) {
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    var matrix = new Matrix2();
    var n = znear;
    var f = zfar;
    var a = 2 * n / width;
    var b = 2 * n / height;
    var c = (f + n) / (f - n);
    var d = -2 * f * n / (f - n);
    var rot = Math.tan(projectionPlaneTilt);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, 1, 0, 0, d, 0, matrix);
    if (halfZRange) {
      matrix.multiplyToRef(mtxConvertNDCToHalfZRange, matrix);
    }
    matrix._updateIdentityStatus(false);
    return matrix;
  };
  Matrix2.PerspectiveFovLH = function(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    if (reverseDepthBufferMode === void 0) {
      reverseDepthBufferMode = false;
    }
    var matrix = new Matrix2();
    Matrix2.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);
    return matrix;
  };
  Matrix2.PerspectiveFovLHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {
    if (isVerticalFovFixed === void 0) {
      isVerticalFovFixed = true;
    }
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    if (reverseDepthBufferMode === void 0) {
      reverseDepthBufferMode = false;
    }
    var n = znear;
    var f = zfar;
    var t = 1 / Math.tan(fov * 0.5);
    var a = isVerticalFovFixed ? t / aspect : t;
    var b = isVerticalFovFixed ? t : t * aspect;
    var c = reverseDepthBufferMode && n === 0 ? -1 : f !== 0 ? (f + n) / (f - n) : 1;
    var d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2 * f * n / (f - n) : -2 * n;
    var rot = Math.tan(projectionPlaneTilt);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, 1, 0, 0, d, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
  };
  Matrix2.PerspectiveFovReverseLHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt) {
    if (isVerticalFovFixed === void 0) {
      isVerticalFovFixed = true;
    }
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    var t = 1 / Math.tan(fov * 0.5);
    var a = isVerticalFovFixed ? t / aspect : t;
    var b = isVerticalFovFixed ? t : t * aspect;
    var rot = Math.tan(projectionPlaneTilt);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, -znear, 1, 0, 0, 1, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
  };
  Matrix2.PerspectiveFovRH = function(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    if (reverseDepthBufferMode === void 0) {
      reverseDepthBufferMode = false;
    }
    var matrix = new Matrix2();
    Matrix2.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);
    return matrix;
  };
  Matrix2.PerspectiveFovRHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {
    if (isVerticalFovFixed === void 0) {
      isVerticalFovFixed = true;
    }
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    if (reverseDepthBufferMode === void 0) {
      reverseDepthBufferMode = false;
    }
    var n = znear;
    var f = zfar;
    var t = 1 / Math.tan(fov * 0.5);
    var a = isVerticalFovFixed ? t / aspect : t;
    var b = isVerticalFovFixed ? t : t * aspect;
    var c = reverseDepthBufferMode && n === 0 ? 1 : f !== 0 ? -(f + n) / (f - n) : -1;
    var d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2 * f * n / (f - n) : -2 * n;
    var rot = Math.tan(projectionPlaneTilt);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, -1, 0, 0, d, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
  };
  Matrix2.PerspectiveFovReverseRHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt) {
    if (isVerticalFovFixed === void 0) {
      isVerticalFovFixed = true;
    }
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    var t = 1 / Math.tan(fov * 0.5);
    var a = isVerticalFovFixed ? t / aspect : t;
    var b = isVerticalFovFixed ? t : t * aspect;
    var rot = Math.tan(projectionPlaneTilt);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, -znear, -1, 0, 0, -1, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
  };
  Matrix2.PerspectiveFovWebVRToRef = function(fov, znear, zfar, result, rightHanded, halfZRange, projectionPlaneTilt) {
    if (rightHanded === void 0) {
      rightHanded = false;
    }
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    var rightHandedFactor = rightHanded ? -1 : 1;
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    var xScale = 2 / (leftTan + rightTan);
    var yScale = 2 / (upTan + downTan);
    var rot = Math.tan(projectionPlaneTilt);
    var m = result._m;
    m[0] = xScale;
    m[1] = m[2] = m[3] = m[4] = 0;
    m[5] = yScale;
    m[6] = 0;
    m[7] = rot;
    m[8] = (leftTan - rightTan) * xScale * 0.5;
    m[9] = -((upTan - downTan) * yScale * 0.5);
    m[10] = -zfar / (znear - zfar);
    m[11] = 1 * rightHandedFactor;
    m[12] = m[13] = m[15] = 0;
    m[14] = -(2 * zfar * znear) / (zfar - znear);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result.markAsUpdated();
  };
  Matrix2.GetFinalMatrix = function(viewport, world, view, projection, zmin, zmax) {
    var cw = viewport.width;
    var ch = viewport.height;
    var cx = viewport.x;
    var cy = viewport.y;
    var viewportMatrix = Matrix2.FromValues(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, zmax - zmin, 0, cx + cw / 2, ch / 2 + cy, zmin, 1);
    var matrix = MathTmp.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    return matrix.multiply(viewportMatrix);
  };
  Matrix2.GetAsMatrix2x2 = function(matrix) {
    var m = matrix.m;
    var arr = [m[0], m[1], m[4], m[5]];
    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
  };
  Matrix2.GetAsMatrix3x3 = function(matrix) {
    var m = matrix.m;
    var arr = [
      m[0],
      m[1],
      m[2],
      m[4],
      m[5],
      m[6],
      m[8],
      m[9],
      m[10]
    ];
    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
  };
  Matrix2.Transpose = function(matrix) {
    var result = new Matrix2();
    Matrix2.TransposeToRef(matrix, result);
    return result;
  };
  Matrix2.TransposeToRef = function(matrix, result) {
    var rm = result._m;
    var mm = matrix.m;
    rm[0] = mm[0];
    rm[1] = mm[4];
    rm[2] = mm[8];
    rm[3] = mm[12];
    rm[4] = mm[1];
    rm[5] = mm[5];
    rm[6] = mm[9];
    rm[7] = mm[13];
    rm[8] = mm[2];
    rm[9] = mm[6];
    rm[10] = mm[10];
    rm[11] = mm[14];
    rm[12] = mm[3];
    rm[13] = mm[7];
    rm[14] = mm[11];
    rm[15] = mm[15];
    result.markAsUpdated();
    result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);
  };
  Matrix2.Reflection = function(plane) {
    var matrix = new Matrix2();
    Matrix2.ReflectionToRef(plane, matrix);
    return matrix;
  };
  Matrix2.ReflectionToRef = function(plane, result) {
    plane.normalize();
    var x = plane.normal.x;
    var y = plane.normal.y;
    var z = plane.normal.z;
    var temp = -2 * x;
    var temp2 = -2 * y;
    var temp3 = -2 * z;
    Matrix2.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0, temp * y, temp2 * y + 1, temp3 * y, 0, temp * z, temp2 * z, temp3 * z + 1, 0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1, result);
  };
  Matrix2.FromXYZAxesToRef = function(xaxis, yaxis, zaxis, result) {
    Matrix2.FromValuesToRef(xaxis._x, xaxis._y, xaxis._z, 0, yaxis._x, yaxis._y, yaxis._z, 0, zaxis._x, zaxis._y, zaxis._z, 0, 0, 0, 0, 1, result);
  };
  Matrix2.FromQuaternionToRef = function(quat, result) {
    var xx = quat._x * quat._x;
    var yy = quat._y * quat._y;
    var zz = quat._z * quat._z;
    var xy = quat._x * quat._y;
    var zw = quat._z * quat._w;
    var zx = quat._z * quat._x;
    var yw = quat._y * quat._w;
    var yz = quat._y * quat._z;
    var xw = quat._x * quat._w;
    result._m[0] = 1 - 2 * (yy + zz);
    result._m[1] = 2 * (xy + zw);
    result._m[2] = 2 * (zx - yw);
    result._m[3] = 0;
    result._m[4] = 2 * (xy - zw);
    result._m[5] = 1 - 2 * (zz + xx);
    result._m[6] = 2 * (yz + xw);
    result._m[7] = 0;
    result._m[8] = 2 * (zx + yw);
    result._m[9] = 2 * (yz - xw);
    result._m[10] = 1 - 2 * (yy + xx);
    result._m[11] = 0;
    result._m[12] = 0;
    result._m[13] = 0;
    result._m[14] = 0;
    result._m[15] = 1;
    result.markAsUpdated();
  };
  Matrix2._updateFlagSeed = 0;
  Matrix2._identityReadOnly = Matrix2.Identity();
  return Matrix2;
}();
var MathTmp = function() {
  function MathTmp2() {
  }
  MathTmp2.Vector3 = ArrayTools.BuildTuple(11, Vector3.Zero);
  MathTmp2.Matrix = ArrayTools.BuildTuple(2, Matrix.Identity);
  MathTmp2.Quaternion = ArrayTools.BuildTuple(3, Quaternion.Zero);
  return MathTmp2;
}();
var TmpVectors = function() {
  function TmpVectors2() {
  }
  TmpVectors2.Vector2 = ArrayTools.BuildTuple(3, Vector2.Zero);
  TmpVectors2.Vector3 = ArrayTools.BuildTuple(13, Vector3.Zero);
  TmpVectors2.Vector4 = ArrayTools.BuildTuple(3, Vector4.Zero);
  TmpVectors2.Quaternion = ArrayTools.BuildTuple(2, Quaternion.Zero);
  TmpVectors2.Matrix = ArrayTools.BuildTuple(8, Matrix.Identity);
  return TmpVectors2;
}();
RegisterClass("BABYLON.Vector2", Vector2);
RegisterClass("BABYLON.Vector3", Vector3);
RegisterClass("BABYLON.Vector4", Vector4);
RegisterClass("BABYLON.Matrix", Matrix);
var mtxConvertNDCToHalfZRange = Matrix.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);
var Space;
(function(Space2) {
  Space2[Space2["LOCAL"] = 0] = "LOCAL";
  Space2[Space2["WORLD"] = 1] = "WORLD";
  Space2[Space2["BONE"] = 2] = "BONE";
})(Space || (Space = {}));
var Axis = function() {
  function Axis2() {
  }
  Axis2.X = new Vector3(1, 0, 0);
  Axis2.Y = new Vector3(0, 1, 0);
  Axis2.Z = new Vector3(0, 0, 1);
  return Axis2;
}();
var Coordinate;
(function(Coordinate2) {
  Coordinate2[Coordinate2["X"] = 0] = "X";
  Coordinate2[Coordinate2["Y"] = 1] = "Y";
  Coordinate2[Coordinate2["Z"] = 2] = "Z";
})(Coordinate || (Coordinate = {}));
var Color3 = function() {
  function Color32(r, g, b) {
    if (r === void 0) {
      r = 0;
    }
    if (g === void 0) {
      g = 0;
    }
    if (b === void 0) {
      b = 0;
    }
    this.r = r;
    this.g = g;
    this.b = b;
  }
  Color32.prototype.toString = function() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}";
  };
  Color32.prototype.getClassName = function() {
    return "Color3";
  };
  Color32.prototype.getHashCode = function() {
    var hash = this.r * 255 | 0;
    hash = hash * 397 ^ (this.g * 255 | 0);
    hash = hash * 397 ^ (this.b * 255 | 0);
    return hash;
  };
  Color32.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.r;
    array[index + 1] = this.g;
    array[index + 2] = this.b;
    return this;
  };
  Color32.prototype.fromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    Color32.FromArrayToRef(array, offset, this);
    return this;
  };
  Color32.prototype.toColor4 = function(alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    return new Color4$1(this.r, this.g, this.b, alpha);
  };
  Color32.prototype.asArray = function() {
    var result = new Array();
    this.toArray(result, 0);
    return result;
  };
  Color32.prototype.toLuminance = function() {
    return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
  };
  Color32.prototype.multiply = function(otherColor) {
    return new Color32(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);
  };
  Color32.prototype.multiplyToRef = function(otherColor, result) {
    result.r = this.r * otherColor.r;
    result.g = this.g * otherColor.g;
    result.b = this.b * otherColor.b;
    return this;
  };
  Color32.prototype.equals = function(otherColor) {
    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;
  };
  Color32.prototype.equalsFloats = function(r, g, b) {
    return this.r === r && this.g === g && this.b === b;
  };
  Color32.prototype.scale = function(scale) {
    return new Color32(this.r * scale, this.g * scale, this.b * scale);
  };
  Color32.prototype.scaleToRef = function(scale, result) {
    result.r = this.r * scale;
    result.g = this.g * scale;
    result.b = this.b * scale;
    return this;
  };
  Color32.prototype.scaleAndAddToRef = function(scale, result) {
    result.r += this.r * scale;
    result.g += this.g * scale;
    result.b += this.b * scale;
    return this;
  };
  Color32.prototype.clampToRef = function(min, max, result) {
    if (min === void 0) {
      min = 0;
    }
    if (max === void 0) {
      max = 1;
    }
    result.r = Scalar.Clamp(this.r, min, max);
    result.g = Scalar.Clamp(this.g, min, max);
    result.b = Scalar.Clamp(this.b, min, max);
    return this;
  };
  Color32.prototype.add = function(otherColor) {
    return new Color32(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);
  };
  Color32.prototype.addToRef = function(otherColor, result) {
    result.r = this.r + otherColor.r;
    result.g = this.g + otherColor.g;
    result.b = this.b + otherColor.b;
    return this;
  };
  Color32.prototype.subtract = function(otherColor) {
    return new Color32(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);
  };
  Color32.prototype.subtractToRef = function(otherColor, result) {
    result.r = this.r - otherColor.r;
    result.g = this.g - otherColor.g;
    result.b = this.b - otherColor.b;
    return this;
  };
  Color32.prototype.clone = function() {
    return new Color32(this.r, this.g, this.b);
  };
  Color32.prototype.copyFrom = function(source) {
    this.r = source.r;
    this.g = source.g;
    this.b = source.b;
    return this;
  };
  Color32.prototype.copyFromFloats = function(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  };
  Color32.prototype.set = function(r, g, b) {
    return this.copyFromFloats(r, g, b);
  };
  Color32.prototype.toHexString = function() {
    var intR = Math.round(this.r * 255);
    var intG = Math.round(this.g * 255);
    var intB = Math.round(this.b * 255);
    return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
  };
  Color32.prototype.toLinearSpace = function() {
    var convertedColor = new Color32();
    this.toLinearSpaceToRef(convertedColor);
    return convertedColor;
  };
  Color32.prototype.toHSV = function() {
    var result = new Color32();
    this.toHSVToRef(result);
    return result;
  };
  Color32.prototype.toHSVToRef = function(result) {
    var r = this.r;
    var g = this.g;
    var b = this.b;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h = 0;
    var s = 0;
    var v = max;
    var dm = max - min;
    if (max !== 0) {
      s = dm / max;
    }
    if (max != min) {
      if (max == r) {
        h = (g - b) / dm;
        if (g < b) {
          h += 6;
        }
      } else if (max == g) {
        h = (b - r) / dm + 2;
      } else if (max == b) {
        h = (r - g) / dm + 4;
      }
      h *= 60;
    }
    result.r = h;
    result.g = s;
    result.b = v;
  };
  Color32.prototype.toLinearSpaceToRef = function(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToLinearSpace);
    convertedColor.g = Math.pow(this.g, ToLinearSpace);
    convertedColor.b = Math.pow(this.b, ToLinearSpace);
    return this;
  };
  Color32.prototype.toGammaSpace = function() {
    var convertedColor = new Color32();
    this.toGammaSpaceToRef(convertedColor);
    return convertedColor;
  };
  Color32.prototype.toGammaSpaceToRef = function(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToGammaSpace);
    convertedColor.g = Math.pow(this.g, ToGammaSpace);
    convertedColor.b = Math.pow(this.b, ToGammaSpace);
    return this;
  };
  Color32.HSVtoRGBToRef = function(hue, saturation, value, result) {
    var chroma = value * saturation;
    var h = hue / 60;
    var x = chroma * (1 - Math.abs(h % 2 - 1));
    var r = 0;
    var g = 0;
    var b = 0;
    if (h >= 0 && h <= 1) {
      r = chroma;
      g = x;
    } else if (h >= 1 && h <= 2) {
      r = x;
      g = chroma;
    } else if (h >= 2 && h <= 3) {
      g = chroma;
      b = x;
    } else if (h >= 3 && h <= 4) {
      g = x;
      b = chroma;
    } else if (h >= 4 && h <= 5) {
      r = x;
      b = chroma;
    } else if (h >= 5 && h <= 6) {
      r = chroma;
      b = x;
    }
    var m = value - chroma;
    result.set(r + m, g + m, b + m);
  };
  Color32.FromHexString = function(hex) {
    if (hex.substring(0, 1) !== "#" || hex.length !== 7) {
      return new Color32(0, 0, 0);
    }
    var r = parseInt(hex.substring(1, 3), 16);
    var g = parseInt(hex.substring(3, 5), 16);
    var b = parseInt(hex.substring(5, 7), 16);
    return Color32.FromInts(r, g, b);
  };
  Color32.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    return new Color32(array[offset], array[offset + 1], array[offset + 2]);
  };
  Color32.FromArrayToRef = function(array, offset, result) {
    if (offset === void 0) {
      offset = 0;
    }
    result.r = array[offset];
    result.g = array[offset + 1];
    result.b = array[offset + 2];
  };
  Color32.FromInts = function(r, g, b) {
    return new Color32(r / 255, g / 255, b / 255);
  };
  Color32.Lerp = function(start, end, amount) {
    var result = new Color32(0, 0, 0);
    Color32.LerpToRef(start, end, amount, result);
    return result;
  };
  Color32.LerpToRef = function(left, right, amount, result) {
    result.r = left.r + (right.r - left.r) * amount;
    result.g = left.g + (right.g - left.g) * amount;
    result.b = left.b + (right.b - left.b) * amount;
  };
  Color32.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    var r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;
    var g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;
    var b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;
    return new Color32(r, g, b);
  };
  Color32.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
    var result = Color32.Black();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  };
  Color32.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
    var t2 = time * time;
    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;
    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;
    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;
  };
  Color32.Red = function() {
    return new Color32(1, 0, 0);
  };
  Color32.Green = function() {
    return new Color32(0, 1, 0);
  };
  Color32.Blue = function() {
    return new Color32(0, 0, 1);
  };
  Color32.Black = function() {
    return new Color32(0, 0, 0);
  };
  Object.defineProperty(Color32, "BlackReadOnly", {
    get: function() {
      return Color32._BlackReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Color32.White = function() {
    return new Color32(1, 1, 1);
  };
  Color32.Purple = function() {
    return new Color32(0.5, 0, 0.5);
  };
  Color32.Magenta = function() {
    return new Color32(1, 0, 1);
  };
  Color32.Yellow = function() {
    return new Color32(1, 1, 0);
  };
  Color32.Gray = function() {
    return new Color32(0.5, 0.5, 0.5);
  };
  Color32.Teal = function() {
    return new Color32(0, 1, 1);
  };
  Color32.Random = function() {
    return new Color32(Math.random(), Math.random(), Math.random());
  };
  Color32._BlackReadOnly = Color32.Black();
  return Color32;
}();
var Color4$1 = function() {
  function Color42(r, g, b, a) {
    if (r === void 0) {
      r = 0;
    }
    if (g === void 0) {
      g = 0;
    }
    if (b === void 0) {
      b = 0;
    }
    if (a === void 0) {
      a = 1;
    }
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  Color42.prototype.addInPlace = function(right) {
    this.r += right.r;
    this.g += right.g;
    this.b += right.b;
    this.a += right.a;
    return this;
  };
  Color42.prototype.asArray = function() {
    var result = new Array();
    this.toArray(result, 0);
    return result;
  };
  Color42.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.r;
    array[index + 1] = this.g;
    array[index + 2] = this.b;
    array[index + 3] = this.a;
    return this;
  };
  Color42.prototype.fromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    Color42.FromArrayToRef(array, offset, this);
    return this;
  };
  Color42.prototype.equals = function(otherColor) {
    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;
  };
  Color42.prototype.add = function(right) {
    return new Color42(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);
  };
  Color42.prototype.subtract = function(right) {
    return new Color42(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);
  };
  Color42.prototype.subtractToRef = function(right, result) {
    result.r = this.r - right.r;
    result.g = this.g - right.g;
    result.b = this.b - right.b;
    result.a = this.a - right.a;
    return this;
  };
  Color42.prototype.scale = function(scale) {
    return new Color42(this.r * scale, this.g * scale, this.b * scale, this.a * scale);
  };
  Color42.prototype.scaleToRef = function(scale, result) {
    result.r = this.r * scale;
    result.g = this.g * scale;
    result.b = this.b * scale;
    result.a = this.a * scale;
    return this;
  };
  Color42.prototype.scaleAndAddToRef = function(scale, result) {
    result.r += this.r * scale;
    result.g += this.g * scale;
    result.b += this.b * scale;
    result.a += this.a * scale;
    return this;
  };
  Color42.prototype.clampToRef = function(min, max, result) {
    if (min === void 0) {
      min = 0;
    }
    if (max === void 0) {
      max = 1;
    }
    result.r = Scalar.Clamp(this.r, min, max);
    result.g = Scalar.Clamp(this.g, min, max);
    result.b = Scalar.Clamp(this.b, min, max);
    result.a = Scalar.Clamp(this.a, min, max);
    return this;
  };
  Color42.prototype.multiply = function(color) {
    return new Color42(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);
  };
  Color42.prototype.multiplyToRef = function(color, result) {
    result.r = this.r * color.r;
    result.g = this.g * color.g;
    result.b = this.b * color.b;
    result.a = this.a * color.a;
    return result;
  };
  Color42.prototype.toString = function() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}";
  };
  Color42.prototype.getClassName = function() {
    return "Color4";
  };
  Color42.prototype.getHashCode = function() {
    var hash = this.r * 255 | 0;
    hash = hash * 397 ^ (this.g * 255 | 0);
    hash = hash * 397 ^ (this.b * 255 | 0);
    hash = hash * 397 ^ (this.a * 255 | 0);
    return hash;
  };
  Color42.prototype.clone = function() {
    return new Color42(this.r, this.g, this.b, this.a);
  };
  Color42.prototype.copyFrom = function(source) {
    this.r = source.r;
    this.g = source.g;
    this.b = source.b;
    this.a = source.a;
    return this;
  };
  Color42.prototype.copyFromFloats = function(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this;
  };
  Color42.prototype.set = function(r, g, b, a) {
    return this.copyFromFloats(r, g, b, a);
  };
  Color42.prototype.toHexString = function(returnAsColor3) {
    if (returnAsColor3 === void 0) {
      returnAsColor3 = false;
    }
    var intR = Math.round(this.r * 255);
    var intG = Math.round(this.g * 255);
    var intB = Math.round(this.b * 255);
    if (returnAsColor3) {
      return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
    }
    var intA = Math.round(this.a * 255);
    return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);
  };
  Color42.prototype.toLinearSpace = function() {
    var convertedColor = new Color42();
    this.toLinearSpaceToRef(convertedColor);
    return convertedColor;
  };
  Color42.prototype.toLinearSpaceToRef = function(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToLinearSpace);
    convertedColor.g = Math.pow(this.g, ToLinearSpace);
    convertedColor.b = Math.pow(this.b, ToLinearSpace);
    convertedColor.a = this.a;
    return this;
  };
  Color42.prototype.toGammaSpace = function() {
    var convertedColor = new Color42();
    this.toGammaSpaceToRef(convertedColor);
    return convertedColor;
  };
  Color42.prototype.toGammaSpaceToRef = function(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToGammaSpace);
    convertedColor.g = Math.pow(this.g, ToGammaSpace);
    convertedColor.b = Math.pow(this.b, ToGammaSpace);
    convertedColor.a = this.a;
    return this;
  };
  Color42.FromHexString = function(hex) {
    if (hex.substring(0, 1) !== "#" || hex.length !== 9 && hex.length !== 7) {
      return new Color42(0, 0, 0, 0);
    }
    var r = parseInt(hex.substring(1, 3), 16);
    var g = parseInt(hex.substring(3, 5), 16);
    var b = parseInt(hex.substring(5, 7), 16);
    var a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) : 255;
    return Color42.FromInts(r, g, b, a);
  };
  Color42.Lerp = function(left, right, amount) {
    var result = new Color42(0, 0, 0, 0);
    Color42.LerpToRef(left, right, amount, result);
    return result;
  };
  Color42.LerpToRef = function(left, right, amount, result) {
    result.r = left.r + (right.r - left.r) * amount;
    result.g = left.g + (right.g - left.g) * amount;
    result.b = left.b + (right.b - left.b) * amount;
    result.a = left.a + (right.a - left.a) * amount;
  };
  Color42.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    var r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;
    var g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;
    var b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;
    var a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;
    return new Color42(r, g, b, a);
  };
  Color42.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
    var result = new Color42();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  };
  Color42.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
    var t2 = time * time;
    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;
    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;
    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;
    result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;
  };
  Color42.FromColor3 = function(color3, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    return new Color42(color3.r, color3.g, color3.b, alpha);
  };
  Color42.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    return new Color42(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  };
  Color42.FromArrayToRef = function(array, offset, result) {
    if (offset === void 0) {
      offset = 0;
    }
    result.r = array[offset];
    result.g = array[offset + 1];
    result.b = array[offset + 2];
    result.a = array[offset + 3];
  };
  Color42.FromInts = function(r, g, b, a) {
    return new Color42(r / 255, g / 255, b / 255, a / 255);
  };
  Color42.CheckColors4 = function(colors, count) {
    if (colors.length === count * 3) {
      var colors4 = [];
      for (var index = 0; index < colors.length; index += 3) {
        var newIndex = index / 3 * 4;
        colors4[newIndex] = colors[index];
        colors4[newIndex + 1] = colors[index + 1];
        colors4[newIndex + 2] = colors[index + 2];
        colors4[newIndex + 3] = 1;
      }
      return colors4;
    }
    return colors;
  };
  return Color42;
}();
var TmpColors = function() {
  function TmpColors2() {
  }
  TmpColors2.Color3 = ArrayTools.BuildArray(3, Color3.Black);
  TmpColors2.Color4 = ArrayTools.BuildArray(3, function() {
    return new Color4$1(0, 0, 0, 0);
  });
  return TmpColors2;
}();
RegisterClass("BABYLON.Color3", Color3);
RegisterClass("BABYLON.Color4", Color4$1);
var Plane = function() {
  function Plane2(a, b, c, d) {
    this.normal = new Vector3(a, b, c);
    this.d = d;
  }
  Plane2.prototype.asArray = function() {
    return [this.normal.x, this.normal.y, this.normal.z, this.d];
  };
  Plane2.prototype.clone = function() {
    return new Plane2(this.normal.x, this.normal.y, this.normal.z, this.d);
  };
  Plane2.prototype.getClassName = function() {
    return "Plane";
  };
  Plane2.prototype.getHashCode = function() {
    var hash = this.normal.getHashCode();
    hash = hash * 397 ^ (this.d | 0);
    return hash;
  };
  Plane2.prototype.normalize = function() {
    var norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);
    var magnitude = 0;
    if (norm !== 0) {
      magnitude = 1 / norm;
    }
    this.normal.x *= magnitude;
    this.normal.y *= magnitude;
    this.normal.z *= magnitude;
    this.d *= magnitude;
    return this;
  };
  Plane2.prototype.transform = function(transformation) {
    var invertedMatrix = Plane2._TmpMatrix;
    transformation.invertToRef(invertedMatrix);
    var m = invertedMatrix.m;
    var x = this.normal.x;
    var y = this.normal.y;
    var z = this.normal.z;
    var d = this.d;
    var normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];
    var normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];
    var normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];
    var finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];
    return new Plane2(normalX, normalY, normalZ, finalD);
  };
  Plane2.prototype.dotCoordinate = function(point) {
    return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;
  };
  Plane2.prototype.copyFromPoints = function(point1, point2, point3) {
    var x1 = point2.x - point1.x;
    var y1 = point2.y - point1.y;
    var z1 = point2.z - point1.z;
    var x2 = point3.x - point1.x;
    var y2 = point3.y - point1.y;
    var z2 = point3.z - point1.z;
    var yz = y1 * z2 - z1 * y2;
    var xz = z1 * x2 - x1 * z2;
    var xy = x1 * y2 - y1 * x2;
    var pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);
    var invPyth;
    if (pyth !== 0) {
      invPyth = 1 / pyth;
    } else {
      invPyth = 0;
    }
    this.normal.x = yz * invPyth;
    this.normal.y = xz * invPyth;
    this.normal.z = xy * invPyth;
    this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);
    return this;
  };
  Plane2.prototype.isFrontFacingTo = function(direction, epsilon) {
    var dot = Vector3.Dot(this.normal, direction);
    return dot <= epsilon;
  };
  Plane2.prototype.signedDistanceTo = function(point) {
    return Vector3.Dot(point, this.normal) + this.d;
  };
  Plane2.FromArray = function(array) {
    return new Plane2(array[0], array[1], array[2], array[3]);
  };
  Plane2.FromPoints = function(point1, point2, point3) {
    var result = new Plane2(0, 0, 0, 0);
    result.copyFromPoints(point1, point2, point3);
    return result;
  };
  Plane2.FromPositionAndNormal = function(origin, normal) {
    var result = new Plane2(0, 0, 0, 0);
    normal.normalize();
    result.normal = normal;
    result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);
    return result;
  };
  Plane2.SignedDistanceToPlaneFromPositionAndNormal = function(origin, normal, point) {
    var d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);
    return Vector3.Dot(point, normal) + d;
  };
  Plane2._TmpMatrix = Matrix.Identity();
  return Plane2;
}();
var Frustum = function() {
  function Frustum2() {
  }
  Frustum2.GetPlanes = function(transform) {
    var frustumPlanes = [];
    for (var index = 0; index < 6; index++) {
      frustumPlanes.push(new Plane(0, 0, 0, 0));
    }
    Frustum2.GetPlanesToRef(transform, frustumPlanes);
    return frustumPlanes;
  };
  Frustum2.GetNearPlaneToRef = function(transform, frustumPlane) {
    var m = transform.m;
    frustumPlane.normal.x = m[3] + m[2];
    frustumPlane.normal.y = m[7] + m[6];
    frustumPlane.normal.z = m[11] + m[10];
    frustumPlane.d = m[15] + m[14];
    frustumPlane.normalize();
  };
  Frustum2.GetFarPlaneToRef = function(transform, frustumPlane) {
    var m = transform.m;
    frustumPlane.normal.x = m[3] - m[2];
    frustumPlane.normal.y = m[7] - m[6];
    frustumPlane.normal.z = m[11] - m[10];
    frustumPlane.d = m[15] - m[14];
    frustumPlane.normalize();
  };
  Frustum2.GetLeftPlaneToRef = function(transform, frustumPlane) {
    var m = transform.m;
    frustumPlane.normal.x = m[3] + m[0];
    frustumPlane.normal.y = m[7] + m[4];
    frustumPlane.normal.z = m[11] + m[8];
    frustumPlane.d = m[15] + m[12];
    frustumPlane.normalize();
  };
  Frustum2.GetRightPlaneToRef = function(transform, frustumPlane) {
    var m = transform.m;
    frustumPlane.normal.x = m[3] - m[0];
    frustumPlane.normal.y = m[7] - m[4];
    frustumPlane.normal.z = m[11] - m[8];
    frustumPlane.d = m[15] - m[12];
    frustumPlane.normalize();
  };
  Frustum2.GetTopPlaneToRef = function(transform, frustumPlane) {
    var m = transform.m;
    frustumPlane.normal.x = m[3] - m[1];
    frustumPlane.normal.y = m[7] - m[5];
    frustumPlane.normal.z = m[11] - m[9];
    frustumPlane.d = m[15] - m[13];
    frustumPlane.normalize();
  };
  Frustum2.GetBottomPlaneToRef = function(transform, frustumPlane) {
    var m = transform.m;
    frustumPlane.normal.x = m[3] + m[1];
    frustumPlane.normal.y = m[7] + m[5];
    frustumPlane.normal.z = m[11] + m[9];
    frustumPlane.d = m[15] + m[13];
    frustumPlane.normalize();
  };
  Frustum2.GetPlanesToRef = function(transform, frustumPlanes) {
    Frustum2.GetNearPlaneToRef(transform, frustumPlanes[0]);
    Frustum2.GetFarPlaneToRef(transform, frustumPlanes[1]);
    Frustum2.GetLeftPlaneToRef(transform, frustumPlanes[2]);
    Frustum2.GetRightPlaneToRef(transform, frustumPlanes[3]);
    Frustum2.GetTopPlaneToRef(transform, frustumPlanes[4]);
    Frustum2.GetBottomPlaneToRef(transform, frustumPlanes[5]);
  };
  return Frustum2;
}();
var Orientation;
(function(Orientation2) {
  Orientation2[Orientation2["CW"] = 0] = "CW";
  Orientation2[Orientation2["CCW"] = 1] = "CCW";
})(Orientation || (Orientation = {}));
var Size = function() {
  function Size2(width, height) {
    this.width = width;
    this.height = height;
  }
  Size2.prototype.toString = function() {
    return "{W: ".concat(this.width, ", H: ").concat(this.height, "}");
  };
  Size2.prototype.getClassName = function() {
    return "Size";
  };
  Size2.prototype.getHashCode = function() {
    var hash = this.width | 0;
    hash = hash * 397 ^ (this.height | 0);
    return hash;
  };
  Size2.prototype.copyFrom = function(src) {
    this.width = src.width;
    this.height = src.height;
  };
  Size2.prototype.copyFromFloats = function(width, height) {
    this.width = width;
    this.height = height;
    return this;
  };
  Size2.prototype.set = function(width, height) {
    return this.copyFromFloats(width, height);
  };
  Size2.prototype.multiplyByFloats = function(w, h) {
    return new Size2(this.width * w, this.height * h);
  };
  Size2.prototype.clone = function() {
    return new Size2(this.width, this.height);
  };
  Size2.prototype.equals = function(other) {
    if (!other) {
      return false;
    }
    return this.width === other.width && this.height === other.height;
  };
  Object.defineProperty(Size2.prototype, "surface", {
    get: function() {
      return this.width * this.height;
    },
    enumerable: false,
    configurable: true
  });
  Size2.Zero = function() {
    return new Size2(0, 0);
  };
  Size2.prototype.add = function(otherSize) {
    var r = new Size2(this.width + otherSize.width, this.height + otherSize.height);
    return r;
  };
  Size2.prototype.subtract = function(otherSize) {
    var r = new Size2(this.width - otherSize.width, this.height - otherSize.height);
    return r;
  };
  Size2.Lerp = function(start, end, amount) {
    var w = start.width + (end.width - start.width) * amount;
    var h = start.height + (end.height - start.height) * amount;
    return new Size2(w, h);
  };
  return Size2;
}();
var Viewport = function() {
  function Viewport2(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  Viewport2.prototype.toGlobal = function(renderWidth, renderHeight) {
    return new Viewport2(this.x * renderWidth, this.y * renderHeight, this.width * renderWidth, this.height * renderHeight);
  };
  Viewport2.prototype.toGlobalToRef = function(renderWidth, renderHeight, ref) {
    ref.x = this.x * renderWidth;
    ref.y = this.y * renderHeight;
    ref.width = this.width * renderWidth;
    ref.height = this.height * renderHeight;
    return this;
  };
  Viewport2.prototype.clone = function() {
    return new Viewport2(this.x, this.y, this.width, this.height);
  };
  return Viewport2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var EventState = function() {
  function EventState2(mask, skipNextObservers, target, currentTarget) {
    if (skipNextObservers === void 0) {
      skipNextObservers = false;
    }
    this.initialize(mask, skipNextObservers, target, currentTarget);
  }
  EventState2.prototype.initialize = function(mask, skipNextObservers, target, currentTarget) {
    if (skipNextObservers === void 0) {
      skipNextObservers = false;
    }
    this.mask = mask;
    this.skipNextObservers = skipNextObservers;
    this.target = target;
    this.currentTarget = currentTarget;
    return this;
  };
  return EventState2;
}();
var Observer = function() {
  function Observer2(callback, mask, scope) {
    if (scope === void 0) {
      scope = null;
    }
    this.callback = callback;
    this.mask = mask;
    this.scope = scope;
    this._willBeUnregistered = false;
    this.unregisterOnNextCall = false;
  }
  return Observer2;
}();
var Observable = function() {
  function Observable2(onObserverAdded) {
    this._observers = new Array();
    this._eventState = new EventState(0);
    if (onObserverAdded) {
      this._onObserverAdded = onObserverAdded;
    }
  }
  Observable2.FromPromise = function(promise, onErrorObservable) {
    var observable = new Observable2();
    promise.then(function(ret) {
      observable.notifyObservers(ret);
    }).catch(function(err) {
      if (onErrorObservable) {
        onErrorObservable.notifyObservers(err);
      } else {
        throw err;
      }
    });
    return observable;
  };
  Object.defineProperty(Observable2.prototype, "observers", {
    get: function() {
      return this._observers;
    },
    enumerable: false,
    configurable: true
  });
  Observable2.prototype.add = function(callback, mask, insertFirst, scope, unregisterOnFirstCall) {
    if (mask === void 0) {
      mask = -1;
    }
    if (insertFirst === void 0) {
      insertFirst = false;
    }
    if (scope === void 0) {
      scope = null;
    }
    if (unregisterOnFirstCall === void 0) {
      unregisterOnFirstCall = false;
    }
    if (!callback) {
      return null;
    }
    var observer = new Observer(callback, mask, scope);
    observer.unregisterOnNextCall = unregisterOnFirstCall;
    if (insertFirst) {
      this._observers.unshift(observer);
    } else {
      this._observers.push(observer);
    }
    if (this._onObserverAdded) {
      this._onObserverAdded(observer);
    }
    return observer;
  };
  Observable2.prototype.addOnce = function(callback) {
    return this.add(callback, void 0, void 0, void 0, true);
  };
  Observable2.prototype.remove = function(observer) {
    if (!observer) {
      return false;
    }
    var index = this._observers.indexOf(observer);
    if (index !== -1) {
      this._deferUnregister(observer);
      return true;
    }
    return false;
  };
  Observable2.prototype.removeCallback = function(callback, scope) {
    for (var index = 0; index < this._observers.length; index++) {
      var observer = this._observers[index];
      if (observer._willBeUnregistered) {
        continue;
      }
      if (observer.callback === callback && (!scope || scope === observer.scope)) {
        this._deferUnregister(observer);
        return true;
      }
    }
    return false;
  };
  Observable2.prototype._deferUnregister = function(observer) {
    var _this = this;
    observer.unregisterOnNextCall = false;
    observer._willBeUnregistered = true;
    setTimeout(function() {
      _this._remove(observer);
    }, 0);
  };
  Observable2.prototype._remove = function(observer) {
    if (!observer) {
      return false;
    }
    var index = this._observers.indexOf(observer);
    if (index !== -1) {
      this._observers.splice(index, 1);
      return true;
    }
    return false;
  };
  Observable2.prototype.makeObserverTopPriority = function(observer) {
    this._remove(observer);
    this._observers.unshift(observer);
  };
  Observable2.prototype.makeObserverBottomPriority = function(observer) {
    this._remove(observer);
    this._observers.push(observer);
  };
  Observable2.prototype.notifyObservers = function(eventData, mask, target, currentTarget, userInfo) {
    if (mask === void 0) {
      mask = -1;
    }
    if (!this._observers.length) {
      return true;
    }
    var state = this._eventState;
    state.mask = mask;
    state.target = target;
    state.currentTarget = currentTarget;
    state.skipNextObservers = false;
    state.lastReturnValue = eventData;
    state.userInfo = userInfo;
    for (var _i = 0, _a = this._observers; _i < _a.length; _i++) {
      var obs = _a[_i];
      if (obs._willBeUnregistered) {
        continue;
      }
      if (obs.mask & mask) {
        if (obs.scope) {
          state.lastReturnValue = obs.callback.apply(obs.scope, [eventData, state]);
        } else {
          state.lastReturnValue = obs.callback(eventData, state);
        }
        if (obs.unregisterOnNextCall) {
          this._deferUnregister(obs);
        }
      }
      if (state.skipNextObservers) {
        return false;
      }
    }
    return true;
  };
  Observable2.prototype.notifyObserversWithPromise = function(eventData, mask, target, currentTarget, userInfo) {
    var _this = this;
    if (mask === void 0) {
      mask = -1;
    }
    var p = Promise.resolve(eventData);
    if (!this._observers.length) {
      return p;
    }
    var state = this._eventState;
    state.mask = mask;
    state.target = target;
    state.currentTarget = currentTarget;
    state.skipNextObservers = false;
    state.userInfo = userInfo;
    this._observers.forEach(function(obs) {
      if (state.skipNextObservers) {
        return;
      }
      if (obs._willBeUnregistered) {
        return;
      }
      if (obs.mask & mask) {
        if (obs.scope) {
          p = p.then(function(lastReturnedValue) {
            state.lastReturnValue = lastReturnedValue;
            return obs.callback.apply(obs.scope, [eventData, state]);
          });
        } else {
          p = p.then(function(lastReturnedValue) {
            state.lastReturnValue = lastReturnedValue;
            return obs.callback(eventData, state);
          });
        }
        if (obs.unregisterOnNextCall) {
          _this._deferUnregister(obs);
        }
      }
    });
    return p.then(function() {
      return eventData;
    });
  };
  Observable2.prototype.notifyObserver = function(observer, eventData, mask) {
    if (mask === void 0) {
      mask = -1;
    }
    if (observer._willBeUnregistered) {
      return;
    }
    var state = this._eventState;
    state.mask = mask;
    state.skipNextObservers = false;
    observer.callback(eventData, state);
    if (observer.unregisterOnNextCall) {
      this._deferUnregister(observer);
    }
  };
  Observable2.prototype.hasObservers = function() {
    return this._observers.length > 0;
  };
  Observable2.prototype.clear = function() {
    this._observers = new Array();
    this._onObserverAdded = null;
  };
  Observable2.prototype.clone = function() {
    var result = new Observable2();
    result._observers = this._observers.slice(0);
    return result;
  };
  Observable2.prototype.hasSpecificMask = function(mask) {
    if (mask === void 0) {
      mask = -1;
    }
    for (var _i = 0, _a = this._observers; _i < _a.length; _i++) {
      var obs = _a[_i];
      if (obs.mask & mask || obs.mask === mask) {
        return true;
      }
    }
    return false;
  };
  return Observable2;
}();
function IsWindowObjectExist() {
  return typeof window !== "undefined";
}
function IsNavigatorAvailable() {
  return typeof navigator !== "undefined";
}
function IsDocumentAvailable() {
  return typeof document !== "undefined";
}
function GetDOMTextContent(element) {
  var result = "";
  var child = element.firstChild;
  while (child) {
    if (child.nodeType === 3) {
      result += child.textContent;
    }
    child = child.nextSibling;
  }
  return result;
}
var DomManagement = {
  IsWindowObjectExist,
  IsNavigatorAvailable,
  IsDocumentAvailable,
  GetDOMTextContent
};
function _WarnImport(name2) {
  return "".concat(name2, " needs to be imported before as it contains a side-effect required by your code.");
}
var Logger = function() {
  function Logger2() {
  }
  Logger2._CheckLimit = function(message, limit) {
    var entry = Logger2._LogLimitOutputs[message];
    if (!entry) {
      entry = { limit, current: 1 };
      Logger2._LogLimitOutputs[message] = entry;
    } else {
      entry.current++;
    }
    return entry.current <= entry.limit;
  };
  Logger2._GenerateLimitMessage = function(message, messageType) {
    var entry = Logger2._LogLimitOutputs[message];
    if (!entry || !Logger2.MessageLimitReached) {
      return;
    }
    if (entry.current === entry.limit) {
      switch (messageType) {
        case 0:
          Logger2.Log(Logger2.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, "log"));
          break;
        case 1:
          Logger2.Warn(Logger2.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, "warning"));
          break;
        case 2:
          Logger2.Error(Logger2.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, "error"));
          break;
      }
    }
  };
  Logger2._AddLogEntry = function(entry) {
    Logger2._LogCache = entry + Logger2._LogCache;
    if (Logger2.OnNewCacheEntry) {
      Logger2.OnNewCacheEntry(entry);
    }
  };
  Logger2._FormatMessage = function(message) {
    var padStr = function(i) {
      return i < 10 ? "0" + i : "" + i;
    };
    var date = new Date();
    return "[" + padStr(date.getHours()) + ":" + padStr(date.getMinutes()) + ":" + padStr(date.getSeconds()) + "]: " + message;
  };
  Logger2._LogDisabled = function(message, limit) {
  };
  Logger2._LogEnabled = function(message, limit) {
    if (limit !== void 0 && !Logger2._CheckLimit(message, limit)) {
      return;
    }
    var formattedMessage = Logger2._FormatMessage(message);
    console.log("BJS - " + formattedMessage);
    var entry = "<div style='color:white'>" + formattedMessage + "</div><br>";
    Logger2._AddLogEntry(entry);
    Logger2._GenerateLimitMessage(message, 0);
  };
  Logger2._WarnDisabled = function(message, limit) {
  };
  Logger2._WarnEnabled = function(message, limit) {
    if (limit !== void 0 && !Logger2._CheckLimit(message, limit)) {
      return;
    }
    var formattedMessage = Logger2._FormatMessage(message);
    console.warn("BJS - " + formattedMessage);
    var entry = "<div style='color:orange'>" + message + "</div><br>";
    Logger2._AddLogEntry(entry);
    Logger2._GenerateLimitMessage(message, 1);
  };
  Logger2._ErrorDisabled = function(message, limit) {
  };
  Logger2._ErrorEnabled = function(message, limit) {
    if (limit !== void 0 && !Logger2._CheckLimit(message, limit)) {
      return;
    }
    var formattedMessage = Logger2._FormatMessage(message);
    Logger2.errorsCount++;
    console.error("BJS - " + formattedMessage);
    var entry = "<div style='color:red'>" + formattedMessage + "</div><br>";
    Logger2._AddLogEntry(entry);
    Logger2._GenerateLimitMessage(message, 2);
  };
  Object.defineProperty(Logger2, "LogCache", {
    get: function() {
      return Logger2._LogCache;
    },
    enumerable: false,
    configurable: true
  });
  Logger2.ClearLogCache = function() {
    Logger2._LogCache = "";
    Logger2._LogLimitOutputs = {};
    Logger2.errorsCount = 0;
  };
  Object.defineProperty(Logger2, "LogLevels", {
    set: function(level) {
      if ((level & Logger2.MessageLogLevel) === Logger2.MessageLogLevel) {
        Logger2.Log = Logger2._LogEnabled;
      } else {
        Logger2.Log = Logger2._LogDisabled;
      }
      if ((level & Logger2.WarningLogLevel) === Logger2.WarningLogLevel) {
        Logger2.Warn = Logger2._WarnEnabled;
      } else {
        Logger2.Warn = Logger2._WarnDisabled;
      }
      if ((level & Logger2.ErrorLogLevel) === Logger2.ErrorLogLevel) {
        Logger2.Error = Logger2._ErrorEnabled;
      } else {
        Logger2.Error = Logger2._ErrorDisabled;
      }
    },
    enumerable: false,
    configurable: true
  });
  Logger2.NoneLogLevel = 0;
  Logger2.MessageLogLevel = 1;
  Logger2.WarningLogLevel = 2;
  Logger2.ErrorLogLevel = 4;
  Logger2.AllLogLevel = 7;
  Logger2.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.";
  Logger2._LogCache = "";
  Logger2._LogLimitOutputs = {};
  Logger2.errorsCount = 0;
  Logger2.Log = Logger2._LogEnabled;
  Logger2.Warn = Logger2._WarnEnabled;
  Logger2.Error = Logger2._ErrorEnabled;
  return Logger2;
}();
var EndsWith = function(str, suffix) {
  return str.indexOf(suffix, str.length - suffix.length) !== -1;
};
var StartsWith = function(str, suffix) {
  if (!str) {
    return false;
  }
  return str.indexOf(suffix) === 0;
};
var EncodeArrayBufferToBase64 = function(buffer) {
  var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var output = "";
  var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
  var i = 0;
  var bytes = ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : new Uint8Array(buffer);
  while (i < bytes.length) {
    chr1 = bytes[i++];
    chr2 = i < bytes.length ? bytes[i++] : Number.NaN;
    chr3 = i < bytes.length ? bytes[i++] : Number.NaN;
    enc1 = chr1 >> 2;
    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    enc3 = (chr2 & 15) << 2 | chr3 >> 6;
    enc4 = chr3 & 63;
    if (isNaN(chr2)) {
      enc3 = enc4 = 64;
    } else if (isNaN(chr3)) {
      enc4 = 64;
    }
    output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
  }
  return output;
};
var DecodeBase64ToString = function(base64Data) {
  return atob(base64Data);
};
var DecodeBase64ToBinary = function(base64Data) {
  var decodedString = DecodeBase64ToString(base64Data);
  var bufferLength = decodedString.length;
  var bufferView = new Uint8Array(new ArrayBuffer(bufferLength));
  for (var i = 0; i < bufferLength; i++) {
    bufferView[i] = decodedString.charCodeAt(i);
  }
  return bufferView.buffer;
};
var ShaderCodeNode = function() {
  function ShaderCodeNode2() {
    this.children = [];
  }
  ShaderCodeNode2.prototype.isValid = function(preprocessors) {
    return true;
  };
  ShaderCodeNode2.prototype.process = function(preprocessors, options) {
    var result = "";
    if (this.line) {
      var value = this.line;
      var processor = options.processor;
      if (processor) {
        if (processor.lineProcessor) {
          value = processor.lineProcessor(value, options.isFragment, options.processingContext);
        }
        if (processor.attributeProcessor && StartsWith(this.line, "attribute")) {
          value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);
        } else if (processor.varyingProcessor && StartsWith(this.line, "varying")) {
          value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
        } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {
          if (!options.lookForClosingBracketForUniformBuffer) {
            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
          }
        } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {
          if (!options.lookForClosingBracketForUniformBuffer) {
            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);
            options.lookForClosingBracketForUniformBuffer = true;
          }
        } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {
          value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
        } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && StartsWith(this.line, "uniform") && !options.lookForClosingBracketForUniformBuffer) {
          var regex = /uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/;
          if (regex.test(this.line)) {
            if (processor.uniformProcessor) {
              value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
            }
          } else {
            if (processor.uniformBufferProcessor) {
              value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);
              options.lookForClosingBracketForUniformBuffer = true;
            }
          }
        }
        if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf("}") !== -1) {
          options.lookForClosingBracketForUniformBuffer = false;
          if (processor.endOfUniformBufferProcessor) {
            value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);
          }
        }
      }
      result += value + "\r\n";
    }
    this.children.forEach(function(child) {
      result += child.process(preprocessors, options);
    });
    if (this.additionalDefineKey) {
      preprocessors[this.additionalDefineKey] = this.additionalDefineValue || "true";
    }
    return result;
  };
  return ShaderCodeNode2;
}();
var ShaderCodeCursor = function() {
  function ShaderCodeCursor2() {
  }
  Object.defineProperty(ShaderCodeCursor2.prototype, "currentLine", {
    get: function() {
      return this._lines[this.lineIndex];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShaderCodeCursor2.prototype, "canRead", {
    get: function() {
      return this.lineIndex < this._lines.length - 1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShaderCodeCursor2.prototype, "lines", {
    set: function(value) {
      this._lines = [];
      for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
        var line = value_1[_i];
        if (line[0] === "#") {
          this._lines.push(line);
          continue;
        }
        var split = line.split(";");
        for (var index = 0; index < split.length; index++) {
          var subLine = split[index];
          subLine = subLine.trim();
          if (!subLine) {
            continue;
          }
          this._lines.push(subLine + (index !== split.length - 1 ? ";" : ""));
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  return ShaderCodeCursor2;
}();
var ShaderCodeConditionNode = function(_super) {
  __extends(ShaderCodeConditionNode2, _super);
  function ShaderCodeConditionNode2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShaderCodeConditionNode2.prototype.process = function(preprocessors, options) {
    for (var index = 0; index < this.children.length; index++) {
      var node = this.children[index];
      if (node.isValid(preprocessors)) {
        return node.process(preprocessors, options);
      }
    }
    return "";
  };
  return ShaderCodeConditionNode2;
}(ShaderCodeNode);
var ShaderCodeTestNode = function(_super) {
  __extends(ShaderCodeTestNode2, _super);
  function ShaderCodeTestNode2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShaderCodeTestNode2.prototype.isValid = function(preprocessors) {
    return this.testExpression.isTrue(preprocessors);
  };
  return ShaderCodeTestNode2;
}(ShaderCodeNode);
var ShaderDefineExpression = function() {
  function ShaderDefineExpression2() {
  }
  ShaderDefineExpression2.prototype.isTrue = function(preprocessors) {
    return true;
  };
  ShaderDefineExpression2.postfixToInfix = function(postfix) {
    var stack = [];
    for (var _i = 0, postfix_1 = postfix; _i < postfix_1.length; _i++) {
      var c = postfix_1[_i];
      if (ShaderDefineExpression2._OperatorPriority[c] === void 0) {
        stack.push(c);
      } else {
        var v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
        stack.length -= 2;
        stack.push("(".concat(v2).concat(c).concat(v1, ")"));
      }
    }
    return stack[stack.length - 1];
  };
  ShaderDefineExpression2.infixToPostfix = function(infix) {
    var result = [];
    var stackIdx = -1;
    var pushOperand = function() {
      operand = operand.trim();
      if (operand !== "") {
        result.push(operand);
        operand = "";
      }
    };
    var push = function(s) {
      if (stackIdx < ShaderDefineExpression2._Stack.length - 1) {
        ShaderDefineExpression2._Stack[++stackIdx] = s;
      }
    };
    var peek = function() {
      return ShaderDefineExpression2._Stack[stackIdx];
    };
    var pop = function() {
      return stackIdx === -1 ? "!!INVALID EXPRESSION!!" : ShaderDefineExpression2._Stack[stackIdx--];
    };
    var idx = 0, operand = "";
    while (idx < infix.length) {
      var c = infix.charAt(idx), token = idx < infix.length - 1 ? infix.substr(idx, 2) : "";
      if (c === "(") {
        operand = "";
        push(c);
      } else if (c === ")") {
        pushOperand();
        while (stackIdx !== -1 && peek() !== "(") {
          result.push(pop());
        }
        pop();
      } else if (ShaderDefineExpression2._OperatorPriority[token] > 1) {
        pushOperand();
        while (stackIdx !== -1 && ShaderDefineExpression2._OperatorPriority[peek()] >= ShaderDefineExpression2._OperatorPriority[token]) {
          result.push(pop());
        }
        push(token);
        idx++;
      } else {
        operand += c;
      }
      idx++;
    }
    pushOperand();
    while (stackIdx !== -1) {
      if (peek() === "(") {
        pop();
      } else {
        result.push(pop());
      }
    }
    return result;
  };
  ShaderDefineExpression2._OperatorPriority = {
    ")": 0,
    "(": 1,
    "||": 2,
    "&&": 3
  };
  ShaderDefineExpression2._Stack = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
  return ShaderDefineExpression2;
}();
var ShaderDefineIsDefinedOperator = function(_super) {
  __extends(ShaderDefineIsDefinedOperator2, _super);
  function ShaderDefineIsDefinedOperator2(define, not) {
    if (not === void 0) {
      not = false;
    }
    var _this = _super.call(this) || this;
    _this.define = define;
    _this.not = not;
    return _this;
  }
  ShaderDefineIsDefinedOperator2.prototype.isTrue = function(preprocessors) {
    var condition = preprocessors[this.define] !== void 0;
    if (this.not) {
      condition = !condition;
    }
    return condition;
  };
  return ShaderDefineIsDefinedOperator2;
}(ShaderDefineExpression);
var ShaderDefineOrOperator = function(_super) {
  __extends(ShaderDefineOrOperator2, _super);
  function ShaderDefineOrOperator2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShaderDefineOrOperator2.prototype.isTrue = function(preprocessors) {
    return this.leftOperand.isTrue(preprocessors) || this.rightOperand.isTrue(preprocessors);
  };
  return ShaderDefineOrOperator2;
}(ShaderDefineExpression);
var ShaderDefineAndOperator = function(_super) {
  __extends(ShaderDefineAndOperator2, _super);
  function ShaderDefineAndOperator2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShaderDefineAndOperator2.prototype.isTrue = function(preprocessors) {
    return this.leftOperand.isTrue(preprocessors) && this.rightOperand.isTrue(preprocessors);
  };
  return ShaderDefineAndOperator2;
}(ShaderDefineExpression);
var ShaderDefineArithmeticOperator = function(_super) {
  __extends(ShaderDefineArithmeticOperator2, _super);
  function ShaderDefineArithmeticOperator2(define, operand, testValue) {
    var _this = _super.call(this) || this;
    _this.define = define;
    _this.operand = operand;
    _this.testValue = testValue;
    return _this;
  }
  ShaderDefineArithmeticOperator2.prototype.isTrue = function(preprocessors) {
    var value = preprocessors[this.define];
    if (value === void 0) {
      value = this.define;
    }
    var condition = false;
    var left = parseInt(value);
    var right = parseInt(this.testValue);
    switch (this.operand) {
      case ">":
        condition = left > right;
        break;
      case "<":
        condition = left < right;
        break;
      case "<=":
        condition = left <= right;
        break;
      case ">=":
        condition = left >= right;
        break;
      case "==":
        condition = left === right;
        break;
    }
    return condition;
  };
  return ShaderDefineArithmeticOperator2;
}(ShaderDefineExpression);
var ShaderLanguage;
(function(ShaderLanguage2) {
  ShaderLanguage2[ShaderLanguage2["GLSL"] = 0] = "GLSL";
  ShaderLanguage2[ShaderLanguage2["WGSL"] = 1] = "WGSL";
})(ShaderLanguage || (ShaderLanguage = {}));
var regexSE = /defined\s*?\((.+?)\)/g;
var regexSERevert = /defined\s*?\[(.+?)\]/g;
var ShaderProcessor = function() {
  function ShaderProcessor2() {
  }
  ShaderProcessor2.Initialize = function(options) {
    if (options.processor && options.processor.initializeShaders) {
      options.processor.initializeShaders(options.processingContext);
    }
  };
  ShaderProcessor2.Process = function(sourceCode, options, callback, engine) {
    var _this = this;
    var _a;
    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {
      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);
    }
    this._ProcessIncludes(sourceCode, options, function(codeWithIncludes) {
      if (options.processCodeAfterIncludes) {
        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? "fragment" : "vertex", codeWithIncludes);
      }
      var migratedCode = _this._ProcessShaderConversion(codeWithIncludes, options, engine);
      callback(migratedCode);
    });
  };
  ShaderProcessor2.PreProcess = function(sourceCode, options, callback, engine) {
    var _this = this;
    var _a;
    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {
      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);
    }
    this._ProcessIncludes(sourceCode, options, function(codeWithIncludes) {
      if (options.processCodeAfterIncludes) {
        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? "fragment" : "vertex", codeWithIncludes);
      }
      var migratedCode = _this._ApplyPreProcessing(codeWithIncludes, options, engine);
      callback(migratedCode);
    });
  };
  ShaderProcessor2.Finalize = function(vertexCode, fragmentCode, options) {
    if (!options.processor || !options.processor.finalizeShaders) {
      return { vertexCode, fragmentCode };
    }
    return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);
  };
  ShaderProcessor2._ProcessPrecision = function(source, options) {
    var _a;
    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.noPrecision) {
      return source;
    }
    var shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;
    if (source.indexOf("precision highp float") === -1) {
      if (!shouldUseHighPrecisionShader) {
        source = "precision mediump float;\n" + source;
      } else {
        source = "precision highp float;\n" + source;
      }
    } else {
      if (!shouldUseHighPrecisionShader) {
        source = source.replace("precision highp float", "precision mediump float");
      }
    }
    return source;
  };
  ShaderProcessor2._ExtractOperation = function(expression) {
    var regex = /defined\((.+)\)/;
    var match = regex.exec(expression);
    if (match && match.length) {
      return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === "!");
    }
    var operators = ["==", ">=", "<=", "<", ">"];
    var operator = "";
    var indexOperator = 0;
    for (var _i = 0, operators_1 = operators; _i < operators_1.length; _i++) {
      operator = operators_1[_i];
      indexOperator = expression.indexOf(operator);
      if (indexOperator > -1) {
        break;
      }
    }
    if (indexOperator === -1) {
      return new ShaderDefineIsDefinedOperator(expression);
    }
    var define = expression.substring(0, indexOperator).trim();
    var value = expression.substring(indexOperator + operator.length).trim();
    return new ShaderDefineArithmeticOperator(define, operator, value);
  };
  ShaderProcessor2._BuildSubExpression = function(expression) {
    expression = expression.replace(regexSE, "defined[$1]");
    var postfix = ShaderDefineExpression.infixToPostfix(expression);
    var stack = [];
    for (var _i = 0, postfix_1 = postfix; _i < postfix_1.length; _i++) {
      var c = postfix_1[_i];
      if (c !== "||" && c !== "&&") {
        stack.push(c);
      } else if (stack.length >= 2) {
        var v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
        stack.length -= 2;
        var operator = c == "&&" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();
        if (typeof v1 === "string") {
          v1 = v1.replace(regexSERevert, "defined($1)");
        }
        if (typeof v2 === "string") {
          v2 = v2.replace(regexSERevert, "defined($1)");
        }
        operator.leftOperand = typeof v2 === "string" ? this._ExtractOperation(v2) : v2;
        operator.rightOperand = typeof v1 === "string" ? this._ExtractOperation(v1) : v1;
        stack.push(operator);
      }
    }
    var result = stack[stack.length - 1];
    if (typeof result === "string") {
      result = result.replace(regexSERevert, "defined($1)");
    }
    return typeof result === "string" ? this._ExtractOperation(result) : result;
  };
  ShaderProcessor2._BuildExpression = function(line, start) {
    var node = new ShaderCodeTestNode();
    var command = line.substring(0, start);
    var expression = line.substring(start);
    expression = expression.substring(0, (expression.indexOf("//") + 1 || expression.length + 1) - 1).trim();
    if (command === "#ifdef") {
      node.testExpression = new ShaderDefineIsDefinedOperator(expression);
    } else if (command === "#ifndef") {
      node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);
    } else {
      node.testExpression = this._BuildSubExpression(expression);
    }
    return node;
  };
  ShaderProcessor2._MoveCursorWithinIf = function(cursor, rootNode, ifNode) {
    var line = cursor.currentLine;
    while (this._MoveCursor(cursor, ifNode)) {
      line = cursor.currentLine;
      var first5 = line.substring(0, 5).toLowerCase();
      if (first5 === "#else") {
        var elseNode = new ShaderCodeNode();
        rootNode.children.push(elseNode);
        this._MoveCursor(cursor, elseNode);
        return;
      } else if (first5 === "#elif") {
        var elifNode = this._BuildExpression(line, 5);
        rootNode.children.push(elifNode);
        ifNode = elifNode;
      }
    }
  };
  ShaderProcessor2._MoveCursor = function(cursor, rootNode) {
    while (cursor.canRead) {
      cursor.lineIndex++;
      var line = cursor.currentLine;
      var keywords = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;
      var matches = keywords.exec(line);
      if (matches && matches.length) {
        var keyword = matches[0];
        switch (keyword) {
          case "#ifdef": {
            var newRootNode = new ShaderCodeConditionNode();
            rootNode.children.push(newRootNode);
            var ifNode = this._BuildExpression(line, 6);
            newRootNode.children.push(ifNode);
            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
            break;
          }
          case "#else":
          case "#elif":
            return true;
          case "#endif":
            return false;
          case "#ifndef": {
            var newRootNode = new ShaderCodeConditionNode();
            rootNode.children.push(newRootNode);
            var ifNode = this._BuildExpression(line, 7);
            newRootNode.children.push(ifNode);
            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
            break;
          }
          case "#if": {
            var newRootNode = new ShaderCodeConditionNode();
            var ifNode = this._BuildExpression(line, 3);
            rootNode.children.push(newRootNode);
            newRootNode.children.push(ifNode);
            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
            break;
          }
        }
      } else {
        var newNode = new ShaderCodeNode();
        newNode.line = line;
        rootNode.children.push(newNode);
        if (line[0] === "#" && line[1] === "d") {
          var split = line.replace(";", "").split(" ");
          newNode.additionalDefineKey = split[1];
          if (split.length === 3) {
            newNode.additionalDefineValue = split[2];
          }
        }
      }
    }
    return false;
  };
  ShaderProcessor2._EvaluatePreProcessors = function(sourceCode, preprocessors, options) {
    var rootNode = new ShaderCodeNode();
    var cursor = new ShaderCodeCursor();
    cursor.lineIndex = -1;
    cursor.lines = sourceCode.split("\n");
    this._MoveCursor(cursor, rootNode);
    return rootNode.process(preprocessors, options);
  };
  ShaderProcessor2._PreparePreProcessors = function(options, engine) {
    var _a;
    var defines = options.defines;
    var preprocessors = {};
    for (var _i = 0, defines_1 = defines; _i < defines_1.length; _i++) {
      var define = defines_1[_i];
      var keyValue = define.replace("#define", "").replace(";", "").trim();
      var split = keyValue.split(" ");
      preprocessors[split[0]] = split.length > 1 ? split[1] : "";
    }
    if (((_a = options.processor) === null || _a === void 0 ? void 0 : _a.shaderLanguage) === ShaderLanguage.GLSL) {
      preprocessors["GL_ES"] = "true";
    }
    preprocessors["__VERSION__"] = options.version;
    preprocessors[options.platformName] = "true";
    engine._getGlobalDefines(preprocessors);
    return preprocessors;
  };
  ShaderProcessor2._ProcessShaderConversion = function(sourceCode, options, engine) {
    var preparedSourceCode = this._ProcessPrecision(sourceCode, options);
    if (!options.processor) {
      return preparedSourceCode;
    }
    if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf("#version 3") !== -1) {
      return preparedSourceCode.replace("#version 300 es", "");
    }
    var defines = options.defines;
    var preprocessors = this._PreparePreProcessors(options, engine);
    if (options.processor.preProcessor) {
      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);
    }
    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);
    if (options.processor.postProcessor) {
      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);
    }
    if (engine._features.needShaderCodeInlining) {
      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);
    }
    return preparedSourceCode;
  };
  ShaderProcessor2._ApplyPreProcessing = function(sourceCode, options, engine) {
    var _a, _b;
    var preparedSourceCode = sourceCode;
    var defines = options.defines;
    var preprocessors = this._PreparePreProcessors(options, engine);
    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessor) {
      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);
    }
    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);
    if ((_b = options.processor) === null || _b === void 0 ? void 0 : _b.postProcessor) {
      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);
    }
    if (engine._features.needShaderCodeInlining) {
      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);
    }
    return preparedSourceCode;
  };
  ShaderProcessor2._ProcessIncludes = function(sourceCode, options, callback) {
    var _this = this;
    var regexShaderInclude = /#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g;
    var match = regexShaderInclude.exec(sourceCode);
    var returnValue = new String(sourceCode);
    var keepProcessing = false;
    while (match != null) {
      var includeFile = match[1];
      if (includeFile.indexOf("__decl__") !== -1) {
        includeFile = includeFile.replace(/__decl__/, "");
        if (options.supportsUniformBuffers) {
          includeFile = includeFile.replace(/Vertex/, "Ubo");
          includeFile = includeFile.replace(/Fragment/, "Ubo");
        }
        includeFile = includeFile + "Declaration";
      }
      if (options.includesShadersStore[includeFile]) {
        var includeContent = options.includesShadersStore[includeFile];
        if (match[2]) {
          var splits = match[3].split(",");
          for (var index = 0; index < splits.length; index += 2) {
            var source = new RegExp(splits[index], "g");
            var dest = splits[index + 1];
            includeContent = includeContent.replace(source, dest);
          }
        }
        if (match[4]) {
          var indexString = match[5];
          if (indexString.indexOf("..") !== -1) {
            var indexSplits = indexString.split("..");
            var minIndex = parseInt(indexSplits[0]);
            var maxIndex = parseInt(indexSplits[1]);
            var sourceIncludeContent = includeContent.slice(0);
            includeContent = "";
            if (isNaN(maxIndex)) {
              maxIndex = options.indexParameters[indexSplits[1]];
            }
            for (var i = minIndex; i < maxIndex; i++) {
              if (!options.supportsUniformBuffers) {
                sourceIncludeContent = sourceIncludeContent.replace(/light\{X\}.(\w*)/g, function(str, p1) {
                  return p1 + "{X}";
                });
              }
              includeContent += sourceIncludeContent.replace(/\{X\}/g, i.toString()) + "\n";
            }
          } else {
            if (!options.supportsUniformBuffers) {
              includeContent = includeContent.replace(/light\{X\}.(\w*)/g, function(str, p1) {
                return p1 + "{X}";
              });
            }
            includeContent = includeContent.replace(/\{X\}/g, indexString);
          }
        }
        returnValue = returnValue.replace(match[0], includeContent);
        keepProcessing = keepProcessing || includeContent.indexOf("#include<") >= 0 || includeContent.indexOf("#include <") >= 0;
      } else {
        var includeShaderUrl = options.shadersRepository + "ShadersInclude/" + includeFile + ".fx";
        ShaderProcessor2._FileToolsLoadFile(includeShaderUrl, function(fileContent) {
          options.includesShadersStore[includeFile] = fileContent;
          _this._ProcessIncludes(returnValue, options, callback);
        });
        return;
      }
      match = regexShaderInclude.exec(sourceCode);
    }
    if (keepProcessing) {
      this._ProcessIncludes(returnValue.toString(), options, callback);
    } else {
      callback(returnValue);
    }
  };
  ShaderProcessor2._FileToolsLoadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    throw _WarnImport("FileTools");
  };
  return ShaderProcessor2;
}();
var ShaderStore = function() {
  function ShaderStore2() {
  }
  ShaderStore2.GetShadersRepository = function(shaderLanguage) {
    if (shaderLanguage === void 0) {
      shaderLanguage = ShaderLanguage.GLSL;
    }
    return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore2.ShadersRepository : ShaderStore2.ShadersRepositoryWGSL;
  };
  ShaderStore2.GetShadersStore = function(shaderLanguage) {
    if (shaderLanguage === void 0) {
      shaderLanguage = ShaderLanguage.GLSL;
    }
    return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore2.ShadersStore : ShaderStore2.ShadersStoreWGSL;
  };
  ShaderStore2.GetIncludesShadersStore = function(shaderLanguage) {
    if (shaderLanguage === void 0) {
      shaderLanguage = ShaderLanguage.GLSL;
    }
    return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore2.IncludesShadersStore : ShaderStore2.IncludesShadersStoreWGSL;
  };
  ShaderStore2.ShadersRepository = "src/Shaders/";
  ShaderStore2.ShadersStore = {};
  ShaderStore2.IncludesShadersStore = {};
  ShaderStore2.ShadersRepositoryWGSL = "src/ShadersWGSL/";
  ShaderStore2.ShadersStoreWGSL = {};
  ShaderStore2.IncludesShadersStoreWGSL = {};
  return ShaderStore2;
}();
var Effect = function() {
  function Effect2(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, engine, defines, fallbacks, onCompiled, onError, indexParameters, key, shaderLanguage) {
    var _this = this;
    if (samplers === void 0) {
      samplers = null;
    }
    if (defines === void 0) {
      defines = null;
    }
    if (fallbacks === void 0) {
      fallbacks = null;
    }
    if (onCompiled === void 0) {
      onCompiled = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (key === void 0) {
      key = "";
    }
    if (shaderLanguage === void 0) {
      shaderLanguage = ShaderLanguage.GLSL;
    }
    var _a, _b, _c;
    this.name = null;
    this.defines = "";
    this.onCompiled = null;
    this.onError = null;
    this.onBind = null;
    this.uniqueId = 0;
    this.onCompileObservable = new Observable();
    this.onErrorObservable = new Observable();
    this._onBindObservable = null;
    this._wasPreviouslyReady = false;
    this._bonesComputationForcedToCPU = false;
    this._uniformBuffersNames = {};
    this._multiTarget = false;
    this._samplers = {};
    this._isReady = false;
    this._compilationError = "";
    this._allFallbacksProcessed = false;
    this._uniforms = {};
    this._key = "";
    this._fallbacks = null;
    this._vertexSourceCodeOverride = "";
    this._fragmentSourceCodeOverride = "";
    this._transformFeedbackVaryings = null;
    this._pipelineContext = null;
    this._vertexSourceCode = "";
    this._fragmentSourceCode = "";
    this._rawVertexSourceCode = "";
    this._rawFragmentSourceCode = "";
    this.name = baseName;
    this._key = key;
    var processCodeAfterIncludes = void 0;
    var processFinalCode = null;
    if (attributesNamesOrOptions.attributes) {
      var options = attributesNamesOrOptions;
      this._engine = uniformsNamesOrEngine;
      this._attributesNames = options.attributes;
      this._uniformsNames = options.uniformsNames.concat(options.samplers);
      this._samplerList = options.samplers.slice();
      this.defines = options.defines;
      this.onError = options.onError;
      this.onCompiled = options.onCompiled;
      this._fallbacks = options.fallbacks;
      this._indexParameters = options.indexParameters;
      this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;
      this._multiTarget = !!options.multiTarget;
      this._shaderLanguage = (_a = options.shaderLanguage) !== null && _a !== void 0 ? _a : ShaderLanguage.GLSL;
      if (options.uniformBuffersNames) {
        this._uniformBuffersNamesList = options.uniformBuffersNames.slice();
        for (var i = 0; i < options.uniformBuffersNames.length; i++) {
          this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;
        }
      }
      processFinalCode = (_b = options.processFinalCode) !== null && _b !== void 0 ? _b : null;
      processCodeAfterIncludes = (_c = options.processCodeAfterIncludes) !== null && _c !== void 0 ? _c : void 0;
    } else {
      this._engine = engine;
      this.defines = defines == null ? "" : defines;
      this._uniformsNames = uniformsNamesOrEngine.concat(samplers);
      this._samplerList = samplers ? samplers.slice() : [];
      this._attributesNames = attributesNamesOrOptions;
      this._uniformBuffersNamesList = [];
      this._shaderLanguage = shaderLanguage;
      this.onError = onError;
      this.onCompiled = onCompiled;
      this._indexParameters = indexParameters;
      this._fallbacks = fallbacks;
    }
    this._attributeLocationByName = {};
    this.uniqueId = Effect2._uniqueIdSeed++;
    var vertexSource;
    var fragmentSource;
    var hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;
    if (baseName.vertexSource) {
      vertexSource = "source:" + baseName.vertexSource;
    } else if (baseName.vertexElement) {
      vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;
      if (!vertexSource) {
        vertexSource = baseName.vertexElement;
      }
    } else {
      vertexSource = baseName.vertex || baseName;
    }
    if (baseName.fragmentSource) {
      fragmentSource = "source:" + baseName.fragmentSource;
    } else if (baseName.fragmentElement) {
      fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;
      if (!fragmentSource) {
        fragmentSource = baseName.fragmentElement;
      }
    } else {
      fragmentSource = baseName.fragment || baseName;
    }
    this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);
    var processorOptions = {
      defines: this.defines.split("\n"),
      indexParameters: this._indexParameters,
      isFragment: false,
      shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
      processor: this._engine._getShaderProcessor(this._shaderLanguage),
      supportsUniformBuffers: this._engine.supportsUniformBuffers,
      shadersRepository: ShaderStore.GetShadersRepository(this._shaderLanguage),
      includesShadersStore: ShaderStore.GetIncludesShadersStore(this._shaderLanguage),
      version: (this._engine.version * 100).toString(),
      platformName: this._engine.shaderPlatformName,
      processingContext: this._processingContext,
      isNDCHalfZRange: this._engine.isNDCHalfZRange,
      useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
      processCodeAfterIncludes
    };
    var shaderCodes = [void 0, void 0];
    var shadersLoaded = function() {
      if (shaderCodes[0] && shaderCodes[1]) {
        processorOptions.isFragment = true;
        var migratedVertexCode_1 = shaderCodes[0], fragmentCode = shaderCodes[1];
        ShaderProcessor.Process(fragmentCode, processorOptions, function(migratedFragmentCode) {
          if (processFinalCode) {
            migratedFragmentCode = processFinalCode("fragment", migratedFragmentCode);
          }
          var finalShaders = ShaderProcessor.Finalize(migratedVertexCode_1, migratedFragmentCode, processorOptions);
          _this._useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName);
        }, _this._engine);
      }
    };
    this._loadShader(vertexSource, "Vertex", "", function(vertexCode) {
      ShaderProcessor.Initialize(processorOptions);
      ShaderProcessor.Process(vertexCode, processorOptions, function(migratedVertexCode) {
        _this._rawVertexSourceCode = vertexCode;
        if (processFinalCode) {
          migratedVertexCode = processFinalCode("vertex", migratedVertexCode);
        }
        shaderCodes[0] = migratedVertexCode;
        shadersLoaded();
      }, _this._engine);
    });
    this._loadShader(fragmentSource, "Fragment", "Pixel", function(fragmentCode) {
      _this._rawFragmentSourceCode = fragmentCode;
      shaderCodes[1] = fragmentCode;
      shadersLoaded();
    });
  }
  Object.defineProperty(Effect2, "ShadersRepository", {
    get: function() {
      return ShaderStore.ShadersRepository;
    },
    set: function(repo) {
      ShaderStore.ShadersRepository = repo;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Effect2.prototype, "onBindObservable", {
    get: function() {
      if (!this._onBindObservable) {
        this._onBindObservable = new Observable();
      }
      return this._onBindObservable;
    },
    enumerable: false,
    configurable: true
  });
  Effect2.prototype._useFinalCode = function(migratedVertexCode, migratedFragmentCode, baseName) {
    if (baseName) {
      var vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;
      var fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;
      this._vertexSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? "//" : "") + "#define SHADER_NAME vertex:" + vertex + "\n" + migratedVertexCode;
      this._fragmentSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? "//" : "") + "#define SHADER_NAME fragment:" + fragment + "\n" + migratedFragmentCode;
    } else {
      this._vertexSourceCode = migratedVertexCode;
      this._fragmentSourceCode = migratedFragmentCode;
    }
    this._prepareEffect();
  };
  Object.defineProperty(Effect2.prototype, "key", {
    get: function() {
      return this._key;
    },
    enumerable: false,
    configurable: true
  });
  Effect2.prototype.isReady = function() {
    try {
      return this._isReadyInternal();
    } catch (_a) {
      return false;
    }
  };
  Effect2.prototype._isReadyInternal = function() {
    if (this._isReady) {
      return true;
    }
    if (this._pipelineContext) {
      return this._pipelineContext.isReady;
    }
    return false;
  };
  Effect2.prototype.getEngine = function() {
    return this._engine;
  };
  Effect2.prototype.getPipelineContext = function() {
    return this._pipelineContext;
  };
  Effect2.prototype.getAttributesNames = function() {
    return this._attributesNames;
  };
  Effect2.prototype.getAttributeLocation = function(index) {
    return this._attributes[index];
  };
  Effect2.prototype.getAttributeLocationByName = function(name2) {
    return this._attributeLocationByName[name2];
  };
  Effect2.prototype.getAttributesCount = function() {
    return this._attributes.length;
  };
  Effect2.prototype.getUniformIndex = function(uniformName) {
    return this._uniformsNames.indexOf(uniformName);
  };
  Effect2.prototype.getUniform = function(uniformName) {
    return this._uniforms[uniformName];
  };
  Effect2.prototype.getSamplers = function() {
    return this._samplerList;
  };
  Effect2.prototype.getUniformNames = function() {
    return this._uniformsNames;
  };
  Effect2.prototype.getUniformBuffersNames = function() {
    return this._uniformBuffersNamesList;
  };
  Effect2.prototype.getIndexParameters = function() {
    return this._indexParameters;
  };
  Effect2.prototype.getCompilationError = function() {
    return this._compilationError;
  };
  Effect2.prototype.allFallbacksProcessed = function() {
    return this._allFallbacksProcessed;
  };
  Effect2.prototype.executeWhenCompiled = function(func) {
    var _this = this;
    if (this.isReady()) {
      func(this);
      return;
    }
    this.onCompileObservable.add(function(effect) {
      func(effect);
    });
    if (!this._pipelineContext || this._pipelineContext.isAsync) {
      setTimeout(function() {
        _this._checkIsReady(null);
      }, 16);
    }
  };
  Effect2.prototype._checkIsReady = function(previousPipelineContext) {
    var _this = this;
    try {
      if (this._isReadyInternal()) {
        return;
      }
    } catch (e) {
      this._processCompilationErrors(e, previousPipelineContext);
      return;
    }
    setTimeout(function() {
      _this._checkIsReady(previousPipelineContext);
    }, 16);
  };
  Effect2.prototype._loadShader = function(shader2, key, optionalKey, callback) {
    if (typeof HTMLElement !== "undefined") {
      if (shader2 instanceof HTMLElement) {
        var shaderCode = GetDOMTextContent(shader2);
        callback(shaderCode);
        return;
      }
    }
    if (shader2.substr(0, 7) === "source:") {
      callback(shader2.substr(7));
      return;
    }
    if (shader2.substr(0, 7) === "base64:") {
      var shaderBinary = window.atob(shader2.substr(7));
      callback(shaderBinary);
      return;
    }
    var shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);
    if (shaderStore[shader2 + key + "Shader"]) {
      callback(shaderStore[shader2 + key + "Shader"]);
      return;
    }
    if (optionalKey && shaderStore[shader2 + optionalKey + "Shader"]) {
      callback(shaderStore[shader2 + optionalKey + "Shader"]);
      return;
    }
    var shaderUrl;
    if (shader2[0] === "." || shader2[0] === "/" || shader2.indexOf("http") > -1) {
      shaderUrl = shader2;
    } else {
      shaderUrl = ShaderStore.GetShadersRepository(this._shaderLanguage) + shader2;
    }
    this._engine._loadFile(shaderUrl + "." + key.toLowerCase() + ".fx", callback);
  };
  Object.defineProperty(Effect2.prototype, "vertexSourceCode", {
    get: function() {
      var _a, _b;
      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getVertexShaderCode()) !== null && _b !== void 0 ? _b : this._vertexSourceCode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Effect2.prototype, "fragmentSourceCode", {
    get: function() {
      var _a, _b;
      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getFragmentShaderCode()) !== null && _b !== void 0 ? _b : this._fragmentSourceCode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Effect2.prototype, "rawVertexSourceCode", {
    get: function() {
      return this._rawVertexSourceCode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Effect2.prototype, "rawFragmentSourceCode", {
    get: function() {
      return this._rawFragmentSourceCode;
    },
    enumerable: false,
    configurable: true
  });
  Effect2.prototype._rebuildProgram = function(vertexSourceCode, fragmentSourceCode, onCompiled, onError) {
    var _this = this;
    this._isReady = false;
    this._vertexSourceCodeOverride = vertexSourceCode;
    this._fragmentSourceCodeOverride = fragmentSourceCode;
    this.onError = function(effect, error) {
      if (onError) {
        onError(error);
      }
    };
    this.onCompiled = function() {
      var scenes = _this.getEngine().scenes;
      if (scenes) {
        for (var i = 0; i < scenes.length; i++) {
          scenes[i].markAllMaterialsAsDirty(63);
        }
      }
      _this._pipelineContext._handlesSpectorRebuildCallback(onCompiled);
    };
    this._fallbacks = null;
    this._prepareEffect();
  };
  Effect2.prototype._prepareEffect = function() {
    var _this = this;
    var attributesNames = this._attributesNames;
    var defines = this.defines;
    var previousPipelineContext = this._pipelineContext;
    this._isReady = false;
    try {
      var engine_1 = this._engine;
      this._pipelineContext = engine_1.createPipelineContext(this._processingContext);
      this._pipelineContext._name = this._key;
      var rebuildRebind = this._rebuildProgram.bind(this);
      if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {
        engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, true, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, null, this._transformFeedbackVaryings, this._key);
      } else {
        engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, false, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, defines, this._transformFeedbackVaryings, this._key);
      }
      engine_1._executeWhenRenderingStateIsCompiled(this._pipelineContext, function() {
        _this._attributes = [];
        _this._pipelineContext._fillEffectInformation(_this, _this._uniformBuffersNames, _this._uniformsNames, _this._uniforms, _this._samplerList, _this._samplers, attributesNames, _this._attributes);
        if (attributesNames) {
          for (var i = 0; i < attributesNames.length; i++) {
            var name_1 = attributesNames[i];
            _this._attributeLocationByName[name_1] = _this._attributes[i];
          }
        }
        engine_1.bindSamplers(_this);
        _this._compilationError = "";
        _this._isReady = true;
        if (_this.onCompiled) {
          _this.onCompiled(_this);
        }
        _this.onCompileObservable.notifyObservers(_this);
        _this.onCompileObservable.clear();
        if (_this._fallbacks) {
          _this._fallbacks.unBindMesh();
        }
        if (previousPipelineContext) {
          _this.getEngine()._deletePipelineContext(previousPipelineContext);
        }
      });
      if (this._pipelineContext.isAsync) {
        this._checkIsReady(previousPipelineContext);
      }
    } catch (e) {
      this._processCompilationErrors(e, previousPipelineContext);
    }
  };
  Effect2.prototype._getShaderCodeAndErrorLine = function(code, error, isFragment) {
    var regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\d+?):/ : /VERTEX SHADER ERROR: 0:(\d+?):/;
    var errorLine = null;
    if (error && code) {
      var res = error.match(regexp);
      if (res && res.length === 2) {
        var lineNumber = parseInt(res[1]);
        var lines = code.split("\n", -1);
        if (lines.length >= lineNumber) {
          errorLine = "Offending line [".concat(lineNumber, "] in ").concat(isFragment ? "fragment" : "vertex", " code: ").concat(lines[lineNumber - 1]);
        }
      }
    }
    return [code, errorLine];
  };
  Effect2.prototype._processCompilationErrors = function(e, previousPipelineContext) {
    var _a, _b;
    var _c, _d, _e;
    if (previousPipelineContext === void 0) {
      previousPipelineContext = null;
    }
    this._compilationError = e.message;
    var attributesNames = this._attributesNames;
    var fallbacks = this._fallbacks;
    Logger.Error("Unable to compile effect:");
    Logger.Error("Uniforms: " + this._uniformsNames.map(function(uniform) {
      return " " + uniform;
    }));
    Logger.Error("Attributes: " + attributesNames.map(function(attribute) {
      return " " + attribute;
    }));
    Logger.Error("Defines:\r\n" + this.defines);
    if (Effect2.LogShaderCodeOnCompilationError) {
      var lineErrorVertex = null, lineErrorFragment = null, code = null;
      if ((_c = this._pipelineContext) === null || _c === void 0 ? void 0 : _c._getVertexShaderCode()) {
        _a = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false), code = _a[0], lineErrorVertex = _a[1];
        if (code) {
          Logger.Error("Vertex code:");
          Logger.Error(code);
        }
      }
      if ((_d = this._pipelineContext) === null || _d === void 0 ? void 0 : _d._getFragmentShaderCode()) {
        _b = this._getShaderCodeAndErrorLine((_e = this._pipelineContext) === null || _e === void 0 ? void 0 : _e._getFragmentShaderCode(), this._compilationError, true), code = _b[0], lineErrorFragment = _b[1];
        if (code) {
          Logger.Error("Fragment code:");
          Logger.Error(code);
        }
      }
      if (lineErrorVertex) {
        Logger.Error(lineErrorVertex);
      }
      if (lineErrorFragment) {
        Logger.Error(lineErrorFragment);
      }
    }
    Logger.Error("Error: " + this._compilationError);
    if (previousPipelineContext) {
      this._pipelineContext = previousPipelineContext;
      this._isReady = true;
      if (this.onError) {
        this.onError(this, this._compilationError);
      }
      this.onErrorObservable.notifyObservers(this);
    }
    if (fallbacks) {
      this._pipelineContext = null;
      if (fallbacks.hasMoreFallbacks) {
        this._allFallbacksProcessed = false;
        Logger.Error("Trying next fallback.");
        this.defines = fallbacks.reduce(this.defines, this);
        this._prepareEffect();
      } else {
        this._allFallbacksProcessed = true;
        if (this.onError) {
          this.onError(this, this._compilationError);
        }
        this.onErrorObservable.notifyObservers(this);
        this.onErrorObservable.clear();
        if (this._fallbacks) {
          this._fallbacks.unBindMesh();
        }
      }
    } else {
      this._allFallbacksProcessed = true;
    }
  };
  Object.defineProperty(Effect2.prototype, "isSupported", {
    get: function() {
      return this._compilationError === "";
    },
    enumerable: false,
    configurable: true
  });
  Effect2.prototype._bindTexture = function(channel, texture) {
    this._engine._bindTexture(this._samplers[channel], texture, channel);
  };
  Effect2.prototype.setTexture = function(channel, texture) {
    this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
  };
  Effect2.prototype.setDepthStencilTexture = function(channel, texture) {
    this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
  };
  Effect2.prototype.setTextureArray = function(channel, textures) {
    var exName = channel + "Ex";
    if (this._samplerList.indexOf(exName + "0") === -1) {
      var initialPos = this._samplerList.indexOf(channel);
      for (var index = 1; index < textures.length; index++) {
        var currentExName = exName + (index - 1).toString();
        this._samplerList.splice(initialPos + index, 0, currentExName);
      }
      var channelIndex = 0;
      for (var _i = 0, _a = this._samplerList; _i < _a.length; _i++) {
        var key = _a[_i];
        this._samplers[key] = channelIndex;
        channelIndex += 1;
      }
    }
    this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);
  };
  Effect2.prototype.setTextureFromPostProcess = function(channel, postProcess) {
    this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);
  };
  Effect2.prototype.setTextureFromPostProcessOutput = function(channel, postProcess) {
    this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);
  };
  Effect2.prototype.bindUniformBuffer = function(buffer, name2) {
    var bufferName = this._uniformBuffersNames[name2];
    if (bufferName === void 0 || Effect2._baseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache) {
      return;
    }
    Effect2._baseCache[bufferName] = buffer;
    this._engine.bindUniformBufferBase(buffer, bufferName, name2);
  };
  Effect2.prototype.bindUniformBlock = function(blockName, index) {
    this._engine.bindUniformBlock(this._pipelineContext, blockName, index);
  };
  Effect2.prototype.setInt = function(uniformName, value) {
    this._pipelineContext.setInt(uniformName, value);
    return this;
  };
  Effect2.prototype.setInt2 = function(uniformName, x, y) {
    this._pipelineContext.setInt2(uniformName, x, y);
    return this;
  };
  Effect2.prototype.setInt3 = function(uniformName, x, y, z) {
    this._pipelineContext.setInt3(uniformName, x, y, z);
    return this;
  };
  Effect2.prototype.setInt4 = function(uniformName, x, y, z, w) {
    this._pipelineContext.setInt4(uniformName, x, y, z, w);
    return this;
  };
  Effect2.prototype.setIntArray = function(uniformName, array) {
    this._pipelineContext.setIntArray(uniformName, array);
    return this;
  };
  Effect2.prototype.setIntArray2 = function(uniformName, array) {
    this._pipelineContext.setIntArray2(uniformName, array);
    return this;
  };
  Effect2.prototype.setIntArray3 = function(uniformName, array) {
    this._pipelineContext.setIntArray3(uniformName, array);
    return this;
  };
  Effect2.prototype.setIntArray4 = function(uniformName, array) {
    this._pipelineContext.setIntArray4(uniformName, array);
    return this;
  };
  Effect2.prototype.setFloatArray = function(uniformName, array) {
    this._pipelineContext.setArray(uniformName, array);
    return this;
  };
  Effect2.prototype.setFloatArray2 = function(uniformName, array) {
    this._pipelineContext.setArray2(uniformName, array);
    return this;
  };
  Effect2.prototype.setFloatArray3 = function(uniformName, array) {
    this._pipelineContext.setArray3(uniformName, array);
    return this;
  };
  Effect2.prototype.setFloatArray4 = function(uniformName, array) {
    this._pipelineContext.setArray4(uniformName, array);
    return this;
  };
  Effect2.prototype.setArray = function(uniformName, array) {
    this._pipelineContext.setArray(uniformName, array);
    return this;
  };
  Effect2.prototype.setArray2 = function(uniformName, array) {
    this._pipelineContext.setArray2(uniformName, array);
    return this;
  };
  Effect2.prototype.setArray3 = function(uniformName, array) {
    this._pipelineContext.setArray3(uniformName, array);
    return this;
  };
  Effect2.prototype.setArray4 = function(uniformName, array) {
    this._pipelineContext.setArray4(uniformName, array);
    return this;
  };
  Effect2.prototype.setMatrices = function(uniformName, matrices) {
    this._pipelineContext.setMatrices(uniformName, matrices);
    return this;
  };
  Effect2.prototype.setMatrix = function(uniformName, matrix) {
    this._pipelineContext.setMatrix(uniformName, matrix);
    return this;
  };
  Effect2.prototype.setMatrix3x3 = function(uniformName, matrix) {
    this._pipelineContext.setMatrix3x3(uniformName, matrix);
    return this;
  };
  Effect2.prototype.setMatrix2x2 = function(uniformName, matrix) {
    this._pipelineContext.setMatrix2x2(uniformName, matrix);
    return this;
  };
  Effect2.prototype.setFloat = function(uniformName, value) {
    this._pipelineContext.setFloat(uniformName, value);
    return this;
  };
  Effect2.prototype.setBool = function(uniformName, bool) {
    this._pipelineContext.setInt(uniformName, bool ? 1 : 0);
    return this;
  };
  Effect2.prototype.setVector2 = function(uniformName, vector2) {
    this._pipelineContext.setVector2(uniformName, vector2);
    return this;
  };
  Effect2.prototype.setFloat2 = function(uniformName, x, y) {
    this._pipelineContext.setFloat2(uniformName, x, y);
    return this;
  };
  Effect2.prototype.setVector3 = function(uniformName, vector3) {
    this._pipelineContext.setVector3(uniformName, vector3);
    return this;
  };
  Effect2.prototype.setFloat3 = function(uniformName, x, y, z) {
    this._pipelineContext.setFloat3(uniformName, x, y, z);
    return this;
  };
  Effect2.prototype.setVector4 = function(uniformName, vector4) {
    this._pipelineContext.setVector4(uniformName, vector4);
    return this;
  };
  Effect2.prototype.setFloat4 = function(uniformName, x, y, z, w) {
    this._pipelineContext.setFloat4(uniformName, x, y, z, w);
    return this;
  };
  Effect2.prototype.setColor3 = function(uniformName, color3) {
    this._pipelineContext.setColor3(uniformName, color3);
    return this;
  };
  Effect2.prototype.setColor4 = function(uniformName, color3, alpha) {
    this._pipelineContext.setColor4(uniformName, color3, alpha);
    return this;
  };
  Effect2.prototype.setDirectColor4 = function(uniformName, color4) {
    this._pipelineContext.setDirectColor4(uniformName, color4);
    return this;
  };
  Effect2.prototype.dispose = function() {
    if (this._pipelineContext) {
      this._pipelineContext.dispose();
    }
    this._engine._releaseEffect(this);
  };
  Effect2.RegisterShader = function(name2, pixelShader, vertexShader, shaderLanguage) {
    if (shaderLanguage === void 0) {
      shaderLanguage = ShaderLanguage.GLSL;
    }
    if (pixelShader) {
      ShaderStore.GetShadersStore(shaderLanguage)["".concat(name2, "PixelShader")] = pixelShader;
    }
    if (vertexShader) {
      ShaderStore.GetShadersStore(shaderLanguage)["".concat(name2, "VertexShader")] = vertexShader;
    }
  };
  Effect2.ResetCache = function() {
    Effect2._baseCache = {};
  };
  Effect2.LogShaderCodeOnCompilationError = true;
  Effect2._uniqueIdSeed = 0;
  Effect2._baseCache = {};
  Effect2.ShadersStore = ShaderStore.ShadersStore;
  Effect2.IncludesShadersStore = ShaderStore.IncludesShadersStore;
  return Effect2;
}();
var DepthCullingState = function() {
  function DepthCullingState2(reset) {
    if (reset === void 0) {
      reset = true;
    }
    this._isDepthTestDirty = false;
    this._isDepthMaskDirty = false;
    this._isDepthFuncDirty = false;
    this._isCullFaceDirty = false;
    this._isCullDirty = false;
    this._isZOffsetDirty = false;
    this._isFrontFaceDirty = false;
    if (reset) {
      this.reset();
    }
  }
  Object.defineProperty(DepthCullingState2.prototype, "isDirty", {
    get: function() {
      return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "zOffset", {
    get: function() {
      return this._zOffset;
    },
    set: function(value) {
      if (this._zOffset === value) {
        return;
      }
      this._zOffset = value;
      this._isZOffsetDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "zOffsetUnits", {
    get: function() {
      return this._zOffsetUnits;
    },
    set: function(value) {
      if (this._zOffsetUnits === value) {
        return;
      }
      this._zOffsetUnits = value;
      this._isZOffsetDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "cullFace", {
    get: function() {
      return this._cullFace;
    },
    set: function(value) {
      if (this._cullFace === value) {
        return;
      }
      this._cullFace = value;
      this._isCullFaceDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "cull", {
    get: function() {
      return this._cull;
    },
    set: function(value) {
      if (this._cull === value) {
        return;
      }
      this._cull = value;
      this._isCullDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "depthFunc", {
    get: function() {
      return this._depthFunc;
    },
    set: function(value) {
      if (this._depthFunc === value) {
        return;
      }
      this._depthFunc = value;
      this._isDepthFuncDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "depthMask", {
    get: function() {
      return this._depthMask;
    },
    set: function(value) {
      if (this._depthMask === value) {
        return;
      }
      this._depthMask = value;
      this._isDepthMaskDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "depthTest", {
    get: function() {
      return this._depthTest;
    },
    set: function(value) {
      if (this._depthTest === value) {
        return;
      }
      this._depthTest = value;
      this._isDepthTestDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "frontFace", {
    get: function() {
      return this._frontFace;
    },
    set: function(value) {
      if (this._frontFace === value) {
        return;
      }
      this._frontFace = value;
      this._isFrontFaceDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  DepthCullingState2.prototype.reset = function() {
    this._depthMask = true;
    this._depthTest = true;
    this._depthFunc = null;
    this._cullFace = null;
    this._cull = null;
    this._zOffset = 0;
    this._zOffsetUnits = 0;
    this._frontFace = null;
    this._isDepthTestDirty = true;
    this._isDepthMaskDirty = true;
    this._isDepthFuncDirty = false;
    this._isCullFaceDirty = false;
    this._isCullDirty = false;
    this._isZOffsetDirty = true;
    this._isFrontFaceDirty = false;
  };
  DepthCullingState2.prototype.apply = function(gl) {
    if (!this.isDirty) {
      return;
    }
    if (this._isCullDirty) {
      if (this.cull) {
        gl.enable(gl.CULL_FACE);
      } else {
        gl.disable(gl.CULL_FACE);
      }
      this._isCullDirty = false;
    }
    if (this._isCullFaceDirty) {
      gl.cullFace(this.cullFace);
      this._isCullFaceDirty = false;
    }
    if (this._isDepthMaskDirty) {
      gl.depthMask(this.depthMask);
      this._isDepthMaskDirty = false;
    }
    if (this._isDepthTestDirty) {
      if (this.depthTest) {
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }
      this._isDepthTestDirty = false;
    }
    if (this._isDepthFuncDirty) {
      gl.depthFunc(this.depthFunc);
      this._isDepthFuncDirty = false;
    }
    if (this._isZOffsetDirty) {
      if (this.zOffset || this.zOffsetUnits) {
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(this.zOffset, this.zOffsetUnits);
      } else {
        gl.disable(gl.POLYGON_OFFSET_FILL);
      }
      this._isZOffsetDirty = false;
    }
    if (this._isFrontFaceDirty) {
      gl.frontFace(this.frontFace);
      this._isFrontFaceDirty = false;
    }
  };
  return DepthCullingState2;
}();
var StencilState = function() {
  function StencilState2() {
    this.reset();
  }
  StencilState2.prototype.reset = function() {
    this.enabled = false;
    this.mask = 255;
    this.func = StencilState2.ALWAYS;
    this.funcRef = 1;
    this.funcMask = 255;
    this.opStencilFail = StencilState2.KEEP;
    this.opDepthFail = StencilState2.KEEP;
    this.opStencilDepthPass = StencilState2.REPLACE;
  };
  Object.defineProperty(StencilState2.prototype, "stencilFunc", {
    get: function() {
      return this.func;
    },
    set: function(value) {
      this.func = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilFuncRef", {
    get: function() {
      return this.funcRef;
    },
    set: function(value) {
      this.funcRef = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilFuncMask", {
    get: function() {
      return this.funcMask;
    },
    set: function(value) {
      this.funcMask = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilOpStencilFail", {
    get: function() {
      return this.opStencilFail;
    },
    set: function(value) {
      this.opStencilFail = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilOpDepthFail", {
    get: function() {
      return this.opDepthFail;
    },
    set: function(value) {
      this.opDepthFail = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilOpStencilDepthPass", {
    get: function() {
      return this.opStencilDepthPass;
    },
    set: function(value) {
      this.opStencilDepthPass = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilMask", {
    get: function() {
      return this.mask;
    },
    set: function(value) {
      this.mask = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilTest", {
    get: function() {
      return this.enabled;
    },
    set: function(value) {
      this.enabled = value;
    },
    enumerable: false,
    configurable: true
  });
  StencilState2.ALWAYS = 519;
  StencilState2.KEEP = 7680;
  StencilState2.REPLACE = 7681;
  return StencilState2;
}();
var AlphaState = function() {
  function AlphaState2() {
    this._blendFunctionParameters = new Array(4);
    this._blendEquationParameters = new Array(2);
    this._blendConstants = new Array(4);
    this._isBlendConstantsDirty = false;
    this._alphaBlend = false;
    this._isAlphaBlendDirty = false;
    this._isBlendFunctionParametersDirty = false;
    this._isBlendEquationParametersDirty = false;
    this.reset();
  }
  Object.defineProperty(AlphaState2.prototype, "isDirty", {
    get: function() {
      return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AlphaState2.prototype, "alphaBlend", {
    get: function() {
      return this._alphaBlend;
    },
    set: function(value) {
      if (this._alphaBlend === value) {
        return;
      }
      this._alphaBlend = value;
      this._isAlphaBlendDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  AlphaState2.prototype.setAlphaBlendConstants = function(r, g, b, a) {
    if (this._blendConstants[0] === r && this._blendConstants[1] === g && this._blendConstants[2] === b && this._blendConstants[3] === a) {
      return;
    }
    this._blendConstants[0] = r;
    this._blendConstants[1] = g;
    this._blendConstants[2] = b;
    this._blendConstants[3] = a;
    this._isBlendConstantsDirty = true;
  };
  AlphaState2.prototype.setAlphaBlendFunctionParameters = function(value0, value1, value2, value3) {
    if (this._blendFunctionParameters[0] === value0 && this._blendFunctionParameters[1] === value1 && this._blendFunctionParameters[2] === value2 && this._blendFunctionParameters[3] === value3) {
      return;
    }
    this._blendFunctionParameters[0] = value0;
    this._blendFunctionParameters[1] = value1;
    this._blendFunctionParameters[2] = value2;
    this._blendFunctionParameters[3] = value3;
    this._isBlendFunctionParametersDirty = true;
  };
  AlphaState2.prototype.setAlphaEquationParameters = function(rgb, alpha) {
    if (this._blendEquationParameters[0] === rgb && this._blendEquationParameters[1] === alpha) {
      return;
    }
    this._blendEquationParameters[0] = rgb;
    this._blendEquationParameters[1] = alpha;
    this._isBlendEquationParametersDirty = true;
  };
  AlphaState2.prototype.reset = function() {
    this._alphaBlend = false;
    this._blendFunctionParameters[0] = null;
    this._blendFunctionParameters[1] = null;
    this._blendFunctionParameters[2] = null;
    this._blendFunctionParameters[3] = null;
    this._blendEquationParameters[0] = null;
    this._blendEquationParameters[1] = null;
    this._blendConstants[0] = null;
    this._blendConstants[1] = null;
    this._blendConstants[2] = null;
    this._blendConstants[3] = null;
    this._isAlphaBlendDirty = true;
    this._isBlendFunctionParametersDirty = false;
    this._isBlendEquationParametersDirty = false;
    this._isBlendConstantsDirty = false;
  };
  AlphaState2.prototype.apply = function(gl) {
    if (!this.isDirty) {
      return;
    }
    if (this._isAlphaBlendDirty) {
      if (this._alphaBlend) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      this._isAlphaBlendDirty = false;
    }
    if (this._isBlendFunctionParametersDirty) {
      gl.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]);
      this._isBlendFunctionParametersDirty = false;
    }
    if (this._isBlendEquationParametersDirty) {
      gl.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]);
      this._isBlendEquationParametersDirty = false;
    }
    if (this._isBlendConstantsDirty) {
      gl.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]);
      this._isBlendConstantsDirty = false;
    }
  };
  return AlphaState2;
}();
var TextureSampler = function() {
  function TextureSampler2() {
    this.samplingMode = -1;
    this._useMipMaps = true;
    this._cachedWrapU = null;
    this._cachedWrapV = null;
    this._cachedWrapR = null;
    this._cachedAnisotropicFilteringLevel = null;
    this._comparisonFunction = 0;
  }
  Object.defineProperty(TextureSampler2.prototype, "wrapU", {
    get: function() {
      return this._cachedWrapU;
    },
    set: function(value) {
      this._cachedWrapU = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureSampler2.prototype, "wrapV", {
    get: function() {
      return this._cachedWrapV;
    },
    set: function(value) {
      this._cachedWrapV = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureSampler2.prototype, "wrapR", {
    get: function() {
      return this._cachedWrapR;
    },
    set: function(value) {
      this._cachedWrapR = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureSampler2.prototype, "anisotropicFilteringLevel", {
    get: function() {
      return this._cachedAnisotropicFilteringLevel;
    },
    set: function(value) {
      this._cachedAnisotropicFilteringLevel = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureSampler2.prototype, "comparisonFunction", {
    get: function() {
      return this._comparisonFunction;
    },
    set: function(value) {
      this._comparisonFunction = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureSampler2.prototype, "useMipMaps", {
    get: function() {
      return this._useMipMaps;
    },
    set: function(value) {
      this._useMipMaps = value;
    },
    enumerable: false,
    configurable: true
  });
  TextureSampler2.prototype.setParameters = function(wrapU, wrapV, wrapR, anisotropicFilteringLevel, samplingMode, comparisonFunction) {
    if (wrapU === void 0) {
      wrapU = 1;
    }
    if (wrapV === void 0) {
      wrapV = 1;
    }
    if (wrapR === void 0) {
      wrapR = 1;
    }
    if (anisotropicFilteringLevel === void 0) {
      anisotropicFilteringLevel = 1;
    }
    if (samplingMode === void 0) {
      samplingMode = 2;
    }
    if (comparisonFunction === void 0) {
      comparisonFunction = 0;
    }
    this._cachedWrapU = wrapU;
    this._cachedWrapV = wrapV;
    this._cachedWrapR = wrapR;
    this._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
    this.samplingMode = samplingMode;
    this._comparisonFunction = comparisonFunction;
    return this;
  };
  TextureSampler2.prototype.compareSampler = function(other) {
    return this._cachedWrapU === other._cachedWrapU && this._cachedWrapV === other._cachedWrapV && this._cachedWrapR === other._cachedWrapR && this._cachedAnisotropicFilteringLevel === other._cachedAnisotropicFilteringLevel && this.samplingMode === other.samplingMode && this._comparisonFunction === other._comparisonFunction && this._useMipMaps === other._useMipMaps;
  };
  return TextureSampler2;
}();
var InternalTextureSource;
(function(InternalTextureSource2) {
  InternalTextureSource2[InternalTextureSource2["Unknown"] = 0] = "Unknown";
  InternalTextureSource2[InternalTextureSource2["Url"] = 1] = "Url";
  InternalTextureSource2[InternalTextureSource2["Temp"] = 2] = "Temp";
  InternalTextureSource2[InternalTextureSource2["Raw"] = 3] = "Raw";
  InternalTextureSource2[InternalTextureSource2["Dynamic"] = 4] = "Dynamic";
  InternalTextureSource2[InternalTextureSource2["RenderTarget"] = 5] = "RenderTarget";
  InternalTextureSource2[InternalTextureSource2["MultiRenderTarget"] = 6] = "MultiRenderTarget";
  InternalTextureSource2[InternalTextureSource2["Cube"] = 7] = "Cube";
  InternalTextureSource2[InternalTextureSource2["CubeRaw"] = 8] = "CubeRaw";
  InternalTextureSource2[InternalTextureSource2["CubePrefiltered"] = 9] = "CubePrefiltered";
  InternalTextureSource2[InternalTextureSource2["Raw3D"] = 10] = "Raw3D";
  InternalTextureSource2[InternalTextureSource2["Raw2DArray"] = 11] = "Raw2DArray";
  InternalTextureSource2[InternalTextureSource2["DepthStencil"] = 12] = "DepthStencil";
  InternalTextureSource2[InternalTextureSource2["CubeRawRGBD"] = 13] = "CubeRawRGBD";
  InternalTextureSource2[InternalTextureSource2["Depth"] = 14] = "Depth";
})(InternalTextureSource || (InternalTextureSource = {}));
var InternalTexture = function(_super) {
  __extends(InternalTexture2, _super);
  function InternalTexture2(engine, source, delayAllocation) {
    if (delayAllocation === void 0) {
      delayAllocation = false;
    }
    var _this = _super.call(this) || this;
    _this.isReady = false;
    _this.isCube = false;
    _this.is3D = false;
    _this.is2DArray = false;
    _this.isMultiview = false;
    _this.url = "";
    _this.generateMipMaps = false;
    _this.samples = 0;
    _this.type = -1;
    _this.format = -1;
    _this.onLoadedObservable = new Observable();
    _this.onErrorObservable = new Observable();
    _this.onRebuildCallback = null;
    _this.width = 0;
    _this.height = 0;
    _this.depth = 0;
    _this.baseWidth = 0;
    _this.baseHeight = 0;
    _this.baseDepth = 0;
    _this.invertY = false;
    _this._invertVScale = false;
    _this._associatedChannel = -1;
    _this._source = InternalTextureSource.Unknown;
    _this._buffer = null;
    _this._bufferView = null;
    _this._bufferViewArray = null;
    _this._bufferViewArrayArray = null;
    _this._size = 0;
    _this._extension = "";
    _this._files = null;
    _this._workingCanvas = null;
    _this._workingContext = null;
    _this._cachedCoordinatesMode = null;
    _this._isDisabled = false;
    _this._compression = null;
    _this._sphericalPolynomial = null;
    _this._sphericalPolynomialPromise = null;
    _this._sphericalPolynomialComputed = false;
    _this._lodGenerationScale = 0;
    _this._lodGenerationOffset = 0;
    _this._useSRGBBuffer = false;
    _this._lodTextureHigh = null;
    _this._lodTextureMid = null;
    _this._lodTextureLow = null;
    _this._isRGBD = false;
    _this._linearSpecularLOD = false;
    _this._irradianceTexture = null;
    _this._hardwareTexture = null;
    _this._maxLodLevel = null;
    _this._references = 1;
    _this._gammaSpace = null;
    _this._engine = engine;
    _this._source = source;
    _this._uniqueId = InternalTexture2._Counter++;
    if (!delayAllocation) {
      _this._hardwareTexture = engine._createHardwareTexture();
    }
    return _this;
  }
  Object.defineProperty(InternalTexture2.prototype, "useMipMaps", {
    get: function() {
      return this.generateMipMaps;
    },
    set: function(value) {
      this.generateMipMaps = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InternalTexture2.prototype, "uniqueId", {
    get: function() {
      return this._uniqueId;
    },
    enumerable: false,
    configurable: true
  });
  InternalTexture2.prototype.getEngine = function() {
    return this._engine;
  };
  Object.defineProperty(InternalTexture2.prototype, "source", {
    get: function() {
      return this._source;
    },
    enumerable: false,
    configurable: true
  });
  InternalTexture2.prototype.incrementReferences = function() {
    this._references++;
  };
  InternalTexture2.prototype.updateSize = function(width, height, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    this._engine.updateTextureDimensions(this, width, height, depth);
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.baseWidth = width;
    this.baseHeight = height;
    this.baseDepth = depth;
    this._size = width * height * depth;
  };
  InternalTexture2.prototype._rebuild = function() {
    var _this = this;
    var _a;
    this.isReady = false;
    this._cachedCoordinatesMode = null;
    this._cachedWrapU = null;
    this._cachedWrapV = null;
    this._cachedWrapR = null;
    this._cachedAnisotropicFilteringLevel = null;
    if (this.onRebuildCallback) {
      var data_1 = this.onRebuildCallback(this);
      var swapAndSetIsReady = function(proxyInternalTexture) {
        proxyInternalTexture._swapAndDie(_this, false);
        _this.isReady = data_1.isReady;
      };
      if (data_1.isAsync) {
        data_1.proxy.then(swapAndSetIsReady);
      } else {
        swapAndSetIsReady(data_1.proxy);
      }
      return;
    }
    var proxy;
    switch (this.source) {
      case InternalTextureSource.Temp:
        break;
      case InternalTextureSource.Url:
        proxy = this._engine.createTexture((_a = this._originalUrl) !== null && _a !== void 0 ? _a : this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, function() {
          proxy._swapAndDie(_this, false);
          _this.isReady = true;
        }, null, this._buffer, void 0, this.format, this._extension, void 0, void 0, void 0, this._useSRGBBuffer);
        return;
      case InternalTextureSource.Raw:
        proxy = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.Raw3D:
        proxy = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.Raw2DArray:
        proxy = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.Dynamic:
        proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);
        proxy._swapAndDie(this, false);
        this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas(), this.invertY, void 0, void 0, true);
        break;
      case InternalTextureSource.Cube:
        proxy = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, function() {
          proxy._swapAndDie(_this, false);
          _this.isReady = true;
        }, null, this.format, this._extension, false, 0, 0, null, void 0, this._useSRGBBuffer);
        return;
      case InternalTextureSource.CubeRaw:
        proxy = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.CubeRawRGBD:
        return;
      case InternalTextureSource.CubePrefiltered:
        proxy = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, function(proxy2) {
          if (proxy2) {
            proxy2._swapAndDie(_this, false);
          }
          _this.isReady = true;
        }, null, this.format, this._extension);
        proxy._sphericalPolynomial = this._sphericalPolynomial;
        return;
    }
  };
  InternalTexture2.prototype._swapAndDie = function(target, swapAll) {
    var _a;
    if (swapAll === void 0) {
      swapAll = true;
    }
    (_a = this._hardwareTexture) === null || _a === void 0 ? void 0 : _a.setUsage(target._source, this.generateMipMaps, this.isCube, this.width, this.height);
    target._hardwareTexture = this._hardwareTexture;
    if (swapAll) {
      target._isRGBD = this._isRGBD;
    }
    if (this._lodTextureHigh) {
      if (target._lodTextureHigh) {
        target._lodTextureHigh.dispose();
      }
      target._lodTextureHigh = this._lodTextureHigh;
    }
    if (this._lodTextureMid) {
      if (target._lodTextureMid) {
        target._lodTextureMid.dispose();
      }
      target._lodTextureMid = this._lodTextureMid;
    }
    if (this._lodTextureLow) {
      if (target._lodTextureLow) {
        target._lodTextureLow.dispose();
      }
      target._lodTextureLow = this._lodTextureLow;
    }
    if (this._irradianceTexture) {
      if (target._irradianceTexture) {
        target._irradianceTexture.dispose();
      }
      target._irradianceTexture = this._irradianceTexture;
    }
    var cache = this._engine.getLoadedTexturesCache();
    var index = cache.indexOf(this);
    if (index !== -1) {
      cache.splice(index, 1);
    }
    var index = cache.indexOf(target);
    if (index === -1) {
      cache.push(target);
    }
  };
  InternalTexture2.prototype.dispose = function() {
    this._references--;
    this.onLoadedObservable.clear();
    this.onErrorObservable.clear();
    if (this._references === 0) {
      this._engine._releaseTexture(this);
      this._hardwareTexture = null;
    }
  };
  InternalTexture2._Counter = 0;
  return InternalTexture2;
}(TextureSampler);
var WebGLShaderProcessor = function() {
  function WebGLShaderProcessor2() {
    this.shaderLanguage = ShaderLanguage.GLSL;
  }
  WebGLShaderProcessor2.prototype.postProcessor = function(code, defines, isFragment, processingContext, engine) {
    if (!engine.getCaps().drawBuffersExtension) {
      var regex = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;
      code = code.replace(regex, "");
    }
    return code;
  };
  return WebGLShaderProcessor2;
}();
var WebGL2ShaderProcessor = function() {
  function WebGL2ShaderProcessor2() {
    this.shaderLanguage = ShaderLanguage.GLSL;
  }
  WebGL2ShaderProcessor2.prototype.attributeProcessor = function(attribute) {
    return attribute.replace("attribute", "in");
  };
  WebGL2ShaderProcessor2.prototype.varyingProcessor = function(varying, isFragment) {
    return varying.replace("varying", isFragment ? "in" : "out");
  };
  WebGL2ShaderProcessor2.prototype.postProcessor = function(code, defines, isFragment, processingContext, engine) {
    var hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;
    var regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
    code = code.replace(regex, "");
    code = code.replace(/texture2D\s*\(/g, "texture(");
    if (isFragment) {
      code = code.replace(/texture2DLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCubeLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCube\s*\(/g, "texture(");
      code = code.replace(/gl_FragDepthEXT/g, "gl_FragDepth");
      code = code.replace(/gl_FragColor/g, "glFragColor");
      code = code.replace(/gl_FragData/g, "glFragData");
      code = code.replace(/void\s+?main\s*\(/g, (hasDrawBuffersExtension ? "" : "out vec4 glFragColor;\n") + "void main(");
    } else {
      var hasMultiviewExtension = defines.indexOf("#define MULTIVIEW") !== -1;
      if (hasMultiviewExtension) {
        return "#extension GL_OVR_multiview2 : require\nlayout (num_views = 2) in;\n" + code;
      }
    }
    return code;
  };
  return WebGL2ShaderProcessor2;
}();
var DataBuffer = function() {
  function DataBuffer2() {
    this.references = 0;
    this.capacity = 0;
    this.is32Bits = false;
    this.uniqueId = DataBuffer2._Counter++;
  }
  Object.defineProperty(DataBuffer2.prototype, "underlyingResource", {
    get: function() {
      return null;
    },
    enumerable: false,
    configurable: true
  });
  DataBuffer2._Counter = 0;
  return DataBuffer2;
}();
var WebGLDataBuffer = function(_super) {
  __extends(WebGLDataBuffer2, _super);
  function WebGLDataBuffer2(resource) {
    var _this = _super.call(this) || this;
    _this._buffer = resource;
    return _this;
  }
  Object.defineProperty(WebGLDataBuffer2.prototype, "underlyingResource", {
    get: function() {
      return this._buffer;
    },
    enumerable: false,
    configurable: true
  });
  return WebGLDataBuffer2;
}(DataBuffer);
var WebGLPipelineContext = function() {
  function WebGLPipelineContext2() {
    this._valueCache = {};
    this.vertexCompilationError = null;
    this.fragmentCompilationError = null;
    this.programLinkError = null;
    this.programValidationError = null;
  }
  Object.defineProperty(WebGLPipelineContext2.prototype, "isAsync", {
    get: function() {
      return this.isParallelCompiled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebGLPipelineContext2.prototype, "isReady", {
    get: function() {
      if (this.program) {
        if (this.isParallelCompiled) {
          return this.engine._isRenderingStateCompiled(this);
        }
        return true;
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  WebGLPipelineContext2.prototype._handlesSpectorRebuildCallback = function(onCompiled) {
    if (onCompiled && this.program) {
      onCompiled(this.program);
    }
  };
  WebGLPipelineContext2.prototype._fillEffectInformation = function(effect, uniformBuffersNames, uniformsNames, uniforms, samplerList, samplers, attributesNames, attributes) {
    var engine = this.engine;
    if (engine.supportsUniformBuffers) {
      for (var name2 in uniformBuffersNames) {
        effect.bindUniformBlock(name2, uniformBuffersNames[name2]);
      }
    }
    var effectAvailableUniforms = this.engine.getUniforms(this, uniformsNames);
    effectAvailableUniforms.forEach(function(uniform, index2) {
      uniforms[uniformsNames[index2]] = uniform;
    });
    this._uniforms = uniforms;
    var index;
    for (index = 0; index < samplerList.length; index++) {
      var sampler = effect.getUniform(samplerList[index]);
      if (sampler == null) {
        samplerList.splice(index, 1);
        index--;
      }
    }
    samplerList.forEach(function(name3, index2) {
      samplers[name3] = index2;
    });
    for (var _i = 0, _a = engine.getAttributes(this, attributesNames); _i < _a.length; _i++) {
      var attr = _a[_i];
      attributes.push(attr);
    }
  };
  WebGLPipelineContext2.prototype.dispose = function() {
    this._uniforms = {};
  };
  WebGLPipelineContext2.prototype._cacheMatrix = function(uniformName, matrix) {
    var cache = this._valueCache[uniformName];
    var flag = matrix.updateFlag;
    if (cache !== void 0 && cache === flag) {
      return false;
    }
    this._valueCache[uniformName] = flag;
    return true;
  };
  WebGLPipelineContext2.prototype._cacheFloat2 = function(uniformName, x, y) {
    var cache = this._valueCache[uniformName];
    if (!cache || cache.length !== 2) {
      cache = [x, y];
      this._valueCache[uniformName] = cache;
      return true;
    }
    var changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    return changed;
  };
  WebGLPipelineContext2.prototype._cacheFloat3 = function(uniformName, x, y, z) {
    var cache = this._valueCache[uniformName];
    if (!cache || cache.length !== 3) {
      cache = [x, y, z];
      this._valueCache[uniformName] = cache;
      return true;
    }
    var changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    if (cache[2] !== z) {
      cache[2] = z;
      changed = true;
    }
    return changed;
  };
  WebGLPipelineContext2.prototype._cacheFloat4 = function(uniformName, x, y, z, w) {
    var cache = this._valueCache[uniformName];
    if (!cache || cache.length !== 4) {
      cache = [x, y, z, w];
      this._valueCache[uniformName] = cache;
      return true;
    }
    var changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    if (cache[2] !== z) {
      cache[2] = z;
      changed = true;
    }
    if (cache[3] !== w) {
      cache[3] = w;
      changed = true;
    }
    return changed;
  };
  WebGLPipelineContext2.prototype.setInt = function(uniformName, value) {
    var cache = this._valueCache[uniformName];
    if (cache !== void 0 && cache === value) {
      return;
    }
    if (this.engine.setInt(this._uniforms[uniformName], value)) {
      this._valueCache[uniformName] = value;
    }
  };
  WebGLPipelineContext2.prototype.setInt2 = function(uniformName, x, y) {
    if (this._cacheFloat2(uniformName, x, y)) {
      if (!this.engine.setInt2(this._uniforms[uniformName], x, y)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setInt3 = function(uniformName, x, y, z) {
    if (this._cacheFloat3(uniformName, x, y, z)) {
      if (!this.engine.setInt3(this._uniforms[uniformName], x, y, z)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setInt4 = function(uniformName, x, y, z, w) {
    if (this._cacheFloat4(uniformName, x, y, z, w)) {
      if (!this.engine.setInt4(this._uniforms[uniformName], x, y, z, w)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setIntArray = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setIntArray(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setIntArray2 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setIntArray2(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setIntArray3 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setIntArray3(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setIntArray4 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setIntArray4(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setArray = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setArray(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setArray2 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setArray2(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setArray3 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setArray3(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setArray4 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setArray4(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setMatrices = function(uniformName, matrices) {
    if (!matrices) {
      return;
    }
    this._valueCache[uniformName] = null;
    this.engine.setMatrices(this._uniforms[uniformName], matrices);
  };
  WebGLPipelineContext2.prototype.setMatrix = function(uniformName, matrix) {
    if (this._cacheMatrix(uniformName, matrix)) {
      if (!this.engine.setMatrices(this._uniforms[uniformName], matrix.toArray())) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setMatrix3x3 = function(uniformName, matrix) {
    this._valueCache[uniformName] = null;
    this.engine.setMatrix3x3(this._uniforms[uniformName], matrix);
  };
  WebGLPipelineContext2.prototype.setMatrix2x2 = function(uniformName, matrix) {
    this._valueCache[uniformName] = null;
    this.engine.setMatrix2x2(this._uniforms[uniformName], matrix);
  };
  WebGLPipelineContext2.prototype.setFloat = function(uniformName, value) {
    var cache = this._valueCache[uniformName];
    if (cache !== void 0 && cache === value) {
      return;
    }
    if (this.engine.setFloat(this._uniforms[uniformName], value)) {
      this._valueCache[uniformName] = value;
    }
  };
  WebGLPipelineContext2.prototype.setVector2 = function(uniformName, vector2) {
    if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {
      if (!this.engine.setFloat2(this._uniforms[uniformName], vector2.x, vector2.y)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setFloat2 = function(uniformName, x, y) {
    if (this._cacheFloat2(uniformName, x, y)) {
      if (!this.engine.setFloat2(this._uniforms[uniformName], x, y)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setVector3 = function(uniformName, vector3) {
    if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {
      if (!this.engine.setFloat3(this._uniforms[uniformName], vector3.x, vector3.y, vector3.z)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setFloat3 = function(uniformName, x, y, z) {
    if (this._cacheFloat3(uniformName, x, y, z)) {
      if (!this.engine.setFloat3(this._uniforms[uniformName], x, y, z)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setVector4 = function(uniformName, vector4) {
    if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], vector4.x, vector4.y, vector4.z, vector4.w)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setFloat4 = function(uniformName, x, y, z, w) {
    if (this._cacheFloat4(uniformName, x, y, z, w)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], x, y, z, w)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setColor3 = function(uniformName, color3) {
    if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {
      if (!this.engine.setFloat3(this._uniforms[uniformName], color3.r, color3.g, color3.b)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setColor4 = function(uniformName, color3, alpha) {
    if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], color3.r, color3.g, color3.b, alpha)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setDirectColor4 = function(uniformName, color4) {
    if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], color4.r, color4.g, color4.b, color4.a)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype._getVertexShaderCode = function() {
    return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null;
  };
  WebGLPipelineContext2.prototype._getFragmentShaderCode = function() {
    return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null;
  };
  return WebGLPipelineContext2;
}();
var WebGLHardwareTexture = function() {
  function WebGLHardwareTexture2(existingTexture, context) {
    if (existingTexture === void 0) {
      existingTexture = null;
    }
    this._MSAARenderBuffer = null;
    this._context = context;
    if (!existingTexture) {
      existingTexture = context.createTexture();
      if (!existingTexture) {
        throw new Error("Unable to create webGL texture");
      }
    }
    this.set(existingTexture);
  }
  Object.defineProperty(WebGLHardwareTexture2.prototype, "underlyingResource", {
    get: function() {
      return this._webGLTexture;
    },
    enumerable: false,
    configurable: true
  });
  WebGLHardwareTexture2.prototype.setUsage = function(textureSource, generateMipMaps, isCube, width, height) {
  };
  WebGLHardwareTexture2.prototype.set = function(hardwareTexture) {
    this._webGLTexture = hardwareTexture;
  };
  WebGLHardwareTexture2.prototype.reset = function() {
    this._webGLTexture = null;
    this._MSAARenderBuffer = null;
  };
  WebGLHardwareTexture2.prototype.release = function() {
    if (this._MSAARenderBuffer) {
      this._context.deleteRenderbuffer(this._MSAARenderBuffer);
      this._MSAARenderBuffer = null;
    }
    if (this._webGLTexture) {
      this._context.deleteTexture(this._webGLTexture);
    }
    this.reset();
  };
  return WebGLHardwareTexture2;
}();
var DrawWrapper = function() {
  function DrawWrapper2(engine, createMaterialContext) {
    if (createMaterialContext === void 0) {
      createMaterialContext = true;
    }
    this.effect = null;
    this.defines = null;
    this.drawContext = engine.createDrawContext();
    if (createMaterialContext) {
      this.materialContext = engine.createMaterialContext();
    }
  }
  DrawWrapper2.IsWrapper = function(effect) {
    return effect.getPipelineContext === void 0;
  };
  DrawWrapper2.GetEffect = function(effect) {
    return effect.getPipelineContext === void 0 ? effect.effect : effect;
  };
  DrawWrapper2.prototype.setEffect = function(effect, defines, resetContext) {
    var _a;
    if (resetContext === void 0) {
      resetContext = true;
    }
    this.effect = effect;
    if (defines !== void 0) {
      this.defines = defines;
    }
    if (resetContext) {
      (_a = this.drawContext) === null || _a === void 0 ? void 0 : _a.reset();
    }
  };
  DrawWrapper2.prototype.dispose = function() {
    var _a;
    (_a = this.drawContext) === null || _a === void 0 ? void 0 : _a.dispose();
  };
  return DrawWrapper2;
}();
var StencilStateComposer = function() {
  function StencilStateComposer2(reset) {
    if (reset === void 0) {
      reset = true;
    }
    this._isStencilTestDirty = false;
    this._isStencilMaskDirty = false;
    this._isStencilFuncDirty = false;
    this._isStencilOpDirty = false;
    this.useStencilGlobalOnly = false;
    if (reset) {
      this.reset();
    }
  }
  Object.defineProperty(StencilStateComposer2.prototype, "isDirty", {
    get: function() {
      return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "func", {
    get: function() {
      return this._func;
    },
    set: function(value) {
      if (this._func === value) {
        return;
      }
      this._func = value;
      this._isStencilFuncDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "funcRef", {
    get: function() {
      return this._funcRef;
    },
    set: function(value) {
      if (this._funcRef === value) {
        return;
      }
      this._funcRef = value;
      this._isStencilFuncDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "funcMask", {
    get: function() {
      return this._funcMask;
    },
    set: function(value) {
      if (this._funcMask === value) {
        return;
      }
      this._funcMask = value;
      this._isStencilFuncDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "opStencilFail", {
    get: function() {
      return this._opStencilFail;
    },
    set: function(value) {
      if (this._opStencilFail === value) {
        return;
      }
      this._opStencilFail = value;
      this._isStencilOpDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "opDepthFail", {
    get: function() {
      return this._opDepthFail;
    },
    set: function(value) {
      if (this._opDepthFail === value) {
        return;
      }
      this._opDepthFail = value;
      this._isStencilOpDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "opStencilDepthPass", {
    get: function() {
      return this._opStencilDepthPass;
    },
    set: function(value) {
      if (this._opStencilDepthPass === value) {
        return;
      }
      this._opStencilDepthPass = value;
      this._isStencilOpDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "mask", {
    get: function() {
      return this._mask;
    },
    set: function(value) {
      if (this._mask === value) {
        return;
      }
      this._mask = value;
      this._isStencilMaskDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "enabled", {
    get: function() {
      return this._enabled;
    },
    set: function(value) {
      if (this._enabled === value) {
        return;
      }
      this._enabled = value;
      this._isStencilTestDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  StencilStateComposer2.prototype.reset = function() {
    var _a;
    this.stencilMaterial = void 0;
    (_a = this.stencilGlobal) === null || _a === void 0 ? void 0 : _a.reset();
    this._isStencilTestDirty = true;
    this._isStencilMaskDirty = true;
    this._isStencilFuncDirty = true;
    this._isStencilOpDirty = true;
  };
  StencilStateComposer2.prototype.apply = function(gl) {
    var _a;
    if (!gl) {
      return;
    }
    var stencilMaterialEnabled = !this.useStencilGlobalOnly && !!((_a = this.stencilMaterial) === null || _a === void 0 ? void 0 : _a.enabled);
    this.enabled = stencilMaterialEnabled ? this.stencilMaterial.enabled : this.stencilGlobal.enabled;
    this.func = stencilMaterialEnabled ? this.stencilMaterial.func : this.stencilGlobal.func;
    this.funcRef = stencilMaterialEnabled ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef;
    this.funcMask = stencilMaterialEnabled ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask;
    this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail;
    this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail;
    this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;
    this.mask = stencilMaterialEnabled ? this.stencilMaterial.mask : this.stencilGlobal.mask;
    if (!this.isDirty) {
      return;
    }
    if (this._isStencilTestDirty) {
      if (this.enabled) {
        gl.enable(gl.STENCIL_TEST);
      } else {
        gl.disable(gl.STENCIL_TEST);
      }
      this._isStencilTestDirty = false;
    }
    if (this._isStencilMaskDirty) {
      gl.stencilMask(this.mask);
      this._isStencilMaskDirty = false;
    }
    if (this._isStencilFuncDirty) {
      gl.stencilFunc(this.func, this.funcRef, this.funcMask);
      this._isStencilFuncDirty = false;
    }
    if (this._isStencilOpDirty) {
      gl.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass);
      this._isStencilOpDirty = false;
    }
  };
  return StencilStateComposer2;
}();
var BufferPointer = function() {
  function BufferPointer2() {
  }
  return BufferPointer2;
}();
var ThinEngine = function() {
  function ThinEngine2(canvasOrContext, antialias, options, adaptToDeviceRatio) {
    var _this = this;
    this._name = "WebGL";
    this.forcePOTTextures = false;
    this.isFullscreen = false;
    this.cullBackFaces = null;
    this.renderEvenInBackground = true;
    this.preventCacheWipeBetweenFrames = false;
    this.validateShaderPrograms = false;
    this._useReverseDepthBuffer = false;
    this.isNDCHalfZRange = false;
    this.hasOriginBottomLeft = true;
    this.disableUniformBuffers = false;
    this.onDisposeObservable = new Observable();
    this._frameId = 0;
    this._uniformBuffers = new Array();
    this._storageBuffers = new Array();
    this._webGLVersion = 1;
    this._windowIsBackground = false;
    this._highPrecisionShadersAllowed = true;
    this._badOS = false;
    this._badDesktopOS = false;
    this._renderingQueueLaunched = false;
    this._activeRenderLoops = new Array();
    this.onContextLostObservable = new Observable();
    this.onContextRestoredObservable = new Observable();
    this._contextWasLost = false;
    this._doNotHandleContextLost = false;
    this.disableVertexArrayObjects = false;
    this._colorWrite = true;
    this._colorWriteChanged = true;
    this._depthCullingState = new DepthCullingState();
    this._stencilStateComposer = new StencilStateComposer();
    this._stencilState = new StencilState();
    this._alphaState = new AlphaState();
    this._alphaMode = 1;
    this._alphaEquation = 0;
    this._internalTexturesCache = new Array();
    this._renderTargetWrapperCache = new Array();
    this._activeChannel = 0;
    this._currentTextureChannel = -1;
    this._boundTexturesCache = {};
    this._compiledEffects = {};
    this._vertexAttribArraysEnabled = [];
    this._uintIndicesCurrentlySet = false;
    this._currentBoundBuffer = new Array();
    this._currentFramebuffer = null;
    this._dummyFramebuffer = null;
    this._currentBufferPointers = new Array();
    this._currentInstanceLocations = new Array();
    this._currentInstanceBuffers = new Array();
    this._vaoRecordInProgress = false;
    this._mustWipeVertexAttributes = false;
    this._nextFreeTextureSlots = new Array();
    this._maxSimultaneousTextures = 0;
    this._activeRequests = new Array();
    this._adaptToDeviceRatio = false;
    this._transformTextureUrl = null;
    this.hostInformation = {
      isMobile: false
    };
    this.premultipliedAlpha = true;
    this.onBeforeTextureInitObservable = new Observable();
    this._isWebGPU = false;
    this._snapshotRenderingMode = 0;
    this._viewportCached = { x: 0, y: 0, z: 0, w: 0 };
    this._unpackFlipYCached = null;
    this.enableUnpackFlipYCached = true;
    this._boundUniforms = {};
    var canvas = null;
    options = options || {};
    this._creationOptions = options;
    this._adaptToDeviceRatio = adaptToDeviceRatio !== null && adaptToDeviceRatio !== void 0 ? adaptToDeviceRatio : false;
    this._stencilStateComposer.stencilGlobal = this._stencilState;
    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);
    if (!canvasOrContext) {
      return;
    }
    adaptToDeviceRatio = adaptToDeviceRatio || options.adaptToDeviceRatio || false;
    if (canvasOrContext.getContext) {
      canvas = canvasOrContext;
      this._renderingCanvas = canvas;
      if (antialias !== void 0) {
        options.antialias = antialias;
      }
      if (options.deterministicLockstep === void 0) {
        options.deterministicLockstep = false;
      }
      if (options.lockstepMaxSteps === void 0) {
        options.lockstepMaxSteps = 4;
      }
      if (options.timeStep === void 0) {
        options.timeStep = 1 / 60;
      }
      if (options.preserveDrawingBuffer === void 0) {
        options.preserveDrawingBuffer = false;
      }
      if (options.audioEngine === void 0) {
        options.audioEngine = true;
      }
      if (options.audioEngineOptions !== void 0 && options.audioEngineOptions.audioContext !== void 0) {
        this._audioContext = options.audioEngineOptions.audioContext;
      }
      if (options.audioEngineOptions !== void 0 && options.audioEngineOptions.audioDestination !== void 0) {
        this._audioDestination = options.audioEngineOptions.audioDestination;
      }
      if (options.stencil === void 0) {
        options.stencil = true;
      }
      if (options.premultipliedAlpha === false) {
        this.premultipliedAlpha = false;
      }
      if (options.xrCompatible === void 0) {
        options.xrCompatible = true;
      }
      this._doNotHandleContextLost = options.doNotHandleContextLost ? true : false;
      if (navigator && navigator.userAgent) {
        this._checkForMobile = function() {
          var currentUA = navigator.userAgent;
          _this.hostInformation.isMobile = currentUA.indexOf("Mobile") !== -1 || currentUA.indexOf("Mac") !== -1 && IsDocumentAvailable() && "ontouchend" in document;
        };
        this._checkForMobile();
        if (IsWindowObjectExist()) {
          window.addEventListener("resize", this._checkForMobile);
        }
        var ua = navigator.userAgent;
        for (var _i = 0, _a = ThinEngine2.ExceptionList; _i < _a.length; _i++) {
          var exception = _a[_i];
          var key = exception.key;
          var targets = exception.targets;
          var check = new RegExp(key);
          if (check.test(ua)) {
            if (exception.capture && exception.captureConstraint) {
              var capture = exception.capture;
              var constraint = exception.captureConstraint;
              var regex = new RegExp(capture);
              var matches = regex.exec(ua);
              if (matches && matches.length > 0) {
                var capturedValue = parseInt(matches[matches.length - 1]);
                if (capturedValue >= constraint) {
                  continue;
                }
              }
            }
            for (var _b = 0, targets_1 = targets; _b < targets_1.length; _b++) {
              var target = targets_1[_b];
              switch (target) {
                case "uniformBuffer":
                  this.disableUniformBuffers = true;
                  break;
                case "vao":
                  this.disableVertexArrayObjects = true;
                  break;
              }
            }
          }
        }
      }
      if (!this._doNotHandleContextLost) {
        this._onContextLost = function(evt) {
          evt.preventDefault();
          _this._contextWasLost = true;
          Logger.Warn("WebGL context lost.");
          _this.onContextLostObservable.notifyObservers(_this);
        };
        this._onContextRestored = function() {
          _this._restoreEngineAfterContextLost(_this._initGLContext.bind(_this));
        };
        canvas.addEventListener("webglcontextlost", this._onContextLost, false);
        canvas.addEventListener("webglcontextrestored", this._onContextRestored, false);
        options.powerPreference = "high-performance";
      }
      this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (this._badDesktopOS) {
        options.xrCompatible = false;
      }
      if (!options.disableWebGL2Support) {
        try {
          this._gl = canvas.getContext("webgl2", options) || canvas.getContext("experimental-webgl2", options);
          if (this._gl) {
            this._webGLVersion = 2;
            this._shaderPlatformName = "WEBGL2";
            if (!this._gl.deleteQuery) {
              this._webGLVersion = 1;
              this._shaderPlatformName = "WEBGL1";
            }
          }
        } catch (e) {
        }
      }
      if (!this._gl) {
        if (!canvas) {
          throw new Error("The provided canvas is null or undefined.");
        }
        try {
          this._gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
        } catch (e) {
          throw new Error("WebGL not supported");
        }
      }
      if (!this._gl) {
        throw new Error("WebGL not supported");
      }
    } else {
      this._gl = canvasOrContext;
      this._renderingCanvas = this._gl.canvas;
      if (this._gl.renderbufferStorageMultisample) {
        this._webGLVersion = 2;
        this._shaderPlatformName = "WEBGL2";
      } else {
        this._shaderPlatformName = "WEBGL1";
      }
      var attributes = this._gl.getContextAttributes();
      if (attributes) {
        options.stencil = attributes.stencil;
      }
    }
    this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
    if (options.useHighPrecisionFloats !== void 0) {
      this._highPrecisionShadersAllowed = options.useHighPrecisionFloats;
    }
    var devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
    var limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;
    this._hardwareScalingLevel = adaptToDeviceRatio ? 1 / Math.min(limitDeviceRatio, devicePixelRatio) : 1;
    this.resize();
    this._isStencilEnable = options.stencil ? true : false;
    this._initGLContext();
    this._initFeatures();
    for (var i = 0; i < this._caps.maxVertexAttribs; i++) {
      this._currentBufferPointers[i] = new BufferPointer();
    }
    this._shaderProcessor = this.webGLVersion > 1 ? new WebGL2ShaderProcessor() : new WebGLShaderProcessor();
    this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);
    var versionToLog = "Babylon.js v".concat(ThinEngine2.Version);
    console.log(versionToLog + " - ".concat(this.description));
    if (this._renderingCanvas && this._renderingCanvas.setAttribute) {
      this._renderingCanvas.setAttribute("data-engine", versionToLog);
    }
  }
  Object.defineProperty(ThinEngine2, "NpmPackage", {
    get: function() {
      return "babylonjs@5.0.0-rc.3";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2, "Version", {
    get: function() {
      return "5.0.0-rc.3";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "description", {
    get: function() {
      var description = this.name + this.webGLVersion;
      if (this._caps.parallelShaderCompile) {
        description += " - Parallel shader compilation";
      }
      return description;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "name", {
    get: function() {
      return this._name;
    },
    set: function(value) {
      this._name = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "version", {
    get: function() {
      return this._webGLVersion;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2, "ShadersRepository", {
    get: function() {
      return Effect.ShadersRepository;
    },
    set: function(value) {
      Effect.ShadersRepository = value;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype._getShaderProcessor = function(shaderLanguage) {
    return this._shaderProcessor;
  };
  Object.defineProperty(ThinEngine2.prototype, "useReverseDepthBuffer", {
    get: function() {
      return this._useReverseDepthBuffer;
    },
    set: function(useReverse) {
      if (useReverse === this._useReverseDepthBuffer) {
        return;
      }
      this._useReverseDepthBuffer = useReverse;
      if (useReverse) {
        this._depthCullingState.depthFunc = 518;
      } else {
        this._depthCullingState.depthFunc = 515;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "frameId", {
    get: function() {
      return this._frameId;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "supportsUniformBuffers", {
    get: function() {
      return this.webGLVersion > 1 && !this.disableUniformBuffers;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype.getCreationOptions = function() {
    return this._creationOptions;
  };
  Object.defineProperty(ThinEngine2.prototype, "_shouldUseHighPrecisionShader", {
    get: function() {
      return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "needPOTTextures", {
    get: function() {
      return this._webGLVersion < 2 || this.forcePOTTextures;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "activeRenderLoops", {
    get: function() {
      return this._activeRenderLoops;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "doNotHandleContextLost", {
    get: function() {
      return this._doNotHandleContextLost;
    },
    set: function(value) {
      this._doNotHandleContextLost = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "_supportsHardwareTextureRescaling", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "framebufferDimensionsObject", {
    set: function(dimensions) {
      this._framebufferDimensionsObject = dimensions;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "currentViewport", {
    get: function() {
      return this._cachedViewport;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "emptyTexture", {
    get: function() {
      if (!this._emptyTexture) {
        this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, false, false, 1);
      }
      return this._emptyTexture;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "emptyTexture3D", {
    get: function() {
      if (!this._emptyTexture3D) {
        this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
      }
      return this._emptyTexture3D;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "emptyTexture2DArray", {
    get: function() {
      if (!this._emptyTexture2DArray) {
        this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
      }
      return this._emptyTexture2DArray;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "emptyCubeTexture", {
    get: function() {
      if (!this._emptyCubeTexture) {
        var faceData = new Uint8Array(4);
        var cubeData = [faceData, faceData, faceData, faceData, faceData, faceData];
        this._emptyCubeTexture = this.createRawCubeTexture(cubeData, 1, 5, 0, false, false, 1);
      }
      return this._emptyCubeTexture;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "isWebGPU", {
    get: function() {
      return this._isWebGPU;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "shaderPlatformName", {
    get: function() {
      return this._shaderPlatformName;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "snapshotRendering", {
    get: function() {
      return false;
    },
    set: function(activate) {
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "snapshotRenderingMode", {
    get: function() {
      return this._snapshotRenderingMode;
    },
    set: function(mode) {
      this._snapshotRenderingMode = mode;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype.snapshotRenderingReset = function() {
    this.snapshotRendering = false;
  };
  ThinEngine2._createCanvas = function(width, height) {
    if (typeof document === "undefined") {
      return new OffscreenCanvas(width, height);
    }
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  };
  ThinEngine2.prototype.createCanvas = function(width, height) {
    return ThinEngine2._createCanvas(width, height);
  };
  ThinEngine2.prototype.createCanvasImage = function() {
    return document.createElement("img");
  };
  ThinEngine2.prototype._restoreEngineAfterContextLost = function(initEngine) {
    var _this = this;
    setTimeout(function() {
      return __awaiter(_this, void 0, void 0, function() {
        var depthTest, depthFunc, depthMask, stencilTest;
        var _a;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              this._dummyFramebuffer = null;
              depthTest = this._depthCullingState.depthTest;
              depthFunc = this._depthCullingState.depthFunc;
              depthMask = this._depthCullingState.depthMask;
              stencilTest = this._stencilState.stencilTest;
              return [4, initEngine()];
            case 1:
              _b.sent();
              this._rebuildEffects();
              (_a = this._rebuildComputeEffects) === null || _a === void 0 ? void 0 : _a.call(this);
              this._rebuildInternalTextures();
              this._rebuildRenderTargetWrappers();
              this._rebuildBuffers();
              this.wipeCaches(true);
              this._depthCullingState.depthTest = depthTest;
              this._depthCullingState.depthFunc = depthFunc;
              this._depthCullingState.depthMask = depthMask;
              this._stencilState.stencilTest = stencilTest;
              Logger.Warn(this.name + " context successfully restored.");
              this.onContextRestoredObservable.notifyObservers(this);
              this._contextWasLost = false;
              return [2];
          }
        });
      });
    }, 0);
  };
  ThinEngine2.prototype._sharedInit = function(canvas, doNotHandleTouchAction, audioEngine) {
    this._renderingCanvas = canvas;
  };
  ThinEngine2.prototype._getShaderProcessingContext = function(shaderLanguage) {
    return null;
  };
  ThinEngine2.prototype._rebuildInternalTextures = function() {
    var currentState = this._internalTexturesCache.slice();
    for (var _i = 0, currentState_1 = currentState; _i < currentState_1.length; _i++) {
      var internalTexture = currentState_1[_i];
      internalTexture._rebuild();
    }
  };
  ThinEngine2.prototype._rebuildRenderTargetWrappers = function() {
    var currentState = this._renderTargetWrapperCache.slice();
    for (var _i = 0, currentState_2 = currentState; _i < currentState_2.length; _i++) {
      var renderTargetWrapper = currentState_2[_i];
      renderTargetWrapper._rebuild();
    }
  };
  ThinEngine2.prototype._rebuildEffects = function() {
    for (var key in this._compiledEffects) {
      var effect = this._compiledEffects[key];
      effect._pipelineContext = null;
      effect._wasPreviouslyReady = false;
      effect._prepareEffect();
    }
    Effect.ResetCache();
  };
  ThinEngine2.prototype.areAllEffectsReady = function() {
    for (var key in this._compiledEffects) {
      var effect = this._compiledEffects[key];
      if (!effect.isReady()) {
        return false;
      }
    }
    return true;
  };
  ThinEngine2.prototype._rebuildBuffers = function() {
    for (var _i = 0, _a = this._uniformBuffers; _i < _a.length; _i++) {
      var uniformBuffer = _a[_i];
      uniformBuffer._rebuild();
    }
    for (var _b = 0, _c = this._storageBuffers; _b < _c.length; _b++) {
      var storageBuffer = _c[_b];
      storageBuffer._rebuild();
    }
  };
  ThinEngine2.prototype._initGLContext = function() {
    this._caps = {
      maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),
      maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),
      maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,
      maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),
      maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),
      maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),
      maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),
      maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),
      maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),
      parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile") || void 0,
      standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension("OES_standard_derivatives") !== null,
      maxAnisotropy: 1,
      astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
      bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
      s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
      s3tc_srgb: this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),
      pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
      etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"),
      textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),
      uintIndices: this._webGLVersion > 1 || this._gl.getExtension("OES_element_index_uint") !== null,
      fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension("EXT_frag_depth") !== null,
      highPrecisionShaderSupported: false,
      timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"),
      supportOcclusionQuery: this._webGLVersion > 1,
      canUseTimestampForTimerQuery: false,
      drawBuffersExtension: false,
      maxMSAASamples: 1,
      colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float")),
      textureFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float") ? true : false,
      textureHalfFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float") ? true : false,
      textureHalfFloatRender: false,
      textureFloatLinearFiltering: false,
      textureFloatRender: false,
      textureHalfFloatLinearFiltering: false,
      vertexArrayObject: false,
      instancedArrays: false,
      textureLOD: this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod") ? true : false,
      blendMinMax: false,
      multiview: this._gl.getExtension("OVR_multiview2"),
      oculusMultiview: this._gl.getExtension("OCULUS_multiview"),
      depthTextureExtension: false,
      canUseGLInstanceID: this._webGLVersion > 1,
      canUseGLVertexID: this._webGLVersion > 1,
      supportComputeShaders: false,
      supportSRGBBuffers: false,
      supportTransformFeedbacks: this._webGLVersion > 1,
      textureMaxLevel: this._webGLVersion > 1
    };
    this._glVersion = this._gl.getParameter(this._gl.VERSION);
    var rendererInfo = this._gl.getExtension("WEBGL_debug_renderer_info");
    if (rendererInfo != null) {
      this._glRenderer = this._gl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);
      this._glVendor = this._gl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);
    }
    if (!this._glVendor) {
      this._glVendor = this._gl.getParameter(this._gl.VENDOR) || "Unknown vendor";
    }
    if (!this._glRenderer) {
      this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || "Unknown renderer";
    }
    if (this._gl.HALF_FLOAT_OES !== 36193) {
      this._gl.HALF_FLOAT_OES = 36193;
    }
    if (this._gl.RGBA16F !== 34842) {
      this._gl.RGBA16F = 34842;
    }
    if (this._gl.RGBA32F !== 34836) {
      this._gl.RGBA32F = 34836;
    }
    if (this._gl.DEPTH24_STENCIL8 !== 35056) {
      this._gl.DEPTH24_STENCIL8 = 35056;
    }
    if (this._caps.timerQuery) {
      if (this._webGLVersion === 1) {
        this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery);
      }
      this._caps.canUseTimestampForTimerQuery = this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT) > 0;
    }
    this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
    this._caps.textureFloatLinearFiltering = this._caps.textureFloat && this._gl.getExtension("OES_texture_float_linear") ? true : false;
    this._caps.textureFloatRender = this._caps.textureFloat && this._canRenderToFloatFramebuffer() ? true : false;
    this._caps.textureHalfFloatLinearFiltering = this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear") ? true : false;
    if (this._caps.astc) {
      this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
    }
    if (this._caps.bptc) {
      this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
    }
    if (this._caps.s3tc_srgb) {
      this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
      this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
    }
    if (this._webGLVersion > 1) {
      if (this._gl.HALF_FLOAT_OES !== 5131) {
        this._gl.HALF_FLOAT_OES = 5131;
      }
    }
    this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer();
    if (this._webGLVersion > 1) {
      this._caps.drawBuffersExtension = true;
      this._caps.maxMSAASamples = this._gl.getParameter(this._gl.MAX_SAMPLES);
    } else {
      var drawBuffersExtension = this._gl.getExtension("WEBGL_draw_buffers");
      if (drawBuffersExtension !== null) {
        this._caps.drawBuffersExtension = true;
        this._gl.drawBuffers = drawBuffersExtension.drawBuffersWEBGL.bind(drawBuffersExtension);
        this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;
        for (var i = 0; i < 16; i++) {
          this._gl["COLOR_ATTACHMENT" + i + "_WEBGL"] = drawBuffersExtension["COLOR_ATTACHMENT" + i + "_WEBGL"];
        }
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.depthTextureExtension = true;
    } else {
      var depthTextureExtension = this._gl.getExtension("WEBGL_depth_texture");
      if (depthTextureExtension != null) {
        this._caps.depthTextureExtension = true;
        this._gl.UNSIGNED_INT_24_8 = depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;
      }
    }
    if (this.disableVertexArrayObjects) {
      this._caps.vertexArrayObject = false;
    } else if (this._webGLVersion > 1) {
      this._caps.vertexArrayObject = true;
    } else {
      var vertexArrayObjectExtension = this._gl.getExtension("OES_vertex_array_object");
      if (vertexArrayObjectExtension != null) {
        this._caps.vertexArrayObject = true;
        this._gl.createVertexArray = vertexArrayObjectExtension.createVertexArrayOES.bind(vertexArrayObjectExtension);
        this._gl.bindVertexArray = vertexArrayObjectExtension.bindVertexArrayOES.bind(vertexArrayObjectExtension);
        this._gl.deleteVertexArray = vertexArrayObjectExtension.deleteVertexArrayOES.bind(vertexArrayObjectExtension);
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.instancedArrays = true;
    } else {
      var instanceExtension = this._gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExtension != null) {
        this._caps.instancedArrays = true;
        this._gl.drawArraysInstanced = instanceExtension.drawArraysInstancedANGLE.bind(instanceExtension);
        this._gl.drawElementsInstanced = instanceExtension.drawElementsInstancedANGLE.bind(instanceExtension);
        this._gl.vertexAttribDivisor = instanceExtension.vertexAttribDivisorANGLE.bind(instanceExtension);
      } else {
        this._caps.instancedArrays = false;
      }
    }
    if (this._gl.getShaderPrecisionFormat) {
      var vertex_highp = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT);
      var fragment_highp = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
      if (vertex_highp && fragment_highp) {
        this._caps.highPrecisionShaderSupported = vertex_highp.precision !== 0 && fragment_highp.precision !== 0;
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.blendMinMax = true;
    } else {
      var blendMinMaxExtension = this._gl.getExtension("EXT_blend_minmax");
      if (blendMinMaxExtension != null) {
        this._caps.blendMinMax = true;
        this._gl.MAX = blendMinMaxExtension.MAX_EXT;
        this._gl.MIN = blendMinMaxExtension.MIN_EXT;
      }
    }
    if (!this._caps.supportSRGBBuffers) {
      if (this._webGLVersion > 1) {
        this._caps.supportSRGBBuffers = true;
      } else {
        var sRGBExtension = this._gl.getExtension("EXT_sRGB");
        if (sRGBExtension != null) {
          this._caps.supportSRGBBuffers = true;
          this._gl.SRGB = sRGBExtension.SRGB_EXT;
          this._gl.SRGB8 = sRGBExtension.SRGB_ALPHA_EXT;
          this._gl.SRGB8_ALPHA8 = sRGBExtension.SRGB_ALPHA_EXT;
        }
      }
      this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && !!(this._creationOptions && this._creationOptions.forceSRGBBufferSupportState);
    }
    this._depthCullingState.depthTest = true;
    this._depthCullingState.depthFunc = this._gl.LEQUAL;
    this._depthCullingState.depthMask = true;
    this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;
    for (var slot = 0; slot < this._maxSimultaneousTextures; slot++) {
      this._nextFreeTextureSlots.push(slot);
    }
  };
  ThinEngine2.prototype._initFeatures = function() {
    this._features = {
      forceBitmapOverHTMLImageElement: false,
      supportRenderAndCopyToLodForFloatTextures: this._webGLVersion !== 1,
      supportDepthStencilTexture: this._webGLVersion !== 1,
      supportShadowSamplers: this._webGLVersion !== 1,
      uniformBufferHardCheckMatrix: false,
      allowTexturePrefiltering: this._webGLVersion !== 1,
      trackUbosInFrame: false,
      checkUbosContentBeforeUpload: false,
      supportCSM: this._webGLVersion !== 1,
      basisNeedsPOT: this._webGLVersion === 1,
      support3DTextures: this._webGLVersion !== 1,
      needTypeSuffixInShaderConstants: this._webGLVersion !== 1,
      supportMSAA: this._webGLVersion !== 1,
      supportSSAO2: this._webGLVersion !== 1,
      supportExtendedTextureFormats: this._webGLVersion !== 1,
      supportSwitchCaseInShader: this._webGLVersion !== 1,
      supportSyncTextureRead: true,
      needsInvertingBitmap: true,
      useUBOBindingCache: true,
      needShaderCodeInlining: false,
      needToAlwaysBindUniformBuffers: false,
      supportRenderPasses: false,
      _collectUbosUpdatedInFrame: false
    };
  };
  Object.defineProperty(ThinEngine2.prototype, "webGLVersion", {
    get: function() {
      return this._webGLVersion;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype.getClassName = function() {
    return "ThinEngine";
  };
  Object.defineProperty(ThinEngine2.prototype, "isStencilEnable", {
    get: function() {
      return this._isStencilEnable;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype._prepareWorkingCanvas = function() {
    if (this._workingCanvas) {
      return;
    }
    this._workingCanvas = this.createCanvas(1, 1);
    var context = this._workingCanvas.getContext("2d");
    if (context) {
      this._workingContext = context;
    }
  };
  ThinEngine2.prototype.resetTextureCache = function() {
    for (var key in this._boundTexturesCache) {
      if (!this._boundTexturesCache.hasOwnProperty(key)) {
        continue;
      }
      this._boundTexturesCache[key] = null;
    }
    this._currentTextureChannel = -1;
  };
  ThinEngine2.prototype.getInfo = function() {
    return this.getGlInfo();
  };
  ThinEngine2.prototype.getGlInfo = function() {
    return {
      vendor: this._glVendor,
      renderer: this._glRenderer,
      version: this._glVersion
    };
  };
  ThinEngine2.prototype.setHardwareScalingLevel = function(level) {
    this._hardwareScalingLevel = level;
    this.resize();
  };
  ThinEngine2.prototype.getHardwareScalingLevel = function() {
    return this._hardwareScalingLevel;
  };
  ThinEngine2.prototype.getLoadedTexturesCache = function() {
    return this._internalTexturesCache;
  };
  ThinEngine2.prototype.getCaps = function() {
    return this._caps;
  };
  ThinEngine2.prototype.stopRenderLoop = function(renderFunction) {
    if (!renderFunction) {
      this._activeRenderLoops = [];
      return;
    }
    var index = this._activeRenderLoops.indexOf(renderFunction);
    if (index >= 0) {
      this._activeRenderLoops.splice(index, 1);
    }
  };
  ThinEngine2.prototype._renderLoop = function() {
    if (!this._contextWasLost) {
      var shouldRender = true;
      if (!this.renderEvenInBackground && this._windowIsBackground) {
        shouldRender = false;
      }
      if (shouldRender) {
        this.beginFrame();
        for (var index = 0; index < this._activeRenderLoops.length; index++) {
          var renderFunction = this._activeRenderLoops[index];
          renderFunction();
        }
        this.endFrame();
      }
    }
    if (this._activeRenderLoops.length > 0) {
      this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
    } else {
      this._renderingQueueLaunched = false;
    }
  };
  ThinEngine2.prototype.getRenderingCanvas = function() {
    return this._renderingCanvas;
  };
  ThinEngine2.prototype.getAudioContext = function() {
    return this._audioContext;
  };
  ThinEngine2.prototype.getAudioDestination = function() {
    return this._audioDestination;
  };
  ThinEngine2.prototype.getHostWindow = function() {
    if (!IsWindowObjectExist()) {
      return null;
    }
    if (this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView) {
      return this._renderingCanvas.ownerDocument.defaultView;
    }
    return window;
  };
  ThinEngine2.prototype.getRenderWidth = function(useScreen) {
    if (useScreen === void 0) {
      useScreen = false;
    }
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.width;
    }
    return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth;
  };
  ThinEngine2.prototype.getRenderHeight = function(useScreen) {
    if (useScreen === void 0) {
      useScreen = false;
    }
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.height;
    }
    return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight;
  };
  ThinEngine2.prototype._queueNewFrame = function(bindedRenderFunction, requester) {
    return ThinEngine2.QueueNewFrame(bindedRenderFunction, requester);
  };
  ThinEngine2.prototype.runRenderLoop = function(renderFunction) {
    if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {
      return;
    }
    this._activeRenderLoops.push(renderFunction);
    if (!this._renderingQueueLaunched) {
      this._renderingQueueLaunched = true;
      this._boundRenderFunction = this._renderLoop.bind(this);
      this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
    }
  };
  ThinEngine2.prototype.clear = function(color, backBuffer, depth, stencil) {
    if (stencil === void 0) {
      stencil = false;
    }
    var useStencilGlobalOnly = this.stencilStateComposer.useStencilGlobalOnly;
    this.stencilStateComposer.useStencilGlobalOnly = true;
    this.applyStates();
    this.stencilStateComposer.useStencilGlobalOnly = useStencilGlobalOnly;
    var mode = 0;
    if (backBuffer && color) {
      this._gl.clearColor(color.r, color.g, color.b, color.a !== void 0 ? color.a : 1);
      mode |= this._gl.COLOR_BUFFER_BIT;
    }
    if (depth) {
      if (this.useReverseDepthBuffer) {
        this._depthCullingState.depthFunc = this._gl.GEQUAL;
        this._gl.clearDepth(0);
      } else {
        this._gl.clearDepth(1);
      }
      mode |= this._gl.DEPTH_BUFFER_BIT;
    }
    if (stencil) {
      this._gl.clearStencil(0);
      mode |= this._gl.STENCIL_BUFFER_BIT;
    }
    this._gl.clear(mode);
  };
  ThinEngine2.prototype._viewport = function(x, y, width, height) {
    if (x !== this._viewportCached.x || y !== this._viewportCached.y || width !== this._viewportCached.z || height !== this._viewportCached.w) {
      this._viewportCached.x = x;
      this._viewportCached.y = y;
      this._viewportCached.z = width;
      this._viewportCached.w = height;
      this._gl.viewport(x, y, width, height);
    }
  };
  ThinEngine2.prototype.setViewport = function(viewport, requiredWidth, requiredHeight) {
    var width = requiredWidth || this.getRenderWidth();
    var height = requiredHeight || this.getRenderHeight();
    var x = viewport.x || 0;
    var y = viewport.y || 0;
    this._cachedViewport = viewport;
    this._viewport(x * width, y * height, width * viewport.width, height * viewport.height);
  };
  ThinEngine2.prototype.beginFrame = function() {
  };
  ThinEngine2.prototype.endFrame = function() {
    if (this._badOS) {
      this.flushFramebuffer();
    }
    this._frameId++;
  };
  ThinEngine2.prototype.resize = function(forceSetSize) {
    if (forceSetSize === void 0) {
      forceSetSize = false;
    }
    var width;
    var height;
    if (this._adaptToDeviceRatio) {
      var devicePixelRatio_1 = IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
      var limitDeviceRatio = this._creationOptions.limitDeviceRatio || devicePixelRatio_1;
      this._hardwareScalingLevel = this._adaptToDeviceRatio ? 1 / Math.min(limitDeviceRatio, devicePixelRatio_1) : 1;
    }
    if (IsWindowObjectExist()) {
      width = this._renderingCanvas ? this._renderingCanvas.clientWidth || this._renderingCanvas.width : window.innerWidth;
      height = this._renderingCanvas ? this._renderingCanvas.clientHeight || this._renderingCanvas.height : window.innerHeight;
    } else {
      width = this._renderingCanvas ? this._renderingCanvas.width : 100;
      height = this._renderingCanvas ? this._renderingCanvas.height : 100;
    }
    this.setSize(width / this._hardwareScalingLevel, height / this._hardwareScalingLevel, forceSetSize);
  };
  ThinEngine2.prototype.setSize = function(width, height, forceSetSize) {
    if (forceSetSize === void 0) {
      forceSetSize = false;
    }
    if (!this._renderingCanvas) {
      return false;
    }
    width = width | 0;
    height = height | 0;
    if (!forceSetSize && this._renderingCanvas.width === width && this._renderingCanvas.height === height) {
      return false;
    }
    this._renderingCanvas.width = width;
    this._renderingCanvas.height = height;
    return true;
  };
  ThinEngine2.prototype.bindFramebuffer = function(texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel, layer) {
    var _a, _b, _c, _d, _e;
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lodLevel === void 0) {
      lodLevel = 0;
    }
    if (layer === void 0) {
      layer = 0;
    }
    var webglRTWrapper = texture;
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    }
    this._currentRenderTarget = texture;
    this._bindUnboundFramebuffer(webglRTWrapper._MSAAFramebuffer ? webglRTWrapper._MSAAFramebuffer : webglRTWrapper._framebuffer);
    var gl = this._gl;
    if (texture.is2DArray) {
      gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, (_a = texture.texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource, lodLevel, layer);
    } else if (texture.isCube) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_b = texture.texture._hardwareTexture) === null || _b === void 0 ? void 0 : _b.underlyingResource, lodLevel);
    }
    var depthStencilTexture = texture._depthStencilTexture;
    if (depthStencilTexture) {
      var attachment = texture._depthStencilTextureWithStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
      if (texture.is2DArray) {
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, (_c = depthStencilTexture._hardwareTexture) === null || _c === void 0 ? void 0 : _c.underlyingResource, lodLevel, layer);
      } else if (texture.isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_d = depthStencilTexture._hardwareTexture) === null || _d === void 0 ? void 0 : _d.underlyingResource, lodLevel);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, (_e = depthStencilTexture._hardwareTexture) === null || _e === void 0 ? void 0 : _e.underlyingResource, lodLevel);
      }
    }
    if (this._cachedViewport && !forceFullscreenViewport) {
      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
    } else {
      if (!requiredWidth) {
        requiredWidth = texture.width;
        if (lodLevel) {
          requiredWidth = requiredWidth / Math.pow(2, lodLevel);
        }
      }
      if (!requiredHeight) {
        requiredHeight = texture.height;
        if (lodLevel) {
          requiredHeight = requiredHeight / Math.pow(2, lodLevel);
        }
      }
      this._viewport(0, 0, requiredWidth, requiredHeight);
    }
    this.wipeCaches();
  };
  ThinEngine2.prototype.setState = function(culling, zOffset, force, reverseSide, cullBackFaces, stencil, zOffsetUnits) {
    var _a, _b;
    if (zOffset === void 0) {
      zOffset = 0;
    }
    if (reverseSide === void 0) {
      reverseSide = false;
    }
    if (zOffsetUnits === void 0) {
      zOffsetUnits = 0;
    }
    if (this._depthCullingState.cull !== culling || force) {
      this._depthCullingState.cull = culling;
    }
    var cullFace = ((_b = (_a = this.cullBackFaces) !== null && _a !== void 0 ? _a : cullBackFaces) !== null && _b !== void 0 ? _b : true) ? this._gl.BACK : this._gl.FRONT;
    if (this._depthCullingState.cullFace !== cullFace || force) {
      this._depthCullingState.cullFace = cullFace;
    }
    this.setZOffset(zOffset);
    this.setZOffsetUnits(zOffsetUnits);
    var frontFace = reverseSide ? this._gl.CW : this._gl.CCW;
    if (this._depthCullingState.frontFace !== frontFace || force) {
      this._depthCullingState.frontFace = frontFace;
    }
    this._stencilStateComposer.stencilMaterial = stencil;
  };
  ThinEngine2.prototype.setZOffset = function(value) {
    this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -value : value;
  };
  ThinEngine2.prototype.getZOffset = function() {
    var zOffset = this._depthCullingState.zOffset;
    return this.useReverseDepthBuffer ? -zOffset : zOffset;
  };
  ThinEngine2.prototype.setZOffsetUnits = function(value) {
    this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -value : value;
  };
  ThinEngine2.prototype.getZOffsetUnits = function() {
    var zOffsetUnits = this._depthCullingState.zOffsetUnits;
    return this.useReverseDepthBuffer ? -zOffsetUnits : zOffsetUnits;
  };
  ThinEngine2.prototype._bindUnboundFramebuffer = function(framebuffer) {
    if (this._currentFramebuffer !== framebuffer) {
      this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
      this._currentFramebuffer = framebuffer;
    }
  };
  ThinEngine2.prototype._currentFrameBufferIsDefaultFrameBuffer = function() {
    return this._currentFramebuffer === null;
  };
  ThinEngine2.prototype.generateMipmaps = function(texture) {
    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  };
  ThinEngine2.prototype.unBindFramebuffer = function(texture, disableGenerateMipMaps, onBeforeUnbind) {
    var _a;
    if (disableGenerateMipMaps === void 0) {
      disableGenerateMipMaps = false;
    }
    var webglRTWrapper = texture;
    this._currentRenderTarget = null;
    var gl = this._gl;
    if (webglRTWrapper._MSAAFramebuffer) {
      if (texture.isMulti) {
        this.unBindMultiColorAttachmentFramebuffer(texture, disableGenerateMipMaps, onBeforeUnbind);
        return;
      }
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, webglRTWrapper._MSAAFramebuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, webglRTWrapper._framebuffer);
      gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
    }
    if (((_a = texture.texture) === null || _a === void 0 ? void 0 : _a.generateMipMaps) && !disableGenerateMipMaps && !texture.isCube) {
      this.generateMipmaps(texture.texture);
    }
    if (onBeforeUnbind) {
      if (webglRTWrapper._MSAAFramebuffer) {
        this._bindUnboundFramebuffer(webglRTWrapper._framebuffer);
      }
      onBeforeUnbind();
    }
    this._bindUnboundFramebuffer(null);
  };
  ThinEngine2.prototype.flushFramebuffer = function() {
    this._gl.flush();
  };
  ThinEngine2.prototype.restoreDefaultFramebuffer = function() {
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    } else {
      this._bindUnboundFramebuffer(null);
    }
    if (this._cachedViewport) {
      this.setViewport(this._cachedViewport);
    }
    this.wipeCaches();
  };
  ThinEngine2.prototype._resetVertexBufferBinding = function() {
    this.bindArrayBuffer(null);
    this._cachedVertexBuffers = null;
  };
  ThinEngine2.prototype.createVertexBuffer = function(data) {
    return this._createVertexBuffer(data, this._gl.STATIC_DRAW);
  };
  ThinEngine2.prototype._createVertexBuffer = function(data, usage) {
    var vbo = this._gl.createBuffer();
    if (!vbo) {
      throw new Error("Unable to create vertex buffer");
    }
    var dataBuffer = new WebGLDataBuffer(vbo);
    this.bindArrayBuffer(dataBuffer);
    if (data instanceof Array) {
      this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(data), usage);
    } else {
      this._gl.bufferData(this._gl.ARRAY_BUFFER, data, usage);
    }
    this._resetVertexBufferBinding();
    dataBuffer.references = 1;
    return dataBuffer;
  };
  ThinEngine2.prototype.createDynamicVertexBuffer = function(data) {
    return this._createVertexBuffer(data, this._gl.DYNAMIC_DRAW);
  };
  ThinEngine2.prototype._resetIndexBufferBinding = function() {
    this.bindIndexBuffer(null);
    this._cachedIndexBuffer = null;
  };
  ThinEngine2.prototype.createIndexBuffer = function(indices, updatable) {
    var vbo = this._gl.createBuffer();
    var dataBuffer = new WebGLDataBuffer(vbo);
    if (!vbo) {
      throw new Error("Unable to create index buffer");
    }
    this.bindIndexBuffer(dataBuffer);
    var data = this._normalizeIndexData(indices);
    this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, updatable ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW);
    this._resetIndexBufferBinding();
    dataBuffer.references = 1;
    dataBuffer.is32Bits = data.BYTES_PER_ELEMENT === 4;
    return dataBuffer;
  };
  ThinEngine2.prototype._normalizeIndexData = function(indices) {
    var bytesPerElement = indices.BYTES_PER_ELEMENT;
    if (bytesPerElement === 2) {
      return indices;
    }
    if (this._caps.uintIndices) {
      if (indices instanceof Uint32Array) {
        return indices;
      } else {
        for (var index = 0; index < indices.length; index++) {
          if (indices[index] >= 65535) {
            return new Uint32Array(indices);
          }
        }
        return new Uint16Array(indices);
      }
    }
    return new Uint16Array(indices);
  };
  ThinEngine2.prototype.bindArrayBuffer = function(buffer) {
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this.bindBuffer(buffer, this._gl.ARRAY_BUFFER);
  };
  ThinEngine2.prototype.bindUniformBlock = function(pipelineContext, blockName, index) {
    var program = pipelineContext.program;
    var uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
    this._gl.uniformBlockBinding(program, uniformLocation, index);
  };
  ThinEngine2.prototype.bindIndexBuffer = function(buffer) {
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this.bindBuffer(buffer, this._gl.ELEMENT_ARRAY_BUFFER);
  };
  ThinEngine2.prototype.bindBuffer = function(buffer, target) {
    if (this._vaoRecordInProgress || this._currentBoundBuffer[target] !== buffer) {
      this._gl.bindBuffer(target, buffer ? buffer.underlyingResource : null);
      this._currentBoundBuffer[target] = buffer;
    }
  };
  ThinEngine2.prototype.updateArrayBuffer = function(data) {
    this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
  };
  ThinEngine2.prototype._vertexAttribPointer = function(buffer, indx, size, type, normalized, stride, offset) {
    var pointer = this._currentBufferPointers[indx];
    if (!pointer) {
      return;
    }
    var changed = false;
    if (!pointer.active) {
      changed = true;
      pointer.active = true;
      pointer.index = indx;
      pointer.size = size;
      pointer.type = type;
      pointer.normalized = normalized;
      pointer.stride = stride;
      pointer.offset = offset;
      pointer.buffer = buffer;
    } else {
      if (pointer.buffer !== buffer) {
        pointer.buffer = buffer;
        changed = true;
      }
      if (pointer.size !== size) {
        pointer.size = size;
        changed = true;
      }
      if (pointer.type !== type) {
        pointer.type = type;
        changed = true;
      }
      if (pointer.normalized !== normalized) {
        pointer.normalized = normalized;
        changed = true;
      }
      if (pointer.stride !== stride) {
        pointer.stride = stride;
        changed = true;
      }
      if (pointer.offset !== offset) {
        pointer.offset = offset;
        changed = true;
      }
    }
    if (changed || this._vaoRecordInProgress) {
      this.bindArrayBuffer(buffer);
      this._gl.vertexAttribPointer(indx, size, type, normalized, stride, offset);
    }
  };
  ThinEngine2.prototype._bindIndexBufferWithCache = function(indexBuffer) {
    if (indexBuffer == null) {
      return;
    }
    if (this._cachedIndexBuffer !== indexBuffer) {
      this._cachedIndexBuffer = indexBuffer;
      this.bindIndexBuffer(indexBuffer);
      this._uintIndicesCurrentlySet = indexBuffer.is32Bits;
    }
  };
  ThinEngine2.prototype._bindVertexBuffersAttributes = function(vertexBuffers, effect, overrideVertexBuffers) {
    var attributes = effect.getAttributesNames();
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this.unbindAllAttributes();
    for (var index = 0; index < attributes.length; index++) {
      var order = effect.getAttributeLocation(index);
      if (order >= 0) {
        var ai = attributes[index];
        var vertexBuffer = null;
        if (overrideVertexBuffers) {
          vertexBuffer = overrideVertexBuffers[ai];
        }
        if (!vertexBuffer) {
          vertexBuffer = vertexBuffers[ai];
        }
        if (!vertexBuffer) {
          continue;
        }
        this._gl.enableVertexAttribArray(order);
        if (!this._vaoRecordInProgress) {
          this._vertexAttribArraysEnabled[order] = true;
        }
        var buffer = vertexBuffer.getBuffer();
        if (buffer) {
          this._vertexAttribPointer(buffer, order, vertexBuffer.getSize(), vertexBuffer.type, vertexBuffer.normalized, vertexBuffer.byteStride, vertexBuffer.byteOffset);
          if (vertexBuffer.getIsInstanced()) {
            this._gl.vertexAttribDivisor(order, vertexBuffer.getInstanceDivisor());
            if (!this._vaoRecordInProgress) {
              this._currentInstanceLocations.push(order);
              this._currentInstanceBuffers.push(buffer);
            }
          }
        }
      }
    }
  };
  ThinEngine2.prototype.recordVertexArrayObject = function(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
    var vao = this._gl.createVertexArray();
    this._vaoRecordInProgress = true;
    this._gl.bindVertexArray(vao);
    this._mustWipeVertexAttributes = true;
    this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
    this.bindIndexBuffer(indexBuffer);
    this._vaoRecordInProgress = false;
    this._gl.bindVertexArray(null);
    return vao;
  };
  ThinEngine2.prototype.bindVertexArrayObject = function(vertexArrayObject, indexBuffer) {
    if (this._cachedVertexArrayObject !== vertexArrayObject) {
      this._cachedVertexArrayObject = vertexArrayObject;
      this._gl.bindVertexArray(vertexArrayObject);
      this._cachedVertexBuffers = null;
      this._cachedIndexBuffer = null;
      this._uintIndicesCurrentlySet = indexBuffer != null && indexBuffer.is32Bits;
      this._mustWipeVertexAttributes = true;
    }
  };
  ThinEngine2.prototype.bindBuffersDirectly = function(vertexBuffer, indexBuffer, vertexDeclaration, vertexStrideSize, effect) {
    if (this._cachedVertexBuffers !== vertexBuffer || this._cachedEffectForVertexBuffers !== effect) {
      this._cachedVertexBuffers = vertexBuffer;
      this._cachedEffectForVertexBuffers = effect;
      var attributesCount = effect.getAttributesCount();
      this._unbindVertexArrayObject();
      this.unbindAllAttributes();
      var offset = 0;
      for (var index = 0; index < attributesCount; index++) {
        if (index < vertexDeclaration.length) {
          var order = effect.getAttributeLocation(index);
          if (order >= 0) {
            this._gl.enableVertexAttribArray(order);
            this._vertexAttribArraysEnabled[order] = true;
            this._vertexAttribPointer(vertexBuffer, order, vertexDeclaration[index], this._gl.FLOAT, false, vertexStrideSize, offset);
          }
          offset += vertexDeclaration[index] * 4;
        }
      }
    }
    this._bindIndexBufferWithCache(indexBuffer);
  };
  ThinEngine2.prototype._unbindVertexArrayObject = function() {
    if (!this._cachedVertexArrayObject) {
      return;
    }
    this._cachedVertexArrayObject = null;
    this._gl.bindVertexArray(null);
  };
  ThinEngine2.prototype.bindBuffers = function(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
    if (this._cachedVertexBuffers !== vertexBuffers || this._cachedEffectForVertexBuffers !== effect) {
      this._cachedVertexBuffers = vertexBuffers;
      this._cachedEffectForVertexBuffers = effect;
      this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
    }
    this._bindIndexBufferWithCache(indexBuffer);
  };
  ThinEngine2.prototype.unbindInstanceAttributes = function() {
    var boundBuffer;
    for (var i = 0, ul = this._currentInstanceLocations.length; i < ul; i++) {
      var instancesBuffer = this._currentInstanceBuffers[i];
      if (boundBuffer != instancesBuffer && instancesBuffer.references) {
        boundBuffer = instancesBuffer;
        this.bindArrayBuffer(instancesBuffer);
      }
      var offsetLocation = this._currentInstanceLocations[i];
      this._gl.vertexAttribDivisor(offsetLocation, 0);
    }
    this._currentInstanceBuffers.length = 0;
    this._currentInstanceLocations.length = 0;
  };
  ThinEngine2.prototype.releaseVertexArrayObject = function(vao) {
    this._gl.deleteVertexArray(vao);
  };
  ThinEngine2.prototype._releaseBuffer = function(buffer) {
    buffer.references--;
    if (buffer.references === 0) {
      this._deleteBuffer(buffer);
      return true;
    }
    return false;
  };
  ThinEngine2.prototype._deleteBuffer = function(buffer) {
    this._gl.deleteBuffer(buffer.underlyingResource);
  };
  ThinEngine2.prototype.updateAndBindInstancesBuffer = function(instancesBuffer, data, offsetLocations) {
    this.bindArrayBuffer(instancesBuffer);
    if (data) {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
    }
    if (offsetLocations[0].index !== void 0) {
      this.bindInstancesBuffer(instancesBuffer, offsetLocations, true);
    } else {
      for (var index = 0; index < 4; index++) {
        var offsetLocation = offsetLocations[index];
        if (!this._vertexAttribArraysEnabled[offsetLocation]) {
          this._gl.enableVertexAttribArray(offsetLocation);
          this._vertexAttribArraysEnabled[offsetLocation] = true;
        }
        this._vertexAttribPointer(instancesBuffer, offsetLocation, 4, this._gl.FLOAT, false, 64, index * 16);
        this._gl.vertexAttribDivisor(offsetLocation, 1);
        this._currentInstanceLocations.push(offsetLocation);
        this._currentInstanceBuffers.push(instancesBuffer);
      }
    }
  };
  ThinEngine2.prototype.bindInstancesBuffer = function(instancesBuffer, attributesInfo, computeStride) {
    if (computeStride === void 0) {
      computeStride = true;
    }
    this.bindArrayBuffer(instancesBuffer);
    var stride = 0;
    if (computeStride) {
      for (var i = 0; i < attributesInfo.length; i++) {
        var ai = attributesInfo[i];
        stride += ai.attributeSize * 4;
      }
    }
    for (var i = 0; i < attributesInfo.length; i++) {
      var ai = attributesInfo[i];
      if (ai.index === void 0) {
        ai.index = this._currentEffect.getAttributeLocationByName(ai.attributeName);
      }
      if (ai.index < 0) {
        continue;
      }
      if (!this._vertexAttribArraysEnabled[ai.index]) {
        this._gl.enableVertexAttribArray(ai.index);
        this._vertexAttribArraysEnabled[ai.index] = true;
      }
      this._vertexAttribPointer(instancesBuffer, ai.index, ai.attributeSize, ai.attributeType || this._gl.FLOAT, ai.normalized || false, stride, ai.offset);
      this._gl.vertexAttribDivisor(ai.index, ai.divisor === void 0 ? 1 : ai.divisor);
      this._currentInstanceLocations.push(ai.index);
      this._currentInstanceBuffers.push(instancesBuffer);
    }
  };
  ThinEngine2.prototype.disableInstanceAttributeByName = function(name2) {
    if (!this._currentEffect) {
      return;
    }
    var attributeLocation = this._currentEffect.getAttributeLocationByName(name2);
    this.disableInstanceAttribute(attributeLocation);
  };
  ThinEngine2.prototype.disableInstanceAttribute = function(attributeLocation) {
    var shouldClean = false;
    var index;
    while ((index = this._currentInstanceLocations.indexOf(attributeLocation)) !== -1) {
      this._currentInstanceLocations.splice(index, 1);
      this._currentInstanceBuffers.splice(index, 1);
      shouldClean = true;
      index = this._currentInstanceLocations.indexOf(attributeLocation);
    }
    if (shouldClean) {
      this._gl.vertexAttribDivisor(attributeLocation, 0);
      this.disableAttributeByIndex(attributeLocation);
    }
  };
  ThinEngine2.prototype.disableAttributeByIndex = function(attributeLocation) {
    this._gl.disableVertexAttribArray(attributeLocation);
    this._vertexAttribArraysEnabled[attributeLocation] = false;
    this._currentBufferPointers[attributeLocation].active = false;
  };
  ThinEngine2.prototype.draw = function(useTriangles, indexStart, indexCount, instancesCount) {
    this.drawElementsType(useTriangles ? 0 : 1, indexStart, indexCount, instancesCount);
  };
  ThinEngine2.prototype.drawPointClouds = function(verticesStart, verticesCount, instancesCount) {
    this.drawArraysType(2, verticesStart, verticesCount, instancesCount);
  };
  ThinEngine2.prototype.drawUnIndexed = function(useTriangles, verticesStart, verticesCount, instancesCount) {
    this.drawArraysType(useTriangles ? 0 : 1, verticesStart, verticesCount, instancesCount);
  };
  ThinEngine2.prototype.drawElementsType = function(fillMode, indexStart, indexCount, instancesCount) {
    this.applyStates();
    this._reportDrawCall();
    var drawMode = this._drawMode(fillMode);
    var indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;
    var mult = this._uintIndicesCurrentlySet ? 4 : 2;
    if (instancesCount) {
      this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);
    } else {
      this._gl.drawElements(drawMode, indexCount, indexFormat, indexStart * mult);
    }
  };
  ThinEngine2.prototype.drawArraysType = function(fillMode, verticesStart, verticesCount, instancesCount) {
    this.applyStates();
    this._reportDrawCall();
    var drawMode = this._drawMode(fillMode);
    if (instancesCount) {
      this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);
    } else {
      this._gl.drawArrays(drawMode, verticesStart, verticesCount);
    }
  };
  ThinEngine2.prototype._drawMode = function(fillMode) {
    switch (fillMode) {
      case 0:
        return this._gl.TRIANGLES;
      case 2:
        return this._gl.POINTS;
      case 1:
        return this._gl.LINES;
      case 3:
        return this._gl.POINTS;
      case 4:
        return this._gl.LINES;
      case 5:
        return this._gl.LINE_LOOP;
      case 6:
        return this._gl.LINE_STRIP;
      case 7:
        return this._gl.TRIANGLE_STRIP;
      case 8:
        return this._gl.TRIANGLE_FAN;
      default:
        return this._gl.TRIANGLES;
    }
  };
  ThinEngine2.prototype._reportDrawCall = function() {
  };
  ThinEngine2.prototype._releaseEffect = function(effect) {
    if (this._compiledEffects[effect._key]) {
      delete this._compiledEffects[effect._key];
      var pipelineContext = effect.getPipelineContext();
      if (pipelineContext) {
        this._deletePipelineContext(pipelineContext);
      }
    }
  };
  ThinEngine2.prototype._deletePipelineContext = function(pipelineContext) {
    var webGLPipelineContext = pipelineContext;
    if (webGLPipelineContext && webGLPipelineContext.program) {
      webGLPipelineContext.program.__SPECTOR_rebuildProgram = null;
      this._gl.deleteProgram(webGLPipelineContext.program);
    }
  };
  ThinEngine2.prototype._getGlobalDefines = function(defines) {
    if (defines) {
      if (this.isNDCHalfZRange) {
        defines["IS_NDC_HALF_ZRANGE"] = "";
      } else {
        delete defines["IS_NDC_HALF_ZRANGE"];
      }
      if (this.useReverseDepthBuffer) {
        defines["USE_REVERSE_DEPTHBUFFER"] = "";
      } else {
        delete defines["USE_REVERSE_DEPTHBUFFER"];
      }
      return;
    } else {
      var s = "";
      if (this.isNDCHalfZRange) {
        s += "#define IS_NDC_HALF_ZRANGE";
      }
      if (this.useReverseDepthBuffer) {
        if (s) {
          s += "\n";
        }
        s += "#define USE_REVERSE_DEPTHBUFFER";
      }
      return s;
    }
  };
  ThinEngine2.prototype.createEffect = function(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters, shaderLanguage) {
    var _a;
    if (shaderLanguage === void 0) {
      shaderLanguage = ShaderLanguage.GLSL;
    }
    var vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;
    var fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;
    var globalDefines = this._getGlobalDefines();
    var fullDefines = (_a = defines !== null && defines !== void 0 ? defines : attributesNamesOrOptions.defines) !== null && _a !== void 0 ? _a : "";
    if (globalDefines) {
      fullDefines += globalDefines;
    }
    var name2 = vertex + "+" + fragment + "@" + fullDefines;
    if (this._compiledEffects[name2]) {
      var compiledEffect = this._compiledEffects[name2];
      if (onCompiled && compiledEffect.isReady()) {
        onCompiled(compiledEffect);
      }
      return compiledEffect;
    }
    var effect = new Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters, name2, shaderLanguage);
    this._compiledEffects[name2] = effect;
    return effect;
  };
  ThinEngine2._ConcatenateShader = function(source, defines, shaderVersion) {
    if (shaderVersion === void 0) {
      shaderVersion = "";
    }
    return shaderVersion + (defines ? defines + "\n" : "") + source;
  };
  ThinEngine2.prototype._compileShader = function(source, type, defines, shaderVersion) {
    return this._compileRawShader(ThinEngine2._ConcatenateShader(source, defines, shaderVersion), type);
  };
  ThinEngine2.prototype._compileRawShader = function(source, type) {
    var gl = this._gl;
    while (gl.getError() != gl.NO_ERROR) {
    }
    var shader2 = gl.createShader(type === "vertex" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
    if (!shader2) {
      throw new Error("Something went wrong while creating a gl ".concat(type, " shader object. gl error=").concat(gl.getError(), ", gl isContextLost=").concat(gl.isContextLost(), ", _contextWasLost=").concat(this._contextWasLost));
    }
    gl.shaderSource(shader2, source);
    gl.compileShader(shader2);
    return shader2;
  };
  ThinEngine2.prototype._getShaderSource = function(shader2) {
    return this._gl.getShaderSource(shader2);
  };
  ThinEngine2.prototype.createRawShaderProgram = function(pipelineContext, vertexCode, fragmentCode, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    context = context || this._gl;
    var vertexShader = this._compileRawShader(vertexCode, "vertex");
    var fragmentShader = this._compileRawShader(fragmentCode, "fragment");
    return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
  };
  ThinEngine2.prototype.createShaderProgram = function(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    context = context || this._gl;
    var shaderVersion = this._webGLVersion > 1 ? "#version 300 es\n#define WEBGL2 \n" : "";
    var vertexShader = this._compileShader(vertexCode, "vertex", defines, shaderVersion);
    var fragmentShader = this._compileShader(fragmentCode, "fragment", defines, shaderVersion);
    return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
  };
  ThinEngine2.prototype.inlineShaderCode = function(code) {
    return code;
  };
  ThinEngine2.prototype.createPipelineContext = function(shaderProcessingContext) {
    var pipelineContext = new WebGLPipelineContext();
    pipelineContext.engine = this;
    if (this._caps.parallelShaderCompile) {
      pipelineContext.isParallelCompiled = true;
    }
    return pipelineContext;
  };
  ThinEngine2.prototype.createMaterialContext = function() {
    return void 0;
  };
  ThinEngine2.prototype.createDrawContext = function() {
    return void 0;
  };
  ThinEngine2.prototype._createShaderProgram = function(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings) {
    var shaderProgram = context.createProgram();
    pipelineContext.program = shaderProgram;
    if (!shaderProgram) {
      throw new Error("Unable to create program");
    }
    context.attachShader(shaderProgram, vertexShader);
    context.attachShader(shaderProgram, fragmentShader);
    context.linkProgram(shaderProgram);
    pipelineContext.context = context;
    pipelineContext.vertexShader = vertexShader;
    pipelineContext.fragmentShader = fragmentShader;
    if (!pipelineContext.isParallelCompiled) {
      this._finalizePipelineContext(pipelineContext);
    }
    return shaderProgram;
  };
  ThinEngine2.prototype._finalizePipelineContext = function(pipelineContext) {
    var context = pipelineContext.context;
    var vertexShader = pipelineContext.vertexShader;
    var fragmentShader = pipelineContext.fragmentShader;
    var program = pipelineContext.program;
    var linked = context.getProgramParameter(program, context.LINK_STATUS);
    if (!linked) {
      if (!this._gl.getShaderParameter(vertexShader, this._gl.COMPILE_STATUS)) {
        var log = this._gl.getShaderInfoLog(vertexShader);
        if (log) {
          pipelineContext.vertexCompilationError = log;
          throw new Error("VERTEX SHADER " + log);
        }
      }
      if (!this._gl.getShaderParameter(fragmentShader, this._gl.COMPILE_STATUS)) {
        var log = this._gl.getShaderInfoLog(fragmentShader);
        if (log) {
          pipelineContext.fragmentCompilationError = log;
          throw new Error("FRAGMENT SHADER " + log);
        }
      }
      var error = context.getProgramInfoLog(program);
      if (error) {
        pipelineContext.programLinkError = error;
        throw new Error(error);
      }
    }
    if (this.validateShaderPrograms) {
      context.validateProgram(program);
      var validated = context.getProgramParameter(program, context.VALIDATE_STATUS);
      if (!validated) {
        var error = context.getProgramInfoLog(program);
        if (error) {
          pipelineContext.programValidationError = error;
          throw new Error(error);
        }
      }
    }
    context.deleteShader(vertexShader);
    context.deleteShader(fragmentShader);
    pipelineContext.vertexShader = void 0;
    pipelineContext.fragmentShader = void 0;
    if (pipelineContext.onCompiled) {
      pipelineContext.onCompiled();
      pipelineContext.onCompiled = void 0;
    }
  };
  ThinEngine2.prototype._preparePipelineContext = function(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, rebuildRebind, defines, transformFeedbackVaryings, key) {
    var webGLRenderingState = pipelineContext;
    if (createAsRaw) {
      webGLRenderingState.program = this.createRawShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, void 0, transformFeedbackVaryings);
    } else {
      webGLRenderingState.program = this.createShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, defines, void 0, transformFeedbackVaryings);
    }
    webGLRenderingState.program.__SPECTOR_rebuildProgram = rebuildRebind;
  };
  ThinEngine2.prototype._isRenderingStateCompiled = function(pipelineContext) {
    var webGLPipelineContext = pipelineContext;
    if (this._gl.getProgramParameter(webGLPipelineContext.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR)) {
      this._finalizePipelineContext(webGLPipelineContext);
      return true;
    }
    return false;
  };
  ThinEngine2.prototype._executeWhenRenderingStateIsCompiled = function(pipelineContext, action) {
    var webGLPipelineContext = pipelineContext;
    if (!webGLPipelineContext.isParallelCompiled) {
      action();
      return;
    }
    var oldHandler = webGLPipelineContext.onCompiled;
    if (oldHandler) {
      webGLPipelineContext.onCompiled = function() {
        oldHandler();
        action();
      };
    } else {
      webGLPipelineContext.onCompiled = action;
    }
  };
  ThinEngine2.prototype.getUniforms = function(pipelineContext, uniformsNames) {
    var results = new Array();
    var webGLPipelineContext = pipelineContext;
    for (var index = 0; index < uniformsNames.length; index++) {
      results.push(this._gl.getUniformLocation(webGLPipelineContext.program, uniformsNames[index]));
    }
    return results;
  };
  ThinEngine2.prototype.getAttributes = function(pipelineContext, attributesNames) {
    var results = [];
    var webGLPipelineContext = pipelineContext;
    for (var index = 0; index < attributesNames.length; index++) {
      try {
        results.push(this._gl.getAttribLocation(webGLPipelineContext.program, attributesNames[index]));
      } catch (e) {
        results.push(-1);
      }
    }
    return results;
  };
  ThinEngine2.prototype.enableEffect = function(effect) {
    effect = effect !== null && DrawWrapper.IsWrapper(effect) ? effect.effect : effect;
    if (!effect || effect === this._currentEffect) {
      return;
    }
    this._stencilStateComposer.stencilMaterial = void 0;
    effect = effect;
    this.bindSamplers(effect);
    this._currentEffect = effect;
    if (effect.onBind) {
      effect.onBind(effect);
    }
    if (effect._onBindObservable) {
      effect._onBindObservable.notifyObservers(effect);
    }
  };
  ThinEngine2.prototype.setInt = function(uniform, value) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1i(uniform, value);
    return true;
  };
  ThinEngine2.prototype.setInt2 = function(uniform, x, y) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform2i(uniform, x, y);
    return true;
  };
  ThinEngine2.prototype.setInt3 = function(uniform, x, y, z) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform3i(uniform, x, y, z);
    return true;
  };
  ThinEngine2.prototype.setInt4 = function(uniform, x, y, z, w) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform4i(uniform, x, y, z, w);
    return true;
  };
  ThinEngine2.prototype.setIntArray = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1iv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setIntArray2 = function(uniform, array) {
    if (!uniform || array.length % 2 !== 0) {
      return false;
    }
    this._gl.uniform2iv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setIntArray3 = function(uniform, array) {
    if (!uniform || array.length % 3 !== 0) {
      return false;
    }
    this._gl.uniform3iv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setIntArray4 = function(uniform, array) {
    if (!uniform || array.length % 4 !== 0) {
      return false;
    }
    this._gl.uniform4iv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setArray = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    if (array.length < 1) {
      return false;
    }
    this._gl.uniform1fv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setArray2 = function(uniform, array) {
    if (!uniform || array.length % 2 !== 0) {
      return false;
    }
    this._gl.uniform2fv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setArray3 = function(uniform, array) {
    if (!uniform || array.length % 3 !== 0) {
      return false;
    }
    this._gl.uniform3fv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setArray4 = function(uniform, array) {
    if (!uniform || array.length % 4 !== 0) {
      return false;
    }
    this._gl.uniform4fv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setMatrices = function(uniform, matrices) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix4fv(uniform, false, matrices);
    return true;
  };
  ThinEngine2.prototype.setMatrix3x3 = function(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix3fv(uniform, false, matrix);
    return true;
  };
  ThinEngine2.prototype.setMatrix2x2 = function(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix2fv(uniform, false, matrix);
    return true;
  };
  ThinEngine2.prototype.setFloat = function(uniform, value) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1f(uniform, value);
    return true;
  };
  ThinEngine2.prototype.setFloat2 = function(uniform, x, y) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform2f(uniform, x, y);
    return true;
  };
  ThinEngine2.prototype.setFloat3 = function(uniform, x, y, z) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform3f(uniform, x, y, z);
    return true;
  };
  ThinEngine2.prototype.setFloat4 = function(uniform, x, y, z, w) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform4f(uniform, x, y, z, w);
    return true;
  };
  ThinEngine2.prototype.applyStates = function() {
    this._depthCullingState.apply(this._gl);
    this._stencilStateComposer.apply(this._gl);
    this._alphaState.apply(this._gl);
    if (this._colorWriteChanged) {
      this._colorWriteChanged = false;
      var enable = this._colorWrite;
      this._gl.colorMask(enable, enable, enable, enable);
    }
  };
  ThinEngine2.prototype.setColorWrite = function(enable) {
    if (enable !== this._colorWrite) {
      this._colorWriteChanged = true;
      this._colorWrite = enable;
    }
  };
  ThinEngine2.prototype.getColorWrite = function() {
    return this._colorWrite;
  };
  Object.defineProperty(ThinEngine2.prototype, "depthCullingState", {
    get: function() {
      return this._depthCullingState;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "alphaState", {
    get: function() {
      return this._alphaState;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "stencilState", {
    get: function() {
      return this._stencilState;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "stencilStateComposer", {
    get: function() {
      return this._stencilStateComposer;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype.clearInternalTexturesCache = function() {
    this._internalTexturesCache = [];
  };
  ThinEngine2.prototype.wipeCaches = function(bruteForce) {
    if (this.preventCacheWipeBetweenFrames && !bruteForce) {
      return;
    }
    this._currentEffect = null;
    this._viewportCached.x = 0;
    this._viewportCached.y = 0;
    this._viewportCached.z = 0;
    this._viewportCached.w = 0;
    this._unbindVertexArrayObject();
    if (bruteForce) {
      this._currentProgram = null;
      this.resetTextureCache();
      this._stencilStateComposer.reset();
      this._depthCullingState.reset();
      this._depthCullingState.depthFunc = this._gl.LEQUAL;
      this._alphaState.reset();
      this._alphaMode = 1;
      this._alphaEquation = 0;
      this._colorWrite = true;
      this._colorWriteChanged = true;
      this._unpackFlipYCached = null;
      this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
      this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
      this._mustWipeVertexAttributes = true;
      this.unbindAllAttributes();
    }
    this._resetVertexBufferBinding();
    this._cachedIndexBuffer = null;
    this._cachedEffectForVertexBuffers = null;
    this.bindIndexBuffer(null);
  };
  ThinEngine2.prototype._getSamplingParameters = function(samplingMode, generateMipMaps) {
    var gl = this._gl;
    var magFilter = gl.NEAREST;
    var minFilter = gl.NEAREST;
    switch (samplingMode) {
      case 11:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_NEAREST;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 3:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_LINEAR;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 8:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_LINEAR;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 4:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_NEAREST;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 5:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_NEAREST;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 6:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_LINEAR;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 7:
        magFilter = gl.NEAREST;
        minFilter = gl.LINEAR;
        break;
      case 1:
        magFilter = gl.NEAREST;
        minFilter = gl.NEAREST;
        break;
      case 9:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_NEAREST;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 10:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_LINEAR;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 2:
        magFilter = gl.LINEAR;
        minFilter = gl.LINEAR;
        break;
      case 12:
        magFilter = gl.LINEAR;
        minFilter = gl.NEAREST;
        break;
    }
    return {
      min: minFilter,
      mag: magFilter
    };
  };
  ThinEngine2.prototype._createTexture = function() {
    var texture = this._gl.createTexture();
    if (!texture) {
      throw new Error("Unable to create texture");
    }
    return texture;
  };
  ThinEngine2.prototype._createHardwareTexture = function() {
    return new WebGLHardwareTexture(this._createTexture(), this._gl);
  };
  ThinEngine2.prototype._createInternalTexture = function(size, options, delayGPUTextureCreation, source) {
    if (source === void 0) {
      source = InternalTextureSource.Unknown;
    }
    var fullOptions = {};
    if (options !== void 0 && typeof options === "object") {
      fullOptions.generateMipMaps = options.generateMipMaps;
      fullOptions.type = options.type === void 0 ? 0 : options.type;
      fullOptions.samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
      fullOptions.format = options.format === void 0 ? 5 : options.format;
    } else {
      fullOptions.generateMipMaps = options;
      fullOptions.type = 0;
      fullOptions.samplingMode = 3;
      fullOptions.format = 5;
    }
    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    }
    if (fullOptions.type === 1 && !this._caps.textureFloat) {
      fullOptions.type = 0;
      Logger.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE");
    }
    var gl = this._gl;
    var texture = new InternalTexture(this, source);
    var width = size.width || size;
    var height = size.height || size;
    var layers = size.layers || 0;
    var filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps ? true : false);
    var target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
    var sizedFormat = this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format);
    var internalFormat = this._getInternalFormat(fullOptions.format);
    var type = this._getWebGLTextureType(fullOptions.type);
    this._bindTextureDirectly(target, texture);
    if (layers !== 0) {
      texture.is2DArray = true;
      gl.texImage3D(target, 0, sizedFormat, width, height, layers, 0, internalFormat, type, null);
    } else {
      gl.texImage2D(target, 0, sizedFormat, width, height, 0, internalFormat, type, null);
    }
    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);
    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (fullOptions.generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.depth = layers;
    texture.isReady = true;
    texture.samples = 1;
    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
    texture.samplingMode = fullOptions.samplingMode;
    texture.type = fullOptions.type;
    texture.format = fullOptions.format;
    this._internalTexturesCache.push(texture);
    return texture;
  };
  ThinEngine2.prototype._getUseSRGBBuffer = function(useSRGBBuffer, noMipmap) {
    return useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || noMipmap);
  };
  ThinEngine2.prototype._createTextureBase = function(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, prepareTexture, prepareTextureProcessFunction, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer) {
    var _this = this;
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (fallback === void 0) {
      fallback = null;
    }
    if (format === void 0) {
      format = null;
    }
    if (forcedExtension === void 0) {
      forcedExtension = null;
    }
    url = url || "";
    var fromData = url.substr(0, 5) === "data:";
    var fromBlob = url.substr(0, 5) === "blob:";
    var isBase64 = fromData && url.indexOf(";base64,") !== -1;
    var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);
    var originalUrl = url;
    if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {
      url = this._transformTextureUrl(url);
    }
    if (originalUrl !== url) {
      texture._originalUrl = originalUrl;
    }
    var lastDot = url.lastIndexOf(".");
    var extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
    var loader = null;
    var queryStringIndex = extension.indexOf("?");
    if (queryStringIndex > -1) {
      extension = extension.split("?")[0];
    }
    for (var _i = 0, _a = ThinEngine2._TextureLoaders; _i < _a.length; _i++) {
      var availableLoader = _a[_i];
      if (availableLoader.canLoad(extension, mimeType)) {
        loader = availableLoader;
        break;
      }
    }
    if (scene) {
      scene._addPendingData(texture);
    }
    texture.url = url;
    texture.generateMipMaps = !noMipmap;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    texture._useSRGBBuffer = this._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);
    if (!this._doNotHandleContextLost) {
      texture._buffer = buffer;
    }
    var onLoadObserver = null;
    if (onLoad && !fallback) {
      onLoadObserver = texture.onLoadedObservable.add(onLoad);
    }
    if (!fallback) {
      this._internalTexturesCache.push(texture);
    }
    var onInternalError = function(message, exception) {
      if (scene) {
        scene._removePendingData(texture);
      }
      if (url === originalUrl) {
        if (onLoadObserver) {
          texture.onLoadedObservable.remove(onLoadObserver);
        }
        if (EngineStore.UseFallbackTexture) {
          _this._createTextureBase(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, prepareTexture, prepareTextureProcessFunction, buffer, texture);
        }
        message = (message || "Unknown error") + (EngineStore.UseFallbackTexture ? " - Fallback texture was used" : "");
        texture.onErrorObservable.notifyObservers({ message, exception });
        if (onError) {
          onError(message, exception);
        }
      } else {
        Logger.Warn("Failed to load ".concat(url, ", falling back to ").concat(originalUrl));
        _this._createTextureBase(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, prepareTexture, prepareTextureProcessFunction, buffer, texture, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
      }
    };
    if (loader) {
      var callback_1 = function(data) {
        loader.loadData(data, texture, function(width, height, loadMipmap, isCompressed, done, loadFailed) {
          if (loadFailed) {
            onInternalError("TextureLoader failed to load data");
          } else {
            prepareTexture(texture, extension, scene, { width, height }, texture.invertY, !loadMipmap, isCompressed, function() {
              done();
              return false;
            }, samplingMode);
          }
        }, loaderOptions);
      };
      if (!buffer) {
        this._loadFile(url, function(data) {
          return callback_1(new Uint8Array(data));
        }, void 0, scene ? scene.offlineProvider : void 0, true, function(request, exception) {
          onInternalError("Unable to load " + (request ? request.responseURL : url, exception));
        });
      } else {
        if (buffer instanceof ArrayBuffer) {
          callback_1(new Uint8Array(buffer));
        } else if (ArrayBuffer.isView(buffer)) {
          callback_1(buffer);
        } else {
          if (onError) {
            onError("Unable to load: only ArrayBuffer or ArrayBufferView is supported", null);
          }
        }
      }
    } else {
      var onload_1 = function(img) {
        if (fromBlob && !_this._doNotHandleContextLost) {
          texture._buffer = img;
        }
        prepareTexture(texture, extension, scene, img, texture.invertY, noMipmap, false, prepareTextureProcessFunction, samplingMode);
      };
      if (!fromData || isBase64) {
        if (buffer && (typeof buffer.decoding === "string" || buffer.close)) {
          onload_1(buffer);
        } else {
          ThinEngine2._FileToolsLoadImage(url, onload_1, onInternalError, scene ? scene.offlineProvider : null, mimeType, texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0);
        }
      } else if (typeof buffer === "string" || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer) || buffer instanceof Blob) {
        ThinEngine2._FileToolsLoadImage(buffer, onload_1, onInternalError, scene ? scene.offlineProvider : null, mimeType, texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0);
      } else if (buffer) {
        onload_1(buffer);
      }
    }
    return texture;
  };
  ThinEngine2.prototype.createTexture = function(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, creationFlags, useSRGBBuffer) {
    var _this = this;
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (fallback === void 0) {
      fallback = null;
    }
    if (format === void 0) {
      format = null;
    }
    if (forcedExtension === void 0) {
      forcedExtension = null;
    }
    return this._createTextureBase(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, this._prepareWebGLTexture.bind(this), function(potWidth, potHeight, img, extension, texture, continuationCallback) {
      var gl = _this._gl;
      var isPot = img.width === potWidth && img.height === potHeight;
      var internalFormat = format ? _this._getInternalFormat(format, texture._useSRGBBuffer) : extension === ".jpg" && !texture._useSRGBBuffer ? gl.RGB : texture._useSRGBBuffer ? gl.SRGB8_ALPHA8 : gl.RGBA;
      var texelFormat = format ? _this._getInternalFormat(format) : extension === ".jpg" && !texture._useSRGBBuffer ? gl.RGB : gl.RGBA;
      if (texture._useSRGBBuffer && _this.webGLVersion === 1) {
        texelFormat = internalFormat;
      }
      if (isPot) {
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, img);
        return false;
      }
      var maxTextureSize = _this._caps.maxTextureSize;
      if (img.width > maxTextureSize || img.height > maxTextureSize || !_this._supportsHardwareTextureRescaling) {
        _this._prepareWorkingCanvas();
        if (!_this._workingCanvas || !_this._workingContext) {
          return false;
        }
        _this._workingCanvas.width = potWidth;
        _this._workingCanvas.height = potHeight;
        _this._workingContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, potWidth, potHeight);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, _this._workingCanvas);
        texture.width = potWidth;
        texture.height = potHeight;
        return false;
      } else {
        var source_1 = new InternalTexture(_this, InternalTextureSource.Temp);
        _this._bindTextureDirectly(gl.TEXTURE_2D, source_1, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, img);
        _this._rescaleTexture(source_1, texture, scene, internalFormat, function() {
          _this._releaseTexture(source_1);
          _this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
          continuationCallback();
        });
      }
      return true;
    }, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
  };
  ThinEngine2._FileToolsLoadImage = function(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
    throw _WarnImport("FileTools");
  };
  ThinEngine2.prototype._rescaleTexture = function(source, destination, scene, internalFormat, onComplete) {
  };
  ThinEngine2.prototype.createRawTexture = function(data, width, height, format, generateMipMaps, invertY, samplingMode, compression, type) {
    throw _WarnImport("Engine.RawTexture");
  };
  ThinEngine2.prototype.createRawCubeTexture = function(data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {
    throw _WarnImport("Engine.RawTexture");
  };
  ThinEngine2.prototype.createRawTexture3D = function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {
    throw _WarnImport("Engine.RawTexture");
  };
  ThinEngine2.prototype.createRawTexture2DArray = function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {
    throw _WarnImport("Engine.RawTexture");
  };
  ThinEngine2.prototype._unpackFlipY = function(value) {
    if (this._unpackFlipYCached !== value) {
      this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, value ? 1 : 0);
      if (this.enableUnpackFlipYCached) {
        this._unpackFlipYCached = value;
      }
    }
  };
  ThinEngine2.prototype._getUnpackAlignement = function() {
    return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);
  };
  ThinEngine2.prototype._getTextureTarget = function(texture) {
    if (texture.isCube) {
      return this._gl.TEXTURE_CUBE_MAP;
    } else if (texture.is3D) {
      return this._gl.TEXTURE_3D;
    } else if (texture.is2DArray || texture.isMultiview) {
      return this._gl.TEXTURE_2D_ARRAY;
    }
    return this._gl.TEXTURE_2D;
  };
  ThinEngine2.prototype.updateTextureSamplingMode = function(samplingMode, texture, generateMipMaps) {
    if (generateMipMaps === void 0) {
      generateMipMaps = false;
    }
    var target = this._getTextureTarget(texture);
    var filters = this._getSamplingParameters(samplingMode, texture.generateMipMaps || generateMipMaps);
    this._setTextureParameterInteger(target, this._gl.TEXTURE_MAG_FILTER, filters.mag, texture);
    this._setTextureParameterInteger(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
    if (generateMipMaps) {
      texture.generateMipMaps = true;
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    texture.samplingMode = samplingMode;
  };
  ThinEngine2.prototype.updateTextureDimensions = function(texture, width, height, depth) {
  };
  ThinEngine2.prototype.updateTextureWrappingMode = function(texture, wrapU, wrapV, wrapR) {
    if (wrapV === void 0) {
      wrapV = null;
    }
    if (wrapR === void 0) {
      wrapR = null;
    }
    var target = this._getTextureTarget(texture);
    if (wrapU !== null) {
      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(wrapU), texture);
      texture._cachedWrapU = wrapU;
    }
    if (wrapV !== null) {
      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(wrapV), texture);
      texture._cachedWrapV = wrapV;
    }
    if ((texture.is2DArray || texture.is3D) && wrapR !== null) {
      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(wrapR), texture);
      texture._cachedWrapR = wrapR;
    }
    this._bindTextureDirectly(target, null);
  };
  ThinEngine2.prototype._setupDepthStencilTexture = function(internalTexture, size, generateStencil, bilinearFiltering, comparisonFunction, samples) {
    if (samples === void 0) {
      samples = 1;
    }
    var width = size.width || size;
    var height = size.height || size;
    var layers = size.layers || 0;
    internalTexture.baseWidth = width;
    internalTexture.baseHeight = height;
    internalTexture.width = width;
    internalTexture.height = height;
    internalTexture.is2DArray = layers > 0;
    internalTexture.depth = layers;
    internalTexture.isReady = true;
    internalTexture.samples = samples;
    internalTexture.generateMipMaps = false;
    internalTexture.samplingMode = bilinearFiltering ? 2 : 1;
    internalTexture.type = 0;
    internalTexture._comparisonFunction = comparisonFunction;
    var gl = this._gl;
    var target = this._getTextureTarget(internalTexture);
    var samplingParameters = this._getSamplingParameters(internalTexture.samplingMode, false);
    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, samplingParameters.mag);
    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, samplingParameters.min);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (comparisonFunction === 0) {
      gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, 515);
      gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.NONE);
    } else {
      gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
      gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
    }
  };
  ThinEngine2.prototype._uploadCompressedDataToTextureDirectly = function(texture, internalFormat, width, height, data, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    var gl = this._gl;
    var target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    if (texture._useSRGBBuffer) {
      switch (internalFormat) {
        case 36492:
          internalFormat = gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
          break;
        case 37808:
          internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
          break;
        case 33776:
          if (this._caps.s3tc_srgb) {
            internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        case 33779:
          if (this._caps.s3tc_srgb) {
            internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        default:
          texture._useSRGBBuffer = false;
          break;
      }
    }
    this._gl.compressedTexImage2D(target, lod, internalFormat, width, height, 0, data);
  };
  ThinEngine2.prototype._uploadDataToTextureDirectly = function(texture, imageData, faceIndex, lod, babylonInternalFormat, useTextureWidthAndHeight) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    if (useTextureWidthAndHeight === void 0) {
      useTextureWidthAndHeight = false;
    }
    var gl = this._gl;
    var textureType = this._getWebGLTextureType(texture.type);
    var format = this._getInternalFormat(texture.format);
    var internalFormat = babylonInternalFormat === void 0 ? this._getRGBABufferInternalSizedFormat(texture.type, texture.format, texture._useSRGBBuffer) : this._getInternalFormat(babylonInternalFormat, texture._useSRGBBuffer);
    this._unpackFlipY(texture.invertY);
    var target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    var lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);
    var lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);
    var width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));
    var height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));
    gl.texImage2D(target, lod, internalFormat, width, height, 0, format, textureType, imageData);
  };
  ThinEngine2.prototype.updateTextureData = function(texture, imageData, xOffset, yOffset, width, height, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    var gl = this._gl;
    var textureType = this._getWebGLTextureType(texture.type);
    var format = this._getInternalFormat(texture.format);
    this._unpackFlipY(texture.invertY);
    var target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    gl.texSubImage2D(target, lod, xOffset, yOffset, width, height, format, textureType, imageData);
  };
  ThinEngine2.prototype._uploadArrayBufferViewToTexture = function(texture, imageData, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    var gl = this._gl;
    var bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    this._bindTextureDirectly(bindTarget, texture, true);
    this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);
    this._bindTextureDirectly(bindTarget, null, true);
  };
  ThinEngine2.prototype._prepareWebGLTextureContinuation = function(texture, scene, noMipmap, isCompressed, samplingMode) {
    var gl = this._gl;
    if (!gl) {
      return;
    }
    var filters = this._getSamplingParameters(samplingMode, !noMipmap);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);
    if (!noMipmap && !isCompressed) {
      gl.generateMipmap(gl.TEXTURE_2D);
    }
    this._bindTextureDirectly(gl.TEXTURE_2D, null);
    if (scene) {
      scene._removePendingData(texture);
    }
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
  };
  ThinEngine2.prototype._prepareWebGLTexture = function(texture, extension, scene, img, invertY, noMipmap, isCompressed, processFunction, samplingMode) {
    var _this = this;
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    var maxTextureSize = this.getCaps().maxTextureSize;
    var potWidth = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine2.GetExponentOfTwo(img.width, maxTextureSize) : img.width);
    var potHeight = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine2.GetExponentOfTwo(img.height, maxTextureSize) : img.height);
    var gl = this._gl;
    if (!gl) {
      return;
    }
    if (!texture._hardwareTexture) {
      if (scene) {
        scene._removePendingData(texture);
      }
      return;
    }
    this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
    this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
    texture.baseWidth = img.width;
    texture.baseHeight = img.height;
    texture.width = potWidth;
    texture.height = potHeight;
    texture.isReady = true;
    if (processFunction(potWidth, potHeight, img, extension, texture, function() {
      _this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
    })) {
      return;
    }
    this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
  };
  ThinEngine2.prototype._setupFramebufferDepthAttachments = function(generateStencilBuffer, generateDepthBuffer, width, height, samples) {
    if (samples === void 0) {
      samples = 1;
    }
    var gl = this._gl;
    if (generateStencilBuffer && generateDepthBuffer) {
      return this._createRenderBuffer(width, height, samples, gl.DEPTH_STENCIL, gl.DEPTH24_STENCIL8, gl.DEPTH_STENCIL_ATTACHMENT);
    }
    if (generateDepthBuffer) {
      var depthFormat = gl.DEPTH_COMPONENT16;
      if (this._webGLVersion > 1) {
        depthFormat = gl.DEPTH_COMPONENT32F;
      }
      return this._createRenderBuffer(width, height, samples, depthFormat, depthFormat, gl.DEPTH_ATTACHMENT);
    }
    if (generateStencilBuffer) {
      return this._createRenderBuffer(width, height, samples, gl.STENCIL_INDEX8, gl.STENCIL_INDEX8, gl.STENCIL_ATTACHMENT);
    }
    return null;
  };
  ThinEngine2.prototype._createRenderBuffer = function(width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer) {
    if (unbindBuffer === void 0) {
      unbindBuffer = true;
    }
    var gl = this._gl;
    var renderBuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
    if (samples > 1 && gl.renderbufferStorageMultisample) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, msInternalFormat, width, height);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
    }
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, renderBuffer);
    if (unbindBuffer) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }
    return renderBuffer;
  };
  ThinEngine2.prototype._releaseTexture = function(texture) {
    var _a;
    this._deleteTexture((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource);
    this.unbindAllTextures();
    var index = this._internalTexturesCache.indexOf(texture);
    if (index !== -1) {
      this._internalTexturesCache.splice(index, 1);
    }
    if (texture._lodTextureHigh) {
      texture._lodTextureHigh.dispose();
    }
    if (texture._lodTextureMid) {
      texture._lodTextureMid.dispose();
    }
    if (texture._lodTextureLow) {
      texture._lodTextureLow.dispose();
    }
    if (texture._irradianceTexture) {
      texture._irradianceTexture.dispose();
    }
  };
  ThinEngine2.prototype._releaseRenderTargetWrapper = function(rtWrapper) {
    var index = this._renderTargetWrapperCache.indexOf(rtWrapper);
    if (index !== -1) {
      this._renderTargetWrapperCache.splice(index, 1);
    }
  };
  ThinEngine2.prototype._deleteTexture = function(texture) {
    if (texture) {
      this._gl.deleteTexture(texture);
    }
  };
  ThinEngine2.prototype._setProgram = function(program) {
    if (this._currentProgram !== program) {
      this._gl.useProgram(program);
      this._currentProgram = program;
    }
  };
  ThinEngine2.prototype.bindSamplers = function(effect) {
    var webGLPipelineContext = effect.getPipelineContext();
    this._setProgram(webGLPipelineContext.program);
    var samplers = effect.getSamplers();
    for (var index = 0; index < samplers.length; index++) {
      var uniform = effect.getUniform(samplers[index]);
      if (uniform) {
        this._boundUniforms[index] = uniform;
      }
    }
    this._currentEffect = null;
  };
  ThinEngine2.prototype._activateCurrentTexture = function() {
    if (this._currentTextureChannel !== this._activeChannel) {
      this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel);
      this._currentTextureChannel = this._activeChannel;
    }
  };
  ThinEngine2.prototype._bindTextureDirectly = function(target, texture, forTextureDataUpdate, force) {
    var _a, _b;
    if (forTextureDataUpdate === void 0) {
      forTextureDataUpdate = false;
    }
    if (force === void 0) {
      force = false;
    }
    var wasPreviouslyBound = false;
    var isTextureForRendering = texture && texture._associatedChannel > -1;
    if (forTextureDataUpdate && isTextureForRendering) {
      this._activeChannel = texture._associatedChannel;
    }
    var currentTextureBound = this._boundTexturesCache[this._activeChannel];
    if (currentTextureBound !== texture || force) {
      this._activateCurrentTexture();
      if (texture && texture.isMultiview) {
        console.error(target, texture);
        throw "_bindTextureDirectly called with a multiview texture!";
      } else {
        this._gl.bindTexture(target, (_b = (_a = texture === null || texture === void 0 ? void 0 : texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource) !== null && _b !== void 0 ? _b : null);
      }
      this._boundTexturesCache[this._activeChannel] = texture;
      if (texture) {
        texture._associatedChannel = this._activeChannel;
      }
    } else if (forTextureDataUpdate) {
      wasPreviouslyBound = true;
      this._activateCurrentTexture();
    }
    if (isTextureForRendering && !forTextureDataUpdate) {
      this._bindSamplerUniformToChannel(texture._associatedChannel, this._activeChannel);
    }
    return wasPreviouslyBound;
  };
  ThinEngine2.prototype._bindTexture = function(channel, texture, name2) {
    if (channel === void 0) {
      return;
    }
    if (texture) {
      texture._associatedChannel = channel;
    }
    this._activeChannel = channel;
    var target = texture ? this._getTextureTarget(texture) : this._gl.TEXTURE_2D;
    this._bindTextureDirectly(target, texture);
  };
  ThinEngine2.prototype.unbindAllTextures = function() {
    for (var channel = 0; channel < this._maxSimultaneousTextures; channel++) {
      this._activeChannel = channel;
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
      if (this.webGLVersion > 1) {
        this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
        this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
      }
    }
  };
  ThinEngine2.prototype.setTexture = function(channel, uniform, texture, name2) {
    if (channel === void 0) {
      return;
    }
    if (uniform) {
      this._boundUniforms[channel] = uniform;
    }
    this._setTexture(channel, texture);
  };
  ThinEngine2.prototype._bindSamplerUniformToChannel = function(sourceSlot, destination) {
    var uniform = this._boundUniforms[sourceSlot];
    if (!uniform || uniform._currentState === destination) {
      return;
    }
    this._gl.uniform1i(uniform, destination);
    uniform._currentState = destination;
  };
  ThinEngine2.prototype._getTextureWrapMode = function(mode) {
    switch (mode) {
      case 1:
        return this._gl.REPEAT;
      case 0:
        return this._gl.CLAMP_TO_EDGE;
      case 2:
        return this._gl.MIRRORED_REPEAT;
    }
    return this._gl.REPEAT;
  };
  ThinEngine2.prototype._setTexture = function(channel, texture, isPartOfTextureArray, depthStencilTexture, name2) {
    if (isPartOfTextureArray === void 0) {
      isPartOfTextureArray = false;
    }
    if (depthStencilTexture === void 0) {
      depthStencilTexture = false;
    }
    if (!texture) {
      if (this._boundTexturesCache[channel] != null) {
        this._activeChannel = channel;
        this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
        if (this.webGLVersion > 1) {
          this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
          this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
        }
      }
      return false;
    }
    if (texture.video) {
      this._activeChannel = channel;
      texture.update();
    } else if (texture.delayLoadState === 4) {
      texture.delayLoad();
      return false;
    }
    var internalTexture;
    if (depthStencilTexture) {
      internalTexture = texture.depthStencilTexture;
    } else if (texture.isReady()) {
      internalTexture = texture.getInternalTexture();
    } else if (texture.isCube) {
      internalTexture = this.emptyCubeTexture;
    } else if (texture.is3D) {
      internalTexture = this.emptyTexture3D;
    } else if (texture.is2DArray) {
      internalTexture = this.emptyTexture2DArray;
    } else {
      internalTexture = this.emptyTexture;
    }
    if (!isPartOfTextureArray && internalTexture) {
      internalTexture._associatedChannel = channel;
    }
    var needToBind = true;
    if (this._boundTexturesCache[channel] === internalTexture) {
      if (!isPartOfTextureArray) {
        this._bindSamplerUniformToChannel(internalTexture._associatedChannel, channel);
      }
      needToBind = false;
    }
    this._activeChannel = channel;
    var target = this._getTextureTarget(internalTexture);
    if (needToBind) {
      this._bindTextureDirectly(target, internalTexture, isPartOfTextureArray);
    }
    if (internalTexture && !internalTexture.isMultiview) {
      if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {
        internalTexture._cachedCoordinatesMode = texture.coordinatesMode;
        var textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;
        texture.wrapU = textureWrapMode;
        texture.wrapV = textureWrapMode;
      }
      if (internalTexture._cachedWrapU !== texture.wrapU) {
        internalTexture._cachedWrapU = texture.wrapU;
        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(texture.wrapU), internalTexture);
      }
      if (internalTexture._cachedWrapV !== texture.wrapV) {
        internalTexture._cachedWrapV = texture.wrapV;
        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(texture.wrapV), internalTexture);
      }
      if (internalTexture.is3D && internalTexture._cachedWrapR !== texture.wrapR) {
        internalTexture._cachedWrapR = texture.wrapR;
        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(texture.wrapR), internalTexture);
      }
      this._setAnisotropicLevel(target, internalTexture, texture.anisotropicFilteringLevel);
    }
    return true;
  };
  ThinEngine2.prototype.setTextureArray = function(channel, uniform, textures, name2) {
    if (channel === void 0 || !uniform) {
      return;
    }
    if (!this._textureUnits || this._textureUnits.length !== textures.length) {
      this._textureUnits = new Int32Array(textures.length);
    }
    for (var i = 0; i < textures.length; i++) {
      var texture = textures[i].getInternalTexture();
      if (texture) {
        this._textureUnits[i] = channel + i;
        texture._associatedChannel = channel + i;
      } else {
        this._textureUnits[i] = -1;
      }
    }
    this._gl.uniform1iv(uniform, this._textureUnits);
    for (var index = 0; index < textures.length; index++) {
      this._setTexture(this._textureUnits[index], textures[index], true);
    }
  };
  ThinEngine2.prototype._setAnisotropicLevel = function(target, internalTexture, anisotropicFilteringLevel) {
    var anisotropicFilterExtension = this._caps.textureAnisotropicFilterExtension;
    if (internalTexture.samplingMode !== 11 && internalTexture.samplingMode !== 3 && internalTexture.samplingMode !== 2) {
      anisotropicFilteringLevel = 1;
    }
    if (anisotropicFilterExtension && internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {
      this._setTextureParameterFloat(target, anisotropicFilterExtension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy), internalTexture);
      internalTexture._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
    }
  };
  ThinEngine2.prototype._setTextureParameterFloat = function(target, parameter, value, texture) {
    this._bindTextureDirectly(target, texture, true, true);
    this._gl.texParameterf(target, parameter, value);
  };
  ThinEngine2.prototype._setTextureParameterInteger = function(target, parameter, value, texture) {
    if (texture) {
      this._bindTextureDirectly(target, texture, true, true);
    }
    this._gl.texParameteri(target, parameter, value);
  };
  ThinEngine2.prototype.unbindAllAttributes = function() {
    if (this._mustWipeVertexAttributes) {
      this._mustWipeVertexAttributes = false;
      for (var i = 0; i < this._caps.maxVertexAttribs; i++) {
        this.disableAttributeByIndex(i);
      }
      return;
    }
    for (var i = 0, ul = this._vertexAttribArraysEnabled.length; i < ul; i++) {
      if (i >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[i]) {
        continue;
      }
      this.disableAttributeByIndex(i);
    }
  };
  ThinEngine2.prototype.releaseEffects = function() {
    for (var name2 in this._compiledEffects) {
      var webGLPipelineContext = this._compiledEffects[name2].getPipelineContext();
      this._deletePipelineContext(webGLPipelineContext);
    }
    this._compiledEffects = {};
  };
  ThinEngine2.prototype.dispose = function() {
    var _a;
    this.stopRenderLoop();
    if (this.onBeforeTextureInitObservable) {
      this.onBeforeTextureInitObservable.clear();
    }
    if (this._emptyTexture) {
      this._releaseTexture(this._emptyTexture);
      this._emptyTexture = null;
    }
    if (this._emptyCubeTexture) {
      this._releaseTexture(this._emptyCubeTexture);
      this._emptyCubeTexture = null;
    }
    if (this._dummyFramebuffer) {
      this._gl.deleteFramebuffer(this._dummyFramebuffer);
    }
    this.releaseEffects();
    (_a = this.releaseComputeEffects) === null || _a === void 0 ? void 0 : _a.call(this);
    this.unbindAllAttributes();
    this._boundUniforms = [];
    if (IsWindowObjectExist()) {
      if (this._renderingCanvas) {
        if (!this._doNotHandleContextLost) {
          this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost);
          this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored);
        }
        window.removeEventListener("resize", this._checkForMobile);
      }
    }
    this._workingCanvas = null;
    this._workingContext = null;
    this._currentBufferPointers = [];
    this._renderingCanvas = null;
    this._currentProgram = null;
    this._boundRenderFunction = null;
    Effect.ResetCache();
    for (var _i = 0, _b = this._activeRequests; _i < _b.length; _i++) {
      var request = _b[_i];
      request.abort();
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
  };
  ThinEngine2.prototype.attachContextLostEvent = function(callback) {
    if (this._renderingCanvas) {
      this._renderingCanvas.addEventListener("webglcontextlost", callback, false);
    }
  };
  ThinEngine2.prototype.attachContextRestoredEvent = function(callback) {
    if (this._renderingCanvas) {
      this._renderingCanvas.addEventListener("webglcontextrestored", callback, false);
    }
  };
  ThinEngine2.prototype.getError = function() {
    return this._gl.getError();
  };
  ThinEngine2.prototype._canRenderToFloatFramebuffer = function() {
    if (this._webGLVersion > 1) {
      return this._caps.colorBufferFloat;
    }
    return this._canRenderToFramebuffer(1);
  };
  ThinEngine2.prototype._canRenderToHalfFloatFramebuffer = function() {
    if (this._webGLVersion > 1) {
      return this._caps.colorBufferFloat;
    }
    return this._canRenderToFramebuffer(2);
  };
  ThinEngine2.prototype._canRenderToFramebuffer = function(type) {
    var gl = this._gl;
    while (gl.getError() !== gl.NO_ERROR) {
    }
    var successful = true;
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), 1, 1, 0, gl.RGBA, this._getWebGLTextureType(type), null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    var fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    successful = successful && status === gl.FRAMEBUFFER_COMPLETE;
    successful = successful && gl.getError() === gl.NO_ERROR;
    if (successful) {
      gl.clear(gl.COLOR_BUFFER_BIT);
      successful = successful && gl.getError() === gl.NO_ERROR;
    }
    if (successful) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      var readFormat = gl.RGBA;
      var readType = gl.UNSIGNED_BYTE;
      var buffer = new Uint8Array(4);
      gl.readPixels(0, 0, 1, 1, readFormat, readType, buffer);
      successful = successful && gl.getError() === gl.NO_ERROR;
    }
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(fb);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    while (!successful && gl.getError() !== gl.NO_ERROR) {
    }
    return successful;
  };
  ThinEngine2.prototype._getWebGLTextureType = function(type) {
    if (this._webGLVersion === 1) {
      switch (type) {
        case 1:
          return this._gl.FLOAT;
        case 2:
          return this._gl.HALF_FLOAT_OES;
        case 0:
          return this._gl.UNSIGNED_BYTE;
        case 8:
          return this._gl.UNSIGNED_SHORT_4_4_4_4;
        case 9:
          return this._gl.UNSIGNED_SHORT_5_5_5_1;
        case 10:
          return this._gl.UNSIGNED_SHORT_5_6_5;
      }
      return this._gl.UNSIGNED_BYTE;
    }
    switch (type) {
      case 3:
        return this._gl.BYTE;
      case 0:
        return this._gl.UNSIGNED_BYTE;
      case 4:
        return this._gl.SHORT;
      case 5:
        return this._gl.UNSIGNED_SHORT;
      case 6:
        return this._gl.INT;
      case 7:
        return this._gl.UNSIGNED_INT;
      case 1:
        return this._gl.FLOAT;
      case 2:
        return this._gl.HALF_FLOAT;
      case 8:
        return this._gl.UNSIGNED_SHORT_4_4_4_4;
      case 9:
        return this._gl.UNSIGNED_SHORT_5_5_5_1;
      case 10:
        return this._gl.UNSIGNED_SHORT_5_6_5;
      case 11:
        return this._gl.UNSIGNED_INT_2_10_10_10_REV;
      case 12:
        return this._gl.UNSIGNED_INT_24_8;
      case 13:
        return this._gl.UNSIGNED_INT_10F_11F_11F_REV;
      case 14:
        return this._gl.UNSIGNED_INT_5_9_9_9_REV;
      case 15:
        return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
    }
    return this._gl.UNSIGNED_BYTE;
  };
  ThinEngine2.prototype._getInternalFormat = function(format, useSRGBBuffer) {
    if (useSRGBBuffer === void 0) {
      useSRGBBuffer = false;
    }
    var internalFormat = useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
    switch (format) {
      case 0:
        internalFormat = this._gl.ALPHA;
        break;
      case 1:
        internalFormat = this._gl.LUMINANCE;
        break;
      case 2:
        internalFormat = this._gl.LUMINANCE_ALPHA;
        break;
      case 6:
        internalFormat = this._gl.RED;
        break;
      case 7:
        internalFormat = this._gl.RG;
        break;
      case 4:
        internalFormat = useSRGBBuffer ? this._gl.SRGB : this._gl.RGB;
        break;
      case 5:
        internalFormat = useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
        break;
    }
    if (this._webGLVersion > 1) {
      switch (format) {
        case 8:
          internalFormat = this._gl.RED_INTEGER;
          break;
        case 9:
          internalFormat = this._gl.RG_INTEGER;
          break;
        case 10:
          internalFormat = this._gl.RGB_INTEGER;
          break;
        case 11:
          internalFormat = this._gl.RGBA_INTEGER;
          break;
      }
    }
    return internalFormat;
  };
  ThinEngine2.prototype._getRGBABufferInternalSizedFormat = function(type, format, useSRGBBuffer) {
    if (useSRGBBuffer === void 0) {
      useSRGBBuffer = false;
    }
    if (this._webGLVersion === 1) {
      if (format !== void 0) {
        switch (format) {
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          case 4:
            return useSRGBBuffer ? this._gl.SRGB : this._gl.RGB;
        }
      }
      return this._gl.RGBA;
    }
    switch (type) {
      case 3:
        switch (format) {
          case 6:
            return this._gl.R8_SNORM;
          case 7:
            return this._gl.RG8_SNORM;
          case 4:
            return this._gl.RGB8_SNORM;
          case 8:
            return this._gl.R8I;
          case 9:
            return this._gl.RG8I;
          case 10:
            return this._gl.RGB8I;
          case 11:
            return this._gl.RGBA8I;
          default:
            return this._gl.RGBA8_SNORM;
        }
      case 0:
        switch (format) {
          case 6:
            return this._gl.R8;
          case 7:
            return this._gl.RG8;
          case 4:
            return useSRGBBuffer ? this._gl.SRGB8 : this._gl.RGB8;
          case 5:
            return useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
          case 8:
            return this._gl.R8UI;
          case 9:
            return this._gl.RG8UI;
          case 10:
            return this._gl.RGB8UI;
          case 11:
            return this._gl.RGBA8UI;
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          default:
            return this._gl.RGBA8;
        }
      case 4:
        switch (format) {
          case 8:
            return this._gl.R16I;
          case 9:
            return this._gl.RG16I;
          case 10:
            return this._gl.RGB16I;
          case 11:
            return this._gl.RGBA16I;
          default:
            return this._gl.RGBA16I;
        }
      case 5:
        switch (format) {
          case 8:
            return this._gl.R16UI;
          case 9:
            return this._gl.RG16UI;
          case 10:
            return this._gl.RGB16UI;
          case 11:
            return this._gl.RGBA16UI;
          default:
            return this._gl.RGBA16UI;
        }
      case 6:
        switch (format) {
          case 8:
            return this._gl.R32I;
          case 9:
            return this._gl.RG32I;
          case 10:
            return this._gl.RGB32I;
          case 11:
            return this._gl.RGBA32I;
          default:
            return this._gl.RGBA32I;
        }
      case 7:
        switch (format) {
          case 8:
            return this._gl.R32UI;
          case 9:
            return this._gl.RG32UI;
          case 10:
            return this._gl.RGB32UI;
          case 11:
            return this._gl.RGBA32UI;
          default:
            return this._gl.RGBA32UI;
        }
      case 1:
        switch (format) {
          case 6:
            return this._gl.R32F;
          case 7:
            return this._gl.RG32F;
          case 4:
            return this._gl.RGB32F;
          case 5:
            return this._gl.RGBA32F;
          default:
            return this._gl.RGBA32F;
        }
      case 2:
        switch (format) {
          case 6:
            return this._gl.R16F;
          case 7:
            return this._gl.RG16F;
          case 4:
            return this._gl.RGB16F;
          case 5:
            return this._gl.RGBA16F;
          default:
            return this._gl.RGBA16F;
        }
      case 10:
        return this._gl.RGB565;
      case 13:
        return this._gl.R11F_G11F_B10F;
      case 14:
        return this._gl.RGB9_E5;
      case 8:
        return this._gl.RGBA4;
      case 9:
        return this._gl.RGB5_A1;
      case 11:
        switch (format) {
          case 5:
            return this._gl.RGB10_A2;
          case 11:
            return this._gl.RGB10_A2UI;
          default:
            return this._gl.RGB10_A2;
        }
    }
    return useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
  };
  ThinEngine2.prototype._getRGBAMultiSampleBufferFormat = function(type) {
    if (type === 1) {
      return this._gl.RGBA32F;
    } else if (type === 2) {
      return this._gl.RGBA16F;
    }
    return this._gl.RGBA8;
  };
  ThinEngine2.prototype._loadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    var _this = this;
    var request = ThinEngine2._FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
    this._activeRequests.push(request);
    request.onCompleteObservable.add(function(request2) {
      _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
    });
    return request;
  };
  ThinEngine2._FileToolsLoadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    throw _WarnImport("FileTools");
  };
  ThinEngine2.prototype.readPixels = function(x, y, width, height, hasAlpha, flushRenderer) {
    if (hasAlpha === void 0) {
      hasAlpha = true;
    }
    if (flushRenderer === void 0) {
      flushRenderer = true;
    }
    var numChannels = hasAlpha ? 4 : 3;
    var format = hasAlpha ? this._gl.RGBA : this._gl.RGB;
    var data = new Uint8Array(height * width * numChannels);
    if (flushRenderer) {
      this.flushFramebuffer();
    }
    this._gl.readPixels(x, y, width, height, format, this._gl.UNSIGNED_BYTE, data);
    return Promise.resolve(data);
  };
  Object.defineProperty(ThinEngine2, "IsSupportedAsync", {
    get: function() {
      return Promise.resolve(this.isSupported());
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2, "IsSupported", {
    get: function() {
      return this.isSupported();
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.isSupported = function() {
    if (this._HasMajorPerformanceCaveat !== null) {
      return !this._HasMajorPerformanceCaveat;
    }
    if (this._IsSupported === null) {
      try {
        var tempcanvas = this._createCanvas(1, 1);
        var gl = tempcanvas.getContext("webgl") || tempcanvas.getContext("experimental-webgl");
        this._IsSupported = gl != null && !!window.WebGLRenderingContext;
      } catch (e) {
        this._IsSupported = false;
      }
    }
    return this._IsSupported;
  };
  Object.defineProperty(ThinEngine2, "HasMajorPerformanceCaveat", {
    get: function() {
      if (this._HasMajorPerformanceCaveat === null) {
        try {
          var tempcanvas = this._createCanvas(1, 1);
          var gl = tempcanvas.getContext("webgl", { failIfMajorPerformanceCaveat: true }) || tempcanvas.getContext("experimental-webgl", { failIfMajorPerformanceCaveat: true });
          this._HasMajorPerformanceCaveat = !gl;
        } catch (e) {
          this._HasMajorPerformanceCaveat = false;
        }
      }
      return this._HasMajorPerformanceCaveat;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.CeilingPOT = function(x) {
    x--;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x++;
    return x;
  };
  ThinEngine2.FloorPOT = function(x) {
    x = x | x >> 1;
    x = x | x >> 2;
    x = x | x >> 4;
    x = x | x >> 8;
    x = x | x >> 16;
    return x - (x >> 1);
  };
  ThinEngine2.NearestPOT = function(x) {
    var c = ThinEngine2.CeilingPOT(x);
    var f = ThinEngine2.FloorPOT(x);
    return c - x > x - f ? f : c;
  };
  ThinEngine2.GetExponentOfTwo = function(value, max, mode) {
    if (mode === void 0) {
      mode = 2;
    }
    var pot;
    switch (mode) {
      case 1:
        pot = ThinEngine2.FloorPOT(value);
        break;
      case 2:
        pot = ThinEngine2.NearestPOT(value);
        break;
      case 3:
      default:
        pot = ThinEngine2.CeilingPOT(value);
        break;
    }
    return Math.min(pot, max);
  };
  ThinEngine2.QueueNewFrame = function(func, requester) {
    if (!IsWindowObjectExist()) {
      if (typeof requestAnimationFrame !== "undefined") {
        return requestAnimationFrame(func);
      }
      return setTimeout(func, 16);
    }
    if (!requester) {
      requester = window;
    }
    if (requester.requestPostAnimationFrame) {
      return requester.requestPostAnimationFrame(func);
    } else if (requester.requestAnimationFrame) {
      return requester.requestAnimationFrame(func);
    } else if (requester.msRequestAnimationFrame) {
      return requester.msRequestAnimationFrame(func);
    } else if (requester.webkitRequestAnimationFrame) {
      return requester.webkitRequestAnimationFrame(func);
    } else if (requester.mozRequestAnimationFrame) {
      return requester.mozRequestAnimationFrame(func);
    } else if (requester.oRequestAnimationFrame) {
      return requester.oRequestAnimationFrame(func);
    } else {
      return window.setTimeout(func, 16);
    }
  };
  ThinEngine2.prototype.getHostDocument = function() {
    if (this._renderingCanvas && this._renderingCanvas.ownerDocument) {
      return this._renderingCanvas.ownerDocument;
    }
    return document;
  };
  ThinEngine2.ExceptionList = [
    { key: "Chrome/63.0", capture: "63\\.0\\.3239\\.(\\d+)", captureConstraint: 108, targets: ["uniformBuffer"] },
    { key: "Firefox/58", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    { key: "Firefox/59", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    { key: "Chrome/72.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Chrome/73.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Chrome/74.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Mac OS.+Chrome/71", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Mac OS.+Chrome/72", capture: null, captureConstraint: null, targets: ["vao"] }
  ];
  ThinEngine2._TextureLoaders = [];
  ThinEngine2.CollisionsEpsilon = 1e-3;
  ThinEngine2._IsSupported = null;
  ThinEngine2._HasMajorPerformanceCaveat = null;
  return ThinEngine2;
}();
var PrecisionDate = function() {
  function PrecisionDate2() {
  }
  Object.defineProperty(PrecisionDate2, "Now", {
    get: function() {
      if (DomManagement.IsWindowObjectExist() && window.performance && window.performance.now) {
        return window.performance.now();
      }
      return Date.now();
    },
    enumerable: false,
    configurable: true
  });
  return PrecisionDate2;
}();
var PerformanceMonitor = function() {
  function PerformanceMonitor2(frameSampleSize) {
    if (frameSampleSize === void 0) {
      frameSampleSize = 30;
    }
    this._enabled = true;
    this._rollingFrameTime = new RollingAverage(frameSampleSize);
  }
  PerformanceMonitor2.prototype.sampleFrame = function(timeMs) {
    if (timeMs === void 0) {
      timeMs = PrecisionDate.Now;
    }
    if (!this._enabled) {
      return;
    }
    if (this._lastFrameTimeMs != null) {
      var dt = timeMs - this._lastFrameTimeMs;
      this._rollingFrameTime.add(dt);
    }
    this._lastFrameTimeMs = timeMs;
  };
  Object.defineProperty(PerformanceMonitor2.prototype, "averageFrameTime", {
    get: function() {
      return this._rollingFrameTime.average;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "averageFrameTimeVariance", {
    get: function() {
      return this._rollingFrameTime.variance;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "instantaneousFrameTime", {
    get: function() {
      return this._rollingFrameTime.history(0);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "averageFPS", {
    get: function() {
      return 1e3 / this._rollingFrameTime.average;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "instantaneousFPS", {
    get: function() {
      var history = this._rollingFrameTime.history(0);
      if (history === 0) {
        return 0;
      }
      return 1e3 / history;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "isSaturated", {
    get: function() {
      return this._rollingFrameTime.isSaturated();
    },
    enumerable: false,
    configurable: true
  });
  PerformanceMonitor2.prototype.enable = function() {
    this._enabled = true;
  };
  PerformanceMonitor2.prototype.disable = function() {
    this._enabled = false;
    this._lastFrameTimeMs = null;
  };
  Object.defineProperty(PerformanceMonitor2.prototype, "isEnabled", {
    get: function() {
      return this._enabled;
    },
    enumerable: false,
    configurable: true
  });
  PerformanceMonitor2.prototype.reset = function() {
    this._lastFrameTimeMs = null;
    this._rollingFrameTime.reset();
  };
  return PerformanceMonitor2;
}();
var RollingAverage = function() {
  function RollingAverage2(length) {
    this._samples = new Array(length);
    this.reset();
  }
  RollingAverage2.prototype.add = function(v) {
    var delta;
    if (this.isSaturated()) {
      var bottomValue = this._samples[this._pos];
      delta = bottomValue - this.average;
      this.average -= delta / (this._sampleCount - 1);
      this._m2 -= delta * (bottomValue - this.average);
    } else {
      this._sampleCount++;
    }
    delta = v - this.average;
    this.average += delta / this._sampleCount;
    this._m2 += delta * (v - this.average);
    this.variance = this._m2 / (this._sampleCount - 1);
    this._samples[this._pos] = v;
    this._pos++;
    this._pos %= this._samples.length;
  };
  RollingAverage2.prototype.history = function(i) {
    if (i >= this._sampleCount || i >= this._samples.length) {
      return 0;
    }
    var i0 = this._wrapPosition(this._pos - 1);
    return this._samples[this._wrapPosition(i0 - i)];
  };
  RollingAverage2.prototype.isSaturated = function() {
    return this._sampleCount >= this._samples.length;
  };
  RollingAverage2.prototype.reset = function() {
    this.average = 0;
    this.variance = 0;
    this._sampleCount = 0;
    this._pos = 0;
    this._m2 = 0;
  };
  RollingAverage2.prototype._wrapPosition = function(i) {
    var max = this._samples.length;
    return (i % max + max) % max;
  };
  return RollingAverage2;
}();
var PerfCounter = function() {
  function PerfCounter2() {
    this._startMonitoringTime = 0;
    this._min = 0;
    this._max = 0;
    this._average = 0;
    this._lastSecAverage = 0;
    this._current = 0;
    this._totalValueCount = 0;
    this._totalAccumulated = 0;
    this._lastSecAccumulated = 0;
    this._lastSecTime = 0;
    this._lastSecValueCount = 0;
  }
  Object.defineProperty(PerfCounter2.prototype, "min", {
    get: function() {
      return this._min;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "max", {
    get: function() {
      return this._max;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "average", {
    get: function() {
      return this._average;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "lastSecAverage", {
    get: function() {
      return this._lastSecAverage;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "current", {
    get: function() {
      return this._current;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "total", {
    get: function() {
      return this._totalAccumulated;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "count", {
    get: function() {
      return this._totalValueCount;
    },
    enumerable: false,
    configurable: true
  });
  PerfCounter2.prototype.fetchNewFrame = function() {
    this._totalValueCount++;
    this._current = 0;
    this._lastSecValueCount++;
  };
  PerfCounter2.prototype.addCount = function(newCount, fetchResult) {
    if (!PerfCounter2.Enabled) {
      return;
    }
    this._current += newCount;
    if (fetchResult) {
      this._fetchResult();
    }
  };
  PerfCounter2.prototype.beginMonitoring = function() {
    if (!PerfCounter2.Enabled) {
      return;
    }
    this._startMonitoringTime = PrecisionDate.Now;
  };
  PerfCounter2.prototype.endMonitoring = function(newFrame) {
    if (newFrame === void 0) {
      newFrame = true;
    }
    if (!PerfCounter2.Enabled) {
      return;
    }
    if (newFrame) {
      this.fetchNewFrame();
    }
    var currentTime = PrecisionDate.Now;
    this._current = currentTime - this._startMonitoringTime;
    if (newFrame) {
      this._fetchResult();
    }
  };
  PerfCounter2.prototype._fetchResult = function() {
    this._totalAccumulated += this._current;
    this._lastSecAccumulated += this._current;
    this._min = Math.min(this._min, this._current);
    this._max = Math.max(this._max, this._current);
    this._average = this._totalAccumulated / this._totalValueCount;
    var now = PrecisionDate.Now;
    if (now - this._lastSecTime > 1e3) {
      this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount;
      this._lastSecTime = now;
      this._lastSecAccumulated = 0;
      this._lastSecValueCount = 0;
    }
  };
  PerfCounter2.Enabled = true;
  return PerfCounter2;
}();
ThinEngine.prototype.setAlphaConstants = function(r, g, b, a) {
  this._alphaState.setAlphaBlendConstants(r, g, b, a);
};
ThinEngine.prototype.setAlphaMode = function(mode, noDepthWriteChange) {
  if (noDepthWriteChange === void 0) {
    noDepthWriteChange = false;
  }
  if (this._alphaMode === mode) {
    return;
  }
  switch (mode) {
    case 0:
      this._alphaState.alphaBlend = false;
      break;
    case 7:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 8:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 2:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 6:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 1:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 3:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 4:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 5:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 9:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 10:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 11:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 12:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO);
      this._alphaState.alphaBlend = true;
      break;
    case 13:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 14:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 15:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO);
      this._alphaState.alphaBlend = true;
      break;
    case 16:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 17:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
  }
  if (!noDepthWriteChange) {
    this.depthCullingState.depthMask = mode === 0;
  }
  this._alphaMode = mode;
};
ThinEngine.prototype.getAlphaMode = function() {
  return this._alphaMode;
};
ThinEngine.prototype.setAlphaEquation = function(equation) {
  if (this._alphaEquation === equation) {
    return;
  }
  switch (equation) {
    case 0:
      this._alphaState.setAlphaEquationParameters(32774, 32774);
      break;
    case 1:
      this._alphaState.setAlphaEquationParameters(32778, 32778);
      break;
    case 2:
      this._alphaState.setAlphaEquationParameters(32779, 32779);
      break;
    case 3:
      this._alphaState.setAlphaEquationParameters(32776, 32776);
      break;
    case 4:
      this._alphaState.setAlphaEquationParameters(32775, 32775);
      break;
    case 5:
      this._alphaState.setAlphaEquationParameters(32775, 32774);
      break;
  }
  this._alphaEquation = equation;
};
ThinEngine.prototype.getAlphaEquation = function() {
  return this._alphaEquation;
};
function allocateAndCopyTypedBuffer(type, sizeOrDstBuffer, sizeInBytes, copyBuffer) {
  if (sizeInBytes === void 0) {
    sizeInBytes = false;
  }
  switch (type) {
    case 3: {
      var buffer_1 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int8Array(sizeOrDstBuffer) : new Int8Array(sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_1.set(new Int8Array(copyBuffer));
      }
      return buffer_1;
    }
    case 0: {
      var buffer_2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_2.set(new Uint8Array(copyBuffer));
      }
      return buffer_2;
    }
    case 4: {
      var buffer_3 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int16Array(sizeOrDstBuffer) : new Int16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_3.set(new Int16Array(copyBuffer));
      }
      return buffer_3;
    }
    case 5:
    case 8:
    case 9:
    case 10:
    case 2: {
      var buffer_4 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint16Array(sizeOrDstBuffer) : new Uint16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_4.set(new Uint16Array(copyBuffer));
      }
      return buffer_4;
    }
    case 6: {
      var buffer_5 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int32Array(sizeOrDstBuffer) : new Int32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_5.set(new Int32Array(copyBuffer));
      }
      return buffer_5;
    }
    case 7:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15: {
      var buffer_6 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint32Array(sizeOrDstBuffer) : new Uint32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_6.set(new Uint32Array(copyBuffer));
      }
      return buffer_6;
    }
    case 1: {
      var buffer_7 = sizeOrDstBuffer instanceof ArrayBuffer ? new Float32Array(sizeOrDstBuffer) : new Float32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_7.set(new Float32Array(copyBuffer));
      }
      return buffer_7;
    }
  }
  var buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);
  if (copyBuffer) {
    buffer.set(new Uint8Array(copyBuffer));
  }
  return buffer;
}
ThinEngine.prototype._readTexturePixelsSync = function(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion) {
  var _a, _b;
  if (faceIndex === void 0) {
    faceIndex = -1;
  }
  if (level === void 0) {
    level = 0;
  }
  if (buffer === void 0) {
    buffer = null;
  }
  if (flushRenderer === void 0) {
    flushRenderer = true;
  }
  if (noDataConversion === void 0) {
    noDataConversion = false;
  }
  var gl = this._gl;
  if (!gl) {
    throw new Error("Engine does not have gl rendering context.");
  }
  if (!this._dummyFramebuffer) {
    var dummy = gl.createFramebuffer();
    if (!dummy) {
      throw new Error("Unable to create dummy framebuffer");
    }
    this._dummyFramebuffer = dummy;
  }
  gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);
  if (faceIndex > -1) {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource, level);
  } else {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, (_b = texture._hardwareTexture) === null || _b === void 0 ? void 0 : _b.underlyingResource, level);
  }
  var readType = texture.type !== void 0 ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;
  if (!noDataConversion) {
    switch (readType) {
      case gl.UNSIGNED_BYTE:
        if (!buffer) {
          buffer = new Uint8Array(4 * width * height);
        }
        readType = gl.UNSIGNED_BYTE;
        break;
      default:
        if (!buffer) {
          buffer = new Float32Array(4 * width * height);
        }
        readType = gl.FLOAT;
        break;
    }
  } else if (!buffer) {
    buffer = allocateAndCopyTypedBuffer(texture.type, 4 * width * height);
  }
  if (flushRenderer) {
    this.flushFramebuffer();
  }
  gl.readPixels(0, 0, width, height, gl.RGBA, readType, buffer);
  gl.bindFramebuffer(gl.FRAMEBUFFER, this._currentFramebuffer);
  return buffer;
};
ThinEngine.prototype._readTexturePixels = function(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion) {
  if (faceIndex === void 0) {
    faceIndex = -1;
  }
  if (level === void 0) {
    level = 0;
  }
  if (buffer === void 0) {
    buffer = null;
  }
  if (flushRenderer === void 0) {
    flushRenderer = true;
  }
  if (noDataConversion === void 0) {
    noDataConversion = false;
  }
  return Promise.resolve(this._readTexturePixelsSync(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion));
};
ThinEngine.prototype.updateDynamicIndexBuffer = function(indexBuffer, indices, offset) {
  this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null;
  this.bindIndexBuffer(indexBuffer);
  var arrayBuffer;
  if (indices instanceof Uint16Array || indices instanceof Uint32Array) {
    arrayBuffer = indices;
  } else {
    arrayBuffer = indexBuffer.is32Bits ? new Uint32Array(indices) : new Uint16Array(indices);
  }
  this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, arrayBuffer, this._gl.DYNAMIC_DRAW);
  this._resetIndexBufferBinding();
};
ThinEngine.prototype.updateDynamicVertexBuffer = function(vertexBuffer, data, byteOffset, byteLength) {
  this.bindArrayBuffer(vertexBuffer);
  if (byteOffset === void 0) {
    byteOffset = 0;
  }
  var dataLength = data.length || data.byteLength;
  if (byteLength === void 0 || byteLength >= dataLength && byteOffset === 0) {
    if (data instanceof Array) {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data));
    } else {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, data);
    }
  } else {
    if (data instanceof Array) {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(data).subarray(byteOffset, byteOffset + byteLength));
    } else {
      if (data instanceof ArrayBuffer) {
        data = new Uint8Array(data, byteOffset, byteLength);
      } else {
        data = new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);
      }
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
    }
  }
  this._resetVertexBufferBinding();
};
var Engine = function(_super) {
  __extends(Engine2, _super);
  function Engine2(canvasOrContext, antialias, options, adaptToDeviceRatio) {
    if (adaptToDeviceRatio === void 0) {
      adaptToDeviceRatio = false;
    }
    var _this = _super.call(this, canvasOrContext, antialias, options, adaptToDeviceRatio) || this;
    _this.enableOfflineSupport = false;
    _this.disableManifestCheck = false;
    _this.scenes = new Array();
    _this._virtualScenes = new Array();
    _this.onNewSceneAddedObservable = new Observable();
    _this.postProcesses = new Array();
    _this.isPointerLock = false;
    _this.onResizeObservable = new Observable();
    _this.onCanvasBlurObservable = new Observable();
    _this.onCanvasFocusObservable = new Observable();
    _this.onCanvasPointerOutObservable = new Observable();
    _this.onBeginFrameObservable = new Observable();
    _this.customAnimationFrameRequester = null;
    _this.onEndFrameObservable = new Observable();
    _this.onBeforeShaderCompilationObservable = new Observable();
    _this.onAfterShaderCompilationObservable = new Observable();
    _this._deterministicLockstep = false;
    _this._lockstepMaxSteps = 4;
    _this._timeStep = 1 / 60;
    _this._fps = 60;
    _this._deltaTime = 0;
    _this._drawCalls = new PerfCounter();
    _this.canvasTabIndex = 1;
    _this.disablePerformanceMonitorInBackground = false;
    _this._performanceMonitor = new PerformanceMonitor();
    _this._compatibilityMode = true;
    _this.currentRenderPassId = 0;
    _this._renderPassNames = ["main"];
    Engine2.Instances.push(_this);
    if (!canvasOrContext) {
      return _this;
    }
    _this._features.supportRenderPasses = true;
    options = _this._creationOptions;
    if (canvasOrContext.getContext) {
      var canvas_1 = canvasOrContext;
      _this._sharedInit(canvas_1, !!options.doNotHandleTouchAction, options.audioEngine);
      if (IsWindowObjectExist()) {
        var anyDoc_1 = document;
        _this._onFullscreenChange = function() {
          if (anyDoc_1.fullscreen !== void 0) {
            _this.isFullscreen = anyDoc_1.fullscreen;
          } else if (anyDoc_1.mozFullScreen !== void 0) {
            _this.isFullscreen = anyDoc_1.mozFullScreen;
          } else if (anyDoc_1.webkitIsFullScreen !== void 0) {
            _this.isFullscreen = anyDoc_1.webkitIsFullScreen;
          } else if (anyDoc_1.msIsFullScreen !== void 0) {
            _this.isFullscreen = anyDoc_1.msIsFullScreen;
          }
          if (_this.isFullscreen && _this._pointerLockRequested && canvas_1) {
            Engine2._RequestPointerlock(canvas_1);
          }
        };
        document.addEventListener("fullscreenchange", _this._onFullscreenChange, false);
        document.addEventListener("mozfullscreenchange", _this._onFullscreenChange, false);
        document.addEventListener("webkitfullscreenchange", _this._onFullscreenChange, false);
        document.addEventListener("msfullscreenchange", _this._onFullscreenChange, false);
        _this._onPointerLockChange = function() {
          _this.isPointerLock = anyDoc_1.mozPointerLockElement === canvas_1 || anyDoc_1.webkitPointerLockElement === canvas_1 || anyDoc_1.msPointerLockElement === canvas_1 || anyDoc_1.pointerLockElement === canvas_1;
        };
        document.addEventListener("pointerlockchange", _this._onPointerLockChange, false);
        document.addEventListener("mspointerlockchange", _this._onPointerLockChange, false);
        document.addEventListener("mozpointerlockchange", _this._onPointerLockChange, false);
        document.addEventListener("webkitpointerlockchange", _this._onPointerLockChange, false);
        if (!Engine2.audioEngine && options.audioEngine && Engine2.AudioEngineFactory) {
          Engine2.audioEngine = Engine2.AudioEngineFactory(_this.getRenderingCanvas(), _this.getAudioContext(), _this.getAudioDestination());
        }
      }
      _this._connectVREvents();
      _this.enableOfflineSupport = Engine2.OfflineProviderFactory !== void 0;
      _this._deterministicLockstep = !!options.deterministicLockstep;
      _this._lockstepMaxSteps = options.lockstepMaxSteps || 0;
      _this._timeStep = options.timeStep || 1 / 60;
    }
    _this._prepareVRComponent();
    if (options.autoEnableWebVR) {
      _this.initWebVR();
    }
    return _this;
  }
  Object.defineProperty(Engine2, "NpmPackage", {
    get: function() {
      return ThinEngine.NpmPackage;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2, "Version", {
    get: function() {
      return ThinEngine.Version;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2, "Instances", {
    get: function() {
      return EngineStore.Instances;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2, "LastCreatedEngine", {
    get: function() {
      return EngineStore.LastCreatedEngine;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2, "LastCreatedScene", {
    get: function() {
      return EngineStore.LastCreatedScene;
    },
    enumerable: false,
    configurable: true
  });
  Engine2.prototype.createImageBitmapFromSource = function(imageSource, options) {
    var _this = this;
    var promise = new Promise(function(resolve, reject) {
      var image = new Image();
      image.onload = function() {
        image.decode().then(function() {
          _this.createImageBitmap(image, options).then(function(imageBitmap) {
            resolve(imageBitmap);
          });
        });
      };
      image.onerror = function() {
        reject("Error loading image ".concat(image.src));
      };
      image.src = imageSource;
    });
    return promise;
  };
  Engine2.prototype.createImageBitmap = function(image, options) {
    return createImageBitmap(image, options);
  };
  Engine2.prototype.resizeImageBitmap = function(image, bufferWidth, bufferHeight) {
    var canvas = this.createCanvas(bufferWidth, bufferHeight);
    var context = canvas.getContext("2d");
    if (!context) {
      throw new Error("Unable to get 2d context for resizeImageBitmap");
    }
    context.drawImage(image, 0, 0);
    var buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;
    return buffer;
  };
  Engine2.MarkAllMaterialsAsDirty = function(flag, predicate) {
    for (var engineIndex = 0; engineIndex < Engine2.Instances.length; engineIndex++) {
      var engine = Engine2.Instances[engineIndex];
      for (var sceneIndex = 0; sceneIndex < engine.scenes.length; sceneIndex++) {
        engine.scenes[sceneIndex].markAllMaterialsAsDirty(flag, predicate);
      }
    }
  };
  Engine2.DefaultLoadingScreenFactory = function(canvas) {
    throw _WarnImport("LoadingScreen");
  };
  Object.defineProperty(Engine2.prototype, "_supportsHardwareTextureRescaling", {
    get: function() {
      return !!Engine2._RescalePostProcessFactory;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2.prototype, "performanceMonitor", {
    get: function() {
      return this._performanceMonitor;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2.prototype, "compatibilityMode", {
    get: function() {
      return this._compatibilityMode;
    },
    set: function(mode) {
      this._compatibilityMode = true;
    },
    enumerable: false,
    configurable: true
  });
  Engine2.prototype.getInputElement = function() {
    return this._renderingCanvas;
  };
  Engine2.prototype._sharedInit = function(canvas, doNotHandleTouchAction, audioEngine) {
    var _this = this;
    _super.prototype._sharedInit.call(this, canvas, doNotHandleTouchAction, audioEngine);
    this._onCanvasFocus = function() {
      _this.onCanvasFocusObservable.notifyObservers(_this);
    };
    this._onCanvasBlur = function() {
      _this.onCanvasBlurObservable.notifyObservers(_this);
    };
    canvas.addEventListener("focus", this._onCanvasFocus);
    canvas.addEventListener("blur", this._onCanvasBlur);
    this._onBlur = function() {
      if (_this.disablePerformanceMonitorInBackground) {
        _this._performanceMonitor.disable();
      }
      _this._windowIsBackground = true;
    };
    this._onFocus = function() {
      if (_this.disablePerformanceMonitorInBackground) {
        _this._performanceMonitor.enable();
      }
      _this._windowIsBackground = false;
    };
    this._onCanvasPointerOut = function(ev) {
      if (document.elementFromPoint(ev.clientX, ev.clientY) !== canvas) {
        _this.onCanvasPointerOutObservable.notifyObservers(ev);
      }
    };
    if (IsWindowObjectExist()) {
      var hostWindow = this.getHostWindow();
      if (hostWindow) {
        hostWindow.addEventListener("blur", this._onBlur);
        hostWindow.addEventListener("focus", this._onFocus);
      }
    }
    canvas.addEventListener("pointerout", this._onCanvasPointerOut);
    if (!doNotHandleTouchAction) {
      this._disableTouchAction();
    }
    if (!Engine2.audioEngine && audioEngine && Engine2.AudioEngineFactory) {
      Engine2.audioEngine = Engine2.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination());
    }
  };
  Engine2.prototype.getAspectRatio = function(viewportOwner, useScreen) {
    if (useScreen === void 0) {
      useScreen = false;
    }
    var viewport = viewportOwner.viewport;
    return this.getRenderWidth(useScreen) * viewport.width / (this.getRenderHeight(useScreen) * viewport.height);
  };
  Engine2.prototype.getScreenAspectRatio = function() {
    return this.getRenderWidth(true) / this.getRenderHeight(true);
  };
  Engine2.prototype.getRenderingCanvasClientRect = function() {
    if (!this._renderingCanvas) {
      return null;
    }
    return this._renderingCanvas.getBoundingClientRect();
  };
  Engine2.prototype.getInputElementClientRect = function() {
    if (!this._renderingCanvas) {
      return null;
    }
    return this.getInputElement().getBoundingClientRect();
  };
  Engine2.prototype.isDeterministicLockStep = function() {
    return this._deterministicLockstep;
  };
  Engine2.prototype.getLockstepMaxSteps = function() {
    return this._lockstepMaxSteps;
  };
  Engine2.prototype.getTimeStep = function() {
    return this._timeStep * 1e3;
  };
  Engine2.prototype.generateMipMapsForCubemap = function(texture, unbind) {
    if (unbind === void 0) {
      unbind = true;
    }
    if (texture.generateMipMaps) {
      var gl = this._gl;
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
      if (unbind) {
        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      }
    }
  };
  Engine2.prototype.getDepthBuffer = function() {
    return this._depthCullingState.depthTest;
  };
  Engine2.prototype.setDepthBuffer = function(enable) {
    this._depthCullingState.depthTest = enable;
  };
  Engine2.prototype.getDepthWrite = function() {
    return this._depthCullingState.depthMask;
  };
  Engine2.prototype.setDepthWrite = function(enable) {
    this._depthCullingState.depthMask = enable;
  };
  Engine2.prototype.getStencilBuffer = function() {
    return this._stencilState.stencilTest;
  };
  Engine2.prototype.setStencilBuffer = function(enable) {
    this._stencilState.stencilTest = enable;
  };
  Engine2.prototype.getStencilMask = function() {
    return this._stencilState.stencilMask;
  };
  Engine2.prototype.setStencilMask = function(mask) {
    this._stencilState.stencilMask = mask;
  };
  Engine2.prototype.getStencilFunction = function() {
    return this._stencilState.stencilFunc;
  };
  Engine2.prototype.getStencilFunctionReference = function() {
    return this._stencilState.stencilFuncRef;
  };
  Engine2.prototype.getStencilFunctionMask = function() {
    return this._stencilState.stencilFuncMask;
  };
  Engine2.prototype.setStencilFunction = function(stencilFunc) {
    this._stencilState.stencilFunc = stencilFunc;
  };
  Engine2.prototype.setStencilFunctionReference = function(reference) {
    this._stencilState.stencilFuncRef = reference;
  };
  Engine2.prototype.setStencilFunctionMask = function(mask) {
    this._stencilState.stencilFuncMask = mask;
  };
  Engine2.prototype.getStencilOperationFail = function() {
    return this._stencilState.stencilOpStencilFail;
  };
  Engine2.prototype.getStencilOperationDepthFail = function() {
    return this._stencilState.stencilOpDepthFail;
  };
  Engine2.prototype.getStencilOperationPass = function() {
    return this._stencilState.stencilOpStencilDepthPass;
  };
  Engine2.prototype.setStencilOperationFail = function(operation) {
    this._stencilState.stencilOpStencilFail = operation;
  };
  Engine2.prototype.setStencilOperationDepthFail = function(operation) {
    this._stencilState.stencilOpDepthFail = operation;
  };
  Engine2.prototype.setStencilOperationPass = function(operation) {
    this._stencilState.stencilOpStencilDepthPass = operation;
  };
  Engine2.prototype.setDitheringState = function(value) {
    if (value) {
      this._gl.enable(this._gl.DITHER);
    } else {
      this._gl.disable(this._gl.DITHER);
    }
  };
  Engine2.prototype.setRasterizerState = function(value) {
    if (value) {
      this._gl.disable(this._gl.RASTERIZER_DISCARD);
    } else {
      this._gl.enable(this._gl.RASTERIZER_DISCARD);
    }
  };
  Engine2.prototype.getDepthFunction = function() {
    return this._depthCullingState.depthFunc;
  };
  Engine2.prototype.setDepthFunction = function(depthFunc) {
    this._depthCullingState.depthFunc = depthFunc;
  };
  Engine2.prototype.setDepthFunctionToGreater = function() {
    this.setDepthFunction(516);
  };
  Engine2.prototype.setDepthFunctionToGreaterOrEqual = function() {
    this.setDepthFunction(518);
  };
  Engine2.prototype.setDepthFunctionToLess = function() {
    this.setDepthFunction(513);
  };
  Engine2.prototype.setDepthFunctionToLessOrEqual = function() {
    this.setDepthFunction(515);
  };
  Engine2.prototype.cacheStencilState = function() {
    this._cachedStencilBuffer = this.getStencilBuffer();
    this._cachedStencilFunction = this.getStencilFunction();
    this._cachedStencilMask = this.getStencilMask();
    this._cachedStencilOperationPass = this.getStencilOperationPass();
    this._cachedStencilOperationFail = this.getStencilOperationFail();
    this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail();
    this._cachedStencilReference = this.getStencilFunctionReference();
  };
  Engine2.prototype.restoreStencilState = function() {
    this.setStencilFunction(this._cachedStencilFunction);
    this.setStencilMask(this._cachedStencilMask);
    this.setStencilBuffer(this._cachedStencilBuffer);
    this.setStencilOperationPass(this._cachedStencilOperationPass);
    this.setStencilOperationFail(this._cachedStencilOperationFail);
    this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail);
    this.setStencilFunctionReference(this._cachedStencilReference);
  };
  Engine2.prototype.setDirectViewport = function(x, y, width, height) {
    var currentViewport = this._cachedViewport;
    this._cachedViewport = null;
    this._viewport(x, y, width, height);
    return currentViewport;
  };
  Engine2.prototype.scissorClear = function(x, y, width, height, clearColor) {
    this.enableScissor(x, y, width, height);
    this.clear(clearColor, true, true, true);
    this.disableScissor();
  };
  Engine2.prototype.enableScissor = function(x, y, width, height) {
    var gl = this._gl;
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(x, y, width, height);
  };
  Engine2.prototype.disableScissor = function() {
    var gl = this._gl;
    gl.disable(gl.SCISSOR_TEST);
  };
  Engine2.prototype._reportDrawCall = function(numDrawCalls) {
    if (numDrawCalls === void 0) {
      numDrawCalls = 1;
    }
    this._drawCalls.addCount(numDrawCalls, false);
  };
  Engine2.prototype.initWebVR = function() {
    throw _WarnImport("WebVRCamera");
  };
  Engine2.prototype._prepareVRComponent = function() {
  };
  Engine2.prototype._connectVREvents = function(canvas, document2) {
  };
  Engine2.prototype._submitVRFrame = function() {
  };
  Engine2.prototype.disableVR = function() {
  };
  Engine2.prototype.isVRPresenting = function() {
    return false;
  };
  Engine2.prototype._requestVRFrame = function() {
  };
  Engine2.prototype._loadFileAsync = function(url, offlineProvider, useArrayBuffer) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._loadFile(url, function(data) {
        resolve(data);
      }, void 0, offlineProvider, useArrayBuffer, function(request, exception) {
        reject(exception);
      });
    });
  };
  Engine2.prototype.getVertexShaderSource = function(program) {
    var shaders = this._gl.getAttachedShaders(program);
    if (!shaders) {
      return null;
    }
    return this._gl.getShaderSource(shaders[0]);
  };
  Engine2.prototype.getFragmentShaderSource = function(program) {
    var shaders = this._gl.getAttachedShaders(program);
    if (!shaders) {
      return null;
    }
    return this._gl.getShaderSource(shaders[1]);
  };
  Engine2.prototype.setDepthStencilTexture = function(channel, uniform, texture, name2) {
    if (channel === void 0) {
      return;
    }
    if (uniform) {
      this._boundUniforms[channel] = uniform;
    }
    if (!texture || !texture.depthStencilTexture) {
      this._setTexture(channel, null, void 0, void 0, name2);
    } else {
      this._setTexture(channel, texture, false, true, name2);
    }
  };
  Engine2.prototype.setTextureFromPostProcess = function(channel, postProcess, name2) {
    var _a;
    var postProcessInput = null;
    if (postProcess) {
      if (postProcess._textures.data[postProcess._currentRenderTextureInd]) {
        postProcessInput = postProcess._textures.data[postProcess._currentRenderTextureInd];
      } else if (postProcess._forcedOutputTexture) {
        postProcessInput = postProcess._forcedOutputTexture;
      }
    }
    this._bindTexture(channel, (_a = postProcessInput === null || postProcessInput === void 0 ? void 0 : postProcessInput.texture) !== null && _a !== void 0 ? _a : null, name2);
  };
  Engine2.prototype.setTextureFromPostProcessOutput = function(channel, postProcess, name2) {
    var _a, _b;
    this._bindTexture(channel, (_b = (_a = postProcess === null || postProcess === void 0 ? void 0 : postProcess._outputTexture) === null || _a === void 0 ? void 0 : _a.texture) !== null && _b !== void 0 ? _b : null, name2);
  };
  Engine2.prototype._rebuildBuffers = function() {
    for (var _i = 0, _a = this.scenes; _i < _a.length; _i++) {
      var scene = _a[_i];
      scene.resetCachedMaterial();
      scene._rebuildGeometries();
      scene._rebuildTextures();
    }
    for (var _b = 0, _c = this._virtualScenes; _b < _c.length; _b++) {
      var scene = _c[_b];
      scene.resetCachedMaterial();
      scene._rebuildGeometries();
      scene._rebuildTextures();
    }
    _super.prototype._rebuildBuffers.call(this);
  };
  Engine2.prototype._renderFrame = function() {
    for (var index = 0; index < this._activeRenderLoops.length; index++) {
      var renderFunction = this._activeRenderLoops[index];
      renderFunction();
    }
  };
  Engine2.prototype._renderLoop = function() {
    if (!this._contextWasLost) {
      var shouldRender = true;
      if (!this.renderEvenInBackground && this._windowIsBackground) {
        shouldRender = false;
      }
      if (shouldRender) {
        this.beginFrame();
        if (!this._renderViews()) {
          this._renderFrame();
        }
        this.endFrame();
      }
    }
    if (this._activeRenderLoops.length > 0) {
      if (this.customAnimationFrameRequester) {
        this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester);
        this._frameHandler = this.customAnimationFrameRequester.requestID;
      } else if (this.isVRPresenting()) {
        this._requestVRFrame();
      } else {
        this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
      }
    } else {
      this._renderingQueueLaunched = false;
    }
  };
  Engine2.prototype._renderViews = function() {
    return false;
  };
  Engine2.prototype.switchFullscreen = function(requestPointerLock) {
    if (this.isFullscreen) {
      this.exitFullscreen();
    } else {
      this.enterFullscreen(requestPointerLock);
    }
  };
  Engine2.prototype.enterFullscreen = function(requestPointerLock) {
    if (!this.isFullscreen) {
      this._pointerLockRequested = requestPointerLock;
      if (this._renderingCanvas) {
        Engine2._RequestFullscreen(this._renderingCanvas);
      }
    }
  };
  Engine2.prototype.exitFullscreen = function() {
    if (this.isFullscreen) {
      Engine2._ExitFullscreen();
    }
  };
  Engine2.prototype.enterPointerlock = function() {
    if (this._renderingCanvas) {
      Engine2._RequestPointerlock(this._renderingCanvas);
    }
  };
  Engine2.prototype.exitPointerlock = function() {
    Engine2._ExitPointerlock();
  };
  Engine2.prototype.beginFrame = function() {
    this._measureFps();
    this.onBeginFrameObservable.notifyObservers(this);
    _super.prototype.beginFrame.call(this);
  };
  Engine2.prototype.endFrame = function() {
    _super.prototype.endFrame.call(this);
    this._submitVRFrame();
    this.onEndFrameObservable.notifyObservers(this);
  };
  Engine2.prototype.resize = function(forceSetSize) {
    if (forceSetSize === void 0) {
      forceSetSize = false;
    }
    if (this.isVRPresenting()) {
      return;
    }
    _super.prototype.resize.call(this, forceSetSize);
  };
  Engine2.prototype.setSize = function(width, height, forceSetSize) {
    if (forceSetSize === void 0) {
      forceSetSize = false;
    }
    if (!this._renderingCanvas) {
      return false;
    }
    if (!_super.prototype.setSize.call(this, width, height, forceSetSize)) {
      return false;
    }
    if (this.scenes) {
      for (var index = 0; index < this.scenes.length; index++) {
        var scene = this.scenes[index];
        for (var camIndex = 0; camIndex < scene.cameras.length; camIndex++) {
          var cam = scene.cameras[camIndex];
          cam._currentRenderId = 0;
        }
      }
      if (this.onResizeObservable.hasObservers()) {
        this.onResizeObservable.notifyObservers(this);
      }
    }
    return true;
  };
  Engine2.prototype._deletePipelineContext = function(pipelineContext) {
    var webGLPipelineContext = pipelineContext;
    if (webGLPipelineContext && webGLPipelineContext.program) {
      if (webGLPipelineContext.transformFeedback) {
        this.deleteTransformFeedback(webGLPipelineContext.transformFeedback);
        webGLPipelineContext.transformFeedback = null;
      }
    }
    _super.prototype._deletePipelineContext.call(this, pipelineContext);
  };
  Engine2.prototype.createShaderProgram = function(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    context = context || this._gl;
    this.onBeforeShaderCompilationObservable.notifyObservers(this);
    var program = _super.prototype.createShaderProgram.call(this, pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings);
    this.onAfterShaderCompilationObservable.notifyObservers(this);
    return program;
  };
  Engine2.prototype._createShaderProgram = function(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    var shaderProgram = context.createProgram();
    pipelineContext.program = shaderProgram;
    if (!shaderProgram) {
      throw new Error("Unable to create program");
    }
    context.attachShader(shaderProgram, vertexShader);
    context.attachShader(shaderProgram, fragmentShader);
    if (this.webGLVersion > 1 && transformFeedbackVaryings) {
      var transformFeedback = this.createTransformFeedback();
      this.bindTransformFeedback(transformFeedback);
      this.setTranformFeedbackVaryings(shaderProgram, transformFeedbackVaryings);
      pipelineContext.transformFeedback = transformFeedback;
    }
    context.linkProgram(shaderProgram);
    if (this.webGLVersion > 1 && transformFeedbackVaryings) {
      this.bindTransformFeedback(null);
    }
    pipelineContext.context = context;
    pipelineContext.vertexShader = vertexShader;
    pipelineContext.fragmentShader = fragmentShader;
    if (!pipelineContext.isParallelCompiled) {
      this._finalizePipelineContext(pipelineContext);
    }
    return shaderProgram;
  };
  Engine2.prototype._releaseTexture = function(texture) {
    _super.prototype._releaseTexture.call(this, texture);
  };
  Engine2.prototype._releaseRenderTargetWrapper = function(rtWrapper) {
    _super.prototype._releaseRenderTargetWrapper.call(this, rtWrapper);
    this.scenes.forEach(function(scene) {
      scene.postProcesses.forEach(function(postProcess) {
        if (postProcess._outputTexture === rtWrapper) {
          postProcess._outputTexture = null;
        }
      });
      scene.cameras.forEach(function(camera) {
        camera._postProcesses.forEach(function(postProcess) {
          if (postProcess) {
            if (postProcess._outputTexture === rtWrapper) {
              postProcess._outputTexture = null;
            }
          }
        });
      });
    });
  };
  Engine2.prototype.getRenderPassNames = function() {
    return this._renderPassNames;
  };
  Engine2.prototype.getCurrentRenderPassName = function() {
    return this._renderPassNames[this.currentRenderPassId];
  };
  Engine2.prototype.createRenderPassId = function(name2) {
    var id = ++Engine2._RenderPassIdCounter;
    this._renderPassNames[id] = name2 !== null && name2 !== void 0 ? name2 : "NONAME";
    return id;
  };
  Engine2.prototype.releaseRenderPassId = function(id) {
    this._renderPassNames[id] = void 0;
    for (var s = 0; s < this.scenes.length; ++s) {
      var scene = this.scenes[s];
      for (var m = 0; m < scene.meshes.length; ++m) {
        var mesh = scene.meshes[m];
        if (mesh.subMeshes) {
          for (var b = 0; b < mesh.subMeshes.length; ++b) {
            var subMesh = mesh.subMeshes[b];
            subMesh._removeDrawWrapper(id);
          }
        }
      }
    }
  };
  Engine2.prototype._rescaleTexture = function(source, destination, scene, internalFormat, onComplete) {
    var _this = this;
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
    var rtt = this.createRenderTargetTexture({
      width: destination.width,
      height: destination.height
    }, {
      generateMipMaps: false,
      type: 0,
      samplingMode: 2,
      generateDepthBuffer: false,
      generateStencilBuffer: false
    });
    if (!this._rescalePostProcess && Engine2._RescalePostProcessFactory) {
      this._rescalePostProcess = Engine2._RescalePostProcessFactory(this);
    }
    this._rescalePostProcess.externalTextureSamplerBinding = true;
    this._rescalePostProcess.getEffect().executeWhenCompiled(function() {
      _this._rescalePostProcess.onApply = function(effect) {
        effect._bindTexture("textureSampler", source);
      };
      var hostingScene = scene;
      if (!hostingScene) {
        hostingScene = _this.scenes[_this.scenes.length - 1];
      }
      hostingScene.postProcessManager.directRender([_this._rescalePostProcess], rtt, true);
      _this._bindTextureDirectly(_this._gl.TEXTURE_2D, destination, true);
      _this._gl.copyTexImage2D(_this._gl.TEXTURE_2D, 0, internalFormat, 0, 0, destination.width, destination.height, 0);
      _this.unBindFramebuffer(rtt);
      rtt.dispose();
      if (onComplete) {
        onComplete();
      }
    });
  };
  Engine2.prototype.getFps = function() {
    return this._fps;
  };
  Engine2.prototype.getDeltaTime = function() {
    return this._deltaTime;
  };
  Engine2.prototype._measureFps = function() {
    this._performanceMonitor.sampleFrame();
    this._fps = this._performanceMonitor.averageFPS;
    this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
  };
  Engine2.prototype._uploadImageToTexture = function(texture, image, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    var gl = this._gl;
    var textureType = this._getWebGLTextureType(texture.type);
    var format = this._getInternalFormat(texture.format);
    var internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, format);
    var bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    this._bindTextureDirectly(bindTarget, texture, true);
    this._unpackFlipY(texture.invertY);
    var target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    gl.texImage2D(target, lod, internalFormat, format, textureType, image);
    this._bindTextureDirectly(bindTarget, null, true);
  };
  Engine2.prototype.updateTextureComparisonFunction = function(texture, comparisonFunction) {
    if (this.webGLVersion === 1) {
      Logger.Error("WebGL 1 does not support texture comparison.");
      return;
    }
    var gl = this._gl;
    if (texture.isCube) {
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
      if (comparisonFunction === 0) {
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, 515);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);
      } else {
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
    } else {
      this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
      if (comparisonFunction === 0) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, 515);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.NONE);
      } else {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
    }
    texture._comparisonFunction = comparisonFunction;
  };
  Engine2.prototype.createInstancesBuffer = function(capacity) {
    var buffer = this._gl.createBuffer();
    if (!buffer) {
      throw new Error("Unable to create instance buffer");
    }
    var result = new WebGLDataBuffer(buffer);
    result.capacity = capacity;
    this.bindArrayBuffer(result);
    this._gl.bufferData(this._gl.ARRAY_BUFFER, capacity, this._gl.DYNAMIC_DRAW);
    result.references = 1;
    return result;
  };
  Engine2.prototype.deleteInstancesBuffer = function(buffer) {
    this._gl.deleteBuffer(buffer);
  };
  Engine2.prototype._clientWaitAsync = function(sync, flags, interval_ms) {
    if (flags === void 0) {
      flags = 0;
    }
    if (interval_ms === void 0) {
      interval_ms = 10;
    }
    var gl = this._gl;
    return new Promise(function(resolve, reject) {
      var check = function() {
        var res = gl.clientWaitSync(sync, flags, 0);
        if (res == gl.WAIT_FAILED) {
          reject();
          return;
        }
        if (res == gl.TIMEOUT_EXPIRED) {
          setTimeout(check, interval_ms);
          return;
        }
        resolve();
      };
      check();
    });
  };
  Engine2.prototype._readPixelsAsync = function(x, y, w, h, format, type, outputBuffer) {
    if (this._webGLVersion < 2) {
      throw new Error("_readPixelsAsync only work on WebGL2+");
    }
    var gl = this._gl;
    var buf = gl.createBuffer();
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
    gl.bufferData(gl.PIXEL_PACK_BUFFER, outputBuffer.byteLength, gl.STREAM_READ);
    gl.readPixels(x, y, w, h, format, type, 0);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    var sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
    if (!sync) {
      return null;
    }
    gl.flush();
    return this._clientWaitAsync(sync, 0, 10).then(function() {
      gl.deleteSync(sync);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
      gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, outputBuffer);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
      gl.deleteBuffer(buf);
      return outputBuffer;
    });
  };
  Engine2.prototype.dispose = function() {
    this.hideLoadingUI();
    this.onNewSceneAddedObservable.clear();
    while (this.postProcesses.length) {
      this.postProcesses[0].dispose();
    }
    if (this._rescalePostProcess) {
      this._rescalePostProcess.dispose();
    }
    while (this.scenes.length) {
      this.scenes[0].dispose();
    }
    while (this._virtualScenes.length) {
      this._virtualScenes[0].dispose();
    }
    if (Engine2.Instances.length === 1 && Engine2.audioEngine) {
      Engine2.audioEngine.dispose();
      Engine2.audioEngine = null;
    }
    this.disableVR();
    if (IsWindowObjectExist()) {
      window.removeEventListener("blur", this._onBlur);
      window.removeEventListener("focus", this._onFocus);
      if (this._renderingCanvas) {
        this._renderingCanvas.removeEventListener("focus", this._onCanvasFocus);
        this._renderingCanvas.removeEventListener("blur", this._onCanvasBlur);
        this._renderingCanvas.removeEventListener("pointerout", this._onCanvasPointerOut);
      }
      if (IsDocumentAvailable()) {
        document.removeEventListener("fullscreenchange", this._onFullscreenChange);
        document.removeEventListener("mozfullscreenchange", this._onFullscreenChange);
        document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange);
        document.removeEventListener("msfullscreenchange", this._onFullscreenChange);
        document.removeEventListener("pointerlockchange", this._onPointerLockChange);
        document.removeEventListener("mspointerlockchange", this._onPointerLockChange);
        document.removeEventListener("mozpointerlockchange", this._onPointerLockChange);
        document.removeEventListener("webkitpointerlockchange", this._onPointerLockChange);
      }
    }
    _super.prototype.dispose.call(this);
    var index = Engine2.Instances.indexOf(this);
    if (index >= 0) {
      Engine2.Instances.splice(index, 1);
    }
    this.onResizeObservable.clear();
    this.onCanvasBlurObservable.clear();
    this.onCanvasFocusObservable.clear();
    this.onCanvasPointerOutObservable.clear();
    this.onBeginFrameObservable.clear();
    this.onEndFrameObservable.clear();
  };
  Engine2.prototype._disableTouchAction = function() {
    if (!this._renderingCanvas || !this._renderingCanvas.setAttribute) {
      return;
    }
    this._renderingCanvas.setAttribute("touch-action", "none");
    this._renderingCanvas.style.touchAction = "none";
    this._renderingCanvas.style.msTouchAction = "none";
  };
  Engine2.prototype.displayLoadingUI = function() {
    if (!IsWindowObjectExist()) {
      return;
    }
    var loadingScreen = this.loadingScreen;
    if (loadingScreen) {
      loadingScreen.displayLoadingUI();
    }
  };
  Engine2.prototype.hideLoadingUI = function() {
    if (!IsWindowObjectExist()) {
      return;
    }
    var loadingScreen = this._loadingScreen;
    if (loadingScreen) {
      loadingScreen.hideLoadingUI();
    }
  };
  Object.defineProperty(Engine2.prototype, "loadingScreen", {
    get: function() {
      if (!this._loadingScreen && this._renderingCanvas) {
        this._loadingScreen = Engine2.DefaultLoadingScreenFactory(this._renderingCanvas);
      }
      return this._loadingScreen;
    },
    set: function(loadingScreen) {
      this._loadingScreen = loadingScreen;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2.prototype, "loadingUIText", {
    set: function(text) {
      this.loadingScreen.loadingUIText = text;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2.prototype, "loadingUIBackgroundColor", {
    set: function(color) {
      this.loadingScreen.loadingUIBackgroundColor = color;
    },
    enumerable: false,
    configurable: true
  });
  Engine2.prototype.createVideoElement = function(constraints) {
    return document.createElement("video");
  };
  Engine2._RequestPointerlock = function(element) {
    element.requestPointerLock = element.requestPointerLock || element.msRequestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
    if (element.requestPointerLock) {
      element.requestPointerLock();
    }
  };
  Engine2._ExitPointerlock = function() {
    var anyDoc = document;
    document.exitPointerLock = document.exitPointerLock || anyDoc.msExitPointerLock || anyDoc.mozExitPointerLock || anyDoc.webkitExitPointerLock;
    if (document.exitPointerLock) {
      document.exitPointerLock();
    }
  };
  Engine2._RequestFullscreen = function(element) {
    var requestFunction = element.requestFullscreen || element.msRequestFullscreen || element.webkitRequestFullscreen || element.mozRequestFullScreen;
    if (!requestFunction) {
      return;
    }
    requestFunction.call(element);
  };
  Engine2._ExitFullscreen = function() {
    var anyDoc = document;
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (anyDoc.mozCancelFullScreen) {
      anyDoc.mozCancelFullScreen();
    } else if (anyDoc.webkitCancelFullScreen) {
      anyDoc.webkitCancelFullScreen();
    } else if (anyDoc.msCancelFullScreen) {
      anyDoc.msCancelFullScreen();
    }
  };
  Engine2.prototype.getFontOffset = function(font) {
    var text = document.createElement("span");
    text.innerHTML = "Hg";
    text.setAttribute("style", "font: ".concat(font, " !important"));
    var block = document.createElement("div");
    block.style.display = "inline-block";
    block.style.width = "1px";
    block.style.height = "0px";
    block.style.verticalAlign = "bottom";
    var div = document.createElement("div");
    div.style.whiteSpace = "nowrap";
    div.appendChild(text);
    div.appendChild(block);
    document.body.appendChild(div);
    var fontAscent = 0;
    var fontHeight = 0;
    try {
      fontHeight = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
      block.style.verticalAlign = "baseline";
      fontAscent = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
    } finally {
      document.body.removeChild(div);
    }
    return { ascent: fontAscent, height: fontHeight, descent: fontHeight - fontAscent };
  };
  Engine2.ALPHA_DISABLE = 0;
  Engine2.ALPHA_ADD = 1;
  Engine2.ALPHA_COMBINE = 2;
  Engine2.ALPHA_SUBTRACT = 3;
  Engine2.ALPHA_MULTIPLY = 4;
  Engine2.ALPHA_MAXIMIZED = 5;
  Engine2.ALPHA_ONEONE = 6;
  Engine2.ALPHA_PREMULTIPLIED = 7;
  Engine2.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
  Engine2.ALPHA_INTERPOLATE = 9;
  Engine2.ALPHA_SCREENMODE = 10;
  Engine2.DELAYLOADSTATE_NONE = 0;
  Engine2.DELAYLOADSTATE_LOADED = 1;
  Engine2.DELAYLOADSTATE_LOADING = 2;
  Engine2.DELAYLOADSTATE_NOTLOADED = 4;
  Engine2.NEVER = 512;
  Engine2.ALWAYS = 519;
  Engine2.LESS = 513;
  Engine2.EQUAL = 514;
  Engine2.LEQUAL = 515;
  Engine2.GREATER = 516;
  Engine2.GEQUAL = 518;
  Engine2.NOTEQUAL = 517;
  Engine2.KEEP = 7680;
  Engine2.REPLACE = 7681;
  Engine2.INCR = 7682;
  Engine2.DECR = 7683;
  Engine2.INVERT = 5386;
  Engine2.INCR_WRAP = 34055;
  Engine2.DECR_WRAP = 34056;
  Engine2.TEXTURE_CLAMP_ADDRESSMODE = 0;
  Engine2.TEXTURE_WRAP_ADDRESSMODE = 1;
  Engine2.TEXTURE_MIRROR_ADDRESSMODE = 2;
  Engine2.TEXTUREFORMAT_ALPHA = 0;
  Engine2.TEXTUREFORMAT_LUMINANCE = 1;
  Engine2.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
  Engine2.TEXTUREFORMAT_RGB = 4;
  Engine2.TEXTUREFORMAT_RGBA = 5;
  Engine2.TEXTUREFORMAT_RED = 6;
  Engine2.TEXTUREFORMAT_R = 6;
  Engine2.TEXTUREFORMAT_RG = 7;
  Engine2.TEXTUREFORMAT_RED_INTEGER = 8;
  Engine2.TEXTUREFORMAT_R_INTEGER = 8;
  Engine2.TEXTUREFORMAT_RG_INTEGER = 9;
  Engine2.TEXTUREFORMAT_RGB_INTEGER = 10;
  Engine2.TEXTUREFORMAT_RGBA_INTEGER = 11;
  Engine2.TEXTURETYPE_UNSIGNED_BYTE = 0;
  Engine2.TEXTURETYPE_UNSIGNED_INT = 0;
  Engine2.TEXTURETYPE_FLOAT = 1;
  Engine2.TEXTURETYPE_HALF_FLOAT = 2;
  Engine2.TEXTURETYPE_BYTE = 3;
  Engine2.TEXTURETYPE_SHORT = 4;
  Engine2.TEXTURETYPE_UNSIGNED_SHORT = 5;
  Engine2.TEXTURETYPE_INT = 6;
  Engine2.TEXTURETYPE_UNSIGNED_INTEGER = 7;
  Engine2.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
  Engine2.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
  Engine2.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
  Engine2.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
  Engine2.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
  Engine2.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
  Engine2.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
  Engine2.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
  Engine2.TEXTURE_NEAREST_SAMPLINGMODE = 1;
  Engine2.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
  Engine2.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
  Engine2.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
  Engine2.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
  Engine2.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
  Engine2.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
  Engine2.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
  Engine2.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
  Engine2.TEXTURE_NEAREST_LINEAR = 7;
  Engine2.TEXTURE_NEAREST_NEAREST = 1;
  Engine2.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
  Engine2.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
  Engine2.TEXTURE_LINEAR_LINEAR = 2;
  Engine2.TEXTURE_LINEAR_NEAREST = 12;
  Engine2.TEXTURE_EXPLICIT_MODE = 0;
  Engine2.TEXTURE_SPHERICAL_MODE = 1;
  Engine2.TEXTURE_PLANAR_MODE = 2;
  Engine2.TEXTURE_CUBIC_MODE = 3;
  Engine2.TEXTURE_PROJECTION_MODE = 4;
  Engine2.TEXTURE_SKYBOX_MODE = 5;
  Engine2.TEXTURE_INVCUBIC_MODE = 6;
  Engine2.TEXTURE_EQUIRECTANGULAR_MODE = 7;
  Engine2.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
  Engine2.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
  Engine2.SCALEMODE_FLOOR = 1;
  Engine2.SCALEMODE_NEAREST = 2;
  Engine2.SCALEMODE_CEILING = 3;
  Engine2._RescalePostProcessFactory = null;
  Engine2._RenderPassIdCounter = 0;
  return Engine2;
}(ThinEngine);
ThinEngine.prototype._debugPushGroup = function(groupName, targetObject) {
};
ThinEngine.prototype._debugPopGroup = function(targetObject) {
};
ThinEngine.prototype._debugInsertMarker = function(text, targetObject) {
};
ThinEngine.prototype._debugFlushPendingCommands = function() {
};
function createEngine(canvas) {
  const engine = new Engine(canvas, true, {
    preserveDrawingBuffer: true,
    stencil: true
  });
  return engine;
}
var cloneValue = function(source, destinationObject) {
  if (!source) {
    return null;
  }
  if (source.getClassName && source.getClassName() === "Mesh") {
    return null;
  }
  if (source.getClassName && source.getClassName() === "SubMesh") {
    return source.clone(destinationObject);
  } else if (source.clone) {
    return source.clone();
  }
  return null;
};
function getAllPropertyNames(obj) {
  var props = [];
  do {
    Object.getOwnPropertyNames(obj).forEach(function(prop) {
      if (props.indexOf(prop) === -1) {
        props.push(prop);
      }
    });
  } while (obj = Object.getPrototypeOf(obj));
  return props;
}
var DeepCopier = function() {
  function DeepCopier2() {
  }
  DeepCopier2.DeepCopy = function(source, destination, doNotCopyList, mustCopyList) {
    var properties = getAllPropertyNames(source);
    for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
      var prop = properties_1[_i];
      if (prop[0] === "_" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {
        continue;
      }
      if (EndsWith(prop, "Observable")) {
        continue;
      }
      if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {
        continue;
      }
      var sourceValue = source[prop];
      var typeOfSourceValue = typeof sourceValue;
      if (typeOfSourceValue === "function") {
        continue;
      }
      try {
        if (typeOfSourceValue === "object") {
          if (sourceValue instanceof Array) {
            destination[prop] = [];
            if (sourceValue.length > 0) {
              if (typeof sourceValue[0] == "object") {
                for (var index = 0; index < sourceValue.length; index++) {
                  var clonedValue = cloneValue(sourceValue[index], destination);
                  if (destination[prop].indexOf(clonedValue) === -1) {
                    destination[prop].push(clonedValue);
                  }
                }
              } else {
                destination[prop] = sourceValue.slice(0);
              }
            }
          } else {
            destination[prop] = cloneValue(sourceValue, destination);
          }
        } else {
          destination[prop] = sourceValue;
        }
      } catch (e) {
        Logger.Warn(e.message);
      }
    }
  };
  return DeepCopier2;
}();
function createXMLHttpRequest() {
  if (typeof _native !== "undefined" && _native.XMLHttpRequest) {
    return new _native.XMLHttpRequest();
  } else {
    return new XMLHttpRequest();
  }
}
var WebRequest = function() {
  function WebRequest2() {
    this._xhr = createXMLHttpRequest();
  }
  WebRequest2.prototype._injectCustomRequestHeaders = function() {
    for (var key in WebRequest2.CustomRequestHeaders) {
      var val = WebRequest2.CustomRequestHeaders[key];
      if (val) {
        this._xhr.setRequestHeader(key, val);
      }
    }
  };
  Object.defineProperty(WebRequest2.prototype, "onprogress", {
    get: function() {
      return this._xhr.onprogress;
    },
    set: function(value) {
      this._xhr.onprogress = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "readyState", {
    get: function() {
      return this._xhr.readyState;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "status", {
    get: function() {
      return this._xhr.status;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "statusText", {
    get: function() {
      return this._xhr.statusText;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "response", {
    get: function() {
      return this._xhr.response;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "responseURL", {
    get: function() {
      return this._xhr.responseURL;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "responseText", {
    get: function() {
      return this._xhr.responseText;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "responseType", {
    get: function() {
      return this._xhr.responseType;
    },
    set: function(value) {
      this._xhr.responseType = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "timeout", {
    get: function() {
      return this._xhr.timeout;
    },
    set: function(value) {
      this._xhr.timeout = value;
    },
    enumerable: false,
    configurable: true
  });
  WebRequest2.prototype.addEventListener = function(type, listener, options) {
    this._xhr.addEventListener(type, listener, options);
  };
  WebRequest2.prototype.removeEventListener = function(type, listener, options) {
    this._xhr.removeEventListener(type, listener, options);
  };
  WebRequest2.prototype.abort = function() {
    this._xhr.abort();
  };
  WebRequest2.prototype.send = function(body) {
    if (WebRequest2.CustomRequestHeaders) {
      this._injectCustomRequestHeaders();
    }
    this._xhr.send(body);
  };
  WebRequest2.prototype.open = function(method, url) {
    for (var _i = 0, _a = WebRequest2.CustomRequestModifiers; _i < _a.length; _i++) {
      var update = _a[_i];
      update(this._xhr, url);
    }
    url = url.replace("file:http:", "http:");
    url = url.replace("file:https:", "https:");
    return this._xhr.open(method, url, true);
  };
  WebRequest2.prototype.setRequestHeader = function(name2, value) {
    this._xhr.setRequestHeader(name2, value);
  };
  WebRequest2.prototype.getResponseHeader = function(name2) {
    return this._xhr.getResponseHeader(name2);
  };
  WebRequest2.CustomRequestHeaders = {};
  WebRequest2.CustomRequestModifiers = new Array();
  return WebRequest2;
}();
var FilesInputStore = function() {
  function FilesInputStore2() {
  }
  FilesInputStore2.FilesToLoad = {};
  return FilesInputStore2;
}();
var RetryStrategy = function() {
  function RetryStrategy2() {
  }
  RetryStrategy2.ExponentialBackoff = function(maxRetries, baseInterval) {
    if (maxRetries === void 0) {
      maxRetries = 3;
    }
    if (baseInterval === void 0) {
      baseInterval = 500;
    }
    return function(url, request, retryIndex) {
      if (request.status !== 0 || retryIndex >= maxRetries || url.indexOf("file:") !== -1) {
        return -1;
      }
      return Math.pow(2, retryIndex) * baseInterval;
    };
  };
  return RetryStrategy2;
}();
var BaseError = function(_super) {
  __extends(BaseError2, _super);
  function BaseError2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  BaseError2._setPrototypeOf = Object.setPrototypeOf || function(o, proto) {
    o.__proto__ = proto;
    return o;
  };
  return BaseError2;
}(Error);
var ErrorCodes = {
  MeshInvalidPositionsError: 0,
  UnsupportedTextureError: 1e3,
  GLTFLoaderUnexpectedMagicError: 2e3,
  SceneLoaderError: 3e3,
  LoadFileError: 4e3,
  RequestFileError: 4001,
  ReadFileError: 4002
};
var RuntimeError = function(_super) {
  __extends(RuntimeError2, _super);
  function RuntimeError2(message, errorCode, innerError) {
    var _this = _super.call(this, message) || this;
    _this.errorCode = errorCode;
    _this.innerError = innerError;
    _this.name = "RuntimeError";
    BaseError._setPrototypeOf(_this, RuntimeError2.prototype);
    return _this;
  }
  return RuntimeError2;
}(BaseError);
var TimingTools = function() {
  function TimingTools2() {
  }
  TimingTools2.SetImmediate = function(action) {
    if (IsWindowObjectExist() && window.setImmediate) {
      window.setImmediate(action);
    } else {
      setTimeout(action, 1);
    }
  };
  return TimingTools2;
}();
var FileTools;
var _injectLTSFileTools = function(DecodeBase64UrlToBinary2, DecodeBase64UrlToString2, FileToolsOptions2, IsBase64DataUrl2, IsFileURL2, LoadFile2, LoadImage2, ReadFile2, RequestFile2, SetCorsBehavior2) {
  FileTools = {
    DecodeBase64UrlToBinary: DecodeBase64UrlToBinary2,
    DecodeBase64UrlToString: DecodeBase64UrlToString2,
    DefaultRetryStrategy: FileToolsOptions2.DefaultRetryStrategy,
    BaseUrl: FileToolsOptions2.BaseUrl,
    CorsBehavior: FileToolsOptions2.CorsBehavior,
    PreprocessUrl: FileToolsOptions2.PreprocessUrl,
    IsBase64DataUrl: IsBase64DataUrl2,
    IsFileURL: IsFileURL2,
    LoadFile: LoadFile2,
    LoadImage: LoadImage2,
    ReadFile: ReadFile2,
    RequestFile: RequestFile2,
    SetCorsBehavior: SetCorsBehavior2
  };
  Object.defineProperty(FileTools, "DefaultRetryStrategy", {
    get: function() {
      return FileToolsOptions2.DefaultRetryStrategy;
    },
    set: function(value) {
      FileToolsOptions2.DefaultRetryStrategy = value;
    }
  });
  Object.defineProperty(FileTools, "BaseUrl", {
    get: function() {
      return FileToolsOptions2.BaseUrl;
    },
    set: function(value) {
      FileToolsOptions2.BaseUrl = value;
    }
  });
  Object.defineProperty(FileTools, "PreprocessUrl", {
    get: function() {
      return FileToolsOptions2.PreprocessUrl;
    },
    set: function(value) {
      FileToolsOptions2.PreprocessUrl = value;
    }
  });
  Object.defineProperty(FileTools, "CorsBehavior", {
    get: function() {
      return FileToolsOptions2.CorsBehavior;
    },
    set: function(value) {
      FileToolsOptions2.CorsBehavior = value;
    }
  });
};
var base64DataUrlRegEx = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);
var LoadFileError = function(_super) {
  __extends(LoadFileError2, _super);
  function LoadFileError2(message, object) {
    var _this = _super.call(this, message, ErrorCodes.LoadFileError) || this;
    _this.name = "LoadFileError";
    BaseError._setPrototypeOf(_this, LoadFileError2.prototype);
    if (object instanceof WebRequest) {
      _this.request = object;
    } else {
      _this.file = object;
    }
    return _this;
  }
  return LoadFileError2;
}(RuntimeError);
var RequestFileError = function(_super) {
  __extends(RequestFileError2, _super);
  function RequestFileError2(message, request) {
    var _this = _super.call(this, message, ErrorCodes.RequestFileError) || this;
    _this.request = request;
    _this.name = "RequestFileError";
    BaseError._setPrototypeOf(_this, RequestFileError2.prototype);
    return _this;
  }
  return RequestFileError2;
}(RuntimeError);
var ReadFileError = function(_super) {
  __extends(ReadFileError2, _super);
  function ReadFileError2(message, file) {
    var _this = _super.call(this, message, ErrorCodes.ReadFileError) || this;
    _this.file = file;
    _this.name = "ReadFileError";
    BaseError._setPrototypeOf(_this, ReadFileError2.prototype);
    return _this;
  }
  return ReadFileError2;
}(RuntimeError);
var FileToolsOptions = {
  DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),
  BaseUrl: "",
  CorsBehavior: "anonymous",
  PreprocessUrl: function(url) {
    return url;
  }
};
var _CleanUrl = function(url) {
  url = url.replace(/#/mg, "%23");
  return url;
};
var SetCorsBehavior = function(url, element) {
  if (url && url.indexOf("data:") === 0) {
    return;
  }
  if (FileToolsOptions.CorsBehavior) {
    if (typeof FileToolsOptions.CorsBehavior === "string" || FileToolsOptions.CorsBehavior instanceof String) {
      element.crossOrigin = FileToolsOptions.CorsBehavior;
    } else {
      var result = FileToolsOptions.CorsBehavior(url);
      if (result) {
        element.crossOrigin = result;
      }
    }
  }
};
var LoadImage = function(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
  var _a;
  if (mimeType === void 0) {
    mimeType = "";
  }
  var url;
  var usingObjectURL = false;
  if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
    if (typeof Blob !== "undefined") {
      url = URL.createObjectURL(new Blob([input], { type: mimeType }));
      usingObjectURL = true;
    } else {
      url = "data:".concat(mimeType, ";base64,") + EncodeArrayBufferToBase64(input);
    }
  } else if (input instanceof Blob) {
    url = URL.createObjectURL(input);
    usingObjectURL = true;
  } else {
    url = _CleanUrl(input);
    url = FileToolsOptions.PreprocessUrl(input);
  }
  var engine = EngineStore.LastCreatedEngine;
  var onErrorHandler = function(exception) {
    if (onError) {
      var inputText = url || input.toString();
      onError("Error while trying to load image: ".concat(inputText.indexOf("http") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + "..."), exception);
    }
  };
  if (typeof Image === "undefined" || ((_a = engine === null || engine === void 0 ? void 0 : engine._features.forceBitmapOverHTMLImageElement) !== null && _a !== void 0 ? _a : false)) {
    LoadFile(url, function(data) {
      engine.createImageBitmap(new Blob([data], { type: mimeType }), __assign({ premultiplyAlpha: "none" }, imageBitmapOptions)).then(function(imgBmp) {
        onLoad(imgBmp);
        if (usingObjectURL) {
          URL.revokeObjectURL(url);
        }
      }).catch(function(reason) {
        if (onError) {
          onError("Error while trying to load image: " + input, reason);
        }
      });
    }, void 0, offlineProvider || void 0, true, function(request, exception) {
      onErrorHandler(exception);
    });
    return null;
  }
  var img = new Image();
  SetCorsBehavior(url, img);
  var loadHandler = function() {
    img.removeEventListener("load", loadHandler);
    img.removeEventListener("error", errorHandler);
    onLoad(img);
    if (usingObjectURL && img.src) {
      URL.revokeObjectURL(img.src);
    }
  };
  var errorHandler = function(err) {
    img.removeEventListener("load", loadHandler);
    img.removeEventListener("error", errorHandler);
    onErrorHandler(err);
    if (usingObjectURL && img.src) {
      URL.revokeObjectURL(img.src);
    }
  };
  img.addEventListener("load", loadHandler);
  img.addEventListener("error", errorHandler);
  var noOfflineSupport = function() {
    img.src = url;
  };
  var loadFromOfflineSupport = function() {
    if (offlineProvider) {
      offlineProvider.loadImage(url, img);
    }
  };
  if (url.substr(0, 5) !== "blob:" && url.substr(0, 5) !== "data:" && offlineProvider && offlineProvider.enableTexturesOffline) {
    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
  } else {
    if (url.indexOf("file:") !== -1) {
      var textureName = decodeURIComponent(url.substring(5).toLowerCase());
      if (FilesInputStore.FilesToLoad[textureName]) {
        try {
          var blobURL;
          try {
            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
          } catch (ex) {
            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
          }
          img.src = blobURL;
          usingObjectURL = true;
        } catch (e) {
          img.src = "";
        }
        return img;
      }
    }
    noOfflineSupport();
  }
  return img;
};
var ReadFile = function(file, onSuccess, onProgress, useArrayBuffer, onError) {
  var reader = new FileReader();
  var fileRequest = {
    onCompleteObservable: new Observable(),
    abort: function() {
      return reader.abort();
    }
  };
  reader.onloadend = function(e) {
    return fileRequest.onCompleteObservable.notifyObservers(fileRequest);
  };
  if (onError) {
    reader.onerror = function(e) {
      onError(new ReadFileError("Unable to read ".concat(file.name), file));
    };
  }
  reader.onload = function(e) {
    onSuccess(e.target["result"]);
  };
  if (onProgress) {
    reader.onprogress = onProgress;
  }
  if (!useArrayBuffer) {
    reader.readAsText(file);
  } else {
    reader.readAsArrayBuffer(file);
  }
  return fileRequest;
};
var LoadFile = function(fileOrUrl, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) {
  if (fileOrUrl.name) {
    return ReadFile(fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError ? function(error) {
      onError(void 0, error);
    } : void 0);
  }
  var url = fileOrUrl;
  if (url.indexOf("file:") !== -1) {
    var fileName = decodeURIComponent(url.substring(5).toLowerCase());
    if (fileName.indexOf("./") === 0) {
      fileName = fileName.substring(2);
    }
    var file = FilesInputStore.FilesToLoad[fileName];
    if (file) {
      return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? function(error) {
        return onError(void 0, new LoadFileError(error.message, error.file));
      } : void 0);
    }
  }
  if (IsBase64DataUrl(url)) {
    var fileRequest_1 = {
      onCompleteObservable: new Observable(),
      abort: function() {
        return function() {
        };
      }
    };
    try {
      onSuccess(useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url));
    } catch (error) {
      if (onError) {
        onError(void 0, error);
      } else {
        Logger.Error(error.message || "Failed to parse the Data URL");
      }
    }
    TimingTools.SetImmediate(function() {
      fileRequest_1.onCompleteObservable.notifyObservers(fileRequest_1);
    });
    return fileRequest_1;
  }
  return RequestFile(url, function(data, request) {
    onSuccess(data, request ? request.responseURL : void 0);
  }, onProgress, offlineProvider, useArrayBuffer, onError ? function(error) {
    onError(error.request, new LoadFileError(error.message, error.request));
  } : void 0, onOpened);
};
var RequestFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) {
  url = _CleanUrl(url);
  url = FileToolsOptions.PreprocessUrl(url);
  var loadUrl = FileToolsOptions.BaseUrl + url;
  var aborted = false;
  var fileRequest = {
    onCompleteObservable: new Observable(),
    abort: function() {
      return aborted = true;
    }
  };
  var requestFile = function() {
    var request = new WebRequest();
    var retryHandle = null;
    var onReadyStateChange;
    var onLoadEnd = function() {
      if (request) {
        if (onProgress) {
          request.removeEventListener("progress", onProgress);
        }
        if (onReadyStateChange) {
          request.removeEventListener("readystatechange", onReadyStateChange);
        }
        request.removeEventListener("loadend", onLoadEnd);
      }
      fileRequest.onCompleteObservable.notifyObservers(fileRequest);
      fileRequest.onCompleteObservable.clear();
    };
    fileRequest.abort = function() {
      aborted = true;
      onLoadEnd();
      if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {
        request.abort();
      }
      if (retryHandle !== null) {
        clearTimeout(retryHandle);
        retryHandle = null;
      }
      request = null;
    };
    var handleError = function(error) {
      var message = error.message || "Unknown error";
      if (onError && request) {
        onError(new RequestFileError(message, request));
      } else {
        Logger.Error(message);
      }
    };
    var retryLoop = function(retryIndex) {
      if (!request) {
        return;
      }
      request.open("GET", loadUrl);
      if (onOpened) {
        try {
          onOpened(request);
        } catch (e) {
          handleError(e);
          return;
        }
      }
      if (useArrayBuffer) {
        request.responseType = "arraybuffer";
      }
      if (onProgress) {
        request.addEventListener("progress", onProgress);
      }
      request.addEventListener("loadend", onLoadEnd);
      onReadyStateChange = function() {
        if (aborted || !request) {
          return;
        }
        if (request.readyState === (XMLHttpRequest.DONE || 4)) {
          request.removeEventListener("readystatechange", onReadyStateChange);
          if (request.status >= 200 && request.status < 300 || request.status === 0 && (!IsWindowObjectExist() || IsFileURL())) {
            try {
              onSuccess(useArrayBuffer ? request.response : request.responseText, request);
            } catch (e) {
              handleError(e);
            }
            return;
          }
          var retryStrategy = FileToolsOptions.DefaultRetryStrategy;
          if (retryStrategy) {
            var waitTime = retryStrategy(loadUrl, request, retryIndex);
            if (waitTime !== -1) {
              request.removeEventListener("loadend", onLoadEnd);
              request = new WebRequest();
              retryHandle = setTimeout(function() {
                return retryLoop(retryIndex + 1);
              }, waitTime);
              return;
            }
          }
          var error = new RequestFileError("Error status: " + request.status + " " + request.statusText + " - Unable to load " + loadUrl, request);
          if (onError) {
            onError(error);
          }
        }
      };
      request.addEventListener("readystatechange", onReadyStateChange);
      request.send();
    };
    retryLoop(0);
  };
  if (offlineProvider && offlineProvider.enableSceneOffline) {
    var noOfflineSupport_1 = function(request) {
      if (request && request.status > 400) {
        if (onError) {
          onError(request);
        }
      } else {
        requestFile();
      }
    };
    var loadFromOfflineSupport = function() {
      if (offlineProvider) {
        offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, function(data) {
          if (!aborted) {
            onSuccess(data);
          }
          fileRequest.onCompleteObservable.notifyObservers(fileRequest);
        }, onProgress ? function(event) {
          if (!aborted) {
            onProgress(event);
          }
        } : void 0, noOfflineSupport_1, useArrayBuffer);
      }
    };
    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport_1);
  } else {
    requestFile();
  }
  return fileRequest;
};
var IsFileURL = function() {
  return typeof location !== "undefined" && location.protocol === "file:";
};
var IsBase64DataUrl = function(uri) {
  return base64DataUrlRegEx.test(uri);
};
function DecodeBase64UrlToBinary(uri) {
  return DecodeBase64ToBinary(uri.split(",")[1]);
}
var DecodeBase64UrlToString = function(uri) {
  return DecodeBase64ToString(uri.split(",")[1]);
};
var initSideEffects = function() {
  ThinEngine._FileToolsLoadImage = LoadImage;
  ThinEngine._FileToolsLoadFile = LoadFile;
  ShaderProcessor._FileToolsLoadFile = LoadFile;
};
initSideEffects();
_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);
var PromiseStates;
(function(PromiseStates2) {
  PromiseStates2[PromiseStates2["Pending"] = 0] = "Pending";
  PromiseStates2[PromiseStates2["Fulfilled"] = 1] = "Fulfilled";
  PromiseStates2[PromiseStates2["Rejected"] = 2] = "Rejected";
})(PromiseStates || (PromiseStates = {}));
var FulFillmentAgregator = function() {
  function FulFillmentAgregator2() {
    this.count = 0;
    this.target = 0;
    this.results = [];
  }
  return FulFillmentAgregator2;
}();
var InternalPromise = function() {
  function InternalPromise2(resolver) {
    var _this = this;
    this._state = PromiseStates.Pending;
    this._children = new Array();
    this._rejectWasConsumed = false;
    if (!resolver) {
      return;
    }
    try {
      resolver(function(value) {
        _this._resolve(value);
      }, function(reason) {
        _this._reject(reason);
      });
    } catch (e) {
      this._reject(e);
    }
  }
  Object.defineProperty(InternalPromise2.prototype, "_result", {
    get: function() {
      return this._resultValue;
    },
    set: function(value) {
      this._resultValue = value;
      if (this._parent && this._parent._result === void 0) {
        this._parent._result = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  InternalPromise2.prototype.catch = function(onRejected) {
    return this.then(void 0, onRejected);
  };
  InternalPromise2.prototype.then = function(onFulfilled, onRejected) {
    var _this = this;
    var newPromise = new InternalPromise2();
    newPromise._onFulfilled = onFulfilled;
    newPromise._onRejected = onRejected;
    this._children.push(newPromise);
    newPromise._parent = this;
    if (this._state !== PromiseStates.Pending) {
      setTimeout(function() {
        if (_this._state === PromiseStates.Fulfilled || _this._rejectWasConsumed) {
          newPromise._resolve(_this._result);
        } else {
          newPromise._reject(_this._reason);
        }
      });
    }
    return newPromise;
  };
  InternalPromise2.prototype._moveChildren = function(children) {
    var _a;
    var _this = this;
    (_a = this._children).push.apply(_a, children.splice(0, children.length));
    this._children.forEach(function(child2) {
      child2._parent = _this;
    });
    if (this._state === PromiseStates.Fulfilled) {
      for (var _i = 0, _b = this._children; _i < _b.length; _i++) {
        var child = _b[_i];
        child._resolve(this._result);
      }
    } else if (this._state === PromiseStates.Rejected) {
      for (var _c = 0, _d = this._children; _c < _d.length; _c++) {
        var child = _d[_c];
        child._reject(this._reason);
      }
    }
  };
  InternalPromise2.prototype._resolve = function(value) {
    try {
      this._state = PromiseStates.Fulfilled;
      var returnedValue = null;
      if (this._onFulfilled) {
        returnedValue = this._onFulfilled(value);
      }
      if (returnedValue !== void 0 && returnedValue !== null) {
        if (returnedValue._state !== void 0) {
          var returnedPromise = returnedValue;
          returnedPromise._parent = this;
          returnedPromise._moveChildren(this._children);
          value = returnedPromise._result;
        } else {
          value = returnedValue;
        }
      }
      this._result = value;
      for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
        var child = _a[_i];
        child._resolve(value);
      }
      this._children.length = 0;
      delete this._onFulfilled;
      delete this._onRejected;
    } catch (e) {
      this._reject(e, true);
    }
  };
  InternalPromise2.prototype._reject = function(reason, onLocalThrow) {
    if (onLocalThrow === void 0) {
      onLocalThrow = false;
    }
    this._state = PromiseStates.Rejected;
    this._reason = reason;
    if (this._onRejected && !onLocalThrow) {
      try {
        this._onRejected(reason);
        this._rejectWasConsumed = true;
      } catch (e) {
        reason = e;
      }
    }
    for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
      var child = _a[_i];
      if (this._rejectWasConsumed) {
        child._resolve(null);
      } else {
        child._reject(reason);
      }
    }
    this._children.length = 0;
    delete this._onFulfilled;
    delete this._onRejected;
  };
  InternalPromise2.resolve = function(value) {
    var newPromise = new InternalPromise2();
    newPromise._resolve(value);
    return newPromise;
  };
  InternalPromise2._RegisterForFulfillment = function(promise, agregator, index) {
    promise.then(function(value) {
      agregator.results[index] = value;
      agregator.count++;
      if (agregator.count === agregator.target) {
        agregator.rootPromise._resolve(agregator.results);
      }
      return null;
    }, function(reason) {
      if (agregator.rootPromise._state !== PromiseStates.Rejected) {
        agregator.rootPromise._reject(reason);
      }
    });
  };
  InternalPromise2.all = function(promises) {
    var newPromise = new InternalPromise2();
    var agregator = new FulFillmentAgregator();
    agregator.target = promises.length;
    agregator.rootPromise = newPromise;
    if (promises.length) {
      for (var index = 0; index < promises.length; index++) {
        InternalPromise2._RegisterForFulfillment(promises[index], agregator, index);
      }
    } else {
      newPromise._resolve([]);
    }
    return newPromise;
  };
  InternalPromise2.race = function(promises) {
    var newPromise = new InternalPromise2();
    if (promises.length) {
      for (var _i = 0, promises_1 = promises; _i < promises_1.length; _i++) {
        var promise = promises_1[_i];
        promise.then(function(value) {
          if (newPromise) {
            newPromise._resolve(value);
            newPromise = null;
          }
          return null;
        }, function(reason) {
          if (newPromise) {
            newPromise._reject(reason);
            newPromise = null;
          }
        });
      }
    }
    return newPromise;
  };
  return InternalPromise2;
}();
var PromisePolyfill = function() {
  function PromisePolyfill2() {
  }
  PromisePolyfill2.Apply = function(force) {
    if (force === void 0) {
      force = false;
    }
    if (force || typeof Promise === "undefined") {
      var root = window;
      root.Promise = InternalPromise;
    }
  };
  return PromisePolyfill2;
}();
var InstantiationTools = function() {
  function InstantiationTools2() {
  }
  InstantiationTools2.Instantiate = function(className) {
    if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[className]) {
      return this.RegisteredExternalClasses[className];
    }
    var internalClass = GetClass(className);
    if (internalClass) {
      return internalClass;
    }
    Logger.Warn(className + " not found, you may have missed an import.");
    var arr = className.split(".");
    var fn = window || this;
    for (var i = 0, len = arr.length; i < len; i++) {
      fn = fn[arr[i]];
    }
    if (typeof fn !== "function") {
      return null;
    }
    return fn;
  };
  InstantiationTools2.RegisteredExternalClasses = {};
  return InstantiationTools2;
}();
function RandomGUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var SliceTools = function() {
  function SliceTools2() {
  }
  SliceTools2.Slice = function(data, start, end) {
    if (data.slice) {
      return data.slice(start, end);
    }
    return Array.prototype.slice.call(data, start, end);
  };
  SliceTools2.SliceToArray = function(data, start, end) {
    if (Array.isArray(data)) {
      return data.slice(start, end);
    }
    return Array.prototype.slice.call(data, start, end);
  };
  return SliceTools2;
}();
var Tools = function() {
  function Tools2() {
  }
  Object.defineProperty(Tools2, "BaseUrl", {
    get: function() {
      return FileToolsOptions.BaseUrl;
    },
    set: function(value) {
      FileToolsOptions.BaseUrl = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "DefaultRetryStrategy", {
    get: function() {
      return FileToolsOptions.DefaultRetryStrategy;
    },
    set: function(strategy) {
      FileToolsOptions.DefaultRetryStrategy = strategy;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "CorsBehavior", {
    get: function() {
      return FileToolsOptions.CorsBehavior;
    },
    set: function(value) {
      FileToolsOptions.CorsBehavior = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "UseFallbackTexture", {
    get: function() {
      return EngineStore.UseFallbackTexture;
    },
    set: function(value) {
      EngineStore.UseFallbackTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "RegisteredExternalClasses", {
    get: function() {
      return InstantiationTools.RegisteredExternalClasses;
    },
    set: function(classes) {
      InstantiationTools.RegisteredExternalClasses = classes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "fallbackTexture", {
    get: function() {
      return EngineStore.FallbackTexture;
    },
    set: function(value) {
      EngineStore.FallbackTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.FetchToRef = function(u, v, width, height, pixels, color) {
    var wrappedU = Math.abs(u) * width % width | 0;
    var wrappedV = Math.abs(v) * height % height | 0;
    var position = (wrappedU + wrappedV * width) * 4;
    color.r = pixels[position] / 255;
    color.g = pixels[position + 1] / 255;
    color.b = pixels[position + 2] / 255;
    color.a = pixels[position + 3] / 255;
  };
  Tools2.Mix = function(a, b, alpha) {
    return a * (1 - alpha) + b * alpha;
  };
  Tools2.Instantiate = function(className) {
    return InstantiationTools.Instantiate(className);
  };
  Tools2.Slice = function(data, start, end) {
    return SliceTools.Slice(data, start, end);
  };
  Tools2.SliceToArray = function(data, start, end) {
    return SliceTools.SliceToArray(data, start, end);
  };
  Tools2.SetImmediate = function(action) {
    TimingTools.SetImmediate(action);
  };
  Tools2.IsExponentOfTwo = function(value) {
    var count = 1;
    do {
      count *= 2;
    } while (count < value);
    return count === value;
  };
  Tools2.FloatRound = function(value) {
    if (Math.fround) {
      return Math.fround(value);
    }
    return Tools2._tmpFloatArray[0] = value, Tools2._tmpFloatArray[0];
  };
  Tools2.GetFilename = function(path) {
    var index = path.lastIndexOf("/");
    if (index < 0) {
      return path;
    }
    return path.substring(index + 1);
  };
  Tools2.GetFolderPath = function(uri, returnUnchangedIfNoSlash) {
    if (returnUnchangedIfNoSlash === void 0) {
      returnUnchangedIfNoSlash = false;
    }
    var index = uri.lastIndexOf("/");
    if (index < 0) {
      if (returnUnchangedIfNoSlash) {
        return uri;
      }
      return "";
    }
    return uri.substring(0, index + 1);
  };
  Tools2.ToDegrees = function(angle) {
    return angle * 180 / Math.PI;
  };
  Tools2.ToRadians = function(angle) {
    return angle * Math.PI / 180;
  };
  Tools2.MakeArray = function(obj, allowsNullUndefined) {
    if (allowsNullUndefined !== true && (obj === void 0 || obj == null)) {
      return null;
    }
    return Array.isArray(obj) ? obj : [obj];
  };
  Tools2.GetPointerPrefix = function(engine) {
    var eventPrefix = "pointer";
    if (IsWindowObjectExist() && !window.PointerEvent) {
      eventPrefix = "mouse";
    }
    if (engine._badDesktopOS && !engine._badOS && !(document && "ontouchend" in document)) {
      eventPrefix = "mouse";
    }
    return eventPrefix;
  };
  Tools2.SetCorsBehavior = function(url, element) {
    SetCorsBehavior(url, element);
  };
  Tools2.CleanUrl = function(url) {
    url = url.replace(/#/gm, "%23");
    return url;
  };
  Object.defineProperty(Tools2, "PreprocessUrl", {
    get: function() {
      return FileToolsOptions.PreprocessUrl;
    },
    set: function(processor) {
      FileToolsOptions.PreprocessUrl = processor;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.LoadImage = function(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
    return LoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions);
  };
  Tools2.LoadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    return LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
  };
  Tools2.LoadFileAsync = function(url, useArrayBuffer) {
    if (useArrayBuffer === void 0) {
      useArrayBuffer = true;
    }
    return new Promise(function(resolve, reject) {
      LoadFile(url, function(data) {
        resolve(data);
      }, void 0, void 0, useArrayBuffer, function(request, exception) {
        reject(exception);
      });
    });
  };
  Tools2.LoadScript = function(scriptUrl, onSuccess, onError, scriptId) {
    if (!IsWindowObjectExist()) {
      return;
    }
    var head = document.getElementsByTagName("head")[0];
    var script = document.createElement("script");
    script.setAttribute("type", "text/javascript");
    script.setAttribute("src", scriptUrl);
    if (scriptId) {
      script.id = scriptId;
    }
    script.onload = function() {
      if (onSuccess) {
        onSuccess();
      }
    };
    script.onerror = function(e) {
      if (onError) {
        onError("Unable to load script '".concat(scriptUrl, "'"), e);
      }
    };
    head.appendChild(script);
  };
  Tools2.LoadScriptAsync = function(scriptUrl, scriptId) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this.LoadScript(scriptUrl, function() {
        resolve();
      }, function(message, exception) {
        reject(exception);
      });
    });
  };
  Tools2.ReadFileAsDataURL = function(fileToLoad, callback, progressCallback) {
    var reader = new FileReader();
    var request = {
      onCompleteObservable: new Observable(),
      abort: function() {
        return reader.abort();
      }
    };
    reader.onloadend = function(e) {
      request.onCompleteObservable.notifyObservers(request);
    };
    reader.onload = function(e) {
      callback(e.target["result"]);
    };
    reader.onprogress = progressCallback;
    reader.readAsDataURL(fileToLoad);
    return request;
  };
  Tools2.ReadFile = function(file, onSuccess, onProgress, useArrayBuffer, onError) {
    return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
  };
  Tools2.FileAsURL = function(content) {
    var fileBlob = new Blob([content]);
    var url = window.URL || window.webkitURL;
    var link = url.createObjectURL(fileBlob);
    return link;
  };
  Tools2.Format = function(value, decimals) {
    if (decimals === void 0) {
      decimals = 2;
    }
    return value.toFixed(decimals);
  };
  Tools2.DeepCopy = function(source, destination, doNotCopyList, mustCopyList) {
    DeepCopier.DeepCopy(source, destination, doNotCopyList, mustCopyList);
  };
  Tools2.IsEmpty = function(obj) {
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        return false;
      }
    }
    return true;
  };
  Tools2.RegisterTopRootEvents = function(windowElement, events) {
    for (var index = 0; index < events.length; index++) {
      var event = events[index];
      windowElement.addEventListener(event.name, event.handler, false);
      try {
        if (window.parent) {
          window.parent.addEventListener(event.name, event.handler, false);
        }
      } catch (e) {
      }
    }
  };
  Tools2.UnregisterTopRootEvents = function(windowElement, events) {
    for (var index = 0; index < events.length; index++) {
      var event = events[index];
      windowElement.removeEventListener(event.name, event.handler);
      try {
        if (windowElement.parent) {
          windowElement.parent.removeEventListener(event.name, event.handler);
        }
      } catch (e) {
      }
    }
  };
  Tools2.DumpFramebuffer = function(width, height, engine, successCallback, mimeType, fileName) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    return __awaiter(this, void 0, void 0, function() {
      var bufferView, data;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, engine.readPixels(0, 0, width, height)];
          case 1:
            bufferView = _a.sent();
            data = new Uint8Array(bufferView.buffer);
            Tools2.DumpData(width, height, data, successCallback, mimeType, fileName, true);
            return [2];
        }
      });
    });
  };
  Tools2.DumpData = function(width, height, data, successCallback, mimeType, fileName, invertY, toArrayBuffer, quality) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (toArrayBuffer === void 0) {
      toArrayBuffer = false;
    }
    if (!Tools2._ScreenshotCanvas) {
      Tools2._ScreenshotCanvas = document.createElement("canvas");
    }
    Tools2._ScreenshotCanvas.width = width;
    Tools2._ScreenshotCanvas.height = height;
    var context = Tools2._ScreenshotCanvas.getContext("2d");
    if (context) {
      if (data instanceof Float32Array) {
        var data2 = new Uint8Array(data.length);
        var n = data.length;
        while (n--) {
          var v = data[n];
          data2[n] = v < 0 ? 0 : v > 1 ? 1 : Math.round(v * 255);
        }
        data = data2;
      }
      var imageData = context.createImageData(width, height);
      var castData = imageData.data;
      castData.set(data);
      context.putImageData(imageData, 0, 0);
      var canvas = Tools2._ScreenshotCanvas;
      if (invertY) {
        var canvas2 = document.createElement("canvas");
        canvas2.width = width;
        canvas2.height = height;
        var ctx2 = canvas2.getContext("2d");
        if (!ctx2) {
          return;
        }
        ctx2.translate(0, height);
        ctx2.scale(1, -1);
        ctx2.drawImage(Tools2._ScreenshotCanvas, 0, 0);
        canvas = canvas2;
      }
      if (toArrayBuffer) {
        Tools2.ToBlob(canvas, function(blob) {
          var fileReader = new FileReader();
          fileReader.onload = function(event) {
            var arrayBuffer = event.target.result;
            if (successCallback) {
              successCallback(arrayBuffer);
            }
          };
          fileReader.readAsArrayBuffer(blob);
        }, mimeType, quality);
      } else {
        Tools2.EncodeScreenshotCanvasData(successCallback, mimeType, fileName, canvas, quality);
      }
    }
  };
  Tools2.DumpDataAsync = function(width, height, data, mimeType, fileName, invertY, toArrayBuffer, quality) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (toArrayBuffer === void 0) {
      toArrayBuffer = false;
    }
    return new Promise(function(resolve) {
      Tools2.DumpData(width, height, data, function(result) {
        return resolve(result);
      }, mimeType, fileName, invertY, toArrayBuffer, quality);
    });
  };
  Tools2.ToBlob = function(canvas, successCallback, mimeType, quality) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (!canvas.toBlob) {
      canvas.toBlob = function(callback, type, quality2) {
        var _this = this;
        setTimeout(function() {
          var binStr = atob(_this.toDataURL(type, quality2).split(",")[1]), len = binStr.length, arr = new Uint8Array(len);
          for (var i = 0; i < len; i++) {
            arr[i] = binStr.charCodeAt(i);
          }
          callback(new Blob([arr]));
        });
      };
    }
    canvas.toBlob(function(blob) {
      successCallback(blob);
    }, mimeType, quality);
  };
  Tools2.EncodeScreenshotCanvasData = function(successCallback, mimeType, fileName, canvas, quality) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (successCallback) {
      var base64Image = (canvas !== null && canvas !== void 0 ? canvas : Tools2._ScreenshotCanvas).toDataURL(mimeType, quality);
      successCallback(base64Image);
    } else {
      this.ToBlob(canvas !== null && canvas !== void 0 ? canvas : Tools2._ScreenshotCanvas, function(blob) {
        if ("download" in document.createElement("a")) {
          if (!fileName) {
            var date = new Date();
            var stringDate = (date.getFullYear() + "-" + (date.getMonth() + 1)).slice(2) + "-" + date.getDate() + "_" + date.getHours() + "-" + ("0" + date.getMinutes()).slice(-2);
            fileName = "screenshot_" + stringDate + ".png";
          }
          Tools2.Download(blob, fileName);
        } else {
          if (blob) {
            var url = URL.createObjectURL(blob);
            var newWindow = window.open("");
            if (!newWindow) {
              return;
            }
            var img = newWindow.document.createElement("img");
            img.onload = function() {
              URL.revokeObjectURL(url);
            };
            img.src = url;
            newWindow.document.body.appendChild(img);
          }
        }
      }, mimeType, quality);
    }
  };
  Tools2.Download = function(blob, fileName) {
    if (navigator && navigator.msSaveBlob) {
      navigator.msSaveBlob(blob, fileName);
      return;
    }
    var url = window.URL.createObjectURL(blob);
    var a = document.createElement("a");
    document.body.appendChild(a);
    a.style.display = "none";
    a.href = url;
    a.download = fileName;
    a.addEventListener("click", function() {
      if (a.parentElement) {
        a.parentElement.removeChild(a);
      }
    });
    a.click();
    window.URL.revokeObjectURL(url);
  };
  Tools2.BackCompatCameraNoPreventDefault = function(args) {
    if (typeof args[0] === "boolean") {
      return args[0];
    } else if (typeof args[1] === "boolean") {
      return args[1];
    }
    return false;
  };
  Tools2.CreateScreenshot = function(engine, camera, size, successCallback, mimeType) {
    throw _WarnImport("ScreenshotTools");
  };
  Tools2.CreateScreenshotAsync = function(engine, camera, size, mimeType) {
    throw _WarnImport("ScreenshotTools");
  };
  Tools2.CreateScreenshotUsingRenderTarget = function(engine, camera, size, successCallback, mimeType, samples, antialiasing, fileName) {
    throw _WarnImport("ScreenshotTools");
  };
  Tools2.CreateScreenshotUsingRenderTargetAsync = function(engine, camera, size, mimeType, samples, antialiasing, fileName) {
    throw _WarnImport("ScreenshotTools");
  };
  Tools2.RandomId = function() {
    return RandomGUID();
  };
  Tools2.IsBase64 = function(uri) {
    return IsBase64DataUrl(uri);
  };
  Tools2.DecodeBase64 = function(uri) {
    return DecodeBase64UrlToBinary(uri);
  };
  Object.defineProperty(Tools2, "errorsCount", {
    get: function() {
      return Logger.errorsCount;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.Log = function(message) {
    Logger.Log(message);
  };
  Tools2.Warn = function(message) {
    Logger.Warn(message);
  };
  Tools2.Error = function(message) {
    Logger.Error(message);
  };
  Object.defineProperty(Tools2, "LogCache", {
    get: function() {
      return Logger.LogCache;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.ClearLogCache = function() {
    Logger.ClearLogCache();
  };
  Object.defineProperty(Tools2, "LogLevels", {
    set: function(level) {
      Logger.LogLevels = level;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "PerformanceLogLevel", {
    set: function(level) {
      if ((level & Tools2.PerformanceUserMarkLogLevel) === Tools2.PerformanceUserMarkLogLevel) {
        Tools2.StartPerformanceCounter = Tools2._StartUserMark;
        Tools2.EndPerformanceCounter = Tools2._EndUserMark;
        return;
      }
      if ((level & Tools2.PerformanceConsoleLogLevel) === Tools2.PerformanceConsoleLogLevel) {
        Tools2.StartPerformanceCounter = Tools2._StartPerformanceConsole;
        Tools2.EndPerformanceCounter = Tools2._EndPerformanceConsole;
        return;
      }
      Tools2.StartPerformanceCounter = Tools2._StartPerformanceCounterDisabled;
      Tools2.EndPerformanceCounter = Tools2._EndPerformanceCounterDisabled;
    },
    enumerable: false,
    configurable: true
  });
  Tools2._StartPerformanceCounterDisabled = function(counterName, condition) {
  };
  Tools2._EndPerformanceCounterDisabled = function(counterName, condition) {
  };
  Tools2._StartUserMark = function(counterName, condition) {
    if (condition === void 0) {
      condition = true;
    }
    if (!Tools2._performance) {
      if (!IsWindowObjectExist()) {
        return;
      }
      Tools2._performance = window.performance;
    }
    if (!condition || !Tools2._performance.mark) {
      return;
    }
    Tools2._performance.mark(counterName + "-Begin");
  };
  Tools2._EndUserMark = function(counterName, condition) {
    if (condition === void 0) {
      condition = true;
    }
    if (!condition || !Tools2._performance.mark) {
      return;
    }
    Tools2._performance.mark(counterName + "-End");
    Tools2._performance.measure(counterName, counterName + "-Begin", counterName + "-End");
  };
  Tools2._StartPerformanceConsole = function(counterName, condition) {
    if (condition === void 0) {
      condition = true;
    }
    if (!condition) {
      return;
    }
    Tools2._StartUserMark(counterName, condition);
    if (console.time) {
      console.time(counterName);
    }
  };
  Tools2._EndPerformanceConsole = function(counterName, condition) {
    if (condition === void 0) {
      condition = true;
    }
    if (!condition) {
      return;
    }
    Tools2._EndUserMark(counterName, condition);
    console.timeEnd(counterName);
  };
  Object.defineProperty(Tools2, "Now", {
    get: function() {
      return PrecisionDate.Now;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.GetClassName = function(object, isType) {
    if (isType === void 0) {
      isType = false;
    }
    var name2 = null;
    if (!isType && object.getClassName) {
      name2 = object.getClassName();
    } else {
      if (object instanceof Object) {
        var classObj = isType ? object : Object.getPrototypeOf(object);
        name2 = classObj.constructor["__bjsclassName__"];
      }
      if (!name2) {
        name2 = typeof object;
      }
    }
    return name2;
  };
  Tools2.First = function(array, predicate) {
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
      var el = array_1[_i];
      if (predicate(el)) {
        return el;
      }
    }
    return null;
  };
  Tools2.getFullClassName = function(object, isType) {
    if (isType === void 0) {
      isType = false;
    }
    var className = null;
    var moduleName = null;
    if (!isType && object.getClassName) {
      className = object.getClassName();
    } else {
      if (object instanceof Object) {
        var classObj = isType ? object : Object.getPrototypeOf(object);
        className = classObj.constructor["__bjsclassName__"];
        moduleName = classObj.constructor["__bjsmoduleName__"];
      }
      if (!className) {
        className = typeof object;
      }
    }
    if (!className) {
      return null;
    }
    return (moduleName != null ? moduleName + "." : "") + className;
  };
  Tools2.DelayAsync = function(delay) {
    return new Promise(function(resolve) {
      setTimeout(function() {
        resolve();
      }, delay);
    });
  };
  Tools2.IsSafari = function() {
    if (!IsNavigatorAvailable()) {
      return false;
    }
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  };
  Tools2.UseCustomRequestHeaders = false;
  Tools2.CustomRequestHeaders = WebRequest.CustomRequestHeaders;
  Tools2._tmpFloatArray = new Float32Array(1);
  Tools2.GetDOMTextContent = GetDOMTextContent;
  Tools2.GetAbsoluteUrl = typeof document === "object" ? function(url) {
    var a = document.createElement("a");
    a.href = url;
    return a.href;
  } : typeof URL === "function" && typeof location === "object" ? function(url) {
    return new URL(url, location.origin).href;
  } : function(url) {
    throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.");
  };
  Tools2.NoneLogLevel = Logger.NoneLogLevel;
  Tools2.MessageLogLevel = Logger.MessageLogLevel;
  Tools2.WarningLogLevel = Logger.WarningLogLevel;
  Tools2.ErrorLogLevel = Logger.ErrorLogLevel;
  Tools2.AllLogLevel = Logger.AllLogLevel;
  Tools2.IsWindowObjectExist = IsWindowObjectExist;
  Tools2.PerformanceNoneLogLevel = 0;
  Tools2.PerformanceUserMarkLogLevel = 1;
  Tools2.PerformanceConsoleLogLevel = 2;
  Tools2.StartPerformanceCounter = Tools2._StartPerformanceCounterDisabled;
  Tools2.EndPerformanceCounter = Tools2._EndPerformanceCounterDisabled;
  return Tools2;
}();
var AsyncLoop = function() {
  function AsyncLoop2(iterations, func, successCallback, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.iterations = iterations;
    this.index = offset - 1;
    this._done = false;
    this._fn = func;
    this._successCallback = successCallback;
  }
  AsyncLoop2.prototype.executeNext = function() {
    if (!this._done) {
      if (this.index + 1 < this.iterations) {
        ++this.index;
        this._fn(this);
      } else {
        this.breakLoop();
      }
    }
  };
  AsyncLoop2.prototype.breakLoop = function() {
    this._done = true;
    this._successCallback();
  };
  AsyncLoop2.Run = function(iterations, fn, successCallback, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var loop = new AsyncLoop2(iterations, fn, successCallback, offset);
    loop.executeNext();
    return loop;
  };
  AsyncLoop2.SyncAsyncForLoop = function(iterations, syncedIterations, fn, callback, breakFunction, timeout) {
    if (timeout === void 0) {
      timeout = 0;
    }
    return AsyncLoop2.Run(Math.ceil(iterations / syncedIterations), function(loop) {
      if (breakFunction && breakFunction()) {
        loop.breakLoop();
      } else {
        setTimeout(function() {
          for (var i = 0; i < syncedIterations; ++i) {
            var iteration = loop.index * syncedIterations + i;
            if (iteration >= iterations) {
              break;
            }
            fn(iteration);
            if (breakFunction && breakFunction()) {
              loop.breakLoop();
              break;
            }
          }
          loop.executeNext();
        }, timeout);
      }
    }, callback);
  };
  return AsyncLoop2;
}();
EngineStore.FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";
PromisePolyfill.Apply();
var SmartArray = function() {
  function SmartArray2(capacity) {
    this.length = 0;
    this.data = new Array(capacity);
    this._id = SmartArray2._GlobalId++;
  }
  SmartArray2.prototype.push = function(value) {
    this.data[this.length++] = value;
    if (this.length > this.data.length) {
      this.data.length *= 2;
    }
  };
  SmartArray2.prototype.forEach = function(func) {
    for (var index = 0; index < this.length; index++) {
      func(this.data[index]);
    }
  };
  SmartArray2.prototype.sort = function(compareFn) {
    this.data.sort(compareFn);
  };
  SmartArray2.prototype.reset = function() {
    this.length = 0;
  };
  SmartArray2.prototype.dispose = function() {
    this.reset();
    if (this.data) {
      this.data.length = 0;
      this.data = [];
    }
  };
  SmartArray2.prototype.concat = function(array) {
    if (array.length === 0) {
      return;
    }
    if (this.length + array.length > this.data.length) {
      this.data.length = (this.length + array.length) * 2;
    }
    for (var index = 0; index < array.length; index++) {
      this.data[this.length++] = (array.data || array)[index];
    }
  };
  SmartArray2.prototype.indexOf = function(value) {
    var position = this.data.indexOf(value);
    if (position >= this.length) {
      return -1;
    }
    return position;
  };
  SmartArray2.prototype.contains = function(value) {
    return this.indexOf(value) !== -1;
  };
  SmartArray2._GlobalId = 0;
  return SmartArray2;
}();
var SmartArrayNoDuplicate = function(_super) {
  __extends(SmartArrayNoDuplicate2, _super);
  function SmartArrayNoDuplicate2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._duplicateId = 0;
    return _this;
  }
  SmartArrayNoDuplicate2.prototype.push = function(value) {
    _super.prototype.push.call(this, value);
    if (!value.__smartArrayFlags) {
      value.__smartArrayFlags = {};
    }
    value.__smartArrayFlags[this._id] = this._duplicateId;
  };
  SmartArrayNoDuplicate2.prototype.pushNoDuplicate = function(value) {
    if (value.__smartArrayFlags && value.__smartArrayFlags[this._id] === this._duplicateId) {
      return false;
    }
    this.push(value);
    return true;
  };
  SmartArrayNoDuplicate2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this._duplicateId++;
  };
  SmartArrayNoDuplicate2.prototype.concatWithNoDuplicate = function(array) {
    if (array.length === 0) {
      return;
    }
    if (this.length + array.length > this.data.length) {
      this.data.length = (this.length + array.length) * 2;
    }
    for (var index = 0; index < array.length; index++) {
      var item = (array.data || array)[index];
      this.pushNoDuplicate(item);
    }
  };
  return SmartArrayNoDuplicate2;
}(SmartArray);
var StringDictionary = function() {
  function StringDictionary2() {
    this._count = 0;
    this._data = {};
  }
  StringDictionary2.prototype.copyFrom = function(source) {
    var _this = this;
    this.clear();
    source.forEach(function(t, v) {
      return _this.add(t, v);
    });
  };
  StringDictionary2.prototype.get = function(key) {
    var val = this._data[key];
    if (val !== void 0) {
      return val;
    }
    return void 0;
  };
  StringDictionary2.prototype.getOrAddWithFactory = function(key, factory) {
    var val = this.get(key);
    if (val !== void 0) {
      return val;
    }
    val = factory(key);
    if (val) {
      this.add(key, val);
    }
    return val;
  };
  StringDictionary2.prototype.getOrAdd = function(key, val) {
    var curVal = this.get(key);
    if (curVal !== void 0) {
      return curVal;
    }
    this.add(key, val);
    return val;
  };
  StringDictionary2.prototype.contains = function(key) {
    return this._data[key] !== void 0;
  };
  StringDictionary2.prototype.add = function(key, value) {
    if (this._data[key] !== void 0) {
      return false;
    }
    this._data[key] = value;
    ++this._count;
    return true;
  };
  StringDictionary2.prototype.set = function(key, value) {
    if (this._data[key] === void 0) {
      return false;
    }
    this._data[key] = value;
    return true;
  };
  StringDictionary2.prototype.getAndRemove = function(key) {
    var val = this.get(key);
    if (val !== void 0) {
      delete this._data[key];
      --this._count;
      return val;
    }
    return null;
  };
  StringDictionary2.prototype.remove = function(key) {
    if (this.contains(key)) {
      delete this._data[key];
      --this._count;
      return true;
    }
    return false;
  };
  StringDictionary2.prototype.clear = function() {
    this._data = {};
    this._count = 0;
  };
  Object.defineProperty(StringDictionary2.prototype, "count", {
    get: function() {
      return this._count;
    },
    enumerable: false,
    configurable: true
  });
  StringDictionary2.prototype.forEach = function(callback) {
    for (var cur in this._data) {
      var val = this._data[cur];
      callback(cur, val);
    }
  };
  StringDictionary2.prototype.first = function(callback) {
    for (var cur in this._data) {
      var val = this._data[cur];
      var res = callback(cur, val);
      if (res) {
        return res;
      }
    }
    return null;
  };
  return StringDictionary2;
}();
var AndOrNotEvaluator = function() {
  function AndOrNotEvaluator2() {
  }
  AndOrNotEvaluator2.Eval = function(query, evaluateCallback) {
    if (!query.match(/\([^\(\)]*\)/g)) {
      query = AndOrNotEvaluator2._HandleParenthesisContent(query, evaluateCallback);
    } else {
      query = query.replace(/\([^\(\)]*\)/g, function(r) {
        r = r.slice(1, r.length - 1);
        return AndOrNotEvaluator2._HandleParenthesisContent(r, evaluateCallback);
      });
    }
    if (query === "true") {
      return true;
    }
    if (query === "false") {
      return false;
    }
    return AndOrNotEvaluator2.Eval(query, evaluateCallback);
  };
  AndOrNotEvaluator2._HandleParenthesisContent = function(parenthesisContent, evaluateCallback) {
    evaluateCallback = evaluateCallback || function(r) {
      return r === "true" ? true : false;
    };
    var result;
    var or = parenthesisContent.split("||");
    for (var i in or) {
      if (or.hasOwnProperty(i)) {
        var ori = AndOrNotEvaluator2._SimplifyNegation(or[i].trim());
        var and = ori.split("&&");
        if (and.length > 1) {
          for (var j = 0; j < and.length; ++j) {
            var andj = AndOrNotEvaluator2._SimplifyNegation(and[j].trim());
            if (andj !== "true" && andj !== "false") {
              if (andj[0] === "!") {
                result = !evaluateCallback(andj.substring(1));
              } else {
                result = evaluateCallback(andj);
              }
            } else {
              result = andj === "true" ? true : false;
            }
            if (!result) {
              ori = "false";
              break;
            }
          }
        }
        if (result || ori === "true") {
          result = true;
          break;
        }
        if (ori !== "true" && ori !== "false") {
          if (ori[0] === "!") {
            result = !evaluateCallback(ori.substring(1));
          } else {
            result = evaluateCallback(ori);
          }
        } else {
          result = ori === "true" ? true : false;
        }
      }
    }
    return result ? "true" : "false";
  };
  AndOrNotEvaluator2._SimplifyNegation = function(booleanString) {
    booleanString = booleanString.replace(/^[\s!]+/, function(r) {
      r = r.replace(/[\s]/g, function() {
        return "";
      });
      return r.length % 2 ? "!" : "";
    });
    booleanString = booleanString.trim();
    if (booleanString === "!true") {
      booleanString = "false";
    } else if (booleanString === "!false") {
      booleanString = "true";
    }
    return booleanString;
  };
  return AndOrNotEvaluator2;
}();
var Tags = function() {
  function Tags2() {
  }
  Tags2.EnableFor = function(obj) {
    obj._tags = obj._tags || {};
    obj.hasTags = function() {
      return Tags2.HasTags(obj);
    };
    obj.addTags = function(tagsString) {
      return Tags2.AddTagsTo(obj, tagsString);
    };
    obj.removeTags = function(tagsString) {
      return Tags2.RemoveTagsFrom(obj, tagsString);
    };
    obj.matchesTagsQuery = function(tagsQuery) {
      return Tags2.MatchesQuery(obj, tagsQuery);
    };
  };
  Tags2.DisableFor = function(obj) {
    delete obj._tags;
    delete obj.hasTags;
    delete obj.addTags;
    delete obj.removeTags;
    delete obj.matchesTagsQuery;
  };
  Tags2.HasTags = function(obj) {
    if (!obj._tags) {
      return false;
    }
    var tags = obj._tags;
    for (var i in tags) {
      if (tags.hasOwnProperty(i)) {
        return true;
      }
    }
    return false;
  };
  Tags2.GetTags = function(obj, asString) {
    if (asString === void 0) {
      asString = true;
    }
    if (!obj._tags) {
      return null;
    }
    if (asString) {
      var tagsArray = [];
      for (var tag in obj._tags) {
        if (obj._tags.hasOwnProperty(tag) && obj._tags[tag] === true) {
          tagsArray.push(tag);
        }
      }
      return tagsArray.join(" ");
    } else {
      return obj._tags;
    }
  };
  Tags2.AddTagsTo = function(obj, tagsString) {
    if (!tagsString) {
      return;
    }
    if (typeof tagsString !== "string") {
      return;
    }
    var tags = tagsString.split(" ");
    tags.forEach(function(tag, index, array) {
      Tags2._AddTagTo(obj, tag);
    });
  };
  Tags2._AddTagTo = function(obj, tag) {
    tag = tag.trim();
    if (tag === "" || tag === "true" || tag === "false") {
      return;
    }
    if (tag.match(/[\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {
      return;
    }
    Tags2.EnableFor(obj);
    obj._tags[tag] = true;
  };
  Tags2.RemoveTagsFrom = function(obj, tagsString) {
    if (!Tags2.HasTags(obj)) {
      return;
    }
    var tags = tagsString.split(" ");
    for (var t in tags) {
      Tags2._RemoveTagFrom(obj, tags[t]);
    }
  };
  Tags2._RemoveTagFrom = function(obj, tag) {
    delete obj._tags[tag];
  };
  Tags2.MatchesQuery = function(obj, tagsQuery) {
    if (tagsQuery === void 0) {
      return true;
    }
    if (tagsQuery === "") {
      return Tags2.HasTags(obj);
    }
    return AndOrNotEvaluator.Eval(tagsQuery, function(r) {
      return Tags2.HasTags(obj) && obj._tags[r];
    });
  };
  return Tags2;
}();
var AbstractScene = function() {
  function AbstractScene2() {
    this.rootNodes = new Array();
    this.cameras = new Array();
    this.lights = new Array();
    this.meshes = new Array();
    this.skeletons = new Array();
    this.particleSystems = new Array();
    this.animations = [];
    this.animationGroups = new Array();
    this.multiMaterials = new Array();
    this.materials = new Array();
    this.morphTargetManagers = new Array();
    this.geometries = new Array();
    this.transformNodes = new Array();
    this.actionManagers = new Array();
    this.textures = new Array();
    this._environmentTexture = null;
    this.postProcesses = new Array();
  }
  AbstractScene2.AddParser = function(name2, parser) {
    this._BabylonFileParsers[name2] = parser;
  };
  AbstractScene2.GetParser = function(name2) {
    if (this._BabylonFileParsers[name2]) {
      return this._BabylonFileParsers[name2];
    }
    return null;
  };
  AbstractScene2.AddIndividualParser = function(name2, parser) {
    this._IndividualBabylonFileParsers[name2] = parser;
  };
  AbstractScene2.GetIndividualParser = function(name2) {
    if (this._IndividualBabylonFileParsers[name2]) {
      return this._IndividualBabylonFileParsers[name2];
    }
    return null;
  };
  AbstractScene2.Parse = function(jsonData, scene, container, rootUrl) {
    for (var parserName in this._BabylonFileParsers) {
      if (this._BabylonFileParsers.hasOwnProperty(parserName)) {
        this._BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);
      }
    }
  };
  Object.defineProperty(AbstractScene2.prototype, "environmentTexture", {
    get: function() {
      return this._environmentTexture;
    },
    set: function(value) {
      this._environmentTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  AbstractScene2.prototype.getNodes = function() {
    var nodes = new Array();
    nodes = nodes.concat(this.meshes);
    nodes = nodes.concat(this.lights);
    nodes = nodes.concat(this.cameras);
    nodes = nodes.concat(this.transformNodes);
    this.skeletons.forEach(function(skeleton) {
      return nodes = nodes.concat(skeleton.bones);
    });
    return nodes;
  };
  AbstractScene2._BabylonFileParsers = {};
  AbstractScene2._IndividualBabylonFileParsers = {};
  return AbstractScene2;
}();
var __decoratorInitialStore = {};
var __mergedStore = {};
var _copySource = function(creationFunction, source, instanciate) {
  var destination = creationFunction();
  if (Tags) {
    Tags.AddTagsTo(destination, source.tags);
  }
  var classStore = getMergedStore(destination);
  for (var property in classStore) {
    var propertyDescriptor = classStore[property];
    var sourceProperty = source[property];
    var propertyType = propertyDescriptor.type;
    if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper.AllowLoadingUniqueId)) {
      switch (propertyType) {
        case 0:
        case 6:
        case 11:
          destination[property] = sourceProperty;
          break;
        case 1:
          destination[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 7:
        case 10:
        case 12:
          destination[property] = instanciate ? sourceProperty : sourceProperty.clone();
          break;
      }
    }
  }
  return destination;
};
function getDirectStore(target) {
  var classKey = target.getClassName();
  if (!__decoratorInitialStore[classKey]) {
    __decoratorInitialStore[classKey] = {};
  }
  return __decoratorInitialStore[classKey];
}
function getMergedStore(target) {
  var classKey = target.getClassName();
  if (__mergedStore[classKey]) {
    return __mergedStore[classKey];
  }
  __mergedStore[classKey] = {};
  var store = __mergedStore[classKey];
  var currentTarget = target;
  var currentKey = classKey;
  while (currentKey) {
    var initialStore = __decoratorInitialStore[currentKey];
    for (var property in initialStore) {
      store[property] = initialStore[property];
    }
    var parent_1 = void 0;
    var done = false;
    do {
      parent_1 = Object.getPrototypeOf(currentTarget);
      if (!parent_1.getClassName) {
        done = true;
        break;
      }
      if (parent_1.getClassName() !== currentKey) {
        break;
      }
      currentTarget = parent_1;
    } while (parent_1);
    if (done) {
      break;
    }
    currentKey = parent_1.getClassName();
    currentTarget = parent_1;
  }
  return store;
}
function generateSerializableMember(type, sourceName) {
  return function(target, propertyKey) {
    var classStore = getDirectStore(target);
    if (!classStore[propertyKey]) {
      classStore[propertyKey] = { type, sourceName };
    }
  };
}
function generateExpandMember(setCallback, targetKey) {
  if (targetKey === void 0) {
    targetKey = null;
  }
  return function(target, propertyKey) {
    var key = targetKey || "_" + propertyKey;
    Object.defineProperty(target, propertyKey, {
      get: function() {
        return this[key];
      },
      set: function(value) {
        if (typeof this.equals === "function") {
          if (this.equals(value)) {
            return;
          }
        }
        if (this[key] === value) {
          return;
        }
        this[key] = value;
        target[setCallback].apply(this);
      },
      enumerable: true,
      configurable: true
    });
  };
}
function expandToProperty(callback, targetKey) {
  if (targetKey === void 0) {
    targetKey = null;
  }
  return generateExpandMember(callback, targetKey);
}
function serialize(sourceName) {
  return generateSerializableMember(0, sourceName);
}
function serializeAsTexture(sourceName) {
  return generateSerializableMember(1, sourceName);
}
function serializeAsColor3(sourceName) {
  return generateSerializableMember(2, sourceName);
}
function serializeAsFresnelParameters(sourceName) {
  return generateSerializableMember(3, sourceName);
}
function serializeAsVector2(sourceName) {
  return generateSerializableMember(4, sourceName);
}
function serializeAsVector3(sourceName) {
  return generateSerializableMember(5, sourceName);
}
function serializeAsMeshReference(sourceName) {
  return generateSerializableMember(6, sourceName);
}
function serializeAsColorCurves(sourceName) {
  return generateSerializableMember(7, sourceName);
}
function serializeAsColor4(sourceName) {
  return generateSerializableMember(8, sourceName);
}
function serializeAsQuaternion(sourceName) {
  return generateSerializableMember(10, sourceName);
}
var SerializationHelper = function() {
  function SerializationHelper2() {
  }
  SerializationHelper2.AppendSerializedAnimations = function(source, destination) {
    if (source.animations) {
      destination.animations = [];
      for (var animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {
        var animation = source.animations[animationIndex];
        destination.animations.push(animation.serialize());
      }
    }
  };
  SerializationHelper2.Serialize = function(entity, serializationObject) {
    if (!serializationObject) {
      serializationObject = {};
    }
    if (Tags) {
      serializationObject.tags = Tags.GetTags(entity);
    }
    var serializedProperties = getMergedStore(entity);
    for (var property in serializedProperties) {
      var propertyDescriptor = serializedProperties[property];
      var targetPropertyName = propertyDescriptor.sourceName || property;
      var propertyType = propertyDescriptor.type;
      var sourceProperty = entity[property];
      if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper2.AllowLoadingUniqueId)) {
        switch (propertyType) {
          case 0:
            serializationObject[targetPropertyName] = sourceProperty;
            break;
          case 1:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 2:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 3:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 4:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 5:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 6:
            serializationObject[targetPropertyName] = sourceProperty.id;
            break;
          case 7:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 8:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 9:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 10:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 11:
            serializationObject[targetPropertyName] = sourceProperty.id;
            break;
          case 12:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
        }
      }
    }
    return serializationObject;
  };
  SerializationHelper2.Parse = function(creationFunction, source, scene, rootUrl) {
    if (rootUrl === void 0) {
      rootUrl = null;
    }
    var destination = creationFunction();
    if (!rootUrl) {
      rootUrl = "";
    }
    if (Tags) {
      Tags.AddTagsTo(destination, source.tags);
    }
    var classStore = getMergedStore(destination);
    for (var property in classStore) {
      var propertyDescriptor = classStore[property];
      var sourceProperty = source[propertyDescriptor.sourceName || property];
      var propertyType = propertyDescriptor.type;
      if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper2.AllowLoadingUniqueId)) {
        var dest = destination;
        switch (propertyType) {
          case 0:
            dest[property] = sourceProperty;
            break;
          case 1:
            if (scene) {
              dest[property] = SerializationHelper2._TextureParser(sourceProperty, scene, rootUrl);
            }
            break;
          case 2:
            dest[property] = Color3.FromArray(sourceProperty);
            break;
          case 3:
            dest[property] = SerializationHelper2._FresnelParametersParser(sourceProperty);
            break;
          case 4:
            dest[property] = Vector2.FromArray(sourceProperty);
            break;
          case 5:
            dest[property] = Vector3.FromArray(sourceProperty);
            break;
          case 6:
            if (scene) {
              dest[property] = scene.getLastMeshById(sourceProperty);
            }
            break;
          case 7:
            dest[property] = SerializationHelper2._ColorCurvesParser(sourceProperty);
            break;
          case 8:
            dest[property] = Color4$1.FromArray(sourceProperty);
            break;
          case 9:
            dest[property] = SerializationHelper2._ImageProcessingConfigurationParser(sourceProperty);
            break;
          case 10:
            dest[property] = Quaternion.FromArray(sourceProperty);
            break;
          case 11:
            if (scene) {
              dest[property] = scene.getCameraById(sourceProperty);
            }
            break;
          case 12:
            dest[property] = Matrix.FromArray(sourceProperty);
            break;
        }
      }
    }
    return destination;
  };
  SerializationHelper2.Clone = function(creationFunction, source) {
    return _copySource(creationFunction, source, false);
  };
  SerializationHelper2.Instanciate = function(creationFunction, source) {
    return _copySource(creationFunction, source, true);
  };
  SerializationHelper2.AllowLoadingUniqueId = false;
  SerializationHelper2._ImageProcessingConfigurationParser = function(sourceProperty) {
    throw _WarnImport("ImageProcessingConfiguration");
  };
  SerializationHelper2._FresnelParametersParser = function(sourceProperty) {
    throw _WarnImport("FresnelParameters");
  };
  SerializationHelper2._ColorCurvesParser = function(sourceProperty) {
    throw _WarnImport("ColorCurves");
  };
  SerializationHelper2._TextureParser = function(sourceProperty, scene, rootUrl) {
    throw _WarnImport("Texture");
  };
  return SerializationHelper2;
}();
function nativeOverride(target, propertyKey, descriptor, predicate) {
  var jsFunc = descriptor.value;
  descriptor.value = function() {
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    var func = jsFunc;
    if (typeof _native !== "undefined" && _native[propertyKey]) {
      var nativeFunc_1 = _native[propertyKey];
      if (predicate) {
        func = function() {
          var params2 = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            params2[_i2] = arguments[_i2];
          }
          return predicate.apply(void 0, params2) ? nativeFunc_1.apply(void 0, params2) : jsFunc.apply(void 0, params2);
        };
      } else {
        func = nativeFunc_1;
      }
    }
    target[propertyKey] = func;
    return func.apply(void 0, params);
  };
}
nativeOverride.filter = function(predicate) {
  return function(target, propertyKey, descriptor) {
    return nativeOverride(target, propertyKey, descriptor, predicate);
  };
};
var MaterialDefines = function() {
  function MaterialDefines2(externalProperties) {
    this._isDirty = true;
    this._areLightsDirty = true;
    this._areLightsDisposed = false;
    this._areAttributesDirty = true;
    this._areTexturesDirty = true;
    this._areFresnelDirty = true;
    this._areMiscDirty = true;
    this._arePrePassDirty = true;
    this._areImageProcessingDirty = true;
    this._normals = false;
    this._uvs = false;
    this._needNormals = false;
    this._needUVs = false;
    this._externalProperties = externalProperties;
    if (externalProperties) {
      for (var prop in externalProperties) {
        if (externalProperties.hasOwnProperty(prop)) {
          this._setDefaultValue(prop);
        }
      }
    }
  }
  Object.defineProperty(MaterialDefines2.prototype, "isDirty", {
    get: function() {
      return this._isDirty;
    },
    enumerable: false,
    configurable: true
  });
  MaterialDefines2.prototype.markAsProcessed = function() {
    this._isDirty = false;
    this._areAttributesDirty = false;
    this._areTexturesDirty = false;
    this._areFresnelDirty = false;
    this._areLightsDirty = false;
    this._areLightsDisposed = false;
    this._areMiscDirty = false;
    this._arePrePassDirty = false;
    this._areImageProcessingDirty = false;
  };
  MaterialDefines2.prototype.markAsUnprocessed = function() {
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAllAsDirty = function() {
    this._areTexturesDirty = true;
    this._areAttributesDirty = true;
    this._areLightsDirty = true;
    this._areFresnelDirty = true;
    this._areMiscDirty = true;
    this._areImageProcessingDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsImageProcessingDirty = function() {
    this._areImageProcessingDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsLightDirty = function(disposed) {
    if (disposed === void 0) {
      disposed = false;
    }
    this._areLightsDirty = true;
    this._areLightsDisposed = this._areLightsDisposed || disposed;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsAttributesDirty = function() {
    this._areAttributesDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsTexturesDirty = function() {
    this._areTexturesDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsFresnelDirty = function() {
    this._areFresnelDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsMiscDirty = function() {
    this._areMiscDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsPrePassDirty = function() {
    this._arePrePassDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.rebuild = function() {
    this._keys = [];
    for (var _i = 0, _a = Object.keys(this); _i < _a.length; _i++) {
      var key = _a[_i];
      if (key[0] === "_") {
        continue;
      }
      this._keys.push(key);
    }
    if (this._externalProperties) {
      for (var name_1 in this._externalProperties) {
        this._keys.push(name_1);
      }
    }
  };
  MaterialDefines2.prototype.isEqual = function(other) {
    if (this._keys.length !== other._keys.length) {
      return false;
    }
    for (var index = 0; index < this._keys.length; index++) {
      var prop = this._keys[index];
      if (this[prop] !== other[prop]) {
        return false;
      }
    }
    return true;
  };
  MaterialDefines2.prototype.cloneTo = function(other) {
    if (this._keys.length !== other._keys.length) {
      other._keys = this._keys.slice(0);
    }
    for (var index = 0; index < this._keys.length; index++) {
      var prop = this._keys[index];
      other[prop] = this[prop];
    }
  };
  MaterialDefines2.prototype.reset = function() {
    var _this = this;
    this._keys.forEach(function(prop) {
      return _this._setDefaultValue(prop);
    });
  };
  MaterialDefines2.prototype._setDefaultValue = function(prop) {
    var _a, _b, _c, _d, _e;
    var type = (_c = (_b = (_a = this._externalProperties) === null || _a === void 0 ? void 0 : _a[prop]) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : typeof this[prop];
    var defValue = (_e = (_d = this._externalProperties) === null || _d === void 0 ? void 0 : _d[prop]) === null || _e === void 0 ? void 0 : _e.default;
    switch (type) {
      case "number":
        this[prop] = defValue !== null && defValue !== void 0 ? defValue : 0;
        break;
      case "string":
        this[prop] = defValue !== null && defValue !== void 0 ? defValue : "";
        break;
      default:
        this[prop] = defValue !== null && defValue !== void 0 ? defValue : false;
        break;
    }
  };
  MaterialDefines2.prototype.toString = function() {
    var result = "";
    for (var index = 0; index < this._keys.length; index++) {
      var prop = this._keys[index];
      var value = this[prop];
      var type = typeof value;
      switch (type) {
        case "number":
        case "string":
          result += "#define " + prop + " " + value + "\n";
          break;
        default:
          if (value) {
            result += "#define " + prop + "\n";
          }
          break;
      }
    }
    return result;
  };
  return MaterialDefines2;
}();
var ColorCurves = function() {
  function ColorCurves2() {
    this._dirty = true;
    this._tempColor = new Color4$1(0, 0, 0, 0);
    this._globalCurve = new Color4$1(0, 0, 0, 0);
    this._highlightsCurve = new Color4$1(0, 0, 0, 0);
    this._midtonesCurve = new Color4$1(0, 0, 0, 0);
    this._shadowsCurve = new Color4$1(0, 0, 0, 0);
    this._positiveCurve = new Color4$1(0, 0, 0, 0);
    this._negativeCurve = new Color4$1(0, 0, 0, 0);
    this._globalHue = 30;
    this._globalDensity = 0;
    this._globalSaturation = 0;
    this._globalExposure = 0;
    this._highlightsHue = 30;
    this._highlightsDensity = 0;
    this._highlightsSaturation = 0;
    this._highlightsExposure = 0;
    this._midtonesHue = 30;
    this._midtonesDensity = 0;
    this._midtonesSaturation = 0;
    this._midtonesExposure = 0;
    this._shadowsHue = 30;
    this._shadowsDensity = 0;
    this._shadowsSaturation = 0;
    this._shadowsExposure = 0;
  }
  Object.defineProperty(ColorCurves2.prototype, "globalHue", {
    get: function() {
      return this._globalHue;
    },
    set: function(value) {
      this._globalHue = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "globalDensity", {
    get: function() {
      return this._globalDensity;
    },
    set: function(value) {
      this._globalDensity = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "globalSaturation", {
    get: function() {
      return this._globalSaturation;
    },
    set: function(value) {
      this._globalSaturation = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "globalExposure", {
    get: function() {
      return this._globalExposure;
    },
    set: function(value) {
      this._globalExposure = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "highlightsHue", {
    get: function() {
      return this._highlightsHue;
    },
    set: function(value) {
      this._highlightsHue = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "highlightsDensity", {
    get: function() {
      return this._highlightsDensity;
    },
    set: function(value) {
      this._highlightsDensity = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "highlightsSaturation", {
    get: function() {
      return this._highlightsSaturation;
    },
    set: function(value) {
      this._highlightsSaturation = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "highlightsExposure", {
    get: function() {
      return this._highlightsExposure;
    },
    set: function(value) {
      this._highlightsExposure = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "midtonesHue", {
    get: function() {
      return this._midtonesHue;
    },
    set: function(value) {
      this._midtonesHue = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "midtonesDensity", {
    get: function() {
      return this._midtonesDensity;
    },
    set: function(value) {
      this._midtonesDensity = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "midtonesSaturation", {
    get: function() {
      return this._midtonesSaturation;
    },
    set: function(value) {
      this._midtonesSaturation = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "midtonesExposure", {
    get: function() {
      return this._midtonesExposure;
    },
    set: function(value) {
      this._midtonesExposure = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "shadowsHue", {
    get: function() {
      return this._shadowsHue;
    },
    set: function(value) {
      this._shadowsHue = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "shadowsDensity", {
    get: function() {
      return this._shadowsDensity;
    },
    set: function(value) {
      this._shadowsDensity = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "shadowsSaturation", {
    get: function() {
      return this._shadowsSaturation;
    },
    set: function(value) {
      this._shadowsSaturation = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "shadowsExposure", {
    get: function() {
      return this._shadowsExposure;
    },
    set: function(value) {
      this._shadowsExposure = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  ColorCurves2.prototype.getClassName = function() {
    return "ColorCurves";
  };
  ColorCurves2.Bind = function(colorCurves, effect, positiveUniform, neutralUniform, negativeUniform) {
    if (positiveUniform === void 0) {
      positiveUniform = "vCameraColorCurvePositive";
    }
    if (neutralUniform === void 0) {
      neutralUniform = "vCameraColorCurveNeutral";
    }
    if (negativeUniform === void 0) {
      negativeUniform = "vCameraColorCurveNegative";
    }
    if (colorCurves._dirty) {
      colorCurves._dirty = false;
      colorCurves.getColorGradingDataToRef(colorCurves._globalHue, colorCurves._globalDensity, colorCurves._globalSaturation, colorCurves._globalExposure, colorCurves._globalCurve);
      colorCurves.getColorGradingDataToRef(colorCurves._highlightsHue, colorCurves._highlightsDensity, colorCurves._highlightsSaturation, colorCurves._highlightsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._highlightsCurve);
      colorCurves.getColorGradingDataToRef(colorCurves._midtonesHue, colorCurves._midtonesDensity, colorCurves._midtonesSaturation, colorCurves._midtonesExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._midtonesCurve);
      colorCurves.getColorGradingDataToRef(colorCurves._shadowsHue, colorCurves._shadowsDensity, colorCurves._shadowsSaturation, colorCurves._shadowsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._shadowsCurve);
      colorCurves._highlightsCurve.subtractToRef(colorCurves._midtonesCurve, colorCurves._positiveCurve);
      colorCurves._midtonesCurve.subtractToRef(colorCurves._shadowsCurve, colorCurves._negativeCurve);
    }
    if (effect) {
      effect.setFloat4(positiveUniform, colorCurves._positiveCurve.r, colorCurves._positiveCurve.g, colorCurves._positiveCurve.b, colorCurves._positiveCurve.a);
      effect.setFloat4(neutralUniform, colorCurves._midtonesCurve.r, colorCurves._midtonesCurve.g, colorCurves._midtonesCurve.b, colorCurves._midtonesCurve.a);
      effect.setFloat4(negativeUniform, colorCurves._negativeCurve.r, colorCurves._negativeCurve.g, colorCurves._negativeCurve.b, colorCurves._negativeCurve.a);
    }
  };
  ColorCurves2.PrepareUniforms = function(uniformsList) {
    uniformsList.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative");
  };
  ColorCurves2.prototype.getColorGradingDataToRef = function(hue, density, saturation, exposure, result) {
    if (hue == null) {
      return;
    }
    hue = ColorCurves2.clamp(hue, 0, 360);
    density = ColorCurves2.clamp(density, -100, 100);
    saturation = ColorCurves2.clamp(saturation, -100, 100);
    exposure = ColorCurves2.clamp(exposure, -100, 100);
    density = ColorCurves2.applyColorGradingSliderNonlinear(density);
    density *= 0.5;
    exposure = ColorCurves2.applyColorGradingSliderNonlinear(exposure);
    if (density < 0) {
      density *= -1;
      hue = (hue + 180) % 360;
    }
    ColorCurves2.fromHSBToRef(hue, density, 50 + 0.25 * exposure, result);
    result.scaleToRef(2, result);
    result.a = 1 + 0.01 * saturation;
  };
  ColorCurves2.applyColorGradingSliderNonlinear = function(value) {
    value /= 100;
    var x = Math.abs(value);
    x = Math.pow(x, 2);
    if (value < 0) {
      x *= -1;
    }
    x *= 100;
    return x;
  };
  ColorCurves2.fromHSBToRef = function(hue, saturation, brightness, result) {
    var h = ColorCurves2.clamp(hue, 0, 360);
    var s = ColorCurves2.clamp(saturation / 100, 0, 1);
    var v = ColorCurves2.clamp(brightness / 100, 0, 1);
    if (s === 0) {
      result.r = v;
      result.g = v;
      result.b = v;
    } else {
      h /= 60;
      var i = Math.floor(h);
      var f = h - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          result.r = v;
          result.g = t;
          result.b = p;
          break;
        case 1:
          result.r = q;
          result.g = v;
          result.b = p;
          break;
        case 2:
          result.r = p;
          result.g = v;
          result.b = t;
          break;
        case 3:
          result.r = p;
          result.g = q;
          result.b = v;
          break;
        case 4:
          result.r = t;
          result.g = p;
          result.b = v;
          break;
        default:
          result.r = v;
          result.g = p;
          result.b = q;
          break;
      }
    }
    result.a = 1;
  };
  ColorCurves2.clamp = function(value, min, max) {
    return Math.min(Math.max(value, min), max);
  };
  ColorCurves2.prototype.clone = function() {
    return SerializationHelper.Clone(function() {
      return new ColorCurves2();
    }, this);
  };
  ColorCurves2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  ColorCurves2.Parse = function(source) {
    return SerializationHelper.Parse(function() {
      return new ColorCurves2();
    }, source, null, null);
  };
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_globalHue", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_globalDensity", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_globalSaturation", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_globalExposure", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_highlightsHue", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_highlightsDensity", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_highlightsSaturation", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_highlightsExposure", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_midtonesHue", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_midtonesDensity", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_midtonesSaturation", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_midtonesExposure", void 0);
  return ColorCurves2;
}();
SerializationHelper._ColorCurvesParser = ColorCurves.Parse;
(function(_super) {
  __extends(ImageProcessingConfigurationDefines, _super);
  function ImageProcessingConfigurationDefines() {
    var _this = _super.call(this) || this;
    _this.IMAGEPROCESSING = false;
    _this.VIGNETTE = false;
    _this.VIGNETTEBLENDMODEMULTIPLY = false;
    _this.VIGNETTEBLENDMODEOPAQUE = false;
    _this.TONEMAPPING = false;
    _this.TONEMAPPING_ACES = false;
    _this.CONTRAST = false;
    _this.COLORCURVES = false;
    _this.COLORGRADING = false;
    _this.COLORGRADING3D = false;
    _this.SAMPLER3DGREENDEPTH = false;
    _this.SAMPLER3DBGRMAP = false;
    _this.IMAGEPROCESSINGPOSTPROCESS = false;
    _this.EXPOSURE = false;
    _this.SKIPFINALCOLORCLAMP = false;
    _this.rebuild();
    return _this;
  }
  return ImageProcessingConfigurationDefines;
})(MaterialDefines);
var ImageProcessingConfiguration = function() {
  function ImageProcessingConfiguration2() {
    this.colorCurves = new ColorCurves();
    this._colorCurvesEnabled = false;
    this._colorGradingEnabled = false;
    this._colorGradingWithGreenDepth = true;
    this._colorGradingBGR = true;
    this._exposure = 1;
    this._toneMappingEnabled = false;
    this._toneMappingType = ImageProcessingConfiguration2.TONEMAPPING_STANDARD;
    this._contrast = 1;
    this.vignetteStretch = 0;
    this.vignetteCentreX = 0;
    this.vignetteCentreY = 0;
    this.vignetteWeight = 1.5;
    this.vignetteColor = new Color4$1(0, 0, 0, 0);
    this.vignetteCameraFov = 0.5;
    this._vignetteBlendMode = ImageProcessingConfiguration2.VIGNETTEMODE_MULTIPLY;
    this._vignetteEnabled = false;
    this._skipFinalColorClamp = false;
    this._applyByPostProcess = false;
    this._isEnabled = true;
    this.onUpdateParameters = new Observable();
  }
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorCurvesEnabled", {
    get: function() {
      return this._colorCurvesEnabled;
    },
    set: function(value) {
      if (this._colorCurvesEnabled === value) {
        return;
      }
      this._colorCurvesEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingTexture", {
    get: function() {
      return this._colorGradingTexture;
    },
    set: function(value) {
      if (this._colorGradingTexture === value) {
        return;
      }
      this._colorGradingTexture = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingEnabled", {
    get: function() {
      return this._colorGradingEnabled;
    },
    set: function(value) {
      if (this._colorGradingEnabled === value) {
        return;
      }
      this._colorGradingEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingWithGreenDepth", {
    get: function() {
      return this._colorGradingWithGreenDepth;
    },
    set: function(value) {
      if (this._colorGradingWithGreenDepth === value) {
        return;
      }
      this._colorGradingWithGreenDepth = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingBGR", {
    get: function() {
      return this._colorGradingBGR;
    },
    set: function(value) {
      if (this._colorGradingBGR === value) {
        return;
      }
      this._colorGradingBGR = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "exposure", {
    get: function() {
      return this._exposure;
    },
    set: function(value) {
      if (this._exposure === value) {
        return;
      }
      this._exposure = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "toneMappingEnabled", {
    get: function() {
      return this._toneMappingEnabled;
    },
    set: function(value) {
      if (this._toneMappingEnabled === value) {
        return;
      }
      this._toneMappingEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "toneMappingType", {
    get: function() {
      return this._toneMappingType;
    },
    set: function(value) {
      if (this._toneMappingType === value) {
        return;
      }
      this._toneMappingType = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "contrast", {
    get: function() {
      return this._contrast;
    },
    set: function(value) {
      if (this._contrast === value) {
        return;
      }
      this._contrast = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "vignetteBlendMode", {
    get: function() {
      return this._vignetteBlendMode;
    },
    set: function(value) {
      if (this._vignetteBlendMode === value) {
        return;
      }
      this._vignetteBlendMode = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "vignetteEnabled", {
    get: function() {
      return this._vignetteEnabled;
    },
    set: function(value) {
      if (this._vignetteEnabled === value) {
        return;
      }
      this._vignetteEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "skipFinalColorClamp", {
    get: function() {
      return this._skipFinalColorClamp;
    },
    set: function(value) {
      if (this._skipFinalColorClamp === value) {
        return;
      }
      this._skipFinalColorClamp = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "applyByPostProcess", {
    get: function() {
      return this._applyByPostProcess;
    },
    set: function(value) {
      if (this._applyByPostProcess === value) {
        return;
      }
      this._applyByPostProcess = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "isEnabled", {
    get: function() {
      return this._isEnabled;
    },
    set: function(value) {
      if (this._isEnabled === value) {
        return;
      }
      this._isEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  ImageProcessingConfiguration2.prototype._updateParameters = function() {
    this.onUpdateParameters.notifyObservers(this);
  };
  ImageProcessingConfiguration2.prototype.getClassName = function() {
    return "ImageProcessingConfiguration";
  };
  ImageProcessingConfiguration2.PrepareUniforms = function(uniforms, defines) {
    if (defines.EXPOSURE) {
      uniforms.push("exposureLinear");
    }
    if (defines.CONTRAST) {
      uniforms.push("contrast");
    }
    if (defines.COLORGRADING) {
      uniforms.push("colorTransformSettings");
    }
    if (defines.VIGNETTE) {
      uniforms.push("vInverseScreenSize");
      uniforms.push("vignetteSettings1");
      uniforms.push("vignetteSettings2");
    }
    if (defines.COLORCURVES) {
      ColorCurves.PrepareUniforms(uniforms);
    }
  };
  ImageProcessingConfiguration2.PrepareSamplers = function(samplersList, defines) {
    if (defines.COLORGRADING) {
      samplersList.push("txColorTransform");
    }
  };
  ImageProcessingConfiguration2.prototype.prepareDefines = function(defines, forPostProcess) {
    if (forPostProcess === void 0) {
      forPostProcess = false;
    }
    if (forPostProcess !== this.applyByPostProcess || !this._isEnabled) {
      defines.VIGNETTE = false;
      defines.TONEMAPPING = false;
      defines.TONEMAPPING_ACES = false;
      defines.CONTRAST = false;
      defines.EXPOSURE = false;
      defines.COLORCURVES = false;
      defines.COLORGRADING = false;
      defines.COLORGRADING3D = false;
      defines.IMAGEPROCESSING = false;
      defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
      defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;
      return;
    }
    defines.VIGNETTE = this.vignetteEnabled;
    defines.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === ImageProcessingConfiguration2._VIGNETTEMODE_MULTIPLY;
    defines.VIGNETTEBLENDMODEOPAQUE = !defines.VIGNETTEBLENDMODEMULTIPLY;
    defines.TONEMAPPING = this.toneMappingEnabled;
    switch (this._toneMappingType) {
      case ImageProcessingConfiguration2.TONEMAPPING_ACES:
        defines.TONEMAPPING_ACES = true;
        break;
      default:
        defines.TONEMAPPING_ACES = false;
        break;
    }
    defines.CONTRAST = this.contrast !== 1;
    defines.EXPOSURE = this.exposure !== 1;
    defines.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves;
    defines.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture;
    if (defines.COLORGRADING) {
      defines.COLORGRADING3D = this.colorGradingTexture.is3D;
    } else {
      defines.COLORGRADING3D = false;
    }
    defines.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth;
    defines.SAMPLER3DBGRMAP = this.colorGradingBGR;
    defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess;
    defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
    defines.IMAGEPROCESSING = defines.VIGNETTE || defines.TONEMAPPING || defines.CONTRAST || defines.EXPOSURE || defines.COLORCURVES || defines.COLORGRADING;
  };
  ImageProcessingConfiguration2.prototype.isReady = function() {
    return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();
  };
  ImageProcessingConfiguration2.prototype.bind = function(effect, overrideAspectRatio) {
    if (this._colorCurvesEnabled && this.colorCurves) {
      ColorCurves.Bind(this.colorCurves, effect);
    }
    if (this._vignetteEnabled) {
      var inverseWidth = 1 / effect.getEngine().getRenderWidth();
      var inverseHeight = 1 / effect.getEngine().getRenderHeight();
      effect.setFloat2("vInverseScreenSize", inverseWidth, inverseHeight);
      var aspectRatio = overrideAspectRatio != null ? overrideAspectRatio : inverseHeight / inverseWidth;
      var vignetteScaleY = Math.tan(this.vignetteCameraFov * 0.5);
      var vignetteScaleX = vignetteScaleY * aspectRatio;
      var vignetteScaleGeometricMean = Math.sqrt(vignetteScaleX * vignetteScaleY);
      vignetteScaleX = Tools.Mix(vignetteScaleX, vignetteScaleGeometricMean, this.vignetteStretch);
      vignetteScaleY = Tools.Mix(vignetteScaleY, vignetteScaleGeometricMean, this.vignetteStretch);
      effect.setFloat4("vignetteSettings1", vignetteScaleX, vignetteScaleY, -vignetteScaleX * this.vignetteCentreX, -vignetteScaleY * this.vignetteCentreY);
      var vignettePower = -2 * this.vignetteWeight;
      effect.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, vignettePower);
    }
    effect.setFloat("exposureLinear", this.exposure);
    effect.setFloat("contrast", this.contrast);
    if (this.colorGradingTexture) {
      effect.setTexture("txColorTransform", this.colorGradingTexture);
      var textureSize = this.colorGradingTexture.getSize().height;
      effect.setFloat4("colorTransformSettings", (textureSize - 1) / textureSize, 0.5 / textureSize, textureSize, this.colorGradingTexture.level);
    }
  };
  ImageProcessingConfiguration2.prototype.clone = function() {
    return SerializationHelper.Clone(function() {
      return new ImageProcessingConfiguration2();
    }, this);
  };
  ImageProcessingConfiguration2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  ImageProcessingConfiguration2.Parse = function(source) {
    return SerializationHelper.Parse(function() {
      return new ImageProcessingConfiguration2();
    }, source, null, null);
  };
  Object.defineProperty(ImageProcessingConfiguration2, "VIGNETTEMODE_MULTIPLY", {
    get: function() {
      return this._VIGNETTEMODE_MULTIPLY;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2, "VIGNETTEMODE_OPAQUE", {
    get: function() {
      return this._VIGNETTEMODE_OPAQUE;
    },
    enumerable: false,
    configurable: true
  });
  ImageProcessingConfiguration2.TONEMAPPING_STANDARD = 0;
  ImageProcessingConfiguration2.TONEMAPPING_ACES = 1;
  ImageProcessingConfiguration2._VIGNETTEMODE_MULTIPLY = 0;
  ImageProcessingConfiguration2._VIGNETTEMODE_OPAQUE = 1;
  __decorate([
    serializeAsColorCurves()
  ], ImageProcessingConfiguration2.prototype, "colorCurves", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_colorCurvesEnabled", void 0);
  __decorate([
    serializeAsTexture("colorGradingTexture")
  ], ImageProcessingConfiguration2.prototype, "_colorGradingTexture", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_colorGradingEnabled", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_colorGradingWithGreenDepth", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_colorGradingBGR", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_exposure", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_toneMappingEnabled", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_toneMappingType", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_contrast", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteStretch", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteCentreX", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteCentreY", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteWeight", void 0);
  __decorate([
    serializeAsColor4()
  ], ImageProcessingConfiguration2.prototype, "vignetteColor", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteCameraFov", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_vignetteBlendMode", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_vignetteEnabled", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_skipFinalColorClamp", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_applyByPostProcess", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_isEnabled", void 0);
  return ImageProcessingConfiguration2;
}();
SerializationHelper._ImageProcessingConfigurationParser = ImageProcessingConfiguration.Parse;
ThinEngine.prototype.createUniformBuffer = function(elements) {
  var ubo = this._gl.createBuffer();
  if (!ubo) {
    throw new Error("Unable to create uniform buffer");
  }
  var result = new WebGLDataBuffer(ubo);
  this.bindUniformBuffer(result);
  if (elements instanceof Float32Array) {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.STATIC_DRAW);
  } else {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.STATIC_DRAW);
  }
  this.bindUniformBuffer(null);
  result.references = 1;
  return result;
};
ThinEngine.prototype.createDynamicUniformBuffer = function(elements) {
  var ubo = this._gl.createBuffer();
  if (!ubo) {
    throw new Error("Unable to create dynamic uniform buffer");
  }
  var result = new WebGLDataBuffer(ubo);
  this.bindUniformBuffer(result);
  if (elements instanceof Float32Array) {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.DYNAMIC_DRAW);
  } else {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.DYNAMIC_DRAW);
  }
  this.bindUniformBuffer(null);
  result.references = 1;
  return result;
};
ThinEngine.prototype.updateUniformBuffer = function(uniformBuffer, elements, offset, count) {
  this.bindUniformBuffer(uniformBuffer);
  if (offset === void 0) {
    offset = 0;
  }
  if (count === void 0) {
    if (elements instanceof Float32Array) {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, elements);
    } else {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, new Float32Array(elements));
    }
  } else {
    if (elements instanceof Float32Array) {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, elements.subarray(offset, offset + count));
    } else {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(elements).subarray(offset, offset + count));
    }
  }
  this.bindUniformBuffer(null);
};
ThinEngine.prototype.bindUniformBuffer = function(buffer) {
  this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, buffer ? buffer.underlyingResource : null);
};
ThinEngine.prototype.bindUniformBufferBase = function(buffer, location2, name2) {
  this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, location2, buffer ? buffer.underlyingResource : null);
};
ThinEngine.prototype.bindUniformBlock = function(pipelineContext, blockName, index) {
  var program = pipelineContext.program;
  var uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
  this._gl.uniformBlockBinding(program, uniformLocation, index);
};
var UniformBuffer = function() {
  function UniformBuffer2(engine, data, dynamic, name2) {
    this._valueCache = {};
    this._engine = engine;
    this._noUBO = !engine.supportsUniformBuffers;
    this._dynamic = dynamic;
    this._name = name2 !== null && name2 !== void 0 ? name2 : "no-name";
    this._data = data || [];
    this._uniformLocations = {};
    this._uniformSizes = {};
    this._uniformArraySizes = {};
    this._uniformLocationPointer = 0;
    this._needSync = false;
    if (this._engine._features.trackUbosInFrame) {
      this._buffers = [];
      this._bufferIndex = -1;
      this._createBufferOnWrite = false;
      this._currentFrameId = 0;
    }
    if (this._noUBO) {
      this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;
      this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;
      this.updateFloat = this._updateFloatForEffect;
      this.updateFloat2 = this._updateFloat2ForEffect;
      this.updateFloat3 = this._updateFloat3ForEffect;
      this.updateFloat4 = this._updateFloat4ForEffect;
      this.updateFloatArray = this._updateFloatArrayForEffect;
      this.updateArray = this._updateArrayForEffect;
      this.updateIntArray = this._updateIntArrayForEffect;
      this.updateMatrix = this._updateMatrixForEffect;
      this.updateMatrices = this._updateMatricesForEffect;
      this.updateVector3 = this._updateVector3ForEffect;
      this.updateVector4 = this._updateVector4ForEffect;
      this.updateColor3 = this._updateColor3ForEffect;
      this.updateColor4 = this._updateColor4ForEffect;
      this.updateDirectColor4 = this._updateDirectColor4ForEffect;
      this.updateInt = this._updateIntForEffect;
      this.updateInt2 = this._updateInt2ForEffect;
      this.updateInt3 = this._updateInt3ForEffect;
      this.updateInt4 = this._updateInt4ForEffect;
    } else {
      this._engine._uniformBuffers.push(this);
      this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;
      this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;
      this.updateFloat = this._updateFloatForUniform;
      this.updateFloat2 = this._updateFloat2ForUniform;
      this.updateFloat3 = this._updateFloat3ForUniform;
      this.updateFloat4 = this._updateFloat4ForUniform;
      this.updateFloatArray = this._updateFloatArrayForUniform;
      this.updateArray = this._updateArrayForUniform;
      this.updateIntArray = this._updateIntArrayForUniform;
      this.updateMatrix = this._updateMatrixForUniform;
      this.updateMatrices = this._updateMatricesForUniform;
      this.updateVector3 = this._updateVector3ForUniform;
      this.updateVector4 = this._updateVector4ForUniform;
      this.updateColor3 = this._updateColor3ForUniform;
      this.updateColor4 = this._updateColor4ForUniform;
      this.updateDirectColor4 = this._updateDirectColor4ForUniform;
      this.updateInt = this._updateIntForUniform;
      this.updateInt2 = this._updateInt2ForUniform;
      this.updateInt3 = this._updateInt3ForUniform;
      this.updateInt4 = this._updateInt4ForUniform;
    }
  }
  Object.defineProperty(UniformBuffer2.prototype, "useUbo", {
    get: function() {
      return !this._noUBO;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(UniformBuffer2.prototype, "isSync", {
    get: function() {
      return !this._needSync;
    },
    enumerable: false,
    configurable: true
  });
  UniformBuffer2.prototype.isDynamic = function() {
    return this._dynamic !== void 0;
  };
  UniformBuffer2.prototype.getData = function() {
    return this._bufferData;
  };
  UniformBuffer2.prototype.getBuffer = function() {
    return this._buffer;
  };
  UniformBuffer2.prototype._fillAlignment = function(size) {
    var alignment;
    if (size <= 2) {
      alignment = size;
    } else {
      alignment = 4;
    }
    if (this._uniformLocationPointer % alignment !== 0) {
      var oldPointer = this._uniformLocationPointer;
      this._uniformLocationPointer += alignment - this._uniformLocationPointer % alignment;
      var diff = this._uniformLocationPointer - oldPointer;
      for (var i = 0; i < diff; i++) {
        this._data.push(0);
      }
    }
  };
  UniformBuffer2.prototype.addUniform = function(name2, size, arraySize) {
    if (arraySize === void 0) {
      arraySize = 0;
    }
    if (this._noUBO) {
      return;
    }
    if (this._uniformLocations[name2] !== void 0) {
      return;
    }
    var data;
    if (arraySize > 0) {
      if (size instanceof Array) {
        throw "addUniform should not be use with Array in UBO: " + name2;
      }
      this._fillAlignment(4);
      this._uniformArraySizes[name2] = { strideSize: size, arraySize };
      if (size == 16) {
        size = size * arraySize;
      } else {
        var perElementPadding = 4 - size;
        var totalPadding = perElementPadding * arraySize;
        size = size * arraySize + totalPadding;
      }
      data = [];
      for (var i = 0; i < size; i++) {
        data.push(0);
      }
    } else {
      if (size instanceof Array) {
        data = size;
        size = data.length;
      } else {
        size = size;
        data = [];
        for (var i = 0; i < size; i++) {
          data.push(0);
        }
      }
      this._fillAlignment(size);
    }
    this._uniformSizes[name2] = size;
    this._uniformLocations[name2] = this._uniformLocationPointer;
    this._uniformLocationPointer += size;
    for (var i = 0; i < size; i++) {
      this._data.push(data[i]);
    }
    this._needSync = true;
  };
  UniformBuffer2.prototype.addMatrix = function(name2, mat) {
    this.addUniform(name2, Array.prototype.slice.call(mat.toArray()));
  };
  UniformBuffer2.prototype.addFloat2 = function(name2, x, y) {
    var temp = [x, y];
    this.addUniform(name2, temp);
  };
  UniformBuffer2.prototype.addFloat3 = function(name2, x, y, z) {
    var temp = [x, y, z];
    this.addUniform(name2, temp);
  };
  UniformBuffer2.prototype.addColor3 = function(name2, color) {
    var temp = [color.r, color.g, color.b];
    this.addUniform(name2, temp);
  };
  UniformBuffer2.prototype.addColor4 = function(name2, color, alpha) {
    var temp = [color.r, color.g, color.b, alpha];
    this.addUniform(name2, temp);
  };
  UniformBuffer2.prototype.addVector3 = function(name2, vector) {
    var temp = [vector.x, vector.y, vector.z];
    this.addUniform(name2, temp);
  };
  UniformBuffer2.prototype.addMatrix3x3 = function(name2) {
    this.addUniform(name2, 12);
  };
  UniformBuffer2.prototype.addMatrix2x2 = function(name2) {
    this.addUniform(name2, 8);
  };
  UniformBuffer2.prototype.create = function() {
    if (this._noUBO) {
      return;
    }
    if (this._buffer) {
      return;
    }
    this._fillAlignment(4);
    this._bufferData = new Float32Array(this._data);
    this._rebuild();
    this._needSync = true;
  };
  UniformBuffer2.prototype._rebuild = function() {
    if (this._noUBO || !this._bufferData) {
      return;
    }
    if (this._dynamic) {
      this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData);
    } else {
      this._buffer = this._engine.createUniformBuffer(this._bufferData);
    }
    if (this._engine._features.trackUbosInFrame) {
      this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : void 0]);
      this._bufferIndex = this._buffers.length - 1;
      this._createBufferOnWrite = false;
    }
  };
  Object.defineProperty(UniformBuffer2.prototype, "_numBuffers", {
    get: function() {
      return this._buffers.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(UniformBuffer2.prototype, "_indexBuffer", {
    get: function() {
      return this._bufferIndex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(UniformBuffer2.prototype, "name", {
    get: function() {
      return this._name;
    },
    enumerable: false,
    configurable: true
  });
  UniformBuffer2.prototype._buffersEqual = function(buf1, buf2) {
    for (var i = 0; i < buf1.length; ++i) {
      if (buf1[i] !== buf2[i]) {
        return false;
      }
    }
    return true;
  };
  UniformBuffer2.prototype._copyBuffer = function(src, dst) {
    for (var i = 0; i < src.length; ++i) {
      dst[i] = src[i];
    }
  };
  UniformBuffer2.prototype.update = function() {
    this.bindUniformBuffer();
    if (!this._buffer) {
      this.create();
      return;
    }
    if (!this._dynamic && !this._needSync) {
      this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
      return;
    }
    if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {
      if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) {
        this._needSync = false;
        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
        return;
      } else {
        this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]);
      }
    }
    this._engine.updateUniformBuffer(this._buffer, this._bufferData);
    if (this._engine._features._collectUbosUpdatedInFrame) {
      if (!UniformBuffer2._updatedUbosInFrame[this._name]) {
        UniformBuffer2._updatedUbosInFrame[this._name] = 0;
      }
      UniformBuffer2._updatedUbosInFrame[this._name]++;
    }
    this._needSync = false;
    this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
  };
  UniformBuffer2.prototype._createNewBuffer = function() {
    if (this._bufferIndex + 1 < this._buffers.length) {
      this._bufferIndex++;
      this._buffer = this._buffers[this._bufferIndex][0];
      this._createBufferOnWrite = false;
      this._needSync = true;
    } else {
      this._rebuild();
    }
  };
  UniformBuffer2.prototype._checkNewFrame = function() {
    if (this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId) {
      this._currentFrameId = this._engine.frameId;
      this._createBufferOnWrite = false;
      if (this._buffers && this._buffers.length > 0) {
        this._needSync = this._bufferIndex !== 0;
        this._bufferIndex = 0;
        this._buffer = this._buffers[this._bufferIndex][0];
      } else {
        this._bufferIndex = -1;
      }
    }
  };
  UniformBuffer2.prototype.updateUniform = function(uniformName, data, size) {
    this._checkNewFrame();
    var location2 = this._uniformLocations[uniformName];
    if (location2 === void 0) {
      if (this._buffer) {
        Logger.Error("Cannot add an uniform after UBO has been created.");
        return;
      }
      this.addUniform(uniformName, size);
      location2 = this._uniformLocations[uniformName];
    }
    if (!this._buffer) {
      this.create();
    }
    if (!this._dynamic) {
      var changed = false;
      for (var i = 0; i < size; i++) {
        if (size === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[location2 + i] !== Tools.FloatRound(data[i])) {
          changed = true;
          if (this._createBufferOnWrite) {
            this._createNewBuffer();
          }
          this._bufferData[location2 + i] = data[i];
        }
      }
      this._needSync = this._needSync || changed;
    } else {
      for (var i = 0; i < size; i++) {
        this._bufferData[location2 + i] = data[i];
      }
    }
  };
  UniformBuffer2.prototype.updateUniformArray = function(uniformName, data, size) {
    this._checkNewFrame();
    var location2 = this._uniformLocations[uniformName];
    if (location2 === void 0) {
      Logger.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform.");
      return;
    }
    if (!this._buffer) {
      this.create();
    }
    var arraySizes = this._uniformArraySizes[uniformName];
    if (!this._dynamic) {
      var changed = false;
      var countToFour = 0;
      var baseStride = 0;
      for (var i = 0; i < size; i++) {
        if (this._bufferData[location2 + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {
          changed = true;
          if (this._createBufferOnWrite) {
            this._createNewBuffer();
          }
          this._bufferData[location2 + baseStride * 4 + countToFour] = data[i];
        }
        countToFour++;
        if (countToFour === arraySizes.strideSize) {
          for (; countToFour < 4; countToFour++) {
            this._bufferData[location2 + baseStride * 4 + countToFour] = 0;
          }
          countToFour = 0;
          baseStride++;
        }
      }
      this._needSync = this._needSync || changed;
    } else {
      for (var i = 0; i < size; i++) {
        this._bufferData[location2 + i] = data[i];
      }
    }
  };
  UniformBuffer2.prototype._cacheMatrix = function(name2, matrix) {
    this._checkNewFrame();
    var cache = this._valueCache[name2];
    var flag = matrix.updateFlag;
    if (cache !== void 0 && cache === flag) {
      return false;
    }
    this._valueCache[name2] = flag;
    return true;
  };
  UniformBuffer2.prototype._updateMatrix3x3ForUniform = function(name2, matrix) {
    for (var i = 0; i < 3; i++) {
      UniformBuffer2._tempBuffer[i * 4] = matrix[i * 3];
      UniformBuffer2._tempBuffer[i * 4 + 1] = matrix[i * 3 + 1];
      UniformBuffer2._tempBuffer[i * 4 + 2] = matrix[i * 3 + 2];
      UniformBuffer2._tempBuffer[i * 4 + 3] = 0;
    }
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 12);
  };
  UniformBuffer2.prototype._updateMatrix3x3ForEffect = function(name2, matrix) {
    this._currentEffect.setMatrix3x3(name2, matrix);
  };
  UniformBuffer2.prototype._updateMatrix2x2ForEffect = function(name2, matrix) {
    this._currentEffect.setMatrix2x2(name2, matrix);
  };
  UniformBuffer2.prototype._updateMatrix2x2ForUniform = function(name2, matrix) {
    for (var i = 0; i < 2; i++) {
      UniformBuffer2._tempBuffer[i * 4] = matrix[i * 2];
      UniformBuffer2._tempBuffer[i * 4 + 1] = matrix[i * 2 + 1];
      UniformBuffer2._tempBuffer[i * 4 + 2] = 0;
      UniformBuffer2._tempBuffer[i * 4 + 3] = 0;
    }
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 8);
  };
  UniformBuffer2.prototype._updateFloatForEffect = function(name2, x) {
    this._currentEffect.setFloat(name2, x);
  };
  UniformBuffer2.prototype._updateFloatForUniform = function(name2, x) {
    UniformBuffer2._tempBuffer[0] = x;
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 1);
  };
  UniformBuffer2.prototype._updateFloat2ForEffect = function(name2, x, y, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setFloat2(name2 + suffix, x, y);
  };
  UniformBuffer2.prototype._updateFloat2ForUniform = function(name2, x, y) {
    UniformBuffer2._tempBuffer[0] = x;
    UniformBuffer2._tempBuffer[1] = y;
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 2);
  };
  UniformBuffer2.prototype._updateFloat3ForEffect = function(name2, x, y, z, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setFloat3(name2 + suffix, x, y, z);
  };
  UniformBuffer2.prototype._updateFloat3ForUniform = function(name2, x, y, z) {
    UniformBuffer2._tempBuffer[0] = x;
    UniformBuffer2._tempBuffer[1] = y;
    UniformBuffer2._tempBuffer[2] = z;
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 3);
  };
  UniformBuffer2.prototype._updateFloat4ForEffect = function(name2, x, y, z, w, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setFloat4(name2 + suffix, x, y, z, w);
  };
  UniformBuffer2.prototype._updateFloat4ForUniform = function(name2, x, y, z, w) {
    UniformBuffer2._tempBuffer[0] = x;
    UniformBuffer2._tempBuffer[1] = y;
    UniformBuffer2._tempBuffer[2] = z;
    UniformBuffer2._tempBuffer[3] = w;
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 4);
  };
  UniformBuffer2.prototype._updateFloatArrayForEffect = function(name2, array) {
    this._currentEffect.setFloatArray(name2, array);
  };
  UniformBuffer2.prototype._updateFloatArrayForUniform = function(name2, array) {
    this.updateUniformArray(name2, array, array.length);
  };
  UniformBuffer2.prototype._updateArrayForEffect = function(name2, array) {
    this._currentEffect.setArray(name2, array);
  };
  UniformBuffer2.prototype._updateArrayForUniform = function(name2, array) {
    this.updateUniformArray(name2, array, array.length);
  };
  UniformBuffer2.prototype._updateIntArrayForEffect = function(name2, array) {
    this._currentEffect.setIntArray(name2, array);
  };
  UniformBuffer2.prototype._updateIntArrayForUniform = function(name2, array) {
    UniformBuffer2._tempBufferInt32View.set(array);
    this.updateUniformArray(name2, UniformBuffer2._tempBuffer, array.length);
  };
  UniformBuffer2.prototype._updateMatrixForEffect = function(name2, mat) {
    this._currentEffect.setMatrix(name2, mat);
  };
  UniformBuffer2.prototype._updateMatrixForUniform = function(name2, mat) {
    if (this._cacheMatrix(name2, mat)) {
      this.updateUniform(name2, mat.toArray(), 16);
    }
  };
  UniformBuffer2.prototype._updateMatricesForEffect = function(name2, mat) {
    this._currentEffect.setMatrices(name2, mat);
  };
  UniformBuffer2.prototype._updateMatricesForUniform = function(name2, mat) {
    this.updateUniform(name2, mat, mat.length);
  };
  UniformBuffer2.prototype._updateVector3ForEffect = function(name2, vector) {
    this._currentEffect.setVector3(name2, vector);
  };
  UniformBuffer2.prototype._updateVector3ForUniform = function(name2, vector) {
    UniformBuffer2._tempBuffer[0] = vector.x;
    UniformBuffer2._tempBuffer[1] = vector.y;
    UniformBuffer2._tempBuffer[2] = vector.z;
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 3);
  };
  UniformBuffer2.prototype._updateVector4ForEffect = function(name2, vector) {
    this._currentEffect.setVector4(name2, vector);
  };
  UniformBuffer2.prototype._updateVector4ForUniform = function(name2, vector) {
    UniformBuffer2._tempBuffer[0] = vector.x;
    UniformBuffer2._tempBuffer[1] = vector.y;
    UniformBuffer2._tempBuffer[2] = vector.z;
    UniformBuffer2._tempBuffer[3] = vector.w;
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 4);
  };
  UniformBuffer2.prototype._updateColor3ForEffect = function(name2, color, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setColor3(name2 + suffix, color);
  };
  UniformBuffer2.prototype._updateColor3ForUniform = function(name2, color) {
    UniformBuffer2._tempBuffer[0] = color.r;
    UniformBuffer2._tempBuffer[1] = color.g;
    UniformBuffer2._tempBuffer[2] = color.b;
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 3);
  };
  UniformBuffer2.prototype._updateColor4ForEffect = function(name2, color, alpha, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setColor4(name2 + suffix, color, alpha);
  };
  UniformBuffer2.prototype._updateDirectColor4ForEffect = function(name2, color, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setDirectColor4(name2 + suffix, color);
  };
  UniformBuffer2.prototype._updateColor4ForUniform = function(name2, color, alpha) {
    UniformBuffer2._tempBuffer[0] = color.r;
    UniformBuffer2._tempBuffer[1] = color.g;
    UniformBuffer2._tempBuffer[2] = color.b;
    UniformBuffer2._tempBuffer[3] = alpha;
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 4);
  };
  UniformBuffer2.prototype._updateDirectColor4ForUniform = function(name2, color) {
    UniformBuffer2._tempBuffer[0] = color.r;
    UniformBuffer2._tempBuffer[1] = color.g;
    UniformBuffer2._tempBuffer[2] = color.b;
    UniformBuffer2._tempBuffer[3] = color.a;
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 4);
  };
  UniformBuffer2.prototype._updateIntForEffect = function(name2, x, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setInt(name2 + suffix, x);
  };
  UniformBuffer2.prototype._updateIntForUniform = function(name2, x) {
    UniformBuffer2._tempBufferInt32View[0] = x;
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 1);
  };
  UniformBuffer2.prototype._updateInt2ForEffect = function(name2, x, y, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setInt2(name2 + suffix, x, y);
  };
  UniformBuffer2.prototype._updateInt2ForUniform = function(name2, x, y) {
    UniformBuffer2._tempBufferInt32View[0] = x;
    UniformBuffer2._tempBufferInt32View[1] = y;
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 2);
  };
  UniformBuffer2.prototype._updateInt3ForEffect = function(name2, x, y, z, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setInt3(name2 + suffix, x, y, z);
  };
  UniformBuffer2.prototype._updateInt3ForUniform = function(name2, x, y, z) {
    UniformBuffer2._tempBufferInt32View[0] = x;
    UniformBuffer2._tempBufferInt32View[1] = y;
    UniformBuffer2._tempBufferInt32View[2] = z;
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 3);
  };
  UniformBuffer2.prototype._updateInt4ForEffect = function(name2, x, y, z, w, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setInt4(name2 + suffix, x, y, z, w);
  };
  UniformBuffer2.prototype._updateInt4ForUniform = function(name2, x, y, z, w) {
    UniformBuffer2._tempBufferInt32View[0] = x;
    UniformBuffer2._tempBufferInt32View[1] = y;
    UniformBuffer2._tempBufferInt32View[2] = z;
    UniformBuffer2._tempBufferInt32View[3] = w;
    this.updateUniform(name2, UniformBuffer2._tempBuffer, 4);
  };
  UniformBuffer2.prototype.setTexture = function(name2, texture) {
    this._currentEffect.setTexture(name2, texture);
  };
  UniformBuffer2.prototype.updateUniformDirectly = function(uniformName, data) {
    this.updateUniform(uniformName, data, data.length);
    this.update();
  };
  UniformBuffer2.prototype.bindToEffect = function(effect, name2) {
    this._currentEffect = effect;
    this._currentEffectName = name2;
  };
  UniformBuffer2.prototype.bindUniformBuffer = function() {
    if (!this._noUBO && this._buffer && this._currentEffect) {
      this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);
    }
  };
  UniformBuffer2.prototype.unbindEffect = function() {
    this._currentEffect = void 0;
    this._currentEffectName = void 0;
  };
  UniformBuffer2.prototype.setDataBuffer = function(dataBuffer) {
    if (!this._buffers) {
      return this._buffer === dataBuffer;
    }
    for (var b = 0; b < this._buffers.length; ++b) {
      var buffer = this._buffers[b];
      if (buffer[0] === dataBuffer) {
        this._bufferIndex = b;
        this._buffer = dataBuffer;
        this._createBufferOnWrite = false;
        this._currentEffect = void 0;
        return true;
      }
    }
    return false;
  };
  UniformBuffer2.prototype.dispose = function() {
    if (this._noUBO) {
      return;
    }
    var uniformBuffers = this._engine._uniformBuffers;
    var index = uniformBuffers.indexOf(this);
    if (index !== -1) {
      uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];
      uniformBuffers.pop();
    }
    if (this._engine._features.trackUbosInFrame && this._buffers) {
      for (var i = 0; i < this._buffers.length; ++i) {
        var buffer = this._buffers[i][0];
        this._engine._releaseBuffer(buffer);
      }
    } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {
      this._buffer = null;
    }
  };
  UniformBuffer2._updatedUbosInFrame = {};
  UniformBuffer2._MAX_UNIFORM_SIZE = 256;
  UniformBuffer2._tempBuffer = new Float32Array(UniformBuffer2._MAX_UNIFORM_SIZE);
  UniformBuffer2._tempBufferInt32View = new Uint32Array(UniformBuffer2._tempBuffer.buffer);
  return UniformBuffer2;
}();
var Buffer2 = function() {
  function Buffer3(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes, divisor) {
    if (stride === void 0) {
      stride = 0;
    }
    if (postponeInternalCreation === void 0) {
      postponeInternalCreation = false;
    }
    if (instanced === void 0) {
      instanced = false;
    }
    if (useBytes === void 0) {
      useBytes = false;
    }
    this._isAlreadyOwned = false;
    if (engine.getScene) {
      this._engine = engine.getScene().getEngine();
    } else {
      this._engine = engine;
    }
    this._updatable = updatable;
    this._instanced = instanced;
    this._divisor = divisor || 1;
    if (data instanceof DataBuffer) {
      this._data = null;
      this._buffer = data;
    } else {
      this._data = data;
      this._buffer = null;
    }
    this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;
    if (!postponeInternalCreation) {
      this.create();
    }
  }
  Buffer3.prototype.createVertexBuffer = function(kind, offset, size, stride, instanced, useBytes, divisor) {
    if (useBytes === void 0) {
      useBytes = false;
    }
    var byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;
    var byteStride = stride ? useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT : this.byteStride;
    return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === void 0 ? this._instanced : instanced, byteOffset, size, void 0, void 0, true, this._divisor || divisor);
  };
  Buffer3.prototype.isUpdatable = function() {
    return this._updatable;
  };
  Buffer3.prototype.getData = function() {
    return this._data;
  };
  Buffer3.prototype.getBuffer = function() {
    return this._buffer;
  };
  Buffer3.prototype.getStrideSize = function() {
    return this.byteStride / Float32Array.BYTES_PER_ELEMENT;
  };
  Buffer3.prototype.create = function(data) {
    if (data === void 0) {
      data = null;
    }
    if (!data && this._buffer) {
      return;
    }
    data = data || this._data;
    if (!data) {
      return;
    }
    if (!this._buffer) {
      if (this._updatable) {
        this._buffer = this._engine.createDynamicVertexBuffer(data);
        this._data = data;
      } else {
        this._buffer = this._engine.createVertexBuffer(data);
      }
    } else if (this._updatable) {
      this._engine.updateDynamicVertexBuffer(this._buffer, data);
      this._data = data;
    }
  };
  Buffer3.prototype._rebuild = function() {
    this._buffer = null;
    this.create(this._data);
  };
  Buffer3.prototype.update = function(data) {
    this.create(data);
  };
  Buffer3.prototype.updateDirectly = function(data, offset, vertexCount, useBytes) {
    if (useBytes === void 0) {
      useBytes = false;
    }
    if (!this._buffer) {
      return;
    }
    if (this._updatable) {
      this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, vertexCount ? vertexCount * this.byteStride : void 0);
      if (offset === 0 && vertexCount === void 0) {
        this._data = data;
      } else {
        this._data = null;
      }
    }
  };
  Buffer3.prototype._increaseReferences = function() {
    if (!this._buffer) {
      return;
    }
    if (!this._isAlreadyOwned) {
      this._isAlreadyOwned = true;
      return;
    }
    this._buffer.references++;
  };
  Buffer3.prototype.dispose = function() {
    if (!this._buffer) {
      return;
    }
    if (this._engine._releaseBuffer(this._buffer)) {
      this._buffer = null;
      this._data = null;
    }
  };
  return Buffer3;
}();
var VertexBuffer = function() {
  function VertexBuffer2(engine, data, kind, updatable, postponeInternalCreation, stride, instanced, offset, size, type, normalized, useBytes, divisor, takeBufferOwnership) {
    if (normalized === void 0) {
      normalized = false;
    }
    if (useBytes === void 0) {
      useBytes = false;
    }
    if (divisor === void 0) {
      divisor = 1;
    }
    if (takeBufferOwnership === void 0) {
      takeBufferOwnership = false;
    }
    if (data instanceof Buffer2) {
      this._buffer = data;
      this._ownsBuffer = takeBufferOwnership;
    } else {
      this._buffer = new Buffer2(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes);
      this._ownsBuffer = true;
    }
    this.uniqueId = VertexBuffer2._Counter++;
    this._kind = kind;
    if (type == void 0) {
      var data_1 = this.getData();
      this.type = VertexBuffer2.FLOAT;
      if (data_1 instanceof Int8Array) {
        this.type = VertexBuffer2.BYTE;
      } else if (data_1 instanceof Uint8Array) {
        this.type = VertexBuffer2.UNSIGNED_BYTE;
      } else if (data_1 instanceof Int16Array) {
        this.type = VertexBuffer2.SHORT;
      } else if (data_1 instanceof Uint16Array) {
        this.type = VertexBuffer2.UNSIGNED_SHORT;
      } else if (data_1 instanceof Int32Array) {
        this.type = VertexBuffer2.INT;
      } else if (data_1 instanceof Uint32Array) {
        this.type = VertexBuffer2.UNSIGNED_INT;
      }
    } else {
      this.type = type;
    }
    var typeByteLength = VertexBuffer2.GetTypeByteLength(this.type);
    if (useBytes) {
      this._size = size || (stride ? stride / typeByteLength : VertexBuffer2.DeduceStride(kind));
      this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;
      this.byteOffset = offset || 0;
    } else {
      this._size = size || stride || VertexBuffer2.DeduceStride(kind);
      this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;
      this.byteOffset = (offset || 0) * typeByteLength;
    }
    this.normalized = normalized;
    this._instanced = instanced !== void 0 ? instanced : false;
    this._instanceDivisor = instanced ? divisor : 0;
    this._computeHashCode();
  }
  Object.defineProperty(VertexBuffer2.prototype, "instanceDivisor", {
    get: function() {
      return this._instanceDivisor;
    },
    set: function(value) {
      this._instanceDivisor = value;
      if (value == 0) {
        this._instanced = false;
      } else {
        this._instanced = true;
      }
      this._computeHashCode();
    },
    enumerable: false,
    configurable: true
  });
  VertexBuffer2.prototype._computeHashCode = function() {
    this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + (this.byteStride << 12);
  };
  VertexBuffer2.prototype._rebuild = function() {
    if (!this._buffer) {
      return;
    }
    this._buffer._rebuild();
  };
  VertexBuffer2.prototype.getKind = function() {
    return this._kind;
  };
  VertexBuffer2.prototype.isUpdatable = function() {
    return this._buffer.isUpdatable();
  };
  VertexBuffer2.prototype.getData = function() {
    return this._buffer.getData();
  };
  VertexBuffer2.prototype.getFloatData = function(totalVertices, forceCopy) {
    var data = this.getData();
    if (!data) {
      return null;
    }
    var tightlyPackedByteStride = this.getSize() * VertexBuffer2.GetTypeByteLength(this.type);
    var count = totalVertices * this.getSize();
    if (this.type !== VertexBuffer2.FLOAT || this.byteStride !== tightlyPackedByteStride) {
      var copy_1 = new Float32Array(count);
      this.forEach(count, function(value, index) {
        return copy_1[index] = value;
      });
      return copy_1;
    }
    if (!(data instanceof Array || data instanceof Float32Array) || this.byteOffset !== 0 || data.length !== count) {
      if (data instanceof Array) {
        var offset = this.byteOffset / 4;
        return SliceTools.Slice(data, offset, offset + count);
      } else if (data instanceof ArrayBuffer) {
        return new Float32Array(data, this.byteOffset, count);
      } else {
        var offset = data.byteOffset + this.byteOffset;
        if (forceCopy) {
          var result = new Float32Array(count);
          var source = new Float32Array(data.buffer, offset, count);
          result.set(source);
          return result;
        }
        var remainder = offset % 4;
        if (remainder) {
          offset = Math.max(0, offset - remainder);
        }
        return new Float32Array(data.buffer, offset, count);
      }
    }
    if (forceCopy) {
      return SliceTools.Slice(data);
    }
    return data;
  };
  VertexBuffer2.prototype.getBuffer = function() {
    return this._buffer.getBuffer();
  };
  VertexBuffer2.prototype.getStrideSize = function() {
    return this.byteStride / VertexBuffer2.GetTypeByteLength(this.type);
  };
  VertexBuffer2.prototype.getOffset = function() {
    return this.byteOffset / VertexBuffer2.GetTypeByteLength(this.type);
  };
  VertexBuffer2.prototype.getSize = function(sizeInBytes) {
    if (sizeInBytes === void 0) {
      sizeInBytes = false;
    }
    return sizeInBytes ? this._size * VertexBuffer2.GetTypeByteLength(this.type) : this._size;
  };
  VertexBuffer2.prototype.getIsInstanced = function() {
    return this._instanced;
  };
  VertexBuffer2.prototype.getInstanceDivisor = function() {
    return this._instanceDivisor;
  };
  VertexBuffer2.prototype.create = function(data) {
    this._buffer.create(data);
  };
  VertexBuffer2.prototype.update = function(data) {
    this._buffer.update(data);
  };
  VertexBuffer2.prototype.updateDirectly = function(data, offset, useBytes) {
    if (useBytes === void 0) {
      useBytes = false;
    }
    this._buffer.updateDirectly(data, offset, void 0, useBytes);
  };
  VertexBuffer2.prototype.dispose = function() {
    if (this._ownsBuffer) {
      this._buffer.dispose();
    }
  };
  VertexBuffer2.prototype.forEach = function(count, callback) {
    VertexBuffer2.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);
  };
  VertexBuffer2.DeduceStride = function(kind) {
    switch (kind) {
      case VertexBuffer2.UVKind:
      case VertexBuffer2.UV2Kind:
      case VertexBuffer2.UV3Kind:
      case VertexBuffer2.UV4Kind:
      case VertexBuffer2.UV5Kind:
      case VertexBuffer2.UV6Kind:
        return 2;
      case VertexBuffer2.NormalKind:
      case VertexBuffer2.PositionKind:
        return 3;
      case VertexBuffer2.ColorKind:
      case VertexBuffer2.MatricesIndicesKind:
      case VertexBuffer2.MatricesIndicesExtraKind:
      case VertexBuffer2.MatricesWeightsKind:
      case VertexBuffer2.MatricesWeightsExtraKind:
      case VertexBuffer2.TangentKind:
        return 4;
      default:
        throw new Error("Invalid kind '" + kind + "'");
    }
  };
  VertexBuffer2.GetTypeByteLength = function(type) {
    switch (type) {
      case VertexBuffer2.BYTE:
      case VertexBuffer2.UNSIGNED_BYTE:
        return 1;
      case VertexBuffer2.SHORT:
      case VertexBuffer2.UNSIGNED_SHORT:
        return 2;
      case VertexBuffer2.INT:
      case VertexBuffer2.UNSIGNED_INT:
      case VertexBuffer2.FLOAT:
        return 4;
      default:
        throw new Error("Invalid type '".concat(type, "'"));
    }
  };
  VertexBuffer2.ForEach = function(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {
    if (data instanceof Array) {
      var offset = byteOffset / 4;
      var stride = byteStride / 4;
      for (var index = 0; index < count; index += componentCount) {
        for (var componentIndex = 0; componentIndex < componentCount; componentIndex++) {
          callback(data[offset + componentIndex], index + componentIndex);
        }
        offset += stride;
      }
    } else {
      var dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);
      var componentByteLength = VertexBuffer2.GetTypeByteLength(componentType);
      for (var index = 0; index < count; index += componentCount) {
        var componentByteOffset = byteOffset;
        for (var componentIndex = 0; componentIndex < componentCount; componentIndex++) {
          var value = VertexBuffer2._GetFloatValue(dataView, componentType, componentByteOffset, normalized);
          callback(value, index + componentIndex);
          componentByteOffset += componentByteLength;
        }
        byteOffset += byteStride;
      }
    }
  };
  VertexBuffer2._GetFloatValue = function(dataView, type, byteOffset, normalized) {
    switch (type) {
      case VertexBuffer2.BYTE: {
        var value = dataView.getInt8(byteOffset);
        if (normalized) {
          value = Math.max(value / 127, -1);
        }
        return value;
      }
      case VertexBuffer2.UNSIGNED_BYTE: {
        var value = dataView.getUint8(byteOffset);
        if (normalized) {
          value = value / 255;
        }
        return value;
      }
      case VertexBuffer2.SHORT: {
        var value = dataView.getInt16(byteOffset, true);
        if (normalized) {
          value = Math.max(value / 32767, -1);
        }
        return value;
      }
      case VertexBuffer2.UNSIGNED_SHORT: {
        var value = dataView.getUint16(byteOffset, true);
        if (normalized) {
          value = value / 65535;
        }
        return value;
      }
      case VertexBuffer2.INT: {
        return dataView.getInt32(byteOffset, true);
      }
      case VertexBuffer2.UNSIGNED_INT: {
        return dataView.getUint32(byteOffset, true);
      }
      case VertexBuffer2.FLOAT: {
        return dataView.getFloat32(byteOffset, true);
      }
      default: {
        throw new Error("Invalid component type ".concat(type));
      }
    }
  };
  VertexBuffer2._Counter = 0;
  VertexBuffer2.BYTE = 5120;
  VertexBuffer2.UNSIGNED_BYTE = 5121;
  VertexBuffer2.SHORT = 5122;
  VertexBuffer2.UNSIGNED_SHORT = 5123;
  VertexBuffer2.INT = 5124;
  VertexBuffer2.UNSIGNED_INT = 5125;
  VertexBuffer2.FLOAT = 5126;
  VertexBuffer2.PositionKind = "position";
  VertexBuffer2.NormalKind = "normal";
  VertexBuffer2.TangentKind = "tangent";
  VertexBuffer2.UVKind = "uv";
  VertexBuffer2.UV2Kind = "uv2";
  VertexBuffer2.UV3Kind = "uv3";
  VertexBuffer2.UV4Kind = "uv4";
  VertexBuffer2.UV5Kind = "uv5";
  VertexBuffer2.UV6Kind = "uv6";
  VertexBuffer2.ColorKind = "color";
  VertexBuffer2.ColorInstanceKind = "instanceColor";
  VertexBuffer2.MatricesIndicesKind = "matricesIndices";
  VertexBuffer2.MatricesWeightsKind = "matricesWeights";
  VertexBuffer2.MatricesIndicesExtraKind = "matricesIndicesExtra";
  VertexBuffer2.MatricesWeightsExtraKind = "matricesWeightsExtra";
  return VertexBuffer2;
}();
var PickingInfo = function() {
  function PickingInfo2() {
    this._pickingUnavailable = false;
    this.hit = false;
    this.distance = 0;
    this.pickedPoint = null;
    this.pickedMesh = null;
    this.bu = 0;
    this.bv = 0;
    this.faceId = -1;
    this.subMeshFaceId = -1;
    this.subMeshId = 0;
    this.pickedSprite = null;
    this.thinInstanceIndex = -1;
    this.ray = null;
    this.originMesh = null;
    this.aimTransform = null;
    this.gripTransform = null;
  }
  PickingInfo2.prototype.getNormal = function(useWorldCoordinates, useVerticesNormals) {
    if (useWorldCoordinates === void 0) {
      useWorldCoordinates = false;
    }
    if (useVerticesNormals === void 0) {
      useVerticesNormals = true;
    }
    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      return null;
    }
    var indices = this.pickedMesh.getIndices();
    if (!indices) {
      return null;
    }
    var result;
    if (useVerticesNormals) {
      var normals = this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);
      var normal0 = Vector3.FromArray(normals, indices[this.faceId * 3] * 3);
      var normal1 = Vector3.FromArray(normals, indices[this.faceId * 3 + 1] * 3);
      var normal2 = Vector3.FromArray(normals, indices[this.faceId * 3 + 2] * 3);
      normal0 = normal0.scale(this.bu);
      normal1 = normal1.scale(this.bv);
      normal2 = normal2.scale(1 - this.bu - this.bv);
      result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);
    } else {
      var positions = this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);
      var vertex1 = Vector3.FromArray(positions, indices[this.faceId * 3] * 3);
      var vertex2 = Vector3.FromArray(positions, indices[this.faceId * 3 + 1] * 3);
      var vertex3 = Vector3.FromArray(positions, indices[this.faceId * 3 + 2] * 3);
      var p1p2 = vertex1.subtract(vertex2);
      var p3p2 = vertex3.subtract(vertex2);
      result = Vector3.Cross(p1p2, p3p2);
    }
    if (useWorldCoordinates) {
      var wm = this.pickedMesh.getWorldMatrix();
      if (this.pickedMesh.nonUniformScaling) {
        TmpVectors.Matrix[0].copyFrom(wm);
        wm = TmpVectors.Matrix[0];
        wm.setTranslationFromFloats(0, 0, 0);
        wm.invert();
        wm.transposeToRef(TmpVectors.Matrix[1]);
        wm = TmpVectors.Matrix[1];
      }
      result = Vector3.TransformNormal(result, wm);
    }
    result.normalize();
    return result;
  };
  PickingInfo2.prototype.getTextureCoordinates = function() {
    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
      return null;
    }
    var indices = this.pickedMesh.getIndices();
    if (!indices) {
      return null;
    }
    var uvs = this.pickedMesh.getVerticesData(VertexBuffer.UVKind);
    if (!uvs) {
      return null;
    }
    var uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);
    var uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);
    var uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);
    uv0 = uv0.scale(this.bu);
    uv1 = uv1.scale(this.bv);
    uv2 = uv2.scale(1 - this.bu - this.bv);
    return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);
  };
  return PickingInfo2;
}();
var ActionEvent = function() {
  function ActionEvent2(source, pointerX, pointerY, meshUnderPointer, sourceEvent, additionalData) {
    this.source = source;
    this.pointerX = pointerX;
    this.pointerY = pointerY;
    this.meshUnderPointer = meshUnderPointer;
    this.sourceEvent = sourceEvent;
    this.additionalData = additionalData;
  }
  ActionEvent2.CreateNew = function(source, evt, additionalData) {
    var scene = source.getScene();
    return new ActionEvent2(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer || source, evt, additionalData);
  };
  ActionEvent2.CreateNewFromSprite = function(source, scene, evt, additionalData) {
    return new ActionEvent2(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt, additionalData);
  };
  ActionEvent2.CreateNewFromScene = function(scene, evt) {
    return new ActionEvent2(null, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt);
  };
  ActionEvent2.CreateNewFromPrimitive = function(prim, pointerPos, evt, additionalData) {
    return new ActionEvent2(prim, pointerPos.x, pointerPos.y, null, evt, additionalData);
  };
  return ActionEvent2;
}();
var PostProcessManager = function() {
  function PostProcessManager2(scene) {
    this._vertexBuffers = {};
    this._scene = scene;
  }
  PostProcessManager2.prototype._prepareBuffers = function() {
    if (this._vertexBuffers[VertexBuffer.PositionKind]) {
      return;
    }
    var vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._scene.getEngine(), vertices, VertexBuffer.PositionKind, false, false, 2);
    this._buildIndexBuffer();
  };
  PostProcessManager2.prototype._buildIndexBuffer = function() {
    var indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);
  };
  PostProcessManager2.prototype._rebuild = function() {
    var vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (!vb) {
      return;
    }
    vb._rebuild();
    this._buildIndexBuffer();
  };
  PostProcessManager2.prototype._prepareFrame = function(sourceTexture, postProcesses) {
    if (sourceTexture === void 0) {
      sourceTexture = null;
    }
    if (postProcesses === void 0) {
      postProcesses = null;
    }
    var camera = this._scene.activeCamera;
    if (!camera) {
      return false;
    }
    postProcesses = postProcesses || camera._postProcesses.filter(function(pp) {
      return pp != null;
    });
    if (!postProcesses || postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
      return false;
    }
    postProcesses[0].activate(camera, sourceTexture, postProcesses !== null && postProcesses !== void 0);
    return true;
  };
  PostProcessManager2.prototype.directRender = function(postProcesses, targetTexture, forceFullscreenViewport, faceIndex, lodLevel, doNotBindFrambuffer) {
    var _a;
    if (targetTexture === void 0) {
      targetTexture = null;
    }
    if (forceFullscreenViewport === void 0) {
      forceFullscreenViewport = false;
    }
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lodLevel === void 0) {
      lodLevel = 0;
    }
    if (doNotBindFrambuffer === void 0) {
      doNotBindFrambuffer = false;
    }
    var engine = this._scene.getEngine();
    for (var index = 0; index < postProcesses.length; index++) {
      if (index < postProcesses.length - 1) {
        postProcesses[index + 1].activate(this._scene.activeCamera, targetTexture === null || targetTexture === void 0 ? void 0 : targetTexture.texture);
      } else {
        if (targetTexture) {
          engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport, lodLevel);
        } else if (!doNotBindFrambuffer) {
          engine.restoreDefaultFramebuffer();
        }
        (_a = engine._debugInsertMarker) === null || _a === void 0 ? void 0 : _a.call(engine, "post process ".concat(postProcesses[index].name, " output"));
      }
      var pp = postProcesses[index];
      var effect = pp.apply();
      if (effect) {
        pp.onBeforeRenderObservable.notifyObservers(effect);
        this._prepareBuffers();
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
        engine.drawElementsType(0, 0, 6);
        pp.onAfterRenderObservable.notifyObservers(effect);
      }
    }
    engine.setDepthBuffer(true);
    engine.setDepthWrite(true);
  };
  PostProcessManager2.prototype._finalizeFrame = function(doNotPresent, targetTexture, faceIndex, postProcesses, forceFullscreenViewport) {
    var _a;
    if (forceFullscreenViewport === void 0) {
      forceFullscreenViewport = false;
    }
    var camera = this._scene.activeCamera;
    if (!camera) {
      return;
    }
    postProcesses = postProcesses || camera._postProcesses.filter(function(pp2) {
      return pp2 != null;
    });
    if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
      return;
    }
    var engine = this._scene.getEngine();
    for (var index = 0, len = postProcesses.length; index < len; index++) {
      var pp = postProcesses[index];
      if (index < len - 1) {
        pp._outputTexture = postProcesses[index + 1].activate(camera, targetTexture === null || targetTexture === void 0 ? void 0 : targetTexture.texture);
      } else {
        if (targetTexture) {
          engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport);
          pp._outputTexture = targetTexture;
        } else {
          engine.restoreDefaultFramebuffer();
          pp._outputTexture = null;
        }
        (_a = engine._debugInsertMarker) === null || _a === void 0 ? void 0 : _a.call(engine, "post process ".concat(postProcesses[index].name, " output"));
      }
      if (doNotPresent) {
        break;
      }
      var effect = pp.apply();
      if (effect) {
        pp.onBeforeRenderObservable.notifyObservers(effect);
        this._prepareBuffers();
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
        engine.drawElementsType(0, 0, 6);
        pp.onAfterRenderObservable.notifyObservers(effect);
      }
    }
    engine.setDepthBuffer(true);
    engine.setDepthWrite(true);
    engine.setAlphaMode(0);
  };
  PostProcessManager2.prototype.dispose = function() {
    var buffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (buffer) {
      buffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer) {
      this._scene.getEngine()._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
  };
  return PostProcessManager2;
}();
var RenderingGroup = function() {
  function RenderingGroup2(index, scene, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
    if (opaqueSortCompareFn === void 0) {
      opaqueSortCompareFn = null;
    }
    if (alphaTestSortCompareFn === void 0) {
      alphaTestSortCompareFn = null;
    }
    if (transparentSortCompareFn === void 0) {
      transparentSortCompareFn = null;
    }
    this.index = index;
    this._opaqueSubMeshes = new SmartArray(256);
    this._transparentSubMeshes = new SmartArray(256);
    this._alphaTestSubMeshes = new SmartArray(256);
    this._depthOnlySubMeshes = new SmartArray(256);
    this._particleSystems = new SmartArray(256);
    this._spriteManagers = new SmartArray(256);
    this._edgesRenderers = new SmartArrayNoDuplicate(16);
    this._scene = scene;
    this.opaqueSortCompareFn = opaqueSortCompareFn;
    this.alphaTestSortCompareFn = alphaTestSortCompareFn;
    this.transparentSortCompareFn = transparentSortCompareFn;
  }
  Object.defineProperty(RenderingGroup2.prototype, "opaqueSortCompareFn", {
    set: function(value) {
      this._opaqueSortCompareFn = value;
      if (value) {
        this._renderOpaque = this.renderOpaqueSorted;
      } else {
        this._renderOpaque = RenderingGroup2.renderUnsorted;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderingGroup2.prototype, "alphaTestSortCompareFn", {
    set: function(value) {
      this._alphaTestSortCompareFn = value;
      if (value) {
        this._renderAlphaTest = this.renderAlphaTestSorted;
      } else {
        this._renderAlphaTest = RenderingGroup2.renderUnsorted;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderingGroup2.prototype, "transparentSortCompareFn", {
    set: function(value) {
      if (value) {
        this._transparentSortCompareFn = value;
      } else {
        this._transparentSortCompareFn = RenderingGroup2.defaultTransparentSortCompare;
      }
      this._renderTransparent = this.renderTransparentSorted;
    },
    enumerable: false,
    configurable: true
  });
  RenderingGroup2.prototype.render = function(customRenderFunction, renderSprites, renderParticles, activeMeshes) {
    if (customRenderFunction) {
      customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);
      return;
    }
    var engine = this._scene.getEngine();
    if (this._depthOnlySubMeshes.length !== 0) {
      engine.setColorWrite(false);
      this._renderAlphaTest(this._depthOnlySubMeshes);
      engine.setColorWrite(true);
    }
    if (this._opaqueSubMeshes.length !== 0) {
      this._renderOpaque(this._opaqueSubMeshes);
    }
    if (this._alphaTestSubMeshes.length !== 0) {
      this._renderAlphaTest(this._alphaTestSubMeshes);
    }
    var stencilState = engine.getStencilBuffer();
    engine.setStencilBuffer(false);
    if (renderSprites) {
      this._renderSprites();
    }
    if (renderParticles) {
      this._renderParticles(activeMeshes);
    }
    if (this.onBeforeTransparentRendering) {
      this.onBeforeTransparentRendering();
    }
    if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {
      engine.setStencilBuffer(stencilState);
      if (this._scene.useOrderIndependentTransparency) {
        var excludedMeshes = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);
        if (excludedMeshes.length) {
          this._renderTransparent(excludedMeshes);
        }
      } else {
        this._renderTransparent(this._transparentSubMeshes);
      }
      engine.setAlphaMode(0);
    }
    engine.setStencilBuffer(false);
    if (this._edgesRenderers.length) {
      for (var edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {
        this._edgesRenderers.data[edgesRendererIndex].render();
      }
      engine.setAlphaMode(0);
    }
    engine.setStencilBuffer(stencilState);
  };
  RenderingGroup2.prototype.renderOpaqueSorted = function(subMeshes) {
    return RenderingGroup2.renderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);
  };
  RenderingGroup2.prototype.renderAlphaTestSorted = function(subMeshes) {
    return RenderingGroup2.renderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);
  };
  RenderingGroup2.prototype.renderTransparentSorted = function(subMeshes) {
    return RenderingGroup2.renderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);
  };
  RenderingGroup2.renderSorted = function(subMeshes, sortCompareFn, camera, transparent) {
    var subIndex = 0;
    var subMesh;
    var cameraPosition = camera ? camera.globalPosition : RenderingGroup2._zeroVector;
    for (; subIndex < subMeshes.length; subIndex++) {
      subMesh = subMeshes.data[subIndex];
      subMesh._alphaIndex = subMesh.getMesh().alphaIndex;
      subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);
    }
    var sortedArray = subMeshes.data.slice(0, subMeshes.length);
    if (sortCompareFn) {
      sortedArray.sort(sortCompareFn);
    }
    for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {
      subMesh = sortedArray[subIndex];
      if (transparent) {
        var material = subMesh.getMaterial();
        if (material && material.needDepthPrePass) {
          var engine = material.getScene().getEngine();
          engine.setColorWrite(false);
          engine.setAlphaMode(0);
          subMesh.render(false);
          engine.setColorWrite(true);
        }
      }
      subMesh.render(transparent);
    }
  };
  RenderingGroup2.renderUnsorted = function(subMeshes) {
    for (var subIndex = 0; subIndex < subMeshes.length; subIndex++) {
      var submesh = subMeshes.data[subIndex];
      submesh.render(false);
    }
  };
  RenderingGroup2.defaultTransparentSortCompare = function(a, b) {
    if (a._alphaIndex > b._alphaIndex) {
      return 1;
    }
    if (a._alphaIndex < b._alphaIndex) {
      return -1;
    }
    return RenderingGroup2.backToFrontSortCompare(a, b);
  };
  RenderingGroup2.backToFrontSortCompare = function(a, b) {
    if (a._distanceToCamera < b._distanceToCamera) {
      return 1;
    }
    if (a._distanceToCamera > b._distanceToCamera) {
      return -1;
    }
    return 0;
  };
  RenderingGroup2.frontToBackSortCompare = function(a, b) {
    if (a._distanceToCamera < b._distanceToCamera) {
      return -1;
    }
    if (a._distanceToCamera > b._distanceToCamera) {
      return 1;
    }
    return 0;
  };
  RenderingGroup2.prototype.prepare = function() {
    this._opaqueSubMeshes.reset();
    this._transparentSubMeshes.reset();
    this._alphaTestSubMeshes.reset();
    this._depthOnlySubMeshes.reset();
    this._particleSystems.reset();
    this._spriteManagers.reset();
    this._edgesRenderers.reset();
  };
  RenderingGroup2.prototype.dispose = function() {
    this._opaqueSubMeshes.dispose();
    this._transparentSubMeshes.dispose();
    this._alphaTestSubMeshes.dispose();
    this._depthOnlySubMeshes.dispose();
    this._particleSystems.dispose();
    this._spriteManagers.dispose();
    this._edgesRenderers.dispose();
  };
  RenderingGroup2.prototype.dispatch = function(subMesh, mesh, material) {
    if (mesh === void 0) {
      mesh = subMesh.getMesh();
    }
    if (material === void 0) {
      material = subMesh.getMaterial();
    }
    if (material === null || material === void 0) {
      return;
    }
    if (material.needAlphaBlendingForMesh(mesh)) {
      this._transparentSubMeshes.push(subMesh);
    } else if (material.needAlphaTesting()) {
      if (material.needDepthPrePass) {
        this._depthOnlySubMeshes.push(subMesh);
      }
      this._alphaTestSubMeshes.push(subMesh);
    } else {
      if (material.needDepthPrePass) {
        this._depthOnlySubMeshes.push(subMesh);
      }
      this._opaqueSubMeshes.push(subMesh);
    }
    mesh._renderingGroup = this;
    if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {
      this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);
    }
  };
  RenderingGroup2.prototype.dispatchSprites = function(spriteManager) {
    this._spriteManagers.push(spriteManager);
  };
  RenderingGroup2.prototype.dispatchParticles = function(particleSystem) {
    this._particleSystems.push(particleSystem);
  };
  RenderingGroup2.prototype._renderParticles = function(activeMeshes) {
    if (this._particleSystems.length === 0) {
      return;
    }
    var activeCamera = this._scene.activeCamera;
    this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);
    for (var particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {
      var particleSystem = this._particleSystems.data[particleIndex];
      if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {
        continue;
      }
      var emitter = particleSystem.emitter;
      if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {
        this._scene._activeParticles.addCount(particleSystem.render(), false);
      }
    }
    this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);
  };
  RenderingGroup2.prototype._renderSprites = function() {
    if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {
      return;
    }
    var activeCamera = this._scene.activeCamera;
    this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);
    for (var id = 0; id < this._spriteManagers.length; id++) {
      var spriteManager = this._spriteManagers.data[id];
      if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {
        spriteManager.render();
      }
    }
    this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);
  };
  RenderingGroup2._zeroVector = Vector3.Zero();
  return RenderingGroup2;
}();
var RenderingGroupInfo = function() {
  function RenderingGroupInfo2() {
  }
  return RenderingGroupInfo2;
}();
var RenderingManager = function() {
  function RenderingManager2(scene) {
    this._useSceneAutoClearSetup = false;
    this._renderingGroups = new Array();
    this._autoClearDepthStencil = {};
    this._customOpaqueSortCompareFn = {};
    this._customAlphaTestSortCompareFn = {};
    this._customTransparentSortCompareFn = {};
    this._renderingGroupInfo = new RenderingGroupInfo();
    this._scene = scene;
    for (var i = RenderingManager2.MIN_RENDERINGGROUPS; i < RenderingManager2.MAX_RENDERINGGROUPS; i++) {
      this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };
    }
  }
  RenderingManager2.prototype._clearDepthStencilBuffer = function(depth, stencil) {
    if (depth === void 0) {
      depth = true;
    }
    if (stencil === void 0) {
      stencil = true;
    }
    if (this._depthStencilBufferAlreadyCleaned) {
      return;
    }
    this._scene.getEngine().clear(null, false, depth, stencil);
    this._depthStencilBufferAlreadyCleaned = true;
  };
  RenderingManager2.prototype.render = function(customRenderFunction, activeMeshes, renderParticles, renderSprites) {
    var info = this._renderingGroupInfo;
    info.scene = this._scene;
    info.camera = this._scene.activeCamera;
    if (this._scene.spriteManagers && renderSprites) {
      for (var index = 0; index < this._scene.spriteManagers.length; index++) {
        var manager = this._scene.spriteManagers[index];
        this.dispatchSprites(manager);
      }
    }
    for (var index = RenderingManager2.MIN_RENDERINGGROUPS; index < RenderingManager2.MAX_RENDERINGGROUPS; index++) {
      this._depthStencilBufferAlreadyCleaned = index === RenderingManager2.MIN_RENDERINGGROUPS;
      var renderingGroup = this._renderingGroups[index];
      if (!renderingGroup) {
        continue;
      }
      var renderingGroupMask = Math.pow(2, index);
      info.renderingGroupId = index;
      this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
      if (RenderingManager2.AUTOCLEAR) {
        var autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];
        if (autoClear && autoClear.autoClear) {
          this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);
        }
      }
      for (var _i = 0, _a = this._scene._beforeRenderingGroupDrawStage; _i < _a.length; _i++) {
        var step = _a[_i];
        step.action(index);
      }
      renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);
      for (var _b = 0, _c = this._scene._afterRenderingGroupDrawStage; _b < _c.length; _b++) {
        var step = _c[_b];
        step.action(index);
      }
      this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
    }
  };
  RenderingManager2.prototype.reset = function() {
    for (var index = RenderingManager2.MIN_RENDERINGGROUPS; index < RenderingManager2.MAX_RENDERINGGROUPS; index++) {
      var renderingGroup = this._renderingGroups[index];
      if (renderingGroup) {
        renderingGroup.prepare();
      }
    }
  };
  RenderingManager2.prototype.dispose = function() {
    this.freeRenderingGroups();
    this._renderingGroups.length = 0;
    this._renderingGroupInfo = null;
  };
  RenderingManager2.prototype.freeRenderingGroups = function() {
    for (var index = RenderingManager2.MIN_RENDERINGGROUPS; index < RenderingManager2.MAX_RENDERINGGROUPS; index++) {
      var renderingGroup = this._renderingGroups[index];
      if (renderingGroup) {
        renderingGroup.dispose();
      }
    }
  };
  RenderingManager2.prototype._prepareRenderingGroup = function(renderingGroupId) {
    if (this._renderingGroups[renderingGroupId] === void 0) {
      this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);
    }
  };
  RenderingManager2.prototype.dispatchSprites = function(spriteManager) {
    var renderingGroupId = spriteManager.renderingGroupId || 0;
    this._prepareRenderingGroup(renderingGroupId);
    this._renderingGroups[renderingGroupId].dispatchSprites(spriteManager);
  };
  RenderingManager2.prototype.dispatchParticles = function(particleSystem) {
    var renderingGroupId = particleSystem.renderingGroupId || 0;
    this._prepareRenderingGroup(renderingGroupId);
    this._renderingGroups[renderingGroupId].dispatchParticles(particleSystem);
  };
  RenderingManager2.prototype.dispatch = function(subMesh, mesh, material) {
    if (mesh === void 0) {
      mesh = subMesh.getMesh();
    }
    var renderingGroupId = mesh.renderingGroupId || 0;
    this._prepareRenderingGroup(renderingGroupId);
    this._renderingGroups[renderingGroupId].dispatch(subMesh, mesh, material);
  };
  RenderingManager2.prototype.setRenderingOrder = function(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
    if (opaqueSortCompareFn === void 0) {
      opaqueSortCompareFn = null;
    }
    if (alphaTestSortCompareFn === void 0) {
      alphaTestSortCompareFn = null;
    }
    if (transparentSortCompareFn === void 0) {
      transparentSortCompareFn = null;
    }
    this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;
    this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;
    this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;
    if (this._renderingGroups[renderingGroupId]) {
      var group = this._renderingGroups[renderingGroupId];
      group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];
      group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];
      group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];
    }
  };
  RenderingManager2.prototype.setRenderingAutoClearDepthStencil = function(renderingGroupId, autoClearDepthStencil, depth, stencil) {
    if (depth === void 0) {
      depth = true;
    }
    if (stencil === void 0) {
      stencil = true;
    }
    this._autoClearDepthStencil[renderingGroupId] = {
      autoClear: autoClearDepthStencil,
      depth,
      stencil
    };
  };
  RenderingManager2.prototype.getAutoClearDepthStencilSetup = function(index) {
    return this._autoClearDepthStencil[index];
  };
  RenderingManager2.MAX_RENDERINGGROUPS = 4;
  RenderingManager2.MIN_RENDERINGGROUPS = 0;
  RenderingManager2.AUTOCLEAR = true;
  return RenderingManager2;
}();
var SceneComponentConstants = function() {
  function SceneComponentConstants2() {
  }
  SceneComponentConstants2.NAME_EFFECTLAYER = "EffectLayer";
  SceneComponentConstants2.NAME_LAYER = "Layer";
  SceneComponentConstants2.NAME_LENSFLARESYSTEM = "LensFlareSystem";
  SceneComponentConstants2.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer";
  SceneComponentConstants2.NAME_PARTICLESYSTEM = "ParticleSystem";
  SceneComponentConstants2.NAME_GAMEPAD = "Gamepad";
  SceneComponentConstants2.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue";
  SceneComponentConstants2.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer";
  SceneComponentConstants2.NAME_PREPASSRENDERER = "PrePassRenderer";
  SceneComponentConstants2.NAME_DEPTHRENDERER = "DepthRenderer";
  SceneComponentConstants2.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer";
  SceneComponentConstants2.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager";
  SceneComponentConstants2.NAME_SPRITE = "Sprite";
  SceneComponentConstants2.NAME_SUBSURFACE = "SubSurface";
  SceneComponentConstants2.NAME_OUTLINERENDERER = "Outline";
  SceneComponentConstants2.NAME_PROCEDURALTEXTURE = "ProceduralTexture";
  SceneComponentConstants2.NAME_SHADOWGENERATOR = "ShadowGenerator";
  SceneComponentConstants2.NAME_OCTREE = "Octree";
  SceneComponentConstants2.NAME_PHYSICSENGINE = "PhysicsEngine";
  SceneComponentConstants2.NAME_AUDIO = "Audio";
  SceneComponentConstants2.STEP_ISREADYFORMESH_EFFECTLAYER = 0;
  SceneComponentConstants2.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;
  SceneComponentConstants2.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;
  SceneComponentConstants2.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;
  SceneComponentConstants2.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;
  SceneComponentConstants2.STEP_BEFORECAMERADRAW_PREPASS = 0;
  SceneComponentConstants2.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;
  SceneComponentConstants2.STEP_BEFORECAMERADRAW_LAYER = 2;
  SceneComponentConstants2.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;
  SceneComponentConstants2.STEP_BEFORERENDERTARGETDRAW_LAYER = 1;
  SceneComponentConstants2.STEP_BEFORERENDERINGMESH_PREPASS = 0;
  SceneComponentConstants2.STEP_BEFORERENDERINGMESH_OUTLINE = 1;
  SceneComponentConstants2.STEP_AFTERRENDERINGMESH_PREPASS = 0;
  SceneComponentConstants2.STEP_AFTERRENDERINGMESH_OUTLINE = 1;
  SceneComponentConstants2.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;
  SceneComponentConstants2.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;
  SceneComponentConstants2.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;
  SceneComponentConstants2.STEP_BEFORECAMERAUPDATE_GAMEPAD = 1;
  SceneComponentConstants2.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;
  SceneComponentConstants2.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;
  SceneComponentConstants2.STEP_AFTERRENDERTARGETDRAW_LAYER = 1;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_PREPASS = 0;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_LAYER = 4;
  SceneComponentConstants2.STEP_AFTERRENDER_AUDIO = 0;
  SceneComponentConstants2.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;
  SceneComponentConstants2.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;
  SceneComponentConstants2.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;
  SceneComponentConstants2.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;
  SceneComponentConstants2.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;
  SceneComponentConstants2.STEP_BEFORECLEARSTAGE_PREPASS = 0;
  SceneComponentConstants2.STEP_BEFORERENDERTARGETCLEARSTAGE_PREPASS = 0;
  SceneComponentConstants2.STEP_POINTERMOVE_SPRITE = 0;
  SceneComponentConstants2.STEP_POINTERDOWN_SPRITE = 0;
  SceneComponentConstants2.STEP_POINTERUP_SPRITE = 0;
  return SceneComponentConstants2;
}();
var Stage = function(_super) {
  __extends(Stage2, _super);
  function Stage2(items) {
    return _super.apply(this, items) || this;
  }
  Stage2.Create = function() {
    return Object.create(Stage2.prototype);
  };
  Stage2.prototype.registerStep = function(index, component, action) {
    var i = 0;
    var maxIndex = Number.MAX_VALUE;
    for (; i < this.length; i++) {
      var step = this[i];
      maxIndex = step.index;
      if (index < maxIndex) {
        break;
      }
    }
    this.splice(i, 0, { index, component, action: action.bind(component) });
  };
  Stage2.prototype.clear = function() {
    this.length = 0;
  };
  return Stage2;
}(Array);
var PointerEventTypes = function() {
  function PointerEventTypes2() {
  }
  PointerEventTypes2.POINTERDOWN = 1;
  PointerEventTypes2.POINTERUP = 2;
  PointerEventTypes2.POINTERMOVE = 4;
  PointerEventTypes2.POINTERWHEEL = 8;
  PointerEventTypes2.POINTERPICK = 16;
  PointerEventTypes2.POINTERTAP = 32;
  PointerEventTypes2.POINTERDOUBLETAP = 64;
  return PointerEventTypes2;
}();
var PointerInfoBase = function() {
  function PointerInfoBase2(type, event) {
    this.type = type;
    this.event = event;
  }
  return PointerInfoBase2;
}();
var PointerInfoPre = function(_super) {
  __extends(PointerInfoPre2, _super);
  function PointerInfoPre2(type, event, localX, localY) {
    var _this = _super.call(this, type, event) || this;
    _this.ray = null;
    _this.skipOnPointerObservable = false;
    _this.localPosition = new Vector2(localX, localY);
    return _this;
  }
  return PointerInfoPre2;
}(PointerInfoBase);
var PointerInfo = function(_super) {
  __extends(PointerInfo2, _super);
  function PointerInfo2(type, event, pickInfo) {
    var _this = _super.call(this, type, event) || this;
    _this.pickInfo = pickInfo;
    return _this;
  }
  return PointerInfo2;
}(PointerInfoBase);
var AbstractActionManager = function() {
  function AbstractActionManager2() {
    this.hoverCursor = "";
    this.actions = new Array();
    this.isRecursive = false;
  }
  Object.defineProperty(AbstractActionManager2, "HasTriggers", {
    get: function() {
      for (var t in AbstractActionManager2.Triggers) {
        if (AbstractActionManager2.Triggers.hasOwnProperty(t)) {
          return true;
        }
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractActionManager2, "HasPickTriggers", {
    get: function() {
      for (var t in AbstractActionManager2.Triggers) {
        if (AbstractActionManager2.Triggers.hasOwnProperty(t)) {
          var t_int = parseInt(t);
          if (t_int >= 1 && t_int <= 7) {
            return true;
          }
        }
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  AbstractActionManager2.HasSpecificTrigger = function(trigger) {
    for (var t in AbstractActionManager2.Triggers) {
      if (AbstractActionManager2.Triggers.hasOwnProperty(t)) {
        var t_int = parseInt(t);
        if (t_int === trigger) {
          return true;
        }
      }
    }
    return false;
  };
  AbstractActionManager2.Triggers = {};
  return AbstractActionManager2;
}();
var KeyboardEventTypes = function() {
  function KeyboardEventTypes2() {
  }
  KeyboardEventTypes2.KEYDOWN = 1;
  KeyboardEventTypes2.KEYUP = 2;
  return KeyboardEventTypes2;
}();
var KeyboardInfo = function() {
  function KeyboardInfo2(type, event) {
    this.type = type;
    this.event = event;
  }
  return KeyboardInfo2;
}();
var KeyboardInfoPre = function(_super) {
  __extends(KeyboardInfoPre2, _super);
  function KeyboardInfoPre2(type, event) {
    var _this = _super.call(this, type, event) || this;
    _this.type = type;
    _this.event = event;
    _this.skipOnKeyboardObservable = false;
    return _this;
  }
  Object.defineProperty(KeyboardInfoPre2.prototype, "skipOnPointerObservable", {
    get: function() {
      return this.skipOnKeyboardObservable;
    },
    set: function(value) {
      this.skipOnKeyboardObservable = value;
    },
    enumerable: false,
    configurable: true
  });
  return KeyboardInfoPre2;
}(KeyboardInfo);
var DeviceType;
(function(DeviceType2) {
  DeviceType2[DeviceType2["Generic"] = 0] = "Generic";
  DeviceType2[DeviceType2["Keyboard"] = 1] = "Keyboard";
  DeviceType2[DeviceType2["Mouse"] = 2] = "Mouse";
  DeviceType2[DeviceType2["Touch"] = 3] = "Touch";
  DeviceType2[DeviceType2["DualShock"] = 4] = "DualShock";
  DeviceType2[DeviceType2["Xbox"] = 5] = "Xbox";
  DeviceType2[DeviceType2["Switch"] = 6] = "Switch";
  DeviceType2[DeviceType2["DualSense"] = 7] = "DualSense";
})(DeviceType || (DeviceType = {}));
var PointerInput;
(function(PointerInput2) {
  PointerInput2[PointerInput2["Horizontal"] = 0] = "Horizontal";
  PointerInput2[PointerInput2["Vertical"] = 1] = "Vertical";
  PointerInput2[PointerInput2["LeftClick"] = 2] = "LeftClick";
  PointerInput2[PointerInput2["MiddleClick"] = 3] = "MiddleClick";
  PointerInput2[PointerInput2["RightClick"] = 4] = "RightClick";
  PointerInput2[PointerInput2["BrowserBack"] = 5] = "BrowserBack";
  PointerInput2[PointerInput2["BrowserForward"] = 6] = "BrowserForward";
  PointerInput2[PointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
  PointerInput2[PointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
  PointerInput2[PointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
  PointerInput2[PointerInput2["Move"] = 12] = "Move";
})(PointerInput || (PointerInput = {}));
var NativePointerInput;
(function(NativePointerInput2) {
  NativePointerInput2[NativePointerInput2["Horizontal"] = 0] = "Horizontal";
  NativePointerInput2[NativePointerInput2["Vertical"] = 1] = "Vertical";
  NativePointerInput2[NativePointerInput2["LeftClick"] = 2] = "LeftClick";
  NativePointerInput2[NativePointerInput2["MiddleClick"] = 3] = "MiddleClick";
  NativePointerInput2[NativePointerInput2["RightClick"] = 4] = "RightClick";
  NativePointerInput2[NativePointerInput2["BrowserBack"] = 5] = "BrowserBack";
  NativePointerInput2[NativePointerInput2["BrowserForward"] = 6] = "BrowserForward";
  NativePointerInput2[NativePointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
  NativePointerInput2[NativePointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
  NativePointerInput2[NativePointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
  NativePointerInput2[NativePointerInput2["DeltaHorizontal"] = 10] = "DeltaHorizontal";
  NativePointerInput2[NativePointerInput2["DeltaVertical"] = 11] = "DeltaVertical";
})(NativePointerInput || (NativePointerInput = {}));
var DualShockInput;
(function(DualShockInput2) {
  DualShockInput2[DualShockInput2["Cross"] = 0] = "Cross";
  DualShockInput2[DualShockInput2["Circle"] = 1] = "Circle";
  DualShockInput2[DualShockInput2["Square"] = 2] = "Square";
  DualShockInput2[DualShockInput2["Triangle"] = 3] = "Triangle";
  DualShockInput2[DualShockInput2["L1"] = 4] = "L1";
  DualShockInput2[DualShockInput2["R1"] = 5] = "R1";
  DualShockInput2[DualShockInput2["L2"] = 6] = "L2";
  DualShockInput2[DualShockInput2["R2"] = 7] = "R2";
  DualShockInput2[DualShockInput2["Share"] = 8] = "Share";
  DualShockInput2[DualShockInput2["Options"] = 9] = "Options";
  DualShockInput2[DualShockInput2["L3"] = 10] = "L3";
  DualShockInput2[DualShockInput2["R3"] = 11] = "R3";
  DualShockInput2[DualShockInput2["DPadUp"] = 12] = "DPadUp";
  DualShockInput2[DualShockInput2["DPadDown"] = 13] = "DPadDown";
  DualShockInput2[DualShockInput2["DPadLeft"] = 14] = "DPadLeft";
  DualShockInput2[DualShockInput2["DPadRight"] = 15] = "DPadRight";
  DualShockInput2[DualShockInput2["Home"] = 16] = "Home";
  DualShockInput2[DualShockInput2["TouchPad"] = 17] = "TouchPad";
  DualShockInput2[DualShockInput2["LStickXAxis"] = 18] = "LStickXAxis";
  DualShockInput2[DualShockInput2["LStickYAxis"] = 19] = "LStickYAxis";
  DualShockInput2[DualShockInput2["RStickXAxis"] = 20] = "RStickXAxis";
  DualShockInput2[DualShockInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(DualShockInput || (DualShockInput = {}));
var DualSenseInput;
(function(DualSenseInput2) {
  DualSenseInput2[DualSenseInput2["Cross"] = 0] = "Cross";
  DualSenseInput2[DualSenseInput2["Circle"] = 1] = "Circle";
  DualSenseInput2[DualSenseInput2["Square"] = 2] = "Square";
  DualSenseInput2[DualSenseInput2["Triangle"] = 3] = "Triangle";
  DualSenseInput2[DualSenseInput2["L1"] = 4] = "L1";
  DualSenseInput2[DualSenseInput2["R1"] = 5] = "R1";
  DualSenseInput2[DualSenseInput2["L2"] = 6] = "L2";
  DualSenseInput2[DualSenseInput2["R2"] = 7] = "R2";
  DualSenseInput2[DualSenseInput2["Create"] = 8] = "Create";
  DualSenseInput2[DualSenseInput2["Options"] = 9] = "Options";
  DualSenseInput2[DualSenseInput2["L3"] = 10] = "L3";
  DualSenseInput2[DualSenseInput2["R3"] = 11] = "R3";
  DualSenseInput2[DualSenseInput2["DPadUp"] = 12] = "DPadUp";
  DualSenseInput2[DualSenseInput2["DPadDown"] = 13] = "DPadDown";
  DualSenseInput2[DualSenseInput2["DPadLeft"] = 14] = "DPadLeft";
  DualSenseInput2[DualSenseInput2["DPadRight"] = 15] = "DPadRight";
  DualSenseInput2[DualSenseInput2["Home"] = 16] = "Home";
  DualSenseInput2[DualSenseInput2["TouchPad"] = 17] = "TouchPad";
  DualSenseInput2[DualSenseInput2["LStickXAxis"] = 18] = "LStickXAxis";
  DualSenseInput2[DualSenseInput2["LStickYAxis"] = 19] = "LStickYAxis";
  DualSenseInput2[DualSenseInput2["RStickXAxis"] = 20] = "RStickXAxis";
  DualSenseInput2[DualSenseInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(DualSenseInput || (DualSenseInput = {}));
var XboxInput;
(function(XboxInput2) {
  XboxInput2[XboxInput2["A"] = 0] = "A";
  XboxInput2[XboxInput2["B"] = 1] = "B";
  XboxInput2[XboxInput2["X"] = 2] = "X";
  XboxInput2[XboxInput2["Y"] = 3] = "Y";
  XboxInput2[XboxInput2["LB"] = 4] = "LB";
  XboxInput2[XboxInput2["RB"] = 5] = "RB";
  XboxInput2[XboxInput2["LT"] = 6] = "LT";
  XboxInput2[XboxInput2["RT"] = 7] = "RT";
  XboxInput2[XboxInput2["Back"] = 8] = "Back";
  XboxInput2[XboxInput2["Start"] = 9] = "Start";
  XboxInput2[XboxInput2["LS"] = 10] = "LS";
  XboxInput2[XboxInput2["RS"] = 11] = "RS";
  XboxInput2[XboxInput2["DPadUp"] = 12] = "DPadUp";
  XboxInput2[XboxInput2["DPadDown"] = 13] = "DPadDown";
  XboxInput2[XboxInput2["DPadLeft"] = 14] = "DPadLeft";
  XboxInput2[XboxInput2["DPadRight"] = 15] = "DPadRight";
  XboxInput2[XboxInput2["Home"] = 16] = "Home";
  XboxInput2[XboxInput2["LStickXAxis"] = 17] = "LStickXAxis";
  XboxInput2[XboxInput2["LStickYAxis"] = 18] = "LStickYAxis";
  XboxInput2[XboxInput2["RStickXAxis"] = 19] = "RStickXAxis";
  XboxInput2[XboxInput2["RStickYAxis"] = 20] = "RStickYAxis";
})(XboxInput || (XboxInput = {}));
var SwitchInput;
(function(SwitchInput2) {
  SwitchInput2[SwitchInput2["B"] = 0] = "B";
  SwitchInput2[SwitchInput2["A"] = 1] = "A";
  SwitchInput2[SwitchInput2["Y"] = 2] = "Y";
  SwitchInput2[SwitchInput2["X"] = 3] = "X";
  SwitchInput2[SwitchInput2["L"] = 4] = "L";
  SwitchInput2[SwitchInput2["R"] = 5] = "R";
  SwitchInput2[SwitchInput2["ZL"] = 6] = "ZL";
  SwitchInput2[SwitchInput2["ZR"] = 7] = "ZR";
  SwitchInput2[SwitchInput2["Minus"] = 8] = "Minus";
  SwitchInput2[SwitchInput2["Plus"] = 9] = "Plus";
  SwitchInput2[SwitchInput2["LS"] = 10] = "LS";
  SwitchInput2[SwitchInput2["RS"] = 11] = "RS";
  SwitchInput2[SwitchInput2["DPadUp"] = 12] = "DPadUp";
  SwitchInput2[SwitchInput2["DPadDown"] = 13] = "DPadDown";
  SwitchInput2[SwitchInput2["DPadLeft"] = 14] = "DPadLeft";
  SwitchInput2[SwitchInput2["DPadRight"] = 15] = "DPadRight";
  SwitchInput2[SwitchInput2["Home"] = 16] = "Home";
  SwitchInput2[SwitchInput2["Capture"] = 17] = "Capture";
  SwitchInput2[SwitchInput2["LStickXAxis"] = 18] = "LStickXAxis";
  SwitchInput2[SwitchInput2["LStickYAxis"] = 19] = "LStickYAxis";
  SwitchInput2[SwitchInput2["RStickXAxis"] = 20] = "RStickXAxis";
  SwitchInput2[SwitchInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(SwitchInput || (SwitchInput = {}));
var DeviceInputEventType;
(function(DeviceInputEventType2) {
  DeviceInputEventType2[DeviceInputEventType2["PointerMove"] = 0] = "PointerMove";
  DeviceInputEventType2[DeviceInputEventType2["PointerDown"] = 1] = "PointerDown";
  DeviceInputEventType2[DeviceInputEventType2["PointerUp"] = 2] = "PointerUp";
})(DeviceInputEventType || (DeviceInputEventType = {}));
var EventConstants = function() {
  function EventConstants2() {
  }
  EventConstants2.DOM_DELTA_PIXEL = 0;
  EventConstants2.DOM_DELTA_LINE = 1;
  EventConstants2.DOM_DELTA_PAGE = 2;
  return EventConstants2;
}();
var DeviceEventFactory = function() {
  function DeviceEventFactory2() {
  }
  DeviceEventFactory2.CreateDeviceEvent = function(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    switch (deviceType) {
      case DeviceType.Keyboard:
        return this._createKeyboardEvent(inputIndex, currentState, deviceInputSystem, elementToAttachTo);
      case DeviceType.Mouse:
        if (inputIndex === PointerInput.MouseWheelX || inputIndex === PointerInput.MouseWheelY || inputIndex === PointerInput.MouseWheelZ) {
          return this._createWheelEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
        }
      case DeviceType.Touch:
        return this._createPointerEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
      default:
        throw "Unable to generate event for device ".concat(DeviceType[deviceType]);
    }
  };
  DeviceEventFactory2._createPointerEvent = function(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    var evt = this._createMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
    if (deviceType === DeviceType.Mouse) {
      evt.deviceType = DeviceType.Mouse;
      evt.pointerId = 1;
      evt.pointerType = "mouse";
    } else {
      evt.deviceType = DeviceType.Touch;
      evt.pointerId = deviceSlot;
      evt.pointerType = "touch";
    }
    if (inputIndex === PointerInput.Move) {
      evt.type = "pointermove";
    } else if (inputIndex >= PointerInput.LeftClick && inputIndex <= PointerInput.RightClick) {
      evt.type = currentState === 1 ? "pointerdown" : "pointerup";
      evt.button = inputIndex - 2;
    }
    return evt;
  };
  DeviceEventFactory2._createWheelEvent = function(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    var evt = this._createMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
    evt.type = "wheel";
    evt.deltaMode = EventConstants.DOM_DELTA_PIXEL;
    evt.deltaX = inputIndex === PointerInput.MouseWheelX ? currentState : deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.MouseWheelX);
    evt.deltaY = inputIndex === PointerInput.MouseWheelY ? currentState : deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.MouseWheelY);
    evt.deltaZ = inputIndex === PointerInput.MouseWheelZ ? currentState : deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.MouseWheelZ);
    return evt;
  };
  DeviceEventFactory2._createMouseEvent = function(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    var evt = this._createEvent(elementToAttachTo);
    var pointerX = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Horizontal);
    var pointerY = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Vertical);
    if (elementToAttachTo) {
      evt.movementX = 0;
      evt.movementY = 0;
      evt.offsetX = evt.movementX - elementToAttachTo.getBoundingClientRect().x;
      evt.offsetY = evt.movementY - elementToAttachTo.getBoundingClientRect().y;
    } else {
      evt.movementX = deviceInputSystem.pollInput(deviceType, deviceSlot, NativePointerInput.DeltaHorizontal);
      evt.movementY = deviceInputSystem.pollInput(deviceType, deviceSlot, NativePointerInput.DeltaVertical);
      evt.offsetX = 0;
      evt.offsetY = 0;
    }
    this._checkNonCharacterKeys(evt, deviceInputSystem);
    evt.clientX = pointerX;
    evt.clientY = pointerY;
    evt.x = pointerX;
    evt.y = pointerY;
    evt.deviceType = deviceType;
    evt.deviceSlot = deviceSlot;
    evt.inputIndex = inputIndex;
    return evt;
  };
  DeviceEventFactory2._createKeyboardEvent = function(inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    var evt = this._createEvent(elementToAttachTo);
    this._checkNonCharacterKeys(evt, deviceInputSystem);
    evt.deviceType = DeviceType.Keyboard;
    evt.deviceSlot = 0;
    evt.inputIndex = inputIndex;
    evt.type = currentState === 1 ? "keydown" : "keyup";
    evt.key = String.fromCharCode(inputIndex);
    evt.keyCode = inputIndex;
    return evt;
  };
  DeviceEventFactory2._checkNonCharacterKeys = function(evt, deviceInputSystem) {
    var isKeyboardActive = deviceInputSystem.isDeviceAvailable(DeviceType.Keyboard);
    var altKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 18) === 1;
    var ctrlKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 17) === 1;
    var metaKey = isKeyboardActive && (deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 91) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 92) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 93) === 1);
    var shiftKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 16) === 1;
    evt.altKey = altKey;
    evt.ctrlKey = ctrlKey;
    evt.metaKey = metaKey;
    evt.shiftKey = shiftKey;
  };
  DeviceEventFactory2._createEvent = function(elementToAttachTo) {
    var evt = {};
    evt.preventDefault = function() {
    };
    evt.target = elementToAttachTo;
    return evt;
  };
  return DeviceEventFactory2;
}();
var NativeDeviceInputSystem = function() {
  function NativeDeviceInputSystem2(nativeInput) {
    var _this = this;
    this.onDeviceConnected = function(deviceType, deviceSlot) {
    };
    this.onDeviceDisconnected = function(deviceType, deviceSlot) {
    };
    this.onInputChanged = function(deviceType, deviceSlot, eventData) {
    };
    this._nativeInput = nativeInput || this._createDummyNativeInput();
    this._nativeInput.onDeviceConnected = function(deviceType, deviceSlot) {
      _this.onDeviceConnected(deviceType, deviceSlot);
    };
    this._nativeInput.onDeviceDisconnected = function(deviceType, deviceSlot) {
      _this.onDeviceDisconnected(deviceType, deviceSlot);
    };
    this._nativeInput.onInputChanged = function(deviceType, deviceSlot, inputIndex, currentState) {
      var idx = inputIndex === NativePointerInput.Horizontal || inputIndex === NativePointerInput.Vertical || inputIndex === NativePointerInput.DeltaHorizontal || inputIndex === NativePointerInput.DeltaVertical ? PointerInput.Move : inputIndex;
      var evt = DeviceEventFactory.CreateDeviceEvent(deviceType, deviceSlot, idx, currentState, _this);
      _this.onInputChanged(deviceType, deviceSlot, evt);
    };
  }
  NativeDeviceInputSystem2.prototype.pollInput = function(deviceType, deviceSlot, inputIndex) {
    return this._nativeInput.pollInput(deviceType, deviceSlot, inputIndex);
  };
  NativeDeviceInputSystem2.prototype.isDeviceAvailable = function(deviceType) {
    return deviceType === DeviceType.Mouse || deviceType === DeviceType.Touch;
  };
  NativeDeviceInputSystem2.prototype.dispose = function() {
    this.onDeviceConnected = function() {
    };
    this.onDeviceDisconnected = function() {
    };
    this.onInputChanged = function() {
    };
  };
  NativeDeviceInputSystem2.prototype._createDummyNativeInput = function() {
    var nativeInput = {
      onDeviceConnected: function(deviceType, deviceSlot) {
      },
      onDeviceDisconnected: function(deviceType, deviceSlot) {
      },
      onInputChanged: function(deviceType, deviceSlot, inputIndex, currentState) {
      },
      pollInput: function() {
        return 0;
      },
      isDeviceAvailable: function() {
        return false;
      },
      dispose: function() {
      }
    };
    return nativeInput;
  };
  return NativeDeviceInputSystem2;
}();
var MAX_KEYCODES = 255;
var MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;
var WebDeviceInputSystem = function() {
  function WebDeviceInputSystem2(engine) {
    var _this = this;
    this._inputs = [];
    this._keyboardActive = false;
    this._pointerActive = false;
    this._usingSafari = Tools.IsSafari();
    this._keyboardDownEvent = function(evt) {
    };
    this._keyboardUpEvent = function(evt) {
    };
    this._keyboardBlurEvent = function(evt) {
    };
    this._pointerMoveEvent = function(evt) {
    };
    this._pointerDownEvent = function(evt) {
    };
    this._pointerUpEvent = function(evt) {
    };
    this._pointerCancelEvent = function(evt) {
    };
    this._pointerWheelEvent = function(evt) {
    };
    this._pointerBlurEvent = function(evt) {
    };
    this._eventsAttached = false;
    this._mouseId = -1;
    this._isUsingFirefox = DomManagement.IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1;
    this._maxTouchPoints = 0;
    this._pointerInputClearObserver = null;
    this._gamepadConnectedEvent = function(evt) {
    };
    this._gamepadDisconnectedEvent = function(evt) {
    };
    this._eventPrefix = Tools.GetPointerPrefix(engine);
    this._engine = engine;
    this.onDeviceConnected = function(deviceType, deviceSlot) {
    };
    this.onDeviceDisconnected = function(deviceType, deviceSlot) {
    };
    this.onInputChanged = function(deviceType, deviceSlot, eventData) {
    };
    this._enableEvents();
    if (!this._engine._onEngineViewChanged) {
      this._engine._onEngineViewChanged = function() {
        _this._enableEvents();
      };
    }
  }
  Object.defineProperty(WebDeviceInputSystem2.prototype, "onDeviceConnected", {
    get: function() {
      return this._onDeviceConnected;
    },
    set: function(callback) {
      this._onDeviceConnected = callback;
      for (var deviceType = 0; deviceType < this._inputs.length; deviceType++) {
        var inputs = this._inputs[deviceType];
        if (inputs) {
          for (var deviceSlotKey in inputs) {
            var deviceSlot = +deviceSlotKey;
            if (this._inputs[deviceType][deviceSlot]) {
              this._onDeviceConnected(deviceType, deviceSlot);
            }
          }
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  WebDeviceInputSystem2.prototype.pollInput = function(deviceType, deviceSlot, inputIndex) {
    var device = this._inputs[deviceType][deviceSlot];
    if (!device) {
      throw "Unable to find device ".concat(DeviceType[deviceType]);
    }
    if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense && navigator.getGamepads) {
      this._updateDevice(deviceType, deviceSlot, inputIndex);
    }
    var currentValue = device[inputIndex];
    if (currentValue === void 0) {
      throw "Unable to find input ".concat(inputIndex, " for device ").concat(DeviceType[deviceType], " in slot ").concat(deviceSlot);
    }
    if (inputIndex === PointerInput.Move) {
      Tools.Warn("Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.");
    }
    return currentValue;
  };
  WebDeviceInputSystem2.prototype.isDeviceAvailable = function(deviceType) {
    return this._inputs[deviceType] !== void 0;
  };
  WebDeviceInputSystem2.prototype.dispose = function() {
    this.onDeviceConnected = function() {
    };
    this.onDeviceDisconnected = function() {
    };
    this.onInputChanged = function() {
    };
    delete this._engine._onEngineViewChanged;
    if (this._elementToAttachTo) {
      this._disableEvents();
    }
  };
  WebDeviceInputSystem2.prototype._enableEvents = function() {
    var inputElement = this === null || this === void 0 ? void 0 : this._engine.getInputElement();
    if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {
      this._disableEvents();
      if (this._inputs) {
        for (var _i = 0, _a = this._inputs; _i < _a.length; _i++) {
          var inputs = _a[_i];
          if (inputs) {
            for (var deviceSlotKey in inputs) {
              var deviceSlot = +deviceSlotKey;
              var device = inputs[deviceSlot];
              if (device) {
                for (var inputIndex = 0; inputIndex < device.length; inputIndex++) {
                  device[inputIndex] = 0;
                }
              }
            }
          }
        }
      }
      this._elementToAttachTo = inputElement;
      this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;
      this._handleKeyActions();
      this._handlePointerActions();
      this._handleGamepadActions();
      this._eventsAttached = true;
      this._checkForConnectedDevices();
    }
  };
  WebDeviceInputSystem2.prototype._disableEvents = function() {
    if (this._elementToAttachTo) {
      this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent);
      this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent);
      this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent);
      this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
      this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);
      window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent);
      window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
    }
    if (this._pointerInputClearObserver) {
      this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);
    }
    this._eventsAttached = false;
  };
  WebDeviceInputSystem2.prototype._checkForConnectedDevices = function() {
    if (navigator.getGamepads) {
      var gamepads = navigator.getGamepads();
      for (var _i = 0, gamepads_1 = gamepads; _i < gamepads_1.length; _i++) {
        var gamepad = gamepads_1[_i];
        if (gamepad) {
          this._addGamePad(gamepad);
        }
      }
    }
    if (matchMedia("(pointer:fine)").matches) {
      this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);
    }
  };
  WebDeviceInputSystem2.prototype._addGamePad = function(gamepad) {
    var deviceType = this._getGamepadDeviceType(gamepad.id);
    var deviceSlot = gamepad.index;
    this._gamepads = this._gamepads || new Array(gamepad.index + 1);
    this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);
    this._gamepads[deviceSlot] = deviceType;
  };
  WebDeviceInputSystem2.prototype._addPointerDevice = function(deviceType, deviceSlot, currentX, currentY) {
    if (!this._pointerActive) {
      this._pointerActive = true;
    }
    this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
    var pointer = this._inputs[deviceType][deviceSlot];
    pointer[0] = currentX;
    pointer[1] = currentY;
  };
  WebDeviceInputSystem2.prototype._registerDevice = function(deviceType, deviceSlot, numberOfInputs) {
    if (deviceSlot === void 0) {
      throw "Unable to register device ".concat(DeviceType[deviceType], " to undefined slot.");
    }
    if (!this._inputs[deviceType]) {
      this._inputs[deviceType] = {};
    }
    if (!this._inputs[deviceType][deviceSlot]) {
      var device = new Array(numberOfInputs);
      for (var i = 0; i < numberOfInputs; i++) {
        device[i] = 0;
      }
      this._inputs[deviceType][deviceSlot] = device;
      this.onDeviceConnected(deviceType, deviceSlot);
    }
  };
  WebDeviceInputSystem2.prototype._unregisterDevice = function(deviceType, deviceSlot) {
    if (this._inputs[deviceType][deviceSlot]) {
      delete this._inputs[deviceType][deviceSlot];
      this.onDeviceDisconnected(deviceType, deviceSlot);
    }
  };
  WebDeviceInputSystem2.prototype._handleKeyActions = function() {
    var _this = this;
    this._keyboardDownEvent = function(evt) {
      if (!_this._keyboardActive) {
        _this._keyboardActive = true;
        _this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
      }
      var kbKey = _this._inputs[DeviceType.Keyboard][0];
      if (kbKey) {
        kbKey[evt.keyCode] = 1;
        var deviceEvent = evt;
        deviceEvent.inputIndex = evt.keyCode;
        _this.onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
      }
    };
    this._keyboardUpEvent = function(evt) {
      if (!_this._keyboardActive) {
        _this._keyboardActive = true;
        _this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
      }
      var kbKey = _this._inputs[DeviceType.Keyboard][0];
      if (kbKey) {
        kbKey[evt.keyCode] = 0;
        var deviceEvent = evt;
        deviceEvent.inputIndex = evt.keyCode;
        _this.onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
      }
    };
    this._keyboardBlurEvent = function(evt) {
      if (_this._keyboardActive) {
        var kbKey = _this._inputs[DeviceType.Keyboard][0];
        for (var i = 0; i < kbKey.length; i++) {
          if (kbKey[i] !== 0) {
            kbKey[i] = 0;
            var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, _this, _this._elementToAttachTo);
            _this.onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
          }
        }
      }
    };
    this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent);
    this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent);
    this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent);
  };
  WebDeviceInputSystem2.prototype._handlePointerActions = function() {
    var _this = this;
    this._maxTouchPoints = DomManagement.IsNavigatorAvailable() && navigator.maxTouchPoints || 2;
    if (!this._activeTouchIds) {
      this._activeTouchIds = new Array(this._maxTouchPoints);
    }
    for (var i = 0; i < this._maxTouchPoints; i++) {
      this._activeTouchIds[i] = -1;
    }
    this._pointerMoveEvent = function(evt) {
      var deviceType = _this._getPointerType(evt);
      var deviceSlot = deviceType === DeviceType.Mouse ? 0 : _this._activeTouchIds.indexOf(evt.pointerId);
      if (!_this._inputs[deviceType]) {
        _this._inputs[deviceType] = {};
      }
      if (!_this._inputs[deviceType][deviceSlot]) {
        _this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
      }
      var pointer = _this._inputs[deviceType][deviceSlot];
      if (pointer) {
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        var deviceEvent = evt;
        deviceEvent.inputIndex = PointerInput.Move;
        _this.onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (!_this._usingSafari && evt.button !== -1) {
          deviceEvent.inputIndex = evt.button + 2;
          pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1;
          _this.onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    this._pointerDownEvent = function(evt) {
      var deviceType = _this._getPointerType(evt);
      var deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;
      if (deviceType === DeviceType.Touch) {
        var idx = _this._activeTouchIds.indexOf(-1);
        if (idx >= 0) {
          deviceSlot = idx;
          _this._activeTouchIds[idx] = evt.pointerId;
        } else {
          Tools.Warn("Max number of touches exceeded.  Ignoring touches in excess of ".concat(_this._maxTouchPoints));
          return;
        }
      }
      if (!_this._inputs[deviceType]) {
        _this._inputs[deviceType] = {};
      }
      if (!_this._inputs[deviceType][deviceSlot]) {
        _this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
      } else if (deviceType === DeviceType.Touch) {
        _this.onDeviceConnected(deviceType, deviceSlot);
      }
      var pointer = _this._inputs[deviceType][deviceSlot];
      if (pointer) {
        var previousHorizontal = pointer[PointerInput.Horizontal];
        var previousVertical = pointer[PointerInput.Vertical];
        if (deviceType === DeviceType.Mouse) {
          if (_this._mouseId === -1) {
            if (evt.pointerId === void 0) {
              _this._mouseId = _this._isUsingFirefox ? 0 : 1;
            } else {
              _this._mouseId = evt.pointerId;
            }
          }
          if (!document.pointerLockElement && _this._elementToAttachTo.hasPointerCapture) {
            try {
              _this._elementToAttachTo.setPointerCapture(_this._mouseId);
            } catch (e) {
            }
          }
        } else {
          if (evt.pointerId && !document.pointerLockElement && _this._elementToAttachTo.hasPointerCapture) {
            try {
              _this._elementToAttachTo.setPointerCapture(evt.pointerId);
            } catch (e) {
            }
          }
        }
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        pointer[evt.button + 2] = 1;
        var deviceEvent = evt;
        deviceEvent.inputIndex = evt.button + 2;
        _this.onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = PointerInput.Move;
          _this.onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    this._pointerUpEvent = function(evt) {
      var _a, _b, _c, _d, _e;
      var deviceType = _this._getPointerType(evt);
      var deviceSlot = deviceType === DeviceType.Mouse ? 0 : _this._activeTouchIds.indexOf(evt.pointerId);
      if (deviceType === DeviceType.Touch) {
        if (deviceSlot === -1) {
          return;
        } else {
          _this._activeTouchIds[deviceSlot] = -1;
        }
      }
      var pointer = (_a = _this._inputs[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot];
      if (pointer && pointer[evt.button + 2] !== 0) {
        var previousHorizontal = pointer[PointerInput.Horizontal];
        var previousVertical = pointer[PointerInput.Vertical];
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        pointer[evt.button + 2] = 0;
        var deviceEvent = evt;
        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = PointerInput.Move;
          _this.onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        deviceEvent.inputIndex = evt.button + 2;
        if (deviceType === DeviceType.Mouse && _this._mouseId >= 0 && ((_c = (_b = _this._elementToAttachTo).hasPointerCapture) === null || _c === void 0 ? void 0 : _c.call(_b, _this._mouseId))) {
          _this._elementToAttachTo.releasePointerCapture(_this._mouseId);
        } else if (evt.pointerId && ((_e = (_d = _this._elementToAttachTo).hasPointerCapture) === null || _e === void 0 ? void 0 : _e.call(_d, evt.pointerId))) {
          _this._elementToAttachTo.releasePointerCapture(evt.pointerId);
        }
        _this.onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (deviceType === DeviceType.Touch) {
          _this.onDeviceDisconnected(deviceType, deviceSlot);
        }
      }
    };
    this._pointerCancelEvent = function(evt) {
      var _a, _b, _c, _d;
      if (evt.pointerType === "mouse") {
        var pointer = _this._inputs[DeviceType.Mouse][0];
        if (_this._mouseId >= 0 && ((_b = (_a = _this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, _this._mouseId))) {
          _this._elementToAttachTo.releasePointerCapture(_this._mouseId);
        }
        for (var inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
          if (pointer[inputIndex] === 1) {
            pointer[inputIndex] = 0;
            var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, _this, _this._elementToAttachTo);
            _this.onInputChanged(DeviceType.Mouse, 0, deviceEvent);
          }
        }
      } else {
        var deviceSlot = _this._activeTouchIds.indexOf(evt.pointerId);
        if ((_d = (_c = _this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, evt.pointerId)) {
          _this._elementToAttachTo.releasePointerCapture(evt.pointerId);
        }
        _this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;
        var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, _this, _this._elementToAttachTo);
        _this.onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
        _this._activeTouchIds[deviceSlot] = -1;
        _this.onDeviceDisconnected(DeviceType.Touch, deviceSlot);
      }
    };
    this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
    var passiveSupported = false;
    var noop = function() {
    };
    try {
      var options = {
        passive: {
          get: function() {
            passiveSupported = true;
          }
        }
      };
      this._elementToAttachTo.addEventListener("test", noop, options);
      this._elementToAttachTo.removeEventListener("test", noop, options);
    } catch (e) {
    }
    this._pointerBlurEvent = function(evt) {
      var _a, _b, _c, _d, _e;
      if (_this.isDeviceAvailable(DeviceType.Mouse)) {
        var pointer = _this._inputs[DeviceType.Mouse][0];
        if (_this._mouseId >= 0 && ((_b = (_a = _this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, _this._mouseId))) {
          _this._elementToAttachTo.releasePointerCapture(_this._mouseId);
        }
        for (var inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
          if (pointer[inputIndex] === 1) {
            pointer[inputIndex] = 0;
            var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, _this, _this._elementToAttachTo);
            _this.onInputChanged(DeviceType.Mouse, 0, deviceEvent);
          }
        }
      }
      if (_this.isDeviceAvailable(DeviceType.Touch)) {
        var pointer = _this._inputs[DeviceType.Touch];
        for (var deviceSlot = 0; deviceSlot < _this._activeTouchIds.length; deviceSlot++) {
          var pointerId = _this._activeTouchIds[deviceSlot];
          if ((_d = (_c = _this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, pointerId)) {
            _this._elementToAttachTo.releasePointerCapture(pointerId);
          }
          if (pointerId !== -1 && ((_e = pointer[deviceSlot]) === null || _e === void 0 ? void 0 : _e[PointerInput.LeftClick]) === 1) {
            pointer[deviceSlot][PointerInput.LeftClick] = 0;
            var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, _this, _this._elementToAttachTo);
            _this.onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
            _this._activeTouchIds[deviceSlot] = -1;
            _this.onDeviceDisconnected(DeviceType.Touch, deviceSlot);
          }
        }
      }
    };
    this._pointerWheelEvent = function(evt) {
      var deviceType = DeviceType.Mouse;
      var deviceSlot = 0;
      if (!_this._inputs[deviceType]) {
        _this._inputs[deviceType] = [];
      }
      if (!_this._inputs[deviceType][deviceSlot]) {
        _this._pointerActive = true;
        _this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
      }
      var pointer = _this._inputs[deviceType][deviceSlot];
      if (pointer) {
        pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;
        pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;
        pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;
        var deviceEvent = evt;
        if (pointer[PointerInput.MouseWheelX] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelX;
          _this.onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        if (pointer[PointerInput.MouseWheelY] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelY;
          _this.onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        if (pointer[PointerInput.MouseWheelZ] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelZ;
          _this.onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
    this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent);
    this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? { passive: false } : false);
    this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(function() {
      if (_this.isDeviceAvailable(DeviceType.Mouse)) {
        var pointer = _this._inputs[DeviceType.Mouse][0];
        pointer[PointerInput.MouseWheelX] = 0;
        pointer[PointerInput.MouseWheelY] = 0;
        pointer[PointerInput.MouseWheelZ] = 0;
      }
    });
  };
  WebDeviceInputSystem2.prototype._handleGamepadActions = function() {
    var _this = this;
    this._gamepadConnectedEvent = function(evt) {
      _this._addGamePad(evt.gamepad);
    };
    this._gamepadDisconnectedEvent = function(evt) {
      if (_this._gamepads) {
        var deviceType = _this._getGamepadDeviceType(evt.gamepad.id);
        var deviceSlot = evt.gamepad.index;
        _this._unregisterDevice(deviceType, deviceSlot);
        delete _this._gamepads[deviceSlot];
      }
    };
    window.addEventListener("gamepadconnected", this._gamepadConnectedEvent);
    window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
  };
  WebDeviceInputSystem2.prototype._updateDevice = function(deviceType, deviceSlot, inputIndex) {
    var gp = navigator.getGamepads()[deviceSlot];
    if (gp && deviceType === this._gamepads[deviceSlot]) {
      var device = this._inputs[deviceType][deviceSlot];
      if (inputIndex >= gp.buttons.length) {
        device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();
      } else {
        device[inputIndex] = gp.buttons[inputIndex].value;
      }
    }
  };
  WebDeviceInputSystem2.prototype._getGamepadDeviceType = function(deviceName) {
    if (deviceName.indexOf("054c") !== -1) {
      return deviceName.indexOf("0ce6") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;
    } else if (deviceName.indexOf("Xbox One") !== -1 || deviceName.search("Xbox 360") !== -1 || deviceName.search("xinput") !== -1) {
      return DeviceType.Xbox;
    } else if (deviceName.indexOf("057e") !== -1) {
      return DeviceType.Switch;
    }
    return DeviceType.Generic;
  };
  WebDeviceInputSystem2.prototype._getPointerType = function(evt) {
    var deviceType = DeviceType.Mouse;
    if (evt.pointerType === "touch" || evt.pointerType === "pen" || evt.touches) {
      deviceType = DeviceType.Touch;
    }
    return deviceType;
  };
  return WebDeviceInputSystem2;
}();
var DeviceSource = function() {
  function DeviceSource2(deviceInputSystem, deviceType, deviceSlot) {
    if (deviceSlot === void 0) {
      deviceSlot = 0;
    }
    this.deviceType = deviceType;
    this.deviceSlot = deviceSlot;
    this.onInputChangedObservable = new Observable();
    this._deviceInputSystem = deviceInputSystem;
  }
  DeviceSource2.prototype.getInput = function(inputIndex) {
    return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, inputIndex);
  };
  return DeviceSource2;
}();
var InternalDeviceSourceManager = function() {
  function InternalDeviceSourceManager2(engine) {
    var _this = this;
    this._registeredManagers = new Array();
    this._refCount = 0;
    this.registerManager = function(manager) {
      for (var deviceType = 0; deviceType < _this._devices.length; deviceType++) {
        var device = _this._devices[deviceType];
        for (var deviceSlotKey in device) {
          var deviceSlot = +deviceSlotKey;
          manager._addDevice(new DeviceSource(_this._deviceInputSystem, deviceType, deviceSlot));
        }
      }
      _this._registeredManagers.push(manager);
    };
    this.unregisterManager = function(manager) {
      var idx = _this._registeredManagers.indexOf(manager);
      if (idx > -1) {
        _this._registeredManagers.splice(idx, 1);
      }
    };
    var numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
    this._devices = new Array(numberOfDeviceTypes);
    if (typeof _native !== "undefined") {
      this._deviceInputSystem = _native.DeviceInputSystem ? new NativeDeviceInputSystem(new _native.DeviceInputSystem()) : new NativeDeviceInputSystem();
    } else {
      this._deviceInputSystem = new WebDeviceInputSystem(engine);
    }
    this._deviceInputSystem.onDeviceConnected = function(deviceType, deviceSlot) {
      if (!_this._devices[deviceType]) {
        _this._devices[deviceType] = new Array();
      }
      if (!_this._devices[deviceType][deviceSlot]) {
        _this._devices[deviceType][deviceSlot] = deviceSlot;
      }
      for (var _i = 0, _a = _this._registeredManagers; _i < _a.length; _i++) {
        var manager = _a[_i];
        var deviceSource = new DeviceSource(_this._deviceInputSystem, deviceType, deviceSlot);
        manager._addDevice(deviceSource);
      }
    };
    this._deviceInputSystem.onDeviceDisconnected = function(deviceType, deviceSlot) {
      var _a;
      if ((_a = _this._devices[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot]) {
        delete _this._devices[deviceType][deviceSlot];
      }
      for (var _i = 0, _b = _this._registeredManagers; _i < _b.length; _i++) {
        var manager = _b[_i];
        manager._removeDevice(deviceType, deviceSlot);
      }
    };
    this._deviceInputSystem.onInputChanged = function(deviceType, deviceSlot, eventData) {
      if (eventData) {
        for (var _i = 0, _a = _this._registeredManagers; _i < _a.length; _i++) {
          var manager = _a[_i];
          manager._onInputChanged(deviceType, deviceSlot, eventData);
        }
      }
    };
  }
  InternalDeviceSourceManager2.prototype.dispose = function() {
    this._deviceInputSystem.dispose();
  };
  return InternalDeviceSourceManager2;
}();
var DeviceSourceManager = function() {
  function DeviceSourceManager2(engine) {
    var _this = this;
    var numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
    this._devices = new Array(numberOfDeviceTypes);
    this._firstDevice = new Array(numberOfDeviceTypes);
    this._engine = engine;
    if (!this._engine._deviceSourceManager) {
      this._engine._deviceSourceManager = new InternalDeviceSourceManager(engine);
    }
    this._engine._deviceSourceManager._refCount++;
    this.onDeviceConnectedObservable = new Observable(function(observer) {
      _this.getDevices().forEach(function(device) {
        _this.onDeviceConnectedObservable.notifyObserver(observer, device);
      });
    });
    this.onDeviceDisconnectedObservable = new Observable();
    this._engine._deviceSourceManager.registerManager(this);
    this._onDisposeObserver = engine.onDisposeObservable.add(function() {
      _this.dispose();
    });
  }
  DeviceSourceManager2.prototype.getDeviceSource = function(deviceType, deviceSlot) {
    if (deviceSlot === void 0) {
      if (this._firstDevice[deviceType] === void 0) {
        return null;
      }
      deviceSlot = this._firstDevice[deviceType];
    }
    if (!this._devices[deviceType] || this._devices[deviceType][deviceSlot] === void 0) {
      return null;
    }
    return this._devices[deviceType][deviceSlot];
  };
  DeviceSourceManager2.prototype.getDeviceSources = function(deviceType) {
    return this._devices[deviceType].filter(function(source) {
      return !!source;
    });
  };
  DeviceSourceManager2.prototype.getDevices = function() {
    var deviceArray = new Array();
    for (var _i = 0, _a = this._devices; _i < _a.length; _i++) {
      var deviceSet = _a[_i];
      deviceArray.push.apply(deviceArray, deviceSet);
    }
    return deviceArray;
  };
  DeviceSourceManager2.prototype.dispose = function() {
    this.onDeviceConnectedObservable.clear();
    this.onDeviceDisconnectedObservable.clear();
    if (this._engine._deviceSourceManager) {
      this._engine._deviceSourceManager.unregisterManager(this);
      if (--this._engine._deviceSourceManager._refCount < 1) {
        this._engine._deviceSourceManager.dispose();
        delete this._engine._deviceSourceManager;
      }
    }
    this._engine.onDisposeObservable.remove(this._onDisposeObserver);
  };
  DeviceSourceManager2.prototype._addDevice = function(deviceSource) {
    if (!this._devices[deviceSource.deviceType]) {
      this._devices[deviceSource.deviceType] = new Array();
    }
    if (!this._devices[deviceSource.deviceType][deviceSource.deviceSlot]) {
      this._devices[deviceSource.deviceType][deviceSource.deviceSlot] = deviceSource;
      this._updateFirstDevices(deviceSource.deviceType);
    }
    this.onDeviceConnectedObservable.notifyObservers(deviceSource);
  };
  DeviceSourceManager2.prototype._removeDevice = function(deviceType, deviceSlot) {
    var _a, _b;
    var deviceSource = (_a = this._devices[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot];
    this.onDeviceDisconnectedObservable.notifyObservers(deviceSource);
    if ((_b = this._devices[deviceType]) === null || _b === void 0 ? void 0 : _b[deviceSlot]) {
      delete this._devices[deviceType][deviceSlot];
    }
    this._updateFirstDevices(deviceType);
  };
  DeviceSourceManager2.prototype._onInputChanged = function(deviceType, deviceSlot, eventData) {
    var _a, _b;
    (_b = (_a = this._devices[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot]) === null || _b === void 0 ? void 0 : _b.onInputChangedObservable.notifyObservers(eventData);
  };
  DeviceSourceManager2.prototype._updateFirstDevices = function(type) {
    switch (type) {
      case DeviceType.Keyboard:
      case DeviceType.Mouse:
        this._firstDevice[type] = 0;
        break;
      case DeviceType.Touch:
      case DeviceType.DualSense:
      case DeviceType.DualShock:
      case DeviceType.Xbox:
      case DeviceType.Switch:
      case DeviceType.Generic:
        delete this._firstDevice[type];
        var devices = this._devices[type];
        if (devices) {
          for (var i = 0; i < devices.length; i++) {
            if (devices[i]) {
              this._firstDevice[type] = i;
              break;
            }
          }
        }
        break;
    }
  };
  return DeviceSourceManager2;
}();
var _ClickInfo = function() {
  function _ClickInfo2() {
    this._singleClick = false;
    this._doubleClick = false;
    this._hasSwiped = false;
    this._ignore = false;
  }
  Object.defineProperty(_ClickInfo2.prototype, "singleClick", {
    get: function() {
      return this._singleClick;
    },
    set: function(b) {
      this._singleClick = b;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(_ClickInfo2.prototype, "doubleClick", {
    get: function() {
      return this._doubleClick;
    },
    set: function(b) {
      this._doubleClick = b;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(_ClickInfo2.prototype, "hasSwiped", {
    get: function() {
      return this._hasSwiped;
    },
    set: function(b) {
      this._hasSwiped = b;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(_ClickInfo2.prototype, "ignore", {
    get: function() {
      return this._ignore;
    },
    set: function(b) {
      this._ignore = b;
    },
    enumerable: false,
    configurable: true
  });
  return _ClickInfo2;
}();
var InputManager = function() {
  function InputManager2(scene) {
    this._alreadyAttached = false;
    this._meshPickProceed = false;
    this._currentPickResult = null;
    this._previousPickResult = null;
    this._totalPointersPressed = 0;
    this._doubleClickOccured = false;
    this._pointerX = 0;
    this._pointerY = 0;
    this._startingPointerPosition = new Vector2(0, 0);
    this._previousStartingPointerPosition = new Vector2(0, 0);
    this._startingPointerTime = 0;
    this._previousStartingPointerTime = 0;
    this._pointerCaptures = {};
    this._meshUnderPointerId = {};
    this._deviceSourceManager = null;
    this._scene = scene || EngineStore.LastCreatedScene;
    if (!this._scene) {
      return;
    }
  }
  Object.defineProperty(InputManager2.prototype, "meshUnderPointer", {
    get: function() {
      return this._pointerOverMesh;
    },
    enumerable: false,
    configurable: true
  });
  InputManager2.prototype.getMeshUnderPointerByPointerId = function(pointerId) {
    return this._meshUnderPointerId[pointerId] || null;
  };
  Object.defineProperty(InputManager2.prototype, "unTranslatedPointer", {
    get: function() {
      return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputManager2.prototype, "pointerX", {
    get: function() {
      return this._pointerX;
    },
    set: function(value) {
      this._pointerX = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputManager2.prototype, "pointerY", {
    get: function() {
      return this._pointerY;
    },
    set: function(value) {
      this._pointerY = value;
    },
    enumerable: false,
    configurable: true
  });
  InputManager2.prototype._updatePointerPosition = function(evt) {
    var canvasRect = this._scene.getEngine().getInputElementClientRect();
    if (!canvasRect) {
      return;
    }
    this._pointerX = evt.clientX - canvasRect.left;
    this._pointerY = evt.clientY - canvasRect.top;
    this._unTranslatedPointerX = this._pointerX;
    this._unTranslatedPointerY = this._pointerY;
  };
  InputManager2.prototype._processPointerMove = function(pickResult, evt) {
    var scene = this._scene;
    var engine = scene.getEngine();
    var canvas = engine.getInputElement();
    if (canvas) {
      canvas.tabIndex = engine.canvasTabIndex;
      if (!scene.doNotHandleCursors) {
        canvas.style.cursor = scene.defaultCursor;
      }
    }
    var isMeshPicked = pickResult && pickResult.hit && pickResult.pickedMesh ? true : false;
    if (isMeshPicked) {
      scene.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId, pickResult);
      if (this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.hasPointerTriggers) {
        if (!scene.doNotHandleCursors && canvas) {
          if (this._pointerOverMesh.actionManager.hoverCursor) {
            canvas.style.cursor = this._pointerOverMesh.actionManager.hoverCursor;
          } else {
            canvas.style.cursor = scene.hoverCursor;
          }
        }
      }
    } else {
      scene.setPointerOverMesh(null, evt.pointerId, pickResult);
    }
    for (var _i = 0, _a = scene._pointerMoveStage; _i < _a.length; _i++) {
      var step = _a[_i];
      pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);
    }
    if (pickResult) {
      var type = evt.type === "wheel" || evt.type === "mousewheel" || evt.type === "DOMMouseScroll" ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;
      if (scene.onPointerMove) {
        scene.onPointerMove(evt, pickResult, type);
      }
      if (scene.onPointerObservable.hasObservers()) {
        var pi = new PointerInfo(type, evt, pickResult);
        this._setRayOnPointerInfo(pi);
        scene.onPointerObservable.notifyObservers(pi, type);
      }
    }
  };
  InputManager2.prototype._setRayOnPointerInfo = function(pointerInfo) {
    var scene = this._scene;
    if (pointerInfo.pickInfo && !pointerInfo.pickInfo._pickingUnavailable) {
      if (!pointerInfo.pickInfo.ray) {
        pointerInfo.pickInfo.ray = scene.createPickingRay(pointerInfo.event.offsetX, pointerInfo.event.offsetY, Matrix.Identity(), scene.activeCamera);
      }
    }
  };
  InputManager2.prototype._checkPrePointerObservable = function(pickResult, evt, type) {
    var scene = this._scene;
    var pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);
    if (pickResult) {
      pi.ray = pickResult.ray;
      if (pickResult.originMesh) {
        pi.nearInteractionPickingInfo = pickResult;
      }
    }
    scene.onPrePointerObservable.notifyObservers(pi, type);
    if (pi.skipOnPointerObservable) {
      return true;
    } else {
      return false;
    }
  };
  InputManager2.prototype.simulatePointerMove = function(pickResult, pointerEventInit) {
    var evt = new PointerEvent("pointermove", pointerEventInit);
    evt.inputIndex = PointerInput.Move;
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {
      return;
    }
    this._processPointerMove(pickResult, evt);
  };
  InputManager2.prototype.simulatePointerDown = function(pickResult, pointerEventInit) {
    var evt = new PointerEvent("pointerdown", pointerEventInit);
    evt.inputIndex = evt.button + 2;
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {
      return;
    }
    this._processPointerDown(pickResult, evt);
  };
  InputManager2.prototype._processPointerDown = function(pickResult, evt) {
    var _this = this;
    var scene = this._scene;
    if (pickResult && pickResult.hit && pickResult.pickedMesh) {
      this._pickedDownMesh = pickResult.pickedMesh;
      var actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
      if (actionManager) {
        if (actionManager.hasPickTriggers) {
          actionManager.processTrigger(5, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
          switch (evt.button) {
            case 0:
              actionManager.processTrigger(2, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
              break;
            case 1:
              actionManager.processTrigger(4, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
              break;
            case 2:
              actionManager.processTrigger(3, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
              break;
          }
        }
        if (actionManager.hasSpecificTrigger(8)) {
          window.setTimeout(function() {
            var pickResult2 = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, function(mesh) {
              return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh === _this._pickedDownMesh;
            }, false, scene.cameraToUseForPointers);
            if (pickResult2 && pickResult2.hit && pickResult2.pickedMesh && actionManager) {
              if (_this._totalPointersPressed !== 0 && Date.now() - _this._startingPointerTime > InputManager2.LongPressDelay && !_this._isPointerSwiping()) {
                _this._startingPointerTime = 0;
                actionManager.processTrigger(8, ActionEvent.CreateNew(pickResult2.pickedMesh, evt));
              }
            }
          }, InputManager2.LongPressDelay);
        }
      }
    } else {
      for (var _i = 0, _a = scene._pointerDownStage; _i < _a.length; _i++) {
        var step = _a[_i];
        pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);
      }
    }
    if (pickResult) {
      var type = PointerEventTypes.POINTERDOWN;
      if (scene.onPointerDown) {
        scene.onPointerDown(evt, pickResult, type);
      }
      if (scene.onPointerObservable.hasObservers()) {
        var pi = new PointerInfo(type, evt, pickResult);
        this._setRayOnPointerInfo(pi);
        scene.onPointerObservable.notifyObservers(pi, type);
      }
    }
  };
  InputManager2.prototype._isPointerSwiping = function() {
    return Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager2.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager2.DragMovementThreshold;
  };
  InputManager2.prototype.simulatePointerUp = function(pickResult, pointerEventInit, doubleTap) {
    var evt = new PointerEvent("pointerup", pointerEventInit);
    evt.inputIndex = PointerInput.Move;
    var clickInfo = new _ClickInfo();
    if (doubleTap) {
      clickInfo.doubleClick = true;
    } else {
      clickInfo.singleClick = true;
    }
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {
      return;
    }
    this._processPointerUp(pickResult, evt, clickInfo);
  };
  InputManager2.prototype._processPointerUp = function(pickResult, evt, clickInfo) {
    var scene = this._scene;
    if (pickResult && pickResult && pickResult.pickedMesh) {
      this._pickedUpMesh = pickResult.pickedMesh;
      if (this._pickedDownMesh === this._pickedUpMesh) {
        if (scene.onPointerPick) {
          scene.onPointerPick(evt, pickResult);
        }
        if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.hasObservers()) {
          var type_1 = PointerEventTypes.POINTERPICK;
          var pi = new PointerInfo(type_1, evt, pickResult);
          this._setRayOnPointerInfo(pi);
          scene.onPointerObservable.notifyObservers(pi, type_1);
        }
      }
      var actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
      if (actionManager && !clickInfo.ignore) {
        actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        if (!clickInfo.hasSwiped && clickInfo.singleClick) {
          actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        }
        var doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);
        if (clickInfo.doubleClick && doubleClickActionManager) {
          doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        }
      }
    } else {
      if (!clickInfo.ignore) {
        for (var _i = 0, _a = scene._pointerUpStage; _i < _a.length; _i++) {
          var step = _a[_i];
          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);
        }
      }
    }
    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {
      var pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);
      if (pickedDownActionManager) {
        pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));
      }
    }
    var type = 0;
    if (scene.onPointerObservable.hasObservers()) {
      if (!clickInfo.ignore && !clickInfo.hasSwiped) {
        if (clickInfo.singleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {
          type = PointerEventTypes.POINTERTAP;
        } else if (clickInfo.doubleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {
          type = PointerEventTypes.POINTERDOUBLETAP;
        }
        if (type) {
          var pi = new PointerInfo(type, evt, pickResult);
          this._setRayOnPointerInfo(pi);
          scene.onPointerObservable.notifyObservers(pi, type);
        }
      }
      if (!clickInfo.ignore) {
        type = PointerEventTypes.POINTERUP;
        var pi = new PointerInfo(type, evt, pickResult);
        this._setRayOnPointerInfo(pi);
        scene.onPointerObservable.notifyObservers(pi, type);
      }
    }
    if (scene.onPointerUp && !clickInfo.ignore) {
      scene.onPointerUp(evt, pickResult, type);
    }
  };
  InputManager2.prototype.isPointerCaptured = function(pointerId) {
    if (pointerId === void 0) {
      pointerId = 0;
    }
    return this._pointerCaptures[pointerId];
  };
  InputManager2.prototype.attachControl = function(attachUp, attachDown, attachMove, elementToAttachTo) {
    var _this = this;
    if (attachUp === void 0) {
      attachUp = true;
    }
    if (attachDown === void 0) {
      attachDown = true;
    }
    if (attachMove === void 0) {
      attachMove = true;
    }
    if (elementToAttachTo === void 0) {
      elementToAttachTo = null;
    }
    var scene = this._scene;
    var engine = scene.getEngine();
    if (!elementToAttachTo) {
      elementToAttachTo = engine.getInputElement();
    }
    if (this._alreadyAttached) {
      this.detachControl();
    }
    if (elementToAttachTo) {
      this._alreadyAttachedTo = elementToAttachTo;
    }
    this._deviceSourceManager = new DeviceSourceManager(engine);
    this._initActionManager = function(act, clickInfo) {
      if (!_this._meshPickProceed) {
        var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);
        _this._currentPickResult = pickResult;
        if (pickResult) {
          act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;
        }
        _this._meshPickProceed = true;
      }
      return act;
    };
    this._delayedSimpleClick = function(btn, clickInfo, cb) {
      if (Date.now() - _this._previousStartingPointerTime > InputManager2.DoubleClickDelay && !_this._doubleClickOccured || btn !== _this._previousButtonPressed) {
        _this._doubleClickOccured = false;
        clickInfo.singleClick = true;
        clickInfo.ignore = false;
        cb(clickInfo, _this._currentPickResult);
      }
    };
    this._initClickEvent = function(obs1, obs2, evt, cb) {
      var clickInfo = new _ClickInfo();
      _this._currentPickResult = null;
      var act = null;
      var checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
      if (!checkPicking && AbstractActionManager) {
        act = _this._initActionManager(act, clickInfo);
        if (act) {
          checkPicking = act.hasPickTriggers;
        }
      }
      var needToIgnoreNext = false;
      if (checkPicking) {
        var btn = evt.button;
        clickInfo.hasSwiped = _this._isPointerSwiping();
        if (!clickInfo.hasSwiped) {
          var checkSingleClickImmediately = !InputManager2.ExclusiveDoubleClickMode;
          if (!checkSingleClickImmediately) {
            checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
            if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {
              act = _this._initActionManager(act, clickInfo);
              if (act) {
                checkSingleClickImmediately = !act.hasSpecificTrigger(6);
              }
            }
          }
          if (checkSingleClickImmediately) {
            if (Date.now() - _this._previousStartingPointerTime > InputManager2.DoubleClickDelay || btn !== _this._previousButtonPressed) {
              clickInfo.singleClick = true;
              cb(clickInfo, _this._currentPickResult);
              needToIgnoreNext = true;
            }
          } else {
            _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;
            _this._delayedSimpleClickTimeout = window.setTimeout(_this._delayedSimpleClick.bind(_this, btn, clickInfo, cb), InputManager2.DoubleClickDelay);
          }
          var checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
          if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {
            act = _this._initActionManager(act, clickInfo);
            if (act) {
              checkDoubleClick = act.hasSpecificTrigger(6);
            }
          }
          if (checkDoubleClick) {
            if (btn === _this._previousButtonPressed && Date.now() - _this._previousStartingPointerTime < InputManager2.DoubleClickDelay && !_this._doubleClickOccured) {
              if (!clickInfo.hasSwiped && !_this._isPointerSwiping()) {
                _this._previousStartingPointerTime = 0;
                _this._doubleClickOccured = true;
                clickInfo.doubleClick = true;
                clickInfo.ignore = false;
                if (InputManager2.ExclusiveDoubleClickMode && _this._previousDelayedSimpleClickTimeout) {
                  clearTimeout(_this._previousDelayedSimpleClickTimeout);
                }
                _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;
                cb(clickInfo, _this._currentPickResult);
              } else {
                _this._doubleClickOccured = false;
                _this._previousStartingPointerTime = _this._startingPointerTime;
                _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;
                _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;
                _this._previousButtonPressed = btn;
                if (InputManager2.ExclusiveDoubleClickMode) {
                  if (_this._previousDelayedSimpleClickTimeout) {
                    clearTimeout(_this._previousDelayedSimpleClickTimeout);
                  }
                  _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;
                  cb(clickInfo, _this._previousPickResult);
                } else {
                  cb(clickInfo, _this._currentPickResult);
                }
              }
              needToIgnoreNext = true;
            } else {
              _this._doubleClickOccured = false;
              _this._previousStartingPointerTime = _this._startingPointerTime;
              _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;
              _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;
              _this._previousButtonPressed = btn;
            }
          }
        }
      }
      if (!needToIgnoreNext) {
        cb(clickInfo, _this._currentPickResult);
      }
    };
    this._onPointerMove = function(evt) {
      if (evt.pointerId === void 0) {
        evt.pointerId = 0;
      }
      _this._updatePointerPosition(evt);
      if (_this._checkPrePointerObservable(null, evt, evt.type === "wheel" || evt.type === "mousewheel" || evt.type === "DOMMouseScroll" ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {
        return;
      }
      if (!scene.cameraToUseForPointers && !scene.activeCamera) {
        return;
      }
      if (scene.skipPointerMovePicking) {
        _this._processPointerMove(new PickingInfo(), evt);
        return;
      }
      if (!scene.pointerMovePredicate) {
        scene.pointerMovePredicate = function(mesh) {
          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
        };
      }
      var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerMovePredicate, false, scene.cameraToUseForPointers, scene.pointerMoveTrianglePredicate);
      _this._processPointerMove(pickResult, evt);
    };
    this._onPointerDown = function(evt) {
      _this._totalPointersPressed++;
      _this._pickedDownMesh = null;
      _this._meshPickProceed = false;
      if (evt.pointerId === void 0) {
        evt.pointerId = 0;
      }
      _this._updatePointerPosition(evt);
      if (scene.preventDefaultOnPointerDown && elementToAttachTo) {
        evt.preventDefault();
        elementToAttachTo.focus();
      }
      _this._startingPointerPosition.x = _this._pointerX;
      _this._startingPointerPosition.y = _this._pointerY;
      _this._startingPointerTime = Date.now();
      if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {
        return;
      }
      if (!scene.cameraToUseForPointers && !scene.activeCamera) {
        return;
      }
      _this._pointerCaptures[evt.pointerId] = true;
      if (!scene.pointerDownPredicate) {
        scene.pointerDownPredicate = function(mesh) {
          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
        };
      }
      _this._pickedDownMesh = null;
      var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);
      _this._processPointerDown(pickResult, evt);
    };
    this._onPointerUp = function(evt) {
      if (_this._totalPointersPressed === 0) {
        return;
      }
      _this._totalPointersPressed--;
      _this._pickedUpMesh = null;
      _this._meshPickProceed = false;
      if (evt.pointerId === void 0) {
        evt.pointerId = 0;
      }
      _this._updatePointerPosition(evt);
      if (scene.preventDefaultOnPointerUp && elementToAttachTo) {
        evt.preventDefault();
        elementToAttachTo.focus();
      }
      _this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, function(clickInfo, pickResult) {
        if (scene.onPrePointerObservable.hasObservers()) {
          if (!clickInfo.ignore) {
            if (!clickInfo.hasSwiped) {
              if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {
                if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {
                  return;
                }
              }
              if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {
                if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {
                  return;
                }
              }
            }
            if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {
              return;
            }
          }
        }
        if (!_this._pointerCaptures[evt.pointerId] && evt.buttons > 0) {
          return;
        }
        _this._pointerCaptures[evt.pointerId] = false;
        if (!scene.cameraToUseForPointers && !scene.activeCamera) {
          return;
        }
        if (!scene.pointerUpPredicate) {
          scene.pointerUpPredicate = function(mesh) {
            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
          };
        }
        if (!_this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || scene.onPointerObservable.hasObservers())) {
          _this._initActionManager(null, clickInfo);
        }
        if (!pickResult) {
          pickResult = _this._currentPickResult;
        }
        _this._processPointerUp(pickResult, evt, clickInfo);
        _this._previousPickResult = _this._currentPickResult;
      });
    };
    this._onKeyDown = function(evt) {
      var type = KeyboardEventTypes.KEYDOWN;
      if (scene.onPreKeyboardObservable.hasObservers()) {
        var pi = new KeyboardInfoPre(type, evt);
        scene.onPreKeyboardObservable.notifyObservers(pi, type);
        if (pi.skipOnKeyboardObservable) {
          return;
        }
      }
      if (scene.onKeyboardObservable.hasObservers()) {
        var pi = new KeyboardInfo(type, evt);
        scene.onKeyboardObservable.notifyObservers(pi, type);
      }
      if (scene.actionManager) {
        scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));
      }
    };
    this._onKeyUp = function(evt) {
      var type = KeyboardEventTypes.KEYUP;
      if (scene.onPreKeyboardObservable.hasObservers()) {
        var pi = new KeyboardInfoPre(type, evt);
        scene.onPreKeyboardObservable.notifyObservers(pi, type);
        if (pi.skipOnKeyboardObservable) {
          return;
        }
      }
      if (scene.onKeyboardObservable.hasObservers()) {
        var pi = new KeyboardInfo(type, evt);
        scene.onKeyboardObservable.notifyObservers(pi, type);
      }
      if (scene.actionManager) {
        scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));
      }
    };
    this._deviceSourceManager.onDeviceConnectedObservable.add(function(deviceSource) {
      if (deviceSource.deviceType === DeviceType.Mouse) {
        deviceSource.onInputChangedObservable.add(function(eventData) {
          if (eventData.inputIndex === PointerInput.LeftClick || eventData.inputIndex === PointerInput.MiddleClick || eventData.inputIndex === PointerInput.RightClick) {
            var evt = eventData;
            if (attachDown && deviceSource.getInput(evt.inputIndex) === 1) {
              _this._onPointerDown(evt);
            } else if (attachUp && deviceSource.getInput(evt.inputIndex) === 0) {
              _this._onPointerUp(evt);
            }
          } else if (attachMove) {
            if (eventData.inputIndex === PointerInput.Move) {
              _this._onPointerMove(eventData);
            } else if (eventData.inputIndex === PointerInput.MouseWheelX || eventData.inputIndex === PointerInput.MouseWheelY || eventData.inputIndex === PointerInput.MouseWheelZ) {
              _this._onPointerMove(eventData);
            }
          }
        });
      } else if (deviceSource.deviceType === DeviceType.Touch) {
        deviceSource.onInputChangedObservable.add(function(eventData) {
          var evt = eventData;
          if (eventData.inputIndex === PointerInput.LeftClick) {
            if (attachDown && deviceSource.getInput(evt.inputIndex) === 1) {
              _this._onPointerDown(eventData);
            } else if (attachUp && deviceSource.getInput(evt.inputIndex) === 0) {
              _this._onPointerUp(eventData);
            }
          }
          if (attachMove && eventData.inputIndex === PointerInput.Move) {
            _this._onPointerMove(eventData);
          }
        });
      } else if (deviceSource.deviceType === DeviceType.Keyboard) {
        deviceSource.onInputChangedObservable.add(function(eventData) {
          var evt = eventData;
          if (evt.type === "keydown") {
            _this._onKeyDown(evt);
          } else if (evt.type === "keyup") {
            _this._onKeyUp(evt);
          }
        });
      }
    });
    this._alreadyAttached = true;
  };
  InputManager2.prototype.detachControl = function() {
    if (this._alreadyAttached) {
      this._deviceSourceManager.dispose();
      this._deviceSourceManager = null;
      if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {
        this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;
      }
      this._alreadyAttached = false;
      this._alreadyAttachedTo = null;
    }
  };
  InputManager2.prototype.setPointerOverMesh = function(mesh, pointerId, pickResult) {
    if (pointerId === void 0) {
      pointerId = 0;
    }
    if (this._meshUnderPointerId[pointerId] === mesh) {
      return;
    }
    var underPointerMesh = this._meshUnderPointerId[pointerId];
    var actionManager;
    if (underPointerMesh) {
      actionManager = underPointerMesh._getActionManagerForTrigger(10);
      if (actionManager) {
        actionManager.processTrigger(10, ActionEvent.CreateNew(underPointerMesh, void 0, { pointerId }));
      }
    }
    if (mesh) {
      this._meshUnderPointerId[pointerId] = mesh;
      this._pointerOverMesh = mesh;
      actionManager = mesh._getActionManagerForTrigger(9);
      if (actionManager) {
        actionManager.processTrigger(9, ActionEvent.CreateNew(mesh, void 0, { pointerId, pickResult }));
      }
    } else {
      delete this._meshUnderPointerId[pointerId];
      this._pointerOverMesh = null;
    }
  };
  InputManager2.prototype.getPointerOverMesh = function() {
    return this._pointerOverMesh;
  };
  InputManager2.prototype._invalidateMesh = function(mesh) {
    if (this._pointerOverMesh === mesh) {
      this._pointerOverMesh = null;
    }
    if (this._pickedDownMesh === mesh) {
      this._pickedDownMesh = null;
    }
    if (this._pickedUpMesh === mesh) {
      this._pickedUpMesh = null;
    }
    for (var pointerId in this._meshUnderPointerId) {
      if (this._meshUnderPointerId[pointerId] === mesh) {
        delete this._meshUnderPointerId[pointerId];
      }
    }
  };
  InputManager2.DragMovementThreshold = 10;
  InputManager2.LongPressDelay = 500;
  InputManager2.DoubleClickDelay = 300;
  InputManager2.ExclusiveDoubleClickMode = false;
  return InputManager2;
}();
var UniqueIdGenerator = function() {
  function UniqueIdGenerator2() {
  }
  Object.defineProperty(UniqueIdGenerator2, "UniqueId", {
    get: function() {
      var result = this._UniqueIdCounter;
      this._UniqueIdCounter++;
      return result;
    },
    enumerable: false,
    configurable: true
  });
  UniqueIdGenerator2._UniqueIdCounter = 1;
  return UniqueIdGenerator2;
}();
var LightConstants = function() {
  function LightConstants2() {
  }
  LightConstants2.CompareLightsPriority = function(a, b) {
    if (a.shadowEnabled !== b.shadowEnabled) {
      return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);
    }
    return b.renderPriority - a.renderPriority;
  };
  LightConstants2.FALLOFF_DEFAULT = 0;
  LightConstants2.FALLOFF_PHYSICAL = 1;
  LightConstants2.FALLOFF_GLTF = 2;
  LightConstants2.FALLOFF_STANDARD = 3;
  LightConstants2.LIGHTMAP_DEFAULT = 0;
  LightConstants2.LIGHTMAP_SPECULAR = 1;
  LightConstants2.LIGHTMAP_SHADOWSONLY = 2;
  LightConstants2.INTENSITYMODE_AUTOMATIC = 0;
  LightConstants2.INTENSITYMODE_LUMINOUSPOWER = 1;
  LightConstants2.INTENSITYMODE_LUMINOUSINTENSITY = 2;
  LightConstants2.INTENSITYMODE_ILLUMINANCE = 3;
  LightConstants2.INTENSITYMODE_LUMINANCE = 4;
  LightConstants2.LIGHTTYPEID_POINTLIGHT = 0;
  LightConstants2.LIGHTTYPEID_DIRECTIONALLIGHT = 1;
  LightConstants2.LIGHTTYPEID_SPOTLIGHT = 2;
  LightConstants2.LIGHTTYPEID_HEMISPHERICLIGHT = 3;
  return LightConstants2;
}();
var ComputePressureObserverWrapper = function() {
  function ComputePressureObserverWrapper2(callback, thresholds) {
    if (ComputePressureObserverWrapper2.IsAvailable) {
      this._observer = new window.ComputePressureObserver(callback, thresholds);
    }
  }
  Object.defineProperty(ComputePressureObserverWrapper2, "IsAvailable", {
    get: function() {
      return IsWindowObjectExist() && "ComputePressureObserver" in window;
    },
    enumerable: false,
    configurable: true
  });
  ComputePressureObserverWrapper2.prototype.observe = function() {
    var _a, _b;
    ((_a = this._observer) === null || _a === void 0 ? void 0 : _a.observe) && ((_b = this._observer) === null || _b === void 0 ? void 0 : _b.observe());
  };
  ComputePressureObserverWrapper2.prototype.unobserve = function() {
    var _a, _b;
    ((_a = this._observer) === null || _a === void 0 ? void 0 : _a.unobserve) && ((_b = this._observer) === null || _b === void 0 ? void 0 : _b.unobserve());
  };
  return ComputePressureObserverWrapper2;
}();
var _injectLTSScene = function(Scene2) {
  Scene2.prototype.setActiveCameraByID = function(id) {
    return this.setActiveCameraById(id);
  };
  Scene2.prototype.getLastMaterialByID = function(id) {
    return this.getLastMaterialById(id);
  };
  Scene2.prototype.getMaterialByID = function(id) {
    return this.getMaterialById(id);
  };
  Scene2.prototype.getTextureByUniqueID = function(uniqueId) {
    return this.getTextureByUniqueId(uniqueId);
  };
  Scene2.prototype.getCameraByID = function(id) {
    return this.getCameraById(id);
  };
  Scene2.prototype.getCameraByUniqueID = function(uniqueId) {
    return this.getCameraByUniqueId(uniqueId);
  };
  Scene2.prototype.getBoneByID = function(id) {
    return this.getBoneById(id);
  };
  Scene2.prototype.getLightByID = function(id) {
    return this.getLightById(id);
  };
  Scene2.prototype.getLightByUniqueID = function(uniqueId) {
    return this.getLightByUniqueId(uniqueId);
  };
  Scene2.prototype.getParticleSystemByID = function(id) {
    return this.getParticleSystemById(id);
  };
  Scene2.prototype.getGeometryByID = function(id) {
    return this.getGeometryById(id);
  };
  Scene2.prototype.getMeshByID = function(id) {
    return this.getMeshById(id);
  };
  Scene2.prototype.getMeshesByID = function(id) {
    return this.getMeshesById(id);
  };
  Scene2.prototype.getTransformNodeByID = function(id) {
    return this.getTransformNodeById(id);
  };
  Scene2.prototype.getTransformNodeByUniqueID = function(uniqueId) {
    return this.getTransformNodeByUniqueId(uniqueId);
  };
  Scene2.prototype.getTransformNodesByID = function(id) {
    return this.getTransformNodesById(id);
  };
  Scene2.prototype.getMeshByUniqueID = function(uniqueId) {
    return this.getMeshByUniqueId(uniqueId);
  };
  Scene2.prototype.getLastMeshByID = function(id) {
    return this.getLastMeshById(id);
  };
  Scene2.prototype.getLastEntryByID = function(id) {
    return this.getLastEntryById(id);
  };
  Scene2.prototype.getNodeByID = function(id) {
    return this.getNodeById(id);
  };
  Scene2.prototype.getLastSkeletonByID = function(id) {
    return this.getLastSkeletonById(id);
  };
};
var Scene = function(_super) {
  __extends(Scene2, _super);
  function Scene2(engine, options) {
    var _this = _super.call(this) || this;
    _this._inputManager = new InputManager(_this);
    _this.cameraToUseForPointers = null;
    _this._isScene = true;
    _this._blockEntityCollection = false;
    _this.autoClear = true;
    _this.autoClearDepthAndStencil = true;
    _this.clearColor = new Color4$1(0.2, 0.2, 0.3, 1);
    _this.ambientColor = new Color3(0, 0, 0);
    _this.environmentIntensity = 1;
    _this._forceWireframe = false;
    _this._skipFrustumClipping = false;
    _this._forcePointsCloud = false;
    _this.animationsEnabled = true;
    _this._animationPropertiesOverride = null;
    _this.useConstantAnimationDeltaTime = false;
    _this.constantlyUpdateMeshUnderPointer = false;
    _this.hoverCursor = "pointer";
    _this.defaultCursor = "";
    _this.doNotHandleCursors = false;
    _this.preventDefaultOnPointerDown = true;
    _this.preventDefaultOnPointerUp = true;
    _this.metadata = null;
    _this.reservedDataStore = null;
    _this.disableOfflineSupportExceptionRules = new Array();
    _this.onDisposeObservable = new Observable();
    _this._onDisposeObserver = null;
    _this.onBeforeRenderObservable = new Observable();
    _this._onBeforeRenderObserver = null;
    _this.onAfterRenderObservable = new Observable();
    _this.onAfterRenderCameraObservable = new Observable();
    _this._onAfterRenderObserver = null;
    _this.onBeforeAnimationsObservable = new Observable();
    _this.onAfterAnimationsObservable = new Observable();
    _this.onBeforeDrawPhaseObservable = new Observable();
    _this.onAfterDrawPhaseObservable = new Observable();
    _this.onReadyObservable = new Observable();
    _this.onBeforeCameraRenderObservable = new Observable();
    _this._onBeforeCameraRenderObserver = null;
    _this.onAfterCameraRenderObservable = new Observable();
    _this._onAfterCameraRenderObserver = null;
    _this.onBeforeActiveMeshesEvaluationObservable = new Observable();
    _this.onAfterActiveMeshesEvaluationObservable = new Observable();
    _this.onBeforeParticlesRenderingObservable = new Observable();
    _this.onAfterParticlesRenderingObservable = new Observable();
    _this.onDataLoadedObservable = new Observable();
    _this.onNewCameraAddedObservable = new Observable();
    _this.onCameraRemovedObservable = new Observable();
    _this.onNewLightAddedObservable = new Observable();
    _this.onLightRemovedObservable = new Observable();
    _this.onNewGeometryAddedObservable = new Observable();
    _this.onGeometryRemovedObservable = new Observable();
    _this.onNewTransformNodeAddedObservable = new Observable();
    _this.onTransformNodeRemovedObservable = new Observable();
    _this.onNewMeshAddedObservable = new Observable();
    _this.onMeshRemovedObservable = new Observable();
    _this.onNewSkeletonAddedObservable = new Observable();
    _this.onSkeletonRemovedObservable = new Observable();
    _this.onNewMaterialAddedObservable = new Observable();
    _this.onNewMultiMaterialAddedObservable = new Observable();
    _this.onMaterialRemovedObservable = new Observable();
    _this.onMultiMaterialRemovedObservable = new Observable();
    _this.onNewTextureAddedObservable = new Observable();
    _this.onTextureRemovedObservable = new Observable();
    _this.onBeforeRenderTargetsRenderObservable = new Observable();
    _this.onAfterRenderTargetsRenderObservable = new Observable();
    _this.onBeforeStepObservable = new Observable();
    _this.onAfterStepObservable = new Observable();
    _this.onActiveCameraChanged = new Observable();
    _this.onBeforeRenderingGroupObservable = new Observable();
    _this.onAfterRenderingGroupObservable = new Observable();
    _this.onMeshImportedObservable = new Observable();
    _this.onAnimationFileImportedObservable = new Observable();
    _this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);
    _this.skipPointerMovePicking = false;
    _this.onPrePointerObservable = new Observable();
    _this.onPointerObservable = new Observable();
    _this.onPreKeyboardObservable = new Observable();
    _this.onKeyboardObservable = new Observable();
    _this._useRightHandedSystem = false;
    _this._timeAccumulator = 0;
    _this._currentStepId = 0;
    _this._currentInternalStep = 0;
    _this._fogEnabled = true;
    _this._fogMode = Scene2.FOGMODE_NONE;
    _this.fogColor = new Color3(0.2, 0.2, 0.3);
    _this.fogDensity = 0.1;
    _this.fogStart = 0;
    _this.fogEnd = 1e3;
    _this.needsPreviousWorldMatrices = false;
    _this._shadowsEnabled = true;
    _this._lightsEnabled = true;
    _this.activeCameras = new Array();
    _this._texturesEnabled = true;
    _this.physicsEnabled = true;
    _this.particlesEnabled = true;
    _this.spritesEnabled = true;
    _this._skeletonsEnabled = true;
    _this.lensFlaresEnabled = true;
    _this.collisionsEnabled = true;
    _this.gravity = new Vector3(0, -9.807, 0);
    _this.postProcessesEnabled = true;
    _this.renderTargetsEnabled = true;
    _this.dumpNextRenderTargets = false;
    _this.customRenderTargets = new Array();
    _this.importedMeshesFiles = new Array();
    _this.probesEnabled = true;
    _this._meshesForIntersections = new SmartArrayNoDuplicate(256);
    _this.proceduralTexturesEnabled = true;
    _this._totalVertices = new PerfCounter();
    _this._activeIndices = new PerfCounter();
    _this._activeParticles = new PerfCounter();
    _this._activeBones = new PerfCounter();
    _this._animationTime = 0;
    _this.animationTimeScale = 1;
    _this._renderId = 0;
    _this._frameId = 0;
    _this._executeWhenReadyTimeoutId = null;
    _this._intermediateRendering = false;
    _this._defaultFrameBufferCleared = false;
    _this._viewUpdateFlag = -1;
    _this._projectionUpdateFlag = -1;
    _this._toBeDisposed = new Array(256);
    _this._activeRequests = new Array();
    _this._pendingData = new Array();
    _this._isDisposed = false;
    _this.dispatchAllSubMeshesOfActiveMeshes = false;
    _this._activeMeshes = new SmartArray(256);
    _this._processedMaterials = new SmartArray(256);
    _this._renderTargets = new SmartArrayNoDuplicate(256);
    _this._activeParticleSystems = new SmartArray(256);
    _this._activeSkeletons = new SmartArrayNoDuplicate(32);
    _this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);
    _this._activeAnimatables = new Array();
    _this._transformMatrix = Matrix.Zero();
    _this.requireLightSorting = false;
    _this._components = [];
    _this._serializableComponents = [];
    _this._transientComponents = [];
    _this._beforeCameraUpdateStage = Stage.Create();
    _this._beforeClearStage = Stage.Create();
    _this._beforeRenderTargetClearStage = Stage.Create();
    _this._gatherRenderTargetsStage = Stage.Create();
    _this._gatherActiveCameraRenderTargetsStage = Stage.Create();
    _this._isReadyForMeshStage = Stage.Create();
    _this._beforeEvaluateActiveMeshStage = Stage.Create();
    _this._evaluateSubMeshStage = Stage.Create();
    _this._preActiveMeshStage = Stage.Create();
    _this._cameraDrawRenderTargetStage = Stage.Create();
    _this._beforeCameraDrawStage = Stage.Create();
    _this._beforeRenderTargetDrawStage = Stage.Create();
    _this._beforeRenderingGroupDrawStage = Stage.Create();
    _this._beforeRenderingMeshStage = Stage.Create();
    _this._afterRenderingMeshStage = Stage.Create();
    _this._afterRenderingGroupDrawStage = Stage.Create();
    _this._afterCameraDrawStage = Stage.Create();
    _this._afterRenderTargetDrawStage = Stage.Create();
    _this._afterRenderStage = Stage.Create();
    _this._pointerMoveStage = Stage.Create();
    _this._pointerDownStage = Stage.Create();
    _this._pointerUpStage = Stage.Create();
    _this.geometriesByUniqueId = null;
    _this._defaultMeshCandidates = {
      data: [],
      length: 0
    };
    _this._defaultSubMeshCandidates = {
      data: [],
      length: 0
    };
    _this._preventFreeActiveMeshesAndRenderingGroups = false;
    _this._activeMeshesFrozen = false;
    _this._skipEvaluateActiveMeshesCompletely = false;
    _this._allowPostProcessClearColor = true;
    _this.getDeterministicFrameTime = function() {
      return _this._engine.getTimeStep();
    };
    _this._blockMaterialDirtyMechanism = false;
    _this._perfCollector = null;
    _this.onComputePressureChanged = new Observable();
    var fullOptions = __assign({ useGeometryUniqueIdsMap: true, useMaterialMeshMap: true, useClonedMeshMap: true, virtual: false }, options);
    _this._engine = engine || EngineStore.LastCreatedEngine;
    if (!fullOptions.virtual) {
      EngineStore._LastCreatedScene = _this;
      _this._engine.scenes.push(_this);
    } else {
      _this._engine._virtualScenes.push(_this);
    }
    _this._uid = null;
    _this._renderingManager = new RenderingManager(_this);
    if (PostProcessManager) {
      _this.postProcessManager = new PostProcessManager(_this);
    }
    if (IsWindowObjectExist()) {
      _this.attachControl();
    }
    _this._createUbo();
    if (ImageProcessingConfiguration) {
      _this._imageProcessingConfiguration = new ImageProcessingConfiguration();
    }
    _this.setDefaultCandidateProviders();
    if (fullOptions.useGeometryUniqueIdsMap) {
      _this.geometriesByUniqueId = {};
    }
    _this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;
    _this.useClonedMeshMap = fullOptions.useClonedMeshMap;
    if (!options || !options.virtual) {
      _this._engine.onNewSceneAddedObservable.notifyObservers(_this);
    }
    if (ComputePressureObserverWrapper.IsAvailable) {
      _this._computePressureObserver = new ComputePressureObserverWrapper(function(update) {
        _this.onComputePressureChanged.notifyObservers(update);
      }, {
        cpuUtilizationThresholds: [0.25, 0.5, 0.75, 0.9],
        cpuSpeedThresholds: [0.5]
      });
      _this._computePressureObserver.observe();
    }
    return _this;
  }
  Scene2.DefaultMaterialFactory = function(scene) {
    throw _WarnImport("StandardMaterial");
  };
  Scene2.CollisionCoordinatorFactory = function() {
    throw _WarnImport("DefaultCollisionCoordinator");
  };
  Object.defineProperty(Scene2.prototype, "environmentTexture", {
    get: function() {
      return this._environmentTexture;
    },
    set: function(value) {
      if (this._environmentTexture === value) {
        return;
      }
      this._environmentTexture = value;
      this.markAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "imageProcessingConfiguration", {
    get: function() {
      return this._imageProcessingConfiguration;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "forceWireframe", {
    get: function() {
      return this._forceWireframe;
    },
    set: function(value) {
      if (this._forceWireframe === value) {
        return;
      }
      this._forceWireframe = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "skipFrustumClipping", {
    get: function() {
      return this._skipFrustumClipping;
    },
    set: function(value) {
      if (this._skipFrustumClipping === value) {
        return;
      }
      this._skipFrustumClipping = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "forcePointsCloud", {
    get: function() {
      return this._forcePointsCloud;
    },
    set: function(value) {
      if (this._forcePointsCloud === value) {
        return;
      }
      this._forcePointsCloud = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "animationPropertiesOverride", {
    get: function() {
      return this._animationPropertiesOverride;
    },
    set: function(value) {
      this._animationPropertiesOverride = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "beforeRender", {
    set: function(callback) {
      if (this._onBeforeRenderObserver) {
        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
      }
      if (callback) {
        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "afterRender", {
    set: function(callback) {
      if (this._onAfterRenderObserver) {
        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
      }
      if (callback) {
        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "beforeCameraRender", {
    set: function(callback) {
      if (this._onBeforeCameraRenderObserver) {
        this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
      }
      this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "afterCameraRender", {
    set: function(callback) {
      if (this._onAfterCameraRenderObserver) {
        this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
      }
      this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "unTranslatedPointer", {
    get: function() {
      return this._inputManager.unTranslatedPointer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2, "DragMovementThreshold", {
    get: function() {
      return InputManager.DragMovementThreshold;
    },
    set: function(value) {
      InputManager.DragMovementThreshold = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2, "LongPressDelay", {
    get: function() {
      return InputManager.LongPressDelay;
    },
    set: function(value) {
      InputManager.LongPressDelay = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2, "DoubleClickDelay", {
    get: function() {
      return InputManager.DoubleClickDelay;
    },
    set: function(value) {
      InputManager.DoubleClickDelay = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2, "ExclusiveDoubleClickMode", {
    get: function() {
      return InputManager.ExclusiveDoubleClickMode;
    },
    set: function(value) {
      InputManager.ExclusiveDoubleClickMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.bindEyePosition = function(effect, variableName, isVector3) {
    var _a;
    if (variableName === void 0) {
      variableName = "vEyePosition";
    }
    if (isVector3 === void 0) {
      isVector3 = false;
    }
    var eyePosition = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : (_a = this.activeCamera.globalPosition) !== null && _a !== void 0 ? _a : this.activeCamera.devicePosition;
    var invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);
    TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);
    if (effect) {
      if (isVector3) {
        effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);
      } else {
        effect.setVector4(variableName, TmpVectors.Vector4[0]);
      }
    }
    return TmpVectors.Vector4[0];
  };
  Scene2.prototype.finalizeSceneUbo = function() {
    var ubo = this.getSceneUniformBuffer();
    var eyePosition = this.bindEyePosition(null);
    ubo.updateFloat4("vEyePosition", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);
    ubo.update();
    return ubo;
  };
  Object.defineProperty(Scene2.prototype, "useRightHandedSystem", {
    get: function() {
      return this._useRightHandedSystem;
    },
    set: function(value) {
      if (this._useRightHandedSystem === value) {
        return;
      }
      this._useRightHandedSystem = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.setStepId = function(newStepId) {
    this._currentStepId = newStepId;
  };
  Scene2.prototype.getStepId = function() {
    return this._currentStepId;
  };
  Scene2.prototype.getInternalStep = function() {
    return this._currentInternalStep;
  };
  Object.defineProperty(Scene2.prototype, "fogEnabled", {
    get: function() {
      return this._fogEnabled;
    },
    set: function(value) {
      if (this._fogEnabled === value) {
        return;
      }
      this._fogEnabled = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "fogMode", {
    get: function() {
      return this._fogMode;
    },
    set: function(value) {
      if (this._fogMode === value) {
        return;
      }
      this._fogMode = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "prePass", {
    get: function() {
      return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "shadowsEnabled", {
    get: function() {
      return this._shadowsEnabled;
    },
    set: function(value) {
      if (this._shadowsEnabled === value) {
        return;
      }
      this._shadowsEnabled = value;
      this.markAllMaterialsAsDirty(2);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "lightsEnabled", {
    get: function() {
      return this._lightsEnabled;
    },
    set: function(value) {
      if (this._lightsEnabled === value) {
        return;
      }
      this._lightsEnabled = value;
      this.markAllMaterialsAsDirty(2);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "activeCamera", {
    get: function() {
      return this._activeCamera;
    },
    set: function(value) {
      if (value === this._activeCamera) {
        return;
      }
      this._activeCamera = value;
      this.onActiveCameraChanged.notifyObservers(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "defaultMaterial", {
    get: function() {
      if (!this._defaultMaterial) {
        this._defaultMaterial = Scene2.DefaultMaterialFactory(this);
      }
      return this._defaultMaterial;
    },
    set: function(value) {
      this._defaultMaterial = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "texturesEnabled", {
    get: function() {
      return this._texturesEnabled;
    },
    set: function(value) {
      if (this._texturesEnabled === value) {
        return;
      }
      this._texturesEnabled = value;
      this.markAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "skeletonsEnabled", {
    get: function() {
      return this._skeletonsEnabled;
    },
    set: function(value) {
      if (this._skeletonsEnabled === value) {
        return;
      }
      this._skeletonsEnabled = value;
      this.markAllMaterialsAsDirty(8);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "collisionCoordinator", {
    get: function() {
      if (!this._collisionCoordinator) {
        this._collisionCoordinator = Scene2.CollisionCoordinatorFactory();
        this._collisionCoordinator.init(this);
      }
      return this._collisionCoordinator;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "frustumPlanes", {
    get: function() {
      return this._frustumPlanes;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype._registerTransientComponents = function() {
    if (this._transientComponents.length > 0) {
      for (var _i = 0, _a = this._transientComponents; _i < _a.length; _i++) {
        var component = _a[_i];
        component.register();
      }
      this._transientComponents = [];
    }
  };
  Scene2.prototype._addComponent = function(component) {
    this._components.push(component);
    this._transientComponents.push(component);
    var serializableComponent = component;
    if (serializableComponent.addFromContainer && serializableComponent.serialize) {
      this._serializableComponents.push(serializableComponent);
    }
  };
  Scene2.prototype._getComponent = function(name2) {
    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
      var component = _a[_i];
      if (component.name === name2) {
        return component;
      }
    }
    return null;
  };
  Scene2.prototype.getClassName = function() {
    return "Scene";
  };
  Scene2.prototype._getDefaultMeshCandidates = function() {
    this._defaultMeshCandidates.data = this.meshes;
    this._defaultMeshCandidates.length = this.meshes.length;
    return this._defaultMeshCandidates;
  };
  Scene2.prototype._getDefaultSubMeshCandidates = function(mesh) {
    this._defaultSubMeshCandidates.data = mesh.subMeshes;
    this._defaultSubMeshCandidates.length = mesh.subMeshes.length;
    return this._defaultSubMeshCandidates;
  };
  Scene2.prototype.setDefaultCandidateProviders = function() {
    this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);
    this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
    this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
    this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
  };
  Object.defineProperty(Scene2.prototype, "meshUnderPointer", {
    get: function() {
      return this._inputManager.meshUnderPointer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "pointerX", {
    get: function() {
      return this._inputManager.pointerX;
    },
    set: function(value) {
      this._inputManager.pointerX = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "pointerY", {
    get: function() {
      return this._inputManager.pointerY;
    },
    set: function(value) {
      this._inputManager.pointerY = value;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getCachedMaterial = function() {
    return this._cachedMaterial;
  };
  Scene2.prototype.getCachedEffect = function() {
    return this._cachedEffect;
  };
  Scene2.prototype.getCachedVisibility = function() {
    return this._cachedVisibility;
  };
  Scene2.prototype.isCachedMaterialInvalid = function(material, effect, visibility) {
    if (visibility === void 0) {
      visibility = 1;
    }
    return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;
  };
  Scene2.prototype.getEngine = function() {
    return this._engine;
  };
  Scene2.prototype.getTotalVertices = function() {
    return this._totalVertices.current;
  };
  Object.defineProperty(Scene2.prototype, "totalVerticesPerfCounter", {
    get: function() {
      return this._totalVertices;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getActiveIndices = function() {
    return this._activeIndices.current;
  };
  Object.defineProperty(Scene2.prototype, "totalActiveIndicesPerfCounter", {
    get: function() {
      return this._activeIndices;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getActiveParticles = function() {
    return this._activeParticles.current;
  };
  Object.defineProperty(Scene2.prototype, "activeParticlesPerfCounter", {
    get: function() {
      return this._activeParticles;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getActiveBones = function() {
    return this._activeBones.current;
  };
  Object.defineProperty(Scene2.prototype, "activeBonesPerfCounter", {
    get: function() {
      return this._activeBones;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getActiveMeshes = function() {
    return this._activeMeshes;
  };
  Scene2.prototype.getAnimationRatio = function() {
    return this._animationRatio !== void 0 ? this._animationRatio : 1;
  };
  Scene2.prototype.getRenderId = function() {
    return this._renderId;
  };
  Scene2.prototype.getFrameId = function() {
    return this._frameId;
  };
  Scene2.prototype.incrementRenderId = function() {
    this._renderId++;
  };
  Scene2.prototype._createUbo = function() {
    this.setSceneUniformBuffer(this.createSceneUniformBuffer());
  };
  Scene2.prototype.simulatePointerMove = function(pickResult, pointerEventInit) {
    this._inputManager.simulatePointerMove(pickResult, pointerEventInit);
    return this;
  };
  Scene2.prototype.simulatePointerDown = function(pickResult, pointerEventInit) {
    this._inputManager.simulatePointerDown(pickResult, pointerEventInit);
    return this;
  };
  Scene2.prototype.simulatePointerUp = function(pickResult, pointerEventInit, doubleTap) {
    this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);
    return this;
  };
  Scene2.prototype.isPointerCaptured = function(pointerId) {
    if (pointerId === void 0) {
      pointerId = 0;
    }
    return this._inputManager.isPointerCaptured(pointerId);
  };
  Scene2.prototype.attachControl = function(attachUp, attachDown, attachMove) {
    if (attachUp === void 0) {
      attachUp = true;
    }
    if (attachDown === void 0) {
      attachDown = true;
    }
    if (attachMove === void 0) {
      attachMove = true;
    }
    this._inputManager.attachControl(attachUp, attachDown, attachMove);
  };
  Scene2.prototype.detachControl = function() {
    this._inputManager.detachControl();
  };
  Scene2.prototype.isReady = function(checkRenderTargets) {
    if (checkRenderTargets === void 0) {
      checkRenderTargets = true;
    }
    if (this._isDisposed) {
      return false;
    }
    var index;
    var engine = this.getEngine();
    if (!engine.areAllEffectsReady()) {
      return false;
    }
    if (this._pendingData.length > 0) {
      return false;
    }
    if (checkRenderTargets) {
      this._processedMaterials.reset();
      this._renderTargets.reset();
    }
    for (index = 0; index < this.meshes.length; index++) {
      var mesh = this.meshes[index];
      if (!mesh.isEnabled()) {
        continue;
      }
      if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
        continue;
      }
      if (!mesh.isReady(true)) {
        return false;
      }
      var hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === "InstancedMesh" || mesh.getClassName() === "InstancedLinesMesh" || engine.getCaps().instancedArrays && mesh.instances.length > 0;
      for (var _i = 0, _a = this._isReadyForMeshStage; _i < _a.length; _i++) {
        var step = _a[_i];
        if (!step.action(mesh, hardwareInstancedRendering)) {
          return false;
        }
      }
      if (!checkRenderTargets) {
        continue;
      }
      var mat = mesh.material || this.defaultMaterial;
      if (mat) {
        if (mat._storeEffectOnSubMeshes) {
          for (var _b = 0, _c = mesh.subMeshes; _b < _c.length; _b++) {
            var subMesh = _c[_b];
            var material = subMesh.getMaterial();
            if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
              if (this._processedMaterials.indexOf(material) === -1) {
                this._processedMaterials.push(material);
                this._renderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
              }
            }
          }
        } else {
          if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {
            if (this._processedMaterials.indexOf(mat) === -1) {
              this._processedMaterials.push(mat);
              this._renderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());
            }
          }
        }
      }
    }
    if (checkRenderTargets) {
      for (index = 0; index < this._renderTargets.length; ++index) {
        var rtt = this._renderTargets.data[index];
        if (!rtt.isReadyForRendering()) {
          return false;
        }
      }
    }
    for (index = 0; index < this.geometries.length; index++) {
      var geometry = this.geometries[index];
      if (geometry.delayLoadState === 2) {
        return false;
      }
    }
    if (this.activeCameras && this.activeCameras.length > 0) {
      for (var _d = 0, _e = this.activeCameras; _d < _e.length; _d++) {
        var camera = _e[_d];
        if (!camera.isReady(true)) {
          return false;
        }
      }
    } else if (this.activeCamera) {
      if (!this.activeCamera.isReady(true)) {
        return false;
      }
    }
    for (var _f = 0, _g = this.particleSystems; _f < _g.length; _f++) {
      var particleSystem = _g[_f];
      if (!particleSystem.isReady()) {
        return false;
      }
    }
    return true;
  };
  Scene2.prototype.resetCachedMaterial = function() {
    this._cachedMaterial = null;
    this._cachedEffect = null;
    this._cachedVisibility = null;
  };
  Scene2.prototype.registerBeforeRender = function(func) {
    this.onBeforeRenderObservable.add(func);
  };
  Scene2.prototype.unregisterBeforeRender = function(func) {
    this.onBeforeRenderObservable.removeCallback(func);
  };
  Scene2.prototype.registerAfterRender = function(func) {
    this.onAfterRenderObservable.add(func);
  };
  Scene2.prototype.unregisterAfterRender = function(func) {
    this.onAfterRenderObservable.removeCallback(func);
  };
  Scene2.prototype._executeOnceBeforeRender = function(func) {
    var _this = this;
    var execFunc = function() {
      func();
      setTimeout(function() {
        _this.unregisterBeforeRender(execFunc);
      });
    };
    this.registerBeforeRender(execFunc);
  };
  Scene2.prototype.executeOnceBeforeRender = function(func, timeout) {
    var _this = this;
    if (timeout !== void 0) {
      setTimeout(function() {
        _this._executeOnceBeforeRender(func);
      }, timeout);
    } else {
      this._executeOnceBeforeRender(func);
    }
  };
  Scene2.prototype._addPendingData = function(data) {
    this._pendingData.push(data);
  };
  Scene2.prototype._removePendingData = function(data) {
    var wasLoading = this.isLoading;
    var index = this._pendingData.indexOf(data);
    if (index !== -1) {
      this._pendingData.splice(index, 1);
    }
    if (wasLoading && !this.isLoading) {
      this.onDataLoadedObservable.notifyObservers(this);
    }
  };
  Scene2.prototype.getWaitingItemsCount = function() {
    return this._pendingData.length;
  };
  Object.defineProperty(Scene2.prototype, "isLoading", {
    get: function() {
      return this._pendingData.length > 0;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.executeWhenReady = function(func, checkRenderTargets) {
    var _this = this;
    if (checkRenderTargets === void 0) {
      checkRenderTargets = false;
    }
    this.onReadyObservable.add(func);
    if (this._executeWhenReadyTimeoutId !== null) {
      return;
    }
    this._executeWhenReadyTimeoutId = setTimeout(function() {
      _this._checkIsReady(checkRenderTargets);
    }, 150);
  };
  Scene2.prototype.whenReadyAsync = function(checkRenderTargets) {
    var _this = this;
    if (checkRenderTargets === void 0) {
      checkRenderTargets = false;
    }
    return new Promise(function(resolve) {
      _this.executeWhenReady(function() {
        resolve();
      }, checkRenderTargets);
    });
  };
  Scene2.prototype._checkIsReady = function(checkRenderTargets) {
    var _this = this;
    if (checkRenderTargets === void 0) {
      checkRenderTargets = false;
    }
    this._registerTransientComponents();
    if (this.isReady(checkRenderTargets)) {
      this.onReadyObservable.notifyObservers(this);
      this.onReadyObservable.clear();
      this._executeWhenReadyTimeoutId = null;
      return;
    }
    if (this._isDisposed) {
      this.onReadyObservable.clear();
      this._executeWhenReadyTimeoutId = null;
      return;
    }
    this._executeWhenReadyTimeoutId = setTimeout(function() {
      _this._checkIsReady(checkRenderTargets);
    }, 150);
  };
  Object.defineProperty(Scene2.prototype, "animatables", {
    get: function() {
      return this._activeAnimatables;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.resetLastAnimationTimeFrame = function() {
    this._animationTimeLast = PrecisionDate.Now;
  };
  Scene2.prototype.getViewMatrix = function() {
    return this._viewMatrix;
  };
  Scene2.prototype.getProjectionMatrix = function() {
    return this._projectionMatrix;
  };
  Scene2.prototype.getTransformMatrix = function() {
    return this._transformMatrix;
  };
  Scene2.prototype.setTransformMatrix = function(viewL, projectionL, viewR, projectionR) {
    if (!viewR && !projectionR && this._multiviewSceneUbo) {
      this._multiviewSceneUbo.dispose();
      this._multiviewSceneUbo = null;
    }
    if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {
      return;
    }
    this._viewUpdateFlag = viewL.updateFlag;
    this._projectionUpdateFlag = projectionL.updateFlag;
    this._viewMatrix = viewL;
    this._projectionMatrix = projectionL;
    this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {
      this._updateMultiviewUbo(viewR, projectionR);
    } else if (this._sceneUbo.useUbo) {
      this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix);
      this._sceneUbo.updateMatrix("view", this._viewMatrix);
      this._sceneUbo.updateMatrix("projection", this._projectionMatrix);
    }
  };
  Scene2.prototype.getSceneUniformBuffer = function() {
    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;
  };
  Scene2.prototype.createSceneUniformBuffer = function(name2) {
    var sceneUbo = new UniformBuffer(this._engine, void 0, false, name2 !== null && name2 !== void 0 ? name2 : "scene");
    sceneUbo.addUniform("viewProjection", 16);
    sceneUbo.addUniform("view", 16);
    sceneUbo.addUniform("projection", 16);
    sceneUbo.addUniform("vEyePosition", 4);
    return sceneUbo;
  };
  Scene2.prototype.setSceneUniformBuffer = function(ubo) {
    this._sceneUbo = ubo;
    this._viewUpdateFlag = -1;
    this._projectionUpdateFlag = -1;
  };
  Scene2.prototype.getUniqueId = function() {
    return UniqueIdGenerator.UniqueId;
  };
  Scene2.prototype.addMesh = function(newMesh, recursive) {
    var _this = this;
    if (recursive === void 0) {
      recursive = false;
    }
    if (this._blockEntityCollection) {
      return;
    }
    this.meshes.push(newMesh);
    newMesh._resyncLightSources();
    if (!newMesh.parent) {
      newMesh._addToSceneRootNodes();
    }
    this.onNewMeshAddedObservable.notifyObservers(newMesh);
    if (recursive) {
      newMesh.getChildMeshes().forEach(function(m) {
        _this.addMesh(m);
      });
    }
  };
  Scene2.prototype.removeMesh = function(toRemove, recursive) {
    var _this = this;
    if (recursive === void 0) {
      recursive = false;
    }
    var index = this.meshes.indexOf(toRemove);
    if (index !== -1) {
      this.meshes[index] = this.meshes[this.meshes.length - 1];
      this.meshes.pop();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this._inputManager._invalidateMesh(toRemove);
    this.onMeshRemovedObservable.notifyObservers(toRemove);
    if (recursive) {
      toRemove.getChildMeshes().forEach(function(m) {
        _this.removeMesh(m);
      });
    }
    return index;
  };
  Scene2.prototype.addTransformNode = function(newTransformNode) {
    if (this._blockEntityCollection) {
      return;
    }
    newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;
    this.transformNodes.push(newTransformNode);
    if (!newTransformNode.parent) {
      newTransformNode._addToSceneRootNodes();
    }
    this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);
  };
  Scene2.prototype.removeTransformNode = function(toRemove) {
    var index = toRemove._indexInSceneTransformNodesArray;
    if (index !== -1) {
      if (index !== this.transformNodes.length - 1) {
        var lastNode = this.transformNodes[this.transformNodes.length - 1];
        this.transformNodes[index] = lastNode;
        lastNode._indexInSceneTransformNodesArray = index;
      }
      toRemove._indexInSceneTransformNodesArray = -1;
      this.transformNodes.pop();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this.onTransformNodeRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeSkeleton = function(toRemove) {
    var index = this.skeletons.indexOf(toRemove);
    if (index !== -1) {
      this.skeletons.splice(index, 1);
      this.onSkeletonRemovedObservable.notifyObservers(toRemove);
      this._executeActiveContainerCleanup(this._activeSkeletons);
    }
    return index;
  };
  Scene2.prototype.removeMorphTargetManager = function(toRemove) {
    var index = this.morphTargetManagers.indexOf(toRemove);
    if (index !== -1) {
      this.morphTargetManagers.splice(index, 1);
    }
    return index;
  };
  Scene2.prototype.removeLight = function(toRemove) {
    var index = this.lights.indexOf(toRemove);
    if (index !== -1) {
      for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {
        var mesh = _a[_i];
        mesh._removeLightSource(toRemove, false);
      }
      this.lights.splice(index, 1);
      this.sortLightsByPriority();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this.onLightRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeCamera = function(toRemove) {
    var index = this.cameras.indexOf(toRemove);
    if (index !== -1) {
      this.cameras.splice(index, 1);
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    if (this.activeCameras) {
      var index2 = this.activeCameras.indexOf(toRemove);
      if (index2 !== -1) {
        this.activeCameras.splice(index2, 1);
      }
    }
    if (this.activeCamera === toRemove) {
      if (this.cameras.length > 0) {
        this.activeCamera = this.cameras[0];
      } else {
        this.activeCamera = null;
      }
    }
    this.onCameraRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeParticleSystem = function(toRemove) {
    var index = this.particleSystems.indexOf(toRemove);
    if (index !== -1) {
      this.particleSystems.splice(index, 1);
      this._executeActiveContainerCleanup(this._activeParticleSystems);
    }
    return index;
  };
  Scene2.prototype.removeAnimation = function(toRemove) {
    var index = this.animations.indexOf(toRemove);
    if (index !== -1) {
      this.animations.splice(index, 1);
    }
    return index;
  };
  Scene2.prototype.stopAnimation = function(target, animationName, targetMask) {
  };
  Scene2.prototype.removeAnimationGroup = function(toRemove) {
    var index = this.animationGroups.indexOf(toRemove);
    if (index !== -1) {
      this.animationGroups.splice(index, 1);
    }
    return index;
  };
  Scene2.prototype.removeMultiMaterial = function(toRemove) {
    var index = this.multiMaterials.indexOf(toRemove);
    if (index !== -1) {
      this.multiMaterials.splice(index, 1);
    }
    this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeMaterial = function(toRemove) {
    var index = toRemove._indexInSceneMaterialArray;
    if (index !== -1 && index < this.materials.length) {
      if (index !== this.materials.length - 1) {
        var lastMaterial = this.materials[this.materials.length - 1];
        this.materials[index] = lastMaterial;
        lastMaterial._indexInSceneMaterialArray = index;
      }
      toRemove._indexInSceneMaterialArray = -1;
      this.materials.pop();
    }
    this.onMaterialRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeActionManager = function(toRemove) {
    var index = this.actionManagers.indexOf(toRemove);
    if (index !== -1) {
      this.actionManagers.splice(index, 1);
    }
    return index;
  };
  Scene2.prototype.removeTexture = function(toRemove) {
    var index = this.textures.indexOf(toRemove);
    if (index !== -1) {
      this.textures.splice(index, 1);
    }
    this.onTextureRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.addLight = function(newLight) {
    if (this._blockEntityCollection) {
      return;
    }
    this.lights.push(newLight);
    this.sortLightsByPriority();
    if (!newLight.parent) {
      newLight._addToSceneRootNodes();
    }
    for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      if (mesh.lightSources.indexOf(newLight) === -1) {
        mesh.lightSources.push(newLight);
        mesh._resyncLightSources();
      }
    }
    this.onNewLightAddedObservable.notifyObservers(newLight);
  };
  Scene2.prototype.sortLightsByPriority = function() {
    if (this.requireLightSorting) {
      this.lights.sort(LightConstants.CompareLightsPriority);
    }
  };
  Scene2.prototype.addCamera = function(newCamera) {
    if (this._blockEntityCollection) {
      return;
    }
    this.cameras.push(newCamera);
    this.onNewCameraAddedObservable.notifyObservers(newCamera);
    if (!newCamera.parent) {
      newCamera._addToSceneRootNodes();
    }
  };
  Scene2.prototype.addSkeleton = function(newSkeleton) {
    if (this._blockEntityCollection) {
      return;
    }
    this.skeletons.push(newSkeleton);
    this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);
  };
  Scene2.prototype.addParticleSystem = function(newParticleSystem) {
    if (this._blockEntityCollection) {
      return;
    }
    this.particleSystems.push(newParticleSystem);
  };
  Scene2.prototype.addAnimation = function(newAnimation) {
    if (this._blockEntityCollection) {
      return;
    }
    this.animations.push(newAnimation);
  };
  Scene2.prototype.addAnimationGroup = function(newAnimationGroup) {
    if (this._blockEntityCollection) {
      return;
    }
    this.animationGroups.push(newAnimationGroup);
  };
  Scene2.prototype.addMultiMaterial = function(newMultiMaterial) {
    if (this._blockEntityCollection) {
      return;
    }
    this.multiMaterials.push(newMultiMaterial);
    this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);
  };
  Scene2.prototype.addMaterial = function(newMaterial) {
    if (this._blockEntityCollection) {
      return;
    }
    newMaterial._indexInSceneMaterialArray = this.materials.length;
    this.materials.push(newMaterial);
    this.onNewMaterialAddedObservable.notifyObservers(newMaterial);
  };
  Scene2.prototype.addMorphTargetManager = function(newMorphTargetManager) {
    if (this._blockEntityCollection) {
      return;
    }
    this.morphTargetManagers.push(newMorphTargetManager);
  };
  Scene2.prototype.addGeometry = function(newGeometry) {
    if (this._blockEntityCollection) {
      return;
    }
    if (this.geometriesByUniqueId) {
      this.geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;
    }
    this.geometries.push(newGeometry);
  };
  Scene2.prototype.addActionManager = function(newActionManager) {
    this.actionManagers.push(newActionManager);
  };
  Scene2.prototype.addTexture = function(newTexture) {
    if (this._blockEntityCollection) {
      return;
    }
    this.textures.push(newTexture);
    this.onNewTextureAddedObservable.notifyObservers(newTexture);
  };
  Scene2.prototype.switchActiveCamera = function(newCamera, attachControl) {
    if (attachControl === void 0) {
      attachControl = true;
    }
    var canvas = this._engine.getInputElement();
    if (!canvas) {
      return;
    }
    if (this.activeCamera) {
      this.activeCamera.detachControl();
    }
    this.activeCamera = newCamera;
    if (attachControl) {
      newCamera.attachControl();
    }
  };
  Scene2.prototype.setActiveCameraById = function(id) {
    var camera = this.getCameraById(id);
    if (camera) {
      this.activeCamera = camera;
      return camera;
    }
    return null;
  };
  Scene2.prototype.setActiveCameraByName = function(name2) {
    var camera = this.getCameraByName(name2);
    if (camera) {
      this.activeCamera = camera;
      return camera;
    }
    return null;
  };
  Scene2.prototype.getAnimationGroupByName = function(name2) {
    for (var index = 0; index < this.animationGroups.length; index++) {
      if (this.animationGroups[index].name === name2) {
        return this.animationGroups[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMaterialByUniqueID = function(uniqueId) {
    for (var index = 0; index < this.materials.length; index++) {
      if (this.materials[index].uniqueId === uniqueId) {
        return this.materials[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMaterialById = function(id) {
    for (var index = 0; index < this.materials.length; index++) {
      if (this.materials[index].id === id) {
        return this.materials[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLastMaterialById = function(id, allowMultiMaterials) {
    if (allowMultiMaterials === void 0) {
      allowMultiMaterials = false;
    }
    for (var index = this.materials.length - 1; index >= 0; index--) {
      if (this.materials[index].id === id) {
        return this.materials[index];
      }
    }
    if (allowMultiMaterials) {
      for (var index = this.multiMaterials.length - 1; index >= 0; index--) {
        if (this.multiMaterials[index].id === id) {
          return this.multiMaterials[index];
        }
      }
    }
    return null;
  };
  Scene2.prototype.getMaterialByName = function(name2) {
    for (var index = 0; index < this.materials.length; index++) {
      if (this.materials[index].name === name2) {
        return this.materials[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTextureByUniqueId = function(uniqueId) {
    for (var index = 0; index < this.textures.length; index++) {
      if (this.textures[index].uniqueId === uniqueId) {
        return this.textures[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTextureByName = function(name2) {
    for (var index = 0; index < this.textures.length; index++) {
      if (this.textures[index].name === name2) {
        return this.textures[index];
      }
    }
    return null;
  };
  Scene2.prototype.getCameraById = function(id) {
    for (var index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].id === id) {
        return this.cameras[index];
      }
    }
    return null;
  };
  Scene2.prototype.getCameraByUniqueId = function(uniqueId) {
    for (var index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].uniqueId === uniqueId) {
        return this.cameras[index];
      }
    }
    return null;
  };
  Scene2.prototype.getCameraByName = function(name2) {
    for (var index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].name === name2) {
        return this.cameras[index];
      }
    }
    return null;
  };
  Scene2.prototype.getBoneById = function(id) {
    for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
      var skeleton = this.skeletons[skeletonIndex];
      for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
        if (skeleton.bones[boneIndex].id === id) {
          return skeleton.bones[boneIndex];
        }
      }
    }
    return null;
  };
  Scene2.prototype.getBoneByName = function(name2) {
    for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
      var skeleton = this.skeletons[skeletonIndex];
      for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
        if (skeleton.bones[boneIndex].name === name2) {
          return skeleton.bones[boneIndex];
        }
      }
    }
    return null;
  };
  Scene2.prototype.getLightByName = function(name2) {
    for (var index = 0; index < this.lights.length; index++) {
      if (this.lights[index].name === name2) {
        return this.lights[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLightById = function(id) {
    for (var index = 0; index < this.lights.length; index++) {
      if (this.lights[index].id === id) {
        return this.lights[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLightByUniqueId = function(uniqueId) {
    for (var index = 0; index < this.lights.length; index++) {
      if (this.lights[index].uniqueId === uniqueId) {
        return this.lights[index];
      }
    }
    return null;
  };
  Scene2.prototype.getParticleSystemById = function(id) {
    for (var index = 0; index < this.particleSystems.length; index++) {
      if (this.particleSystems[index].id === id) {
        return this.particleSystems[index];
      }
    }
    return null;
  };
  Scene2.prototype.getGeometryById = function(id) {
    for (var index = 0; index < this.geometries.length; index++) {
      if (this.geometries[index].id === id) {
        return this.geometries[index];
      }
    }
    return null;
  };
  Scene2.prototype._getGeometryByUniqueId = function(uniqueId) {
    if (this.geometriesByUniqueId) {
      var index_1 = this.geometriesByUniqueId[uniqueId];
      if (index_1 !== void 0) {
        return this.geometries[index_1];
      }
    } else {
      for (var index = 0; index < this.geometries.length; index++) {
        if (this.geometries[index].uniqueId === uniqueId) {
          return this.geometries[index];
        }
      }
    }
    return null;
  };
  Scene2.prototype.pushGeometry = function(geometry, force) {
    if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {
      return false;
    }
    this.addGeometry(geometry);
    this.onNewGeometryAddedObservable.notifyObservers(geometry);
    return true;
  };
  Scene2.prototype.removeGeometry = function(geometry) {
    var index;
    if (this.geometriesByUniqueId) {
      index = this.geometriesByUniqueId[geometry.uniqueId];
      if (index === void 0) {
        return false;
      }
    } else {
      index = this.geometries.indexOf(geometry);
      if (index < 0) {
        return false;
      }
    }
    if (index !== this.geometries.length - 1) {
      var lastGeometry = this.geometries[this.geometries.length - 1];
      if (lastGeometry) {
        this.geometries[index] = lastGeometry;
        if (this.geometriesByUniqueId) {
          this.geometriesByUniqueId[lastGeometry.uniqueId] = index;
          this.geometriesByUniqueId[geometry.uniqueId] = void 0;
        }
      }
    }
    this.geometries.pop();
    this.onGeometryRemovedObservable.notifyObservers(geometry);
    return true;
  };
  Scene2.prototype.getGeometries = function() {
    return this.geometries;
  };
  Scene2.prototype.getMeshById = function(id) {
    for (var index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMeshesById = function(id) {
    return this.meshes.filter(function(m) {
      return m.id === id;
    });
  };
  Scene2.prototype.getTransformNodeById = function(id) {
    for (var index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTransformNodeByUniqueId = function(uniqueId) {
    for (var index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].uniqueId === uniqueId) {
        return this.transformNodes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTransformNodesById = function(id) {
    return this.transformNodes.filter(function(m) {
      return m.id === id;
    });
  };
  Scene2.prototype.getMeshByUniqueId = function(uniqueId) {
    for (var index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].uniqueId === uniqueId) {
        return this.meshes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLastMeshById = function(id) {
    for (var index = this.meshes.length - 1; index >= 0; index--) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLastEntryById = function(id) {
    var index;
    for (index = this.meshes.length - 1; index >= 0; index--) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    for (index = this.transformNodes.length - 1; index >= 0; index--) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    for (index = this.cameras.length - 1; index >= 0; index--) {
      if (this.cameras[index].id === id) {
        return this.cameras[index];
      }
    }
    for (index = this.lights.length - 1; index >= 0; index--) {
      if (this.lights[index].id === id) {
        return this.lights[index];
      }
    }
    return null;
  };
  Scene2.prototype.getNodeById = function(id) {
    var mesh = this.getMeshById(id);
    if (mesh) {
      return mesh;
    }
    var transformNode = this.getTransformNodeById(id);
    if (transformNode) {
      return transformNode;
    }
    var light = this.getLightById(id);
    if (light) {
      return light;
    }
    var camera = this.getCameraById(id);
    if (camera) {
      return camera;
    }
    var bone = this.getBoneById(id);
    if (bone) {
      return bone;
    }
    return null;
  };
  Scene2.prototype.getNodeByName = function(name2) {
    var mesh = this.getMeshByName(name2);
    if (mesh) {
      return mesh;
    }
    var transformNode = this.getTransformNodeByName(name2);
    if (transformNode) {
      return transformNode;
    }
    var light = this.getLightByName(name2);
    if (light) {
      return light;
    }
    var camera = this.getCameraByName(name2);
    if (camera) {
      return camera;
    }
    var bone = this.getBoneByName(name2);
    if (bone) {
      return bone;
    }
    return null;
  };
  Scene2.prototype.getMeshByName = function(name2) {
    for (var index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].name === name2) {
        return this.meshes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTransformNodeByName = function(name2) {
    for (var index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].name === name2) {
        return this.transformNodes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLastSkeletonById = function(id) {
    for (var index = this.skeletons.length - 1; index >= 0; index--) {
      if (this.skeletons[index].id === id) {
        return this.skeletons[index];
      }
    }
    return null;
  };
  Scene2.prototype.getSkeletonByUniqueId = function(uniqueId) {
    for (var index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].uniqueId === uniqueId) {
        return this.skeletons[index];
      }
    }
    return null;
  };
  Scene2.prototype.getSkeletonById = function(id) {
    for (var index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].id === id) {
        return this.skeletons[index];
      }
    }
    return null;
  };
  Scene2.prototype.getSkeletonByName = function(name2) {
    for (var index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].name === name2) {
        return this.skeletons[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMorphTargetManagerById = function(id) {
    for (var index = 0; index < this.morphTargetManagers.length; index++) {
      if (this.morphTargetManagers[index].uniqueId === id) {
        return this.morphTargetManagers[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMorphTargetById = function(id) {
    for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
      var morphTargetManager = this.morphTargetManagers[managerIndex];
      for (var index = 0; index < morphTargetManager.numTargets; ++index) {
        var target = morphTargetManager.getTarget(index);
        if (target.id === id) {
          return target;
        }
      }
    }
    return null;
  };
  Scene2.prototype.getMorphTargetByName = function(name2) {
    for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
      var morphTargetManager = this.morphTargetManagers[managerIndex];
      for (var index = 0; index < morphTargetManager.numTargets; ++index) {
        var target = morphTargetManager.getTarget(index);
        if (target.name === name2) {
          return target;
        }
      }
    }
    return null;
  };
  Scene2.prototype.getPostProcessByName = function(name2) {
    for (var postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {
      var postProcess = this.postProcesses[postProcessIndex];
      if (postProcess.name === name2) {
        return postProcess;
      }
    }
    return null;
  };
  Scene2.prototype.isActiveMesh = function(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  };
  Object.defineProperty(Scene2.prototype, "uid", {
    get: function() {
      if (!this._uid) {
        this._uid = Tools.RandomId();
      }
      return this._uid;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.addExternalData = function(key, data) {
    if (!this._externalData) {
      this._externalData = new StringDictionary();
    }
    return this._externalData.add(key, data);
  };
  Scene2.prototype.getExternalData = function(key) {
    if (!this._externalData) {
      return null;
    }
    return this._externalData.get(key);
  };
  Scene2.prototype.getOrAddExternalDataWithFactory = function(key, factory) {
    if (!this._externalData) {
      this._externalData = new StringDictionary();
    }
    return this._externalData.getOrAddWithFactory(key, factory);
  };
  Scene2.prototype.removeExternalData = function(key) {
    return this._externalData.remove(key);
  };
  Scene2.prototype._evaluateSubMesh = function(subMesh, mesh, initialMesh) {
    if (initialMesh.hasInstances || initialMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.subMeshes.length === 1 || subMesh.isInFrustum(this._frustumPlanes)) {
      for (var _i = 0, _a = this._evaluateSubMeshStage; _i < _a.length; _i++) {
        var step = _a[_i];
        step.action(mesh, subMesh);
      }
      var material = subMesh.getMaterial();
      if (material !== null && material !== void 0) {
        if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
          if (this._processedMaterials.indexOf(material) === -1) {
            this._processedMaterials.push(material);
            this._renderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
          }
        }
        this._renderingManager.dispatch(subMesh, mesh, material);
      }
    }
  };
  Scene2.prototype.freeProcessedMaterials = function() {
    this._processedMaterials.dispose();
  };
  Object.defineProperty(Scene2.prototype, "blockfreeActiveMeshesAndRenderingGroups", {
    get: function() {
      return this._preventFreeActiveMeshesAndRenderingGroups;
    },
    set: function(value) {
      if (this._preventFreeActiveMeshesAndRenderingGroups === value) {
        return;
      }
      if (value) {
        this.freeActiveMeshes();
        this.freeRenderingGroups();
      }
      this._preventFreeActiveMeshesAndRenderingGroups = value;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.freeActiveMeshes = function() {
    if (this.blockfreeActiveMeshesAndRenderingGroups) {
      return;
    }
    this._activeMeshes.dispose();
    if (this.activeCamera && this.activeCamera._activeMeshes) {
      this.activeCamera._activeMeshes.dispose();
    }
    if (this.activeCameras) {
      for (var i = 0; i < this.activeCameras.length; i++) {
        var activeCamera = this.activeCameras[i];
        if (activeCamera && activeCamera._activeMeshes) {
          activeCamera._activeMeshes.dispose();
        }
      }
    }
  };
  Scene2.prototype.freeRenderingGroups = function() {
    if (this.blockfreeActiveMeshesAndRenderingGroups) {
      return;
    }
    if (this._renderingManager) {
      this._renderingManager.freeRenderingGroups();
    }
    if (this.textures) {
      for (var i = 0; i < this.textures.length; i++) {
        var texture = this.textures[i];
        if (texture && texture.renderList) {
          texture.freeRenderingGroups();
        }
      }
    }
  };
  Scene2.prototype._isInIntermediateRendering = function() {
    return this._intermediateRendering;
  };
  Scene2.prototype.freezeActiveMeshes = function(skipEvaluateActiveMeshes, onSuccess, onError, freezeMeshes) {
    var _this = this;
    if (skipEvaluateActiveMeshes === void 0) {
      skipEvaluateActiveMeshes = false;
    }
    if (freezeMeshes === void 0) {
      freezeMeshes = true;
    }
    this.executeWhenReady(function() {
      if (!_this.activeCamera) {
        onError && onError("No active camera found");
        return;
      }
      if (!_this._frustumPlanes) {
        _this.updateTransformMatrix();
      }
      _this._evaluateActiveMeshes();
      _this._activeMeshesFrozen = true;
      _this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;
      if (freezeMeshes) {
        for (var index = 0; index < _this._activeMeshes.length; index++) {
          _this._activeMeshes.data[index]._freeze();
        }
      }
      onSuccess && onSuccess();
    });
    return this;
  };
  Scene2.prototype.unfreezeActiveMeshes = function() {
    for (var index = 0; index < this.meshes.length; index++) {
      var mesh = this.meshes[index];
      if (mesh._internalAbstractMeshDataInfo) {
        mesh._internalAbstractMeshDataInfo._isActive = false;
      }
    }
    for (var index = 0; index < this._activeMeshes.length; index++) {
      this._activeMeshes.data[index]._unFreeze();
    }
    this._activeMeshesFrozen = false;
    return this;
  };
  Scene2.prototype._executeActiveContainerCleanup = function(container) {
    var isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;
    if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {
      return;
    }
    this.onBeforeRenderObservable.addOnce(function() {
      return container.dispose();
    });
  };
  Scene2.prototype._evaluateActiveMeshes = function() {
    var _a;
    if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {
      if (this._activeMeshes.length > 0) {
        (_a = this.activeCamera) === null || _a === void 0 ? void 0 : _a._activeMeshes.reset();
        this._activeMeshes.reset();
        this._renderingManager.reset();
        this._processedMaterials.reset();
        this._activeParticleSystems.reset();
        this._activeSkeletons.reset();
        this._softwareSkinnedMeshes.reset();
      }
      return;
    }
    if (this._activeMeshesFrozen && this._activeMeshes.length) {
      if (!this._skipEvaluateActiveMeshesCompletely) {
        var len_1 = this._activeMeshes.length;
        for (var i = 0; i < len_1; i++) {
          var mesh = this._activeMeshes.data[i];
          mesh.computeWorldMatrix();
        }
      }
      if (this._activeParticleSystems) {
        var psLength = this._activeParticleSystems.length;
        for (var i = 0; i < psLength; i++) {
          this._activeParticleSystems.data[i].animate();
        }
      }
      return;
    }
    if (!this.activeCamera) {
      return;
    }
    this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);
    this.activeCamera._activeMeshes.reset();
    this._activeMeshes.reset();
    this._renderingManager.reset();
    this._processedMaterials.reset();
    this._activeParticleSystems.reset();
    this._activeSkeletons.reset();
    this._softwareSkinnedMeshes.reset();
    for (var _i = 0, _b = this._beforeEvaluateActiveMeshStage; _i < _b.length; _i++) {
      var step = _b[_i];
      step.action();
    }
    var meshes = this.getActiveMeshCandidates();
    var len = meshes.length;
    for (var i = 0; i < len; i++) {
      var mesh = meshes.data[i];
      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;
      if (mesh.isBlocked) {
        continue;
      }
      this._totalVertices.addCount(mesh.getTotalVertices(), false);
      if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.lengthSquared() === 0) {
        continue;
      }
      mesh.computeWorldMatrix();
      if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {
        this._meshesForIntersections.pushNoDuplicate(mesh);
      }
      var meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);
      mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;
      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;
      if (meshToRender === void 0 || meshToRender === null) {
        continue;
      }
      if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {
        meshToRender.computeWorldMatrix();
      }
      mesh._preActivate();
      if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {
        this._activeMeshes.push(mesh);
        this.activeCamera._activeMeshes.push(mesh);
        if (meshToRender !== mesh) {
          meshToRender._activate(this._renderId, false);
        }
        for (var _c = 0, _d = this._preActiveMeshStage; _c < _d.length; _c++) {
          var step = _d[_c];
          step.action(mesh);
        }
        if (mesh._activate(this._renderId, false)) {
          if (!mesh.isAnInstance) {
            meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;
          } else {
            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
              meshToRender = mesh;
            }
          }
          meshToRender._internalAbstractMeshDataInfo._isActive = true;
          this._activeMesh(mesh, meshToRender);
        }
        mesh._postActivate();
      }
    }
    this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);
    if (this.particlesEnabled) {
      this.onBeforeParticlesRenderingObservable.notifyObservers(this);
      for (var particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {
        var particleSystem = this.particleSystems[particleIndex];
        if (!particleSystem.isStarted() || !particleSystem.emitter) {
          continue;
        }
        var emitter = particleSystem.emitter;
        if (!emitter.position || emitter.isEnabled()) {
          this._activeParticleSystems.push(particleSystem);
          particleSystem.animate();
          this._renderingManager.dispatchParticles(particleSystem);
        }
      }
      this.onAfterParticlesRenderingObservable.notifyObservers(this);
    }
  };
  Scene2.prototype._activeMesh = function(sourceMesh, mesh) {
    if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== void 0) {
      if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {
        mesh.skeleton.prepare();
        this._activeBones.addCount(mesh.skeleton.bones.length, false);
      }
      if (!mesh.computeBonesUsingShaders) {
        this._softwareSkinnedMeshes.pushNoDuplicate(mesh);
      }
    }
    if (mesh !== void 0 && mesh !== null && mesh.subMeshes !== void 0 && mesh.subMeshes !== null && mesh.subMeshes.length > 0) {
      var subMeshes = this.getActiveSubMeshCandidates(mesh);
      var len = subMeshes.length;
      for (var i = 0; i < len; i++) {
        var subMesh = subMeshes.data[i];
        this._evaluateSubMesh(subMesh, mesh, sourceMesh);
      }
    }
  };
  Scene2.prototype.updateTransformMatrix = function(force) {
    if (!this.activeCamera) {
      return;
    }
    if (this.activeCamera._renderingMultiview) {
      var leftCamera = this.activeCamera._rigCameras[0];
      var rightCamera = this.activeCamera._rigCameras[1];
      this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));
    } else {
      this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));
    }
  };
  Scene2.prototype._bindFrameBuffer = function(camera, clear) {
    if (clear === void 0) {
      clear = true;
    }
    if (camera && camera._multiviewTexture) {
      camera._multiviewTexture._bindFrameBuffer();
    } else if (camera && camera.outputRenderTarget) {
      camera.outputRenderTarget._bindFrameBuffer();
    } else {
      if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {
        this._engine.restoreDefaultFramebuffer();
      }
    }
    if (clear) {
      this._clearFrameBuffer(camera);
    }
  };
  Scene2.prototype._clearFrameBuffer = function(camera) {
    if (camera && camera._multiviewTexture)
      ;
    else if (camera && camera.outputRenderTarget) {
      var rtt = camera.outputRenderTarget;
      if (rtt.onClearObservable.hasObservers()) {
        rtt.onClearObservable.notifyObservers(this._engine);
      } else if (!rtt.skipInitialClear) {
        this._engine.clear(rtt.clearColor || this.clearColor, !rtt._cleared, true, true);
        rtt._cleared = true;
      }
    } else {
      if (!this._defaultFrameBufferCleared) {
        this._defaultFrameBufferCleared = true;
        this._clear();
      } else {
        this._engine.clear(null, false, true, true);
      }
    }
  };
  Scene2.prototype._renderForCamera = function(camera, rigParent, bindFrameBuffer) {
    var _a, _b, _c;
    if (bindFrameBuffer === void 0) {
      bindFrameBuffer = true;
    }
    if (camera && camera._skipRendering) {
      return;
    }
    var engine = this._engine;
    this._activeCamera = camera;
    if (!this.activeCamera) {
      throw new Error("Active camera not set");
    }
    engine.setViewport(this.activeCamera.viewport);
    this.resetCachedMaterial();
    this._renderId++;
    if (!this.prePass && bindFrameBuffer) {
      var skipInitialClear = true;
      if (camera._renderingMultiview && camera.outputRenderTarget) {
        skipInitialClear = camera.outputRenderTarget.skipInitialClear;
        if (this.autoClear) {
          camera.outputRenderTarget.skipInitialClear = false;
        }
      }
      this._bindFrameBuffer(this._activeCamera);
      if (camera._renderingMultiview && camera.outputRenderTarget) {
        camera.outputRenderTarget.skipInitialClear = skipInitialClear;
      }
    }
    this.updateTransformMatrix();
    this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);
    this._evaluateActiveMeshes();
    for (var softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {
      var mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];
      mesh.applySkeleton(mesh.skeleton);
    }
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
    if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {
      this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);
    }
    if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {
      this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);
    }
    if (this.environmentTexture && this.environmentTexture.isRenderTarget) {
      this._renderTargets.pushNoDuplicate(this.environmentTexture);
    }
    for (var _i = 0, _d = this._gatherActiveCameraRenderTargetsStage; _i < _d.length; _i++) {
      var step = _d[_i];
      step.action(this._renderTargets);
    }
    var needRebind = false;
    if (this.renderTargetsEnabled) {
      this._intermediateRendering = true;
      if (this._renderTargets.length > 0) {
        Tools.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
        for (var renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {
          var renderTarget = this._renderTargets.data[renderIndex];
          if (renderTarget._shouldRender()) {
            this._renderId++;
            var hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;
            renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);
            needRebind = true;
          }
        }
        Tools.EndPerformanceCounter("Render targets", this._renderTargets.length > 0);
        this._renderId++;
      }
      for (var _e = 0, _f = this._cameraDrawRenderTargetStage; _e < _f.length; _e++) {
        var step = _f[_e];
        needRebind = step.action(this.activeCamera) || needRebind;
      }
      this._intermediateRendering = false;
    }
    this._engine.currentRenderPassId = (_c = (_b = (_a = camera.outputRenderTarget) === null || _a === void 0 ? void 0 : _a.renderPassId) !== null && _b !== void 0 ? _b : camera.renderPassId) !== null && _c !== void 0 ? _c : 0;
    if (needRebind && !this.prePass) {
      this._bindFrameBuffer(this._activeCamera, false);
    }
    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
    if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {
      this.postProcessManager._prepareFrame();
    }
    for (var _g = 0, _h = this._beforeCameraDrawStage; _g < _h.length; _g++) {
      var step = _h[_g];
      step.action(this.activeCamera);
    }
    this.onBeforeDrawPhaseObservable.notifyObservers(this);
    if (engine.snapshotRendering && engine.snapshotRenderingMode === 1) {
      this.finalizeSceneUbo();
    }
    this._renderingManager.render(null, null, true, true);
    this.onAfterDrawPhaseObservable.notifyObservers(this);
    for (var _j = 0, _k = this._afterCameraDrawStage; _j < _k.length; _j++) {
      var step = _k[_j];
      step.action(this.activeCamera);
    }
    if (this.postProcessManager && !camera._multiviewTexture) {
      var texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : void 0;
      this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);
    }
    this._renderTargets.reset();
    this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);
  };
  Scene2.prototype._processSubCameras = function(camera, bindFrameBuffer) {
    if (bindFrameBuffer === void 0) {
      bindFrameBuffer = true;
    }
    if (camera.cameraRigMode === 0 || camera._renderingMultiview) {
      if (camera._renderingMultiview && !this._multiviewSceneUbo) {
        this._createMultiviewUbo();
      }
      this._renderForCamera(camera, void 0, bindFrameBuffer);
      this.onAfterRenderCameraObservable.notifyObservers(camera);
      return;
    }
    if (camera._useMultiviewToSingleView) {
      this._renderMultiviewToSingleView(camera);
    } else {
      this.onBeforeCameraRenderObservable.notifyObservers(camera);
      for (var index = 0; index < camera._rigCameras.length; index++) {
        this._renderForCamera(camera._rigCameras[index], camera);
      }
    }
    this._activeCamera = camera;
    this.updateTransformMatrix();
    this.onAfterRenderCameraObservable.notifyObservers(camera);
  };
  Scene2.prototype._checkIntersections = function() {
    for (var index = 0; index < this._meshesForIntersections.length; index++) {
      var sourceMesh = this._meshesForIntersections.data[index];
      if (!sourceMesh.actionManager) {
        continue;
      }
      for (var actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {
        var action = sourceMesh.actionManager.actions[actionIndex];
        if (action.trigger === 12 || action.trigger === 13) {
          var parameters = action.getTriggerParameter();
          var otherMesh = parameters.mesh ? parameters.mesh : parameters;
          var areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);
          var currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);
          if (areIntersecting && currentIntersectionInProgress === -1) {
            if (action.trigger === 12) {
              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh));
              sourceMesh._intersectionsInProgress.push(otherMesh);
            } else if (action.trigger === 13) {
              sourceMesh._intersectionsInProgress.push(otherMesh);
            }
          } else if (!areIntersecting && currentIntersectionInProgress > -1) {
            if (action.trigger === 13) {
              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh));
            }
            if (!sourceMesh.actionManager.hasSpecificTrigger(13, function(parameter) {
              var parameterMesh = parameter.mesh ? parameter.mesh : parameter;
              return otherMesh === parameterMesh;
            }) || action.trigger === 13) {
              sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);
            }
          }
        }
      }
    }
  };
  Scene2.prototype._advancePhysicsEngineStep = function(step) {
  };
  Scene2.prototype._animate = function() {
  };
  Scene2.prototype.animate = function() {
    if (this._engine.isDeterministicLockStep()) {
      var deltaTime = Math.max(Scene2.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene2.MaxDeltaTime)) + this._timeAccumulator;
      var defaultFrameTime = this._engine.getTimeStep();
      var defaultFPS = 1e3 / defaultFrameTime / 1e3;
      var stepsTaken = 0;
      var maxSubSteps = this._engine.getLockstepMaxSteps();
      var internalSteps = Math.floor(deltaTime / defaultFrameTime);
      internalSteps = Math.min(internalSteps, maxSubSteps);
      while (deltaTime > 0 && stepsTaken < internalSteps) {
        this.onBeforeStepObservable.notifyObservers(this);
        this._animationRatio = defaultFrameTime * defaultFPS;
        this._animate();
        this.onAfterAnimationsObservable.notifyObservers(this);
        if (this.physicsEnabled) {
          this._advancePhysicsEngineStep(defaultFrameTime);
        }
        this.onAfterStepObservable.notifyObservers(this);
        this._currentStepId++;
        stepsTaken++;
        deltaTime -= defaultFrameTime;
      }
      this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;
    } else {
      var deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene2.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene2.MaxDeltaTime));
      this._animationRatio = deltaTime * (60 / 1e3);
      this._animate();
      this.onAfterAnimationsObservable.notifyObservers(this);
      if (this.physicsEnabled) {
        this._advancePhysicsEngineStep(deltaTime);
      }
    }
  };
  Scene2.prototype._clear = function() {
    if (this.autoClearDepthAndStencil || this.autoClear) {
      this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);
    }
  };
  Scene2.prototype.checkCameraRenderTarget = function(camera) {
    var _a;
    if ((camera === null || camera === void 0 ? void 0 : camera.outputRenderTarget) && !(camera === null || camera === void 0 ? void 0 : camera.isRigCamera)) {
      camera.outputRenderTarget._cleared = false;
    }
    if ((_a = camera === null || camera === void 0 ? void 0 : camera.rigCameras) === null || _a === void 0 ? void 0 : _a.length) {
      for (var i = 0; i < camera.rigCameras.length; ++i) {
        var rtt = camera.rigCameras[i].outputRenderTarget;
        if (rtt) {
          rtt._cleared = false;
        }
      }
    }
  };
  Scene2.prototype.resetDrawCache = function(passId) {
    if (!this.meshes) {
      return;
    }
    for (var _i = 0, _a = this.meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      mesh.resetDrawCache(passId);
    }
  };
  Scene2.prototype.render = function(updateCameras, ignoreAnimations) {
    var _a, _b, _c;
    if (updateCameras === void 0) {
      updateCameras = true;
    }
    if (ignoreAnimations === void 0) {
      ignoreAnimations = false;
    }
    if (this.isDisposed) {
      return;
    }
    if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {
      this._checkIsReady();
    }
    this._frameId++;
    this._defaultFrameBufferCleared = false;
    this.checkCameraRenderTarget(this.activeCamera);
    if ((_a = this.activeCameras) === null || _a === void 0 ? void 0 : _a.length) {
      this.activeCameras.forEach(this.checkCameraRenderTarget);
    }
    this._registerTransientComponents();
    this._activeParticles.fetchNewFrame();
    this._totalVertices.fetchNewFrame();
    this._activeIndices.fetchNewFrame();
    this._activeBones.fetchNewFrame();
    this._meshesForIntersections.reset();
    this.resetCachedMaterial();
    this.onBeforeAnimationsObservable.notifyObservers(this);
    if (this.actionManager) {
      this.actionManager.processTrigger(11);
    }
    if (!ignoreAnimations) {
      this.animate();
    }
    for (var _i = 0, _d = this._beforeCameraUpdateStage; _i < _d.length; _i++) {
      var step = _d[_i];
      step.action();
    }
    if (updateCameras) {
      if (this.activeCameras && this.activeCameras.length > 0) {
        for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
          var camera = this.activeCameras[cameraIndex];
          camera.update();
          if (camera.cameraRigMode !== 0) {
            for (var index = 0; index < camera._rigCameras.length; index++) {
              camera._rigCameras[index].update();
            }
          }
        }
      } else if (this.activeCamera) {
        this.activeCamera.update();
        if (this.activeCamera.cameraRigMode !== 0) {
          for (var index = 0; index < this.activeCamera._rigCameras.length; index++) {
            this.activeCamera._rigCameras[index].update();
          }
        }
      }
    }
    this.onBeforeRenderObservable.notifyObservers(this);
    var engine = this.getEngine();
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
    var currentActiveCamera = ((_b = this.activeCameras) === null || _b === void 0 ? void 0 : _b.length) ? this.activeCameras[0] : this.activeCamera;
    if (this.renderTargetsEnabled) {
      Tools.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
      this._intermediateRendering = true;
      for (var customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {
        var renderTarget = this.customRenderTargets[customIndex];
        if (renderTarget._shouldRender()) {
          this._renderId++;
          this.activeCamera = renderTarget.activeCamera || this.activeCamera;
          if (!this.activeCamera) {
            throw new Error("Active camera not set");
          }
          engine.setViewport(this.activeCamera.viewport);
          this.updateTransformMatrix();
          renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);
        }
      }
      Tools.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
      this._intermediateRendering = false;
      this._renderId++;
    }
    this._engine.currentRenderPassId = (_c = currentActiveCamera === null || currentActiveCamera === void 0 ? void 0 : currentActiveCamera.renderPassId) !== null && _c !== void 0 ? _c : 0;
    this.activeCamera = currentActiveCamera;
    if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {
      this._bindFrameBuffer(this._activeCamera, false);
    }
    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
    for (var _e = 0, _f = this._beforeClearStage; _e < _f.length; _e++) {
      var step = _f[_e];
      step.action();
    }
    this._clearFrameBuffer(this.activeCamera);
    for (var _g = 0, _h = this._gatherRenderTargetsStage; _g < _h.length; _g++) {
      var step = _h[_g];
      step.action(this._renderTargets);
    }
    if (this.activeCameras && this.activeCameras.length > 0) {
      for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
        this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);
      }
    } else {
      if (!this.activeCamera) {
        throw new Error("No camera defined");
      }
      this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);
    }
    this._checkIntersections();
    for (var _j = 0, _k = this._afterRenderStage; _j < _k.length; _j++) {
      var step = _k[_j];
      step.action();
    }
    if (this.afterRender) {
      this.afterRender();
    }
    this.onAfterRenderObservable.notifyObservers(this);
    if (this._toBeDisposed.length) {
      for (var index = 0; index < this._toBeDisposed.length; index++) {
        var data = this._toBeDisposed[index];
        if (data) {
          data.dispose();
        }
      }
      this._toBeDisposed = [];
    }
    if (this.dumpNextRenderTargets) {
      this.dumpNextRenderTargets = false;
    }
    this._activeBones.addCount(0, true);
    this._activeIndices.addCount(0, true);
    this._activeParticles.addCount(0, true);
    this._engine.restoreDefaultFramebuffer();
  };
  Scene2.prototype.freezeMaterials = function() {
    for (var i = 0; i < this.materials.length; i++) {
      this.materials[i].freeze();
    }
  };
  Scene2.prototype.unfreezeMaterials = function() {
    for (var i = 0; i < this.materials.length; i++) {
      this.materials[i].unfreeze();
    }
  };
  Scene2.prototype.dispose = function() {
    var _a;
    if (this.isDisposed) {
      return;
    }
    this.beforeRender = null;
    this.afterRender = null;
    this.metadata = null;
    this.skeletons = [];
    this.morphTargetManagers = [];
    this._transientComponents = [];
    this._isReadyForMeshStage.clear();
    this._beforeEvaluateActiveMeshStage.clear();
    this._evaluateSubMeshStage.clear();
    this._preActiveMeshStage.clear();
    this._cameraDrawRenderTargetStage.clear();
    this._beforeCameraDrawStage.clear();
    this._beforeRenderTargetDrawStage.clear();
    this._beforeRenderingGroupDrawStage.clear();
    this._beforeRenderingMeshStage.clear();
    this._afterRenderingMeshStage.clear();
    this._afterRenderingGroupDrawStage.clear();
    this._afterCameraDrawStage.clear();
    this._afterRenderTargetDrawStage.clear();
    this._afterRenderStage.clear();
    this._beforeCameraUpdateStage.clear();
    this._beforeClearStage.clear();
    this._gatherRenderTargetsStage.clear();
    this._gatherActiveCameraRenderTargetsStage.clear();
    this._pointerMoveStage.clear();
    this._pointerDownStage.clear();
    this._pointerUpStage.clear();
    this.importedMeshesFiles = new Array();
    if (this.stopAllAnimations) {
      this.stopAllAnimations();
    }
    this.resetCachedMaterial();
    if (this.activeCamera) {
      this.activeCamera._activeMeshes.dispose();
      this.activeCamera = null;
    }
    this._activeMeshes.dispose();
    this._renderingManager.dispose();
    this._processedMaterials.dispose();
    this._activeParticleSystems.dispose();
    this._activeSkeletons.dispose();
    this._softwareSkinnedMeshes.dispose();
    this._renderTargets.dispose();
    this._registeredForLateAnimationBindings.dispose();
    this._meshesForIntersections.dispose();
    this._toBeDisposed = [];
    for (var _i = 0, _b = this._activeRequests; _i < _b.length; _i++) {
      var request = _b[_i];
      request.abort();
    }
    this._activeRequests = [];
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onBeforeRenderObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onBeforeRenderTargetsRenderObservable.clear();
    this.onAfterRenderTargetsRenderObservable.clear();
    this.onAfterStepObservable.clear();
    this.onBeforeStepObservable.clear();
    this.onBeforeActiveMeshesEvaluationObservable.clear();
    this.onAfterActiveMeshesEvaluationObservable.clear();
    this.onBeforeParticlesRenderingObservable.clear();
    this.onAfterParticlesRenderingObservable.clear();
    this.onBeforeDrawPhaseObservable.clear();
    this.onAfterDrawPhaseObservable.clear();
    this.onBeforeAnimationsObservable.clear();
    this.onAfterAnimationsObservable.clear();
    this.onDataLoadedObservable.clear();
    this.onBeforeRenderingGroupObservable.clear();
    this.onAfterRenderingGroupObservable.clear();
    this.onMeshImportedObservable.clear();
    this.onBeforeCameraRenderObservable.clear();
    this.onAfterCameraRenderObservable.clear();
    this.onReadyObservable.clear();
    this.onNewCameraAddedObservable.clear();
    this.onCameraRemovedObservable.clear();
    this.onNewLightAddedObservable.clear();
    this.onLightRemovedObservable.clear();
    this.onNewGeometryAddedObservable.clear();
    this.onGeometryRemovedObservable.clear();
    this.onNewTransformNodeAddedObservable.clear();
    this.onTransformNodeRemovedObservable.clear();
    this.onNewMeshAddedObservable.clear();
    this.onMeshRemovedObservable.clear();
    this.onNewSkeletonAddedObservable.clear();
    this.onSkeletonRemovedObservable.clear();
    this.onNewMaterialAddedObservable.clear();
    this.onNewMultiMaterialAddedObservable.clear();
    this.onMaterialRemovedObservable.clear();
    this.onMultiMaterialRemovedObservable.clear();
    this.onNewTextureAddedObservable.clear();
    this.onTextureRemovedObservable.clear();
    this.onPrePointerObservable.clear();
    this.onPointerObservable.clear();
    this.onPreKeyboardObservable.clear();
    this.onKeyboardObservable.clear();
    this.onActiveCameraChanged.clear();
    this.onComputePressureChanged.clear();
    (_a = this._computePressureObserver) === null || _a === void 0 ? void 0 : _a.unobserve();
    this._computePressureObserver = void 0;
    this.detachControl();
    var canvas = this._engine.getInputElement();
    if (canvas) {
      var index;
      for (index = 0; index < this.cameras.length; index++) {
        this.cameras[index].detachControl();
      }
    }
    while (this.animationGroups.length) {
      this.animationGroups[0].dispose();
    }
    while (this.lights.length) {
      this.lights[0].dispose();
    }
    while (this.meshes.length) {
      this.meshes[0].dispose(true);
    }
    while (this.transformNodes.length) {
      this.transformNodes[0].dispose(true);
    }
    while (this.cameras.length) {
      this.cameras[0].dispose();
    }
    if (this._defaultMaterial) {
      this._defaultMaterial.dispose();
    }
    while (this.multiMaterials.length) {
      this.multiMaterials[0].dispose();
    }
    while (this.materials.length) {
      this.materials[0].dispose();
    }
    while (this.particleSystems.length) {
      this.particleSystems[0].dispose();
    }
    while (this.postProcesses.length) {
      this.postProcesses[0].dispose();
    }
    while (this.textures.length) {
      this.textures[0].dispose();
    }
    while (this.morphTargetManagers.length) {
      this.morphTargetManagers[0].dispose();
    }
    this._sceneUbo.dispose();
    if (this._multiviewSceneUbo) {
      this._multiviewSceneUbo.dispose();
    }
    this.postProcessManager.dispose();
    for (var _c = 0, _d = this._components; _c < _d.length; _c++) {
      var component = _d[_c];
      component.dispose();
    }
    index = this._engine.scenes.indexOf(this);
    if (index > -1) {
      this._engine.scenes.splice(index, 1);
    }
    if (EngineStore._LastCreatedScene === this) {
      if (this._engine.scenes.length > 0) {
        EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];
      } else {
        EngineStore._LastCreatedScene = null;
      }
    }
    index = this._engine._virtualScenes.indexOf(this);
    if (index > -1) {
      this._engine._virtualScenes.splice(index, 1);
    }
    this._engine.wipeCaches(true);
    this._isDisposed = true;
  };
  Object.defineProperty(Scene2.prototype, "isDisposed", {
    get: function() {
      return this._isDisposed;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.clearCachedVertexData = function() {
    for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
      var mesh = this.meshes[meshIndex];
      var geometry = mesh.geometry;
      if (geometry) {
        geometry.clearCachedData();
      }
    }
  };
  Scene2.prototype.cleanCachedTextureBuffer = function() {
    for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {
      var baseTexture = _a[_i];
      var buffer = baseTexture._buffer;
      if (buffer) {
        baseTexture._buffer = null;
      }
    }
  };
  Scene2.prototype.getWorldExtends = function(filterPredicate) {
    var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    filterPredicate = filterPredicate || function() {
      return true;
    };
    this.meshes.filter(filterPredicate).forEach(function(mesh) {
      mesh.computeWorldMatrix(true);
      if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {
        return;
      }
      var boundingInfo = mesh.getBoundingInfo();
      var minBox = boundingInfo.boundingBox.minimumWorld;
      var maxBox = boundingInfo.boundingBox.maximumWorld;
      Vector3.CheckExtends(minBox, min, max);
      Vector3.CheckExtends(maxBox, min, max);
    });
    return {
      min,
      max
    };
  };
  Scene2.prototype.createPickingRay = function(x, y, world, camera, cameraViewSpace) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.createPickingRayToRef = function(x, y, world, result, camera, cameraViewSpace, enableDistantPicking) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.createPickingRayInCameraSpace = function(x, y, camera) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.createPickingRayInCameraSpaceToRef = function(x, y, result, camera) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.pick = function(x, y, predicate, fastCheck, camera, trianglePredicate) {
    var pi = new PickingInfo();
    pi._pickingUnavailable = true;
    return pi;
  };
  Scene2.prototype.pickWithBoundingInfo = function(x, y, predicate, fastCheck, camera) {
    var pi = new PickingInfo();
    pi._pickingUnavailable = true;
    return pi;
  };
  Scene2.prototype.pickWithRay = function(ray, predicate, fastCheck, trianglePredicate) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.multiPick = function(x, y, predicate, camera, trianglePredicate) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.multiPickWithRay = function(ray, predicate, trianglePredicate) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.setPointerOverMesh = function(mesh, pointerId, pickResult) {
    this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);
  };
  Scene2.prototype.getPointerOverMesh = function() {
    return this._inputManager.getPointerOverMesh();
  };
  Scene2.prototype._rebuildGeometries = function() {
    for (var _i = 0, _a = this.geometries; _i < _a.length; _i++) {
      var geometry = _a[_i];
      geometry._rebuild();
    }
    for (var _b = 0, _c = this.meshes; _b < _c.length; _b++) {
      var mesh = _c[_b];
      mesh._rebuild();
    }
    if (this.postProcessManager) {
      this.postProcessManager._rebuild();
    }
    for (var _d = 0, _e = this._components; _d < _e.length; _d++) {
      var component = _e[_d];
      component.rebuild();
    }
    for (var _f = 0, _g = this.particleSystems; _f < _g.length; _f++) {
      var system = _g[_f];
      system.rebuild();
    }
    if (this.spriteManagers) {
      for (var _h = 0, _j = this.spriteManagers; _h < _j.length; _h++) {
        var spriteMgr = _j[_h];
        spriteMgr.rebuild();
      }
    }
  };
  Scene2.prototype._rebuildTextures = function() {
    for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {
      var texture = _a[_i];
      texture._rebuild();
    }
    this.markAllMaterialsAsDirty(1);
  };
  Scene2.prototype._getByTags = function(list, tagsQuery, forEach) {
    if (tagsQuery === void 0) {
      return list;
    }
    var listByTags = [];
    forEach = forEach || function(item2) {
      return;
    };
    for (var i in list) {
      var item = list[i];
      if (Tags && Tags.MatchesQuery(item, tagsQuery)) {
        listByTags.push(item);
        forEach(item);
      }
    }
    return listByTags;
  };
  Scene2.prototype.getMeshesByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.meshes, tagsQuery, forEach);
  };
  Scene2.prototype.getCamerasByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.cameras, tagsQuery, forEach);
  };
  Scene2.prototype.getLightsByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.lights, tagsQuery, forEach);
  };
  Scene2.prototype.getMaterialByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));
  };
  Scene2.prototype.getTransformNodesByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.transformNodes, tagsQuery, forEach);
  };
  Scene2.prototype.setRenderingOrder = function(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
    if (opaqueSortCompareFn === void 0) {
      opaqueSortCompareFn = null;
    }
    if (alphaTestSortCompareFn === void 0) {
      alphaTestSortCompareFn = null;
    }
    if (transparentSortCompareFn === void 0) {
      transparentSortCompareFn = null;
    }
    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
  };
  Scene2.prototype.setRenderingAutoClearDepthStencil = function(renderingGroupId, autoClearDepthStencil, depth, stencil) {
    if (depth === void 0) {
      depth = true;
    }
    if (stencil === void 0) {
      stencil = true;
    }
    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);
  };
  Scene2.prototype.getAutoClearDepthStencilSetup = function(index) {
    return this._renderingManager.getAutoClearDepthStencilSetup(index);
  };
  Object.defineProperty(Scene2.prototype, "blockMaterialDirtyMechanism", {
    get: function() {
      return this._blockMaterialDirtyMechanism;
    },
    set: function(value) {
      if (this._blockMaterialDirtyMechanism === value) {
        return;
      }
      this._blockMaterialDirtyMechanism = value;
      if (!value) {
        this.markAllMaterialsAsDirty(63);
      }
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.markAllMaterialsAsDirty = function(flag, predicate) {
    if (this._blockMaterialDirtyMechanism) {
      return;
    }
    for (var _i = 0, _a = this.materials; _i < _a.length; _i++) {
      var material = _a[_i];
      if (predicate && !predicate(material)) {
        continue;
      }
      material.markAsDirty(flag);
    }
  };
  Scene2.prototype._loadFile = function(fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
    var _this = this;
    var request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
    this._activeRequests.push(request);
    request.onCompleteObservable.add(function(request2) {
      _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
    });
    return request;
  };
  Scene2.prototype._loadFileAsync = function(fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._loadFile(fileOrUrl, function(data) {
        resolve(data);
      }, onProgress, useOfflineSupport, useArrayBuffer, function(request, exception) {
        reject(exception);
      }, onOpened);
    });
  };
  Scene2.prototype._requestFile = function(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
    var _this = this;
    var request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
    this._activeRequests.push(request);
    request.onCompleteObservable.add(function(request2) {
      _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
    });
    return request;
  };
  Scene2.prototype._requestFileAsync = function(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._requestFile(url, function(data) {
        resolve(data);
      }, onProgress, useOfflineSupport, useArrayBuffer, function(error) {
        reject(error);
      }, onOpened);
    });
  };
  Scene2.prototype._readFile = function(file, onSuccess, onProgress, useArrayBuffer, onError) {
    var _this = this;
    var request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
    this._activeRequests.push(request);
    request.onCompleteObservable.add(function(request2) {
      _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
    });
    return request;
  };
  Scene2.prototype._readFileAsync = function(file, onProgress, useArrayBuffer) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._readFile(file, function(data) {
        resolve(data);
      }, onProgress, useArrayBuffer, function(error) {
        reject(error);
      });
    });
  };
  Scene2.prototype.getPerfCollector = function() {
    throw _WarnImport("performanceViewerSceneExtension");
  };
  Scene2.FOGMODE_NONE = 0;
  Scene2.FOGMODE_EXP = 1;
  Scene2.FOGMODE_EXP2 = 2;
  Scene2.FOGMODE_LINEAR = 3;
  Scene2.MinDeltaTime = 1;
  Scene2.MaxDeltaTime = 1e3;
  return Scene2;
}(AbstractScene);
_injectLTSScene(Scene);
function inlineScheduler(coroutine, onStep, onError) {
  try {
    var step_1 = coroutine.next();
    if (step_1.done) {
      onStep(step_1);
    } else if (!step_1.value) {
      onStep(step_1);
    } else {
      step_1.value.then(function() {
        step_1.value = void 0;
        onStep(step_1);
      }, onError);
    }
  } catch (error) {
    onError(error);
  }
}
function createYieldingScheduler(yieldAfterMS) {
  if (yieldAfterMS === void 0) {
    yieldAfterMS = 25;
  }
  var startTime;
  return function(coroutine, onStep, onError) {
    var currentTime = performance.now();
    if (startTime === void 0 || currentTime - startTime > yieldAfterMS) {
      startTime = currentTime;
      setTimeout(function() {
        inlineScheduler(coroutine, onStep, onError);
      }, 0);
    } else {
      inlineScheduler(coroutine, onStep, onError);
    }
  };
}
function runCoroutine(coroutine, scheduler, onSuccess, onError, abortSignal) {
  var resume = function() {
    var reschedule;
    var onStep = function(stepResult) {
      if (stepResult.done) {
        onSuccess(stepResult.value);
      } else {
        if (reschedule === void 0) {
          reschedule = true;
        } else {
          resume();
        }
      }
    };
    do {
      reschedule = void 0;
      if (!abortSignal || !abortSignal.aborted) {
        scheduler(coroutine, onStep, onError);
      } else {
        onError(new Error("Aborted"));
      }
      if (reschedule === void 0) {
        reschedule = false;
      }
    } while (reschedule);
  };
  resume();
}
function runCoroutineSync(coroutine, abortSignal) {
  var result;
  runCoroutine(coroutine, inlineScheduler, function(r) {
    return result = r;
  }, function(e) {
    throw e;
  }, abortSignal);
  return result;
}
function runCoroutineAsync(coroutine, scheduler, abortSignal) {
  return new Promise(function(resolve, reject) {
    runCoroutine(coroutine, scheduler, resolve, reject, abortSignal);
  });
}
function makeSyncFunction(coroutineFactory, abortSignal) {
  return function() {
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    return runCoroutineSync(coroutineFactory.apply(void 0, params), abortSignal);
  };
}
var _InternalNodeDataInfo = function() {
  function _InternalNodeDataInfo2() {
    this._doNotSerialize = false;
    this._isDisposed = false;
    this._sceneRootNodesIndex = -1;
    this._isEnabled = true;
    this._isParentEnabled = true;
    this._isReady = true;
    this._onEnabledStateChangedObservable = new Observable();
    this._onClonedObservable = new Observable();
  }
  return _InternalNodeDataInfo2;
}();
var Node = function() {
  function Node2(name2, scene) {
    if (scene === void 0) {
      scene = null;
    }
    this._isDirty = false;
    this._nodeDataStorage = new _InternalNodeDataInfo();
    this.state = "";
    this.metadata = null;
    this.reservedDataStore = null;
    this._parentContainer = null;
    this.animations = new Array();
    this._ranges = {};
    this.onReady = null;
    this._currentRenderId = -1;
    this._parentUpdateId = -1;
    this._childUpdateId = -1;
    this._waitingParentId = null;
    this._cache = {};
    this._parentNode = null;
    this._children = null;
    this._worldMatrix = Matrix.Identity();
    this._worldMatrixDeterminant = 0;
    this._worldMatrixDeterminantIsDirty = true;
    this._animationPropertiesOverride = null;
    this._isNode = true;
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this._behaviors = new Array();
    this.name = name2;
    this.id = name2;
    this._scene = scene || EngineStore.LastCreatedScene;
    this.uniqueId = this._scene.getUniqueId();
    this._initCache();
  }
  Node2.AddNodeConstructor = function(type, constructorFunc) {
    this._NodeConstructors[type] = constructorFunc;
  };
  Node2.Construct = function(type, name2, scene, options) {
    var constructorFunc = this._NodeConstructors[type];
    if (!constructorFunc) {
      return null;
    }
    return constructorFunc(name2, scene, options);
  };
  Object.defineProperty(Node2.prototype, "doNotSerialize", {
    get: function() {
      if (this._nodeDataStorage._doNotSerialize) {
        return true;
      }
      if (this._parentNode) {
        return this._parentNode.doNotSerialize;
      }
      return false;
    },
    set: function(value) {
      this._nodeDataStorage._doNotSerialize = value;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype.isDisposed = function() {
    return this._nodeDataStorage._isDisposed;
  };
  Object.defineProperty(Node2.prototype, "parent", {
    get: function() {
      return this._parentNode;
    },
    set: function(parent) {
      if (this._parentNode === parent) {
        return;
      }
      var previousParentNode = this._parentNode;
      if (this._parentNode && this._parentNode._children !== void 0 && this._parentNode._children !== null) {
        var index = this._parentNode._children.indexOf(this);
        if (index !== -1) {
          this._parentNode._children.splice(index, 1);
        }
        if (!parent && !this._nodeDataStorage._isDisposed) {
          this._addToSceneRootNodes();
        }
      }
      this._parentNode = parent;
      if (this._parentNode) {
        if (this._parentNode._children === void 0 || this._parentNode._children === null) {
          this._parentNode._children = new Array();
        }
        this._parentNode._children.push(this);
        if (!previousParentNode) {
          this._removeFromSceneRootNodes();
        }
      }
      this._syncParentEnabledState();
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype._addToSceneRootNodes = function() {
    if (this._nodeDataStorage._sceneRootNodesIndex === -1) {
      this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length;
      this._scene.rootNodes.push(this);
    }
  };
  Node2.prototype._removeFromSceneRootNodes = function() {
    if (this._nodeDataStorage._sceneRootNodesIndex !== -1) {
      var rootNodes = this._scene.rootNodes;
      var lastIdx = rootNodes.length - 1;
      rootNodes[this._nodeDataStorage._sceneRootNodesIndex] = rootNodes[lastIdx];
      rootNodes[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex;
      this._scene.rootNodes.pop();
      this._nodeDataStorage._sceneRootNodesIndex = -1;
    }
  };
  Object.defineProperty(Node2.prototype, "animationPropertiesOverride", {
    get: function() {
      if (!this._animationPropertiesOverride) {
        return this._scene.animationPropertiesOverride;
      }
      return this._animationPropertiesOverride;
    },
    set: function(value) {
      this._animationPropertiesOverride = value;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype.getClassName = function() {
    return "Node";
  };
  Object.defineProperty(Node2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node2.prototype, "onEnabledStateChangedObservable", {
    get: function() {
      return this._nodeDataStorage._onEnabledStateChangedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node2.prototype, "onClonedObservable", {
    get: function() {
      return this._nodeDataStorage._onClonedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype.getScene = function() {
    return this._scene;
  };
  Node2.prototype.getEngine = function() {
    return this._scene.getEngine();
  };
  Node2.prototype.addBehavior = function(behavior, attachImmediately) {
    var _this = this;
    if (attachImmediately === void 0) {
      attachImmediately = false;
    }
    var index = this._behaviors.indexOf(behavior);
    if (index !== -1) {
      return this;
    }
    behavior.init();
    if (this._scene.isLoading && !attachImmediately) {
      this._scene.onDataLoadedObservable.addOnce(function() {
        behavior.attach(_this);
      });
    } else {
      behavior.attach(this);
    }
    this._behaviors.push(behavior);
    return this;
  };
  Node2.prototype.removeBehavior = function(behavior) {
    var index = this._behaviors.indexOf(behavior);
    if (index === -1) {
      return this;
    }
    this._behaviors[index].detach();
    this._behaviors.splice(index, 1);
    return this;
  };
  Object.defineProperty(Node2.prototype, "behaviors", {
    get: function() {
      return this._behaviors;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype.getBehaviorByName = function(name2) {
    for (var _i = 0, _a = this._behaviors; _i < _a.length; _i++) {
      var behavior = _a[_i];
      if (behavior.name === name2) {
        return behavior;
      }
    }
    return null;
  };
  Node2.prototype.getWorldMatrix = function() {
    if (this._currentRenderId !== this._scene.getRenderId()) {
      this.computeWorldMatrix();
    }
    return this._worldMatrix;
  };
  Node2.prototype._getWorldMatrixDeterminant = function() {
    if (this._worldMatrixDeterminantIsDirty) {
      this._worldMatrixDeterminantIsDirty = false;
      this._worldMatrixDeterminant = this._worldMatrix.determinant();
    }
    return this._worldMatrixDeterminant;
  };
  Object.defineProperty(Node2.prototype, "worldMatrixFromCache", {
    get: function() {
      return this._worldMatrix;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype._initCache = function() {
    this._cache = {};
    this._cache.parent = void 0;
  };
  Node2.prototype.updateCache = function(force) {
    if (!force && this.isSynchronized()) {
      return;
    }
    this._cache.parent = this.parent;
    this._updateCache();
  };
  Node2.prototype._getActionManagerForTrigger = function(trigger, initialCall) {
    if (!this.parent) {
      return null;
    }
    return this.parent._getActionManagerForTrigger(trigger, false);
  };
  Node2.prototype._updateCache = function(ignoreParentClass) {
  };
  Node2.prototype._isSynchronized = function() {
    return true;
  };
  Node2.prototype._markSyncedWithParent = function() {
    if (this._parentNode) {
      this._parentUpdateId = this._parentNode._childUpdateId;
    }
  };
  Node2.prototype.isSynchronizedWithParent = function() {
    if (!this._parentNode) {
      return true;
    }
    if (this._parentNode._isDirty || this._parentUpdateId !== this._parentNode._childUpdateId) {
      return false;
    }
    return this._parentNode.isSynchronized();
  };
  Node2.prototype.isSynchronized = function() {
    if (this._cache.parent != this._parentNode) {
      this._cache.parent = this._parentNode;
      return false;
    }
    if (this._parentNode && !this.isSynchronizedWithParent()) {
      return false;
    }
    return this._isSynchronized();
  };
  Node2.prototype.isReady = function(completeCheck) {
    return this._nodeDataStorage._isReady;
  };
  Node2.prototype.markAsDirty = function(property) {
    this._currentRenderId = Number.MAX_VALUE;
    this._isDirty = true;
    return this;
  };
  Node2.prototype.isEnabled = function(checkAncestors) {
    if (checkAncestors === void 0) {
      checkAncestors = true;
    }
    if (checkAncestors === false) {
      return this._nodeDataStorage._isEnabled;
    }
    if (!this._nodeDataStorage._isEnabled) {
      return false;
    }
    return this._nodeDataStorage._isParentEnabled;
  };
  Node2.prototype._syncParentEnabledState = function() {
    this._nodeDataStorage._isParentEnabled = this._parentNode ? this._parentNode.isEnabled() : true;
    if (this._children) {
      this._children.forEach(function(c) {
        c._syncParentEnabledState();
      });
    }
  };
  Node2.prototype.setEnabled = function(value) {
    if (this._nodeDataStorage._isEnabled === value) {
      return;
    }
    this._nodeDataStorage._isEnabled = value;
    this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(value);
    this._syncParentEnabledState();
  };
  Node2.prototype.isDescendantOf = function(ancestor) {
    if (this.parent) {
      if (this.parent === ancestor) {
        return true;
      }
      return this.parent.isDescendantOf(ancestor);
    }
    return false;
  };
  Node2.prototype._getDescendants = function(results, directDescendantsOnly, predicate) {
    if (directDescendantsOnly === void 0) {
      directDescendantsOnly = false;
    }
    if (!this._children) {
      return;
    }
    for (var index = 0; index < this._children.length; index++) {
      var item = this._children[index];
      if (!predicate || predicate(item)) {
        results.push(item);
      }
      if (!directDescendantsOnly) {
        item._getDescendants(results, false, predicate);
      }
    }
  };
  Node2.prototype.getDescendants = function(directDescendantsOnly, predicate) {
    var results = new Array();
    this._getDescendants(results, directDescendantsOnly, predicate);
    return results;
  };
  Node2.prototype.getChildMeshes = function(directDescendantsOnly, predicate) {
    var results = [];
    this._getDescendants(results, directDescendantsOnly, function(node) {
      return (!predicate || predicate(node)) && node.cullingStrategy !== void 0;
    });
    return results;
  };
  Node2.prototype.getChildren = function(predicate, directDescendantsOnly) {
    if (directDescendantsOnly === void 0) {
      directDescendantsOnly = true;
    }
    return this.getDescendants(directDescendantsOnly, predicate);
  };
  Node2.prototype._setReady = function(state) {
    if (state === this._nodeDataStorage._isReady) {
      return;
    }
    if (!state) {
      this._nodeDataStorage._isReady = false;
      return;
    }
    if (this.onReady) {
      this.onReady(this);
    }
    this._nodeDataStorage._isReady = true;
  };
  Node2.prototype.getAnimationByName = function(name2) {
    for (var i = 0; i < this.animations.length; i++) {
      var animation = this.animations[i];
      if (animation.name === name2) {
        return animation;
      }
    }
    return null;
  };
  Node2.prototype.createAnimationRange = function(name2, from, to) {
    if (!this._ranges[name2]) {
      this._ranges[name2] = Node2._AnimationRangeFactory(name2, from, to);
      for (var i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
        if (this.animations[i]) {
          this.animations[i].createRange(name2, from, to);
        }
      }
    }
  };
  Node2.prototype.deleteAnimationRange = function(name2, deleteFrames) {
    if (deleteFrames === void 0) {
      deleteFrames = true;
    }
    for (var i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
      if (this.animations[i]) {
        this.animations[i].deleteRange(name2, deleteFrames);
      }
    }
    this._ranges[name2] = null;
  };
  Node2.prototype.getAnimationRange = function(name2) {
    return this._ranges[name2] || null;
  };
  Node2.prototype.getAnimationRanges = function() {
    var animationRanges = [];
    var name2;
    for (name2 in this._ranges) {
      animationRanges.push(this._ranges[name2]);
    }
    return animationRanges;
  };
  Node2.prototype.beginAnimation = function(name2, loop, speedRatio, onAnimationEnd) {
    var range = this.getAnimationRange(name2);
    if (!range) {
      return null;
    }
    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
  };
  Node2.prototype.serializeAnimationRanges = function() {
    var serializationRanges = [];
    for (var name2 in this._ranges) {
      var localRange = this._ranges[name2];
      if (!localRange) {
        continue;
      }
      var range = {};
      range.name = name2;
      range.from = localRange.from;
      range.to = localRange.to;
      serializationRanges.push(range);
    }
    return serializationRanges;
  };
  Node2.prototype.computeWorldMatrix = function(force) {
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    return this._worldMatrix;
  };
  Node2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this._nodeDataStorage._isDisposed = true;
    if (!doNotRecurse) {
      var nodes = this.getDescendants(true);
      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var node = nodes_1[_i];
        node.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
    }
    if (!this.parent) {
      this._removeFromSceneRootNodes();
    } else {
      this.parent = null;
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onEnabledStateChangedObservable.clear();
    this.onClonedObservable.clear();
    for (var _a = 0, _b = this._behaviors; _a < _b.length; _a++) {
      var behavior = _b[_a];
      behavior.detach();
    }
    this._behaviors = [];
    this.metadata = null;
  };
  Node2.ParseAnimationRanges = function(node, parsedNode, scene) {
    if (parsedNode.ranges) {
      for (var index = 0; index < parsedNode.ranges.length; index++) {
        var data = parsedNode.ranges[index];
        node.createAnimationRange(data.name, data.from, data.to);
      }
    }
  };
  Node2.prototype.getHierarchyBoundingVectors = function(includeDescendants, predicate) {
    if (includeDescendants === void 0) {
      includeDescendants = true;
    }
    if (predicate === void 0) {
      predicate = null;
    }
    this.getScene().incrementRenderId();
    this.computeWorldMatrix(true);
    var min;
    var max;
    var thisAbstractMesh = this;
    if (thisAbstractMesh.getBoundingInfo && thisAbstractMesh.subMeshes) {
      var boundingInfo = thisAbstractMesh.getBoundingInfo();
      min = boundingInfo.boundingBox.minimumWorld.clone();
      max = boundingInfo.boundingBox.maximumWorld.clone();
    } else {
      min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    }
    if (includeDescendants) {
      var descendants = this.getDescendants(false);
      for (var _i = 0, descendants_1 = descendants; _i < descendants_1.length; _i++) {
        var descendant = descendants_1[_i];
        var childMesh = descendant;
        childMesh.computeWorldMatrix(true);
        if (predicate && !predicate(childMesh)) {
          continue;
        }
        if (!childMesh.getBoundingInfo || childMesh.getTotalVertices() === 0) {
          continue;
        }
        var childBoundingInfo = childMesh.getBoundingInfo();
        var boundingBox = childBoundingInfo.boundingBox;
        var minBox = boundingBox.minimumWorld;
        var maxBox = boundingBox.maximumWorld;
        Vector3.CheckExtends(minBox, min, max);
        Vector3.CheckExtends(maxBox, min, max);
      }
    }
    return {
      min,
      max
    };
  };
  Node2._AnimationRangeFactory = function(name2, from, to) {
    throw _WarnImport("AnimationRange");
  };
  Node2._NodeConstructors = {};
  __decorate([
    serialize()
  ], Node2.prototype, "name", void 0);
  __decorate([
    serialize()
  ], Node2.prototype, "id", void 0);
  __decorate([
    serialize()
  ], Node2.prototype, "uniqueId", void 0);
  __decorate([
    serialize()
  ], Node2.prototype, "state", void 0);
  __decorate([
    serialize()
  ], Node2.prototype, "metadata", void 0);
  return Node2;
}();
var VertexData = function() {
  function VertexData2() {
    this._applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));
  }
  VertexData2.prototype.set = function(data, kind) {
    if (!data.length) {
      Logger.Warn("Setting vertex data kind '".concat(kind, "' with an empty array"));
    }
    switch (kind) {
      case VertexBuffer.PositionKind:
        this.positions = data;
        break;
      case VertexBuffer.NormalKind:
        this.normals = data;
        break;
      case VertexBuffer.TangentKind:
        this.tangents = data;
        break;
      case VertexBuffer.UVKind:
        this.uvs = data;
        break;
      case VertexBuffer.UV2Kind:
        this.uvs2 = data;
        break;
      case VertexBuffer.UV3Kind:
        this.uvs3 = data;
        break;
      case VertexBuffer.UV4Kind:
        this.uvs4 = data;
        break;
      case VertexBuffer.UV5Kind:
        this.uvs5 = data;
        break;
      case VertexBuffer.UV6Kind:
        this.uvs6 = data;
        break;
      case VertexBuffer.ColorKind:
        this.colors = data;
        break;
      case VertexBuffer.MatricesIndicesKind:
        this.matricesIndices = data;
        break;
      case VertexBuffer.MatricesWeightsKind:
        this.matricesWeights = data;
        break;
      case VertexBuffer.MatricesIndicesExtraKind:
        this.matricesIndicesExtra = data;
        break;
      case VertexBuffer.MatricesWeightsExtraKind:
        this.matricesWeightsExtra = data;
        break;
    }
  };
  VertexData2.prototype.applyToMesh = function(mesh, updatable) {
    this._applyTo(mesh, updatable, false);
    return this;
  };
  VertexData2.prototype.applyToGeometry = function(geometry, updatable) {
    this._applyTo(geometry, updatable, false);
    return this;
  };
  VertexData2.prototype.updateMesh = function(mesh) {
    this._update(mesh);
    return this;
  };
  VertexData2.prototype.updateGeometry = function(geometry) {
    this._update(geometry);
    return this;
  };
  VertexData2.prototype._applyToCoroutine = function(meshOrGeometry, updatable, isAsync) {
    if (updatable === void 0) {
      updatable = false;
    }
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          if (!this.positions)
            return [3, 2];
          meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);
          if (!isAsync)
            return [3, 2];
          return [4];
        case 1:
          _a.sent();
          _a.label = 2;
        case 2:
          if (!this.normals)
            return [3, 4];
          meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);
          if (!isAsync)
            return [3, 4];
          return [4];
        case 3:
          _a.sent();
          _a.label = 4;
        case 4:
          if (!this.tangents)
            return [3, 6];
          meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);
          if (!isAsync)
            return [3, 6];
          return [4];
        case 5:
          _a.sent();
          _a.label = 6;
        case 6:
          if (!this.uvs)
            return [3, 8];
          meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);
          if (!isAsync)
            return [3, 8];
          return [4];
        case 7:
          _a.sent();
          _a.label = 8;
        case 8:
          if (!this.uvs2)
            return [3, 10];
          meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);
          if (!isAsync)
            return [3, 10];
          return [4];
        case 9:
          _a.sent();
          _a.label = 10;
        case 10:
          if (!this.uvs3)
            return [3, 12];
          meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);
          if (!isAsync)
            return [3, 12];
          return [4];
        case 11:
          _a.sent();
          _a.label = 12;
        case 12:
          if (!this.uvs4)
            return [3, 14];
          meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);
          if (!isAsync)
            return [3, 14];
          return [4];
        case 13:
          _a.sent();
          _a.label = 14;
        case 14:
          if (!this.uvs5)
            return [3, 16];
          meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);
          if (!isAsync)
            return [3, 16];
          return [4];
        case 15:
          _a.sent();
          _a.label = 16;
        case 16:
          if (!this.uvs6)
            return [3, 18];
          meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);
          if (!isAsync)
            return [3, 18];
          return [4];
        case 17:
          _a.sent();
          _a.label = 18;
        case 18:
          if (!this.colors)
            return [3, 20];
          meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);
          if (!isAsync)
            return [3, 20];
          return [4];
        case 19:
          _a.sent();
          _a.label = 20;
        case 20:
          if (!this.matricesIndices)
            return [3, 22];
          meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);
          if (!isAsync)
            return [3, 22];
          return [4];
        case 21:
          _a.sent();
          _a.label = 22;
        case 22:
          if (!this.matricesWeights)
            return [3, 24];
          meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);
          if (!isAsync)
            return [3, 24];
          return [4];
        case 23:
          _a.sent();
          _a.label = 24;
        case 24:
          if (!this.matricesIndicesExtra)
            return [3, 26];
          meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);
          if (!isAsync)
            return [3, 26];
          return [4];
        case 25:
          _a.sent();
          _a.label = 26;
        case 26:
          if (!this.matricesWeightsExtra)
            return [3, 28];
          meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);
          if (!isAsync)
            return [3, 28];
          return [4];
        case 27:
          _a.sent();
          _a.label = 28;
        case 28:
          if (!this.indices)
            return [3, 31];
          meshOrGeometry.setIndices(this.indices, null, updatable);
          if (!isAsync)
            return [3, 30];
          return [4];
        case 29:
          _a.sent();
          _a.label = 30;
        case 30:
          return [3, 32];
        case 31:
          meshOrGeometry.setIndices([], null);
          _a.label = 32;
        case 32:
          return [2, this];
      }
    });
  };
  VertexData2.prototype._update = function(meshOrGeometry, updateExtends, makeItUnique) {
    if (this.positions) {
      meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);
    }
    if (this.normals) {
      meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);
    }
    if (this.tangents) {
      meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);
    }
    if (this.uvs) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);
    }
    if (this.uvs2) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);
    }
    if (this.uvs3) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);
    }
    if (this.uvs4) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);
    }
    if (this.uvs5) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);
    }
    if (this.uvs6) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);
    }
    if (this.colors) {
      meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);
    }
    if (this.matricesIndices) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);
    }
    if (this.matricesWeights) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);
    }
    if (this.matricesIndicesExtra) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);
    }
    if (this.matricesWeightsExtra) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);
    }
    if (this.indices) {
      meshOrGeometry.setIndices(this.indices, null);
    }
    return this;
  };
  VertexData2._TransformVector3Coordinates = function(coordinates, transformation, offset, length) {
    if (offset === void 0) {
      offset = 0;
    }
    if (length === void 0) {
      length = coordinates.length;
    }
    var coordinate = TmpVectors.Vector3[0];
    var transformedCoordinate = TmpVectors.Vector3[1];
    for (var index = offset; index < offset + length; index += 3) {
      Vector3.FromArrayToRef(coordinates, index, coordinate);
      Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);
      coordinates[index] = transformedCoordinate.x;
      coordinates[index + 1] = transformedCoordinate.y;
      coordinates[index + 2] = transformedCoordinate.z;
    }
  };
  VertexData2._TransformVector3Normals = function(normals, transformation, offset, length) {
    if (offset === void 0) {
      offset = 0;
    }
    if (length === void 0) {
      length = normals.length;
    }
    var normal = TmpVectors.Vector3[0];
    var transformedNormal = TmpVectors.Vector3[1];
    for (var index = offset; index < offset + length; index += 3) {
      Vector3.FromArrayToRef(normals, index, normal);
      Vector3.TransformNormalToRef(normal, transformation, transformedNormal);
      normals[index] = transformedNormal.x;
      normals[index + 1] = transformedNormal.y;
      normals[index + 2] = transformedNormal.z;
    }
  };
  VertexData2._TransformVector4Normals = function(normals, transformation, offset, length) {
    if (offset === void 0) {
      offset = 0;
    }
    if (length === void 0) {
      length = normals.length;
    }
    var normal = TmpVectors.Vector4[0];
    var transformedNormal = TmpVectors.Vector4[1];
    for (var index = offset; index < offset + length; index += 4) {
      Vector4.FromArrayToRef(normals, index, normal);
      Vector4.TransformNormalToRef(normal, transformation, transformedNormal);
      normals[index] = transformedNormal.x;
      normals[index + 1] = transformedNormal.y;
      normals[index + 2] = transformedNormal.z;
      normals[index + 3] = transformedNormal.w;
    }
  };
  VertexData2._FlipFaces = function(indices, offset, length) {
    if (offset === void 0) {
      offset = 0;
    }
    if (length === void 0) {
      length = indices.length;
    }
    for (var index = offset; index < offset + length; index += 3) {
      var tmp = indices[index + 1];
      indices[index + 1] = indices[index + 2];
      indices[index + 2] = tmp;
    }
  };
  VertexData2.prototype.transform = function(matrix) {
    var flip = matrix.determinant() < 0;
    if (this.positions) {
      VertexData2._TransformVector3Coordinates(this.positions, matrix);
    }
    if (this.normals) {
      VertexData2._TransformVector3Normals(this.normals, matrix);
    }
    if (this.tangents) {
      VertexData2._TransformVector4Normals(this.tangents, matrix);
    }
    if (flip && this.indices) {
      VertexData2._FlipFaces(this.indices);
    }
    return this;
  };
  VertexData2.prototype.merge = function(others, use32BitsIndices, forceCloneIndices) {
    if (use32BitsIndices === void 0) {
      use32BitsIndices = false;
    }
    if (forceCloneIndices === void 0) {
      forceCloneIndices = false;
    }
    var vertexDatas = Array.isArray(others) ? others.map(function(other) {
      return [other, void 0];
    }) : [[others, void 0]];
    return runCoroutineSync(this._mergeCoroutine(void 0, vertexDatas, use32BitsIndices, false, forceCloneIndices));
  };
  VertexData2.prototype._mergeCoroutine = function(transform, vertexDatas, use32BitsIndices, isAsync, forceCloneIndices) {
    var others, _i, others_1, other, totalIndices, sliceIndices, indices, indicesOffset, temp, positionsOffset, _a, vertexDatas_1, _b, other, transform_1, index;
    var _this = this;
    var _c, _d, _e, _f;
    if (use32BitsIndices === void 0) {
      use32BitsIndices = false;
    }
    return __generator(this, function(_g) {
      switch (_g.label) {
        case 0:
          this._validate();
          others = vertexDatas.map(function(vertexData) {
            return vertexData[0];
          });
          for (_i = 0, others_1 = others; _i < others_1.length; _i++) {
            other = others_1[_i];
            other._validate();
            if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {
              throw new Error("Cannot merge vertex data that do not have the same set of attributes");
            }
          }
          totalIndices = others.reduce(function(indexSum, vertexData) {
            var _a2, _b2;
            return indexSum + ((_b2 = (_a2 = vertexData.indices) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b2 !== void 0 ? _b2 : 0);
          }, (_d = (_c = this.indices) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0);
          sliceIndices = forceCloneIndices || others.some(function(vertexData) {
            return vertexData.indices === _this.indices;
          });
          indices = sliceIndices ? (_e = this.indices) === null || _e === void 0 ? void 0 : _e.slice() : this.indices;
          if (!(totalIndices > 0))
            return [3, 4];
          indicesOffset = (_f = indices === null || indices === void 0 ? void 0 : indices.length) !== null && _f !== void 0 ? _f : 0;
          if (!indices) {
            indices = new Array(totalIndices);
          }
          if (indices.length !== totalIndices) {
            if (Array.isArray(indices)) {
              indices.length = totalIndices;
            } else {
              temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);
              temp.set(indices);
              indices = temp;
            }
            if (transform && transform.determinant() < 0) {
              VertexData2._FlipFaces(indices, 0, indicesOffset);
            }
          }
          positionsOffset = this.positions ? this.positions.length / 3 : 0;
          _a = 0, vertexDatas_1 = vertexDatas;
          _g.label = 1;
        case 1:
          if (!(_a < vertexDatas_1.length))
            return [3, 4];
          _b = vertexDatas_1[_a], other = _b[0], transform_1 = _b[1];
          if (!other.indices)
            return [3, 3];
          for (index = 0; index < other.indices.length; index++) {
            indices[indicesOffset + index] = other.indices[index] + positionsOffset;
          }
          if (transform_1 && transform_1.determinant() < 0) {
            VertexData2._FlipFaces(indices, indicesOffset, other.indices.length);
          }
          positionsOffset += other.positions.length / 3;
          indicesOffset += other.indices.length;
          if (!isAsync)
            return [3, 3];
          return [4];
        case 2:
          _g.sent();
          _g.label = 3;
        case 3:
          _a++;
          return [3, 1];
        case 4:
          this.indices = indices;
          this.positions = VertexData2._mergeElement(VertexBuffer.PositionKind, this.positions, transform, vertexDatas.map(function(other2) {
            return [other2[0].positions, other2[1]];
          }));
          if (!isAsync)
            return [3, 6];
          return [4];
        case 5:
          _g.sent();
          _g.label = 6;
        case 6:
          this.normals = VertexData2._mergeElement(VertexBuffer.NormalKind, this.normals, transform, vertexDatas.map(function(other2) {
            return [other2[0].normals, other2[1]];
          }));
          if (!isAsync)
            return [3, 8];
          return [4];
        case 7:
          _g.sent();
          _g.label = 8;
        case 8:
          this.tangents = VertexData2._mergeElement(VertexBuffer.TangentKind, this.tangents, transform, vertexDatas.map(function(other2) {
            return [other2[0].tangents, other2[1]];
          }));
          if (!isAsync)
            return [3, 10];
          return [4];
        case 9:
          _g.sent();
          _g.label = 10;
        case 10:
          this.uvs = VertexData2._mergeElement(VertexBuffer.UVKind, this.uvs, transform, vertexDatas.map(function(other2) {
            return [other2[0].uvs, other2[1]];
          }));
          if (!isAsync)
            return [3, 12];
          return [4];
        case 11:
          _g.sent();
          _g.label = 12;
        case 12:
          this.uvs2 = VertexData2._mergeElement(VertexBuffer.UV2Kind, this.uvs2, transform, vertexDatas.map(function(other2) {
            return [other2[0].uvs2, other2[1]];
          }));
          if (!isAsync)
            return [3, 14];
          return [4];
        case 13:
          _g.sent();
          _g.label = 14;
        case 14:
          this.uvs3 = VertexData2._mergeElement(VertexBuffer.UV3Kind, this.uvs3, transform, vertexDatas.map(function(other2) {
            return [other2[0].uvs3, other2[1]];
          }));
          if (!isAsync)
            return [3, 16];
          return [4];
        case 15:
          _g.sent();
          _g.label = 16;
        case 16:
          this.uvs4 = VertexData2._mergeElement(VertexBuffer.UV4Kind, this.uvs4, transform, vertexDatas.map(function(other2) {
            return [other2[0].uvs4, other2[1]];
          }));
          if (!isAsync)
            return [3, 18];
          return [4];
        case 17:
          _g.sent();
          _g.label = 18;
        case 18:
          this.uvs5 = VertexData2._mergeElement(VertexBuffer.UV5Kind, this.uvs5, transform, vertexDatas.map(function(other2) {
            return [other2[0].uvs5, other2[1]];
          }));
          if (!isAsync)
            return [3, 20];
          return [4];
        case 19:
          _g.sent();
          _g.label = 20;
        case 20:
          this.uvs6 = VertexData2._mergeElement(VertexBuffer.UV6Kind, this.uvs6, transform, vertexDatas.map(function(other2) {
            return [other2[0].uvs6, other2[1]];
          }));
          if (!isAsync)
            return [3, 22];
          return [4];
        case 21:
          _g.sent();
          _g.label = 22;
        case 22:
          this.colors = VertexData2._mergeElement(VertexBuffer.ColorKind, this.colors, transform, vertexDatas.map(function(other2) {
            return [other2[0].colors, other2[1]];
          }));
          if (!isAsync)
            return [3, 24];
          return [4];
        case 23:
          _g.sent();
          _g.label = 24;
        case 24:
          this.matricesIndices = VertexData2._mergeElement(VertexBuffer.MatricesIndicesKind, this.matricesIndices, transform, vertexDatas.map(function(other2) {
            return [other2[0].matricesIndices, other2[1]];
          }));
          if (!isAsync)
            return [3, 26];
          return [4];
        case 25:
          _g.sent();
          _g.label = 26;
        case 26:
          this.matricesWeights = VertexData2._mergeElement(VertexBuffer.MatricesWeightsKind, this.matricesWeights, transform, vertexDatas.map(function(other2) {
            return [other2[0].matricesWeights, other2[1]];
          }));
          if (!isAsync)
            return [3, 28];
          return [4];
        case 27:
          _g.sent();
          _g.label = 28;
        case 28:
          this.matricesIndicesExtra = VertexData2._mergeElement(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, transform, vertexDatas.map(function(other2) {
            return [other2[0].matricesIndicesExtra, other2[1]];
          }));
          if (!isAsync)
            return [3, 30];
          return [4];
        case 29:
          _g.sent();
          _g.label = 30;
        case 30:
          this.matricesWeightsExtra = VertexData2._mergeElement(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, transform, vertexDatas.map(function(other2) {
            return [other2[0].matricesWeightsExtra, other2[1]];
          }));
          return [2, this];
      }
    });
  };
  VertexData2._mergeElement = function(kind, source, transform, others) {
    var nonNullOthers = others.filter(function(other) {
      return other[0] !== null && other[0] !== void 0;
    });
    if (nonNullOthers.length === 0) {
      return source;
    }
    if (!source) {
      return this._mergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));
    }
    var len = nonNullOthers.reduce(function(sumLen, elements) {
      return sumLen + elements[0].length;
    }, source.length);
    var transformRange = kind === VertexBuffer.PositionKind ? VertexData2._TransformVector3Coordinates : kind === VertexBuffer.NormalKind ? VertexData2._TransformVector3Normals : kind === VertexBuffer.TangentKind ? VertexData2._TransformVector4Normals : function() {
    };
    if (source instanceof Float32Array) {
      var ret32 = new Float32Array(len);
      ret32.set(source);
      transform && transformRange(ret32, transform, 0, source.length);
      var offset = source.length;
      for (var _i = 0, nonNullOthers_1 = nonNullOthers; _i < nonNullOthers_1.length; _i++) {
        var _a = nonNullOthers_1[_i], vertexData = _a[0], transform_2 = _a[1];
        ret32.set(vertexData, offset);
        transform_2 && transformRange(ret32, transform_2, offset, vertexData.length);
        offset += vertexData.length;
      }
      return ret32;
    } else {
      var ret = new Array(len);
      for (var i = 0; i < source.length; i++) {
        ret[i] = source[i];
      }
      transform && transformRange(ret, transform, 0, source.length);
      var offset = source.length;
      for (var _b = 0, nonNullOthers_2 = nonNullOthers; _b < nonNullOthers_2.length; _b++) {
        var _c = nonNullOthers_2[_b], vertexData = _c[0], transform_3 = _c[1];
        for (var i = 0; i < vertexData.length; i++) {
          ret[offset + i] = vertexData[i];
        }
        transform_3 && transformRange(ret, transform_3, offset, vertexData.length);
        offset += vertexData.length;
      }
      return ret;
    }
  };
  VertexData2.prototype._validate = function() {
    if (!this.positions) {
      throw new RuntimeError("Positions are required", ErrorCodes.MeshInvalidPositionsError);
    }
    var getElementCount = function(kind, values) {
      var stride = VertexBuffer.DeduceStride(kind);
      if (values.length % stride !== 0) {
        throw new Error("The " + kind + "s array count must be a multiple of " + stride);
      }
      return values.length / stride;
    };
    var positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);
    var validateElementCount = function(kind, values) {
      var elementCount = getElementCount(kind, values);
      if (elementCount !== positionsElementCount) {
        throw new Error("The " + kind + "s element count (" + elementCount + ") does not match the positions count (" + positionsElementCount + ")");
      }
    };
    if (this.normals) {
      validateElementCount(VertexBuffer.NormalKind, this.normals);
    }
    if (this.tangents) {
      validateElementCount(VertexBuffer.TangentKind, this.tangents);
    }
    if (this.uvs) {
      validateElementCount(VertexBuffer.UVKind, this.uvs);
    }
    if (this.uvs2) {
      validateElementCount(VertexBuffer.UV2Kind, this.uvs2);
    }
    if (this.uvs3) {
      validateElementCount(VertexBuffer.UV3Kind, this.uvs3);
    }
    if (this.uvs4) {
      validateElementCount(VertexBuffer.UV4Kind, this.uvs4);
    }
    if (this.uvs5) {
      validateElementCount(VertexBuffer.UV5Kind, this.uvs5);
    }
    if (this.uvs6) {
      validateElementCount(VertexBuffer.UV6Kind, this.uvs6);
    }
    if (this.colors) {
      validateElementCount(VertexBuffer.ColorKind, this.colors);
    }
    if (this.matricesIndices) {
      validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);
    }
    if (this.matricesWeights) {
      validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);
    }
    if (this.matricesIndicesExtra) {
      validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);
    }
    if (this.matricesWeightsExtra) {
      validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);
    }
  };
  VertexData2.prototype.serialize = function() {
    var serializationObject = {};
    if (this.positions) {
      serializationObject.positions = this.positions;
    }
    if (this.normals) {
      serializationObject.normals = this.normals;
    }
    if (this.tangents) {
      serializationObject.tangents = this.tangents;
    }
    if (this.uvs) {
      serializationObject.uvs = this.uvs;
    }
    if (this.uvs2) {
      serializationObject.uvs2 = this.uvs2;
    }
    if (this.uvs3) {
      serializationObject.uvs3 = this.uvs3;
    }
    if (this.uvs4) {
      serializationObject.uvs4 = this.uvs4;
    }
    if (this.uvs5) {
      serializationObject.uvs5 = this.uvs5;
    }
    if (this.uvs6) {
      serializationObject.uvs6 = this.uvs6;
    }
    if (this.colors) {
      serializationObject.colors = this.colors;
    }
    if (this.matricesIndices) {
      serializationObject.matricesIndices = this.matricesIndices;
      serializationObject.matricesIndices._isExpanded = true;
    }
    if (this.matricesWeights) {
      serializationObject.matricesWeights = this.matricesWeights;
    }
    if (this.matricesIndicesExtra) {
      serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;
      serializationObject.matricesIndicesExtra._isExpanded = true;
    }
    if (this.matricesWeightsExtra) {
      serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;
    }
    serializationObject.indices = this.indices;
    return serializationObject;
  };
  VertexData2.ExtractFromMesh = function(mesh, copyWhenShared, forceCopy) {
    return VertexData2._ExtractFrom(mesh, copyWhenShared, forceCopy);
  };
  VertexData2.ExtractFromGeometry = function(geometry, copyWhenShared, forceCopy) {
    return VertexData2._ExtractFrom(geometry, copyWhenShared, forceCopy);
  };
  VertexData2._ExtractFrom = function(meshOrGeometry, copyWhenShared, forceCopy) {
    var result = new VertexData2();
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {
      result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
      result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
      result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
      result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
      result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
      result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {
      result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
      result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);
    }
    result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);
    return result;
  };
  VertexData2.CreateRibbon = function(options) {
    throw _WarnImport("ribbonBuilder");
  };
  VertexData2.CreateBox = function(options) {
    throw _WarnImport("boxBuilder");
  };
  VertexData2.CreateTiledBox = function(options) {
    throw _WarnImport("tiledBoxBuilder");
  };
  VertexData2.CreateTiledPlane = function(options) {
    throw _WarnImport("tiledPlaneBuilder");
  };
  VertexData2.CreateSphere = function(options) {
    throw _WarnImport("sphereBuilder");
  };
  VertexData2.CreateCylinder = function(options) {
    throw _WarnImport("cylinderBuilder");
  };
  VertexData2.CreateTorus = function(options) {
    throw _WarnImport("torusBuilder");
  };
  VertexData2.CreateLineSystem = function(options) {
    throw _WarnImport("linesBuilder");
  };
  VertexData2.CreateDashedLines = function(options) {
    throw _WarnImport("linesBuilder");
  };
  VertexData2.CreateGround = function(options) {
    throw _WarnImport("groundBuilder");
  };
  VertexData2.CreateTiledGround = function(options) {
    throw _WarnImport("groundBuilder");
  };
  VertexData2.CreateGroundFromHeightMap = function(options) {
    throw _WarnImport("groundBuilder");
  };
  VertexData2.CreatePlane = function(options) {
    throw _WarnImport("planeBuilder");
  };
  VertexData2.CreateDisc = function(options) {
    throw _WarnImport("discBuilder");
  };
  VertexData2.CreatePolygon = function(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {
    throw _WarnImport("polygonBuilder");
  };
  VertexData2.CreateIcoSphere = function(options) {
    throw _WarnImport("icoSphereBuilder");
  };
  VertexData2.CreatePolyhedron = function(options) {
    throw _WarnImport("polyhedronBuilder");
  };
  VertexData2.CreateCapsule = function(options) {
    if (options === void 0) {
      options = {
        orientation: Vector3.Up(),
        subdivisions: 2,
        tessellation: 16,
        height: 1,
        radius: 0.25,
        capSubdivisions: 6
      };
    }
    throw _WarnImport("capsuleBuilder");
  };
  VertexData2.CreateTorusKnot = function(options) {
    throw _WarnImport("torusKnotBuilder");
  };
  VertexData2.ComputeNormals = function(positions, indices, normals, options) {
    var index = 0;
    var p1p2x = 0;
    var p1p2y = 0;
    var p1p2z = 0;
    var p3p2x = 0;
    var p3p2y = 0;
    var p3p2z = 0;
    var faceNormalx = 0;
    var faceNormaly = 0;
    var faceNormalz = 0;
    var length = 0;
    var v1x = 0;
    var v1y = 0;
    var v1z = 0;
    var v2x = 0;
    var v2y = 0;
    var v2z = 0;
    var v3x = 0;
    var v3y = 0;
    var v3z = 0;
    var computeFacetNormals = false;
    var computeFacetPositions = false;
    var computeFacetPartitioning = false;
    var computeDepthSort = false;
    var faceNormalSign = 1;
    var ratio = 0;
    var distanceTo = null;
    if (options) {
      computeFacetNormals = options.facetNormals ? true : false;
      computeFacetPositions = options.facetPositions ? true : false;
      computeFacetPartitioning = options.facetPartitioning ? true : false;
      faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;
      ratio = options.ratio || 0;
      computeDepthSort = options.depthSort ? true : false;
      distanceTo = options.distanceTo;
      if (computeDepthSort) {
        if (distanceTo === void 0) {
          distanceTo = Vector3.Zero();
        }
        var depthSortedFacets = options.depthSortedFacets;
      }
    }
    var xSubRatio = 0;
    var ySubRatio = 0;
    var zSubRatio = 0;
    var subSq = 0;
    if (computeFacetPartitioning && options && options.bbSize) {
      var ox = 0;
      var oy = 0;
      var oz = 0;
      var b1x = 0;
      var b1y = 0;
      var b1z = 0;
      var b2x = 0;
      var b2y = 0;
      var b2z = 0;
      var b3x = 0;
      var b3y = 0;
      var b3z = 0;
      var block_idx_o = 0;
      var block_idx_v1 = 0;
      var block_idx_v2 = 0;
      var block_idx_v3 = 0;
      var bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;
      bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;
      xSubRatio = options.subDiv.X * ratio / options.bbSize.x;
      ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;
      zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;
      subSq = options.subDiv.max * options.subDiv.max;
      options.facetPartitioning.length = 0;
    }
    for (index = 0; index < positions.length; index++) {
      normals[index] = 0;
    }
    var nbFaces = indices.length / 3 | 0;
    for (index = 0; index < nbFaces; index++) {
      v1x = indices[index * 3] * 3;
      v1y = v1x + 1;
      v1z = v1x + 2;
      v2x = indices[index * 3 + 1] * 3;
      v2y = v2x + 1;
      v2z = v2x + 2;
      v3x = indices[index * 3 + 2] * 3;
      v3y = v3x + 1;
      v3z = v3x + 2;
      p1p2x = positions[v1x] - positions[v2x];
      p1p2y = positions[v1y] - positions[v2y];
      p1p2z = positions[v1z] - positions[v2z];
      p3p2x = positions[v3x] - positions[v2x];
      p3p2y = positions[v3y] - positions[v2y];
      p3p2z = positions[v3z] - positions[v2z];
      faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);
      faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);
      faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);
      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
      length = length === 0 ? 1 : length;
      faceNormalx /= length;
      faceNormaly /= length;
      faceNormalz /= length;
      if (computeFacetNormals && options) {
        options.facetNormals[index].x = faceNormalx;
        options.facetNormals[index].y = faceNormaly;
        options.facetNormals[index].z = faceNormalz;
      }
      if (computeFacetPositions && options) {
        options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3;
        options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3;
        options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3;
      }
      if (computeFacetPartitioning && options) {
        ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);
        oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);
        oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);
        b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;
        block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;
        block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;
        block_idx_o = ox + options.subDiv.max * oy + subSq * oz;
        options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();
        options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();
        options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();
        options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();
        options.facetPartitioning[block_idx_v1].push(index);
        if (block_idx_v2 != block_idx_v1) {
          options.facetPartitioning[block_idx_v2].push(index);
        }
        if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {
          options.facetPartitioning[block_idx_v3].push(index);
        }
        if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {
          options.facetPartitioning[block_idx_o].push(index);
        }
      }
      if (computeDepthSort && options && options.facetPositions) {
        var dsf = depthSortedFacets[index];
        dsf.ind = index * 3;
        dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);
      }
      normals[v1x] += faceNormalx;
      normals[v1y] += faceNormaly;
      normals[v1z] += faceNormalz;
      normals[v2x] += faceNormalx;
      normals[v2y] += faceNormaly;
      normals[v2z] += faceNormalz;
      normals[v3x] += faceNormalx;
      normals[v3y] += faceNormaly;
      normals[v3z] += faceNormalz;
    }
    for (index = 0; index < normals.length / 3; index++) {
      faceNormalx = normals[index * 3];
      faceNormaly = normals[index * 3 + 1];
      faceNormalz = normals[index * 3 + 2];
      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
      length = length === 0 ? 1 : length;
      faceNormalx /= length;
      faceNormaly /= length;
      faceNormalz /= length;
      normals[index * 3] = faceNormalx;
      normals[index * 3 + 1] = faceNormaly;
      normals[index * 3 + 2] = faceNormalz;
    }
  };
  VertexData2._ComputeSides = function(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {
    var li = indices.length;
    var ln = normals.length;
    var i;
    var n;
    sideOrientation = sideOrientation || VertexData2.DEFAULTSIDE;
    switch (sideOrientation) {
      case VertexData2.FRONTSIDE:
        break;
      case VertexData2.BACKSIDE:
        var tmp;
        for (i = 0; i < li; i += 3) {
          tmp = indices[i];
          indices[i] = indices[i + 2];
          indices[i + 2] = tmp;
        }
        for (n = 0; n < ln; n++) {
          normals[n] = -normals[n];
        }
        break;
      case VertexData2.DOUBLESIDE:
        var lp = positions.length;
        var l = lp / 3;
        for (var p = 0; p < lp; p++) {
          positions[lp + p] = positions[p];
        }
        for (i = 0; i < li; i += 3) {
          indices[i + li] = indices[i + 2] + l;
          indices[i + 1 + li] = indices[i + 1] + l;
          indices[i + 2 + li] = indices[i] + l;
        }
        for (n = 0; n < ln; n++) {
          normals[ln + n] = -normals[n];
        }
        var lu = uvs.length;
        var u = 0;
        for (u = 0; u < lu; u++) {
          uvs[u + lu] = uvs[u];
        }
        frontUVs = frontUVs ? frontUVs : new Vector4(0, 0, 1, 1);
        backUVs = backUVs ? backUVs : new Vector4(0, 0, 1, 1);
        u = 0;
        for (i = 0; i < lu / 2; i++) {
          uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];
          uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];
          uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];
          uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];
          u += 2;
        }
        break;
    }
  };
  VertexData2.ImportVertexData = function(parsedVertexData, geometry) {
    var vertexData = new VertexData2();
    var positions = parsedVertexData.positions;
    if (positions) {
      vertexData.set(positions, VertexBuffer.PositionKind);
    }
    var normals = parsedVertexData.normals;
    if (normals) {
      vertexData.set(normals, VertexBuffer.NormalKind);
    }
    var tangents = parsedVertexData.tangents;
    if (tangents) {
      vertexData.set(tangents, VertexBuffer.TangentKind);
    }
    var uvs = parsedVertexData.uvs;
    if (uvs) {
      vertexData.set(uvs, VertexBuffer.UVKind);
    }
    var uv2s = parsedVertexData.uv2s;
    if (uv2s) {
      vertexData.set(uv2s, VertexBuffer.UV2Kind);
    }
    var uv3s = parsedVertexData.uv3s;
    if (uv3s) {
      vertexData.set(uv3s, VertexBuffer.UV3Kind);
    }
    var uv4s = parsedVertexData.uv4s;
    if (uv4s) {
      vertexData.set(uv4s, VertexBuffer.UV4Kind);
    }
    var uv5s = parsedVertexData.uv5s;
    if (uv5s) {
      vertexData.set(uv5s, VertexBuffer.UV5Kind);
    }
    var uv6s = parsedVertexData.uv6s;
    if (uv6s) {
      vertexData.set(uv6s, VertexBuffer.UV6Kind);
    }
    var colors = parsedVertexData.colors;
    if (colors) {
      vertexData.set(Color4$1.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);
    }
    var matricesIndices = parsedVertexData.matricesIndices;
    if (matricesIndices) {
      vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);
    }
    var matricesWeights = parsedVertexData.matricesWeights;
    if (matricesWeights) {
      vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);
    }
    var indices = parsedVertexData.indices;
    if (indices) {
      vertexData.indices = indices;
    }
    geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);
  };
  VertexData2.FRONTSIDE = 0;
  VertexData2.BACKSIDE = 1;
  VertexData2.DOUBLESIDE = 2;
  VertexData2.DEFAULTSIDE = 0;
  __decorate([
    nativeOverride.filter(function() {
      var _a = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _a[_i] = arguments[_i];
      }
      var coordinates = _a[0];
      return !Array.isArray(coordinates);
    })
  ], VertexData2, "_TransformVector3Coordinates", null);
  __decorate([
    nativeOverride.filter(function() {
      var _a = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _a[_i] = arguments[_i];
      }
      var normals = _a[0];
      return !Array.isArray(normals);
    })
  ], VertexData2, "_TransformVector3Normals", null);
  __decorate([
    nativeOverride.filter(function() {
      var _a = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _a[_i] = arguments[_i];
      }
      var normals = _a[0];
      return !Array.isArray(normals);
    })
  ], VertexData2, "_TransformVector4Normals", null);
  __decorate([
    nativeOverride.filter(function() {
      var _a = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _a[_i] = arguments[_i];
      }
      var indices = _a[0];
      return !Array.isArray(indices);
    })
  ], VertexData2, "_FlipFaces", null);
  return VertexData2;
}();
var IntersectionInfo = function() {
  function IntersectionInfo2(bu, bv, distance) {
    this.bu = bu;
    this.bv = bv;
    this.distance = distance;
    this.faceId = 0;
    this.subMeshId = 0;
  }
  return IntersectionInfo2;
}();
var BoundingBox = function() {
  function BoundingBox2(min, max, worldMatrix) {
    this.vectors = ArrayTools.BuildArray(8, Vector3.Zero);
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.extendSize = Vector3.Zero();
    this.extendSizeWorld = Vector3.Zero();
    this.directions = ArrayTools.BuildArray(3, Vector3.Zero);
    this.vectorsWorld = ArrayTools.BuildArray(8, Vector3.Zero);
    this.minimumWorld = Vector3.Zero();
    this.maximumWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this._drawWrapperFront = null;
    this._drawWrapperBack = null;
    this.reConstruct(min, max, worldMatrix);
  }
  BoundingBox2.prototype.reConstruct = function(min, max, worldMatrix) {
    var minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    var vectors = this.vectors;
    this.minimum.copyFromFloats(minX, minY, minZ);
    this.maximum.copyFromFloats(maxX, maxY, maxZ);
    vectors[0].copyFromFloats(minX, minY, minZ);
    vectors[1].copyFromFloats(maxX, maxY, maxZ);
    vectors[2].copyFromFloats(maxX, minY, minZ);
    vectors[3].copyFromFloats(minX, maxY, minZ);
    vectors[4].copyFromFloats(minX, minY, maxZ);
    vectors[5].copyFromFloats(maxX, maxY, minZ);
    vectors[6].copyFromFloats(minX, maxY, maxZ);
    vectors[7].copyFromFloats(maxX, minY, maxZ);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);
    this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;
    this._update(this._worldMatrix);
  };
  BoundingBox2.prototype.scale = function(factor) {
    var tmpVectors = BoundingBox2.TmpVector3;
    var diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);
    var len = diff.length();
    diff.normalizeFromLength(len);
    var distance = len * factor;
    var newRadius = diff.scaleInPlace(distance * 0.5);
    var min = this.center.subtractToRef(newRadius, tmpVectors[1]);
    var max = this.center.addToRef(newRadius, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  };
  BoundingBox2.prototype.getWorldMatrix = function() {
    return this._worldMatrix;
  };
  BoundingBox2.prototype._update = function(world) {
    var minWorld = this.minimumWorld;
    var maxWorld = this.maximumWorld;
    var directions = this.directions;
    var vectorsWorld = this.vectorsWorld;
    var vectors = this.vectors;
    if (!world.isIdentity()) {
      minWorld.setAll(Number.MAX_VALUE);
      maxWorld.setAll(-Number.MAX_VALUE);
      for (var index = 0; index < 8; ++index) {
        var v = vectorsWorld[index];
        Vector3.TransformCoordinatesToRef(vectors[index], world, v);
        minWorld.minimizeInPlace(v);
        maxWorld.maximizeInPlace(v);
      }
      maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);
      maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);
    } else {
      minWorld.copyFrom(this.minimum);
      maxWorld.copyFrom(this.maximum);
      for (var index = 0; index < 8; ++index) {
        vectorsWorld[index].copyFrom(vectors[index]);
      }
      this.extendSizeWorld.copyFrom(this.extendSize);
      this.centerWorld.copyFrom(this.center);
    }
    Vector3.FromArrayToRef(world.m, 0, directions[0]);
    Vector3.FromArrayToRef(world.m, 4, directions[1]);
    Vector3.FromArrayToRef(world.m, 8, directions[2]);
    this._worldMatrix = world;
  };
  BoundingBox2.prototype.isInFrustum = function(frustumPlanes) {
    return BoundingBox2.IsInFrustum(this.vectorsWorld, frustumPlanes);
  };
  BoundingBox2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
    return BoundingBox2.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);
  };
  BoundingBox2.prototype.intersectsPoint = function(point) {
    var min = this.minimumWorld;
    var max = this.maximumWorld;
    var minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    var pointX = point.x, pointY = point.y, pointZ = point.z;
    var delta = -Epsilon;
    if (maxX - pointX < delta || delta > pointX - minX) {
      return false;
    }
    if (maxY - pointY < delta || delta > pointY - minY) {
      return false;
    }
    if (maxZ - pointZ < delta || delta > pointZ - minZ) {
      return false;
    }
    return true;
  };
  BoundingBox2.prototype.intersectsSphere = function(sphere) {
    return BoundingBox2.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);
  };
  BoundingBox2.prototype.intersectsMinMax = function(min, max) {
    var myMin = this.minimumWorld;
    var myMax = this.maximumWorld;
    var myMinX = myMin.x, myMinY = myMin.y, myMinZ = myMin.z, myMaxX = myMax.x, myMaxY = myMax.y, myMaxZ = myMax.z;
    var minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    if (myMaxX < minX || myMinX > maxX) {
      return false;
    }
    if (myMaxY < minY || myMinY > maxY) {
      return false;
    }
    if (myMaxZ < minZ || myMinZ > maxZ) {
      return false;
    }
    return true;
  };
  BoundingBox2.prototype.dispose = function() {
    var _a, _b;
    (_a = this._drawWrapperFront) === null || _a === void 0 ? void 0 : _a.dispose();
    (_b = this._drawWrapperBack) === null || _b === void 0 ? void 0 : _b.dispose();
  };
  BoundingBox2.Intersects = function(box0, box1) {
    return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);
  };
  BoundingBox2.IntersectsSphere = function(minPoint, maxPoint, sphereCenter, sphereRadius) {
    var vector = BoundingBox2.TmpVector3[0];
    Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);
    var num = Vector3.DistanceSquared(sphereCenter, vector);
    return num <= sphereRadius * sphereRadius;
  };
  BoundingBox2.IsCompletelyInFrustum = function(boundingVectors, frustumPlanes) {
    for (var p = 0; p < 6; ++p) {
      var frustumPlane = frustumPlanes[p];
      for (var i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {
          return false;
        }
      }
    }
    return true;
  };
  BoundingBox2.IsInFrustum = function(boundingVectors, frustumPlanes) {
    for (var p = 0; p < 6; ++p) {
      var canReturnFalse = true;
      var frustumPlane = frustumPlanes[p];
      for (var i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {
          canReturnFalse = false;
          break;
        }
      }
      if (canReturnFalse) {
        return false;
      }
    }
    return true;
  };
  BoundingBox2.TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);
  return BoundingBox2;
}();
var BoundingSphere = function() {
  function BoundingSphere2(min, max, worldMatrix) {
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this.reConstruct(min, max, worldMatrix);
  }
  BoundingSphere2.prototype.reConstruct = function(min, max, worldMatrix) {
    this.minimum.copyFrom(min);
    this.maximum.copyFrom(max);
    var distance = Vector3.Distance(min, max);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    this.radius = distance * 0.5;
    this._update(worldMatrix || Matrix.IdentityReadOnly);
  };
  BoundingSphere2.prototype.scale = function(factor) {
    var newRadius = this.radius * factor;
    var tmpVectors = BoundingSphere2.TmpVector3;
    var tempRadiusVector = tmpVectors[0].setAll(newRadius);
    var min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);
    var max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  };
  BoundingSphere2.prototype.getWorldMatrix = function() {
    return this._worldMatrix;
  };
  BoundingSphere2.prototype._update = function(worldMatrix) {
    if (!worldMatrix.isIdentity()) {
      Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);
      var tempVector = BoundingSphere2.TmpVector3[0];
      Vector3.TransformNormalFromFloatsToRef(1, 1, 1, worldMatrix, tempVector);
      this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;
    } else {
      this.centerWorld.copyFrom(this.center);
      this.radiusWorld = this.radius;
    }
  };
  BoundingSphere2.prototype.isInFrustum = function(frustumPlanes) {
    var center = this.centerWorld;
    var radius = this.radiusWorld;
    for (var i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) <= -radius) {
        return false;
      }
    }
    return true;
  };
  BoundingSphere2.prototype.isCenterInFrustum = function(frustumPlanes) {
    var center = this.centerWorld;
    for (var i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) < 0) {
        return false;
      }
    }
    return true;
  };
  BoundingSphere2.prototype.intersectsPoint = function(point) {
    var squareDistance = Vector3.DistanceSquared(this.centerWorld, point);
    if (this.radiusWorld * this.radiusWorld < squareDistance) {
      return false;
    }
    return true;
  };
  BoundingSphere2.Intersects = function(sphere0, sphere1) {
    var squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);
    var radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;
    if (radiusSum * radiusSum < squareDistance) {
      return false;
    }
    return true;
  };
  BoundingSphere2.CreateFromCenterAndRadius = function(center, radius, matrix) {
    this.TmpVector3[0].copyFrom(center);
    this.TmpVector3[1].copyFromFloats(0, 0, radius);
    this.TmpVector3[2].copyFrom(center);
    this.TmpVector3[0].addInPlace(this.TmpVector3[1]);
    this.TmpVector3[2].subtractInPlace(this.TmpVector3[1]);
    var sphere = new BoundingSphere2(this.TmpVector3[0], this.TmpVector3[2]);
    if (matrix) {
      sphere._worldMatrix = matrix;
    } else {
      sphere._worldMatrix = Matrix.Identity();
    }
    return sphere;
  };
  BoundingSphere2.TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);
  return BoundingSphere2;
}();
var _result0 = { min: 0, max: 0 };
var _result1 = { min: 0, max: 0 };
var computeBoxExtents = function(axis, box, result) {
  var p = Vector3.Dot(box.centerWorld, axis);
  var r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;
  var r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;
  var r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;
  var r = r0 + r1 + r2;
  result.min = p - r;
  result.max = p + r;
};
var axisOverlap = function(axis, box0, box1) {
  computeBoxExtents(axis, box0, _result0);
  computeBoxExtents(axis, box1, _result1);
  return !(_result0.min > _result1.max || _result1.min > _result0.max);
};
var BoundingInfo = function() {
  function BoundingInfo2(minimum, maximum, worldMatrix) {
    this._isLocked = false;
    this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);
    this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);
  }
  BoundingInfo2.prototype.reConstruct = function(min, max, worldMatrix) {
    this.boundingBox.reConstruct(min, max, worldMatrix);
    this.boundingSphere.reConstruct(min, max, worldMatrix);
  };
  Object.defineProperty(BoundingInfo2.prototype, "minimum", {
    get: function() {
      return this.boundingBox.minimum;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BoundingInfo2.prototype, "maximum", {
    get: function() {
      return this.boundingBox.maximum;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BoundingInfo2.prototype, "isLocked", {
    get: function() {
      return this._isLocked;
    },
    set: function(value) {
      this._isLocked = value;
    },
    enumerable: false,
    configurable: true
  });
  BoundingInfo2.prototype.update = function(world) {
    if (this._isLocked) {
      return;
    }
    this.boundingBox._update(world);
    this.boundingSphere._update(world);
  };
  BoundingInfo2.prototype.centerOn = function(center, extend) {
    var minimum = BoundingInfo2.TmpVector3[0].copyFrom(center).subtractInPlace(extend);
    var maximum = BoundingInfo2.TmpVector3[1].copyFrom(center).addInPlace(extend);
    this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    return this;
  };
  BoundingInfo2.prototype.encapsulate = function(point) {
    var minimum = Vector3.Minimize(this.minimum, point);
    var maximum = Vector3.Maximize(this.maximum, point);
    this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    return this;
  };
  BoundingInfo2.prototype.encapsulateBoundingInfo = function(toEncapsulate) {
    this.encapsulate(toEncapsulate.boundingBox.centerWorld.subtract(toEncapsulate.boundingBox.extendSizeWorld));
    this.encapsulate(toEncapsulate.boundingBox.centerWorld.add(toEncapsulate.boundingBox.extendSizeWorld));
    return this;
  };
  BoundingInfo2.prototype.scale = function(factor) {
    this.boundingBox.scale(factor);
    this.boundingSphere.scale(factor);
    return this;
  };
  BoundingInfo2.prototype.isInFrustum = function(frustumPlanes, strategy) {
    if (strategy === void 0) {
      strategy = 0;
    }
    var inclusionTest = strategy === 2 || strategy === 3;
    if (inclusionTest) {
      if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {
        return true;
      }
    }
    if (!this.boundingSphere.isInFrustum(frustumPlanes)) {
      return false;
    }
    var bSphereOnlyTest = strategy === 1 || strategy === 3;
    if (bSphereOnlyTest) {
      return true;
    }
    return this.boundingBox.isInFrustum(frustumPlanes);
  };
  Object.defineProperty(BoundingInfo2.prototype, "diagonalLength", {
    get: function() {
      var boundingBox = this.boundingBox;
      var diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo2.TmpVector3[0]);
      return diag.length();
    },
    enumerable: false,
    configurable: true
  });
  BoundingInfo2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
    return this.boundingBox.isCompletelyInFrustum(frustumPlanes);
  };
  BoundingInfo2.prototype._checkCollision = function(collider) {
    return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);
  };
  BoundingInfo2.prototype.intersectsPoint = function(point) {
    if (!this.boundingSphere.centerWorld) {
      return false;
    }
    if (!this.boundingSphere.intersectsPoint(point)) {
      return false;
    }
    if (!this.boundingBox.intersectsPoint(point)) {
      return false;
    }
    return true;
  };
  BoundingInfo2.prototype.intersects = function(boundingInfo, precise) {
    if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {
      return false;
    }
    if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {
      return false;
    }
    if (!precise) {
      return true;
    }
    var box0 = this.boundingBox;
    var box1 = boundingInfo.boundingBox;
    if (!axisOverlap(box0.directions[0], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box0.directions[1], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box0.directions[2], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[0], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[1], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[2], box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {
      return false;
    }
    return true;
  };
  BoundingInfo2.TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);
  return BoundingInfo2;
}();
var MathHelpers = function() {
  function MathHelpers2() {
  }
  MathHelpers2.extractMinAndMaxIndexed = function(positions, indices, indexStart, indexCount, minimum, maximum) {
    for (var index = indexStart; index < indexStart + indexCount; index++) {
      var offset = indices[index] * 3;
      var x = positions[offset];
      var y = positions[offset + 1];
      var z = positions[offset + 2];
      minimum.minimizeInPlaceFromFloats(x, y, z);
      maximum.maximizeInPlaceFromFloats(x, y, z);
    }
  };
  MathHelpers2.extractMinAndMax = function(positions, start, count, stride, minimum, maximum) {
    for (var index = start, offset = start * stride; index < start + count; index++, offset += stride) {
      var x = positions[offset];
      var y = positions[offset + 1];
      var z = positions[offset + 2];
      minimum.minimizeInPlaceFromFloats(x, y, z);
      maximum.maximizeInPlaceFromFloats(x, y, z);
    }
  };
  __decorate([
    nativeOverride.filter(function() {
      var _a = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _a[_i] = arguments[_i];
      }
      var positions = _a[0], indices = _a[1];
      return !Array.isArray(positions) && !Array.isArray(indices);
    })
  ], MathHelpers2, "extractMinAndMaxIndexed", null);
  __decorate([
    nativeOverride.filter(function() {
      var _a = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _a[_i] = arguments[_i];
      }
      var positions = _a[0];
      return !Array.isArray(positions);
    })
  ], MathHelpers2, "extractMinAndMax", null);
  return MathHelpers2;
}();
function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias) {
  if (bias === void 0) {
    bias = null;
  }
  var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}
function extractMinAndMax(positions, start, count, bias, stride) {
  if (bias === void 0) {
    bias = null;
  }
  var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  if (!stride) {
    stride = 3;
  }
  MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}
var SubMesh = function() {
  function SubMesh2(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox, addToMesh) {
    if (createBoundingBox === void 0) {
      createBoundingBox = true;
    }
    if (addToMesh === void 0) {
      addToMesh = true;
    }
    this.materialIndex = materialIndex;
    this.verticesStart = verticesStart;
    this.verticesCount = verticesCount;
    this.indexStart = indexStart;
    this.indexCount = indexCount;
    this._mainDrawWrapperOverride = null;
    this._linesIndexCount = 0;
    this._linesIndexBuffer = null;
    this._lastColliderWorldVertices = null;
    this._lastColliderTransformMatrix = null;
    this._renderId = 0;
    this._alphaIndex = 0;
    this._distanceToCamera = 0;
    this._currentMaterial = null;
    this._mesh = mesh;
    this._renderingMesh = renderingMesh || mesh;
    if (addToMesh) {
      mesh.subMeshes.push(this);
    }
    this._engine = this._mesh.getScene().getEngine();
    this.resetDrawCache();
    this._trianglePlanes = [];
    this._id = mesh.subMeshes.length - 1;
    if (createBoundingBox) {
      this.refreshBoundingInfo();
      mesh.computeWorldMatrix(true);
    }
  }
  Object.defineProperty(SubMesh2.prototype, "materialDefines", {
    get: function() {
      var _a;
      return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.defines;
    },
    set: function(defines) {
      var _a;
      var drawWrapper = (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(void 0, true);
      drawWrapper.defines = defines;
    },
    enumerable: false,
    configurable: true
  });
  SubMesh2.prototype._getDrawWrapper = function(passId, createIfNotExisting) {
    if (createIfNotExisting === void 0) {
      createIfNotExisting = false;
    }
    passId = passId !== null && passId !== void 0 ? passId : this._engine.currentRenderPassId;
    var drawWrapper = this._drawWrappers[passId];
    if (!drawWrapper && createIfNotExisting) {
      this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());
    }
    return drawWrapper;
  };
  SubMesh2.prototype._removeDrawWrapper = function(passId, disposeWrapper) {
    var _a;
    if (disposeWrapper === void 0) {
      disposeWrapper = true;
    }
    if (disposeWrapper) {
      (_a = this._drawWrappers[passId]) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    this._drawWrappers[passId] = void 0;
  };
  Object.defineProperty(SubMesh2.prototype, "effect", {
    get: function() {
      var _a, _b;
      return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (_b = (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubMesh2.prototype, "_drawWrapper", {
    get: function() {
      var _a;
      return (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(void 0, true);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubMesh2.prototype, "_drawWrapperOverride", {
    get: function() {
      return this._mainDrawWrapperOverride;
    },
    enumerable: false,
    configurable: true
  });
  SubMesh2.prototype._setMainDrawWrapperOverride = function(wrapper) {
    this._mainDrawWrapperOverride = wrapper;
  };
  SubMesh2.prototype.setEffect = function(effect, defines, materialContext, resetContext) {
    if (defines === void 0) {
      defines = null;
    }
    if (resetContext === void 0) {
      resetContext = true;
    }
    var drawWrapper = this._drawWrapper;
    drawWrapper.setEffect(effect, defines, resetContext);
    if (materialContext !== void 0) {
      drawWrapper.materialContext = materialContext;
    }
    if (!effect) {
      drawWrapper.defines = null;
      drawWrapper.materialContext = void 0;
    }
  };
  SubMesh2.prototype.resetDrawCache = function(passId) {
    if (this._drawWrappers) {
      if (passId !== void 0) {
        this._removeDrawWrapper(passId);
        return;
      } else {
        for (var _i = 0, _a = this._drawWrappers; _i < _a.length; _i++) {
          var drawWrapper = _a[_i];
          drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();
        }
      }
    }
    this._drawWrappers = [];
  };
  SubMesh2.AddToMesh = function(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox) {
    if (createBoundingBox === void 0) {
      createBoundingBox = true;
    }
    return new SubMesh2(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);
  };
  Object.defineProperty(SubMesh2.prototype, "IsGlobal", {
    get: function() {
      return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices();
    },
    enumerable: false,
    configurable: true
  });
  SubMesh2.prototype.getBoundingInfo = function() {
    if (this.IsGlobal) {
      return this._mesh.getBoundingInfo();
    }
    return this._boundingInfo;
  };
  SubMesh2.prototype.setBoundingInfo = function(boundingInfo) {
    this._boundingInfo = boundingInfo;
    return this;
  };
  SubMesh2.prototype.getMesh = function() {
    return this._mesh;
  };
  SubMesh2.prototype.getRenderingMesh = function() {
    return this._renderingMesh;
  };
  SubMesh2.prototype.getReplacementMesh = function() {
    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
  };
  SubMesh2.prototype.getEffectiveMesh = function() {
    var replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
    return replacementMesh ? replacementMesh : this._renderingMesh;
  };
  SubMesh2.prototype.getMaterial = function() {
    var _a;
    var rootMaterial = (_a = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) !== null && _a !== void 0 ? _a : this._renderingMesh.material;
    if (rootMaterial === null || rootMaterial === void 0) {
      return this._mesh.getScene().defaultMaterial;
    } else if (this._IsMultiMaterial(rootMaterial)) {
      var effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);
      if (this._currentMaterial !== effectiveMaterial) {
        this._currentMaterial = effectiveMaterial;
        this.resetDrawCache();
      }
      return effectiveMaterial;
    }
    return rootMaterial;
  };
  SubMesh2.prototype._IsMultiMaterial = function(material) {
    return material.getSubMaterial !== void 0;
  };
  SubMesh2.prototype.refreshBoundingInfo = function(data) {
    if (data === void 0) {
      data = null;
    }
    this._lastColliderWorldVertices = null;
    if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {
      return this;
    }
    if (!data) {
      data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);
    }
    if (!data) {
      this._boundingInfo = this._mesh.getBoundingInfo();
      return this;
    }
    var indices = this._renderingMesh.getIndices();
    var extend;
    if (this.indexStart === 0 && this.indexCount === indices.length) {
      var boundingInfo = this._renderingMesh.getBoundingInfo();
      extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };
    } else {
      extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);
    }
    if (this._boundingInfo) {
      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
    } else {
      this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
    }
    return this;
  };
  SubMesh2.prototype._checkCollision = function(collider) {
    var boundingInfo = this.getBoundingInfo();
    return boundingInfo._checkCollision(collider);
  };
  SubMesh2.prototype.updateBoundingInfo = function(world) {
    var boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      this.refreshBoundingInfo();
      boundingInfo = this.getBoundingInfo();
    }
    if (boundingInfo) {
      boundingInfo.update(world);
    }
    return this;
  };
  SubMesh2.prototype.isInFrustum = function(frustumPlanes) {
    var boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);
  };
  SubMesh2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
    var boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return boundingInfo.isCompletelyInFrustum(frustumPlanes);
  };
  SubMesh2.prototype.render = function(enableAlphaMode) {
    this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : void 0);
    return this;
  };
  SubMesh2.prototype._getLinesIndexBuffer = function(indices, engine) {
    if (!this._linesIndexBuffer) {
      var linesIndices = [];
      for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {
        linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);
      }
      this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);
      this._linesIndexCount = linesIndices.length;
    }
    return this._linesIndexBuffer;
  };
  SubMesh2.prototype.canIntersects = function(ray) {
    var boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return ray.intersectsBox(boundingInfo.boundingBox);
  };
  SubMesh2.prototype.intersects = function(ray, positions, indices, fastCheck, trianglePredicate) {
    var material = this.getMaterial();
    if (!material) {
      return null;
    }
    var step = 3;
    var checkStopper = false;
    switch (material.fillMode) {
      case 3:
      case 5:
      case 6:
      case 8:
        return null;
      case 7:
        step = 1;
        checkStopper = true;
        break;
    }
    if (material.fillMode === 4) {
      if (!indices.length) {
        return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
      }
      return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
    } else {
      if (!indices.length && this._mesh._unIndexed) {
        return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);
      }
      return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);
    }
  };
  SubMesh2.prototype._intersectLines = function(ray, positions, indices, intersectionThreshold, fastCheck) {
    var intersectInfo = null;
    for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {
      var p0 = positions[indices[index]];
      var p1 = positions[indices[index + 1]];
      var length = ray.intersectionSegment(p0, p1, intersectionThreshold);
      if (length < 0) {
        continue;
      }
      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {
        intersectInfo = new IntersectionInfo(null, null, length);
        intersectInfo.faceId = index / 2;
        if (fastCheck) {
          break;
        }
      }
    }
    return intersectInfo;
  };
  SubMesh2.prototype._intersectUnIndexedLines = function(ray, positions, indices, intersectionThreshold, fastCheck) {
    var intersectInfo = null;
    for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {
      var p0 = positions[index];
      var p1 = positions[index + 1];
      var length = ray.intersectionSegment(p0, p1, intersectionThreshold);
      if (length < 0) {
        continue;
      }
      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {
        intersectInfo = new IntersectionInfo(null, null, length);
        intersectInfo.faceId = index / 2;
        if (fastCheck) {
          break;
        }
      }
    }
    return intersectInfo;
  };
  SubMesh2.prototype._intersectTriangles = function(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {
    var intersectInfo = null;
    var faceId = -1;
    for (var index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {
      faceId++;
      var indexA = indices[index];
      var indexB = indices[index + 1];
      var indexC = indices[index + 2];
      if (checkStopper && indexC === 4294967295) {
        index += 2;
        continue;
      }
      var p0 = positions[indexA];
      var p1 = positions[indexB];
      var p2 = positions[indexC];
      if (!p0 || !p1 || !p2) {
        continue;
      }
      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {
        continue;
      }
      var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
      if (currentIntersectInfo) {
        if (currentIntersectInfo.distance < 0) {
          continue;
        }
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.faceId = faceId;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    return intersectInfo;
  };
  SubMesh2.prototype._intersectUnIndexedTriangles = function(ray, positions, indices, fastCheck, trianglePredicate) {
    var intersectInfo = null;
    for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {
      var p0 = positions[index];
      var p1 = positions[index + 1];
      var p2 = positions[index + 2];
      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {
        continue;
      }
      var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
      if (currentIntersectInfo) {
        if (currentIntersectInfo.distance < 0) {
          continue;
        }
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.faceId = index / 3;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    return intersectInfo;
  };
  SubMesh2.prototype._rebuild = function() {
    if (this._linesIndexBuffer) {
      this._linesIndexBuffer = null;
    }
  };
  SubMesh2.prototype.clone = function(newMesh, newRenderingMesh) {
    var result = new SubMesh2(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);
    if (!this.IsGlobal) {
      var boundingInfo = this.getBoundingInfo();
      if (!boundingInfo) {
        return result;
      }
      result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);
    }
    return result;
  };
  SubMesh2.prototype.dispose = function() {
    if (this._linesIndexBuffer) {
      this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);
      this._linesIndexBuffer = null;
    }
    var index = this._mesh.subMeshes.indexOf(this);
    this._mesh.subMeshes.splice(index, 1);
    this.resetDrawCache();
  };
  SubMesh2.prototype.getClassName = function() {
    return "SubMesh";
  };
  SubMesh2.CreateFromIndices = function(materialIndex, startIndex, indexCount, mesh, renderingMesh, createBoundingBox) {
    if (createBoundingBox === void 0) {
      createBoundingBox = true;
    }
    var minVertexIndex = Number.MAX_VALUE;
    var maxVertexIndex = -Number.MAX_VALUE;
    var whatWillRender = renderingMesh || mesh;
    var indices = whatWillRender.getIndices();
    for (var index = startIndex; index < startIndex + indexCount; index++) {
      var vertexIndex = indices[index];
      if (vertexIndex < minVertexIndex) {
        minVertexIndex = vertexIndex;
      }
      if (vertexIndex > maxVertexIndex) {
        maxVertexIndex = vertexIndex;
      }
    }
    return new SubMesh2(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);
  };
  return SubMesh2;
}();
var SceneLoaderFlags = function() {
  function SceneLoaderFlags2() {
  }
  Object.defineProperty(SceneLoaderFlags2, "ForceFullSceneLoadingForIncremental", {
    get: function() {
      return SceneLoaderFlags2._ForceFullSceneLoadingForIncremental;
    },
    set: function(value) {
      SceneLoaderFlags2._ForceFullSceneLoadingForIncremental = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoaderFlags2, "ShowLoadingScreen", {
    get: function() {
      return SceneLoaderFlags2._ShowLoadingScreen;
    },
    set: function(value) {
      SceneLoaderFlags2._ShowLoadingScreen = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoaderFlags2, "loggingLevel", {
    get: function() {
      return SceneLoaderFlags2._loggingLevel;
    },
    set: function(value) {
      SceneLoaderFlags2._loggingLevel = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoaderFlags2, "CleanBoneMatrixWeights", {
    get: function() {
      return SceneLoaderFlags2._CleanBoneMatrixWeights;
    },
    set: function(value) {
      SceneLoaderFlags2._CleanBoneMatrixWeights = value;
    },
    enumerable: false,
    configurable: true
  });
  SceneLoaderFlags2._ForceFullSceneLoadingForIncremental = false;
  SceneLoaderFlags2._ShowLoadingScreen = true;
  SceneLoaderFlags2._CleanBoneMatrixWeights = false;
  SceneLoaderFlags2._loggingLevel = 0;
  return SceneLoaderFlags2;
}();
var CompatibilityOptions = function() {
  function CompatibilityOptions2() {
  }
  CompatibilityOptions2.UseOpenGLOrientationForUV = false;
  return CompatibilityOptions2;
}();
var Geometry = function() {
  function Geometry2(id, scene, vertexData, updatable, mesh) {
    if (updatable === void 0) {
      updatable = false;
    }
    if (mesh === void 0) {
      mesh = null;
    }
    this.delayLoadState = 0;
    this._totalVertices = 0;
    this._isDisposed = false;
    this._indexBufferIsUpdatable = false;
    this._positionsCache = [];
    this._parentContainer = null;
    this.useBoundingInfoFromGeometry = false;
    this._scene = scene || EngineStore.LastCreatedScene;
    if (!this._scene) {
      return;
    }
    this.id = id;
    this.uniqueId = this._scene.getUniqueId();
    this._engine = this._scene.getEngine();
    this._meshes = [];
    this._vertexBuffers = {};
    this._indices = [];
    this._updatable = updatable;
    if (vertexData) {
      this.setAllVerticesData(vertexData, updatable);
    } else {
      this._totalVertices = 0;
      this._indices = [];
    }
    if (this._engine.getCaps().vertexArrayObject) {
      this._vertexArrayObjects = {};
    }
    if (mesh) {
      this.applyToMesh(mesh);
      mesh.computeWorldMatrix(true);
    }
  }
  Object.defineProperty(Geometry2.prototype, "boundingBias", {
    get: function() {
      return this._boundingBias;
    },
    set: function(value) {
      if (this._boundingBias) {
        this._boundingBias.copyFrom(value);
      } else {
        this._boundingBias = value.clone();
      }
      this._updateBoundingInfo(true, null);
    },
    enumerable: false,
    configurable: true
  });
  Geometry2.CreateGeometryForMesh = function(mesh) {
    var geometry = new Geometry2(Geometry2.RandomId(), mesh.getScene());
    geometry.applyToMesh(mesh);
    return geometry;
  };
  Object.defineProperty(Geometry2.prototype, "meshes", {
    get: function() {
      return this._meshes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Geometry2.prototype, "extend", {
    get: function() {
      return this._extend;
    },
    enumerable: false,
    configurable: true
  });
  Geometry2.prototype.getScene = function() {
    return this._scene;
  };
  Geometry2.prototype.getEngine = function() {
    return this._engine;
  };
  Geometry2.prototype.isReady = function() {
    return this.delayLoadState === 1 || this.delayLoadState === 0;
  };
  Object.defineProperty(Geometry2.prototype, "doNotSerialize", {
    get: function() {
      for (var index = 0; index < this._meshes.length; index++) {
        if (!this._meshes[index].doNotSerialize) {
          return false;
        }
      }
      return true;
    },
    enumerable: false,
    configurable: true
  });
  Geometry2.prototype._rebuild = function() {
    if (this._vertexArrayObjects) {
      this._vertexArrayObjects = {};
    }
    if (this._meshes.length !== 0 && this._indices) {
      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);
    }
    for (var key in this._vertexBuffers) {
      var vertexBuffer = this._vertexBuffers[key];
      vertexBuffer._rebuild();
    }
  };
  Geometry2.prototype.setAllVerticesData = function(vertexData, updatable) {
    vertexData.applyToGeometry(this, updatable);
    this.notifyUpdate();
  };
  Geometry2.prototype.setVerticesData = function(kind, data, updatable, stride) {
    if (updatable === void 0) {
      updatable = false;
    }
    if (updatable && Array.isArray(data)) {
      data = new Float32Array(data);
    }
    var buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);
    this.setVerticesBuffer(buffer);
  };
  Geometry2.prototype.removeVerticesData = function(kind) {
    if (this._vertexBuffers[kind]) {
      this._vertexBuffers[kind].dispose();
      delete this._vertexBuffers[kind];
    }
    if (this._vertexArrayObjects) {
      this._disposeVertexArrayObjects();
    }
  };
  Geometry2.prototype.setVerticesBuffer = function(buffer, totalVertices, disposeExistingBuffer) {
    if (totalVertices === void 0) {
      totalVertices = null;
    }
    if (disposeExistingBuffer === void 0) {
      disposeExistingBuffer = true;
    }
    var kind = buffer.getKind();
    if (this._vertexBuffers[kind] && disposeExistingBuffer) {
      this._vertexBuffers[kind].dispose();
    }
    if (buffer._buffer) {
      buffer._buffer._increaseReferences();
    }
    this._vertexBuffers[kind] = buffer;
    var meshes = this._meshes;
    var numOfMeshes = meshes.length;
    if (kind === VertexBuffer.PositionKind) {
      var data = buffer.getData();
      if (totalVertices != null) {
        this._totalVertices = totalVertices;
      } else {
        if (data != null) {
          this._totalVertices = data.length / (buffer.type === VertexBuffer.BYTE ? buffer.byteStride : buffer.byteStride / 4);
        }
      }
      this._updateExtend(data);
      this._resetPointsArrayCache();
      for (var index = 0; index < numOfMeshes; index++) {
        var mesh = meshes[index];
        mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
        mesh._createGlobalSubMesh(false);
        mesh.computeWorldMatrix(true);
        mesh.synchronizeInstances();
      }
    }
    this.notifyUpdate(kind);
  };
  Geometry2.prototype.updateVerticesDataDirectly = function(kind, data, offset, useBytes) {
    if (useBytes === void 0) {
      useBytes = false;
    }
    var vertexBuffer = this.getVertexBuffer(kind);
    if (!vertexBuffer) {
      return;
    }
    vertexBuffer.updateDirectly(data, offset, useBytes);
    this.notifyUpdate(kind);
  };
  Geometry2.prototype.updateVerticesData = function(kind, data, updateExtends) {
    if (updateExtends === void 0) {
      updateExtends = false;
    }
    var vertexBuffer = this.getVertexBuffer(kind);
    if (!vertexBuffer) {
      return;
    }
    vertexBuffer.update(data);
    if (kind === VertexBuffer.PositionKind) {
      this._updateBoundingInfo(updateExtends, data);
    }
    this.notifyUpdate(kind);
  };
  Geometry2.prototype._updateBoundingInfo = function(updateExtends, data) {
    if (updateExtends) {
      this._updateExtend(data);
    }
    this._resetPointsArrayCache();
    if (updateExtends) {
      var meshes = this._meshes;
      for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
        var mesh = meshes_1[_i];
        if (mesh.hasBoundingInfo) {
          mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);
        } else {
          mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
        }
        var subMeshes = mesh.subMeshes;
        for (var _a = 0, subMeshes_1 = subMeshes; _a < subMeshes_1.length; _a++) {
          var subMesh = subMeshes_1[_a];
          subMesh.refreshBoundingInfo();
        }
      }
    }
  };
  Geometry2.prototype._bind = function(effect, indexToBind, overrideVertexBuffers, overrideVertexArrayObjects) {
    if (!effect) {
      return;
    }
    if (indexToBind === void 0) {
      indexToBind = this._indexBuffer;
    }
    var vbs = this.getVertexBuffers();
    if (!vbs) {
      return;
    }
    if (indexToBind != this._indexBuffer || !this._vertexArrayObjects && !overrideVertexArrayObjects) {
      this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);
      return;
    }
    var vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;
    if (!vaos[effect.key]) {
      vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);
    }
    this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);
  };
  Geometry2.prototype.getTotalVertices = function() {
    if (!this.isReady()) {
      return 0;
    }
    return this._totalVertices;
  };
  Geometry2.prototype.getVerticesData = function(kind, copyWhenShared, forceCopy) {
    var vertexBuffer = this.getVertexBuffer(kind);
    if (!vertexBuffer) {
      return null;
    }
    return vertexBuffer.getFloatData(this._totalVertices, forceCopy || copyWhenShared && this._meshes.length !== 1);
  };
  Geometry2.prototype.isVertexBufferUpdatable = function(kind) {
    var vb = this._vertexBuffers[kind];
    if (!vb) {
      return false;
    }
    return vb.isUpdatable();
  };
  Geometry2.prototype.getVertexBuffer = function(kind) {
    if (!this.isReady()) {
      return null;
    }
    return this._vertexBuffers[kind];
  };
  Geometry2.prototype.getVertexBuffers = function() {
    if (!this.isReady()) {
      return null;
    }
    return this._vertexBuffers;
  };
  Geometry2.prototype.isVerticesDataPresent = function(kind) {
    if (!this._vertexBuffers) {
      if (this._delayInfo) {
        return this._delayInfo.indexOf(kind) !== -1;
      }
      return false;
    }
    return this._vertexBuffers[kind] !== void 0;
  };
  Geometry2.prototype.getVerticesDataKinds = function() {
    var result = [];
    var kind;
    if (!this._vertexBuffers && this._delayInfo) {
      for (kind in this._delayInfo) {
        result.push(kind);
      }
    } else {
      for (kind in this._vertexBuffers) {
        result.push(kind);
      }
    }
    return result;
  };
  Geometry2.prototype.updateIndices = function(indices, offset, gpuMemoryOnly) {
    if (gpuMemoryOnly === void 0) {
      gpuMemoryOnly = false;
    }
    if (!this._indexBuffer) {
      return;
    }
    if (!this._indexBufferIsUpdatable) {
      this.setIndices(indices, null, true);
    } else {
      var needToUpdateSubMeshes = indices.length !== this._indices.length;
      if (!gpuMemoryOnly) {
        this._indices = indices.slice();
      }
      this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);
      if (needToUpdateSubMeshes) {
        for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {
          var mesh = _a[_i];
          mesh._createGlobalSubMesh(true);
        }
      }
    }
  };
  Geometry2.prototype.setIndices = function(indices, totalVertices, updatable) {
    if (totalVertices === void 0) {
      totalVertices = null;
    }
    if (updatable === void 0) {
      updatable = false;
    }
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
    }
    this._indices = indices;
    this._indexBufferIsUpdatable = updatable;
    if (this._meshes.length !== 0 && this._indices) {
      this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);
    }
    if (totalVertices != void 0) {
      this._totalVertices = totalVertices;
    }
    for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      mesh._createGlobalSubMesh(true);
      mesh.synchronizeInstances();
    }
    this.notifyUpdate();
  };
  Geometry2.prototype.getTotalIndices = function() {
    if (!this.isReady()) {
      return 0;
    }
    return this._indices.length;
  };
  Geometry2.prototype.getIndices = function(copyWhenShared, forceCopy) {
    if (!this.isReady()) {
      return null;
    }
    var orig = this._indices;
    if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {
      return orig;
    } else {
      return Tools.Slice(orig);
    }
  };
  Geometry2.prototype.getIndexBuffer = function() {
    if (!this.isReady()) {
      return null;
    }
    return this._indexBuffer;
  };
  Geometry2.prototype._releaseVertexArrayObject = function(effect) {
    if (effect === void 0) {
      effect = null;
    }
    if (!effect || !this._vertexArrayObjects) {
      return;
    }
    if (this._vertexArrayObjects[effect.key]) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);
      delete this._vertexArrayObjects[effect.key];
    }
  };
  Geometry2.prototype.releaseForMesh = function(mesh, shouldDispose) {
    var meshes = this._meshes;
    var index = meshes.indexOf(mesh);
    if (index === -1) {
      return;
    }
    meshes.splice(index, 1);
    if (this._vertexArrayObjects) {
      mesh._invalidateInstanceVertexArrayObject();
    }
    mesh._geometry = null;
    if (meshes.length === 0 && shouldDispose) {
      this.dispose();
    }
  };
  Geometry2.prototype.applyToMesh = function(mesh) {
    if (mesh._geometry === this) {
      return;
    }
    var previousGeometry = mesh._geometry;
    if (previousGeometry) {
      previousGeometry.releaseForMesh(mesh);
    }
    if (this._vertexArrayObjects) {
      mesh._invalidateInstanceVertexArrayObject();
    }
    var meshes = this._meshes;
    mesh._geometry = this;
    mesh._internalAbstractMeshDataInfo._positions = null;
    this._scene.pushGeometry(this);
    meshes.push(mesh);
    if (this.isReady()) {
      this._applyToMesh(mesh);
    } else if (this._boundingInfo) {
      mesh.setBoundingInfo(this._boundingInfo);
    }
  };
  Geometry2.prototype._updateExtend = function(data) {
    if (data === void 0) {
      data = null;
    }
    if (this.useBoundingInfoFromGeometry && this._boundingInfo) {
      this._extend = {
        minimum: this._boundingInfo.minimum.clone(),
        maximum: this._boundingInfo.maximum.clone()
      };
    } else {
      if (!data) {
        data = this.getVerticesData(VertexBuffer.PositionKind);
        if (!data) {
          return;
        }
      }
      this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);
    }
  };
  Geometry2.prototype._applyToMesh = function(mesh) {
    var numOfMeshes = this._meshes.length;
    for (var kind in this._vertexBuffers) {
      if (numOfMeshes === 1) {
        this._vertexBuffers[kind].create();
      }
      if (kind === VertexBuffer.PositionKind) {
        if (!this._extend) {
          this._updateExtend();
        }
        mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
        mesh._createGlobalSubMesh(false);
        mesh._updateBoundingInfo();
      }
    }
    if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {
      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);
    }
    mesh._syncGeometryWithMorphTargetManager();
    mesh.synchronizeInstances();
  };
  Geometry2.prototype.notifyUpdate = function(kind) {
    if (this.onGeometryUpdated) {
      this.onGeometryUpdated(this, kind);
    }
    if (this._vertexArrayObjects) {
      this._disposeVertexArrayObjects();
    }
    for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      mesh._markSubMeshesAsAttributesDirty();
    }
  };
  Geometry2.prototype.load = function(scene, onLoaded) {
    if (this.delayLoadState === 2) {
      return;
    }
    if (this.isReady()) {
      if (onLoaded) {
        onLoaded();
      }
      return;
    }
    this.delayLoadState = 2;
    this._queueLoad(scene, onLoaded);
  };
  Geometry2.prototype._queueLoad = function(scene, onLoaded) {
    var _this = this;
    if (!this.delayLoadingFile) {
      return;
    }
    scene._addPendingData(this);
    scene._loadFile(this.delayLoadingFile, function(data) {
      if (!_this._delayLoadingFunction) {
        return;
      }
      _this._delayLoadingFunction(JSON.parse(data), _this);
      _this.delayLoadState = 1;
      _this._delayInfo = [];
      scene._removePendingData(_this);
      var meshes = _this._meshes;
      var numOfMeshes = meshes.length;
      for (var index = 0; index < numOfMeshes; index++) {
        _this._applyToMesh(meshes[index]);
      }
      if (onLoaded) {
        onLoaded();
      }
    }, void 0, true);
  };
  Geometry2.prototype.toLeftHanded = function() {
    var tIndices = this.getIndices(false);
    if (tIndices != null && tIndices.length > 0) {
      for (var i = 0; i < tIndices.length; i += 3) {
        var tTemp = tIndices[i + 0];
        tIndices[i + 0] = tIndices[i + 2];
        tIndices[i + 2] = tTemp;
      }
      this.setIndices(tIndices);
    }
    var tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);
    if (tPositions != null && tPositions.length > 0) {
      for (var i = 0; i < tPositions.length; i += 3) {
        tPositions[i + 2] = -tPositions[i + 2];
      }
      this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);
    }
    var tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);
    if (tNormals != null && tNormals.length > 0) {
      for (var i = 0; i < tNormals.length; i += 3) {
        tNormals[i + 2] = -tNormals[i + 2];
      }
      this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);
    }
  };
  Geometry2.prototype._resetPointsArrayCache = function() {
    this._positions = null;
  };
  Geometry2.prototype._generatePointsArray = function() {
    if (this._positions) {
      return true;
    }
    var data = this.getVerticesData(VertexBuffer.PositionKind);
    if (!data || data.length === 0) {
      return false;
    }
    for (var index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {
      this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);
    }
    for (var index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {
      this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);
    }
    this._positionsCache.length = data.length / 3;
    this._positions = this._positionsCache;
    return true;
  };
  Geometry2.prototype.isDisposed = function() {
    return this._isDisposed;
  };
  Geometry2.prototype._disposeVertexArrayObjects = function() {
    if (this._vertexArrayObjects) {
      for (var kind in this._vertexArrayObjects) {
        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);
      }
      this._vertexArrayObjects = {};
      var meshes = this._meshes;
      var numOfMeshes = meshes.length;
      for (var index = 0; index < numOfMeshes; index++) {
        meshes[index]._invalidateInstanceVertexArrayObject();
      }
    }
  };
  Geometry2.prototype.dispose = function() {
    var meshes = this._meshes;
    var numOfMeshes = meshes.length;
    var index;
    for (index = 0; index < numOfMeshes; index++) {
      this.releaseForMesh(meshes[index]);
    }
    this._meshes = [];
    this._disposeVertexArrayObjects();
    for (var kind in this._vertexBuffers) {
      this._vertexBuffers[kind].dispose();
    }
    this._vertexBuffers = {};
    this._totalVertices = 0;
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
    }
    this._indexBuffer = null;
    this._indices = [];
    this.delayLoadState = 0;
    this.delayLoadingFile = null;
    this._delayLoadingFunction = null;
    this._delayInfo = [];
    this._boundingInfo = null;
    this._scene.removeGeometry(this);
    if (this._parentContainer) {
      var index_1 = this._parentContainer.geometries.indexOf(this);
      if (index_1 > -1) {
        this._parentContainer.geometries.splice(index_1, 1);
      }
      this._parentContainer = null;
    }
    this._isDisposed = true;
  };
  Geometry2.prototype.copy = function(id) {
    var vertexData = new VertexData();
    vertexData.indices = [];
    var indices = this.getIndices();
    if (indices) {
      for (var index = 0; index < indices.length; index++) {
        vertexData.indices.push(indices[index]);
      }
    }
    var updatable = false;
    var stopChecking = false;
    var kind;
    for (kind in this._vertexBuffers) {
      var data = this.getVerticesData(kind);
      if (data) {
        if (data instanceof Float32Array) {
          vertexData.set(new Float32Array(data), kind);
        } else {
          vertexData.set(data.slice(0), kind);
        }
        if (!stopChecking) {
          var vb = this.getVertexBuffer(kind);
          if (vb) {
            updatable = vb.isUpdatable();
            stopChecking = !updatable;
          }
        }
      }
    }
    var geometry = new Geometry2(id, this._scene, vertexData, updatable);
    geometry.delayLoadState = this.delayLoadState;
    geometry.delayLoadingFile = this.delayLoadingFile;
    geometry._delayLoadingFunction = this._delayLoadingFunction;
    for (kind in this._delayInfo) {
      geometry._delayInfo = geometry._delayInfo || [];
      geometry._delayInfo.push(kind);
    }
    geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);
    return geometry;
  };
  Geometry2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.id = this.id;
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.updatable = this._updatable;
    if (Tags && Tags.HasTags(this)) {
      serializationObject.tags = Tags.GetTags(this);
    }
    return serializationObject;
  };
  Geometry2.prototype.toNumberArray = function(origin) {
    if (Array.isArray(origin)) {
      return origin;
    } else {
      return Array.prototype.slice.call(origin);
    }
  };
  Geometry2.prototype.clearCachedData = function() {
    this._indices = [];
    this._resetPointsArrayCache();
    for (var vbName in this._vertexBuffers) {
      if (!this._vertexBuffers.hasOwnProperty(vbName)) {
        continue;
      }
      this._vertexBuffers[vbName]._buffer._data = null;
    }
  };
  Geometry2.prototype.serializeVerticeData = function() {
    var serializationObject = this.serialize();
    if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      serializationObject.positions = this.toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
        serializationObject.positions._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      serializationObject.normals = this.toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
        serializationObject.normals._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      serializationObject.tangents = this.toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {
        serializationObject.tangents._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {
      serializationObject.uvs = this.toNumberArray(this.getVerticesData(VertexBuffer.UVKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {
        serializationObject.uvs._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
      serializationObject.uv2s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {
        serializationObject.uv2s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
      serializationObject.uv3s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {
        serializationObject.uv3s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
      serializationObject.uv4s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {
        serializationObject.uv4s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
      serializationObject.uv5s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {
        serializationObject.uv5s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
      serializationObject.uv6s = this.toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {
        serializationObject.uv6s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      serializationObject.colors = this.toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {
        serializationObject.colors._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      serializationObject.matricesIndices = this.toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));
      serializationObject.matricesIndices._isExpanded = true;
      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {
        serializationObject.matricesIndices._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      serializationObject.matricesWeights = this.toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {
        serializationObject.matricesWeights._updatable = true;
      }
    }
    serializationObject.indices = this.toNumberArray(this.getIndices());
    return serializationObject;
  };
  Geometry2.ExtractFromMesh = function(mesh, id) {
    var geometry = mesh._geometry;
    if (!geometry) {
      return null;
    }
    return geometry.copy(id);
  };
  Geometry2.RandomId = function() {
    return Tools.RandomId();
  };
  Geometry2._GetGeometryByLoadedUniqueId = function(uniqueId, scene) {
    for (var index = 0; index < scene.geometries.length; index++) {
      if (scene.geometries[index]._loadedUniqueId === uniqueId) {
        return scene.geometries[index];
      }
    }
    return null;
  };
  Geometry2._ImportGeometry = function(parsedGeometry, mesh) {
    var scene = mesh.getScene();
    var geometryUniqueId = parsedGeometry.geometryUniqueId;
    var geometryId = parsedGeometry.geometryId;
    if (geometryUniqueId || geometryId) {
      var geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);
      if (geometry) {
        geometry.applyToMesh(mesh);
      }
    } else if (parsedGeometry instanceof ArrayBuffer) {
      var binaryInfo = mesh._binaryInfo;
      if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {
        var positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);
      }
      if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {
        var normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);
      }
      if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {
        var tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);
      }
      if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {
        var uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (var index = 1; index < uvsData.length; index += 2) {
            uvsData[index] = 1 - uvsData[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);
      }
      if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {
        var uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (var index = 1; index < uvs2Data.length; index += 2) {
            uvs2Data[index] = 1 - uvs2Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);
      }
      if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {
        var uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (var index = 1; index < uvs3Data.length; index += 2) {
            uvs3Data[index] = 1 - uvs3Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);
      }
      if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {
        var uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (var index = 1; index < uvs4Data.length; index += 2) {
            uvs4Data[index] = 1 - uvs4Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);
      }
      if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {
        var uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (var index = 1; index < uvs5Data.length; index += 2) {
            uvs5Data[index] = 1 - uvs5Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);
      }
      if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {
        var uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (var index = 1; index < uvs6Data.length; index += 2) {
            uvs6Data[index] = 1 - uvs6Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);
      }
      if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {
        var colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);
      }
      if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {
        var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);
        var floatIndices = [];
        for (var i = 0; i < matricesIndicesData.length; i++) {
          var index = matricesIndicesData[i];
          floatIndices.push(index & 255);
          floatIndices.push((index & 65280) >> 8);
          floatIndices.push((index & 16711680) >> 16);
          floatIndices.push(index >> 24 & 255);
        }
        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);
      }
      if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {
        var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);
        var floatIndices = [];
        for (var i = 0; i < matricesIndicesData.length; i++) {
          var index = matricesIndicesData[i];
          floatIndices.push(index & 255);
          floatIndices.push((index & 65280) >> 8);
          floatIndices.push((index & 16711680) >> 16);
          floatIndices.push(index >> 24 & 255);
        }
        mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);
      }
      if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {
        var matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);
      }
      if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {
        var indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);
        mesh.setIndices(indicesData, null);
      }
      if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {
        var subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);
        mesh.subMeshes = [];
        for (var i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {
          var materialIndex = subMeshesData[i * 5 + 0];
          var verticesStart = subMeshesData[i * 5 + 1];
          var verticesCount = subMeshesData[i * 5 + 2];
          var indexStart = subMeshesData[i * 5 + 3];
          var indexCount = subMeshesData[i * 5 + 4];
          SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);
        }
      }
    } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {
      mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);
      mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);
      if (parsedGeometry.tangents) {
        mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);
      }
      if (parsedGeometry.uvs) {
        mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);
      }
      if (parsedGeometry.uvs2) {
        mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);
      }
      if (parsedGeometry.uvs3) {
        mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);
      }
      if (parsedGeometry.uvs4) {
        mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);
      }
      if (parsedGeometry.uvs5) {
        mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);
      }
      if (parsedGeometry.uvs6) {
        mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);
      }
      if (parsedGeometry.colors) {
        mesh.setVerticesData(VertexBuffer.ColorKind, Color4$1.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);
      }
      if (parsedGeometry.matricesIndices) {
        if (!parsedGeometry.matricesIndices._isExpanded) {
          var floatIndices = [];
          for (var i = 0; i < parsedGeometry.matricesIndices.length; i++) {
            var matricesIndex = parsedGeometry.matricesIndices[i];
            floatIndices.push(matricesIndex & 255);
            floatIndices.push((matricesIndex & 65280) >> 8);
            floatIndices.push((matricesIndex & 16711680) >> 16);
            floatIndices.push(matricesIndex >> 24 & 255);
          }
          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);
        } else {
          delete parsedGeometry.matricesIndices._isExpanded;
          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);
        }
      }
      if (parsedGeometry.matricesIndicesExtra) {
        if (!parsedGeometry.matricesIndicesExtra._isExpanded) {
          var floatIndices = [];
          for (var i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {
            var matricesIndex = parsedGeometry.matricesIndicesExtra[i];
            floatIndices.push(matricesIndex & 255);
            floatIndices.push((matricesIndex & 65280) >> 8);
            floatIndices.push((matricesIndex & 16711680) >> 16);
            floatIndices.push(matricesIndex >> 24 & 255);
          }
          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);
        } else {
          delete parsedGeometry.matricesIndices._isExpanded;
          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);
        }
      }
      if (parsedGeometry.matricesWeights) {
        Geometry2._CleanMatricesWeights(parsedGeometry, mesh);
        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);
      }
      if (parsedGeometry.matricesWeightsExtra) {
        mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);
      }
      mesh.setIndices(parsedGeometry.indices, null);
    }
    if (parsedGeometry.subMeshes) {
      mesh.subMeshes = [];
      for (var subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {
        var parsedSubMesh = parsedGeometry.subMeshes[subIndex];
        SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);
      }
    }
    if (mesh._shouldGenerateFlatShading) {
      mesh.convertToFlatShadedMesh();
      mesh._shouldGenerateFlatShading = false;
    }
    mesh.computeWorldMatrix(true);
    scene.onMeshImportedObservable.notifyObservers(mesh);
  };
  Geometry2._CleanMatricesWeights = function(parsedGeometry, mesh) {
    var epsilon = 1e-3;
    if (!SceneLoaderFlags.CleanBoneMatrixWeights) {
      return;
    }
    var noInfluenceBoneIndex = 0;
    if (parsedGeometry.skeletonId > -1) {
      var skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);
      if (!skeleton) {
        return;
      }
      noInfluenceBoneIndex = skeleton.bones.length;
    } else {
      return;
    }
    var matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);
    var matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
    var matricesWeights = parsedGeometry.matricesWeights;
    var matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;
    var influencers = parsedGeometry.numBoneInfluencer;
    var size = matricesWeights.length;
    for (var i = 0; i < size; i += 4) {
      var weight = 0;
      var firstZeroWeight = -1;
      for (var j = 0; j < 4; j++) {
        var w = matricesWeights[i + j];
        weight += w;
        if (w < epsilon && firstZeroWeight < 0) {
          firstZeroWeight = j;
        }
      }
      if (matricesWeightsExtra) {
        for (var j = 0; j < 4; j++) {
          var w = matricesWeightsExtra[i + j];
          weight += w;
          if (w < epsilon && firstZeroWeight < 0) {
            firstZeroWeight = j + 4;
          }
        }
      }
      if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {
        firstZeroWeight = influencers - 1;
      }
      if (weight > epsilon) {
        var mweight = 1 / weight;
        for (var j = 0; j < 4; j++) {
          matricesWeights[i + j] *= mweight;
        }
        if (matricesWeightsExtra) {
          for (var j = 0; j < 4; j++) {
            matricesWeightsExtra[i + j] *= mweight;
          }
        }
      } else {
        if (firstZeroWeight >= 4) {
          matricesWeightsExtra[i + firstZeroWeight - 4] = 1 - weight;
          matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;
        } else {
          matricesWeights[i + firstZeroWeight] = 1 - weight;
          matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;
        }
      }
    }
    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);
    if (parsedGeometry.matricesWeightsExtra) {
      mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);
    }
  };
  Geometry2.Parse = function(parsedVertexData, scene, rootUrl) {
    var geometry = new Geometry2(parsedVertexData.id, scene, void 0, parsedVertexData.updatable);
    geometry._loadedUniqueId = parsedVertexData.uniqueId;
    if (Tags) {
      Tags.AddTagsTo(geometry, parsedVertexData.tags);
    }
    if (parsedVertexData.delayLoadingFile) {
      geometry.delayLoadState = 4;
      geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;
      geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));
      geometry._delayInfo = [];
      if (parsedVertexData.hasUVs) {
        geometry._delayInfo.push(VertexBuffer.UVKind);
      }
      if (parsedVertexData.hasUVs2) {
        geometry._delayInfo.push(VertexBuffer.UV2Kind);
      }
      if (parsedVertexData.hasUVs3) {
        geometry._delayInfo.push(VertexBuffer.UV3Kind);
      }
      if (parsedVertexData.hasUVs4) {
        geometry._delayInfo.push(VertexBuffer.UV4Kind);
      }
      if (parsedVertexData.hasUVs5) {
        geometry._delayInfo.push(VertexBuffer.UV5Kind);
      }
      if (parsedVertexData.hasUVs6) {
        geometry._delayInfo.push(VertexBuffer.UV6Kind);
      }
      if (parsedVertexData.hasColors) {
        geometry._delayInfo.push(VertexBuffer.ColorKind);
      }
      if (parsedVertexData.hasMatricesIndices) {
        geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);
      }
      if (parsedVertexData.hasMatricesWeights) {
        geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);
      }
      geometry._delayLoadingFunction = VertexData.ImportVertexData;
    } else {
      VertexData.ImportVertexData(parsedVertexData, geometry);
    }
    scene.pushGeometry(geometry, true);
    return geometry;
  };
  return Geometry2;
}();
var TransformNode = function(_super) {
  __extends(TransformNode2, _super);
  function TransformNode2(name2, scene, isPure) {
    if (scene === void 0) {
      scene = null;
    }
    if (isPure === void 0) {
      isPure = true;
    }
    var _this = _super.call(this, name2, scene) || this;
    _this._forward = new Vector3(0, 0, 1);
    _this._up = new Vector3(0, 1, 0);
    _this._right = new Vector3(1, 0, 0);
    _this._position = Vector3.Zero();
    _this._rotation = Vector3.Zero();
    _this._rotationQuaternion = null;
    _this._scaling = Vector3.One();
    _this._transformToBoneReferal = null;
    _this._isAbsoluteSynced = false;
    _this._billboardMode = TransformNode2.BILLBOARDMODE_NONE;
    _this._preserveParentRotationForBillboard = false;
    _this.scalingDeterminant = 1;
    _this._infiniteDistance = false;
    _this.ignoreNonUniformScaling = false;
    _this.reIntegrateRotationIntoRotationQuaternion = false;
    _this._poseMatrix = null;
    _this._localMatrix = Matrix.Zero();
    _this._usePivotMatrix = false;
    _this._absolutePosition = Vector3.Zero();
    _this._absoluteScaling = Vector3.Zero();
    _this._absoluteRotationQuaternion = Quaternion.Identity();
    _this._pivotMatrix = Matrix.Identity();
    _this._postMultiplyPivotMatrix = false;
    _this._isWorldMatrixFrozen = false;
    _this._indexInSceneTransformNodesArray = -1;
    _this.onAfterWorldMatrixUpdateObservable = new Observable();
    _this._nonUniformScaling = false;
    if (isPure) {
      _this.getScene().addTransformNode(_this);
    }
    return _this;
  }
  Object.defineProperty(TransformNode2.prototype, "billboardMode", {
    get: function() {
      return this._billboardMode;
    },
    set: function(value) {
      if (this._billboardMode === value) {
        return;
      }
      this._billboardMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "preserveParentRotationForBillboard", {
    get: function() {
      return this._preserveParentRotationForBillboard;
    },
    set: function(value) {
      if (value === this._preserveParentRotationForBillboard) {
        return;
      }
      this._preserveParentRotationForBillboard = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "infiniteDistance", {
    get: function() {
      return this._infiniteDistance;
    },
    set: function(value) {
      if (this._infiniteDistance === value) {
        return;
      }
      this._infiniteDistance = value;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.getClassName = function() {
    return "TransformNode";
  };
  Object.defineProperty(TransformNode2.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(newPosition) {
      this._position = newPosition;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.isUsingPivotMatrix = function() {
    return this._usePivotMatrix;
  };
  Object.defineProperty(TransformNode2.prototype, "rotation", {
    get: function() {
      return this._rotation;
    },
    set: function(newRotation) {
      this._rotation = newRotation;
      this._rotationQuaternion = null;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "scaling", {
    get: function() {
      return this._scaling;
    },
    set: function(newScaling) {
      this._scaling = newScaling;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "rotationQuaternion", {
    get: function() {
      return this._rotationQuaternion;
    },
    set: function(quaternion) {
      this._rotationQuaternion = quaternion;
      if (quaternion) {
        this._rotation.setAll(0);
      }
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "forward", {
    get: function() {
      Vector3.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1 : 1, this.getWorldMatrix(), this._forward);
      return this._forward.normalize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "up", {
    get: function() {
      Vector3.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up);
      return this._up.normalize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "right", {
    get: function() {
      Vector3.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1 : 1, 0, 0, this.getWorldMatrix(), this._right);
      return this._right.normalize();
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.updatePoseMatrix = function(matrix) {
    if (!this._poseMatrix) {
      this._poseMatrix = matrix.clone();
      return this;
    }
    this._poseMatrix.copyFrom(matrix);
    return this;
  };
  TransformNode2.prototype.getPoseMatrix = function() {
    if (!this._poseMatrix) {
      this._poseMatrix = Matrix.Identity();
    }
    return this._poseMatrix;
  };
  TransformNode2.prototype._isSynchronized = function() {
    var cache = this._cache;
    if (this.billboardMode !== cache.billboardMode || this.billboardMode !== TransformNode2.BILLBOARDMODE_NONE) {
      return false;
    }
    if (cache.pivotMatrixUpdated) {
      return false;
    }
    if (this.infiniteDistance) {
      return false;
    }
    if (this.position._isDirty) {
      return false;
    }
    if (this.scaling._isDirty) {
      return false;
    }
    if (this._rotationQuaternion && this._rotationQuaternion._isDirty || this.rotation._isDirty) {
      return false;
    }
    return true;
  };
  TransformNode2.prototype._initCache = function() {
    _super.prototype._initCache.call(this);
    var cache = this._cache;
    cache.localMatrixUpdated = false;
    cache.billboardMode = -1;
    cache.infiniteDistance = false;
  };
  Object.defineProperty(TransformNode2.prototype, "absolutePosition", {
    get: function() {
      return this.getAbsolutePosition();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "absoluteScaling", {
    get: function() {
      this._syncAbsoluteScalingAndRotation();
      return this._absoluteScaling;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "absoluteRotationQuaternion", {
    get: function() {
      this._syncAbsoluteScalingAndRotation();
      return this._absoluteRotationQuaternion;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.setPreTransformMatrix = function(matrix) {
    return this.setPivotMatrix(matrix, false);
  };
  TransformNode2.prototype.setPivotMatrix = function(matrix, postMultiplyPivotMatrix) {
    if (postMultiplyPivotMatrix === void 0) {
      postMultiplyPivotMatrix = true;
    }
    this._pivotMatrix.copyFrom(matrix);
    this._usePivotMatrix = !this._pivotMatrix.isIdentity();
    this._cache.pivotMatrixUpdated = true;
    this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;
    if (this._postMultiplyPivotMatrix) {
      if (!this._pivotMatrixInverse) {
        this._pivotMatrixInverse = Matrix.Invert(this._pivotMatrix);
      } else {
        this._pivotMatrix.invertToRef(this._pivotMatrixInverse);
      }
    }
    return this;
  };
  TransformNode2.prototype.getPivotMatrix = function() {
    return this._pivotMatrix;
  };
  TransformNode2.prototype.instantiateHierarchy = function(newParent, options, onNewNodeCreated) {
    if (newParent === void 0) {
      newParent = null;
    }
    var clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true);
    if (clone) {
      if (onNewNodeCreated) {
        onNewNodeCreated(this, clone);
      }
    }
    for (var _i = 0, _a = this.getChildTransformNodes(true); _i < _a.length; _i++) {
      var child = _a[_i];
      child.instantiateHierarchy(clone, options, onNewNodeCreated);
    }
    return clone;
  };
  TransformNode2.prototype.freezeWorldMatrix = function(newWorldMatrix, decompose) {
    if (newWorldMatrix === void 0) {
      newWorldMatrix = null;
    }
    if (decompose === void 0) {
      decompose = false;
    }
    if (newWorldMatrix) {
      if (decompose) {
        this._rotation.setAll(0);
        this._rotationQuaternion = this._rotationQuaternion || Quaternion.Identity();
        newWorldMatrix.decompose(this._scaling, this._rotationQuaternion, this._position);
        this.computeWorldMatrix(true);
      } else {
        this._worldMatrix = newWorldMatrix;
        this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
        this._afterComputeWorldMatrix();
      }
    } else {
      this._isWorldMatrixFrozen = false;
      this.computeWorldMatrix(true);
    }
    this._isDirty = false;
    this._isWorldMatrixFrozen = true;
    return this;
  };
  TransformNode2.prototype.unfreezeWorldMatrix = function() {
    this._isWorldMatrixFrozen = false;
    this.computeWorldMatrix(true);
    return this;
  };
  Object.defineProperty(TransformNode2.prototype, "isWorldMatrixFrozen", {
    get: function() {
      return this._isWorldMatrixFrozen;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.getAbsolutePosition = function() {
    this.computeWorldMatrix();
    return this._absolutePosition;
  };
  TransformNode2.prototype.setAbsolutePosition = function(absolutePosition) {
    if (!absolutePosition) {
      return this;
    }
    var absolutePositionX;
    var absolutePositionY;
    var absolutePositionZ;
    if (absolutePosition.x === void 0) {
      if (arguments.length < 3) {
        return this;
      }
      absolutePositionX = arguments[0];
      absolutePositionY = arguments[1];
      absolutePositionZ = arguments[2];
    } else {
      absolutePositionX = absolutePosition.x;
      absolutePositionY = absolutePosition.y;
      absolutePositionZ = absolutePosition.z;
    }
    if (this.parent) {
      var invertParentWorldMatrix = TmpVectors.Matrix[0];
      this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
      Vector3.TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);
    } else {
      this.position.x = absolutePositionX;
      this.position.y = absolutePositionY;
      this.position.z = absolutePositionZ;
    }
    this._absolutePosition.copyFrom(absolutePosition);
    return this;
  };
  TransformNode2.prototype.setPositionWithLocalVector = function(vector3) {
    this.computeWorldMatrix();
    this.position = Vector3.TransformNormal(vector3, this._localMatrix);
    return this;
  };
  TransformNode2.prototype.getPositionExpressedInLocalSpace = function() {
    this.computeWorldMatrix();
    var invLocalWorldMatrix = TmpVectors.Matrix[0];
    this._localMatrix.invertToRef(invLocalWorldMatrix);
    return Vector3.TransformNormal(this.position, invLocalWorldMatrix);
  };
  TransformNode2.prototype.locallyTranslate = function(vector3) {
    this.computeWorldMatrix(true);
    this.position = Vector3.TransformCoordinates(vector3, this._localMatrix);
    return this;
  };
  TransformNode2.prototype.lookAt = function(targetPoint, yawCor, pitchCor, rollCor, space) {
    if (yawCor === void 0) {
      yawCor = 0;
    }
    if (pitchCor === void 0) {
      pitchCor = 0;
    }
    if (rollCor === void 0) {
      rollCor = 0;
    }
    if (space === void 0) {
      space = Space.LOCAL;
    }
    var dv = TransformNode2._lookAtVectorCache;
    var pos = space === Space.LOCAL ? this.position : this.getAbsolutePosition();
    targetPoint.subtractToRef(pos, dv);
    this.setDirection(dv, yawCor, pitchCor, rollCor);
    if (space === Space.WORLD && this.parent) {
      if (this.rotationQuaternion) {
        var rotationMatrix = TmpVectors.Matrix[0];
        this.rotationQuaternion.toRotationMatrix(rotationMatrix);
        var parentRotationMatrix = TmpVectors.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
        parentRotationMatrix.invert();
        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
        this.rotationQuaternion.fromRotationMatrix(rotationMatrix);
      } else {
        var quaternionRotation = TmpVectors.Quaternion[0];
        Quaternion.FromEulerVectorToRef(this.rotation, quaternionRotation);
        var rotationMatrix = TmpVectors.Matrix[0];
        quaternionRotation.toRotationMatrix(rotationMatrix);
        var parentRotationMatrix = TmpVectors.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
        parentRotationMatrix.invert();
        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
        quaternionRotation.fromRotationMatrix(rotationMatrix);
        quaternionRotation.toEulerAnglesToRef(this.rotation);
      }
    }
    return this;
  };
  TransformNode2.prototype.getDirection = function(localAxis) {
    var result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  };
  TransformNode2.prototype.getDirectionToRef = function(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
    return this;
  };
  TransformNode2.prototype.setDirection = function(localAxis, yawCor, pitchCor, rollCor) {
    if (yawCor === void 0) {
      yawCor = 0;
    }
    if (pitchCor === void 0) {
      pitchCor = 0;
    }
    if (rollCor === void 0) {
      rollCor = 0;
    }
    var yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;
    var len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);
    var pitch = -Math.atan2(localAxis.y, len);
    if (this.rotationQuaternion) {
      Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);
    } else {
      this.rotation.x = pitch + pitchCor;
      this.rotation.y = yaw + yawCor;
      this.rotation.z = rollCor;
    }
    return this;
  };
  TransformNode2.prototype.setPivotPoint = function(point, space) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (this.getScene().getRenderId() == 0) {
      this.computeWorldMatrix(true);
    }
    var wm = this.getWorldMatrix();
    if (space == Space.WORLD) {
      var tmat = TmpVectors.Matrix[0];
      wm.invertToRef(tmat);
      point = Vector3.TransformCoordinates(point, tmat);
    }
    return this.setPivotMatrix(Matrix.Translation(-point.x, -point.y, -point.z), true);
  };
  TransformNode2.prototype.getPivotPoint = function() {
    var point = Vector3.Zero();
    this.getPivotPointToRef(point);
    return point;
  };
  TransformNode2.prototype.getPivotPointToRef = function(result) {
    result.x = -this._pivotMatrix.m[12];
    result.y = -this._pivotMatrix.m[13];
    result.z = -this._pivotMatrix.m[14];
    return this;
  };
  TransformNode2.prototype.getAbsolutePivotPoint = function() {
    var point = Vector3.Zero();
    this.getAbsolutePivotPointToRef(point);
    return point;
  };
  TransformNode2.prototype.getAbsolutePivotPointToRef = function(result) {
    this.getPivotPointToRef(result);
    Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);
    return this;
  };
  TransformNode2.prototype.markAsDirty = function(property) {
    if (this._children) {
      for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
        var child = _a[_i];
        child.markAsDirty(property);
      }
    }
    return _super.prototype.markAsDirty.call(this, property);
  };
  TransformNode2.prototype.setParent = function(node, preserveScalingSign) {
    if (preserveScalingSign === void 0) {
      preserveScalingSign = false;
    }
    if (!node && !this.parent) {
      return this;
    }
    var quatRotation = TmpVectors.Quaternion[0];
    var position = TmpVectors.Vector3[0];
    var scale = TmpVectors.Vector3[1];
    var invParentMatrix = TmpVectors.Matrix[1];
    Matrix.IdentityToRef(invParentMatrix);
    var composedMatrix = TmpVectors.Matrix[0];
    this.computeWorldMatrix(true);
    var currentRotation = this.rotationQuaternion;
    if (!currentRotation) {
      currentRotation = TransformNode2._TmpRotation;
      Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, currentRotation);
    }
    Matrix.ComposeToRef(this.scaling, currentRotation, this.position, composedMatrix);
    if (this.parent) {
      composedMatrix.multiplyToRef(this.parent.computeWorldMatrix(true), composedMatrix);
    }
    if (node) {
      node.computeWorldMatrix(true).invertToRef(invParentMatrix);
      composedMatrix.multiplyToRef(invParentMatrix, composedMatrix);
    }
    composedMatrix.decompose(scale, quatRotation, position, preserveScalingSign ? this : void 0);
    if (this.rotationQuaternion) {
      this.rotationQuaternion.copyFrom(quatRotation);
    } else {
      quatRotation.toEulerAnglesToRef(this.rotation);
    }
    this.scaling.copyFrom(scale);
    this.position.copyFrom(position);
    this.parent = node;
    return this;
  };
  Object.defineProperty(TransformNode2.prototype, "nonUniformScaling", {
    get: function() {
      return this._nonUniformScaling;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype._updateNonUniformScalingState = function(value) {
    if (this._nonUniformScaling === value) {
      return false;
    }
    this._nonUniformScaling = value;
    return true;
  };
  TransformNode2.prototype.attachToBone = function(bone, affectedTransformNode) {
    this._currentParentWhenAttachingToBone = this.parent;
    this._transformToBoneReferal = affectedTransformNode;
    this.parent = bone;
    bone.getSkeleton().prepare();
    if (bone.getWorldMatrix().determinant() < 0) {
      this.scalingDeterminant *= -1;
    }
    return this;
  };
  TransformNode2.prototype.detachFromBone = function(resetToPreviousParent) {
    if (resetToPreviousParent === void 0) {
      resetToPreviousParent = false;
    }
    if (!this.parent) {
      if (resetToPreviousParent) {
        this.parent = this._currentParentWhenAttachingToBone;
      }
      return this;
    }
    if (this.parent.getWorldMatrix().determinant() < 0) {
      this.scalingDeterminant *= -1;
    }
    this._transformToBoneReferal = null;
    if (resetToPreviousParent) {
      this.parent = this._currentParentWhenAttachingToBone;
    } else {
      this.parent = null;
    }
    return this;
  };
  TransformNode2.prototype.rotate = function(axis, amount, space) {
    axis.normalize();
    if (!this.rotationQuaternion) {
      this.rotationQuaternion = this.rotation.toQuaternion();
      this.rotation.setAll(0);
    }
    var rotationQuaternion;
    if (!space || space === Space.LOCAL) {
      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode2._rotationAxisCache);
      this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);
    } else {
      if (this.parent) {
        var invertParentWorldMatrix = TmpVectors.Matrix[0];
        this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
        axis = Vector3.TransformNormal(axis, invertParentWorldMatrix);
      }
      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode2._rotationAxisCache);
      rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    }
    return this;
  };
  TransformNode2.prototype.rotateAround = function(point, axis, amount) {
    axis.normalize();
    if (!this.rotationQuaternion) {
      this.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
      this.rotation.setAll(0);
    }
    var tmpVector = TmpVectors.Vector3[0];
    var finalScale = TmpVectors.Vector3[1];
    var finalTranslation = TmpVectors.Vector3[2];
    var finalRotation = TmpVectors.Quaternion[0];
    var translationMatrix = TmpVectors.Matrix[0];
    var translationMatrixInv = TmpVectors.Matrix[1];
    var rotationMatrix = TmpVectors.Matrix[2];
    var finalMatrix = TmpVectors.Matrix[3];
    point.subtractToRef(this.position, tmpVector);
    Matrix.TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix);
    Matrix.TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv);
    Matrix.RotationAxisToRef(axis, amount, rotationMatrix);
    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix);
    finalMatrix.multiplyToRef(translationMatrix, finalMatrix);
    finalMatrix.decompose(finalScale, finalRotation, finalTranslation);
    this.position.addInPlace(finalTranslation);
    finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    return this;
  };
  TransformNode2.prototype.translate = function(axis, distance, space) {
    var displacementVector = axis.scale(distance);
    if (!space || space === Space.LOCAL) {
      var tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);
      this.setPositionWithLocalVector(tempV3);
    } else {
      this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));
    }
    return this;
  };
  TransformNode2.prototype.addRotation = function(x, y, z) {
    var rotationQuaternion;
    if (this.rotationQuaternion) {
      rotationQuaternion = this.rotationQuaternion;
    } else {
      rotationQuaternion = TmpVectors.Quaternion[1];
      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);
    }
    var accumulation = TmpVectors.Quaternion[0];
    Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);
    rotationQuaternion.multiplyInPlace(accumulation);
    if (!this.rotationQuaternion) {
      rotationQuaternion.toEulerAnglesToRef(this.rotation);
    }
    return this;
  };
  TransformNode2.prototype._getEffectiveParent = function() {
    return this.parent;
  };
  TransformNode2.prototype.computeWorldMatrix = function(force) {
    if (this._isWorldMatrixFrozen && !this._isDirty) {
      return this._worldMatrix;
    }
    var currentRenderId = this.getScene().getRenderId();
    if (!this._isDirty && !force && this.isSynchronized()) {
      this._currentRenderId = currentRenderId;
      return this._worldMatrix;
    }
    var camera = this.getScene().activeCamera;
    var useBillboardPosition = (this._billboardMode & TransformNode2.BILLBOARDMODE_USE_POSITION) !== 0;
    var useBillboardPath = this._billboardMode !== TransformNode2.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
    this._updateCache();
    var cache = this._cache;
    cache.pivotMatrixUpdated = false;
    cache.billboardMode = this.billboardMode;
    cache.infiniteDistance = this.infiniteDistance;
    this._currentRenderId = currentRenderId;
    this._childUpdateId += 1;
    this._isDirty = false;
    this._position._isDirty = false;
    this._rotation._isDirty = false;
    this._scaling._isDirty = false;
    var parent = this._getEffectiveParent();
    var scaling = TransformNode2._TmpScaling;
    var translation = this._position;
    if (this._infiniteDistance) {
      if (!this.parent && camera) {
        var cameraWorldMatrix = camera.getWorldMatrix();
        var cameraGlobalPosition = new Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);
        translation = TransformNode2._TmpTranslation;
        translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);
      }
    }
    scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);
    var rotation;
    if (this._rotationQuaternion) {
      this._rotationQuaternion._isDirty = false;
      rotation = this._rotationQuaternion;
      if (this.reIntegrateRotationIntoRotationQuaternion) {
        var len = this.rotation.lengthSquared();
        if (len) {
          this._rotationQuaternion.multiplyInPlace(Quaternion.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));
          this._rotation.copyFromFloats(0, 0, 0);
        }
      }
    } else {
      rotation = TransformNode2._TmpRotation;
      Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);
    }
    if (this._usePivotMatrix) {
      var scaleMatrix = TmpVectors.Matrix[1];
      Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix);
      var rotationMatrix = TmpVectors.Matrix[0];
      rotation.toRotationMatrix(rotationMatrix);
      this._pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);
      TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix);
      if (this._postMultiplyPivotMatrix) {
        this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);
      }
      this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);
    } else {
      Matrix.ComposeToRef(scaling, rotation, translation, this._localMatrix);
    }
    if (parent && parent.getWorldMatrix) {
      if (force) {
        parent.computeWorldMatrix(force);
      }
      if (useBillboardPath) {
        if (this._transformToBoneReferal) {
          parent.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), TmpVectors.Matrix[7]);
        } else {
          TmpVectors.Matrix[7].copyFrom(parent.getWorldMatrix());
        }
        var translation_1 = TmpVectors.Vector3[5];
        var scale = TmpVectors.Vector3[6];
        TmpVectors.Matrix[7].decompose(scale, void 0, translation_1);
        Matrix.ScalingToRef(scale.x, scale.y, scale.z, TmpVectors.Matrix[7]);
        TmpVectors.Matrix[7].setTranslation(translation_1);
        this._localMatrix.multiplyToRef(TmpVectors.Matrix[7], this._worldMatrix);
      } else {
        if (this._transformToBoneReferal) {
          this._localMatrix.multiplyToRef(parent.getWorldMatrix(), TmpVectors.Matrix[6]);
          TmpVectors.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);
        } else {
          this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);
        }
      }
      this._markSyncedWithParent();
    } else {
      this._worldMatrix.copyFrom(this._localMatrix);
    }
    if (useBillboardPath && camera && this.billboardMode && !useBillboardPosition) {
      var storedTranslation = TmpVectors.Vector3[0];
      this._worldMatrix.getTranslationToRef(storedTranslation);
      TmpVectors.Matrix[1].copyFrom(camera.getViewMatrix());
      TmpVectors.Matrix[1].setTranslationFromFloats(0, 0, 0);
      TmpVectors.Matrix[1].invertToRef(TmpVectors.Matrix[0]);
      if ((this.billboardMode & TransformNode2.BILLBOARDMODE_ALL) !== TransformNode2.BILLBOARDMODE_ALL) {
        TmpVectors.Matrix[0].decompose(void 0, TmpVectors.Quaternion[0], void 0);
        var eulerAngles = TmpVectors.Vector3[1];
        TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_X) !== TransformNode2.BILLBOARDMODE_X) {
          eulerAngles.x = 0;
        }
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Y) !== TransformNode2.BILLBOARDMODE_Y) {
          eulerAngles.y = 0;
        }
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Z) !== TransformNode2.BILLBOARDMODE_Z) {
          eulerAngles.z = 0;
        }
        Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0);
      this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
      this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
    } else if (useBillboardPath && camera && this.billboardMode && useBillboardPosition) {
      var storedTranslation = TmpVectors.Vector3[0];
      this._worldMatrix.getTranslationToRef(storedTranslation);
      var cameraPosition = camera.globalPosition;
      this._worldMatrix.invertToRef(TmpVectors.Matrix[1]);
      var camInObjSpace = TmpVectors.Vector3[1];
      Vector3.TransformCoordinatesToRef(cameraPosition, TmpVectors.Matrix[1], camInObjSpace);
      camInObjSpace.normalize();
      var yaw = -Math.atan2(camInObjSpace.z, camInObjSpace.x) + Math.PI / 2;
      var len_1 = Math.sqrt(camInObjSpace.x * camInObjSpace.x + camInObjSpace.z * camInObjSpace.z);
      var pitch = -Math.atan2(camInObjSpace.y, len_1);
      Quaternion.RotationYawPitchRollToRef(yaw, pitch, 0, TmpVectors.Quaternion[0]);
      if ((this.billboardMode & TransformNode2.BILLBOARDMODE_ALL) !== TransformNode2.BILLBOARDMODE_ALL) {
        var eulerAngles = TmpVectors.Vector3[1];
        TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_X) !== TransformNode2.BILLBOARDMODE_X) {
          eulerAngles.x = 0;
        }
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Y) !== TransformNode2.BILLBOARDMODE_Y) {
          eulerAngles.y = 0;
        }
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Z) !== TransformNode2.BILLBOARDMODE_Z) {
          eulerAngles.z = 0;
        }
        Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
      } else {
        Matrix.FromQuaternionToRef(TmpVectors.Quaternion[0], TmpVectors.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0);
      this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
      this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
    }
    if (!this.ignoreNonUniformScaling) {
      if (this._scaling.isNonUniformWithinEpsilon(1e-6)) {
        this._updateNonUniformScalingState(true);
      } else if (parent && parent._nonUniformScaling) {
        this._updateNonUniformScalingState(parent._nonUniformScaling);
      } else {
        this._updateNonUniformScalingState(false);
      }
    } else {
      this._updateNonUniformScalingState(false);
    }
    this._afterComputeWorldMatrix();
    this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
    this._isAbsoluteSynced = false;
    this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);
    if (!this._poseMatrix) {
      this._poseMatrix = Matrix.Invert(this._worldMatrix);
    }
    this._worldMatrixDeterminantIsDirty = true;
    return this._worldMatrix;
  };
  TransformNode2.prototype.resetLocalMatrix = function(independentOfChildren) {
    if (independentOfChildren === void 0) {
      independentOfChildren = true;
    }
    this.computeWorldMatrix();
    if (independentOfChildren) {
      var children = this.getChildren();
      for (var i = 0; i < children.length; ++i) {
        var child = children[i];
        if (child) {
          child.computeWorldMatrix();
          var bakedMatrix = TmpVectors.Matrix[0];
          child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);
          var tmpRotationQuaternion = TmpVectors.Quaternion[0];
          bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);
          if (child.rotationQuaternion) {
            child.rotationQuaternion.copyFrom(tmpRotationQuaternion);
          } else {
            tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);
          }
        }
      }
    }
    this.scaling.copyFromFloats(1, 1, 1);
    this.position.copyFromFloats(0, 0, 0);
    this.rotation.copyFromFloats(0, 0, 0);
    if (this.rotationQuaternion) {
      this.rotationQuaternion = Quaternion.Identity();
    }
    this._worldMatrix = Matrix.Identity();
  };
  TransformNode2.prototype._afterComputeWorldMatrix = function() {
  };
  TransformNode2.prototype.registerAfterWorldMatrixUpdate = function(func) {
    this.onAfterWorldMatrixUpdateObservable.add(func);
    return this;
  };
  TransformNode2.prototype.unregisterAfterWorldMatrixUpdate = function(func) {
    this.onAfterWorldMatrixUpdateObservable.removeCallback(func);
    return this;
  };
  TransformNode2.prototype.getPositionInCameraSpace = function(camera) {
    if (camera === void 0) {
      camera = null;
    }
    if (!camera) {
      camera = this.getScene().activeCamera;
    }
    return Vector3.TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());
  };
  TransformNode2.prototype.getDistanceToCamera = function(camera) {
    if (camera === void 0) {
      camera = null;
    }
    if (!camera) {
      camera = this.getScene().activeCamera;
    }
    return this.getAbsolutePosition().subtract(camera.globalPosition).length();
  };
  TransformNode2.prototype.clone = function(name2, newParent, doNotCloneChildren) {
    var _this = this;
    var result = SerializationHelper.Clone(function() {
      return new TransformNode2(name2, _this.getScene());
    }, this);
    result.name = name2;
    result.id = name2;
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      var directDescendants = this.getDescendants(true);
      for (var index = 0; index < directDescendants.length; index++) {
        var child = directDescendants[index];
        if (child.clone) {
          child.clone(name2 + "." + child.name, result);
        }
      }
    }
    return result;
  };
  TransformNode2.prototype.serialize = function(currentSerializationObject) {
    var serializationObject = SerializationHelper.Serialize(this, currentSerializationObject);
    serializationObject.type = this.getClassName();
    serializationObject.uniqueId = this.uniqueId;
    if (this.parent) {
      serializationObject.parentId = this.parent.uniqueId;
    }
    serializationObject.localMatrix = this.getPivotMatrix().asArray();
    serializationObject.isEnabled = this.isEnabled();
    if (this.parent) {
      serializationObject.parentId = this.parent.uniqueId;
    }
    return serializationObject;
  };
  TransformNode2.Parse = function(parsedTransformNode, scene, rootUrl) {
    var transformNode = SerializationHelper.Parse(function() {
      return new TransformNode2(parsedTransformNode.name, scene);
    }, parsedTransformNode, scene, rootUrl);
    if (parsedTransformNode.localMatrix) {
      transformNode.setPreTransformMatrix(Matrix.FromArray(parsedTransformNode.localMatrix));
    } else if (parsedTransformNode.pivotMatrix) {
      transformNode.setPivotMatrix(Matrix.FromArray(parsedTransformNode.pivotMatrix));
    }
    transformNode.setEnabled(parsedTransformNode.isEnabled);
    if (parsedTransformNode.parentId !== void 0) {
      transformNode._waitingParentId = parsedTransformNode.parentId;
    }
    return transformNode;
  };
  TransformNode2.prototype.getChildTransformNodes = function(directDescendantsOnly, predicate) {
    var results = [];
    this._getDescendants(results, directDescendantsOnly, function(node) {
      return (!predicate || predicate(node)) && node instanceof TransformNode2;
    });
    return results;
  };
  TransformNode2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this.getScene().stopAnimation(this);
    this.getScene().removeTransformNode(this);
    if (this._parentContainer) {
      var index = this._parentContainer.transformNodes.indexOf(this);
      if (index > -1) {
        this._parentContainer.transformNodes.splice(index, 1);
      }
      this._parentContainer = null;
    }
    this.onAfterWorldMatrixUpdateObservable.clear();
    if (doNotRecurse) {
      var transformNodes = this.getChildTransformNodes(true);
      for (var _i = 0, transformNodes_1 = transformNodes; _i < transformNodes_1.length; _i++) {
        var transformNode = transformNodes_1[_i];
        transformNode.parent = null;
        transformNode.computeWorldMatrix(true);
      }
    }
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  TransformNode2.prototype.normalizeToUnitCube = function(includeDescendants, ignoreRotation, predicate) {
    if (includeDescendants === void 0) {
      includeDescendants = true;
    }
    if (ignoreRotation === void 0) {
      ignoreRotation = false;
    }
    var storedRotation = null;
    var storedRotationQuaternion = null;
    if (ignoreRotation) {
      if (this.rotationQuaternion) {
        storedRotationQuaternion = this.rotationQuaternion.clone();
        this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
      } else if (this.rotation) {
        storedRotation = this.rotation.clone();
        this.rotation.copyFromFloats(0, 0, 0);
      }
    }
    var boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);
    var sizeVec = boundingVectors.max.subtract(boundingVectors.min);
    var maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
    if (maxDimension === 0) {
      return this;
    }
    var scale = 1 / maxDimension;
    this.scaling.scaleInPlace(scale);
    if (ignoreRotation) {
      if (this.rotationQuaternion && storedRotationQuaternion) {
        this.rotationQuaternion.copyFrom(storedRotationQuaternion);
      } else if (this.rotation && storedRotation) {
        this.rotation.copyFrom(storedRotation);
      }
    }
    return this;
  };
  TransformNode2.prototype._syncAbsoluteScalingAndRotation = function() {
    if (!this._isAbsoluteSynced) {
      this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);
      this._isAbsoluteSynced = true;
    }
  };
  TransformNode2.BILLBOARDMODE_NONE = 0;
  TransformNode2.BILLBOARDMODE_X = 1;
  TransformNode2.BILLBOARDMODE_Y = 2;
  TransformNode2.BILLBOARDMODE_Z = 4;
  TransformNode2.BILLBOARDMODE_ALL = 7;
  TransformNode2.BILLBOARDMODE_USE_POSITION = 128;
  TransformNode2._TmpRotation = Quaternion.Zero();
  TransformNode2._TmpScaling = Vector3.Zero();
  TransformNode2._TmpTranslation = Vector3.Zero();
  TransformNode2._lookAtVectorCache = new Vector3(0, 0, 0);
  TransformNode2._rotationAxisCache = new Quaternion();
  __decorate([
    serializeAsVector3("position")
  ], TransformNode2.prototype, "_position", void 0);
  __decorate([
    serializeAsVector3("rotation")
  ], TransformNode2.prototype, "_rotation", void 0);
  __decorate([
    serializeAsQuaternion("rotationQuaternion")
  ], TransformNode2.prototype, "_rotationQuaternion", void 0);
  __decorate([
    serializeAsVector3("scaling")
  ], TransformNode2.prototype, "_scaling", void 0);
  __decorate([
    serialize("billboardMode")
  ], TransformNode2.prototype, "_billboardMode", void 0);
  __decorate([
    serialize()
  ], TransformNode2.prototype, "scalingDeterminant", void 0);
  __decorate([
    serialize("infiniteDistance")
  ], TransformNode2.prototype, "_infiniteDistance", void 0);
  __decorate([
    serialize()
  ], TransformNode2.prototype, "ignoreNonUniformScaling", void 0);
  __decorate([
    serialize()
  ], TransformNode2.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0);
  return TransformNode2;
}(Node);
var _MeshCollisionData = function() {
  function _MeshCollisionData2() {
    this._checkCollisions = false;
    this._collisionMask = -1;
    this._collisionGroup = -1;
    this._surroundingMeshes = null;
    this._collider = null;
    this._oldPositionForCollisions = new Vector3(0, 0, 0);
    this._diffPositionForCollisions = new Vector3(0, 0, 0);
    this._collisionResponse = true;
  }
  return _MeshCollisionData2;
}();
var _FacetDataStorage = function() {
  function _FacetDataStorage2() {
    this.facetNb = 0;
    this.partitioningSubdivisions = 10;
    this.partitioningBBoxRatio = 1.01;
    this.facetDataEnabled = false;
    this.facetParameters = {};
    this.bbSize = Vector3.Zero();
    this.subDiv = {
      max: 1,
      X: 1,
      Y: 1,
      Z: 1
    };
    this.facetDepthSort = false;
    this.facetDepthSortEnabled = false;
  }
  return _FacetDataStorage2;
}();
var _InternalAbstractMeshDataInfo = function() {
  function _InternalAbstractMeshDataInfo2() {
    this._hasVertexAlpha = false;
    this._useVertexColors = true;
    this._numBoneInfluencers = 4;
    this._applyFog = true;
    this._receiveShadows = false;
    this._facetData = new _FacetDataStorage();
    this._visibility = 1;
    this._skeleton = null;
    this._layerMask = 268435455;
    this._computeBonesUsingShaders = true;
    this._isActive = false;
    this._onlyForInstances = false;
    this._isActiveIntermediate = false;
    this._onlyForInstancesIntermediate = false;
    this._actAsRegularMesh = false;
    this._currentLOD = null;
    this._currentLODIsUpToDate = false;
    this._collisionRetryCount = 3;
    this._morphTargetManager = null;
    this._renderingGroupId = 0;
    this._bakedVertexAnimationManager = null;
    this._material = null;
    this._positions = null;
    this._meshCollisionData = new _MeshCollisionData();
    this._enableDistantPicking = false;
  }
  return _InternalAbstractMeshDataInfo2;
}();
var AbstractMesh = function(_super) {
  __extends(AbstractMesh2, _super);
  function AbstractMesh2(name2, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var _this = _super.call(this, name2, scene, false) || this;
    _this._internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();
    _this._waitingMaterialId = null;
    _this.cullingStrategy = AbstractMesh2.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
    _this.onCollideObservable = new Observable();
    _this.onCollisionPositionChangeObservable = new Observable();
    _this.onMaterialChangedObservable = new Observable();
    _this.definedFacingForward = true;
    _this._occlusionQuery = null;
    _this._renderingGroup = null;
    _this.alphaIndex = Number.MAX_VALUE;
    _this.isVisible = true;
    _this.isPickable = true;
    _this.isNearPickable = false;
    _this.isNearGrabbable = false;
    _this.showSubMeshesBoundingBox = false;
    _this.isBlocker = false;
    _this.enablePointerMoveEvents = false;
    _this.outlineColor = Color3.Red();
    _this.outlineWidth = 0.02;
    _this.overlayColor = Color3.Red();
    _this.overlayAlpha = 0.5;
    _this.useOctreeForRenderingSelection = true;
    _this.useOctreeForPicking = true;
    _this.useOctreeForCollisions = true;
    _this.alwaysSelectAsActiveMesh = false;
    _this.doNotSyncBoundingInfo = false;
    _this.actionManager = null;
    _this.ellipsoid = new Vector3(0.5, 1, 0.5);
    _this.ellipsoidOffset = new Vector3(0, 0, 0);
    _this.edgesWidth = 1;
    _this.edgesColor = new Color4$1(1, 0, 0, 1);
    _this._edgesRenderer = null;
    _this._masterMesh = null;
    _this._boundingInfo = null;
    _this._boundingInfoIsDirty = true;
    _this._renderId = 0;
    _this._intersectionsInProgress = new Array();
    _this._unIndexed = false;
    _this._lightSources = new Array();
    _this._waitingData = {
      lods: null,
      actions: null,
      freezeWorldMatrix: null
    };
    _this._bonesTransformMatrices = null;
    _this._transformMatrixTexture = null;
    _this.onRebuildObservable = new Observable();
    _this._onCollisionPositionChange = function(collisionId, newPosition, collidedMesh) {
      if (collidedMesh === void 0) {
        collidedMesh = null;
      }
      newPosition.subtractToRef(_this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, _this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
      if (_this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > Engine.CollisionsEpsilon) {
        _this.position.addInPlace(_this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
      }
      if (collidedMesh) {
        _this.onCollideObservable.notifyObservers(collidedMesh);
      }
      _this.onCollisionPositionChangeObservable.notifyObservers(_this.position);
    };
    _this.getScene().addMesh(_this);
    _this._resyncLightSources();
    _this._uniformBuffer = new UniformBuffer(_this.getScene().getEngine(), void 0, void 0, name2);
    _this._buildUniformLayout();
    return _this;
  }
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_NONE", {
    get: function() {
      return TransformNode.BILLBOARDMODE_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_X", {
    get: function() {
      return TransformNode.BILLBOARDMODE_X;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_Y", {
    get: function() {
      return TransformNode.BILLBOARDMODE_Y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_Z", {
    get: function() {
      return TransformNode.BILLBOARDMODE_Z;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_ALL", {
    get: function() {
      return TransformNode.BILLBOARDMODE_ALL;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_USE_POSITION", {
    get: function() {
      return TransformNode.BILLBOARDMODE_USE_POSITION;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "facetNb", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetNb;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "partitioningSubdivisions", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;
    },
    set: function(nb) {
      this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "partitioningBBoxRatio", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;
    },
    set: function(ratio) {
      this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "mustDepthSortFacets", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;
    },
    set: function(sort) {
      this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "facetDepthSortFrom", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;
    },
    set: function(location2) {
      this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collisionRetryCount", {
    get: function() {
      return this._internalAbstractMeshDataInfo._collisionRetryCount;
    },
    set: function(retryCount) {
      this._internalAbstractMeshDataInfo._collisionRetryCount = retryCount;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "isFacetDataEnabled", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "morphTargetManager", {
    get: function() {
      return this._internalAbstractMeshDataInfo._morphTargetManager;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._morphTargetManager === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._morphTargetManager = value;
      this._syncGeometryWithMorphTargetManager();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "bakedVertexAnimationManager", {
    get: function() {
      return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype._syncGeometryWithMorphTargetManager = function() {
  };
  AbstractMesh2.prototype._updateNonUniformScalingState = function(value) {
    if (!_super.prototype._updateNonUniformScalingState.call(this, value)) {
      return false;
    }
    this._markSubMeshesAsMiscDirty();
    return true;
  };
  Object.defineProperty(AbstractMesh2.prototype, "onCollide", {
    set: function(callback) {
      if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver) {
        this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver);
      }
      this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "onCollisionPositionChange", {
    set: function(callback) {
      if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver) {
        this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver);
      }
      this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "visibility", {
    get: function() {
      return this._internalAbstractMeshDataInfo._visibility;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._visibility === value) {
        return;
      }
      var oldValue = this._internalAbstractMeshDataInfo._visibility;
      this._internalAbstractMeshDataInfo._visibility = value;
      if (oldValue === 1 && value !== 1 || oldValue !== 1 && value === 1) {
        this._markSubMeshesAsMiscDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "renderingGroupId", {
    get: function() {
      return this._internalAbstractMeshDataInfo._renderingGroupId;
    },
    set: function(value) {
      this._internalAbstractMeshDataInfo._renderingGroupId = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "material", {
    get: function() {
      return this._internalAbstractMeshDataInfo._material;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._material === value) {
        return;
      }
      if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
        this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
      }
      this._internalAbstractMeshDataInfo._material = value;
      if (value && value.meshMap) {
        value.meshMap[this.uniqueId] = this;
      }
      if (this.onMaterialChangedObservable.hasObservers()) {
        this.onMaterialChangedObservable.notifyObservers(this);
      }
      if (!this.subMeshes) {
        return;
      }
      this.resetDrawCache();
      this._unBindEffect();
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.getMaterialForRenderPass = function(renderPassId) {
    var _a;
    return (_a = this._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[renderPassId];
  };
  AbstractMesh2.prototype.setMaterialForRenderPass = function(renderPassId, material) {
    if (!this._internalAbstractMeshDataInfo._materialForRenderPass) {
      this._internalAbstractMeshDataInfo._materialForRenderPass = [];
    }
    this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId] = material;
  };
  Object.defineProperty(AbstractMesh2.prototype, "receiveShadows", {
    get: function() {
      return this._internalAbstractMeshDataInfo._receiveShadows;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._receiveShadows === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._receiveShadows = value;
      this._markSubMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "hasVertexAlpha", {
    get: function() {
      return this._internalAbstractMeshDataInfo._hasVertexAlpha;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._hasVertexAlpha = value;
      this._markSubMeshesAsAttributesDirty();
      this._markSubMeshesAsMiscDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "useVertexColors", {
    get: function() {
      return this._internalAbstractMeshDataInfo._useVertexColors;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._useVertexColors === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._useVertexColors = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "computeBonesUsingShaders", {
    get: function() {
      return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "numBoneInfluencers", {
    get: function() {
      return this._internalAbstractMeshDataInfo._numBoneInfluencers;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._numBoneInfluencers = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "applyFog", {
    get: function() {
      return this._internalAbstractMeshDataInfo._applyFog;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._applyFog === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._applyFog = value;
      this._markSubMeshesAsMiscDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "enableDistantPicking", {
    get: function() {
      return this._internalAbstractMeshDataInfo._enableDistantPicking;
    },
    set: function(value) {
      this._internalAbstractMeshDataInfo._enableDistantPicking = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "layerMask", {
    get: function() {
      return this._internalAbstractMeshDataInfo._layerMask;
    },
    set: function(value) {
      if (value === this._internalAbstractMeshDataInfo._layerMask) {
        return;
      }
      this._internalAbstractMeshDataInfo._layerMask = value;
      this._resyncLightSources();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collisionMask", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;
    },
    set: function(mask) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collisionResponse", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;
    },
    set: function(response) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = response;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collisionGroup", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;
    },
    set: function(mask) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "surroundingMeshes", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;
    },
    set: function(meshes) {
      this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = meshes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "lightSources", {
    get: function() {
      return this._lightSources;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "_positions", {
    get: function() {
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "skeleton", {
    get: function() {
      return this._internalAbstractMeshDataInfo._skeleton;
    },
    set: function(value) {
      var skeleton = this._internalAbstractMeshDataInfo._skeleton;
      if (skeleton && skeleton.needInitialSkinMatrix) {
        skeleton._unregisterMeshWithPoseMatrix(this);
      }
      if (value && value.needInitialSkinMatrix) {
        value._registerMeshWithPoseMatrix(this);
      }
      this._internalAbstractMeshDataInfo._skeleton = value;
      if (!this._internalAbstractMeshDataInfo._skeleton) {
        this._bonesTransformMatrices = null;
      }
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype._buildUniformLayout = function() {
    this._uniformBuffer.addUniform("world", 16);
    this._uniformBuffer.addUniform("visibility", 1);
    this._uniformBuffer.create();
  };
  AbstractMesh2.prototype.transferToEffect = function(world) {
    var ubo = this._uniformBuffer;
    ubo.updateMatrix("world", world);
    ubo.updateFloat("visibility", this._internalAbstractMeshDataInfo._visibility);
    ubo.update();
  };
  AbstractMesh2.prototype.getMeshUniformBuffer = function() {
    return this._uniformBuffer;
  };
  AbstractMesh2.prototype.getClassName = function() {
    return "AbstractMesh";
  };
  AbstractMesh2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name + ", isInstance: " + (this.getClassName() !== "InstancedMesh" ? "YES" : "NO");
    ret += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0);
    var skeleton = this._internalAbstractMeshDataInfo._skeleton;
    if (skeleton) {
      ret += ", skeleton: " + skeleton.name;
    }
    if (fullDetails) {
      ret += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode];
      ret += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO");
    }
    return ret;
  };
  AbstractMesh2.prototype._getEffectiveParent = function() {
    if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {
      return this._masterMesh;
    }
    return _super.prototype._getEffectiveParent.call(this);
  };
  AbstractMesh2.prototype._getActionManagerForTrigger = function(trigger, initialCall) {
    if (initialCall === void 0) {
      initialCall = true;
    }
    if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {
      if (trigger) {
        if (this.actionManager.hasSpecificTrigger(trigger)) {
          return this.actionManager;
        }
      } else {
        return this.actionManager;
      }
    }
    if (!this.parent) {
      return null;
    }
    return this.parent._getActionManagerForTrigger(trigger, false);
  };
  AbstractMesh2.prototype._rebuild = function(dispose) {
    this.onRebuildObservable.notifyObservers(this);
    if (this._occlusionQuery !== null) {
      this._occlusionQuery = null;
    }
    if (!this.subMeshes) {
      return;
    }
    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
      var subMesh = _a[_i];
      subMesh._rebuild();
    }
  };
  AbstractMesh2.prototype._resyncLightSources = function() {
    this._lightSources.length = 0;
    for (var _i = 0, _a = this.getScene().lights; _i < _a.length; _i++) {
      var light = _a[_i];
      if (!light.isEnabled()) {
        continue;
      }
      if (light.canAffectMesh(this)) {
        this._lightSources.push(light);
      }
    }
    this._markSubMeshesAsLightDirty();
  };
  AbstractMesh2.prototype._resyncLightSource = function(light) {
    var isIn = light.isEnabled() && light.canAffectMesh(this);
    var index = this._lightSources.indexOf(light);
    var removed = false;
    if (index === -1) {
      if (!isIn) {
        return;
      }
      this._lightSources.push(light);
    } else {
      if (isIn) {
        return;
      }
      removed = true;
      this._lightSources.splice(index, 1);
    }
    this._markSubMeshesAsLightDirty(removed);
  };
  AbstractMesh2.prototype._unBindEffect = function() {
    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
      var subMesh = _a[_i];
      subMesh.setEffect(null);
    }
  };
  AbstractMesh2.prototype._removeLightSource = function(light, dispose) {
    var index = this._lightSources.indexOf(light);
    if (index === -1) {
      return;
    }
    this._lightSources.splice(index, 1);
    this._markSubMeshesAsLightDirty(dispose);
  };
  AbstractMesh2.prototype._markSubMeshesAsDirty = function(func) {
    if (!this.subMeshes) {
      return;
    }
    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
      var subMesh = _a[_i];
      for (var i = 0; i < subMesh._drawWrappers.length; ++i) {
        var drawWrapper = subMesh._drawWrappers[i];
        if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {
          continue;
        }
        func(drawWrapper.defines);
      }
    }
  };
  AbstractMesh2.prototype._markSubMeshesAsLightDirty = function(dispose) {
    if (dispose === void 0) {
      dispose = false;
    }
    this._markSubMeshesAsDirty(function(defines) {
      return defines.markAsLightDirty(dispose);
    });
  };
  AbstractMesh2.prototype._markSubMeshesAsAttributesDirty = function() {
    this._markSubMeshesAsDirty(function(defines) {
      return defines.markAsAttributesDirty();
    });
  };
  AbstractMesh2.prototype._markSubMeshesAsMiscDirty = function() {
    this._markSubMeshesAsDirty(function(defines) {
      return defines.markAsMiscDirty();
    });
  };
  AbstractMesh2.prototype.markAsDirty = function(property) {
    this._currentRenderId = Number.MAX_VALUE;
    this._isDirty = true;
    return this;
  };
  AbstractMesh2.prototype.resetDrawCache = function(passId) {
    if (!this.subMeshes) {
      return;
    }
    for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
      var subMesh = _a[_i];
      subMesh.resetDrawCache(passId);
    }
  };
  Object.defineProperty(AbstractMesh2.prototype, "scaling", {
    get: function() {
      return this._scaling;
    },
    set: function(newScaling) {
      this._scaling = newScaling;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "isBlocked", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.getLOD = function(camera) {
    return this;
  };
  AbstractMesh2.prototype.getTotalVertices = function() {
    return 0;
  };
  AbstractMesh2.prototype.getTotalIndices = function() {
    return 0;
  };
  AbstractMesh2.prototype.getIndices = function() {
    return null;
  };
  AbstractMesh2.prototype.getVerticesData = function(kind) {
    return null;
  };
  AbstractMesh2.prototype.setVerticesData = function(kind, data, updatable, stride) {
    return this;
  };
  AbstractMesh2.prototype.updateVerticesData = function(kind, data, updateExtends, makeItUnique) {
    return this;
  };
  AbstractMesh2.prototype.setIndices = function(indices, totalVertices) {
    return this;
  };
  AbstractMesh2.prototype.isVerticesDataPresent = function(kind) {
    return false;
  };
  AbstractMesh2.prototype.getBoundingInfo = function() {
    if (this._masterMesh) {
      return this._masterMesh.getBoundingInfo();
    }
    if (this._boundingInfoIsDirty) {
      this._boundingInfoIsDirty = false;
      this._updateBoundingInfo();
    }
    return this._boundingInfo;
  };
  AbstractMesh2.prototype.setBoundingInfo = function(boundingInfo) {
    this._boundingInfo = boundingInfo;
    return this;
  };
  Object.defineProperty(AbstractMesh2.prototype, "hasBoundingInfo", {
    get: function() {
      return this._boundingInfo !== null;
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.buildBoundingInfo = function(minimum, maximum, worldMatrix) {
    this._boundingInfo = new BoundingInfo(minimum, maximum, worldMatrix);
    return this._boundingInfo;
  };
  AbstractMesh2.prototype.normalizeToUnitCube = function(includeDescendants, ignoreRotation, predicate) {
    if (includeDescendants === void 0) {
      includeDescendants = true;
    }
    if (ignoreRotation === void 0) {
      ignoreRotation = false;
    }
    return _super.prototype.normalizeToUnitCube.call(this, includeDescendants, ignoreRotation, predicate);
  };
  Object.defineProperty(AbstractMesh2.prototype, "useBones", {
    get: function() {
      return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind);
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype._preActivate = function() {
  };
  AbstractMesh2.prototype._preActivateForIntermediateRendering = function(renderId) {
  };
  AbstractMesh2.prototype._activate = function(renderId, intermediateRendering) {
    this._renderId = renderId;
    return true;
  };
  AbstractMesh2.prototype._postActivate = function() {
  };
  AbstractMesh2.prototype._freeze = function() {
  };
  AbstractMesh2.prototype._unFreeze = function() {
  };
  AbstractMesh2.prototype.getWorldMatrix = function() {
    if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {
      return this._masterMesh.getWorldMatrix();
    }
    return _super.prototype.getWorldMatrix.call(this);
  };
  AbstractMesh2.prototype._getWorldMatrixDeterminant = function() {
    if (this._masterMesh) {
      return this._masterMesh._getWorldMatrixDeterminant();
    }
    return _super.prototype._getWorldMatrixDeterminant.call(this);
  };
  Object.defineProperty(AbstractMesh2.prototype, "isAnInstance", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "hasInstances", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "hasThinInstances", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.movePOV = function(amountRight, amountUp, amountForward) {
    this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));
    return this;
  };
  AbstractMesh2.prototype.calcMovePOV = function(amountRight, amountUp, amountForward) {
    var rotMatrix = new Matrix();
    var rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
    rotQuaternion.toRotationMatrix(rotMatrix);
    var translationDelta = Vector3.Zero();
    var defForwardMult = this.definedFacingForward ? -1 : 1;
    Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);
    return translationDelta;
  };
  AbstractMesh2.prototype.rotatePOV = function(flipBack, twirlClockwise, tiltRight) {
    this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));
    return this;
  };
  AbstractMesh2.prototype.calcRotatePOV = function(flipBack, twirlClockwise, tiltRight) {
    var defForwardMult = this.definedFacingForward ? 1 : -1;
    return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);
  };
  AbstractMesh2.prototype.refreshBoundingInfo = function(applySkeleton, applyMorph) {
    if (applySkeleton === void 0) {
      applySkeleton = false;
    }
    if (applyMorph === void 0) {
      applyMorph = false;
    }
    if (this._boundingInfo && this._boundingInfo.isLocked) {
      return this;
    }
    this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), null);
    return this;
  };
  AbstractMesh2.prototype._refreshBoundingInfo = function(data, bias) {
    if (data) {
      var extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);
      if (this._boundingInfo) {
        this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
      } else {
        this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
      }
    }
    if (this.subMeshes) {
      for (var index = 0; index < this.subMeshes.length; index++) {
        this.subMeshes[index].refreshBoundingInfo(data);
      }
    }
    this._updateBoundingInfo();
  };
  AbstractMesh2.prototype.getPositionData = function(applySkeleton, applyMorph, data) {
    data = data !== null && data !== void 0 ? data : this.getVerticesData(VertexBuffer.PositionKind);
    if (data && applyMorph && this.morphTargetManager) {
      var faceIndexCount = 0;
      var positionIndex = 0;
      for (var vertexCount = 0; vertexCount < data.length; vertexCount++) {
        for (var targetCount = 0; targetCount < this.morphTargetManager.numTargets; targetCount++) {
          var targetMorph = this.morphTargetManager.getTarget(targetCount);
          var influence = targetMorph.influence;
          if (influence > 0) {
            var morphTargetPositions = targetMorph.getPositions();
            if (morphTargetPositions) {
              data[vertexCount] += (morphTargetPositions[vertexCount] - data[vertexCount]) * influence;
            }
          }
        }
        faceIndexCount++;
        if (this._positions && faceIndexCount === 3) {
          faceIndexCount = 0;
          var index_1 = positionIndex * 3;
          this._positions[positionIndex++].copyFromFloats(data[index_1], data[index_1 + 1], data[index_1 + 2]);
        }
      }
    }
    if (data && applySkeleton && this.skeleton) {
      var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
      var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
      if (matricesWeightsData && matricesIndicesData) {
        var needExtras = this.numBoneInfluencers > 4;
        var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
        var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
        var skeletonMatrices = this.skeleton.getTransformMatrices(this);
        var tempVector = TmpVectors.Vector3[0];
        var finalMatrix = TmpVectors.Matrix[0];
        var tempMatrix = TmpVectors.Matrix[1];
        var matWeightIdx = 0;
        for (var index = 0; index < data.length; index += 3, matWeightIdx += 4) {
          finalMatrix.reset();
          var inf;
          var weight;
          for (inf = 0; inf < 4; inf++) {
            weight = matricesWeightsData[matWeightIdx + inf];
            if (weight > 0) {
              Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
              finalMatrix.addToSelf(tempMatrix);
            }
          }
          if (needExtras) {
            for (inf = 0; inf < 4; inf++) {
              weight = matricesWeightsExtraData[matWeightIdx + inf];
              if (weight > 0) {
                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
                finalMatrix.addToSelf(tempMatrix);
              }
            }
          }
          Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);
          tempVector.toArray(data, index);
          if (this._positions) {
            this._positions[index / 3].copyFrom(tempVector);
          }
        }
      }
    }
    return data;
  };
  AbstractMesh2.prototype._getPositionData = function(applySkeleton, applyMorph) {
    var _a;
    var data = this.getVerticesData(VertexBuffer.PositionKind);
    if (this._internalAbstractMeshDataInfo._positions) {
      this._internalAbstractMeshDataInfo._positions = null;
    }
    if (data && (applySkeleton && this.skeleton || applyMorph && this.morphTargetManager)) {
      data = Tools.Slice(data);
      this._generatePointsArray();
      if (this._positions) {
        var pos = this._positions;
        this._internalAbstractMeshDataInfo._positions = new Array(pos.length);
        for (var i = 0; i < pos.length; i++) {
          this._internalAbstractMeshDataInfo._positions[i] = ((_a = pos[i]) === null || _a === void 0 ? void 0 : _a.clone()) || new Vector3();
        }
      }
    }
    return this.getPositionData(applySkeleton, applyMorph, data);
  };
  AbstractMesh2.prototype._updateBoundingInfo = function() {
    if (this._boundingInfo) {
      this._boundingInfo.update(this.worldMatrixFromCache);
    } else {
      this._boundingInfo = new BoundingInfo(this.position, this.position, this.worldMatrixFromCache);
    }
    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
    return this;
  };
  AbstractMesh2.prototype._updateSubMeshesBoundingInfo = function(matrix) {
    if (!this.subMeshes) {
      return this;
    }
    var count = this.subMeshes.length;
    for (var subIndex = 0; subIndex < count; subIndex++) {
      var subMesh = this.subMeshes[subIndex];
      if (count > 1 || !subMesh.IsGlobal) {
        subMesh.updateBoundingInfo(matrix);
      }
    }
    return this;
  };
  AbstractMesh2.prototype._afterComputeWorldMatrix = function() {
    if (this.doNotSyncBoundingInfo) {
      return;
    }
    this._boundingInfoIsDirty = true;
  };
  AbstractMesh2.prototype.isInFrustum = function(frustumPlanes) {
    return this.getBoundingInfo().isInFrustum(frustumPlanes, this.cullingStrategy);
  };
  AbstractMesh2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
    return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);
  };
  AbstractMesh2.prototype.intersectsMesh = function(mesh, precise, includeDescendants) {
    if (precise === void 0) {
      precise = false;
    }
    var boundingInfo = this.getBoundingInfo();
    var otherBoundingInfo = mesh.getBoundingInfo();
    if (boundingInfo.intersects(otherBoundingInfo, precise)) {
      return true;
    }
    if (includeDescendants) {
      for (var _i = 0, _a = this.getChildMeshes(); _i < _a.length; _i++) {
        var child = _a[_i];
        if (child.intersectsMesh(mesh, precise, true)) {
          return true;
        }
      }
    }
    return false;
  };
  AbstractMesh2.prototype.intersectsPoint = function(point) {
    return this.getBoundingInfo().intersectsPoint(point);
  };
  Object.defineProperty(AbstractMesh2.prototype, "checkCollisions", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;
    },
    set: function(collisionEnabled) {
      this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = collisionEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collider", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._collider;
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.moveWithCollisions = function(displacement) {
    var globalPosition = this.getAbsolutePosition();
    globalPosition.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);
    var coordinator = this.getScene().collisionCoordinator;
    if (!this._internalAbstractMeshDataInfo._meshCollisionData._collider) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collider = coordinator.createCollider();
    }
    this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid;
    coordinator.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, displacement, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId);
    return this;
  };
  AbstractMesh2.prototype._collideForSubMesh = function(subMesh, transformMatrix, collider) {
    var _a;
    this._generatePointsArray();
    if (!this._positions) {
      return this;
    }
    if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {
      subMesh._lastColliderTransformMatrix = transformMatrix.clone();
      subMesh._lastColliderWorldVertices = [];
      subMesh._trianglePlanes = [];
      var start = subMesh.verticesStart;
      var end = subMesh.verticesStart + subMesh.verticesCount;
      for (var i = start; i < end; i++) {
        subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));
      }
    }
    collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this, this._shouldConvertRHS(), ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.fillMode) === 7);
    return this;
  };
  AbstractMesh2.prototype._processCollisionsForSubMeshes = function(collider, transformMatrix) {
    var subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);
    var len = subMeshes.length;
    for (var index = 0; index < len; index++) {
      var subMesh = subMeshes.data[index];
      if (len > 1 && !subMesh._checkCollision(collider)) {
        continue;
      }
      this._collideForSubMesh(subMesh, transformMatrix, collider);
    }
    return this;
  };
  AbstractMesh2.prototype._shouldConvertRHS = function() {
    return false;
  };
  AbstractMesh2.prototype._checkCollision = function(collider) {
    if (!this.getBoundingInfo()._checkCollision(collider)) {
      return this;
    }
    var collisionsScalingMatrix = TmpVectors.Matrix[0];
    var collisionsTransformMatrix = TmpVectors.Matrix[1];
    Matrix.ScalingToRef(1 / collider._radius.x, 1 / collider._radius.y, 1 / collider._radius.z, collisionsScalingMatrix);
    this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);
    this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);
    return this;
  };
  AbstractMesh2.prototype._generatePointsArray = function() {
    return false;
  };
  AbstractMesh2.prototype.intersects = function(ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo) {
    if (onlyBoundingInfo === void 0) {
      onlyBoundingInfo = false;
    }
    if (skipBoundingInfo === void 0) {
      skipBoundingInfo = false;
    }
    var pickingInfo = new PickingInfo();
    var intersectionThreshold = this.getClassName() === "InstancedLinesMesh" || this.getClassName() === "LinesMesh" ? this.intersectionThreshold : 0;
    var boundingInfo = this.getBoundingInfo();
    if (!this.subMeshes) {
      return pickingInfo;
    }
    if (!skipBoundingInfo && (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {
      return pickingInfo;
    }
    if (onlyBoundingInfo) {
      pickingInfo.hit = skipBoundingInfo ? false : true;
      pickingInfo.pickedMesh = skipBoundingInfo ? null : this;
      pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
      pickingInfo.subMeshId = 0;
      return pickingInfo;
    }
    if (!this._generatePointsArray()) {
      return pickingInfo;
    }
    var intersectInfo = null;
    var subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);
    var len = subMeshes.length;
    var anySubmeshSupportIntersect = false;
    for (var index = 0; index < len; index++) {
      var subMesh = subMeshes.data[index];
      var material = subMesh.getMaterial();
      if (!material) {
        continue;
      }
      if (material.fillMode == 7 || material.fillMode == 0 || material.fillMode == 1 || material.fillMode == 2 || material.fillMode == 4) {
        anySubmeshSupportIntersect = true;
        break;
      }
    }
    if (!anySubmeshSupportIntersect) {
      pickingInfo.hit = true;
      pickingInfo.pickedMesh = this;
      pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
      pickingInfo.subMeshId = -1;
      return pickingInfo;
    }
    for (var index = 0; index < len; index++) {
      var subMesh = subMeshes.data[index];
      if (len > 1 && !subMesh.canIntersects(ray)) {
        continue;
      }
      var currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck, trianglePredicate);
      if (currentIntersectInfo) {
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.subMeshId = index;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    if (intersectInfo) {
      var world = worldToUse !== null && worldToUse !== void 0 ? worldToUse : this.getWorldMatrix();
      var worldOrigin = TmpVectors.Vector3[0];
      var direction = TmpVectors.Vector3[1];
      Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);
      ray.direction.scaleToRef(intersectInfo.distance, direction);
      var worldDirection = Vector3.TransformNormal(direction, world);
      var pickedPoint = worldDirection.addInPlace(worldOrigin);
      pickingInfo.hit = true;
      pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);
      pickingInfo.pickedPoint = pickedPoint;
      pickingInfo.pickedMesh = this;
      pickingInfo.bu = intersectInfo.bu || 0;
      pickingInfo.bv = intersectInfo.bv || 0;
      pickingInfo.subMeshFaceId = intersectInfo.faceId;
      pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf("LinesMesh") !== -1 ? 2 : 3);
      pickingInfo.subMeshId = intersectInfo.subMeshId;
      return pickingInfo;
    }
    return pickingInfo;
  };
  AbstractMesh2.prototype.clone = function(name2, newParent, doNotCloneChildren) {
    return null;
  };
  AbstractMesh2.prototype.releaseSubMeshes = function() {
    if (this.subMeshes) {
      while (this.subMeshes.length) {
        this.subMeshes[0].dispose();
      }
    } else {
      this.subMeshes = new Array();
    }
    return this;
  };
  AbstractMesh2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    var _this = this;
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    var index;
    if (this._scene.useMaterialMeshMap) {
      if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
        this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
      }
    }
    this.getScene().freeActiveMeshes();
    this.getScene().freeRenderingGroups();
    if (this.actionManager !== void 0 && this.actionManager !== null) {
      this.actionManager.dispose();
      this.actionManager = null;
    }
    this._internalAbstractMeshDataInfo._skeleton = null;
    if (this._transformMatrixTexture) {
      this._transformMatrixTexture.dispose();
      this._transformMatrixTexture = null;
    }
    for (index = 0; index < this._intersectionsInProgress.length; index++) {
      var other = this._intersectionsInProgress[index];
      var pos = other._intersectionsInProgress.indexOf(this);
      other._intersectionsInProgress.splice(pos, 1);
    }
    this._intersectionsInProgress = [];
    var lights = this.getScene().lights;
    lights.forEach(function(light) {
      var meshIndex = light.includedOnlyMeshes.indexOf(_this);
      if (meshIndex !== -1) {
        light.includedOnlyMeshes.splice(meshIndex, 1);
      }
      meshIndex = light.excludedMeshes.indexOf(_this);
      if (meshIndex !== -1) {
        light.excludedMeshes.splice(meshIndex, 1);
      }
      var generator = light.getShadowGenerator();
      if (generator) {
        var shadowMap = generator.getShadowMap();
        if (shadowMap && shadowMap.renderList) {
          meshIndex = shadowMap.renderList.indexOf(_this);
          if (meshIndex !== -1) {
            shadowMap.renderList.splice(meshIndex, 1);
          }
        }
      }
    });
    if (this.getClassName() !== "InstancedMesh" || this.getClassName() !== "InstancedLinesMesh") {
      this.releaseSubMeshes();
    }
    var engine = this.getScene().getEngine();
    if (this._occlusionQuery !== null) {
      this.isOcclusionQueryInProgress = false;
      engine.deleteQuery(this._occlusionQuery);
      this._occlusionQuery = null;
    }
    engine.wipeCaches();
    this.getScene().removeMesh(this);
    if (this._parentContainer) {
      var index_2 = this._parentContainer.meshes.indexOf(this);
      if (index_2 > -1) {
        this._parentContainer.meshes.splice(index_2, 1);
      }
      this._parentContainer = null;
    }
    if (disposeMaterialAndTextures) {
      if (this.material) {
        if (this.material.getClassName() === "MultiMaterial") {
          this.material.dispose(false, true, true);
        } else {
          this.material.dispose(false, true);
        }
      }
    }
    if (!doNotRecurse) {
      for (index = 0; index < this.getScene().particleSystems.length; index++) {
        if (this.getScene().particleSystems[index].emitter === this) {
          this.getScene().particleSystems[index].dispose();
          index--;
        }
      }
    }
    if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {
      this.disableFacetData();
    }
    this._uniformBuffer.dispose();
    this.onAfterWorldMatrixUpdateObservable.clear();
    this.onCollideObservable.clear();
    this.onCollisionPositionChangeObservable.clear();
    this.onRebuildObservable.clear();
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  AbstractMesh2.prototype.addChild = function(mesh, preserveScalingSign) {
    if (preserveScalingSign === void 0) {
      preserveScalingSign = false;
    }
    mesh.setParent(this, preserveScalingSign);
    return this;
  };
  AbstractMesh2.prototype.removeChild = function(mesh, preserveScalingSign) {
    if (preserveScalingSign === void 0) {
      preserveScalingSign = false;
    }
    mesh.setParent(null, preserveScalingSign);
    return this;
  };
  AbstractMesh2.prototype._initFacetData = function() {
    var data = this._internalAbstractMeshDataInfo._facetData;
    if (!data.facetNormals) {
      data.facetNormals = new Array();
    }
    if (!data.facetPositions) {
      data.facetPositions = new Array();
    }
    if (!data.facetPartitioning) {
      data.facetPartitioning = new Array();
    }
    data.facetNb = this.getIndices().length / 3 | 0;
    data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10;
    data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01;
    for (var f = 0; f < data.facetNb; f++) {
      data.facetNormals[f] = Vector3.Zero();
      data.facetPositions[f] = Vector3.Zero();
    }
    data.facetDataEnabled = true;
    return this;
  };
  AbstractMesh2.prototype.updateFacetData = function() {
    var data = this._internalAbstractMeshDataInfo._facetData;
    if (!data.facetDataEnabled) {
      this._initFacetData();
    }
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    var indices = this.getIndices();
    var normals = this.getVerticesData(VertexBuffer.NormalKind);
    var bInfo = this.getBoundingInfo();
    if (data.facetDepthSort && !data.facetDepthSortEnabled) {
      data.facetDepthSortEnabled = true;
      if (indices instanceof Uint16Array) {
        data.depthSortedIndices = new Uint16Array(indices);
      } else if (indices instanceof Uint32Array) {
        data.depthSortedIndices = new Uint32Array(indices);
      } else {
        var needs32bits = false;
        for (var i = 0; i < indices.length; i++) {
          if (indices[i] > 65535) {
            needs32bits = true;
            break;
          }
        }
        if (needs32bits) {
          data.depthSortedIndices = new Uint32Array(indices);
        } else {
          data.depthSortedIndices = new Uint16Array(indices);
        }
      }
      data.facetDepthSortFunction = function(f1, f2) {
        return f2.sqDistance - f1.sqDistance;
      };
      if (!data.facetDepthSortFrom) {
        var camera = this.getScene().activeCamera;
        data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();
      }
      data.depthSortedFacets = [];
      for (var f = 0; f < data.facetNb; f++) {
        var depthSortedFacet = { ind: f * 3, sqDistance: 0 };
        data.depthSortedFacets.push(depthSortedFacet);
      }
      data.invertedMatrix = Matrix.Identity();
      data.facetDepthSortOrigin = Vector3.Zero();
    }
    data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;
    data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;
    data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;
    var bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;
    bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;
    data.subDiv.max = data.partitioningSubdivisions;
    data.subDiv.X = Math.floor(data.subDiv.max * data.bbSize.x / bbSizeMax);
    data.subDiv.Y = Math.floor(data.subDiv.max * data.bbSize.y / bbSizeMax);
    data.subDiv.Z = Math.floor(data.subDiv.max * data.bbSize.z / bbSizeMax);
    data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X;
    data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;
    data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;
    data.facetParameters.facetNormals = this.getFacetLocalNormals();
    data.facetParameters.facetPositions = this.getFacetLocalPositions();
    data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();
    data.facetParameters.bInfo = bInfo;
    data.facetParameters.bbSize = data.bbSize;
    data.facetParameters.subDiv = data.subDiv;
    data.facetParameters.ratio = this.partitioningBBoxRatio;
    data.facetParameters.depthSort = data.facetDepthSort;
    if (data.facetDepthSort && data.facetDepthSortEnabled) {
      this.computeWorldMatrix(true);
      this._worldMatrix.invertToRef(data.invertedMatrix);
      Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);
      data.facetParameters.distanceTo = data.facetDepthSortOrigin;
    }
    data.facetParameters.depthSortedFacets = data.depthSortedFacets;
    if (normals) {
      VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);
    }
    if (data.facetDepthSort && data.facetDepthSortEnabled) {
      data.depthSortedFacets.sort(data.facetDepthSortFunction);
      var l = data.depthSortedIndices.length / 3 | 0;
      for (var f = 0; f < l; f++) {
        var sind = data.depthSortedFacets[f].ind;
        data.depthSortedIndices[f * 3] = indices[sind];
        data.depthSortedIndices[f * 3 + 1] = indices[sind + 1];
        data.depthSortedIndices[f * 3 + 2] = indices[sind + 2];
      }
      this.updateIndices(data.depthSortedIndices, void 0, true);
    }
    return this;
  };
  AbstractMesh2.prototype.getFacetLocalNormals = function() {
    var facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetNormals) {
      this.updateFacetData();
    }
    return facetData.facetNormals;
  };
  AbstractMesh2.prototype.getFacetLocalPositions = function() {
    var facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetPositions) {
      this.updateFacetData();
    }
    return facetData.facetPositions;
  };
  AbstractMesh2.prototype.getFacetLocalPartitioning = function() {
    var facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetPartitioning) {
      this.updateFacetData();
    }
    return facetData.facetPartitioning;
  };
  AbstractMesh2.prototype.getFacetPosition = function(i) {
    var pos = Vector3.Zero();
    this.getFacetPositionToRef(i, pos);
    return pos;
  };
  AbstractMesh2.prototype.getFacetPositionToRef = function(i, ref) {
    var localPos = this.getFacetLocalPositions()[i];
    var world = this.getWorldMatrix();
    Vector3.TransformCoordinatesToRef(localPos, world, ref);
    return this;
  };
  AbstractMesh2.prototype.getFacetNormal = function(i) {
    var norm = Vector3.Zero();
    this.getFacetNormalToRef(i, norm);
    return norm;
  };
  AbstractMesh2.prototype.getFacetNormalToRef = function(i, ref) {
    var localNorm = this.getFacetLocalNormals()[i];
    Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);
    return this;
  };
  AbstractMesh2.prototype.getFacetsAtLocalCoordinates = function(x, y, z) {
    var bInfo = this.getBoundingInfo();
    var data = this._internalAbstractMeshDataInfo._facetData;
    var ox = Math.floor((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio / data.bbSize.x);
    var oy = Math.floor((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio / data.bbSize.y);
    var oz = Math.floor((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio / data.bbSize.z);
    if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {
      return null;
    }
    return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];
  };
  AbstractMesh2.prototype.getClosestFacetAtCoordinates = function(x, y, z, projected, checkFace, facing) {
    if (checkFace === void 0) {
      checkFace = false;
    }
    if (facing === void 0) {
      facing = true;
    }
    var world = this.getWorldMatrix();
    var invMat = TmpVectors.Matrix[5];
    world.invertToRef(invMat);
    var invVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect);
    var closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);
    if (projected) {
      Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);
    }
    return closest;
  };
  AbstractMesh2.prototype.getClosestFacetAtLocalCoordinates = function(x, y, z, projected, checkFace, facing) {
    if (checkFace === void 0) {
      checkFace = false;
    }
    if (facing === void 0) {
      facing = true;
    }
    var closest = null;
    var tmpx = 0;
    var tmpy = 0;
    var tmpz = 0;
    var d = 0;
    var t0 = 0;
    var projx = 0;
    var projy = 0;
    var projz = 0;
    var facetPositions = this.getFacetLocalPositions();
    var facetNormals = this.getFacetLocalNormals();
    var facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);
    if (!facetsInBlock) {
      return null;
    }
    var shortest = Number.MAX_VALUE;
    var tmpDistance = shortest;
    var fib;
    var norm;
    var p0;
    for (var idx = 0; idx < facetsInBlock.length; idx++) {
      fib = facetsInBlock[idx];
      norm = facetNormals[fib];
      p0 = facetPositions[fib];
      d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;
      if (!checkFace || checkFace && facing && d >= 0 || checkFace && !facing && d <= 0) {
        d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;
        t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);
        projx = x + norm.x * t0;
        projy = y + norm.y * t0;
        projz = z + norm.z * t0;
        tmpx = projx - x;
        tmpy = projy - y;
        tmpz = projz - z;
        tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz;
        if (tmpDistance < shortest) {
          shortest = tmpDistance;
          closest = fib;
          if (projected) {
            projected.x = projx;
            projected.y = projy;
            projected.z = projz;
          }
        }
      }
    }
    return closest;
  };
  AbstractMesh2.prototype.getFacetDataParameters = function() {
    return this._internalAbstractMeshDataInfo._facetData.facetParameters;
  };
  AbstractMesh2.prototype.disableFacetData = function() {
    var facetData = this._internalAbstractMeshDataInfo._facetData;
    if (facetData.facetDataEnabled) {
      facetData.facetDataEnabled = false;
      facetData.facetPositions = new Array();
      facetData.facetNormals = new Array();
      facetData.facetPartitioning = new Array();
      facetData.facetParameters = null;
      facetData.depthSortedIndices = new Uint32Array(0);
    }
    return this;
  };
  AbstractMesh2.prototype.updateIndices = function(indices, offset, gpuMemoryOnly) {
    return this;
  };
  AbstractMesh2.prototype.createNormals = function(updatable) {
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    var indices = this.getIndices();
    var normals;
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      normals = this.getVerticesData(VertexBuffer.NormalKind);
    } else {
      normals = [];
    }
    VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });
    this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);
    return this;
  };
  AbstractMesh2.prototype.alignWithNormal = function(normal, upDirection) {
    if (!upDirection) {
      upDirection = Axis.Y;
    }
    var axisX = TmpVectors.Vector3[0];
    var axisZ = TmpVectors.Vector3[1];
    Vector3.CrossToRef(upDirection, normal, axisZ);
    Vector3.CrossToRef(normal, axisZ, axisX);
    if (this.rotationQuaternion) {
      Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);
    } else {
      Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);
    }
    return this;
  };
  AbstractMesh2.prototype._checkOcclusionQuery = function() {
    return false;
  };
  AbstractMesh2.prototype.disableEdgesRendering = function() {
    throw _WarnImport("EdgesRenderer");
  };
  AbstractMesh2.prototype.enableEdgesRendering = function(epsilon, checkVerticesInsteadOfIndices, options) {
    throw _WarnImport("EdgesRenderer");
  };
  AbstractMesh2.prototype.getConnectedParticleSystems = function() {
    var _this = this;
    return this._scene.particleSystems.filter(function(particleSystem) {
      return particleSystem.emitter === _this;
    });
  };
  AbstractMesh2.OCCLUSION_TYPE_NONE = 0;
  AbstractMesh2.OCCLUSION_TYPE_OPTIMISTIC = 1;
  AbstractMesh2.OCCLUSION_TYPE_STRICT = 2;
  AbstractMesh2.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;
  AbstractMesh2.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;
  AbstractMesh2.CULLINGSTRATEGY_STANDARD = 0;
  AbstractMesh2.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
  AbstractMesh2.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
  AbstractMesh2.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
  return AbstractMesh2;
}(TransformNode);
RegisterClass("BABYLON.AbstractMesh", AbstractMesh);
var Camera = function(_super) {
  __extends(Camera2, _super);
  function Camera2(name2, position, scene, setActiveOnSceneIfNoneActive) {
    if (setActiveOnSceneIfNoneActive === void 0) {
      setActiveOnSceneIfNoneActive = true;
    }
    var _this = _super.call(this, name2, scene) || this;
    _this._position = Vector3.Zero();
    _this._upVector = Vector3.Up();
    _this.orthoLeft = null;
    _this.orthoRight = null;
    _this.orthoBottom = null;
    _this.orthoTop = null;
    _this.fov = 0.8;
    _this.projectionPlaneTilt = 0;
    _this.minZ = 1;
    _this.maxZ = 1e4;
    _this.inertia = 0.9;
    _this.mode = Camera2.PERSPECTIVE_CAMERA;
    _this.isIntermediate = false;
    _this.viewport = new Viewport(0, 0, 1, 1);
    _this.layerMask = 268435455;
    _this.fovMode = Camera2.FOVMODE_VERTICAL_FIXED;
    _this.cameraRigMode = Camera2.RIG_MODE_NONE;
    _this.customRenderTargets = new Array();
    _this.outputRenderTarget = null;
    _this.onViewMatrixChangedObservable = new Observable();
    _this.onProjectionMatrixChangedObservable = new Observable();
    _this.onAfterCheckInputsObservable = new Observable();
    _this.onRestoreStateObservable = new Observable();
    _this.isRigCamera = false;
    _this._rigCameras = new Array();
    _this._webvrViewMatrix = Matrix.Identity();
    _this._skipRendering = false;
    _this._projectionMatrix = new Matrix();
    _this._postProcesses = new Array();
    _this._activeMeshes = new SmartArray(256);
    _this._globalPosition = Vector3.Zero();
    _this._computedViewMatrix = Matrix.Identity();
    _this._doNotComputeProjectionMatrix = false;
    _this._transformMatrix = Matrix.Zero();
    _this._refreshFrustumPlanes = true;
    _this._absoluteRotation = Quaternion.Identity();
    _this._isCamera = true;
    _this._isLeftCamera = false;
    _this._isRightCamera = false;
    _this.getScene().addCamera(_this);
    if (setActiveOnSceneIfNoneActive && !_this.getScene().activeCamera) {
      _this.getScene().activeCamera = _this;
    }
    _this.position = position;
    _this.renderPassId = _this.getScene().getEngine().createRenderPassId("Camera ".concat(name2));
    return _this;
  }
  Object.defineProperty(Camera2.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(newPosition) {
      this._position = newPosition;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "upVector", {
    get: function() {
      return this._upVector;
    },
    set: function(vec) {
      this._upVector = vec;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "screenArea", {
    get: function() {
      var _a, _b, _c, _d;
      var x = 0;
      var y = 0;
      if (this.mode === Camera2.PERSPECTIVE_CAMERA) {
        if (this.fovMode === Camera2.FOVMODE_VERTICAL_FIXED) {
          y = this.minZ * 2 * Math.tan(this.fov / 2);
          x = this.getEngine().getAspectRatio(this) * y;
        } else {
          x = this.minZ * 2 * Math.tan(this.fov / 2);
          y = x / this.getEngine().getAspectRatio(this);
        }
      } else {
        var halfWidth = this.getEngine().getRenderWidth() / 2;
        var halfHeight = this.getEngine().getRenderHeight() / 2;
        x = ((_a = this.orthoRight) !== null && _a !== void 0 ? _a : halfWidth) - ((_b = this.orthoLeft) !== null && _b !== void 0 ? _b : -halfWidth);
        y = ((_c = this.orthoTop) !== null && _c !== void 0 ? _c : halfHeight) - ((_d = this.orthoBottom) !== null && _d !== void 0 ? _d : -halfHeight);
      }
      return x * y;
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype.storeState = function() {
    this._stateStored = true;
    this._storedFov = this.fov;
    return this;
  };
  Camera2.prototype._restoreStateValues = function() {
    if (!this._stateStored) {
      return false;
    }
    this.fov = this._storedFov;
    return true;
  };
  Camera2.prototype.restoreState = function() {
    if (this._restoreStateValues()) {
      this.onRestoreStateObservable.notifyObservers(this);
      return true;
    }
    return false;
  };
  Camera2.prototype.getClassName = function() {
    return "Camera";
  };
  Camera2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name;
    ret += ", type: " + this.getClassName();
    if (this.animations) {
      for (var i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  };
  Camera2.prototype.applyVerticalCorrection = function() {
    var rot = this.absoluteRotation.toEulerAngles();
    this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;
  };
  Object.defineProperty(Camera2.prototype, "globalPosition", {
    get: function() {
      return this._globalPosition;
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype.getActiveMeshes = function() {
    return this._activeMeshes;
  };
  Camera2.prototype.isActiveMesh = function(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  };
  Camera2.prototype.isReady = function(completeCheck) {
    if (completeCheck === void 0) {
      completeCheck = false;
    }
    if (completeCheck) {
      for (var _i = 0, _a = this._postProcesses; _i < _a.length; _i++) {
        var pp = _a[_i];
        if (pp && !pp.isReady()) {
          return false;
        }
      }
    }
    return _super.prototype.isReady.call(this, completeCheck);
  };
  Camera2.prototype._initCache = function() {
    _super.prototype._initCache.call(this);
    this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.mode = void 0;
    this._cache.minZ = void 0;
    this._cache.maxZ = void 0;
    this._cache.fov = void 0;
    this._cache.fovMode = void 0;
    this._cache.aspectRatio = void 0;
    this._cache.orthoLeft = void 0;
    this._cache.orthoRight = void 0;
    this._cache.orthoBottom = void 0;
    this._cache.orthoTop = void 0;
    this._cache.renderWidth = void 0;
    this._cache.renderHeight = void 0;
  };
  Camera2.prototype._updateCache = function(ignoreParentClass) {
    if (!ignoreParentClass) {
      _super.prototype._updateCache.call(this);
    }
    this._cache.position.copyFrom(this.position);
    this._cache.upVector.copyFrom(this.upVector);
  };
  Camera2.prototype._isSynchronized = function() {
    return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
  };
  Camera2.prototype._isSynchronizedViewMatrix = function() {
    if (!_super.prototype._isSynchronized.call(this)) {
      return false;
    }
    return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();
  };
  Camera2.prototype._isSynchronizedProjectionMatrix = function() {
    var check = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
    if (!check) {
      return false;
    }
    var engine = this.getEngine();
    if (this.mode === Camera2.PERSPECTIVE_CAMERA) {
      check = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === engine.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt;
    } else {
      check = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === engine.getRenderWidth() && this._cache.renderHeight === engine.getRenderHeight();
    }
    return check;
  };
  Camera2.prototype.attachControl = function(ignored, noPreventDefault) {
  };
  Camera2.prototype.detachControl = function(ignored) {
  };
  Camera2.prototype.update = function() {
    this._checkInputs();
    if (this.cameraRigMode !== Camera2.RIG_MODE_NONE) {
      this._updateRigCameras();
    }
  };
  Camera2.prototype._checkInputs = function() {
    this.onAfterCheckInputsObservable.notifyObservers(this);
  };
  Object.defineProperty(Camera2.prototype, "rigCameras", {
    get: function() {
      return this._rigCameras;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "rigPostProcess", {
    get: function() {
      return this._rigPostProcess;
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype._getFirstPostProcess = function() {
    for (var ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {
      if (this._postProcesses[ppIndex] !== null) {
        return this._postProcesses[ppIndex];
      }
    }
    return null;
  };
  Camera2.prototype._cascadePostProcessesToRigCams = function() {
    var firstPostProcess = this._getFirstPostProcess();
    if (firstPostProcess) {
      firstPostProcess.markTextureDirty();
    }
    for (var i = 0, len = this._rigCameras.length; i < len; i++) {
      var cam = this._rigCameras[i];
      var rigPostProcess = cam._rigPostProcess;
      if (rigPostProcess) {
        var isPass = rigPostProcess.getEffectName() === "pass";
        if (isPass) {
          cam.isIntermediate = this._postProcesses.length === 0;
        }
        cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);
        rigPostProcess.markTextureDirty();
      } else {
        cam._postProcesses = this._postProcesses.slice(0);
      }
    }
  };
  Camera2.prototype.attachPostProcess = function(postProcess, insertAt) {
    if (insertAt === void 0) {
      insertAt = null;
    }
    if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {
      Logger.Error("You're trying to reuse a post process not defined as reusable.");
      return 0;
    }
    if (insertAt == null || insertAt < 0) {
      this._postProcesses.push(postProcess);
    } else if (this._postProcesses[insertAt] === null) {
      this._postProcesses[insertAt] = postProcess;
    } else {
      this._postProcesses.splice(insertAt, 0, postProcess);
    }
    this._cascadePostProcessesToRigCams();
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    return this._postProcesses.indexOf(postProcess);
  };
  Camera2.prototype.detachPostProcess = function(postProcess) {
    var idx = this._postProcesses.indexOf(postProcess);
    if (idx !== -1) {
      this._postProcesses[idx] = null;
    }
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    this._cascadePostProcessesToRigCams();
  };
  Camera2.prototype.getWorldMatrix = function() {
    if (this._isSynchronizedViewMatrix()) {
      return this._worldMatrix;
    }
    this.getViewMatrix();
    return this._worldMatrix;
  };
  Camera2.prototype._getViewMatrix = function() {
    return Matrix.Identity();
  };
  Camera2.prototype.getViewMatrix = function(force) {
    if (!force && this._isSynchronizedViewMatrix()) {
      return this._computedViewMatrix;
    }
    this.updateCache();
    this._computedViewMatrix = this._getViewMatrix();
    this._currentRenderId = this.getScene().getRenderId();
    this._childUpdateId++;
    this._refreshFrustumPlanes = true;
    if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {
      this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);
    }
    if (this.parent && this.parent.onViewMatrixChangedObservable) {
      this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent);
    }
    this.onViewMatrixChangedObservable.notifyObservers(this);
    this._computedViewMatrix.invertToRef(this._worldMatrix);
    return this._computedViewMatrix;
  };
  Camera2.prototype.freezeProjectionMatrix = function(projection) {
    this._doNotComputeProjectionMatrix = true;
    if (projection !== void 0) {
      this._projectionMatrix = projection;
    }
  };
  Camera2.prototype.unfreezeProjectionMatrix = function() {
    this._doNotComputeProjectionMatrix = false;
  };
  Camera2.prototype.getProjectionMatrix = function(force) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this._doNotComputeProjectionMatrix || !force && this._isSynchronizedProjectionMatrix()) {
      return this._projectionMatrix;
    }
    this._cache.mode = this.mode;
    this._cache.minZ = this.minZ;
    this._cache.maxZ = this.maxZ;
    this._refreshFrustumPlanes = true;
    var engine = this.getEngine();
    var scene = this.getScene();
    if (this.mode === Camera2.PERSPECTIVE_CAMERA) {
      this._cache.fov = this.fov;
      this._cache.fovMode = this.fovMode;
      this._cache.aspectRatio = engine.getAspectRatio(this);
      this._cache.projectionPlaneTilt = this.projectionPlaneTilt;
      if (this.minZ <= 0) {
        this.minZ = 0.1;
      }
      var reverseDepth = engine.useReverseDepthBuffer;
      var getProjectionMatrix = void 0;
      if (scene.useRightHandedSystem) {
        getProjectionMatrix = Matrix.PerspectiveFovRHToRef;
      } else {
        getProjectionMatrix = Matrix.PerspectiveFovLHToRef;
      }
      getProjectionMatrix(this.fov, engine.getAspectRatio(this), reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === Camera2.FOVMODE_VERTICAL_FIXED, engine.isNDCHalfZRange, this.projectionPlaneTilt, engine.useReverseDepthBuffer);
    } else {
      var halfWidth = engine.getRenderWidth() / 2;
      var halfHeight = engine.getRenderHeight() / 2;
      if (scene.useRightHandedSystem) {
        Matrix.OrthoOffCenterRHToRef((_a = this.orthoLeft) !== null && _a !== void 0 ? _a : -halfWidth, (_b = this.orthoRight) !== null && _b !== void 0 ? _b : halfWidth, (_c = this.orthoBottom) !== null && _c !== void 0 ? _c : -halfHeight, (_d = this.orthoTop) !== null && _d !== void 0 ? _d : halfHeight, this.minZ, this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
      } else {
        Matrix.OrthoOffCenterLHToRef((_e = this.orthoLeft) !== null && _e !== void 0 ? _e : -halfWidth, (_f = this.orthoRight) !== null && _f !== void 0 ? _f : halfWidth, (_g = this.orthoBottom) !== null && _g !== void 0 ? _g : -halfHeight, (_h = this.orthoTop) !== null && _h !== void 0 ? _h : halfHeight, this.minZ, this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
      }
      this._cache.orthoLeft = this.orthoLeft;
      this._cache.orthoRight = this.orthoRight;
      this._cache.orthoBottom = this.orthoBottom;
      this._cache.orthoTop = this.orthoTop;
      this._cache.renderWidth = engine.getRenderWidth();
      this._cache.renderHeight = engine.getRenderHeight();
    }
    this.onProjectionMatrixChangedObservable.notifyObservers(this);
    return this._projectionMatrix;
  };
  Camera2.prototype.getTransformationMatrix = function() {
    this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    return this._transformMatrix;
  };
  Camera2.prototype._updateFrustumPlanes = function() {
    if (!this._refreshFrustumPlanes) {
      return;
    }
    this.getTransformationMatrix();
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    this._refreshFrustumPlanes = false;
  };
  Camera2.prototype.isInFrustum = function(target, checkRigCameras) {
    if (checkRigCameras === void 0) {
      checkRigCameras = false;
    }
    this._updateFrustumPlanes();
    if (checkRigCameras && this.rigCameras.length > 0) {
      var result = false;
      this.rigCameras.forEach(function(cam) {
        cam._updateFrustumPlanes();
        result = result || target.isInFrustum(cam._frustumPlanes);
      });
      return result;
    } else {
      return target.isInFrustum(this._frustumPlanes);
    }
  };
  Camera2.prototype.isCompletelyInFrustum = function(target) {
    this._updateFrustumPlanes();
    return target.isCompletelyInFrustum(this._frustumPlanes);
  };
  Camera2.prototype.getForwardRay = function(length, transform, origin) {
    throw _WarnImport("Ray");
  };
  Camera2.prototype.getForwardRayToRef = function(refRay, length, transform, origin) {
    throw _WarnImport("Ray");
  };
  Camera2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this.onViewMatrixChangedObservable.clear();
    this.onProjectionMatrixChangedObservable.clear();
    this.onAfterCheckInputsObservable.clear();
    this.onRestoreStateObservable.clear();
    if (this.inputs) {
      this.inputs.clear();
    }
    this.getScene().stopAnimation(this);
    this.getScene().removeCamera(this);
    while (this._rigCameras.length > 0) {
      var camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    if (this._parentContainer) {
      var index = this._parentContainer.cameras.indexOf(this);
      if (index > -1) {
        this._parentContainer.cameras.splice(index, 1);
      }
      this._parentContainer = null;
    }
    if (this._rigPostProcess) {
      this._rigPostProcess.dispose(this);
      this._rigPostProcess = null;
      this._postProcesses = [];
    } else if (this.cameraRigMode !== Camera2.RIG_MODE_NONE) {
      this._rigPostProcess = null;
      this._postProcesses = [];
    } else {
      var i = this._postProcesses.length;
      while (--i >= 0) {
        var postProcess = this._postProcesses[i];
        if (postProcess) {
          postProcess.dispose(this);
        }
      }
    }
    var i = this.customRenderTargets.length;
    while (--i >= 0) {
      this.customRenderTargets[i].dispose();
    }
    this.customRenderTargets = [];
    this._activeMeshes.dispose();
    this.getScene().getEngine().releaseRenderPassId(this.renderPassId);
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  Object.defineProperty(Camera2.prototype, "isLeftCamera", {
    get: function() {
      return this._isLeftCamera;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "isRightCamera", {
    get: function() {
      return this._isRightCamera;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "leftCamera", {
    get: function() {
      if (this._rigCameras.length < 1) {
        return null;
      }
      return this._rigCameras[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "rightCamera", {
    get: function() {
      if (this._rigCameras.length < 2) {
        return null;
      }
      return this._rigCameras[1];
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype.getLeftTarget = function() {
    if (this._rigCameras.length < 1) {
      return null;
    }
    return this._rigCameras[0].getTarget();
  };
  Camera2.prototype.getRightTarget = function() {
    if (this._rigCameras.length < 2) {
      return null;
    }
    return this._rigCameras[1].getTarget();
  };
  Camera2.prototype.setCameraRigMode = function(mode, rigParams) {
    if (this.cameraRigMode === mode) {
      return;
    }
    while (this._rigCameras.length > 0) {
      var camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    this.cameraRigMode = mode;
    this._cameraRigParams = {};
    this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;
    this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);
    if (this.cameraRigMode !== Camera2.RIG_MODE_NONE) {
      var leftCamera = this.createRigCamera(this.name + "_L", 0);
      if (leftCamera) {
        leftCamera._isLeftCamera = true;
      }
      var rightCamera = this.createRigCamera(this.name + "_R", 1);
      if (rightCamera) {
        rightCamera._isRightCamera = true;
      }
      if (leftCamera && rightCamera) {
        this._rigCameras.push(leftCamera);
        this._rigCameras.push(rightCamera);
      }
    }
    this._setRigMode(rigParams);
    this._cascadePostProcessesToRigCams();
    this.update();
  };
  Camera2.prototype._setRigMode = function(rigParams) {
  };
  Camera2.prototype._getVRProjectionMatrix = function() {
    Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, true, this.getEngine().isNDCHalfZRange);
    this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);
    return this._projectionMatrix;
  };
  Camera2.prototype._updateCameraRotationMatrix = function() {
  };
  Camera2.prototype._updateWebVRCameraRotationMatrix = function() {
  };
  Camera2.prototype._getWebVRProjectionMatrix = function() {
    return Matrix.Identity();
  };
  Camera2.prototype._getWebVRViewMatrix = function() {
    return Matrix.Identity();
  };
  Camera2.prototype.setCameraRigParameter = function(name2, value) {
    if (!this._cameraRigParams) {
      this._cameraRigParams = {};
    }
    this._cameraRigParams[name2] = value;
    if (name2 === "interaxialDistance") {
      this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);
    }
  };
  Camera2.prototype.createRigCamera = function(name2, cameraIndex) {
    return null;
  };
  Camera2.prototype._updateRigCameras = function() {
    for (var i = 0; i < this._rigCameras.length; i++) {
      this._rigCameras[i].minZ = this.minZ;
      this._rigCameras[i].maxZ = this.maxZ;
      this._rigCameras[i].fov = this.fov;
      this._rigCameras[i].upVector.copyFrom(this.upVector);
    }
    if (this.cameraRigMode === Camera2.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {
      this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;
    }
  };
  Camera2.prototype._setupInputs = function() {
  };
  Camera2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getClassName();
    if (this.parent) {
      serializationObject.parentId = this.parent.uniqueId;
    }
    if (this.inputs) {
      this.inputs.serialize(serializationObject);
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  };
  Camera2.prototype.clone = function(name2) {
    var camera = SerializationHelper.Clone(Camera2.GetConstructorFromName(this.getClassName(), name2, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
    camera.name = name2;
    this.onClonedObservable.notifyObservers(camera);
    return camera;
  };
  Camera2.prototype.getDirection = function(localAxis) {
    var result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  };
  Object.defineProperty(Camera2.prototype, "absoluteRotation", {
    get: function() {
      this.getWorldMatrix().decompose(void 0, this._absoluteRotation);
      return this._absoluteRotation;
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype.getDirectionToRef = function(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
  };
  Camera2.GetConstructorFromName = function(type, name2, scene, interaxial_distance, isStereoscopicSideBySide) {
    if (interaxial_distance === void 0) {
      interaxial_distance = 0;
    }
    if (isStereoscopicSideBySide === void 0) {
      isStereoscopicSideBySide = true;
    }
    var constructorFunc = Node.Construct(type, name2, scene, {
      interaxial_distance,
      isStereoscopicSideBySide
    });
    if (constructorFunc) {
      return constructorFunc;
    }
    return function() {
      return Camera2._createDefaultParsedCamera(name2, scene);
    };
  };
  Camera2.prototype.computeWorldMatrix = function() {
    return this.getWorldMatrix();
  };
  Camera2.Parse = function(parsedCamera, scene) {
    var type = parsedCamera.type;
    var construct = Camera2.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);
    var camera = SerializationHelper.Parse(construct, parsedCamera, scene);
    if (parsedCamera.parentId !== void 0) {
      camera._waitingParentId = parsedCamera.parentId;
    }
    if (camera.inputs) {
      camera.inputs.parse(parsedCamera);
      camera._setupInputs();
    }
    if (parsedCamera.upVector) {
      camera.upVector = Vector3.FromArray(parsedCamera.upVector);
    }
    if (camera.setPosition) {
      camera.position.copyFromFloats(0, 0, 0);
      camera.setPosition(Vector3.FromArray(parsedCamera.position));
    }
    if (parsedCamera.target) {
      if (camera.setTarget) {
        camera.setTarget(Vector3.FromArray(parsedCamera.target));
      }
    }
    if (parsedCamera.cameraRigMode) {
      var rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};
      camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);
    }
    if (parsedCamera.animations) {
      for (var animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {
        var parsedAnimation = parsedCamera.animations[animationIndex];
        var internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          camera.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(camera, parsedCamera, scene);
    }
    if (parsedCamera.autoAnimate) {
      scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1);
    }
    if (parsedCamera.isEnabled !== void 0) {
      camera.setEnabled(parsedCamera.isEnabled);
    }
    return camera;
  };
  Camera2._createDefaultParsedCamera = function(name2, scene) {
    throw _WarnImport("UniversalCamera");
  };
  Camera2.PERSPECTIVE_CAMERA = 0;
  Camera2.ORTHOGRAPHIC_CAMERA = 1;
  Camera2.FOVMODE_VERTICAL_FIXED = 0;
  Camera2.FOVMODE_HORIZONTAL_FIXED = 1;
  Camera2.RIG_MODE_NONE = 0;
  Camera2.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
  Camera2.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
  Camera2.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
  Camera2.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
  Camera2.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
  Camera2.RIG_MODE_VR = 20;
  Camera2.RIG_MODE_WEBVR = 21;
  Camera2.RIG_MODE_CUSTOM = 22;
  Camera2.ForceAttachControlToAlwaysPreventDefault = false;
  __decorate([
    serializeAsVector3("position")
  ], Camera2.prototype, "_position", void 0);
  __decorate([
    serializeAsVector3("upVector")
  ], Camera2.prototype, "_upVector", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "orthoLeft", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "orthoRight", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "orthoBottom", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "orthoTop", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "fov", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "projectionPlaneTilt", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "minZ", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "maxZ", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "inertia", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "mode", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "layerMask", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "fovMode", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "cameraRigMode", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "interaxialDistance", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "isStereoscopicSideBySide", void 0);
  return Camera2;
}(Node);
var Light = function(_super) {
  __extends(Light2, _super);
  function Light2(name2, scene) {
    var _this = _super.call(this, name2, scene) || this;
    _this.diffuse = new Color3(1, 1, 1);
    _this.specular = new Color3(1, 1, 1);
    _this.falloffType = Light2.FALLOFF_DEFAULT;
    _this.intensity = 1;
    _this._range = Number.MAX_VALUE;
    _this._inverseSquaredRange = 0;
    _this._photometricScale = 1;
    _this._intensityMode = Light2.INTENSITYMODE_AUTOMATIC;
    _this._radius = 1e-5;
    _this.renderPriority = 0;
    _this._shadowEnabled = true;
    _this._excludeWithLayerMask = 0;
    _this._includeOnlyWithLayerMask = 0;
    _this._lightmapMode = 0;
    _this._excludedMeshesIds = new Array();
    _this._includedOnlyMeshesIds = new Array();
    _this._isLight = true;
    _this.getScene().addLight(_this);
    _this._uniformBuffer = new UniformBuffer(_this.getScene().getEngine(), void 0, void 0, name2);
    _this._buildUniformLayout();
    _this.includedOnlyMeshes = new Array();
    _this.excludedMeshes = new Array();
    _this._resyncMeshes();
    return _this;
  }
  Object.defineProperty(Light2.prototype, "range", {
    get: function() {
      return this._range;
    },
    set: function(value) {
      this._range = value;
      this._inverseSquaredRange = 1 / (this.range * this.range);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "intensityMode", {
    get: function() {
      return this._intensityMode;
    },
    set: function(value) {
      this._intensityMode = value;
      this._computePhotometricScale();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "radius", {
    get: function() {
      return this._radius;
    },
    set: function(value) {
      this._radius = value;
      this._computePhotometricScale();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "shadowEnabled", {
    get: function() {
      return this._shadowEnabled;
    },
    set: function(value) {
      if (this._shadowEnabled === value) {
        return;
      }
      this._shadowEnabled = value;
      this._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "includedOnlyMeshes", {
    get: function() {
      return this._includedOnlyMeshes;
    },
    set: function(value) {
      this._includedOnlyMeshes = value;
      this._hookArrayForIncludedOnly(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "excludedMeshes", {
    get: function() {
      return this._excludedMeshes;
    },
    set: function(value) {
      this._excludedMeshes = value;
      this._hookArrayForExcluded(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "excludeWithLayerMask", {
    get: function() {
      return this._excludeWithLayerMask;
    },
    set: function(value) {
      this._excludeWithLayerMask = value;
      this._resyncMeshes();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "includeOnlyWithLayerMask", {
    get: function() {
      return this._includeOnlyWithLayerMask;
    },
    set: function(value) {
      this._includeOnlyWithLayerMask = value;
      this._resyncMeshes();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "lightmapMode", {
    get: function() {
      return this._lightmapMode;
    },
    set: function(value) {
      if (this._lightmapMode === value) {
        return;
      }
      this._lightmapMode = value;
      this._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Light2.prototype.transferTexturesToEffect = function(effect, lightIndex) {
    return this;
  };
  Light2.prototype._bindLight = function(lightIndex, scene, effect, useSpecular, receiveShadows) {
    if (receiveShadows === void 0) {
      receiveShadows = true;
    }
    var iAsString = lightIndex.toString();
    var needUpdate = false;
    this._uniformBuffer.bindToEffect(effect, "Light" + iAsString);
    if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {
      this._renderId = scene.getRenderId();
      this._lastUseSpecular = useSpecular;
      var scaledIntensity = this.getScaledIntensity();
      this.transferToEffect(effect, iAsString);
      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);
      this._uniformBuffer.updateColor4("vLightDiffuse", TmpColors.Color3[0], this.range, iAsString);
      if (useSpecular) {
        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);
        this._uniformBuffer.updateColor4("vLightSpecular", TmpColors.Color3[1], this.radius, iAsString);
      }
      needUpdate = true;
    }
    this.transferTexturesToEffect(effect, iAsString);
    if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {
      var shadowGenerator = this.getShadowGenerator();
      if (shadowGenerator) {
        shadowGenerator.bindShadowLight(iAsString, effect);
        needUpdate = true;
      }
    }
    if (needUpdate) {
      this._uniformBuffer.update();
    } else {
      this._uniformBuffer.bindUniformBuffer();
    }
  };
  Light2.prototype.getClassName = function() {
    return "Light";
  };
  Light2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name;
    ret += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()];
    if (this.animations) {
      for (var i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  };
  Light2.prototype._syncParentEnabledState = function() {
    _super.prototype._syncParentEnabledState.call(this);
    if (!this.isDisposed()) {
      this._resyncMeshes();
    }
  };
  Light2.prototype.setEnabled = function(value) {
    _super.prototype.setEnabled.call(this, value);
    this._resyncMeshes();
  };
  Light2.prototype.getShadowGenerator = function() {
    return this._shadowGenerator;
  };
  Light2.prototype.getAbsolutePosition = function() {
    return Vector3.Zero();
  };
  Light2.prototype.canAffectMesh = function(mesh) {
    if (!mesh) {
      return true;
    }
    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {
      return false;
    }
    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
      return false;
    }
    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {
      return false;
    }
    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {
      return false;
    }
    return true;
  };
  Light2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    if (this._shadowGenerator) {
      this._shadowGenerator.dispose();
      this._shadowGenerator = null;
    }
    this.getScene().stopAnimation(this);
    if (this._parentContainer) {
      var index = this._parentContainer.lights.indexOf(this);
      if (index > -1) {
        this._parentContainer.lights.splice(index, 1);
      }
      this._parentContainer = null;
    }
    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      mesh._removeLightSource(this, true);
    }
    this._uniformBuffer.dispose();
    this.getScene().removeLight(this);
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  Light2.prototype.getTypeID = function() {
    return 0;
  };
  Light2.prototype.getScaledIntensity = function() {
    return this._photometricScale * this.intensity;
  };
  Light2.prototype.clone = function(name2, newParent) {
    if (newParent === void 0) {
      newParent = null;
    }
    var constructor = Light2.GetConstructorFromName(this.getTypeID(), name2, this.getScene());
    if (!constructor) {
      return null;
    }
    var clonedLight = SerializationHelper.Clone(constructor, this);
    if (name2) {
      clonedLight.name = name2;
    }
    if (newParent) {
      clonedLight.parent = newParent;
    }
    clonedLight.setEnabled(this.isEnabled());
    this.onClonedObservable.notifyObservers(clonedLight);
    return clonedLight;
  };
  Light2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getTypeID();
    if (this.parent) {
      serializationObject.parentId = this.parent.uniqueId;
    }
    if (this.excludedMeshes.length > 0) {
      serializationObject.excludedMeshesIds = [];
      this.excludedMeshes.forEach(function(mesh) {
        serializationObject.excludedMeshesIds.push(mesh.id);
      });
    }
    if (this.includedOnlyMeshes.length > 0) {
      serializationObject.includedOnlyMeshesIds = [];
      this.includedOnlyMeshes.forEach(function(mesh) {
        serializationObject.includedOnlyMeshesIds.push(mesh.id);
      });
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  };
  Light2.GetConstructorFromName = function(type, name2, scene) {
    var constructorFunc = Node.Construct("Light_Type_" + type, name2, scene);
    if (constructorFunc) {
      return constructorFunc;
    }
    return null;
  };
  Light2.Parse = function(parsedLight, scene) {
    var constructor = Light2.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);
    if (!constructor) {
      return null;
    }
    var light = SerializationHelper.Parse(constructor, parsedLight, scene);
    if (parsedLight.excludedMeshesIds) {
      light._excludedMeshesIds = parsedLight.excludedMeshesIds;
    }
    if (parsedLight.includedOnlyMeshesIds) {
      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;
    }
    if (parsedLight.parentId !== void 0) {
      light._waitingParentId = parsedLight.parentId;
    }
    if (parsedLight.falloffType !== void 0) {
      light.falloffType = parsedLight.falloffType;
    }
    if (parsedLight.lightmapMode !== void 0) {
      light.lightmapMode = parsedLight.lightmapMode;
    }
    if (parsedLight.animations) {
      for (var animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {
        var parsedAnimation = parsedLight.animations[animationIndex];
        var internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          light.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(light, parsedLight, scene);
    }
    if (parsedLight.autoAnimate) {
      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1);
    }
    if (parsedLight.isEnabled !== void 0) {
      light.setEnabled(parsedLight.isEnabled);
    }
    return light;
  };
  Light2.prototype._hookArrayForExcluded = function(array) {
    var _this = this;
    var oldPush = array.push;
    array.push = function() {
      var items = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        items[_i2] = arguments[_i2];
      }
      var result = oldPush.apply(array, items);
      for (var _a = 0, items_1 = items; _a < items_1.length; _a++) {
        var item2 = items_1[_a];
        item2._resyncLightSource(_this);
      }
      return result;
    };
    var oldSplice = array.splice;
    array.splice = function(index, deleteCount) {
      var deleted = oldSplice.apply(array, [index, deleteCount]);
      for (var _i2 = 0, deleted_1 = deleted; _i2 < deleted_1.length; _i2++) {
        var item2 = deleted_1[_i2];
        item2._resyncLightSource(_this);
      }
      return deleted;
    };
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
      var item = array_1[_i];
      item._resyncLightSource(this);
    }
  };
  Light2.prototype._hookArrayForIncludedOnly = function(array) {
    var _this = this;
    var oldPush = array.push;
    array.push = function() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      var result = oldPush.apply(array, items);
      _this._resyncMeshes();
      return result;
    };
    var oldSplice = array.splice;
    array.splice = function(index, deleteCount) {
      var deleted = oldSplice.apply(array, [index, deleteCount]);
      _this._resyncMeshes();
      return deleted;
    };
    this._resyncMeshes();
  };
  Light2.prototype._resyncMeshes = function() {
    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      mesh._resyncLightSource(this);
    }
  };
  Light2.prototype._markMeshesAsLightDirty = function() {
    for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {
      var mesh = _a[_i];
      if (mesh.lightSources.indexOf(this) !== -1) {
        mesh._markSubMeshesAsLightDirty();
      }
    }
  };
  Light2.prototype._computePhotometricScale = function() {
    this._photometricScale = this._getPhotometricScale();
    this.getScene().resetCachedMaterial();
  };
  Light2.prototype._getPhotometricScale = function() {
    var photometricScale = 0;
    var lightTypeID = this.getTypeID();
    var photometricMode = this.intensityMode;
    if (photometricMode === Light2.INTENSITYMODE_AUTOMATIC) {
      if (lightTypeID === Light2.LIGHTTYPEID_DIRECTIONALLIGHT) {
        photometricMode = Light2.INTENSITYMODE_ILLUMINANCE;
      } else {
        photometricMode = Light2.INTENSITYMODE_LUMINOUSINTENSITY;
      }
    }
    switch (lightTypeID) {
      case Light2.LIGHTTYPEID_POINTLIGHT:
      case Light2.LIGHTTYPEID_SPOTLIGHT:
        switch (photometricMode) {
          case Light2.INTENSITYMODE_LUMINOUSPOWER:
            photometricScale = 1 / (4 * Math.PI);
            break;
          case Light2.INTENSITYMODE_LUMINOUSINTENSITY:
            photometricScale = 1;
            break;
          case Light2.INTENSITYMODE_LUMINANCE:
            photometricScale = this.radius * this.radius;
            break;
        }
        break;
      case Light2.LIGHTTYPEID_DIRECTIONALLIGHT:
        switch (photometricMode) {
          case Light2.INTENSITYMODE_ILLUMINANCE:
            photometricScale = 1;
            break;
          case Light2.INTENSITYMODE_LUMINANCE:
            var apexAngleRadians = this.radius;
            apexAngleRadians = Math.max(apexAngleRadians, 1e-3);
            var solidAngle = 2 * Math.PI * (1 - Math.cos(apexAngleRadians));
            photometricScale = solidAngle;
            break;
        }
        break;
      case Light2.LIGHTTYPEID_HEMISPHERICLIGHT:
        photometricScale = 1;
        break;
    }
    return photometricScale;
  };
  Light2.prototype._reorderLightsInScene = function() {
    var scene = this.getScene();
    if (this._renderPriority != 0) {
      scene.requireLightSorting = true;
    }
    this.getScene().sortLightsByPriority();
  };
  Light2.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;
  Light2.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;
  Light2.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;
  Light2.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;
  Light2.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;
  Light2.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;
  Light2.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;
  Light2.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;
  Light2.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;
  Light2.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;
  Light2.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;
  Light2.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;
  Light2.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;
  Light2.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;
  Light2.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;
  Light2.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;
  __decorate([
    serializeAsColor3()
  ], Light2.prototype, "diffuse", void 0);
  __decorate([
    serializeAsColor3()
  ], Light2.prototype, "specular", void 0);
  __decorate([
    serialize()
  ], Light2.prototype, "falloffType", void 0);
  __decorate([
    serialize()
  ], Light2.prototype, "intensity", void 0);
  __decorate([
    serialize()
  ], Light2.prototype, "range", null);
  __decorate([
    serialize()
  ], Light2.prototype, "intensityMode", null);
  __decorate([
    serialize()
  ], Light2.prototype, "radius", null);
  __decorate([
    serialize()
  ], Light2.prototype, "_renderPriority", void 0);
  __decorate([
    expandToProperty("_reorderLightsInScene")
  ], Light2.prototype, "renderPriority", void 0);
  __decorate([
    serialize("shadowEnabled")
  ], Light2.prototype, "_shadowEnabled", void 0);
  __decorate([
    serialize("excludeWithLayerMask")
  ], Light2.prototype, "_excludeWithLayerMask", void 0);
  __decorate([
    serialize("includeOnlyWithLayerMask")
  ], Light2.prototype, "_includeOnlyWithLayerMask", void 0);
  __decorate([
    serialize("lightmapMode")
  ], Light2.prototype, "_lightmapMode", void 0);
  return Light2;
}(Node);
var ThinMaterialHelper = function() {
  function ThinMaterialHelper2() {
  }
  ThinMaterialHelper2.BindClipPlane = function(effect, holder) {
    if (holder.clipPlane) {
      var clipPlane = holder.clipPlane;
      effect.setFloat4("vClipPlane", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane2) {
      var clipPlane = holder.clipPlane2;
      effect.setFloat4("vClipPlane2", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane3) {
      var clipPlane = holder.clipPlane3;
      effect.setFloat4("vClipPlane3", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane4) {
      var clipPlane = holder.clipPlane4;
      effect.setFloat4("vClipPlane4", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane5) {
      var clipPlane = holder.clipPlane5;
      effect.setFloat4("vClipPlane5", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane6) {
      var clipPlane = holder.clipPlane6;
      effect.setFloat4("vClipPlane6", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
  };
  return ThinMaterialHelper2;
}();
var MaterialHelper = function() {
  function MaterialHelper2() {
  }
  MaterialHelper2.BindSceneUniformBuffer = function(effect, sceneUbo) {
    sceneUbo.bindToEffect(effect, "Scene");
  };
  MaterialHelper2.PrepareDefinesForMergedUV = function(texture, defines, key) {
    defines._needUVs = true;
    defines[key] = true;
    if (texture.getTextureMatrix().isIdentityAs3x2()) {
      defines[key + "DIRECTUV"] = texture.coordinatesIndex + 1;
      defines["MAINUV" + (texture.coordinatesIndex + 1)] = true;
    } else {
      defines[key + "DIRECTUV"] = 0;
    }
  };
  MaterialHelper2.BindTextureMatrix = function(texture, uniformBuffer, key) {
    var matrix = texture.getTextureMatrix();
    uniformBuffer.updateMatrix(key + "Matrix", matrix);
  };
  MaterialHelper2.GetFogState = function(mesh, scene) {
    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE;
  };
  MaterialHelper2.PrepareDefinesForMisc = function(mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines) {
    if (defines._areMiscDirty) {
      defines["LOGARITHMICDEPTH"] = useLogarithmicDepth;
      defines["POINTSIZE"] = pointsCloud;
      defines["FOG"] = fogEnabled && this.GetFogState(mesh, scene);
      defines["NONUNIFORMSCALING"] = mesh.nonUniformScaling;
      defines["ALPHATEST"] = alphaTest;
    }
  };
  MaterialHelper2.PrepareDefinesForFrameBoundValues = function(scene, engine, defines, useInstances, useClipPlane, useThinInstances) {
    if (useClipPlane === void 0) {
      useClipPlane = null;
    }
    if (useThinInstances === void 0) {
      useThinInstances = false;
    }
    var changed = false;
    var useClipPlane1 = false;
    var useClipPlane2 = false;
    var useClipPlane3 = false;
    var useClipPlane4 = false;
    var useClipPlane5 = false;
    var useClipPlane6 = false;
    useClipPlane1 = useClipPlane == null ? scene.clipPlane !== void 0 && scene.clipPlane !== null : useClipPlane;
    useClipPlane2 = useClipPlane == null ? scene.clipPlane2 !== void 0 && scene.clipPlane2 !== null : useClipPlane;
    useClipPlane3 = useClipPlane == null ? scene.clipPlane3 !== void 0 && scene.clipPlane3 !== null : useClipPlane;
    useClipPlane4 = useClipPlane == null ? scene.clipPlane4 !== void 0 && scene.clipPlane4 !== null : useClipPlane;
    useClipPlane5 = useClipPlane == null ? scene.clipPlane5 !== void 0 && scene.clipPlane5 !== null : useClipPlane;
    useClipPlane6 = useClipPlane == null ? scene.clipPlane6 !== void 0 && scene.clipPlane6 !== null : useClipPlane;
    if (defines["CLIPPLANE"] !== useClipPlane1) {
      defines["CLIPPLANE"] = useClipPlane1;
      changed = true;
    }
    if (defines["CLIPPLANE2"] !== useClipPlane2) {
      defines["CLIPPLANE2"] = useClipPlane2;
      changed = true;
    }
    if (defines["CLIPPLANE3"] !== useClipPlane3) {
      defines["CLIPPLANE3"] = useClipPlane3;
      changed = true;
    }
    if (defines["CLIPPLANE4"] !== useClipPlane4) {
      defines["CLIPPLANE4"] = useClipPlane4;
      changed = true;
    }
    if (defines["CLIPPLANE5"] !== useClipPlane5) {
      defines["CLIPPLANE5"] = useClipPlane5;
      changed = true;
    }
    if (defines["CLIPPLANE6"] !== useClipPlane6) {
      defines["CLIPPLANE6"] = useClipPlane6;
      changed = true;
    }
    if (defines["DEPTHPREPASS"] !== !engine.getColorWrite()) {
      defines["DEPTHPREPASS"] = !defines["DEPTHPREPASS"];
      changed = true;
    }
    if (defines["INSTANCES"] !== useInstances) {
      defines["INSTANCES"] = useInstances;
      changed = true;
    }
    if (defines["INSTANCESCOLOR"] && !defines["INSTANCES"]) {
      defines["INSTANCESCOLOR"] = false;
      changed = true;
    }
    if (defines["THIN_INSTANCES"] !== useThinInstances) {
      defines["THIN_INSTANCES"] = useThinInstances;
      changed = true;
    }
    if (changed) {
      defines.markAsUnprocessed();
    }
  };
  MaterialHelper2.PrepareDefinesForBones = function(mesh, defines) {
    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      defines["NUM_BONE_INFLUENCERS"] = mesh.numBoneInfluencers;
      var materialSupportsBoneTexture = defines["BONETEXTURE"] !== void 0;
      if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {
        defines["BONETEXTURE"] = true;
      } else {
        defines["BonesPerMesh"] = mesh.skeleton.bones.length + 1;
        defines["BONETEXTURE"] = materialSupportsBoneTexture ? false : void 0;
        var prePassRenderer = mesh.getScene().prePassRenderer;
        if (prePassRenderer && prePassRenderer.enabled) {
          var nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;
          defines["BONES_VELOCITY_ENABLED"] = nonExcluded;
        }
      }
    } else {
      defines["NUM_BONE_INFLUENCERS"] = 0;
      defines["BonesPerMesh"] = 0;
    }
  };
  MaterialHelper2.PrepareDefinesForMorphTargets = function(mesh, defines) {
    var manager = mesh.morphTargetManager;
    if (manager) {
      defines["MORPHTARGETS_UV"] = manager.supportsUVs && defines["UV1"];
      defines["MORPHTARGETS_TANGENT"] = manager.supportsTangents && defines["TANGENT"];
      defines["MORPHTARGETS_NORMAL"] = manager.supportsNormals && defines["NORMAL"];
      defines["MORPHTARGETS"] = manager.numInfluencers > 0;
      defines["NUM_MORPH_INFLUENCERS"] = manager.numInfluencers;
      defines["MORPHTARGETS_TEXTURE"] = manager.isUsingTextureForTargets;
    } else {
      defines["MORPHTARGETS_UV"] = false;
      defines["MORPHTARGETS_TANGENT"] = false;
      defines["MORPHTARGETS_NORMAL"] = false;
      defines["MORPHTARGETS"] = false;
      defines["NUM_MORPH_INFLUENCERS"] = 0;
    }
  };
  MaterialHelper2.PrepareDefinesForBakedVertexAnimation = function(mesh, defines) {
    var manager = mesh.bakedVertexAnimationManager;
    defines["BAKED_VERTEX_ANIMATION_TEXTURE"] = manager && manager.isEnabled ? true : false;
  };
  MaterialHelper2.PrepareDefinesForAttributes = function(mesh, defines, useVertexColor, useBones, useMorphTargets, useVertexAlpha, useBakedVertexAnimation) {
    if (useMorphTargets === void 0) {
      useMorphTargets = false;
    }
    if (useVertexAlpha === void 0) {
      useVertexAlpha = true;
    }
    if (useBakedVertexAnimation === void 0) {
      useBakedVertexAnimation = true;
    }
    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {
      return false;
    }
    defines._normals = defines._needNormals;
    defines._uvs = defines._needUVs;
    defines["NORMAL"] = defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
    if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      defines["TANGENT"] = true;
    }
    for (var i = 1; i <= 6; ++i) {
      defines["UV" + i] = defines._needUVs ? mesh.isVerticesDataPresent("uv".concat(i === 1 ? "" : i)) : false;
    }
    if (useVertexColor) {
      var hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);
      defines["VERTEXCOLOR"] = hasVertexColors;
      defines["VERTEXALPHA"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;
    }
    if (mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {
      defines["INSTANCESCOLOR"] = true;
    }
    if (useBones) {
      this.PrepareDefinesForBones(mesh, defines);
    }
    if (useMorphTargets) {
      this.PrepareDefinesForMorphTargets(mesh, defines);
    }
    if (useBakedVertexAnimation) {
      this.PrepareDefinesForBakedVertexAnimation(mesh, defines);
    }
    return true;
  };
  MaterialHelper2.PrepareDefinesForMultiview = function(scene, defines) {
    if (scene.activeCamera) {
      var previousMultiview = defines.MULTIVIEW;
      defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;
      if (defines.MULTIVIEW != previousMultiview) {
        defines.markAsUnprocessed();
      }
    }
  };
  MaterialHelper2.PrepareDefinesForOIT = function(scene, defines, needAlphaBlending) {
    var previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;
    var previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;
    defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;
    defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;
    if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {
      defines.markAsUnprocessed();
    }
  };
  MaterialHelper2.PrepareDefinesForPrePass = function(scene, defines, canRenderToMRT) {
    var previousPrePass = defines.PREPASS;
    if (!defines._arePrePassDirty) {
      return;
    }
    var texturesList = [
      {
        type: 1,
        define: "PREPASS_POSITION",
        index: "PREPASS_POSITION_INDEX"
      },
      {
        type: 2,
        define: "PREPASS_VELOCITY",
        index: "PREPASS_VELOCITY_INDEX"
      },
      {
        type: 3,
        define: "PREPASS_REFLECTIVITY",
        index: "PREPASS_REFLECTIVITY_INDEX"
      },
      {
        type: 0,
        define: "PREPASS_IRRADIANCE",
        index: "PREPASS_IRRADIANCE_INDEX"
      },
      {
        type: 7,
        define: "PREPASS_ALBEDO_SQRT",
        index: "PREPASS_ALBEDO_SQRT_INDEX"
      },
      {
        type: 5,
        define: "PREPASS_DEPTH",
        index: "PREPASS_DEPTH_INDEX"
      },
      {
        type: 6,
        define: "PREPASS_NORMAL",
        index: "PREPASS_NORMAL_INDEX"
      }
    ];
    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {
      defines.PREPASS = true;
      defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;
      for (var i = 0; i < texturesList.length; i++) {
        var index = scene.prePassRenderer.getIndex(texturesList[i].type);
        if (index !== -1) {
          defines[texturesList[i].define] = true;
          defines[texturesList[i].index] = index;
        } else {
          defines[texturesList[i].define] = false;
        }
      }
    } else {
      defines.PREPASS = false;
      for (var i = 0; i < texturesList.length; i++) {
        defines[texturesList[i].define] = false;
      }
    }
    if (defines.PREPASS != previousPrePass) {
      defines.markAsUnprocessed();
      defines.markAsImageProcessingDirty();
    }
  };
  MaterialHelper2.PrepareDefinesForLight = function(scene, mesh, light, lightIndex, defines, specularSupported, state) {
    state.needNormals = true;
    if (defines["LIGHT" + lightIndex] === void 0) {
      state.needRebuild = true;
    }
    defines["LIGHT" + lightIndex] = true;
    defines["SPOTLIGHT" + lightIndex] = false;
    defines["HEMILIGHT" + lightIndex] = false;
    defines["POINTLIGHT" + lightIndex] = false;
    defines["DIRLIGHT" + lightIndex] = false;
    light.prepareLightSpecificDefines(defines, lightIndex);
    defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = false;
    defines["LIGHT_FALLOFF_GLTF" + lightIndex] = false;
    defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = false;
    switch (light.falloffType) {
      case Light.FALLOFF_GLTF:
        defines["LIGHT_FALLOFF_GLTF" + lightIndex] = true;
        break;
      case Light.FALLOFF_PHYSICAL:
        defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = true;
        break;
      case Light.FALLOFF_STANDARD:
        defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = true;
        break;
    }
    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {
      state.specularEnabled = true;
    }
    defines["SHADOW" + lightIndex] = false;
    defines["SHADOWCSM" + lightIndex] = false;
    defines["SHADOWCSMDEBUG" + lightIndex] = false;
    defines["SHADOWCSMNUM_CASCADES" + lightIndex] = false;
    defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = false;
    defines["SHADOWCSMNOBLEND" + lightIndex] = false;
    defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = false;
    defines["SHADOWPCF" + lightIndex] = false;
    defines["SHADOWPCSS" + lightIndex] = false;
    defines["SHADOWPOISSON" + lightIndex] = false;
    defines["SHADOWESM" + lightIndex] = false;
    defines["SHADOWCLOSEESM" + lightIndex] = false;
    defines["SHADOWCUBE" + lightIndex] = false;
    defines["SHADOWLOWQUALITY" + lightIndex] = false;
    defines["SHADOWMEDIUMQUALITY" + lightIndex] = false;
    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {
      var shadowGenerator = light.getShadowGenerator();
      if (shadowGenerator) {
        var shadowMap = shadowGenerator.getShadowMap();
        if (shadowMap) {
          if (shadowMap.renderList && shadowMap.renderList.length > 0) {
            state.shadowEnabled = true;
            shadowGenerator.prepareDefines(defines, lightIndex);
          }
        }
      }
    }
    if (light.lightmapMode != Light.LIGHTMAP_DEFAULT) {
      state.lightmapMode = true;
      defines["LIGHTMAPEXCLUDED" + lightIndex] = true;
      defines["LIGHTMAPNOSPECULAR" + lightIndex] = light.lightmapMode == Light.LIGHTMAP_SHADOWSONLY;
    } else {
      defines["LIGHTMAPEXCLUDED" + lightIndex] = false;
      defines["LIGHTMAPNOSPECULAR" + lightIndex] = false;
    }
  };
  MaterialHelper2.PrepareDefinesForLights = function(scene, mesh, defines, specularSupported, maxSimultaneousLights, disableLighting) {
    if (maxSimultaneousLights === void 0) {
      maxSimultaneousLights = 4;
    }
    if (disableLighting === void 0) {
      disableLighting = false;
    }
    if (!defines._areLightsDirty) {
      return defines._needNormals;
    }
    var lightIndex = 0;
    var state = {
      needNormals: false,
      needRebuild: false,
      lightmapMode: false,
      shadowEnabled: false,
      specularEnabled: false
    };
    if (scene.lightsEnabled && !disableLighting) {
      for (var _i = 0, _a = mesh.lightSources; _i < _a.length; _i++) {
        var light = _a[_i];
        this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);
        lightIndex++;
        if (lightIndex === maxSimultaneousLights) {
          break;
        }
      }
    }
    defines["SPECULARTERM"] = state.specularEnabled;
    defines["SHADOWS"] = state.shadowEnabled;
    for (var index = lightIndex; index < maxSimultaneousLights; index++) {
      if (defines["LIGHT" + index] !== void 0) {
        defines["LIGHT" + index] = false;
        defines["HEMILIGHT" + index] = false;
        defines["POINTLIGHT" + index] = false;
        defines["DIRLIGHT" + index] = false;
        defines["SPOTLIGHT" + index] = false;
        defines["SHADOW" + index] = false;
        defines["SHADOWCSM" + index] = false;
        defines["SHADOWCSMDEBUG" + index] = false;
        defines["SHADOWCSMNUM_CASCADES" + index] = false;
        defines["SHADOWCSMUSESHADOWMAXZ" + index] = false;
        defines["SHADOWCSMNOBLEND" + index] = false;
        defines["SHADOWCSM_RIGHTHANDED" + index] = false;
        defines["SHADOWPCF" + index] = false;
        defines["SHADOWPCSS" + index] = false;
        defines["SHADOWPOISSON" + index] = false;
        defines["SHADOWESM" + index] = false;
        defines["SHADOWCLOSEESM" + index] = false;
        defines["SHADOWCUBE" + index] = false;
        defines["SHADOWLOWQUALITY" + index] = false;
        defines["SHADOWMEDIUMQUALITY" + index] = false;
      }
    }
    var caps = scene.getEngine().getCaps();
    if (defines["SHADOWFLOAT"] === void 0) {
      state.needRebuild = true;
    }
    defines["SHADOWFLOAT"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);
    defines["LIGHTMAPEXCLUDED"] = state.lightmapMode;
    if (state.needRebuild) {
      defines.rebuild();
    }
    return state.needNormals;
  };
  MaterialHelper2.PrepareUniformsAndSamplersForLight = function(lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList, updateOnlyBuffersList) {
    if (uniformBuffersList === void 0) {
      uniformBuffersList = null;
    }
    if (updateOnlyBuffersList === void 0) {
      updateOnlyBuffersList = false;
    }
    if (uniformBuffersList) {
      uniformBuffersList.push("Light" + lightIndex);
    }
    if (updateOnlyBuffersList) {
      return;
    }
    uniformsList.push("vLightData" + lightIndex, "vLightDiffuse" + lightIndex, "vLightSpecular" + lightIndex, "vLightDirection" + lightIndex, "vLightFalloff" + lightIndex, "vLightGround" + lightIndex, "lightMatrix" + lightIndex, "shadowsInfo" + lightIndex, "depthValues" + lightIndex);
    samplersList.push("shadowSampler" + lightIndex);
    samplersList.push("depthSampler" + lightIndex);
    uniformsList.push("viewFrustumZ" + lightIndex, "cascadeBlendFactor" + lightIndex, "lightSizeUVCorrection" + lightIndex, "depthCorrection" + lightIndex, "penumbraDarkness" + lightIndex, "frustumLengths" + lightIndex);
    if (projectedLightTexture) {
      samplersList.push("projectionLightSampler" + lightIndex);
      uniformsList.push("textureProjectionMatrix" + lightIndex);
    }
  };
  MaterialHelper2.PrepareUniformsAndSamplersList = function(uniformsListOrOptions, samplersList, defines, maxSimultaneousLights) {
    if (maxSimultaneousLights === void 0) {
      maxSimultaneousLights = 4;
    }
    var uniformsList;
    var uniformBuffersList = null;
    if (uniformsListOrOptions.uniformsNames) {
      var options = uniformsListOrOptions;
      uniformsList = options.uniformsNames;
      uniformBuffersList = options.uniformBuffersNames;
      samplersList = options.samplers;
      defines = options.defines;
      maxSimultaneousLights = options.maxSimultaneousLights || 0;
    } else {
      uniformsList = uniformsListOrOptions;
      if (!samplersList) {
        samplersList = [];
      }
    }
    for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffersList);
    }
    if (defines["NUM_MORPH_INFLUENCERS"]) {
      uniformsList.push("morphTargetInfluences");
    }
    if (defines["BAKED_VERTEX_ANIMATION_TEXTURE"]) {
      uniformsList.push("bakedVertexAnimationSettings");
      uniformsList.push("bakedVertexAnimationTextureSizeInverted");
      uniformsList.push("bakedVertexAnimationTime");
      samplersList.push("bakedVertexAnimationTexture");
    }
  };
  MaterialHelper2.HandleFallbacksForShadows = function(defines, fallbacks, maxSimultaneousLights, rank) {
    if (maxSimultaneousLights === void 0) {
      maxSimultaneousLights = 4;
    }
    if (rank === void 0) {
      rank = 0;
    }
    var lightFallbackRank = 0;
    for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      if (lightIndex > 0) {
        lightFallbackRank = rank + lightIndex;
        fallbacks.addFallback(lightFallbackRank, "LIGHT" + lightIndex);
      }
      if (!defines["SHADOWS"]) {
        if (defines["SHADOW" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOW" + lightIndex);
        }
        if (defines["SHADOWPCF" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWPCF" + lightIndex);
        }
        if (defines["SHADOWPCSS" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWPCSS" + lightIndex);
        }
        if (defines["SHADOWPOISSON" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWPOISSON" + lightIndex);
        }
        if (defines["SHADOWESM" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWESM" + lightIndex);
        }
        if (defines["SHADOWCLOSEESM" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWCLOSEESM" + lightIndex);
        }
      }
    }
    return lightFallbackRank++;
  };
  MaterialHelper2.PrepareAttributesForMorphTargetsInfluencers = function(attribs, mesh, influencers) {
    this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;
    this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);
  };
  MaterialHelper2.PrepareAttributesForMorphTargets = function(attribs, mesh, defines) {
    var influencers = defines["NUM_MORPH_INFLUENCERS"];
    if (influencers > 0 && EngineStore.LastCreatedEngine) {
      var maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;
      var manager = mesh.morphTargetManager;
      if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {
        return;
      }
      var normal = manager && manager.supportsNormals && defines["NORMAL"];
      var tangent = manager && manager.supportsTangents && defines["TANGENT"];
      var uv = manager && manager.supportsUVs && defines["UV1"];
      for (var index = 0; index < influencers; index++) {
        attribs.push(VertexBuffer.PositionKind + index);
        if (normal) {
          attribs.push(VertexBuffer.NormalKind + index);
        }
        if (tangent) {
          attribs.push(VertexBuffer.TangentKind + index);
        }
        if (uv) {
          attribs.push(VertexBuffer.UVKind + "_" + index);
        }
        if (attribs.length > maxAttributesCount) {
          Logger.Error("Cannot add more vertex attributes for mesh " + mesh.name);
        }
      }
    }
  };
  MaterialHelper2.PrepareAttributesForBakedVertexAnimation = function(attribs, mesh, defines) {
    var enabled = defines["BAKED_VERTEX_ANIMATION_TEXTURE"] && defines["INSTANCES"];
    if (enabled) {
      attribs.push("bakedVertexAnimationSettingsInstanced");
    }
  };
  MaterialHelper2.PrepareAttributesForBones = function(attribs, mesh, defines, fallbacks) {
    if (defines["NUM_BONE_INFLUENCERS"] > 0) {
      fallbacks.addCPUSkinningFallback(0, mesh);
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (defines["NUM_BONE_INFLUENCERS"] > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
    }
  };
  MaterialHelper2.PrepareAttributesForInstances = function(attribs, defines) {
    if (defines["INSTANCES"] || defines["THIN_INSTANCES"]) {
      this.PushAttributesForInstances(attribs, !!defines["PREPASS_VELOCITY"]);
    }
  };
  MaterialHelper2.PushAttributesForInstances = function(attribs, needsPreviousMatrices) {
    if (needsPreviousMatrices === void 0) {
      needsPreviousMatrices = false;
    }
    attribs.push("world0");
    attribs.push("world1");
    attribs.push("world2");
    attribs.push("world3");
    if (needsPreviousMatrices) {
      attribs.push("previousWorld0");
      attribs.push("previousWorld1");
      attribs.push("previousWorld2");
      attribs.push("previousWorld3");
    }
  };
  MaterialHelper2.BindLightProperties = function(light, effect, lightIndex) {
    light.transferToEffect(effect, lightIndex + "");
  };
  MaterialHelper2.BindLight = function(light, lightIndex, scene, effect, useSpecular, receiveShadows) {
    if (receiveShadows === void 0) {
      receiveShadows = true;
    }
    light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);
  };
  MaterialHelper2.BindLights = function(scene, mesh, effect, defines, maxSimultaneousLights) {
    if (maxSimultaneousLights === void 0) {
      maxSimultaneousLights = 4;
    }
    var len = Math.min(mesh.lightSources.length, maxSimultaneousLights);
    for (var i = 0; i < len; i++) {
      var light = mesh.lightSources[i];
      this.BindLight(light, i, scene, effect, typeof defines === "boolean" ? defines : defines["SPECULARTERM"], mesh.receiveShadows);
    }
  };
  MaterialHelper2.BindFogParameters = function(scene, mesh, effect, linearSpace) {
    if (linearSpace === void 0) {
      linearSpace = false;
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
      if (linearSpace) {
        scene.fogColor.toLinearSpaceToRef(this._tempFogColor);
        effect.setColor3("vFogColor", this._tempFogColor);
      } else {
        effect.setColor3("vFogColor", scene.fogColor);
      }
    }
  };
  MaterialHelper2.BindBonesParameters = function(mesh, effect, prePassConfiguration) {
    if (!effect || !mesh) {
      return;
    }
    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {
      mesh.computeBonesUsingShaders = false;
    }
    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      var skeleton = mesh.skeleton;
      if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex("boneTextureWidth") > -1) {
        var boneTexture = skeleton.getTransformMatrixTexture(mesh);
        effect.setTexture("boneSampler", boneTexture);
        effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
      } else {
        var matrices = skeleton.getTransformMatrices(mesh);
        if (matrices) {
          effect.setMatrices("mBones", matrices);
          if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {
            if (!prePassConfiguration.previousBones[mesh.uniqueId]) {
              prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();
            }
            effect.setMatrices("mPreviousBones", prePassConfiguration.previousBones[mesh.uniqueId]);
            MaterialHelper2._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);
          }
        }
      }
    }
  };
  MaterialHelper2._CopyBonesTransformationMatrices = function(source, target) {
    target.set(source);
    return target;
  };
  MaterialHelper2.BindMorphTargetParameters = function(abstractMesh, effect) {
    var manager = abstractMesh.morphTargetManager;
    if (!abstractMesh || !manager) {
      return;
    }
    effect.setFloatArray("morphTargetInfluences", manager.influences);
  };
  MaterialHelper2.BindLogDepth = function(defines, effect, scene) {
    if (!defines || defines["LOGARITHMICDEPTH"]) {
      var camera = scene.activeCamera;
      if (camera.mode === Camera.ORTHOGRAPHIC_CAMERA) {
        Logger.Error("Logarithmic depth is not compatible with orthographic cameras!", 20);
      }
      effect.setFloat("logarithmicDepthConstant", 2 / (Math.log(camera.maxZ + 1) / Math.LN2));
    }
  };
  MaterialHelper2.BindClipPlane = function(effect, scene) {
    ThinMaterialHelper.BindClipPlane(effect, scene);
  };
  MaterialHelper2._TmpMorphInfluencers = { "NUM_MORPH_INFLUENCERS": 0 };
  MaterialHelper2._tempFogColor = Color3.Black();
  return MaterialHelper2;
}();
var MaterialStencilState = function() {
  function MaterialStencilState2() {
    this.reset();
  }
  MaterialStencilState2.prototype.reset = function() {
    this.enabled = false;
    this.mask = 255;
    this.func = 519;
    this.funcRef = 1;
    this.funcMask = 255;
    this.opStencilFail = 7680;
    this.opDepthFail = 7680;
    this.opStencilDepthPass = 7681;
  };
  Object.defineProperty(MaterialStencilState2.prototype, "func", {
    get: function() {
      return this._func;
    },
    set: function(value) {
      this._func = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "funcRef", {
    get: function() {
      return this._funcRef;
    },
    set: function(value) {
      this._funcRef = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "funcMask", {
    get: function() {
      return this._funcMask;
    },
    set: function(value) {
      this._funcMask = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "opStencilFail", {
    get: function() {
      return this._opStencilFail;
    },
    set: function(value) {
      this._opStencilFail = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "opDepthFail", {
    get: function() {
      return this._opDepthFail;
    },
    set: function(value) {
      this._opDepthFail = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "opStencilDepthPass", {
    get: function() {
      return this._opStencilDepthPass;
    },
    set: function(value) {
      this._opStencilDepthPass = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "mask", {
    get: function() {
      return this._mask;
    },
    set: function(value) {
      this._mask = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "enabled", {
    get: function() {
      return this._enabled;
    },
    set: function(value) {
      this._enabled = value;
    },
    enumerable: false,
    configurable: true
  });
  MaterialStencilState2.prototype.getClassName = function() {
    return "MaterialStencilState";
  };
  MaterialStencilState2.prototype.copyTo = function(stencilState) {
    SerializationHelper.Clone(function() {
      return stencilState;
    }, this);
  };
  MaterialStencilState2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  MaterialStencilState2.prototype.parse = function(source, scene, rootUrl) {
    var _this = this;
    SerializationHelper.Parse(function() {
      return _this;
    }, source, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "func", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "funcRef", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "funcMask", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "opStencilFail", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "opDepthFail", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "opStencilDepthPass", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "mask", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "enabled", null);
  return MaterialStencilState2;
}();
var MaterialPluginEvent;
(function(MaterialPluginEvent2) {
  MaterialPluginEvent2[MaterialPluginEvent2["Created"] = 1] = "Created";
  MaterialPluginEvent2[MaterialPluginEvent2["Disposed"] = 2] = "Disposed";
  MaterialPluginEvent2[MaterialPluginEvent2["GetDefineNames"] = 4] = "GetDefineNames";
  MaterialPluginEvent2[MaterialPluginEvent2["PrepareUniformBuffer"] = 8] = "PrepareUniformBuffer";
  MaterialPluginEvent2[MaterialPluginEvent2["IsReadyForSubMesh"] = 16] = "IsReadyForSubMesh";
  MaterialPluginEvent2[MaterialPluginEvent2["PrepareDefines"] = 32] = "PrepareDefines";
  MaterialPluginEvent2[MaterialPluginEvent2["BindForSubMesh"] = 64] = "BindForSubMesh";
  MaterialPluginEvent2[MaterialPluginEvent2["PrepareEffect"] = 128] = "PrepareEffect";
  MaterialPluginEvent2[MaterialPluginEvent2["GetAnimatables"] = 256] = "GetAnimatables";
  MaterialPluginEvent2[MaterialPluginEvent2["GetActiveTextures"] = 512] = "GetActiveTextures";
  MaterialPluginEvent2[MaterialPluginEvent2["HasTexture"] = 1024] = "HasTexture";
  MaterialPluginEvent2[MaterialPluginEvent2["FillRenderTargetTextures"] = 2048] = "FillRenderTargetTextures";
  MaterialPluginEvent2[MaterialPluginEvent2["HasRenderTargetTextures"] = 4096] = "HasRenderTargetTextures";
  MaterialPluginEvent2[MaterialPluginEvent2["HardBindForSubMesh"] = 8192] = "HardBindForSubMesh";
})(MaterialPluginEvent || (MaterialPluginEvent = {}));
var Material = function() {
  function Material2(name2, scene, doNotAdd) {
    this.shadowDepthWrapper = null;
    this.allowShaderHotSwapping = true;
    this.metadata = null;
    this.reservedDataStore = null;
    this.checkReadyOnEveryCall = false;
    this.checkReadyOnlyOnce = false;
    this.state = "";
    this._alpha = 1;
    this._backFaceCulling = true;
    this._cullBackFaces = true;
    this.onCompiled = null;
    this.onError = null;
    this.getRenderTargetTextures = null;
    this.doNotSerialize = false;
    this._storeEffectOnSubMeshes = false;
    this.animations = null;
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this._onUnBindObservable = null;
    this._onBindObserver = null;
    this._alphaMode = 2;
    this._needDepthPrePass = false;
    this.disableDepthWrite = false;
    this.disableColorWrite = false;
    this.forceDepthWrite = false;
    this.depthFunction = 0;
    this.separateCullingPass = false;
    this._fogEnabled = true;
    this.pointSize = 1;
    this.zOffset = 0;
    this.zOffsetUnits = 0;
    this.stencil = new MaterialStencilState();
    this._useUBO = false;
    this._fillMode = Material2.TriangleFillMode;
    this._cachedDepthWriteState = false;
    this._cachedColorWriteState = false;
    this._cachedDepthFunctionState = 0;
    this._indexInSceneMaterialArray = -1;
    this.meshMap = null;
    this._parentContainer = null;
    this._uniformBufferLayoutBuilt = false;
    this._eventInfo = {};
    this._callbackPluginEventGeneric = function() {
      return void 0;
    };
    this._callbackPluginEventIsReadyForSubMesh = function() {
      return void 0;
    };
    this._callbackPluginEventPrepareDefines = function() {
      return void 0;
    };
    this._callbackPluginEventHardBindForSubMesh = function() {
      return void 0;
    };
    this._callbackPluginEventBindForSubMesh = function() {
      return void 0;
    };
    this._callbackPluginEventHasRenderTargetTextures = function() {
      return void 0;
    };
    this._callbackPluginEventFillRenderTargetTextures = function() {
      return void 0;
    };
    this._forceAlphaTest = false;
    this._transparencyMode = null;
    this.name = name2;
    var setScene = scene || EngineStore.LastCreatedScene;
    if (!setScene) {
      return;
    }
    this._scene = setScene;
    this._dirtyCallbacks = {};
    this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this);
    this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this);
    this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this);
    this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this);
    this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this);
    this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this);
    this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this);
    this.id = name2 || Tools.RandomId();
    this.uniqueId = this._scene.getUniqueId();
    this._materialContext = this._scene.getEngine().createMaterialContext();
    this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);
    this._drawWrapper.materialContext = this._materialContext;
    if (this._scene.useRightHandedSystem) {
      this.sideOrientation = Material2.ClockWiseSideOrientation;
    } else {
      this.sideOrientation = Material2.CounterClockWiseSideOrientation;
    }
    this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), void 0, void 0, name2);
    this._useUBO = this.getScene().getEngine().supportsUniformBuffers;
    if (!doNotAdd) {
      this._scene.addMaterial(this);
    }
    if (this._scene.useMaterialMeshMap) {
      this.meshMap = {};
    }
    Material2.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);
  }
  Object.defineProperty(Material2.prototype, "canRenderToMRT", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "alpha", {
    get: function() {
      return this._alpha;
    },
    set: function(value) {
      if (this._alpha === value) {
        return;
      }
      this._alpha = value;
      this.markAsDirty(Material2.MiscDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "backFaceCulling", {
    get: function() {
      return this._backFaceCulling;
    },
    set: function(value) {
      if (this._backFaceCulling === value) {
        return;
      }
      this._backFaceCulling = value;
      this.markAsDirty(Material2.TextureDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "cullBackFaces", {
    get: function() {
      return this._cullBackFaces;
    },
    set: function(value) {
      if (this._cullBackFaces === value) {
        return;
      }
      this._cullBackFaces = value;
      this.markAsDirty(Material2.TextureDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "hasRenderTargetTextures", {
    get: function() {
      this._eventInfo.hasRenderTargetTextures = false;
      this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
      return this._eventInfo.hasRenderTargetTextures;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onBindObservable", {
    get: function() {
      if (!this._onBindObservable) {
        this._onBindObservable = new Observable();
      }
      return this._onBindObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onBind", {
    set: function(callback) {
      if (this._onBindObserver) {
        this.onBindObservable.remove(this._onBindObserver);
      }
      this._onBindObserver = this.onBindObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onUnBindObservable", {
    get: function() {
      if (!this._onUnBindObservable) {
        this._onUnBindObservable = new Observable();
      }
      return this._onUnBindObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onEffectCreatedObservable", {
    get: function() {
      if (!this._onEffectCreatedObservable) {
        this._onEffectCreatedObservable = new Observable();
      }
      return this._onEffectCreatedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "alphaMode", {
    get: function() {
      return this._alphaMode;
    },
    set: function(value) {
      if (this._alphaMode === value) {
        return;
      }
      this._alphaMode = value;
      this.markAsDirty(Material2.TextureDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "needDepthPrePass", {
    get: function() {
      return this._needDepthPrePass;
    },
    set: function(value) {
      if (this._needDepthPrePass === value) {
        return;
      }
      this._needDepthPrePass = value;
      if (this._needDepthPrePass) {
        this.checkReadyOnEveryCall = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "isPrePassCapable", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "fogEnabled", {
    get: function() {
      return this._fogEnabled;
    },
    set: function(value) {
      if (this._fogEnabled === value) {
        return;
      }
      this._fogEnabled = value;
      this.markAsDirty(Material2.MiscDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "wireframe", {
    get: function() {
      switch (this._fillMode) {
        case Material2.WireFrameFillMode:
        case Material2.LineListDrawMode:
        case Material2.LineLoopDrawMode:
        case Material2.LineStripDrawMode:
          return true;
      }
      return this._scene.forceWireframe;
    },
    set: function(value) {
      this.fillMode = value ? Material2.WireFrameFillMode : Material2.TriangleFillMode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "pointsCloud", {
    get: function() {
      switch (this._fillMode) {
        case Material2.PointFillMode:
        case Material2.PointListDrawMode:
          return true;
      }
      return this._scene.forcePointsCloud;
    },
    set: function(value) {
      this.fillMode = value ? Material2.PointFillMode : Material2.TriangleFillMode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "fillMode", {
    get: function() {
      return this._fillMode;
    },
    set: function(value) {
      if (this._fillMode === value) {
        return;
      }
      this._fillMode = value;
      this.markAsDirty(Material2.MiscDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Material2.prototype._getDrawWrapper = function() {
    return this._drawWrapper;
  };
  Material2.prototype._setDrawWrapper = function(drawWrapper) {
    this._drawWrapper = drawWrapper;
  };
  Material2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name;
    return ret;
  };
  Material2.prototype.getClassName = function() {
    return "Material";
  };
  Object.defineProperty(Material2.prototype, "isFrozen", {
    get: function() {
      return this.checkReadyOnlyOnce;
    },
    enumerable: false,
    configurable: true
  });
  Material2.prototype.freeze = function() {
    this.markDirty();
    this.checkReadyOnlyOnce = true;
  };
  Material2.prototype.unfreeze = function() {
    this.markDirty();
    this.checkReadyOnlyOnce = false;
  };
  Material2.prototype.isReady = function(mesh, useInstances) {
    return true;
  };
  Material2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    var defines = subMesh.materialDefines;
    if (!defines) {
      return false;
    }
    this._eventInfo.isReadyForSubMesh = true;
    this._eventInfo.defines = defines;
    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
    return this._eventInfo.isReadyForSubMesh;
  };
  Material2.prototype.getEffect = function() {
    return this._drawWrapper.effect;
  };
  Material2.prototype.getScene = function() {
    return this._scene;
  };
  Object.defineProperty(Material2.prototype, "transparencyMode", {
    get: function() {
      return this._transparencyMode;
    },
    set: function(value) {
      if (this._transparencyMode === value) {
        return;
      }
      this._transparencyMode = value;
      this._forceAlphaTest = value === Material2.MATERIAL_ALPHATESTANDBLEND;
      this._markAllSubMeshesAsTexturesAndMiscDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "_disableAlphaBlending", {
    get: function() {
      return this._transparencyMode === Material2.MATERIAL_OPAQUE || this._transparencyMode === Material2.MATERIAL_ALPHATEST;
    },
    enumerable: false,
    configurable: true
  });
  Material2.prototype.needAlphaBlending = function() {
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1;
  };
  Material2.prototype.needAlphaBlendingForMesh = function(mesh) {
    if (this._disableAlphaBlending && mesh.visibility >= 1) {
      return false;
    }
    return this.needAlphaBlending() || mesh.visibility < 1 || mesh.hasVertexAlpha;
  };
  Material2.prototype.needAlphaTesting = function() {
    if (this._forceAlphaTest) {
      return true;
    }
    return false;
  };
  Material2.prototype._shouldTurnAlphaTestOn = function(mesh) {
    return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();
  };
  Material2.prototype.getAlphaTestTexture = function() {
    return null;
  };
  Material2.prototype.markDirty = function() {
    var meshes = this.getScene().meshes;
    for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
      var mesh = meshes_1[_i];
      if (!mesh.subMeshes) {
        continue;
      }
      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {
        var subMesh = _b[_a];
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        if (!subMesh.effect) {
          continue;
        }
        subMesh.effect._wasPreviouslyReady = false;
      }
    }
  };
  Material2.prototype._preBind = function(effect, overrideOrientation) {
    if (overrideOrientation === void 0) {
      overrideOrientation = null;
    }
    var engine = this._scene.getEngine();
    var orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;
    var reverse = orientation === Material2.ClockWiseSideOrientation;
    engine.enableEffect(effect ? effect : this._getDrawWrapper());
    engine.setState(this.backFaceCulling, this.zOffset, false, reverse, this.cullBackFaces, this.stencil, this.zOffsetUnits);
    return reverse;
  };
  Material2.prototype.bind = function(world, mesh) {
  };
  Material2.prototype.buildUniformLayout = function() {
    var ubo = this._uniformBuffer;
    this._eventInfo.ubo = ubo;
    this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);
    ubo.create();
    this._uniformBufferLayoutBuilt = true;
  };
  Material2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
    var effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventBindForSubMesh(this._eventInfo);
  };
  Material2.prototype.bindOnlyWorldMatrix = function(world) {
  };
  Material2.prototype.bindView = function(effect) {
    if (!this._useUBO) {
      effect.setMatrix("view", this.getScene().getViewMatrix());
    } else {
      this._needToBindSceneUbo = true;
    }
  };
  Material2.prototype.bindViewProjection = function(effect) {
    if (!this._useUBO) {
      effect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
      effect.setMatrix("projection", this.getScene().getProjectionMatrix());
    } else {
      this._needToBindSceneUbo = true;
    }
  };
  Material2.prototype.bindEyePosition = function(effect, variableName) {
    if (!this._useUBO) {
      this._scene.bindEyePosition(effect, variableName);
    } else {
      this._needToBindSceneUbo = true;
    }
  };
  Material2.prototype._afterBind = function(mesh, effect) {
    if (effect === void 0) {
      effect = null;
    }
    this._scene._cachedMaterial = this;
    if (this._needToBindSceneUbo) {
      if (effect) {
        this._needToBindSceneUbo = false;
        MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());
        this._scene.finalizeSceneUbo();
      }
    }
    if (mesh) {
      this._scene._cachedVisibility = mesh.visibility;
    } else {
      this._scene._cachedVisibility = 1;
    }
    if (this._onBindObservable && mesh) {
      this._onBindObservable.notifyObservers(mesh);
    }
    if (this.disableDepthWrite) {
      var engine = this._scene.getEngine();
      this._cachedDepthWriteState = engine.getDepthWrite();
      engine.setDepthWrite(false);
    }
    if (this.disableColorWrite) {
      var engine = this._scene.getEngine();
      this._cachedColorWriteState = engine.getColorWrite();
      engine.setColorWrite(false);
    }
    if (this.depthFunction !== 0) {
      var engine = this._scene.getEngine();
      this._cachedDepthFunctionState = engine.getDepthFunction() || 0;
      engine.setDepthFunction(this.depthFunction);
    }
  };
  Material2.prototype.unbind = function() {
    if (this._onUnBindObservable) {
      this._onUnBindObservable.notifyObservers(this);
    }
    if (this.depthFunction !== 0) {
      var engine = this._scene.getEngine();
      engine.setDepthFunction(this._cachedDepthFunctionState);
    }
    if (this.disableDepthWrite) {
      var engine = this._scene.getEngine();
      engine.setDepthWrite(this._cachedDepthWriteState);
    }
    if (this.disableColorWrite) {
      var engine = this._scene.getEngine();
      engine.setColorWrite(this._cachedColorWriteState);
    }
  };
  Material2.prototype.getAnimatables = function() {
    this._eventInfo.animatables = [];
    this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);
    return this._eventInfo.animatables;
  };
  Material2.prototype.getActiveTextures = function() {
    this._eventInfo.activeTextures = [];
    this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);
    return this._eventInfo.activeTextures;
  };
  Material2.prototype.hasTexture = function(texture) {
    this._eventInfo.hasTexture = false;
    this._eventInfo.texture = texture;
    this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);
    return this._eventInfo.hasTexture;
  };
  Material2.prototype.clone = function(name2) {
    return null;
  };
  Material2.prototype.getBindedMeshes = function() {
    var _this = this;
    if (this.meshMap) {
      var result = new Array();
      for (var meshId in this.meshMap) {
        var mesh = this.meshMap[meshId];
        if (mesh) {
          result.push(mesh);
        }
      }
      return result;
    } else {
      var meshes = this._scene.meshes;
      return meshes.filter(function(mesh2) {
        return mesh2.material === _this;
      });
    }
  };
  Material2.prototype.forceCompilation = function(mesh, onCompiled, options, onError) {
    var _this = this;
    var localOptions = __assign({ clipPlane: false, useInstances: false }, options);
    var scene = this.getScene();
    var currentHotSwapingState = this.allowShaderHotSwapping;
    this.allowShaderHotSwapping = false;
    var checkReady = function() {
      if (!_this._scene || !_this._scene.getEngine()) {
        return;
      }
      var clipPlaneState = scene.clipPlane;
      if (localOptions.clipPlane) {
        scene.clipPlane = new Plane(0, 0, 0, 1);
      }
      if (_this._storeEffectOnSubMeshes) {
        var allDone = true, lastError = null;
        if (mesh.subMeshes) {
          var tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, void 0, false, false);
          if (tempSubMesh.materialDefines) {
            tempSubMesh.materialDefines._renderId = -1;
          }
          if (!_this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {
            if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {
              lastError = tempSubMesh.effect.getCompilationError();
            } else {
              allDone = false;
              setTimeout(checkReady, 16);
            }
          }
        }
        if (allDone) {
          _this.allowShaderHotSwapping = currentHotSwapingState;
          if (lastError) {
            if (onError) {
              onError(lastError);
            }
          }
          if (onCompiled) {
            onCompiled(_this);
          }
        }
      } else {
        if (_this.isReady()) {
          _this.allowShaderHotSwapping = currentHotSwapingState;
          if (onCompiled) {
            onCompiled(_this);
          }
        } else {
          setTimeout(checkReady, 16);
        }
      }
      if (localOptions.clipPlane) {
        scene.clipPlane = clipPlaneState;
      }
    };
    checkReady();
  };
  Material2.prototype.forceCompilationAsync = function(mesh, options) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this.forceCompilation(mesh, function() {
        resolve();
      }, options, function(reason) {
        reject(reason);
      });
    });
  };
  Material2.prototype.markAsDirty = function(flag) {
    if (this.getScene().blockMaterialDirtyMechanism) {
      return;
    }
    Material2._DirtyCallbackArray.length = 0;
    if (flag & Material2.TextureDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._TextureDirtyCallBack);
    }
    if (flag & Material2.LightDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._LightsDirtyCallBack);
    }
    if (flag & Material2.FresnelDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._FresnelDirtyCallBack);
    }
    if (flag & Material2.AttributesDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._AttributeDirtyCallBack);
    }
    if (flag & Material2.MiscDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._MiscDirtyCallBack);
    }
    if (flag & Material2.PrePassDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._PrePassDirtyCallBack);
    }
    if (Material2._DirtyCallbackArray.length) {
      this._markAllSubMeshesAsDirty(Material2._RunDirtyCallBacks);
    }
    this.getScene().resetCachedMaterial();
  };
  Material2.prototype.resetDrawCache = function() {
    var meshes = this.getScene().meshes;
    for (var _i = 0, meshes_2 = meshes; _i < meshes_2.length; _i++) {
      var mesh = meshes_2[_i];
      if (!mesh.subMeshes) {
        continue;
      }
      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {
        var subMesh = _b[_a];
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        subMesh.resetDrawCache();
      }
    }
  };
  Material2.prototype._markAllSubMeshesAsDirty = function(func) {
    if (this.getScene().blockMaterialDirtyMechanism) {
      return;
    }
    var meshes = this.getScene().meshes;
    for (var _i = 0, meshes_3 = meshes; _i < meshes_3.length; _i++) {
      var mesh = meshes_3[_i];
      if (!mesh.subMeshes) {
        continue;
      }
      for (var _a = 0, _b = mesh.subMeshes; _a < _b.length; _a++) {
        var subMesh = _b[_a];
        if (mesh._renderId === 0 || subMesh.getMaterial() !== this) {
          continue;
        }
        for (var _c = 0, _d = subMesh._drawWrappers; _c < _d.length; _c++) {
          var drawWrapper = _d[_c];
          if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {
            continue;
          }
          if (this._materialContext === drawWrapper.materialContext) {
            func(drawWrapper.defines);
          }
        }
      }
    }
  };
  Material2.prototype._markScenePrePassDirty = function() {
    if (this.getScene().blockMaterialDirtyMechanism) {
      return;
    }
    var prePassRenderer = this.getScene().enablePrePassRenderer();
    if (prePassRenderer) {
      prePassRenderer.markAsDirty();
    }
  };
  Material2.prototype._markAllSubMeshesAsAllDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._AllDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsImageProcessingDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._ImageProcessingDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsTexturesDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._TextureDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsFresnelDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._FresnelDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsFresnelAndMiscDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._FresnelAndMiscDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsLightsDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._LightsDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsAttributesDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._AttributeDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsMiscDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._MiscDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsPrePassDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._MiscDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsTexturesAndMiscDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._TextureAndMiscDirtyCallBack);
  };
  Material2.prototype.setPrePassRenderer = function(prePassRenderer) {
    return false;
  };
  Material2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    var scene = this.getScene();
    scene.stopAnimation(this);
    scene.freeProcessedMaterials();
    scene.removeMaterial(this);
    this._eventInfo.forceDisposeTextures = forceDisposeTextures;
    this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);
    if (this._parentContainer) {
      var index = this._parentContainer.materials.indexOf(this);
      if (index > -1) {
        this._parentContainer.materials.splice(index, 1);
      }
      this._parentContainer = null;
    }
    if (notBoundToMesh !== true) {
      if (this.meshMap) {
        for (var meshId in this.meshMap) {
          var mesh = this.meshMap[meshId];
          if (mesh) {
            mesh.material = null;
            this.releaseVertexArrayObject(mesh, forceDisposeEffect);
          }
        }
      } else {
        var meshes = scene.meshes;
        for (var _i = 0, meshes_4 = meshes; _i < meshes_4.length; _i++) {
          var mesh = meshes_4[_i];
          if (mesh.material === this && !mesh.sourceMesh) {
            mesh.material = null;
            this.releaseVertexArrayObject(mesh, forceDisposeEffect);
          }
        }
      }
    }
    this._uniformBuffer.dispose();
    if (forceDisposeEffect && this._drawWrapper.effect) {
      if (!this._storeEffectOnSubMeshes) {
        this._drawWrapper.effect.dispose();
      }
      this._drawWrapper.effect = null;
    }
    this.metadata = null;
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    if (this._onBindObservable) {
      this._onBindObservable.clear();
    }
    if (this._onUnBindObservable) {
      this._onUnBindObservable.clear();
    }
    if (this._onEffectCreatedObservable) {
      this._onEffectCreatedObservable.clear();
    }
  };
  Material2.prototype.releaseVertexArrayObject = function(mesh, forceDisposeEffect) {
    if (mesh.geometry) {
      var geometry = mesh.geometry;
      if (this._storeEffectOnSubMeshes) {
        for (var _i = 0, _a = mesh.subMeshes; _i < _a.length; _i++) {
          var subMesh = _a[_i];
          geometry._releaseVertexArrayObject(subMesh.effect);
          if (forceDisposeEffect && subMesh.effect) {
            subMesh.effect.dispose();
          }
        }
      } else {
        geometry._releaseVertexArrayObject(this._drawWrapper.effect);
      }
    }
  };
  Material2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.stencil = this.stencil.serialize();
    serializationObject.uniqueId = this.uniqueId;
    return serializationObject;
  };
  Material2.Parse = function(parsedMaterial, scene, rootUrl) {
    if (!parsedMaterial.customType) {
      parsedMaterial.customType = "BABYLON.StandardMaterial";
    } else if (parsedMaterial.customType === "BABYLON.PBRMaterial" && parsedMaterial.overloadedAlbedo) {
      parsedMaterial.customType = "BABYLON.LegacyPBRMaterial";
      if (!BABYLON.LegacyPBRMaterial) {
        Logger.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.");
        return null;
      }
    }
    var materialType = Tools.Instantiate(parsedMaterial.customType);
    var material = materialType.Parse(parsedMaterial, scene, rootUrl);
    material._loadedUniqueId = parsedMaterial.uniqueId;
    return material;
  };
  Material2.TriangleFillMode = 0;
  Material2.WireFrameFillMode = 1;
  Material2.PointFillMode = 2;
  Material2.PointListDrawMode = 3;
  Material2.LineListDrawMode = 4;
  Material2.LineLoopDrawMode = 5;
  Material2.LineStripDrawMode = 6;
  Material2.TriangleStripDrawMode = 7;
  Material2.TriangleFanDrawMode = 8;
  Material2.ClockWiseSideOrientation = 0;
  Material2.CounterClockWiseSideOrientation = 1;
  Material2.TextureDirtyFlag = 1;
  Material2.LightDirtyFlag = 2;
  Material2.FresnelDirtyFlag = 4;
  Material2.AttributesDirtyFlag = 8;
  Material2.MiscDirtyFlag = 16;
  Material2.PrePassDirtyFlag = 32;
  Material2.AllDirtyFlag = 63;
  Material2.MATERIAL_OPAQUE = 0;
  Material2.MATERIAL_ALPHATEST = 1;
  Material2.MATERIAL_ALPHABLEND = 2;
  Material2.MATERIAL_ALPHATESTANDBLEND = 3;
  Material2.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;
  Material2.MATERIAL_NORMALBLENDMETHOD_RNM = 1;
  Material2.OnEventObservable = new Observable();
  Material2._AllDirtyCallBack = function(defines) {
    return defines.markAllAsDirty();
  };
  Material2._ImageProcessingDirtyCallBack = function(defines) {
    return defines.markAsImageProcessingDirty();
  };
  Material2._TextureDirtyCallBack = function(defines) {
    return defines.markAsTexturesDirty();
  };
  Material2._FresnelDirtyCallBack = function(defines) {
    return defines.markAsFresnelDirty();
  };
  Material2._MiscDirtyCallBack = function(defines) {
    return defines.markAsMiscDirty();
  };
  Material2._PrePassDirtyCallBack = function(defines) {
    return defines.markAsPrePassDirty();
  };
  Material2._LightsDirtyCallBack = function(defines) {
    return defines.markAsLightDirty();
  };
  Material2._AttributeDirtyCallBack = function(defines) {
    return defines.markAsAttributesDirty();
  };
  Material2._FresnelAndMiscDirtyCallBack = function(defines) {
    Material2._FresnelDirtyCallBack(defines);
    Material2._MiscDirtyCallBack(defines);
  };
  Material2._TextureAndMiscDirtyCallBack = function(defines) {
    Material2._TextureDirtyCallBack(defines);
    Material2._MiscDirtyCallBack(defines);
  };
  Material2._DirtyCallbackArray = [];
  Material2._RunDirtyCallBacks = function(defines) {
    for (var _i = 0, _a = Material2._DirtyCallbackArray; _i < _a.length; _i++) {
      var cb = _a[_i];
      cb(defines);
    }
  };
  __decorate([
    serialize()
  ], Material2.prototype, "id", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "uniqueId", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "name", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "metadata", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "checkReadyOnEveryCall", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "checkReadyOnlyOnce", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "state", void 0);
  __decorate([
    serialize("alpha")
  ], Material2.prototype, "_alpha", void 0);
  __decorate([
    serialize("backFaceCulling")
  ], Material2.prototype, "_backFaceCulling", void 0);
  __decorate([
    serialize("cullBackFaces")
  ], Material2.prototype, "_cullBackFaces", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "sideOrientation", void 0);
  __decorate([
    serialize("alphaMode")
  ], Material2.prototype, "_alphaMode", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "_needDepthPrePass", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "disableDepthWrite", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "disableColorWrite", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "forceDepthWrite", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "depthFunction", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "separateCullingPass", void 0);
  __decorate([
    serialize("fogEnabled")
  ], Material2.prototype, "_fogEnabled", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "pointSize", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "zOffset", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "zOffsetUnits", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "pointsCloud", null);
  __decorate([
    serialize()
  ], Material2.prototype, "fillMode", null);
  __decorate([
    serialize()
  ], Material2.prototype, "transparencyMode", null);
  return Material2;
}();
var MultiMaterial = function(_super) {
  __extends(MultiMaterial2, _super);
  function MultiMaterial2(name2, scene) {
    var _this = _super.call(this, name2, scene, true) || this;
    _this._waitingSubMaterialsUniqueIds = [];
    _this.getScene().multiMaterials.push(_this);
    _this.subMaterials = new Array();
    _this._storeEffectOnSubMeshes = true;
    return _this;
  }
  Object.defineProperty(MultiMaterial2.prototype, "subMaterials", {
    get: function() {
      return this._subMaterials;
    },
    set: function(value) {
      this._subMaterials = value;
      this._hookArray(value);
    },
    enumerable: false,
    configurable: true
  });
  MultiMaterial2.prototype.getChildren = function() {
    return this.subMaterials;
  };
  MultiMaterial2.prototype._hookArray = function(array) {
    var _this = this;
    var oldPush = array.push;
    array.push = function() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      var result = oldPush.apply(array, items);
      _this._markAllSubMeshesAsTexturesDirty();
      return result;
    };
    var oldSplice = array.splice;
    array.splice = function(index, deleteCount) {
      var deleted = oldSplice.apply(array, [index, deleteCount]);
      _this._markAllSubMeshesAsTexturesDirty();
      return deleted;
    };
  };
  MultiMaterial2.prototype.getSubMaterial = function(index) {
    if (index < 0 || index >= this.subMaterials.length) {
      return this.getScene().defaultMaterial;
    }
    return this.subMaterials[index];
  };
  MultiMaterial2.prototype.getActiveTextures = function() {
    var _a;
    return (_a = _super.prototype.getActiveTextures.call(this)).concat.apply(_a, this.subMaterials.map(function(subMaterial) {
      if (subMaterial) {
        return subMaterial.getActiveTextures();
      } else {
        return [];
      }
    }));
  };
  MultiMaterial2.prototype.hasTexture = function(texture) {
    var _a;
    if (_super.prototype.hasTexture.call(this, texture)) {
      return true;
    }
    for (var i = 0; i < this.subMaterials.length; i++) {
      if ((_a = this.subMaterials[i]) === null || _a === void 0 ? void 0 : _a.hasTexture(texture)) {
        return true;
      }
    }
    return false;
  };
  MultiMaterial2.prototype.getClassName = function() {
    return "MultiMaterial";
  };
  MultiMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    for (var index = 0; index < this.subMaterials.length; index++) {
      var subMaterial = this.subMaterials[index];
      if (subMaterial) {
        if (subMaterial._storeEffectOnSubMeshes) {
          if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {
            return false;
          }
          continue;
        }
        if (!subMaterial.isReady(mesh)) {
          return false;
        }
      }
    }
    return true;
  };
  MultiMaterial2.prototype.clone = function(name2, cloneChildren) {
    var newMultiMaterial = new MultiMaterial2(name2, this.getScene());
    for (var index = 0; index < this.subMaterials.length; index++) {
      var subMaterial = null;
      var current = this.subMaterials[index];
      if (cloneChildren && current) {
        subMaterial = current.clone(name2 + "-" + current.name);
      } else {
        subMaterial = this.subMaterials[index];
      }
      newMultiMaterial.subMaterials.push(subMaterial);
    }
    return newMultiMaterial;
  };
  MultiMaterial2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.id = this.id;
    serializationObject.uniqueId = this.uniqueId;
    if (Tags) {
      serializationObject.tags = Tags.GetTags(this);
    }
    serializationObject.materialsUniqueIds = [];
    serializationObject.materials = [];
    for (var matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {
      var subMat = this.subMaterials[matIndex];
      if (subMat) {
        serializationObject.materialsUniqueIds.push(subMat.uniqueId);
        serializationObject.materials.push(subMat.id);
      } else {
        serializationObject.materialsUniqueIds.push(null);
        serializationObject.materials.push(null);
      }
    }
    return serializationObject;
  };
  MultiMaterial2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures, forceDisposeChildren) {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    if (forceDisposeChildren) {
      for (var index = 0; index < this.subMaterials.length; index++) {
        var subMaterial = this.subMaterials[index];
        if (subMaterial) {
          subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);
        }
      }
    }
    var index = scene.multiMaterials.indexOf(this);
    if (index >= 0) {
      scene.multiMaterials.splice(index, 1);
    }
    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);
  };
  MultiMaterial2.ParseMultiMaterial = function(parsedMultiMaterial, scene) {
    var multiMaterial = new MultiMaterial2(parsedMultiMaterial.name, scene);
    multiMaterial.id = parsedMultiMaterial.id;
    multiMaterial._loadedUniqueId = parsedMultiMaterial.uniqueId;
    if (Tags) {
      Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);
    }
    if (parsedMultiMaterial.materialsUniqueIds) {
      multiMaterial._waitingSubMaterialsUniqueIds = parsedMultiMaterial.materialsUniqueIds;
    } else {
      parsedMultiMaterial.materials.forEach(function(subMatId) {
        return multiMaterial.subMaterials.push(scene.getLastMaterialById(subMatId));
      });
    }
    return multiMaterial;
  };
  return MultiMaterial2;
}(Material);
RegisterClass("BABYLON.MultiMaterial", MultiMaterial);
var MeshLODLevel = function() {
  function MeshLODLevel2(distanceOrScreenCoverage, mesh) {
    this.distanceOrScreenCoverage = distanceOrScreenCoverage;
    this.mesh = mesh;
  }
  return MeshLODLevel2;
}();
var _injectLTSMesh = function(Mesh2) {
  Mesh2.prototype.setMaterialByID = function(id) {
    return this.setMaterialById(id);
  };
  Mesh2.CreateDisc = Mesh2.CreateDisc || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreateBox = Mesh2.CreateBox || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreateSphere = Mesh2.CreateSphere || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreateCylinder = Mesh2.CreateCylinder || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreateTorusKnot = Mesh2.CreateTorusKnot || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreateTorus = Mesh2.CreateTorus || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreatePlane = Mesh2.CreatePlane || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreateGround = Mesh2.CreateGround || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreateTiledGround = Mesh2.CreateTiledGround || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreateGroundFromHeightMap = Mesh2.CreateGroundFromHeightMap || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreateTube = Mesh2.CreateTube || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreatePolyhedron = Mesh2.CreatePolyhedron || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreateIcoSphere = Mesh2.CreateIcoSphere || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreateDecal = Mesh2.CreateDecal || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreateCapsule = Mesh2.CreateCapsule || function() {
    throw _WarnImport("MeshBuilder");
  };
  Mesh2.CreateGoldberg = Mesh2.CreateGoldberg || function() {
    throw _WarnImport("MeshBuilder");
  };
};
var _InstanceDataStorage = function() {
  function _InstanceDataStorage2() {
    this.visibleInstances = {};
    this.batchCache = new _InstancesBatch();
    this.batchCacheReplacementModeInFrozenMode = new _InstancesBatch();
    this.instancesBufferSize = 32 * 16 * 4;
  }
  return _InstanceDataStorage2;
}();
var _InstancesBatch = function() {
  function _InstancesBatch2() {
    this.mustReturn = false;
    this.visibleInstances = new Array();
    this.renderSelf = new Array();
    this.hardwareInstancedRendering = new Array();
  }
  return _InstancesBatch2;
}();
var _ThinInstanceDataStorage = function() {
  function _ThinInstanceDataStorage2() {
    this.instancesCount = 0;
    this.matrixBuffer = null;
    this.previousMatrixBuffer = null;
    this.matrixBufferSize = 32 * 16;
    this.matrixData = null;
    this.boundingVectors = [];
    this.worldMatrices = null;
  }
  return _ThinInstanceDataStorage2;
}();
var _InternalMeshDataInfo = function() {
  function _InternalMeshDataInfo2() {
    this._areNormalsFrozen = false;
    this._source = null;
    this.meshMap = null;
    this._preActivateId = -1;
    this._LODLevels = new Array();
    this._useLODScreenCoverage = false;
    this._effectiveMaterial = null;
    this._forcedInstanceCount = 0;
  }
  return _InternalMeshDataInfo2;
}();
var Mesh = function(_super) {
  __extends(Mesh2, _super);
  function Mesh2(name2, scene, parent, source, doNotCloneChildren, clonePhysicsImpostor) {
    if (scene === void 0) {
      scene = null;
    }
    if (parent === void 0) {
      parent = null;
    }
    if (source === void 0) {
      source = null;
    }
    if (clonePhysicsImpostor === void 0) {
      clonePhysicsImpostor = true;
    }
    var _this = _super.call(this, name2, scene) || this;
    _this._internalMeshDataInfo = new _InternalMeshDataInfo();
    _this.delayLoadState = 0;
    _this.instances = new Array();
    _this._creationDataStorage = null;
    _this._geometry = null;
    _this._instanceDataStorage = new _InstanceDataStorage();
    _this._thinInstanceDataStorage = new _ThinInstanceDataStorage();
    _this._shouldGenerateFlatShading = false;
    _this._originalBuilderSideOrientation = Mesh2.DEFAULTSIDE;
    _this.overrideMaterialSideOrientation = null;
    _this.ignoreCameraMaxZ = false;
    scene = _this.getScene();
    _this._onBeforeDraw = function(isInstance, world, effectiveMaterial) {
      if (isInstance && effectiveMaterial) {
        if (_this._uniformBuffer) {
          _this.transferToEffect(world);
        } else {
          effectiveMaterial.bindOnlyWorldMatrix(world);
        }
      }
    };
    if (source) {
      if (source._geometry) {
        source._geometry.applyToMesh(_this);
      }
      DeepCopier.DeepCopy(source, _this, [
        "name",
        "material",
        "skeleton",
        "instances",
        "parent",
        "uniqueId",
        "source",
        "metadata",
        "morphTargetManager",
        "hasInstances",
        "worldMatrixInstancedBuffer",
        "previousWorldMatrixInstancedBuffer",
        "hasLODLevels",
        "geometry",
        "isBlocked",
        "areNormalsFrozen",
        "facetNb",
        "isFacetDataEnabled",
        "lightSources",
        "useBones",
        "isAnInstance",
        "collider",
        "edgesRenderer",
        "forward",
        "up",
        "right",
        "absolutePosition",
        "absoluteScaling",
        "absoluteRotationQuaternion",
        "isWorldMatrixFrozen",
        "nonUniformScaling",
        "behaviors",
        "worldMatrixFromCache",
        "hasThinInstances",
        "cloneMeshMap",
        "hasBoundingInfo"
      ], ["_poseMatrix"]);
      _this._internalMeshDataInfo._source = source;
      if (scene.useClonedMeshMap) {
        if (!source._internalMeshDataInfo.meshMap) {
          source._internalMeshDataInfo.meshMap = {};
        }
        source._internalMeshDataInfo.meshMap[_this.uniqueId] = _this;
      }
      _this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;
      _this._creationDataStorage = source._creationDataStorage;
      if (source._ranges) {
        var ranges = source._ranges;
        for (var name2 in ranges) {
          if (!ranges.hasOwnProperty(name2)) {
            continue;
          }
          if (!ranges[name2]) {
            continue;
          }
          _this.createAnimationRange(name2, ranges[name2].from, ranges[name2].to);
        }
      }
      if (source.metadata && source.metadata.clone) {
        _this.metadata = source.metadata.clone();
      } else {
        _this.metadata = source.metadata;
      }
      if (Tags && Tags.HasTags(source)) {
        Tags.AddTagsTo(_this, Tags.GetTags(source, true));
      }
      _this.setEnabled(source.isEnabled());
      _this.parent = source.parent;
      _this.setPivotMatrix(source.getPivotMatrix());
      _this.id = name2 + "." + source.id;
      _this.material = source.material;
      if (!doNotCloneChildren) {
        var directDescendants = source.getDescendants(true);
        for (var index = 0; index < directDescendants.length; index++) {
          var child = directDescendants[index];
          if (child.clone) {
            child.clone(name2 + "." + child.name, _this);
          }
        }
      }
      if (source.morphTargetManager) {
        _this.morphTargetManager = source.morphTargetManager;
      }
      if (scene.getPhysicsEngine) {
        var physicsEngine = scene.getPhysicsEngine();
        if (clonePhysicsImpostor && physicsEngine) {
          var impostor = physicsEngine.getImpostorForPhysicsObject(source);
          if (impostor) {
            _this.physicsImpostor = impostor.clone(_this);
          }
        }
      }
      for (var index = 0; index < scene.particleSystems.length; index++) {
        var system = scene.particleSystems[index];
        if (system.emitter === source) {
          system.clone(system.name, _this);
        }
      }
      _this.skeleton = source.skeleton;
      _this.refreshBoundingInfo(true, true);
      _this.computeWorldMatrix(true);
    }
    if (parent !== null) {
      _this.parent = parent;
    }
    _this._instanceDataStorage.hardwareInstancedRendering = _this.getEngine().getCaps().instancedArrays;
    _this._internalMeshDataInfo._onMeshReadyObserverAdded = function(observer) {
      observer.unregisterOnNextCall = true;
      if (_this.isReady(true)) {
        _this.onMeshReadyObservable.notifyObservers(_this);
      } else {
        if (!_this._internalMeshDataInfo._checkReadinessObserver) {
          _this._internalMeshDataInfo._checkReadinessObserver = _this._scene.onBeforeRenderObservable.add(function() {
            if (_this.isReady(true)) {
              _this._scene.onBeforeRenderObservable.remove(_this._internalMeshDataInfo._checkReadinessObserver);
              _this._internalMeshDataInfo._checkReadinessObserver = null;
              _this.onMeshReadyObservable.notifyObservers(_this);
            }
          });
        }
      }
    };
    _this.onMeshReadyObservable = new Observable(_this._internalMeshDataInfo._onMeshReadyObserverAdded);
    if (source) {
      source.onClonedObservable.notifyObservers(_this);
    }
    return _this;
  }
  Mesh2._GetDefaultSideOrientation = function(orientation) {
    return orientation || Mesh2.FRONTSIDE;
  };
  Object.defineProperty(Mesh2.prototype, "useLODScreenCoverage", {
    get: function() {
      return this._internalMeshDataInfo._useLODScreenCoverage;
    },
    set: function(value) {
      this._internalMeshDataInfo._useLODScreenCoverage = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "computeBonesUsingShaders", {
    get: function() {
      return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
        return;
      }
      if (value && this._internalMeshDataInfo._sourcePositions) {
        this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions.slice(), true);
        if (this._internalMeshDataInfo._sourceNormals) {
          this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals.slice(), true);
        }
      }
      this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBeforeRenderObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onBeforeRenderObservable) {
        this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();
      }
      return this._internalMeshDataInfo._onBeforeRenderObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBeforeBindObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onBeforeBindObservable) {
        this._internalMeshDataInfo._onBeforeBindObservable = new Observable();
      }
      return this._internalMeshDataInfo._onBeforeBindObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onAfterRenderObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onAfterRenderObservable) {
        this._internalMeshDataInfo._onAfterRenderObservable = new Observable();
      }
      return this._internalMeshDataInfo._onAfterRenderObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBetweenPassObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onBetweenPassObservable) {
        this._internalMeshDataInfo._onBetweenPassObservable = new Observable();
      }
      return this._internalMeshDataInfo._onBetweenPassObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBeforeDrawObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onBeforeDrawObservable) {
        this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();
      }
      return this._internalMeshDataInfo._onBeforeDrawObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBeforeDraw", {
    set: function(callback) {
      if (this._onBeforeDrawObserver) {
        this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);
      }
      this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "hasInstances", {
    get: function() {
      return this.instances.length > 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "hasThinInstances", {
    get: function() {
      var _a;
      return ((_a = this._thinInstanceDataStorage.instancesCount) !== null && _a !== void 0 ? _a : 0) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "forcedInstanceCount", {
    get: function() {
      return this._internalMeshDataInfo._forcedInstanceCount;
    },
    set: function(count) {
      this._internalMeshDataInfo._forcedInstanceCount = count;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "source", {
    get: function() {
      return this._internalMeshDataInfo._source;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "cloneMeshMap", {
    get: function() {
      return this._internalMeshDataInfo.meshMap;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "isUnIndexed", {
    get: function() {
      return this._unIndexed;
    },
    set: function(value) {
      if (this._unIndexed !== value) {
        this._unIndexed = value;
        this._markSubMeshesAsAttributesDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "worldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.instancesData;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "previousWorldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.instancesPreviousData;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "manualUpdateOfWorldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.manualUpdate;
    },
    set: function(value) {
      this._instanceDataStorage.manualUpdate = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "manualUpdateOfPreviousWorldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.previousManualUpdate;
    },
    set: function(value) {
      this._instanceDataStorage.previousManualUpdate = value;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.instantiateHierarchy = function(newParent, options, onNewNodeCreated) {
    if (newParent === void 0) {
      newParent = null;
    }
    var instance = this.getTotalVertices() > 0 && (!options || !options.doNotInstantiate) ? this.createInstance("instance of " + (this.name || this.id)) : this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true);
    instance.parent = newParent || this.parent;
    instance.position = this.position.clone();
    instance.scaling = this.scaling.clone();
    if (this.rotationQuaternion) {
      instance.rotationQuaternion = this.rotationQuaternion.clone();
    } else {
      instance.rotation = this.rotation.clone();
    }
    if (onNewNodeCreated) {
      onNewNodeCreated(this, instance);
    }
    for (var _i = 0, _a = this.getChildTransformNodes(true); _i < _a.length; _i++) {
      var child = _a[_i];
      child.instantiateHierarchy(instance, options, onNewNodeCreated);
    }
    return instance;
  };
  Mesh2.prototype.getClassName = function() {
    return "Mesh";
  };
  Object.defineProperty(Mesh2.prototype, "_isMesh", {
    get: function() {
      return true;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.toString = function(fullDetails) {
    var ret = _super.prototype.toString.call(this, fullDetails);
    ret += ", n vertices: " + this.getTotalVertices();
    ret += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE");
    if (this.animations) {
      for (var i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    if (fullDetails) {
      if (this._geometry) {
        var ib = this.getIndices();
        var vb = this.getVerticesData(VertexBuffer.PositionKind);
        if (vb && ib) {
          ret += ", flat shading: " + (vb.length / 3 === ib.length ? "YES" : "NO");
        }
      } else {
        ret += ", flat shading: UNKNOWN";
      }
    }
    return ret;
  };
  Mesh2.prototype._unBindEffect = function() {
    _super.prototype._unBindEffect.call(this);
    for (var _i = 0, _a = this.instances; _i < _a.length; _i++) {
      var instance = _a[_i];
      instance._unBindEffect();
    }
  };
  Object.defineProperty(Mesh2.prototype, "hasLODLevels", {
    get: function() {
      return this._internalMeshDataInfo._LODLevels.length > 0;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.getLODLevels = function() {
    return this._internalMeshDataInfo._LODLevels;
  };
  Mesh2.prototype._sortLODLevels = function() {
    var sortingOrderFactor = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;
    this._internalMeshDataInfo._LODLevels.sort(function(a, b) {
      if (a.distanceOrScreenCoverage < b.distanceOrScreenCoverage) {
        return sortingOrderFactor;
      }
      if (a.distanceOrScreenCoverage > b.distanceOrScreenCoverage) {
        return -sortingOrderFactor;
      }
      return 0;
    });
  };
  Mesh2.prototype.addLODLevel = function(distanceOrScreenCoverage, mesh) {
    if (mesh && mesh._masterMesh) {
      Logger.Warn("You cannot use a mesh as LOD level twice");
      return this;
    }
    var level = new MeshLODLevel(distanceOrScreenCoverage, mesh);
    this._internalMeshDataInfo._LODLevels.push(level);
    if (mesh) {
      mesh._masterMesh = this;
    }
    this._sortLODLevels();
    return this;
  };
  Mesh2.prototype.getLODLevelAtDistance = function(distance) {
    var internalDataInfo = this._internalMeshDataInfo;
    for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {
      var level = internalDataInfo._LODLevels[index];
      if (level.distanceOrScreenCoverage === distance) {
        return level.mesh;
      }
    }
    return null;
  };
  Mesh2.prototype.removeLODLevel = function(mesh) {
    var internalDataInfo = this._internalMeshDataInfo;
    for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {
      if (internalDataInfo._LODLevels[index].mesh === mesh) {
        internalDataInfo._LODLevels.splice(index, 1);
        if (mesh) {
          mesh._masterMesh = null;
        }
      }
    }
    this._sortLODLevels();
    return this;
  };
  Mesh2.prototype.getLOD = function(camera, boundingSphere) {
    var internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {
      return this;
    }
    var bSphere;
    if (boundingSphere) {
      bSphere = boundingSphere;
    } else {
      var boundingInfo = this.getBoundingInfo();
      bSphere = boundingInfo.boundingSphere;
    }
    var distanceToCamera = bSphere.centerWorld.subtract(camera.globalPosition).length();
    var useScreenCoverage = internalDataInfo._useLODScreenCoverage;
    var compareValue = distanceToCamera;
    var compareSign = 1;
    if (useScreenCoverage) {
      var screenArea = camera.screenArea;
      var meshArea = bSphere.radiusWorld * camera.minZ / distanceToCamera;
      meshArea = meshArea * meshArea * Math.PI;
      compareValue = meshArea / screenArea;
      compareSign = -1;
    }
    if (compareSign * internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distanceOrScreenCoverage > compareSign * compareValue) {
      if (this.onLODLevelSelection) {
        this.onLODLevelSelection(compareValue, this, this);
      }
      return this;
    }
    for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {
      var level = internalDataInfo._LODLevels[index];
      if (compareSign * level.distanceOrScreenCoverage < compareSign * compareValue) {
        if (level.mesh) {
          if (level.mesh.delayLoadState === 4) {
            level.mesh._checkDelayState();
            return this;
          }
          if (level.mesh.delayLoadState === 2) {
            return this;
          }
          level.mesh._preActivate();
          level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
        }
        if (this.onLODLevelSelection) {
          this.onLODLevelSelection(compareValue, this, level.mesh);
        }
        return level.mesh;
      }
    }
    if (this.onLODLevelSelection) {
      this.onLODLevelSelection(compareValue, this, this);
    }
    return this;
  };
  Object.defineProperty(Mesh2.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.getTotalVertices = function() {
    if (this._geometry === null || this._geometry === void 0) {
      return 0;
    }
    return this._geometry.getTotalVertices();
  };
  Mesh2.prototype.getVerticesData = function(kind, copyWhenShared, forceCopy) {
    var _a, _b;
    if (!this._geometry) {
      return null;
    }
    var data = (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.getFloatData(this._geometry.getTotalVertices(), forceCopy || copyWhenShared && this._geometry.meshes.length !== 1);
    if (!data) {
      data = this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);
    }
    return data;
  };
  Mesh2.prototype.getVertexBuffer = function(kind) {
    var _a, _b;
    if (!this._geometry) {
      return null;
    }
    return (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== null && _b !== void 0 ? _b : this._geometry.getVertexBuffer(kind);
  };
  Mesh2.prototype.isVerticesDataPresent = function(kind) {
    var _a;
    if (!this._geometry) {
      if (this._delayInfo) {
        return this._delayInfo.indexOf(kind) !== -1;
      }
      return false;
    }
    return ((_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== void 0 || this._geometry.isVerticesDataPresent(kind);
  };
  Mesh2.prototype.isVertexBufferUpdatable = function(kind) {
    var _a, _b;
    if (!this._geometry) {
      if (this._delayInfo) {
        return this._delayInfo.indexOf(kind) !== -1;
      }
      return false;
    }
    return ((_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.isUpdatable()) || this._geometry.isVertexBufferUpdatable(kind);
  };
  Mesh2.prototype.getVerticesDataKinds = function() {
    if (!this._geometry) {
      var result = new Array();
      if (this._delayInfo) {
        this._delayInfo.forEach(function(kind2) {
          result.push(kind2);
        });
      }
      return result;
    }
    var kinds = this._geometry.getVerticesDataKinds();
    if (this._userInstancedBuffersStorage) {
      for (var kind in this._userInstancedBuffersStorage.vertexBuffers) {
        kinds.push(kind);
      }
    }
    return kinds;
  };
  Mesh2.prototype.getTotalIndices = function() {
    if (!this._geometry) {
      return 0;
    }
    return this._geometry.getTotalIndices();
  };
  Mesh2.prototype.getIndices = function(copyWhenShared, forceCopy) {
    if (!this._geometry) {
      return [];
    }
    return this._geometry.getIndices(copyWhenShared, forceCopy);
  };
  Object.defineProperty(Mesh2.prototype, "isBlocked", {
    get: function() {
      return this._masterMesh !== null && this._masterMesh !== void 0;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.isReady = function(completeCheck, forceInstanceSupport) {
    var _a, _b, _c, _d, _e, _f;
    if (completeCheck === void 0) {
      completeCheck = false;
    }
    if (forceInstanceSupport === void 0) {
      forceInstanceSupport = false;
    }
    if (this.delayLoadState === 2) {
      return false;
    }
    if (!_super.prototype.isReady.call(this, completeCheck)) {
      return false;
    }
    if (!this.subMeshes || this.subMeshes.length === 0) {
      return true;
    }
    if (!completeCheck) {
      return true;
    }
    var engine = this.getEngine();
    var scene = this.getScene();
    var hardwareInstancedRendering = forceInstanceSupport || engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);
    this.computeWorldMatrix();
    var mat = this.material || scene.defaultMaterial;
    if (mat) {
      if (mat._storeEffectOnSubMeshes) {
        for (var _i = 0, _g = this.subMeshes; _i < _g.length; _i++) {
          var subMesh = _g[_i];
          var effectiveMaterial = subMesh.getMaterial();
          if (effectiveMaterial) {
            if (effectiveMaterial._storeEffectOnSubMeshes) {
              if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
                return false;
              }
            } else {
              if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {
                return false;
              }
            }
          }
        }
      } else {
        if (!mat.isReady(this, hardwareInstancedRendering)) {
          return false;
        }
      }
    }
    var currentRenderPassId = engine.currentRenderPassId;
    for (var _h = 0, _j = this.lightSources; _h < _j.length; _h++) {
      var light = _j[_h];
      var generator = light.getShadowGenerator();
      if (generator && (!((_a = generator.getShadowMap()) === null || _a === void 0 ? void 0 : _a.renderList) || ((_b = generator.getShadowMap()) === null || _b === void 0 ? void 0 : _b.renderList) && ((_d = (_c = generator.getShadowMap()) === null || _c === void 0 ? void 0 : _c.renderList) === null || _d === void 0 ? void 0 : _d.indexOf(this)) !== -1)) {
        if (generator.getShadowMap()) {
          engine.currentRenderPassId = generator.getShadowMap().renderPassId;
        }
        for (var _k = 0, _l = this.subMeshes; _k < _l.length; _k++) {
          var subMesh = _l[_k];
          if (!generator.isReady(subMesh, hardwareInstancedRendering, (_f = (_e = subMesh.getMaterial()) === null || _e === void 0 ? void 0 : _e.needAlphaBlendingForMesh(this)) !== null && _f !== void 0 ? _f : false)) {
            engine.currentRenderPassId = currentRenderPassId;
            return false;
          }
        }
        engine.currentRenderPassId = currentRenderPassId;
      }
    }
    for (var _m = 0, _o = this._internalMeshDataInfo._LODLevels; _m < _o.length; _m++) {
      var lod = _o[_m];
      if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {
        return false;
      }
    }
    return true;
  };
  Object.defineProperty(Mesh2.prototype, "areNormalsFrozen", {
    get: function() {
      return this._internalMeshDataInfo._areNormalsFrozen;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.freezeNormals = function() {
    this._internalMeshDataInfo._areNormalsFrozen = true;
    return this;
  };
  Mesh2.prototype.unfreezeNormals = function() {
    this._internalMeshDataInfo._areNormalsFrozen = false;
    return this;
  };
  Object.defineProperty(Mesh2.prototype, "overridenInstanceCount", {
    set: function(count) {
      this._instanceDataStorage.overridenInstanceCount = count;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype._preActivate = function() {
    var internalDataInfo = this._internalMeshDataInfo;
    var sceneRenderId = this.getScene().getRenderId();
    if (internalDataInfo._preActivateId === sceneRenderId) {
      return this;
    }
    internalDataInfo._preActivateId = sceneRenderId;
    this._instanceDataStorage.visibleInstances = null;
    return this;
  };
  Mesh2.prototype._preActivateForIntermediateRendering = function(renderId) {
    if (this._instanceDataStorage.visibleInstances) {
      this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;
    }
    return this;
  };
  Mesh2.prototype._registerInstanceForRenderId = function(instance, renderId) {
    if (!this._instanceDataStorage.visibleInstances) {
      this._instanceDataStorage.visibleInstances = {
        defaultRenderId: renderId,
        selfDefaultRenderId: this._renderId
      };
    }
    if (!this._instanceDataStorage.visibleInstances[renderId]) {
      if (this._instanceDataStorage.previousRenderId !== void 0 && this._instanceDataStorage.isFrozen) {
        this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;
      }
      this._instanceDataStorage.previousRenderId = renderId;
      this._instanceDataStorage.visibleInstances[renderId] = new Array();
    }
    this._instanceDataStorage.visibleInstances[renderId].push(instance);
    return this;
  };
  Mesh2.prototype._afterComputeWorldMatrix = function() {
    _super.prototype._afterComputeWorldMatrix.call(this);
    if (!this.hasThinInstances) {
      return;
    }
    if (!this.doNotSyncBoundingInfo) {
      this.thinInstanceRefreshBoundingInfo(false);
    }
  };
  Mesh2.prototype._postActivate = function() {
    if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {
      this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);
      this.edgesRenderer.customInstances.push(this.getWorldMatrix());
    }
  };
  Mesh2.prototype.refreshBoundingInfo = function(applySkeleton, applyMorph) {
    if (applySkeleton === void 0) {
      applySkeleton = false;
    }
    if (applyMorph === void 0) {
      applyMorph = false;
    }
    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
      return this;
    }
    var bias = this.geometry ? this.geometry.boundingBias : null;
    this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), bias);
    return this;
  };
  Mesh2.prototype._createGlobalSubMesh = function(force) {
    var totalVertices = this.getTotalVertices();
    if (!totalVertices || !this.getIndices()) {
      return null;
    }
    if (this.subMeshes && this.subMeshes.length > 0) {
      var ib = this.getIndices();
      if (!ib) {
        return null;
      }
      var totalIndices = ib.length;
      var needToRecreate = false;
      if (force) {
        needToRecreate = true;
      } else {
        for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {
          var submesh = _a[_i];
          if (submesh.indexStart + submesh.indexCount > totalIndices) {
            needToRecreate = true;
            break;
          }
          if (submesh.verticesStart + submesh.verticesCount > totalVertices) {
            needToRecreate = true;
            break;
          }
        }
      }
      if (!needToRecreate) {
        return this.subMeshes[0];
      }
    }
    this.releaseSubMeshes();
    return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);
  };
  Mesh2.prototype.subdivide = function(count) {
    if (count < 1) {
      return;
    }
    var totalIndices = this.getTotalIndices();
    var subdivisionSize = totalIndices / count | 0;
    var offset = 0;
    while (subdivisionSize % 3 !== 0) {
      subdivisionSize++;
    }
    this.releaseSubMeshes();
    for (var index = 0; index < count; index++) {
      if (offset >= totalIndices) {
        break;
      }
      SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this);
      offset += subdivisionSize;
    }
    this.synchronizeInstances();
  };
  Mesh2.prototype.setVerticesData = function(kind, data, updatable, stride) {
    if (updatable === void 0) {
      updatable = false;
    }
    if (!this._geometry) {
      var vertexData = new VertexData();
      vertexData.set(data, kind);
      var scene = this.getScene();
      new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);
    } else {
      this._geometry.setVerticesData(kind, data, updatable, stride);
    }
    return this;
  };
  Mesh2.prototype.removeVerticesData = function(kind) {
    if (!this._geometry) {
      return;
    }
    this._geometry.removeVerticesData(kind);
  };
  Mesh2.prototype.markVerticesDataAsUpdatable = function(kind, updatable) {
    if (updatable === void 0) {
      updatable = true;
    }
    var vb = this.getVertexBuffer(kind);
    if (!vb || vb.isUpdatable() === updatable) {
      return;
    }
    this.setVerticesData(kind, this.getVerticesData(kind), updatable);
  };
  Mesh2.prototype.setVerticesBuffer = function(buffer, disposeExistingBuffer) {
    if (disposeExistingBuffer === void 0) {
      disposeExistingBuffer = true;
    }
    if (!this._geometry) {
      this._geometry = Geometry.CreateGeometryForMesh(this);
    }
    this._geometry.setVerticesBuffer(buffer, null, disposeExistingBuffer);
    return this;
  };
  Mesh2.prototype.updateVerticesData = function(kind, data, updateExtends, makeItUnique) {
    if (!this._geometry) {
      return this;
    }
    if (!makeItUnique) {
      this._geometry.updateVerticesData(kind, data, updateExtends);
    } else {
      this.makeGeometryUnique();
      this.updateVerticesData(kind, data, updateExtends, false);
    }
    return this;
  };
  Mesh2.prototype.updateMeshPositions = function(positionFunction, computeNormals) {
    if (computeNormals === void 0) {
      computeNormals = true;
    }
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positions) {
      return this;
    }
    positionFunction(positions);
    this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
    if (computeNormals) {
      var indices = this.getIndices();
      var normals = this.getVerticesData(VertexBuffer.NormalKind);
      if (!normals) {
        return this;
      }
      VertexData.ComputeNormals(positions, indices, normals);
      this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);
    }
    return this;
  };
  Mesh2.prototype.makeGeometryUnique = function() {
    if (!this._geometry) {
      return this;
    }
    if (this._geometry.meshes.length === 1) {
      return this;
    }
    var oldGeometry = this._geometry;
    var geometry = this._geometry.copy(Geometry.RandomId());
    oldGeometry.releaseForMesh(this, true);
    geometry.applyToMesh(this);
    return this;
  };
  Mesh2.prototype.setIndices = function(indices, totalVertices, updatable) {
    if (totalVertices === void 0) {
      totalVertices = null;
    }
    if (updatable === void 0) {
      updatable = false;
    }
    if (!this._geometry) {
      var vertexData = new VertexData();
      vertexData.indices = indices;
      var scene = this.getScene();
      new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);
    } else {
      this._geometry.setIndices(indices, totalVertices, updatable);
    }
    return this;
  };
  Mesh2.prototype.updateIndices = function(indices, offset, gpuMemoryOnly) {
    if (gpuMemoryOnly === void 0) {
      gpuMemoryOnly = false;
    }
    if (!this._geometry) {
      return this;
    }
    this._geometry.updateIndices(indices, offset, gpuMemoryOnly);
    return this;
  };
  Mesh2.prototype.toLeftHanded = function() {
    if (!this._geometry) {
      return this;
    }
    this._geometry.toLeftHanded();
    return this;
  };
  Mesh2.prototype._bind = function(subMesh, effect, fillMode) {
    if (!this._geometry) {
      return this;
    }
    var engine = this.getScene().getEngine();
    if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets) {
      this.morphTargetManager._bind(effect);
    }
    var indexToBind;
    if (this._unIndexed) {
      indexToBind = null;
    } else {
      switch (fillMode) {
        case Material.PointFillMode:
          indexToBind = null;
          break;
        case Material.WireFrameFillMode:
          indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);
          break;
        default:
        case Material.TriangleFillMode:
          indexToBind = this._geometry.getIndexBuffer();
          break;
      }
    }
    if (!this._userInstancedBuffersStorage || this.hasThinInstances) {
      this._geometry._bind(effect, indexToBind);
    } else {
      this._geometry._bind(effect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);
    }
    return this;
  };
  Mesh2.prototype._draw = function(subMesh, fillMode, instancesCount) {
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    if (this._internalMeshDataInfo._onBeforeDrawObservable) {
      this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);
    }
    var scene = this.getScene();
    var engine = scene.getEngine();
    if (this._unIndexed || fillMode == Material.PointFillMode) {
      engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, this.forcedInstanceCount || instancesCount);
    } else if (fillMode == Material.WireFrameFillMode) {
      engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, this.forcedInstanceCount || instancesCount);
    } else {
      engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);
    }
    return this;
  };
  Mesh2.prototype.registerBeforeRender = function(func) {
    this.onBeforeRenderObservable.add(func);
    return this;
  };
  Mesh2.prototype.unregisterBeforeRender = function(func) {
    this.onBeforeRenderObservable.removeCallback(func);
    return this;
  };
  Mesh2.prototype.registerAfterRender = function(func) {
    this.onAfterRenderObservable.add(func);
    return this;
  };
  Mesh2.prototype.unregisterAfterRender = function(func) {
    this.onAfterRenderObservable.removeCallback(func);
    return this;
  };
  Mesh2.prototype._getInstancesRenderList = function(subMeshId, isReplacementMode) {
    if (isReplacementMode === void 0) {
      isReplacementMode = false;
    }
    if (this._instanceDataStorage.isFrozen) {
      if (isReplacementMode) {
        this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[subMeshId] = false;
        this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[subMeshId] = true;
        return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;
      }
      if (this._instanceDataStorage.previousBatch) {
        return this._instanceDataStorage.previousBatch;
      }
    }
    var scene = this.getScene();
    var isInIntermediateRendering = scene._isInIntermediateRendering();
    var onlyForInstances = isInIntermediateRendering ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances;
    var batchCache = this._instanceDataStorage.batchCache;
    batchCache.mustReturn = false;
    batchCache.renderSelf[subMeshId] = isReplacementMode || !onlyForInstances && this.isEnabled() && this.isVisible;
    batchCache.visibleInstances[subMeshId] = null;
    if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {
      var visibleInstances = this._instanceDataStorage.visibleInstances;
      var currentRenderId = scene.getRenderId();
      var defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;
      batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];
      if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {
        batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];
      }
    }
    batchCache.hardwareInstancedRendering[subMeshId] = !isReplacementMode && this._instanceDataStorage.hardwareInstancedRendering && batchCache.visibleInstances[subMeshId] !== null && batchCache.visibleInstances[subMeshId] !== void 0;
    this._instanceDataStorage.previousBatch = batchCache;
    return batchCache;
  };
  Mesh2.prototype._renderWithInstances = function(subMesh, fillMode, batch, effect, engine) {
    var _a;
    var visibleInstances = batch.visibleInstances[subMesh._id];
    if (!visibleInstances) {
      return this;
    }
    var instanceStorage = this._instanceDataStorage;
    var currentInstancesBufferSize = instanceStorage.instancesBufferSize;
    var instancesBuffer = instanceStorage.instancesBuffer;
    var instancesPreviousBuffer = instanceStorage.instancesPreviousBuffer;
    var matricesCount = visibleInstances.length + 1;
    var bufferSize = matricesCount * 16 * 4;
    while (instanceStorage.instancesBufferSize < bufferSize) {
      instanceStorage.instancesBufferSize *= 2;
    }
    if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {
      instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);
    }
    if (this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {
      instanceStorage.instancesPreviousData = new Float32Array(instanceStorage.instancesBufferSize / 4);
    }
    var offset = 0;
    var instancesCount = 0;
    var renderSelf = batch.renderSelf[subMesh._id];
    var needUpdateBuffer = !instancesBuffer || currentInstancesBufferSize !== instanceStorage.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousBuffer;
    if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {
      var world = this.getWorldMatrix();
      if (renderSelf) {
        if (this._scene.needsPreviousWorldMatrices) {
          if (!instanceStorage.masterMeshPreviousWorldMatrix) {
            instanceStorage.masterMeshPreviousWorldMatrix = world.clone();
            instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
          } else {
            instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
            instanceStorage.masterMeshPreviousWorldMatrix.copyFrom(world);
          }
        }
        world.copyToArray(instanceStorage.instancesData, offset);
        offset += 16;
        instancesCount++;
      }
      if (visibleInstances) {
        if (Mesh2.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMesh.getRenderingMesh()))) {
          var cameraPosition = this._scene.activeCamera.globalPosition;
          for (var instanceIndex_1 = 0; instanceIndex_1 < visibleInstances.length; instanceIndex_1++) {
            var instanceMesh = visibleInstances[instanceIndex_1];
            instanceMesh._distanceToCamera = Vector3.Distance(instanceMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);
          }
          visibleInstances.sort(function(m1, m2) {
            return m1._distanceToCamera > m2._distanceToCamera ? -1 : m1._distanceToCamera < m2._distanceToCamera ? 1 : 0;
          });
        }
        for (var instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {
          var instance = visibleInstances[instanceIndex];
          var matrix = instance.getWorldMatrix();
          matrix.copyToArray(instanceStorage.instancesData, offset);
          if (this._scene.needsPreviousWorldMatrices) {
            if (!instance._previousWorldMatrix) {
              instance._previousWorldMatrix = matrix.clone();
              instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
            } else {
              instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
              instance._previousWorldMatrix.copyFrom(matrix);
            }
          }
          offset += 16;
          instancesCount++;
        }
      }
    } else {
      instancesCount = (renderSelf ? 1 : 0) + visibleInstances.length;
    }
    if (needUpdateBuffer) {
      if (instancesBuffer) {
        instancesBuffer.dispose();
      }
      if (instancesPreviousBuffer) {
        instancesPreviousBuffer.dispose();
      }
      instancesBuffer = new Buffer2(engine, instanceStorage.instancesData, true, 16, false, true);
      instanceStorage.instancesBuffer = instancesBuffer;
      if (!this._userInstancedBuffersStorage) {
        this._userInstancedBuffersStorage = {
          data: {},
          vertexBuffers: {},
          strides: {},
          sizes: {},
          vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
        };
      }
      this._userInstancedBuffersStorage.vertexBuffers["world0"] = instancesBuffer.createVertexBuffer("world0", 0, 4);
      this._userInstancedBuffersStorage.vertexBuffers["world1"] = instancesBuffer.createVertexBuffer("world1", 4, 4);
      this._userInstancedBuffersStorage.vertexBuffers["world2"] = instancesBuffer.createVertexBuffer("world2", 8, 4);
      this._userInstancedBuffersStorage.vertexBuffers["world3"] = instancesBuffer.createVertexBuffer("world3", 12, 4);
      if (this._scene.needsPreviousWorldMatrices) {
        instancesPreviousBuffer = new Buffer2(engine, instanceStorage.instancesPreviousData, true, 16, false, true);
        instanceStorage.instancesPreviousBuffer = instancesPreviousBuffer;
        this._userInstancedBuffersStorage.vertexBuffers["previousWorld0"] = instancesPreviousBuffer.createVertexBuffer("previousWorld0", 0, 4);
        this._userInstancedBuffersStorage.vertexBuffers["previousWorld1"] = instancesPreviousBuffer.createVertexBuffer("previousWorld1", 4, 4);
        this._userInstancedBuffersStorage.vertexBuffers["previousWorld2"] = instancesPreviousBuffer.createVertexBuffer("previousWorld2", 8, 4);
        this._userInstancedBuffersStorage.vertexBuffers["previousWorld3"] = instancesPreviousBuffer.createVertexBuffer("previousWorld3", 12, 4);
      }
      this._invalidateInstanceVertexArrayObject();
    } else {
      if (!this._instanceDataStorage.isFrozen) {
        instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);
        if (this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate)) {
          instancesPreviousBuffer.updateDirectly(instanceStorage.instancesPreviousData, 0, instancesCount);
        }
      }
    }
    this._processInstancedBuffers(visibleInstances, renderSelf);
    this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
    if (engine._currentDrawContext) {
      engine._currentDrawContext.useInstancing = true;
    }
    this._bind(subMesh, effect, fillMode);
    this._draw(subMesh, fillMode, instancesCount);
    if (this._scene.needsPreviousWorldMatrices && !needUpdateBuffer && this._instanceDataStorage.manualUpdate && !this._instanceDataStorage.isFrozen && !this._instanceDataStorage.previousManualUpdate) {
      instancesPreviousBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);
    }
    engine.unbindInstanceAttributes();
    return this;
  };
  Mesh2.prototype._renderWithThinInstances = function(subMesh, fillMode, effect, engine) {
    var _a, _b;
    var instancesCount = (_b = (_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.instancesCount) !== null && _b !== void 0 ? _b : 0;
    this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
    if (engine._currentDrawContext) {
      engine._currentDrawContext.useInstancing = true;
    }
    this._bind(subMesh, effect, fillMode);
    this._draw(subMesh, fillMode, instancesCount);
    if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData) {
      if (!this._thinInstanceDataStorage.previousMatrixBuffer) {
        this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.matrixData, false);
      } else {
        this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, instancesCount);
      }
    }
    engine.unbindInstanceAttributes();
  };
  Mesh2.prototype._processInstancedBuffers = function(visibleInstances, renderSelf) {
  };
  Mesh2.prototype._processRendering = function(renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {
    var scene = this.getScene();
    var engine = scene.getEngine();
    if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {
      this._renderWithThinInstances(subMesh, fillMode, effect, engine);
      return this;
    }
    if (hardwareInstancedRendering) {
      this._renderWithInstances(subMesh, fillMode, batch, effect, engine);
    } else {
      if (engine._currentDrawContext) {
        engine._currentDrawContext.useInstancing = false;
      }
      var instanceCount = 0;
      if (batch.renderSelf[subMesh._id]) {
        if (onBeforeDraw) {
          onBeforeDraw(false, renderingMesh.getWorldMatrix(), effectiveMaterial);
        }
        instanceCount++;
        this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);
      }
      var visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];
      if (visibleInstancesForSubMesh) {
        var visibleInstanceCount = visibleInstancesForSubMesh.length;
        instanceCount += visibleInstanceCount;
        for (var instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {
          var instance = visibleInstancesForSubMesh[instanceIndex];
          var world = instance.getWorldMatrix();
          if (onBeforeDraw) {
            onBeforeDraw(true, world, effectiveMaterial);
          }
          this._draw(subMesh, fillMode);
        }
      }
      scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);
    }
    return this;
  };
  Mesh2.prototype._rebuild = function(dispose) {
    if (dispose === void 0) {
      dispose = false;
    }
    if (this._instanceDataStorage.instancesBuffer) {
      if (dispose) {
        this._instanceDataStorage.instancesBuffer.dispose();
      }
      this._instanceDataStorage.instancesBuffer = null;
    }
    if (this._userInstancedBuffersStorage) {
      for (var kind in this._userInstancedBuffersStorage.vertexBuffers) {
        var buffer = this._userInstancedBuffersStorage.vertexBuffers[kind];
        if (buffer) {
          if (dispose) {
            buffer.dispose();
          }
          this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
        }
      }
      if (this._userInstancedBuffersStorage.vertexArrayObjects) {
        this._userInstancedBuffersStorage.vertexArrayObjects = {};
      }
    }
    this._internalMeshDataInfo._effectiveMaterial = null;
    _super.prototype._rebuild.call(this, dispose);
  };
  Mesh2.prototype._freeze = function() {
    if (!this.subMeshes) {
      return;
    }
    for (var index = 0; index < this.subMeshes.length; index++) {
      this._getInstancesRenderList(index);
    }
    this._internalMeshDataInfo._effectiveMaterial = null;
    this._instanceDataStorage.isFrozen = true;
  };
  Mesh2.prototype._unFreeze = function() {
    this._instanceDataStorage.isFrozen = false;
    this._instanceDataStorage.previousBatch = null;
  };
  Mesh2.prototype.render = function(subMesh, enableAlphaMode, effectiveMeshReplacement) {
    var _a, _b, _c;
    var scene = this.getScene();
    if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {
      this._internalAbstractMeshDataInfo._isActiveIntermediate = false;
    } else {
      this._internalAbstractMeshDataInfo._isActive = false;
    }
    if (this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) {
      return this;
    }
    var batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);
    if (batch.mustReturn) {
      return this;
    }
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    var engine = scene.getEngine();
    var oldCameraMaxZ = 0;
    var oldCamera = null;
    if (this.ignoreCameraMaxZ && scene.activeCamera && !scene._isInIntermediateRendering()) {
      oldCameraMaxZ = scene.activeCamera.maxZ;
      oldCamera = scene.activeCamera;
      scene.activeCamera.maxZ = 0;
      scene.updateTransformMatrix(true);
    }
    if (this._internalMeshDataInfo._onBeforeRenderObservable) {
      this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);
    }
    var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || subMesh.getRenderingMesh().hasThinInstances;
    var instanceDataStorage = this._instanceDataStorage;
    var material = subMesh.getMaterial();
    if (!material) {
      if (oldCamera) {
        oldCamera.maxZ = oldCameraMaxZ;
        scene.updateTransformMatrix(true);
      }
      return this;
    }
    if (!instanceDataStorage.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== material) {
      if (material._storeEffectOnSubMeshes) {
        if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
          if (oldCamera) {
            oldCamera.maxZ = oldCameraMaxZ;
            scene.updateTransformMatrix(true);
          }
          return this;
        }
      } else if (!material.isReady(this, hardwareInstancedRendering)) {
        if (oldCamera) {
          oldCamera.maxZ = oldCameraMaxZ;
          scene.updateTransformMatrix(true);
        }
        return this;
      }
      this._internalMeshDataInfo._effectiveMaterial = material;
    } else if (material._storeEffectOnSubMeshes && !((_a = subMesh.effect) === null || _a === void 0 ? void 0 : _a._wasPreviouslyReady) || !material._storeEffectOnSubMeshes && !((_b = material.getEffect()) === null || _b === void 0 ? void 0 : _b._wasPreviouslyReady)) {
      if (oldCamera) {
        oldCamera.maxZ = oldCameraMaxZ;
        scene.updateTransformMatrix(true);
      }
      return this;
    }
    if (enableAlphaMode) {
      engine.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);
    }
    var drawWrapper;
    if (this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes) {
      drawWrapper = subMesh._drawWrapper;
    } else {
      drawWrapper = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();
    }
    var effect = (_c = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _c !== void 0 ? _c : null;
    for (var _i = 0, _d = scene._beforeRenderingMeshStage; _i < _d.length; _i++) {
      var step = _d[_i];
      step.action(this, subMesh, batch, effect);
    }
    if (!drawWrapper || !effect) {
      if (oldCamera) {
        oldCamera.maxZ = oldCameraMaxZ;
        scene.updateTransformMatrix(true);
      }
      return this;
    }
    var effectiveMesh = effectiveMeshReplacement || this;
    var sideOrientation;
    if (!instanceDataStorage.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {
      var mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();
      sideOrientation = this.overrideMaterialSideOrientation;
      if (sideOrientation == null) {
        sideOrientation = this._internalMeshDataInfo._effectiveMaterial.sideOrientation;
      }
      if (mainDeterminant < 0) {
        sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
      }
      instanceDataStorage.sideOrientation = sideOrientation;
    } else {
      sideOrientation = instanceDataStorage.sideOrientation;
    }
    var reverse = this._internalMeshDataInfo._effectiveMaterial._preBind(drawWrapper, sideOrientation);
    if (this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite) {
      engine.setDepthWrite(true);
    }
    var fillMode = scene.forcePointsCloud ? Material.PointFillMode : scene.forceWireframe ? Material.WireFrameFillMode : this._internalMeshDataInfo._effectiveMaterial.fillMode;
    if (this._internalMeshDataInfo._onBeforeBindObservable) {
      this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);
    }
    if (!hardwareInstancedRendering) {
      this._bind(subMesh, effect, fillMode);
    }
    var effectiveMaterial = this._internalMeshDataInfo._effectiveMaterial;
    var world = effectiveMesh.getWorldMatrix();
    if (effectiveMaterial._storeEffectOnSubMeshes) {
      effectiveMaterial.bindForSubMesh(world, this, subMesh);
    } else {
      effectiveMaterial.bind(world, this);
    }
    if (!effectiveMaterial.backFaceCulling && effectiveMaterial.separateCullingPass) {
      engine.setState(true, effectiveMaterial.zOffset, false, !reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);
      this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);
      engine.setState(true, effectiveMaterial.zOffset, false, reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);
      if (this._internalMeshDataInfo._onBetweenPassObservable) {
        this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(subMesh);
      }
    }
    this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);
    this._internalMeshDataInfo._effectiveMaterial.unbind();
    for (var _e = 0, _f = scene._afterRenderingMeshStage; _e < _f.length; _e++) {
      var step = _f[_e];
      step.action(this, subMesh, batch, effect);
    }
    if (this._internalMeshDataInfo._onAfterRenderObservable) {
      this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);
    }
    if (oldCamera) {
      oldCamera.maxZ = oldCameraMaxZ;
      scene.updateTransformMatrix(true);
    }
    return this;
  };
  Mesh2.prototype.cleanMatrixWeights = function() {
    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
        this.normalizeSkinWeightsAndExtra();
      } else {
        this.normalizeSkinFourWeights();
      }
    }
  };
  Mesh2.prototype.normalizeSkinFourWeights = function() {
    var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    var numWeights = matricesWeights.length;
    for (var a = 0; a < numWeights; a += 4) {
      var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
      if (t === 0) {
        matricesWeights[a] = 1;
      } else {
        var recip = 1 / t;
        matricesWeights[a] *= recip;
        matricesWeights[a + 1] *= recip;
        matricesWeights[a + 2] *= recip;
        matricesWeights[a + 3] *= recip;
      }
    }
    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
  };
  Mesh2.prototype.normalizeSkinWeightsAndExtra = function() {
    var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
    var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    var numWeights = matricesWeights.length;
    for (var a = 0; a < numWeights; a += 4) {
      var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
      t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];
      if (t === 0) {
        matricesWeights[a] = 1;
      } else {
        var recip = 1 / t;
        matricesWeights[a] *= recip;
        matricesWeights[a + 1] *= recip;
        matricesWeights[a + 2] *= recip;
        matricesWeights[a + 3] *= recip;
        matricesWeightsExtra[a] *= recip;
        matricesWeightsExtra[a + 1] *= recip;
        matricesWeightsExtra[a + 2] *= recip;
        matricesWeightsExtra[a + 3] *= recip;
      }
    }
    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);
  };
  Mesh2.prototype.validateSkinning = function() {
    var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
    var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    if (matricesWeights === null || this.skeleton == null) {
      return { skinned: false, valid: true, report: "not skinned" };
    }
    var numWeights = matricesWeights.length;
    var numberNotSorted = 0;
    var missingWeights = 0;
    var maxUsedWeights = 0;
    var numberNotNormalized = 0;
    var numInfluences = matricesWeightsExtra === null ? 4 : 8;
    var usedWeightCounts = new Array();
    for (var a = 0; a <= numInfluences; a++) {
      usedWeightCounts[a] = 0;
    }
    var toleranceEpsilon = 1e-3;
    for (var a = 0; a < numWeights; a += 4) {
      var lastWeight = matricesWeights[a];
      var t = lastWeight;
      var usedWeights = t === 0 ? 0 : 1;
      for (var b = 1; b < numInfluences; b++) {
        var d = b < 4 ? matricesWeights[a + b] : matricesWeightsExtra[a + b - 4];
        if (d > lastWeight) {
          numberNotSorted++;
        }
        if (d !== 0) {
          usedWeights++;
        }
        t += d;
        lastWeight = d;
      }
      usedWeightCounts[usedWeights]++;
      if (usedWeights > maxUsedWeights) {
        maxUsedWeights = usedWeights;
      }
      if (t === 0) {
        missingWeights++;
      } else {
        var recip = 1 / t;
        var tolerance = 0;
        for (b = 0; b < numInfluences; b++) {
          if (b < 4) {
            tolerance += Math.abs(matricesWeights[a + b] - matricesWeights[a + b] * recip);
          } else {
            tolerance += Math.abs(matricesWeightsExtra[a + b - 4] - matricesWeightsExtra[a + b - 4] * recip);
          }
        }
        if (tolerance > toleranceEpsilon) {
          numberNotNormalized++;
        }
      }
    }
    var numBones = this.skeleton.bones.length;
    var matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
    var matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
    var numBadBoneIndices = 0;
    for (var a = 0; a < numWeights; a += 4) {
      for (var b = 0; b < numInfluences; b++) {
        var index = b < 4 ? matricesIndices[a + b] : matricesIndicesExtra[a + b - 4];
        if (index >= numBones || index < 0) {
          numBadBoneIndices++;
        }
      }
    }
    var output = "Number of Weights = " + numWeights / 4 + "\nMaximum influences = " + maxUsedWeights + "\nMissing Weights = " + missingWeights + "\nNot Sorted = " + numberNotSorted + "\nNot Normalized = " + numberNotNormalized + "\nWeightCounts = [" + usedWeightCounts + "]\nNumber of bones = " + numBones + "\nBad Bone Indices = " + numBadBoneIndices;
    return { skinned: true, valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0, report: output };
  };
  Mesh2.prototype._checkDelayState = function() {
    var scene = this.getScene();
    if (this._geometry) {
      this._geometry.load(scene);
    } else if (this.delayLoadState === 4) {
      this.delayLoadState = 2;
      this._queueLoad(scene);
    }
    return this;
  };
  Mesh2.prototype._queueLoad = function(scene) {
    var _this = this;
    scene._addPendingData(this);
    var getBinaryData = this.delayLoadingFile.indexOf(".babylonbinarymeshdata") !== -1;
    Tools.LoadFile(this.delayLoadingFile, function(data) {
      if (data instanceof ArrayBuffer) {
        _this._delayLoadingFunction(data, _this);
      } else {
        _this._delayLoadingFunction(JSON.parse(data), _this);
      }
      _this.instances.forEach(function(instance) {
        instance.refreshBoundingInfo();
        instance._syncSubMeshes();
      });
      _this.delayLoadState = 1;
      scene._removePendingData(_this);
    }, function() {
    }, scene.offlineProvider, getBinaryData);
    return this;
  };
  Mesh2.prototype.isInFrustum = function(frustumPlanes) {
    if (this.delayLoadState === 2) {
      return false;
    }
    if (!_super.prototype.isInFrustum.call(this, frustumPlanes)) {
      return false;
    }
    this._checkDelayState();
    return true;
  };
  Mesh2.prototype.setMaterialById = function(id) {
    var materials = this.getScene().materials;
    var index;
    for (index = materials.length - 1; index > -1; index--) {
      if (materials[index].id === id) {
        this.material = materials[index];
        return this;
      }
    }
    var multiMaterials = this.getScene().multiMaterials;
    for (index = multiMaterials.length - 1; index > -1; index--) {
      if (multiMaterials[index].id === id) {
        this.material = multiMaterials[index];
        return this;
      }
    }
    return this;
  };
  Mesh2.prototype.getAnimatables = function() {
    var results = new Array();
    if (this.material) {
      results.push(this.material);
    }
    if (this.skeleton) {
      results.push(this.skeleton);
    }
    return results;
  };
  Mesh2.prototype.bakeTransformIntoVertices = function(transform) {
    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      return this;
    }
    var submeshes = this.subMeshes.splice(0);
    this._resetPointsArrayCache();
    var data = this.getVerticesData(VertexBuffer.PositionKind);
    var temp = new Array();
    var index;
    for (index = 0; index < data.length; index += 3) {
      Vector3.TransformCoordinates(Vector3.FromArray(data, index), transform).toArray(temp, index);
    }
    this.setVerticesData(VertexBuffer.PositionKind, temp, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable());
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      data = this.getVerticesData(VertexBuffer.NormalKind);
      temp = [];
      for (index = 0; index < data.length; index += 3) {
        Vector3.TransformNormal(Vector3.FromArray(data, index), transform).normalize().toArray(temp, index);
      }
      this.setVerticesData(VertexBuffer.NormalKind, temp, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());
    }
    if (transform.determinant() < 0) {
      this.flipFaces();
    }
    this.releaseSubMeshes();
    this.subMeshes = submeshes;
    return this;
  };
  Mesh2.prototype.bakeCurrentTransformIntoVertices = function(bakeIndependenlyOfChildren) {
    if (bakeIndependenlyOfChildren === void 0) {
      bakeIndependenlyOfChildren = true;
    }
    this.bakeTransformIntoVertices(this.computeWorldMatrix(true));
    this.resetLocalMatrix(bakeIndependenlyOfChildren);
    return this;
  };
  Object.defineProperty(Mesh2.prototype, "_positions", {
    get: function() {
      if (this._internalAbstractMeshDataInfo._positions) {
        return this._internalAbstractMeshDataInfo._positions;
      }
      if (this._geometry) {
        return this._geometry._positions;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype._resetPointsArrayCache = function() {
    if (this._geometry) {
      this._geometry._resetPointsArrayCache();
    }
    return this;
  };
  Mesh2.prototype._generatePointsArray = function() {
    if (this._geometry) {
      return this._geometry._generatePointsArray();
    }
    return false;
  };
  Mesh2.prototype.clone = function(name2, newParent, doNotCloneChildren, clonePhysicsImpostor) {
    if (name2 === void 0) {
      name2 = "";
    }
    if (newParent === void 0) {
      newParent = null;
    }
    if (clonePhysicsImpostor === void 0) {
      clonePhysicsImpostor = true;
    }
    return new Mesh2(name2, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);
  };
  Mesh2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this.morphTargetManager = null;
    if (this._geometry) {
      this._geometry.releaseForMesh(this, true);
    }
    var internalDataInfo = this._internalMeshDataInfo;
    if (internalDataInfo._onBeforeDrawObservable) {
      internalDataInfo._onBeforeDrawObservable.clear();
    }
    if (internalDataInfo._onBeforeBindObservable) {
      internalDataInfo._onBeforeBindObservable.clear();
    }
    if (internalDataInfo._onBeforeRenderObservable) {
      internalDataInfo._onBeforeRenderObservable.clear();
    }
    if (internalDataInfo._onAfterRenderObservable) {
      internalDataInfo._onAfterRenderObservable.clear();
    }
    if (internalDataInfo._onBetweenPassObservable) {
      internalDataInfo._onBetweenPassObservable.clear();
    }
    if (this._scene.useClonedMeshMap) {
      if (internalDataInfo.meshMap) {
        for (var uniqueId in internalDataInfo.meshMap) {
          var mesh = internalDataInfo.meshMap[uniqueId];
          if (mesh) {
            mesh._internalMeshDataInfo._source = null;
            internalDataInfo.meshMap[uniqueId] = void 0;
          }
        }
      }
      if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {
        internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = void 0;
      }
    } else {
      var meshes = this.getScene().meshes;
      for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
        var abstractMesh = meshes_1[_i];
        var mesh = abstractMesh;
        if (mesh._internalMeshDataInfo && mesh._internalMeshDataInfo._source && mesh._internalMeshDataInfo._source === this) {
          mesh._internalMeshDataInfo._source = null;
        }
      }
    }
    internalDataInfo._source = null;
    this._disposeInstanceSpecificData();
    this._disposeThinInstanceSpecificData();
    if (this._internalMeshDataInfo._checkReadinessObserver) {
      this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);
    }
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  Mesh2.prototype._disposeInstanceSpecificData = function() {
  };
  Mesh2.prototype._disposeThinInstanceSpecificData = function() {
  };
  Mesh2.prototype._invalidateInstanceVertexArrayObject = function() {
  };
  Mesh2.prototype.applyDisplacementMap = function(url, minHeight, maxHeight, onSuccess, uvOffset, uvScale, forceUpdate) {
    var _this = this;
    if (forceUpdate === void 0) {
      forceUpdate = false;
    }
    var scene = this.getScene();
    var onload = function(img) {
      var heightMapWidth = img.width;
      var heightMapHeight = img.height;
      var canvas = _this.getEngine().createCanvas(heightMapWidth, heightMapHeight);
      var context = canvas.getContext("2d");
      context.drawImage(img, 0, 0);
      var buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;
      _this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);
      if (onSuccess) {
        onSuccess(_this);
      }
    };
    Tools.LoadImage(url, onload, function() {
    }, scene.offlineProvider);
    return this;
  };
  Mesh2.prototype.applyDisplacementMapFromBuffer = function(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate) {
    if (forceUpdate === void 0) {
      forceUpdate = false;
    }
    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {
      Logger.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing");
      return this;
    }
    var positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);
    var normals = this.getVerticesData(VertexBuffer.NormalKind);
    var uvs = this.getVerticesData(VertexBuffer.UVKind);
    var position = Vector3.Zero();
    var normal = Vector3.Zero();
    var uv = Vector2.Zero();
    uvOffset = uvOffset || Vector2.Zero();
    uvScale = uvScale || new Vector2(1, 1);
    for (var index = 0; index < positions.length; index += 3) {
      Vector3.FromArrayToRef(positions, index, position);
      Vector3.FromArrayToRef(normals, index, normal);
      Vector2.FromArrayToRef(uvs, index / 3 * 2, uv);
      var u = Math.abs(uv.x * uvScale.x + uvOffset.x % 1) * (heightMapWidth - 1) % heightMapWidth | 0;
      var v = Math.abs(uv.y * uvScale.y + uvOffset.y % 1) * (heightMapHeight - 1) % heightMapHeight | 0;
      var pos = (u + v * heightMapWidth) * 4;
      var r = buffer[pos] / 255;
      var g = buffer[pos + 1] / 255;
      var b = buffer[pos + 2] / 255;
      var gradient = r * 0.3 + g * 0.59 + b * 0.11;
      normal.normalize();
      normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);
      position = position.add(normal);
      position.toArray(positions, index);
    }
    VertexData.ComputeNormals(positions, this.getIndices(), normals);
    if (forceUpdate) {
      this.setVerticesData(VertexBuffer.PositionKind, positions);
      this.setVerticesData(VertexBuffer.NormalKind, normals);
      this.setVerticesData(VertexBuffer.UVKind, uvs);
    } else {
      this.updateVerticesData(VertexBuffer.PositionKind, positions);
      this.updateVerticesData(VertexBuffer.NormalKind, normals);
    }
    return this;
  };
  Mesh2.prototype.convertToFlatShadedMesh = function() {
    var kinds = this.getVerticesDataKinds();
    var vbs = {};
    var data = {};
    var newdata = {};
    var updatableNormals = false;
    var kindIndex;
    var kind;
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      var vertexBuffer = this.getVertexBuffer(kind);
      var vertexData = vertexBuffer.getData();
      if (vertexData instanceof Array || vertexData instanceof Float32Array) {
        if (vertexData.length === 0) {
          continue;
        }
      }
      if (kind === VertexBuffer.NormalKind) {
        updatableNormals = vertexBuffer.isUpdatable();
        kinds.splice(kindIndex, 1);
        kindIndex--;
        continue;
      }
      vbs[kind] = vertexBuffer;
      data[kind] = this.getVerticesData(kind);
      newdata[kind] = [];
    }
    var previousSubmeshes = this.subMeshes.slice(0);
    var indices = this.getIndices();
    var totalIndices = this.getTotalIndices();
    var index;
    for (index = 0; index < totalIndices; index++) {
      var vertexIndex = indices[index];
      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
        kind = kinds[kindIndex];
        if (!vbs[kind]) {
          continue;
        }
        var stride = vbs[kind].getStrideSize();
        for (var offset = 0; offset < stride; offset++) {
          newdata[kind].push(data[kind][vertexIndex * stride + offset]);
        }
      }
    }
    var normals = [];
    var positions = newdata[VertexBuffer.PositionKind];
    var useRightHandedSystem = this.getScene().useRightHandedSystem;
    var flipNormalGeneration;
    if (useRightHandedSystem) {
      flipNormalGeneration = this.overrideMaterialSideOrientation === 1;
    } else {
      flipNormalGeneration = this.overrideMaterialSideOrientation === 0;
    }
    for (index = 0; index < totalIndices; index += 3) {
      indices[index] = index;
      indices[index + 1] = index + 1;
      indices[index + 2] = index + 2;
      var p1 = Vector3.FromArray(positions, index * 3);
      var p2 = Vector3.FromArray(positions, (index + 1) * 3);
      var p3 = Vector3.FromArray(positions, (index + 2) * 3);
      var p1p2 = p1.subtract(p2);
      var p3p2 = p3.subtract(p2);
      var normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));
      if (flipNormalGeneration) {
        normal.scaleInPlace(-1);
      }
      for (var localIndex = 0; localIndex < 3; localIndex++) {
        normals.push(normal.x);
        normals.push(normal.y);
        normals.push(normal.z);
      }
    }
    this.setIndices(indices);
    this.setVerticesData(VertexBuffer.NormalKind, normals, updatableNormals);
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      if (!newdata[kind]) {
        continue;
      }
      this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());
    }
    this.releaseSubMeshes();
    for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {
      var previousOne = previousSubmeshes[submeshIndex];
      SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);
    }
    this.synchronizeInstances();
    return this;
  };
  Mesh2.prototype.convertToUnIndexedMesh = function() {
    var kinds = this.getVerticesDataKinds();
    var vbs = {};
    var data = {};
    var newdata = {};
    var kindIndex;
    var kind;
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      var vertexBuffer = this.getVertexBuffer(kind);
      vbs[kind] = vertexBuffer;
      data[kind] = vbs[kind].getData();
      newdata[kind] = [];
    }
    var previousSubmeshes = this.subMeshes.slice(0);
    var indices = this.getIndices();
    var totalIndices = this.getTotalIndices();
    var index;
    for (index = 0; index < totalIndices; index++) {
      var vertexIndex = indices[index];
      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
        kind = kinds[kindIndex];
        var stride = vbs[kind].getStrideSize();
        for (var offset = 0; offset < stride; offset++) {
          newdata[kind].push(data[kind][vertexIndex * stride + offset]);
        }
      }
    }
    for (index = 0; index < totalIndices; index += 3) {
      indices[index] = index;
      indices[index + 1] = index + 1;
      indices[index + 2] = index + 2;
    }
    this.setIndices(indices);
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());
    }
    this.releaseSubMeshes();
    for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {
      var previousOne = previousSubmeshes[submeshIndex];
      SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);
    }
    this._unIndexed = true;
    this.synchronizeInstances();
    return this;
  };
  Mesh2.prototype.flipFaces = function(flipNormals) {
    if (flipNormals === void 0) {
      flipNormals = false;
    }
    var vertex_data = VertexData.ExtractFromMesh(this);
    var i;
    if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {
      for (i = 0; i < vertex_data.normals.length; i++) {
        vertex_data.normals[i] *= -1;
      }
    }
    if (vertex_data.indices) {
      var temp;
      for (i = 0; i < vertex_data.indices.length; i += 3) {
        temp = vertex_data.indices[i + 1];
        vertex_data.indices[i + 1] = vertex_data.indices[i + 2];
        vertex_data.indices[i + 2] = temp;
      }
    }
    vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
    return this;
  };
  Mesh2.prototype.increaseVertices = function(numberPerEdge) {
    var vertex_data = VertexData.ExtractFromMesh(this);
    var uvs = vertex_data.uvs && !Array.isArray(vertex_data.uvs) && Array.from ? Array.from(vertex_data.uvs) : vertex_data.uvs;
    var currentIndices = vertex_data.indices && !Array.isArray(vertex_data.indices) && Array.from ? Array.from(vertex_data.indices) : vertex_data.indices;
    var positions = vertex_data.positions && !Array.isArray(vertex_data.positions) && Array.from ? Array.from(vertex_data.positions) : vertex_data.positions;
    var normals = vertex_data.normals && !Array.isArray(vertex_data.normals) && Array.from ? Array.from(vertex_data.normals) : vertex_data.normals;
    if (!currentIndices || !positions || !normals || !uvs) {
      Logger.Warn("VertexData contains null entries");
    } else {
      vertex_data.indices = currentIndices;
      vertex_data.positions = positions;
      vertex_data.normals = normals;
      vertex_data.uvs = uvs;
      var segments = numberPerEdge + 1;
      var tempIndices = new Array();
      for (var i = 0; i < segments + 1; i++) {
        tempIndices[i] = new Array();
      }
      var a;
      var b;
      var deltaPosition = new Vector3(0, 0, 0);
      var deltaNormal = new Vector3(0, 0, 0);
      var deltaUV = new Vector2(0, 0);
      var indices = new Array();
      var vertexIndex = new Array();
      var side = new Array();
      var len;
      var positionPtr = positions.length;
      var uvPtr = uvs.length;
      for (var i = 0; i < currentIndices.length; i += 3) {
        vertexIndex[0] = currentIndices[i];
        vertexIndex[1] = currentIndices[i + 1];
        vertexIndex[2] = currentIndices[i + 2];
        for (var j = 0; j < 3; j++) {
          a = vertexIndex[j];
          b = vertexIndex[(j + 1) % 3];
          if (side[a] === void 0 && side[b] === void 0) {
            side[a] = new Array();
            side[b] = new Array();
          } else {
            if (side[a] === void 0) {
              side[a] = new Array();
            }
            if (side[b] === void 0) {
              side[b] = new Array();
            }
          }
          if (side[a][b] === void 0 && side[b][a] === void 0) {
            side[a][b] = [];
            deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;
            deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;
            deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;
            deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;
            deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;
            deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;
            deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;
            deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;
            side[a][b].push(a);
            for (var k = 1; k < segments; k++) {
              side[a][b].push(positions.length / 3);
              positions[positionPtr] = positions[3 * a] + k * deltaPosition.x;
              normals[positionPtr++] = normals[3 * a] + k * deltaNormal.x;
              positions[positionPtr] = positions[3 * a + 1] + k * deltaPosition.y;
              normals[positionPtr++] = normals[3 * a + 1] + k * deltaNormal.y;
              positions[positionPtr] = positions[3 * a + 2] + k * deltaPosition.z;
              normals[positionPtr++] = normals[3 * a + 2] + k * deltaNormal.z;
              uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;
              uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;
            }
            side[a][b].push(b);
            side[b][a] = new Array();
            len = side[a][b].length;
            for (var idx = 0; idx < len; idx++) {
              side[b][a][idx] = side[a][b][len - 1 - idx];
            }
          }
        }
        tempIndices[0][0] = currentIndices[i];
        tempIndices[1][0] = side[currentIndices[i]][currentIndices[i + 1]][1];
        tempIndices[1][1] = side[currentIndices[i]][currentIndices[i + 2]][1];
        for (var k = 2; k < segments; k++) {
          tempIndices[k][0] = side[currentIndices[i]][currentIndices[i + 1]][k];
          tempIndices[k][k] = side[currentIndices[i]][currentIndices[i + 2]][k];
          deltaPosition.x = (positions[3 * tempIndices[k][k]] - positions[3 * tempIndices[k][0]]) / k;
          deltaPosition.y = (positions[3 * tempIndices[k][k] + 1] - positions[3 * tempIndices[k][0] + 1]) / k;
          deltaPosition.z = (positions[3 * tempIndices[k][k] + 2] - positions[3 * tempIndices[k][0] + 2]) / k;
          deltaNormal.x = (normals[3 * tempIndices[k][k]] - normals[3 * tempIndices[k][0]]) / k;
          deltaNormal.y = (normals[3 * tempIndices[k][k] + 1] - normals[3 * tempIndices[k][0] + 1]) / k;
          deltaNormal.z = (normals[3 * tempIndices[k][k] + 2] - normals[3 * tempIndices[k][0] + 2]) / k;
          deltaUV.x = (uvs[2 * tempIndices[k][k]] - uvs[2 * tempIndices[k][0]]) / k;
          deltaUV.y = (uvs[2 * tempIndices[k][k] + 1] - uvs[2 * tempIndices[k][0] + 1]) / k;
          for (var j = 1; j < k; j++) {
            tempIndices[k][j] = positions.length / 3;
            positions[positionPtr] = positions[3 * tempIndices[k][0]] + j * deltaPosition.x;
            normals[positionPtr++] = normals[3 * tempIndices[k][0]] + j * deltaNormal.x;
            positions[positionPtr] = positions[3 * tempIndices[k][0] + 1] + j * deltaPosition.y;
            normals[positionPtr++] = normals[3 * tempIndices[k][0] + 1] + j * deltaNormal.y;
            positions[positionPtr] = positions[3 * tempIndices[k][0] + 2] + j * deltaPosition.z;
            normals[positionPtr++] = normals[3 * tempIndices[k][0] + 2] + j * deltaNormal.z;
            uvs[uvPtr++] = uvs[2 * tempIndices[k][0]] + j * deltaUV.x;
            uvs[uvPtr++] = uvs[2 * tempIndices[k][0] + 1] + j * deltaUV.y;
          }
        }
        tempIndices[segments] = side[currentIndices[i + 1]][currentIndices[i + 2]];
        indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);
        for (var k = 1; k < segments; k++) {
          for (var j = 0; j < k; j++) {
            indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
            indices.push(tempIndices[k][j], tempIndices[k + 1][j + 1], tempIndices[k][j + 1]);
          }
          indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
        }
      }
      vertex_data.indices = indices;
      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
    }
  };
  Mesh2.prototype.forceSharedVertices = function() {
    var vertex_data = VertexData.ExtractFromMesh(this);
    var currentUVs = vertex_data.uvs;
    var currentIndices = vertex_data.indices;
    var currentPositions = vertex_data.positions;
    var currentColors = vertex_data.colors;
    if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {
      Logger.Warn("VertexData contains empty entries");
    } else {
      var positions = new Array();
      var indices = new Array();
      var uvs = new Array();
      var colors = new Array();
      var pstring = new Array();
      var indexPtr = 0;
      var uniquePositions = {};
      var ptr;
      var facet;
      for (var i = 0; i < currentIndices.length; i += 3) {
        facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]];
        pstring = new Array();
        for (var j = 0; j < 3; j++) {
          pstring[j] = "";
          for (var k = 0; k < 3; k++) {
            if (Math.abs(currentPositions[3 * facet[j] + k]) < 1e-8) {
              currentPositions[3 * facet[j] + k] = 0;
            }
            pstring[j] += currentPositions[3 * facet[j] + k] + "|";
          }
        }
        if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {
          for (var j = 0; j < 3; j++) {
            ptr = uniquePositions[pstring[j]];
            if (ptr === void 0) {
              uniquePositions[pstring[j]] = indexPtr;
              ptr = indexPtr++;
              for (var k = 0; k < 3; k++) {
                positions.push(currentPositions[3 * facet[j] + k]);
              }
              if (currentColors !== null && currentColors !== void 0) {
                for (var k = 0; k < 4; k++) {
                  colors.push(currentColors[4 * facet[j] + k]);
                }
              }
              if (currentUVs !== null && currentUVs !== void 0) {
                for (var k = 0; k < 2; k++) {
                  uvs.push(currentUVs[2 * facet[j] + k]);
                }
              }
            }
            indices.push(ptr);
          }
        }
      }
      var normals = new Array();
      VertexData.ComputeNormals(positions, indices, normals);
      vertex_data.positions = positions;
      vertex_data.indices = indices;
      vertex_data.normals = normals;
      if (currentUVs !== null && currentUVs !== void 0) {
        vertex_data.uvs = uvs;
      }
      if (currentColors !== null && currentColors !== void 0) {
        vertex_data.colors = colors;
      }
      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
    }
  };
  Mesh2._instancedMeshFactory = function(name2, mesh) {
    throw _WarnImport("InstancedMesh");
  };
  Mesh2._PhysicsImpostorParser = function(scene, physicObject, jsonObject) {
    throw _WarnImport("PhysicsImpostor");
  };
  Mesh2.prototype.createInstance = function(name2) {
    return Mesh2._instancedMeshFactory(name2, this);
  };
  Mesh2.prototype.synchronizeInstances = function() {
    for (var instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {
      var instance = this.instances[instanceIndex];
      instance._syncSubMeshes();
    }
    return this;
  };
  Mesh2.prototype.optimizeIndices = function(successCallback) {
    var _this = this;
    var indices = this.getIndices();
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positions || !indices) {
      return this;
    }
    var vectorPositions = new Array();
    for (var pos = 0; pos < positions.length; pos = pos + 3) {
      vectorPositions.push(Vector3.FromArray(positions, pos));
    }
    var dupes = new Array();
    AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, function(iteration) {
      var realPos = vectorPositions.length - 1 - iteration;
      var testedPosition = vectorPositions[realPos];
      for (var j = 0; j < realPos; ++j) {
        var againstPosition = vectorPositions[j];
        if (testedPosition.equals(againstPosition)) {
          dupes[realPos] = j;
          break;
        }
      }
    }, function() {
      for (var i = 0; i < indices.length; ++i) {
        indices[i] = dupes[indices[i]] || indices[i];
      }
      var originalSubMeshes = _this.subMeshes.slice(0);
      _this.setIndices(indices);
      _this.subMeshes = originalSubMeshes;
      if (successCallback) {
        successCallback(_this);
      }
    });
    return this;
  };
  Mesh2.prototype.serialize = function(serializationObject) {
    serializationObject.name = this.name;
    serializationObject.id = this.id;
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getClassName();
    if (Tags && Tags.HasTags(this)) {
      serializationObject.tags = Tags.GetTags(this);
    }
    serializationObject.position = this.position.asArray();
    if (this.rotationQuaternion) {
      serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();
    } else if (this.rotation) {
      serializationObject.rotation = this.rotation.asArray();
    }
    serializationObject.scaling = this.scaling.asArray();
    if (this._postMultiplyPivotMatrix) {
      serializationObject.pivotMatrix = this.getPivotMatrix().asArray();
    } else {
      serializationObject.localMatrix = this.getPivotMatrix().asArray();
    }
    serializationObject.isEnabled = this.isEnabled(false);
    serializationObject.isVisible = this.isVisible;
    serializationObject.infiniteDistance = this.infiniteDistance;
    serializationObject.pickable = this.isPickable;
    serializationObject.receiveShadows = this.receiveShadows;
    serializationObject.billboardMode = this.billboardMode;
    serializationObject.visibility = this.visibility;
    serializationObject.checkCollisions = this.checkCollisions;
    serializationObject.isBlocker = this.isBlocker;
    serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation;
    if (this.parent) {
      serializationObject.parentId = this.parent.uniqueId;
    }
    serializationObject.isUnIndexed = this.isUnIndexed;
    var geometry = this._geometry;
    if (geometry && this.subMeshes) {
      serializationObject.geometryUniqueId = geometry.uniqueId;
      serializationObject.geometryId = geometry.id;
      serializationObject.subMeshes = [];
      for (var subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {
        var subMesh = this.subMeshes[subIndex];
        serializationObject.subMeshes.push({
          materialIndex: subMesh.materialIndex,
          verticesStart: subMesh.verticesStart,
          verticesCount: subMesh.verticesCount,
          indexStart: subMesh.indexStart,
          indexCount: subMesh.indexCount
        });
      }
    }
    if (this.material) {
      if (!this.material.doNotSerialize) {
        serializationObject.materialUniqueId = this.material.uniqueId;
        serializationObject.materialId = this.material.id;
      }
    } else {
      this.material = null;
      serializationObject.materialUniqueId = this._scene.defaultMaterial.uniqueId;
      serializationObject.materialId = this._scene.defaultMaterial.id;
    }
    if (this.morphTargetManager) {
      serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;
    }
    if (this.skeleton) {
      serializationObject.skeletonId = this.skeleton.id;
      serializationObject.numBoneInfluencers = this.numBoneInfluencers;
    }
    if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
      var impostor = this.getPhysicsImpostor();
      if (impostor) {
        serializationObject.physicsMass = impostor.getParam("mass");
        serializationObject.physicsFriction = impostor.getParam("friction");
        serializationObject.physicsRestitution = impostor.getParam("mass");
        serializationObject.physicsImpostor = impostor.type;
      }
    }
    if (this.metadata) {
      serializationObject.metadata = this.metadata;
    }
    serializationObject.instances = [];
    for (var index = 0; index < this.instances.length; index++) {
      var instance = this.instances[index];
      if (instance.doNotSerialize) {
        continue;
      }
      var serializationInstance = {
        name: instance.name,
        id: instance.id,
        isEnabled: instance.isEnabled(false),
        isVisible: instance.isVisible,
        isPickable: instance.isPickable,
        checkCollisions: instance.checkCollisions,
        position: instance.position.asArray(),
        scaling: instance.scaling.asArray()
      };
      if (instance.parent) {
        serializationInstance.parentId = instance.parent.uniqueId;
      }
      if (instance.rotationQuaternion) {
        serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();
      } else if (instance.rotation) {
        serializationInstance.rotation = instance.rotation.asArray();
      }
      if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
        var impostor = instance.getPhysicsImpostor();
        if (impostor) {
          serializationInstance.physicsMass = impostor.getParam("mass");
          serializationInstance.physicsFriction = impostor.getParam("friction");
          serializationInstance.physicsRestitution = impostor.getParam("mass");
          serializationInstance.physicsImpostor = impostor.type;
        }
      }
      if (instance.metadata) {
        serializationInstance.metadata = instance.metadata;
      }
      serializationObject.instances.push(serializationInstance);
      SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);
      serializationInstance.ranges = instance.serializeAnimationRanges();
    }
    if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {
      serializationObject.thinInstances = {
        instancesCount: this._thinInstanceDataStorage.instancesCount,
        matrixData: Tools.SliceToArray(this._thinInstanceDataStorage.matrixData),
        matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,
        enablePicking: this.thinInstanceEnablePicking
      };
      if (this._userThinInstanceBuffersStorage) {
        var userThinInstance = {
          data: {},
          sizes: {},
          strides: {}
        };
        for (var kind in this._userThinInstanceBuffersStorage.data) {
          userThinInstance.data[kind] = Tools.SliceToArray(this._userThinInstanceBuffersStorage.data[kind]);
          userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];
          userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];
        }
        serializationObject.thinInstances.userThinInstance = userThinInstance;
      }
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.layerMask = this.layerMask;
    serializationObject.alphaIndex = this.alphaIndex;
    serializationObject.hasVertexAlpha = this.hasVertexAlpha;
    serializationObject.overlayAlpha = this.overlayAlpha;
    serializationObject.overlayColor = this.overlayColor.asArray();
    serializationObject.renderOverlay = this.renderOverlay;
    serializationObject.applyFog = this.applyFog;
    if (this.actionManager) {
      serializationObject.actions = this.actionManager.serialize(this.name);
    }
  };
  Mesh2.prototype._syncGeometryWithMorphTargetManager = function() {
    if (!this.geometry) {
      return;
    }
    this._markSubMeshesAsAttributesDirty();
    var morphTargetManager = this._internalAbstractMeshDataInfo._morphTargetManager;
    if (morphTargetManager && morphTargetManager.vertexCount) {
      if (morphTargetManager.vertexCount !== this.getTotalVertices()) {
        Logger.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.");
        this.morphTargetManager = null;
        return;
      }
      if (morphTargetManager.isUsingTextureForTargets) {
        return;
      }
      for (var index = 0; index < morphTargetManager.numInfluencers; index++) {
        var morphTarget = morphTargetManager.getActiveTarget(index);
        var positions = morphTarget.getPositions();
        if (!positions) {
          Logger.Error("Invalid morph target. Target must have positions.");
          return;
        }
        this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);
        var normals = morphTarget.getNormals();
        if (normals) {
          this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);
        }
        var tangents = morphTarget.getTangents();
        if (tangents) {
          this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);
        }
        var uvs = morphTarget.getUVs();
        if (uvs) {
          this.geometry.setVerticesData(VertexBuffer.UVKind + "_" + index, uvs, false, 2);
        }
      }
    } else {
      var index = 0;
      while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + index)) {
        this.geometry.removeVerticesData(VertexBuffer.PositionKind + index);
        if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + index)) {
          this.geometry.removeVerticesData(VertexBuffer.NormalKind + index);
        }
        if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + index)) {
          this.geometry.removeVerticesData(VertexBuffer.TangentKind + index);
        }
        if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + index)) {
          this.geometry.removeVerticesData(VertexBuffer.UVKind + "_" + index);
        }
        index++;
      }
    }
  };
  Mesh2.Parse = function(parsedMesh, scene, rootUrl) {
    var mesh;
    if (parsedMesh.type && parsedMesh.type === "LinesMesh") {
      mesh = Mesh2._LinesMeshParser(parsedMesh, scene);
    } else if (parsedMesh.type && parsedMesh.type === "GroundMesh") {
      mesh = Mesh2._GroundMeshParser(parsedMesh, scene);
    } else if (parsedMesh.type && parsedMesh.type === "GoldbergMesh") {
      mesh = Mesh2._GoldbergMeshParser(parsedMesh, scene);
    } else {
      mesh = new Mesh2(parsedMesh.name, scene);
    }
    mesh.id = parsedMesh.id;
    if (Tags) {
      Tags.AddTagsTo(mesh, parsedMesh.tags);
    }
    mesh.position = Vector3.FromArray(parsedMesh.position);
    if (parsedMesh.metadata !== void 0) {
      mesh.metadata = parsedMesh.metadata;
    }
    if (parsedMesh.rotationQuaternion) {
      mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);
    } else if (parsedMesh.rotation) {
      mesh.rotation = Vector3.FromArray(parsedMesh.rotation);
    }
    mesh.scaling = Vector3.FromArray(parsedMesh.scaling);
    if (parsedMesh.localMatrix) {
      mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));
    } else if (parsedMesh.pivotMatrix) {
      mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));
    }
    mesh.setEnabled(parsedMesh.isEnabled);
    mesh.isVisible = parsedMesh.isVisible;
    mesh.infiniteDistance = parsedMesh.infiniteDistance;
    mesh.showBoundingBox = parsedMesh.showBoundingBox;
    mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;
    if (parsedMesh.applyFog !== void 0) {
      mesh.applyFog = parsedMesh.applyFog;
    }
    if (parsedMesh.pickable !== void 0) {
      mesh.isPickable = parsedMesh.pickable;
    }
    if (parsedMesh.alphaIndex !== void 0) {
      mesh.alphaIndex = parsedMesh.alphaIndex;
    }
    mesh.receiveShadows = parsedMesh.receiveShadows;
    mesh.billboardMode = parsedMesh.billboardMode;
    if (parsedMesh.visibility !== void 0) {
      mesh.visibility = parsedMesh.visibility;
    }
    mesh.checkCollisions = parsedMesh.checkCollisions;
    mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;
    if (parsedMesh.isBlocker !== void 0) {
      mesh.isBlocker = parsedMesh.isBlocker;
    }
    mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;
    if (parsedMesh.freezeWorldMatrix) {
      mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;
    }
    if (parsedMesh.parentId !== void 0) {
      mesh._waitingParentId = parsedMesh.parentId;
    }
    if (parsedMesh.actions !== void 0) {
      mesh._waitingData.actions = parsedMesh.actions;
    }
    if (parsedMesh.overlayAlpha !== void 0) {
      mesh.overlayAlpha = parsedMesh.overlayAlpha;
    }
    if (parsedMesh.overlayColor !== void 0) {
      mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);
    }
    if (parsedMesh.renderOverlay !== void 0) {
      mesh.renderOverlay = parsedMesh.renderOverlay;
    }
    mesh.isUnIndexed = !!parsedMesh.isUnIndexed;
    mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;
    if (parsedMesh.delayLoadingFile) {
      mesh.delayLoadState = 4;
      mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;
      mesh.buildBoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));
      if (parsedMesh._binaryInfo) {
        mesh._binaryInfo = parsedMesh._binaryInfo;
      }
      mesh._delayInfo = [];
      if (parsedMesh.hasUVs) {
        mesh._delayInfo.push(VertexBuffer.UVKind);
      }
      if (parsedMesh.hasUVs2) {
        mesh._delayInfo.push(VertexBuffer.UV2Kind);
      }
      if (parsedMesh.hasUVs3) {
        mesh._delayInfo.push(VertexBuffer.UV3Kind);
      }
      if (parsedMesh.hasUVs4) {
        mesh._delayInfo.push(VertexBuffer.UV4Kind);
      }
      if (parsedMesh.hasUVs5) {
        mesh._delayInfo.push(VertexBuffer.UV5Kind);
      }
      if (parsedMesh.hasUVs6) {
        mesh._delayInfo.push(VertexBuffer.UV6Kind);
      }
      if (parsedMesh.hasColors) {
        mesh._delayInfo.push(VertexBuffer.ColorKind);
      }
      if (parsedMesh.hasMatricesIndices) {
        mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);
      }
      if (parsedMesh.hasMatricesWeights) {
        mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);
      }
      mesh._delayLoadingFunction = Geometry._ImportGeometry;
      if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {
        mesh._checkDelayState();
      }
    } else {
      Geometry._ImportGeometry(parsedMesh, mesh);
    }
    if (parsedMesh.materialUniqueId) {
      mesh._waitingMaterialId = parsedMesh.materialUniqueId;
    } else if (parsedMesh.materialId) {
      mesh._waitingMaterialId = parsedMesh.materialId;
    }
    if (parsedMesh.morphTargetManagerId > -1) {
      mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);
    }
    if (parsedMesh.skeletonId !== void 0 && parsedMesh.skeletonId !== null) {
      mesh.skeleton = scene.getLastSkeletonById(parsedMesh.skeletonId);
      if (parsedMesh.numBoneInfluencers) {
        mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;
      }
    }
    if (parsedMesh.animations) {
      for (var animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {
        var parsedAnimation = parsedMesh.animations[animationIndex];
        var internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          mesh.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(mesh, parsedMesh, scene);
    }
    if (parsedMesh.autoAnimate) {
      scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1);
    }
    if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {
      mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));
    } else {
      mesh.layerMask = 268435455;
    }
    if (parsedMesh.physicsImpostor) {
      Mesh2._PhysicsImpostorParser(scene, mesh, parsedMesh);
    }
    if (parsedMesh.lodMeshIds) {
      mesh._waitingData.lods = {
        ids: parsedMesh.lodMeshIds,
        distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,
        coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null
      };
    }
    if (parsedMesh.instances) {
      for (var index = 0; index < parsedMesh.instances.length; index++) {
        var parsedInstance = parsedMesh.instances[index];
        var instance = mesh.createInstance(parsedInstance.name);
        if (parsedInstance.id) {
          instance.id = parsedInstance.id;
        }
        if (Tags) {
          if (parsedInstance.tags) {
            Tags.AddTagsTo(instance, parsedInstance.tags);
          } else {
            Tags.AddTagsTo(instance, parsedMesh.tags);
          }
        }
        instance.position = Vector3.FromArray(parsedInstance.position);
        if (parsedInstance.metadata !== void 0) {
          instance.metadata = parsedInstance.metadata;
        }
        if (parsedInstance.parentId !== void 0) {
          instance._waitingParentId = parsedInstance.parentId;
        }
        if (parsedInstance.isEnabled !== void 0 && parsedInstance.isEnabled !== null) {
          instance.setEnabled(parsedInstance.isEnabled);
        }
        if (parsedInstance.isVisible !== void 0 && parsedInstance.isVisible !== null) {
          instance.isVisible = parsedInstance.isVisible;
        }
        if (parsedInstance.isPickable !== void 0 && parsedInstance.isPickable !== null) {
          instance.isPickable = parsedInstance.isPickable;
        }
        if (parsedInstance.rotationQuaternion) {
          instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);
        } else if (parsedInstance.rotation) {
          instance.rotation = Vector3.FromArray(parsedInstance.rotation);
        }
        instance.scaling = Vector3.FromArray(parsedInstance.scaling);
        if (parsedInstance.checkCollisions != void 0 && parsedInstance.checkCollisions != null) {
          instance.checkCollisions = parsedInstance.checkCollisions;
        }
        if (parsedInstance.pickable != void 0 && parsedInstance.pickable != null) {
          instance.isPickable = parsedInstance.pickable;
        }
        if (parsedInstance.showBoundingBox != void 0 && parsedInstance.showBoundingBox != null) {
          instance.showBoundingBox = parsedInstance.showBoundingBox;
        }
        if (parsedInstance.showSubMeshesBoundingBox != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
          instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;
        }
        if (parsedInstance.alphaIndex != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
          instance.alphaIndex = parsedInstance.alphaIndex;
        }
        if (parsedInstance.physicsImpostor) {
          Mesh2._PhysicsImpostorParser(scene, instance, parsedInstance);
        }
        if (parsedInstance.animations) {
          for (animationIndex = 0; animationIndex < parsedInstance.animations.length; animationIndex++) {
            parsedAnimation = parsedInstance.animations[animationIndex];
            var internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              instance.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          Node.ParseAnimationRanges(instance, parsedInstance, scene);
          if (parsedInstance.autoAnimate) {
            scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1);
          }
        }
      }
    }
    if (parsedMesh.thinInstances) {
      var thinInstances = parsedMesh.thinInstances;
      mesh.thinInstanceEnablePicking = !!thinInstances.enablePicking;
      if (thinInstances.matrixData) {
        mesh.thinInstanceSetBuffer("matrix", new Float32Array(thinInstances.matrixData), 16, false);
        mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
        mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;
      } else {
        mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
      }
      if (parsedMesh.thinInstances.userThinInstance) {
        var userThinInstance = parsedMesh.thinInstances.userThinInstance;
        for (var kind in userThinInstance.data) {
          mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);
          mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];
        }
      }
    }
    return mesh;
  };
  Mesh2.prototype.setPositionsForCPUSkinning = function() {
    var internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._sourcePositions) {
      var source = this.getVerticesData(VertexBuffer.PositionKind);
      if (!source) {
        return internalDataInfo._sourcePositions;
      }
      internalDataInfo._sourcePositions = new Float32Array(source);
      if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
        this.setVerticesData(VertexBuffer.PositionKind, source, true);
      }
    }
    return internalDataInfo._sourcePositions;
  };
  Mesh2.prototype.setNormalsForCPUSkinning = function() {
    var internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._sourceNormals) {
      var source = this.getVerticesData(VertexBuffer.NormalKind);
      if (!source) {
        return internalDataInfo._sourceNormals;
      }
      internalDataInfo._sourceNormals = new Float32Array(source);
      if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
        this.setVerticesData(VertexBuffer.NormalKind, source, true);
      }
    }
    return internalDataInfo._sourceNormals;
  };
  Mesh2.prototype.applySkeleton = function(skeleton) {
    if (!this.geometry) {
      return this;
    }
    if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {
      return this;
    }
    this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();
    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      return this;
    }
    if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      return this;
    }
    if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      return this;
    }
    var hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);
    var internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._sourcePositions) {
      var submeshes = this.subMeshes.slice();
      this.setPositionsForCPUSkinning();
      this.subMeshes = submeshes;
    }
    if (hasNormals && !internalDataInfo._sourceNormals) {
      this.setNormalsForCPUSkinning();
    }
    var positionsData = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positionsData) {
      return this;
    }
    if (!(positionsData instanceof Float32Array)) {
      positionsData = new Float32Array(positionsData);
    }
    var normalsData = this.getVerticesData(VertexBuffer.NormalKind);
    if (hasNormals) {
      if (!normalsData) {
        return this;
      }
      if (!(normalsData instanceof Float32Array)) {
        normalsData = new Float32Array(normalsData);
      }
    }
    var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
    var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    if (!matricesWeightsData || !matricesIndicesData) {
      return this;
    }
    var needExtras = this.numBoneInfluencers > 4;
    var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
    var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
    var skeletonMatrices = skeleton.getTransformMatrices(this);
    var tempVector3 = Vector3.Zero();
    var finalMatrix = new Matrix();
    var tempMatrix = new Matrix();
    var matWeightIdx = 0;
    var inf;
    for (var index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {
      var weight;
      for (inf = 0; inf < 4; inf++) {
        weight = matricesWeightsData[matWeightIdx + inf];
        if (weight > 0) {
          Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
          finalMatrix.addToSelf(tempMatrix);
        }
      }
      if (needExtras) {
        for (inf = 0; inf < 4; inf++) {
          weight = matricesWeightsExtraData[matWeightIdx + inf];
          if (weight > 0) {
            Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
            finalMatrix.addToSelf(tempMatrix);
          }
        }
      }
      Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);
      tempVector3.toArray(positionsData, index);
      if (hasNormals) {
        Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);
        tempVector3.toArray(normalsData, index);
      }
      finalMatrix.reset();
    }
    this.updateVerticesData(VertexBuffer.PositionKind, positionsData);
    if (hasNormals) {
      this.updateVerticesData(VertexBuffer.NormalKind, normalsData);
    }
    return this;
  };
  Mesh2.MinMax = function(meshes) {
    var minVector = null;
    var maxVector = null;
    meshes.forEach(function(mesh) {
      var boundingInfo = mesh.getBoundingInfo();
      var boundingBox = boundingInfo.boundingBox;
      if (!minVector || !maxVector) {
        minVector = boundingBox.minimumWorld;
        maxVector = boundingBox.maximumWorld;
      } else {
        minVector.minimizeInPlace(boundingBox.minimumWorld);
        maxVector.maximizeInPlace(boundingBox.maximumWorld);
      }
    });
    if (!minVector || !maxVector) {
      return {
        min: Vector3.Zero(),
        max: Vector3.Zero()
      };
    }
    return {
      min: minVector,
      max: maxVector
    };
  };
  Mesh2.Center = function(meshesOrMinMaxVector) {
    var minMaxVector = meshesOrMinMaxVector instanceof Array ? Mesh2.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;
    return Vector3.Center(minMaxVector.min, minMaxVector.max);
  };
  Mesh2.MergeMeshes = function(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {
    if (disposeSource === void 0) {
      disposeSource = true;
    }
    return runCoroutineSync(Mesh2._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, false));
  };
  Mesh2.MergeMeshesAsync = function(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {
    if (disposeSource === void 0) {
      disposeSource = true;
    }
    return runCoroutineAsync(Mesh2._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, true), createYieldingScheduler());
  };
  Mesh2._MergeMeshesCoroutine = function(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, isAsync) {
    var index, totalVertices, newMultiMaterial, subIndex, matIndex, materialArray, materialIndexArray, indiceArray, mesh, material, source, getVertexDataFromMesh, _a, sourceVertexData, sourceTransform, meshVertexDatas, i, mergeCoroutine, mergeCoroutineStep, vertexData, applyToCoroutine, applyToCoroutineStep, offset, _i, _b, subMesh;
    if (disposeSource === void 0) {
      disposeSource = true;
    }
    return __generator(this, function(_c) {
      switch (_c.label) {
        case 0:
          meshes = meshes.filter(Boolean);
          if (meshes.length === 0) {
            return [2, null];
          }
          if (!allow32BitsIndices) {
            totalVertices = 0;
            for (index = 0; index < meshes.length; index++) {
              totalVertices += meshes[index].getTotalVertices();
              if (totalVertices >= 65536) {
                Logger.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices");
                return [2, null];
              }
            }
          }
          if (multiMultiMaterials) {
            newMultiMaterial = null;
            subdivideWithSubMeshes = false;
          }
          materialArray = new Array();
          materialIndexArray = new Array();
          indiceArray = new Array();
          for (index = 0; index < meshes.length; index++) {
            mesh = meshes[index];
            if (mesh.isAnInstance) {
              Logger.Warn("Cannot merge instance meshes.");
              return [2, null];
            }
            if (subdivideWithSubMeshes) {
              indiceArray.push(mesh.getTotalIndices());
            }
            if (multiMultiMaterials) {
              if (mesh.material) {
                material = mesh.material;
                if (material instanceof MultiMaterial) {
                  for (matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {
                    if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {
                      materialArray.push(material.subMaterials[matIndex]);
                    }
                  }
                  for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                    materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));
                    indiceArray.push(mesh.subMeshes[subIndex].indexCount);
                  }
                } else {
                  if (materialArray.indexOf(material) < 0) {
                    materialArray.push(material);
                  }
                  for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                    materialIndexArray.push(materialArray.indexOf(material));
                    indiceArray.push(mesh.subMeshes[subIndex].indexCount);
                  }
                }
              } else {
                for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                  materialIndexArray.push(0);
                  indiceArray.push(mesh.subMeshes[subIndex].indexCount);
                }
              }
            }
          }
          source = meshes[0];
          getVertexDataFromMesh = function(mesh2) {
            var wm = mesh2.computeWorldMatrix(true);
            var vertexData2 = VertexData.ExtractFromMesh(mesh2, false, false);
            return [vertexData2, wm];
          };
          _a = getVertexDataFromMesh(source), sourceVertexData = _a[0], sourceTransform = _a[1];
          if (!isAsync)
            return [3, 2];
          return [4];
        case 1:
          _c.sent();
          _c.label = 2;
        case 2:
          meshVertexDatas = new Array(meshes.length - 1);
          i = 1;
          _c.label = 3;
        case 3:
          if (!(i < meshes.length))
            return [3, 6];
          meshVertexDatas[i - 1] = getVertexDataFromMesh(meshes[i]);
          if (!isAsync)
            return [3, 5];
          return [4];
        case 4:
          _c.sent();
          _c.label = 5;
        case 5:
          i++;
          return [3, 3];
        case 6:
          mergeCoroutine = sourceVertexData._mergeCoroutine(sourceTransform, meshVertexDatas, allow32BitsIndices, isAsync, !disposeSource);
          mergeCoroutineStep = mergeCoroutine.next();
          _c.label = 7;
        case 7:
          if (!!mergeCoroutineStep.done)
            return [3, 10];
          if (!isAsync)
            return [3, 9];
          return [4];
        case 8:
          _c.sent();
          _c.label = 9;
        case 9:
          mergeCoroutineStep = mergeCoroutine.next();
          return [3, 7];
        case 10:
          vertexData = mergeCoroutineStep.value;
          if (!meshSubclass) {
            meshSubclass = new Mesh2(source.name + "_merged", source.getScene());
          }
          applyToCoroutine = vertexData._applyToCoroutine(meshSubclass, void 0, isAsync);
          applyToCoroutineStep = applyToCoroutine.next();
          _c.label = 11;
        case 11:
          if (!!applyToCoroutineStep.done)
            return [3, 14];
          if (!isAsync)
            return [3, 13];
          return [4];
        case 12:
          _c.sent();
          _c.label = 13;
        case 13:
          applyToCoroutineStep = applyToCoroutine.next();
          return [3, 11];
        case 14:
          meshSubclass.checkCollisions = source.checkCollisions;
          meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation;
          if (disposeSource) {
            for (index = 0; index < meshes.length; index++) {
              meshes[index].dispose();
            }
          }
          if (subdivideWithSubMeshes || multiMultiMaterials) {
            meshSubclass.releaseSubMeshes();
            index = 0;
            offset = 0;
            while (index < indiceArray.length) {
              SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass, void 0, false);
              offset += indiceArray[index];
              index++;
            }
            for (_i = 0, _b = meshSubclass.subMeshes; _i < _b.length; _i++) {
              subMesh = _b[_i];
              subMesh.refreshBoundingInfo();
            }
            meshSubclass.computeWorldMatrix(true);
          }
          if (multiMultiMaterials) {
            newMultiMaterial = new MultiMaterial(source.name + "_merged", source.getScene());
            newMultiMaterial.subMaterials = materialArray;
            for (subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {
              meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];
            }
            meshSubclass.material = newMultiMaterial;
          } else {
            meshSubclass.material = source.material;
          }
          return [2, meshSubclass];
      }
    });
  };
  Mesh2.prototype.addInstance = function(instance) {
    instance._indexInSourceMeshInstanceArray = this.instances.length;
    this.instances.push(instance);
  };
  Mesh2.prototype.removeInstance = function(instance) {
    var index = instance._indexInSourceMeshInstanceArray;
    if (index != -1) {
      if (index !== this.instances.length - 1) {
        var last = this.instances[this.instances.length - 1];
        this.instances[index] = last;
        last._indexInSourceMeshInstanceArray = index;
      }
      instance._indexInSourceMeshInstanceArray = -1;
      this.instances.pop();
    }
  };
  Mesh2.prototype._shouldConvertRHS = function() {
    return this.overrideMaterialSideOrientation === Material.CounterClockWiseSideOrientation;
  };
  Mesh2.FRONTSIDE = VertexData.FRONTSIDE;
  Mesh2.BACKSIDE = VertexData.BACKSIDE;
  Mesh2.DOUBLESIDE = VertexData.DOUBLESIDE;
  Mesh2.DEFAULTSIDE = VertexData.DEFAULTSIDE;
  Mesh2.NO_CAP = 0;
  Mesh2.CAP_START = 1;
  Mesh2.CAP_END = 2;
  Mesh2.CAP_ALL = 3;
  Mesh2.NO_FLIP = 0;
  Mesh2.FLIP_TILE = 1;
  Mesh2.ROTATE_TILE = 2;
  Mesh2.FLIP_ROW = 3;
  Mesh2.ROTATE_ROW = 4;
  Mesh2.FLIP_N_ROTATE_TILE = 5;
  Mesh2.FLIP_N_ROTATE_ROW = 6;
  Mesh2.CENTER = 0;
  Mesh2.LEFT = 1;
  Mesh2.RIGHT = 2;
  Mesh2.TOP = 3;
  Mesh2.BOTTOM = 4;
  Mesh2.INSTANCEDMESH_SORT_TRANSPARENT = false;
  Mesh2._GroundMeshParser = function(parsedMesh, scene) {
    throw _WarnImport("GroundMesh");
  };
  Mesh2._GoldbergMeshParser = function(parsedMesh, scene) {
    throw _WarnImport("GoldbergMesh");
  };
  Mesh2._LinesMeshParser = function(parsedMesh, scene) {
    throw _WarnImport("LinesMesh");
  };
  return Mesh2;
}(AbstractMesh);
RegisterClass("BABYLON.Mesh", Mesh);
_injectLTSMesh(Mesh);
var SceneOptimization = function() {
  function SceneOptimization2(priority) {
    if (priority === void 0) {
      priority = 0;
    }
    this.priority = priority;
  }
  SceneOptimization2.prototype.getDescription = function() {
    return "";
  };
  SceneOptimization2.prototype.apply = function(scene, optimizer) {
    return true;
  };
  return SceneOptimization2;
}();
var TextureOptimization = function(_super) {
  __extends(TextureOptimization2, _super);
  function TextureOptimization2(priority, maximumSize, step) {
    if (priority === void 0) {
      priority = 0;
    }
    if (maximumSize === void 0) {
      maximumSize = 1024;
    }
    if (step === void 0) {
      step = 0.5;
    }
    var _this = _super.call(this, priority) || this;
    _this.priority = priority;
    _this.maximumSize = maximumSize;
    _this.step = step;
    return _this;
  }
  TextureOptimization2.prototype.getDescription = function() {
    return "Reducing render target texture size to " + this.maximumSize;
  };
  TextureOptimization2.prototype.apply = function(scene, optimizer) {
    var allDone = true;
    for (var index = 0; index < scene.textures.length; index++) {
      var texture = scene.textures[index];
      if (!texture.canRescale || texture.getContext) {
        continue;
      }
      var currentSize = texture.getSize();
      var maxDimension = Math.max(currentSize.width, currentSize.height);
      if (maxDimension > this.maximumSize) {
        texture.scale(this.step);
        allDone = false;
      }
    }
    return allDone;
  };
  return TextureOptimization2;
}(SceneOptimization);
var HardwareScalingOptimization = function(_super) {
  __extends(HardwareScalingOptimization2, _super);
  function HardwareScalingOptimization2(priority, maximumScale, step) {
    if (priority === void 0) {
      priority = 0;
    }
    if (maximumScale === void 0) {
      maximumScale = 2;
    }
    if (step === void 0) {
      step = 0.25;
    }
    var _this = _super.call(this, priority) || this;
    _this.priority = priority;
    _this.maximumScale = maximumScale;
    _this.step = step;
    _this._currentScale = -1;
    _this._directionOffset = 1;
    return _this;
  }
  HardwareScalingOptimization2.prototype.getDescription = function() {
    return "Setting hardware scaling level to " + this._currentScale;
  };
  HardwareScalingOptimization2.prototype.apply = function(scene, optimizer) {
    if (this._currentScale === -1) {
      this._currentScale = scene.getEngine().getHardwareScalingLevel();
      if (this._currentScale > this.maximumScale) {
        this._directionOffset = -1;
      }
    }
    this._currentScale += this._directionOffset * this.step;
    scene.getEngine().setHardwareScalingLevel(this._currentScale);
    return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;
  };
  return HardwareScalingOptimization2;
}(SceneOptimization);
var ShadowsOptimization = function(_super) {
  __extends(ShadowsOptimization2, _super);
  function ShadowsOptimization2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShadowsOptimization2.prototype.getDescription = function() {
    return "Turning shadows on/off";
  };
  ShadowsOptimization2.prototype.apply = function(scene, optimizer) {
    scene.shadowsEnabled = optimizer.isInImprovementMode;
    return true;
  };
  return ShadowsOptimization2;
}(SceneOptimization);
var PostProcessesOptimization = function(_super) {
  __extends(PostProcessesOptimization2, _super);
  function PostProcessesOptimization2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PostProcessesOptimization2.prototype.getDescription = function() {
    return "Turning post-processes on/off";
  };
  PostProcessesOptimization2.prototype.apply = function(scene, optimizer) {
    scene.postProcessesEnabled = optimizer.isInImprovementMode;
    return true;
  };
  return PostProcessesOptimization2;
}(SceneOptimization);
var LensFlaresOptimization = function(_super) {
  __extends(LensFlaresOptimization2, _super);
  function LensFlaresOptimization2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LensFlaresOptimization2.prototype.getDescription = function() {
    return "Turning lens flares on/off";
  };
  LensFlaresOptimization2.prototype.apply = function(scene, optimizer) {
    scene.lensFlaresEnabled = optimizer.isInImprovementMode;
    return true;
  };
  return LensFlaresOptimization2;
}(SceneOptimization);
var CustomOptimization = function(_super) {
  __extends(CustomOptimization2, _super);
  function CustomOptimization2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CustomOptimization2.prototype.getDescription = function() {
    if (this.onGetDescription) {
      return this.onGetDescription();
    }
    return "Running user defined callback";
  };
  CustomOptimization2.prototype.apply = function(scene, optimizer) {
    if (this.onApply) {
      return this.onApply(scene, optimizer);
    }
    return true;
  };
  return CustomOptimization2;
}(SceneOptimization);
var ParticlesOptimization = function(_super) {
  __extends(ParticlesOptimization2, _super);
  function ParticlesOptimization2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ParticlesOptimization2.prototype.getDescription = function() {
    return "Turning particles on/off";
  };
  ParticlesOptimization2.prototype.apply = function(scene, optimizer) {
    scene.particlesEnabled = optimizer.isInImprovementMode;
    return true;
  };
  return ParticlesOptimization2;
}(SceneOptimization);
var RenderTargetsOptimization = function(_super) {
  __extends(RenderTargetsOptimization2, _super);
  function RenderTargetsOptimization2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RenderTargetsOptimization2.prototype.getDescription = function() {
    return "Turning render targets off";
  };
  RenderTargetsOptimization2.prototype.apply = function(scene, optimizer) {
    scene.renderTargetsEnabled = optimizer.isInImprovementMode;
    return true;
  };
  return RenderTargetsOptimization2;
}(SceneOptimization);
var MergeMeshesOptimization = function(_super) {
  __extends(MergeMeshesOptimization2, _super);
  function MergeMeshesOptimization2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._canBeMerged = function(abstractMesh) {
      if (!(abstractMesh instanceof Mesh)) {
        return false;
      }
      var mesh = abstractMesh;
      if (mesh.isDisposed()) {
        return false;
      }
      if (!mesh.isVisible || !mesh.isEnabled()) {
        return false;
      }
      if (mesh.instances.length > 0) {
        return false;
      }
      if (mesh.skeleton || mesh.hasLODLevels) {
        return false;
      }
      return true;
    };
    return _this;
  }
  Object.defineProperty(MergeMeshesOptimization2, "UpdateSelectionTree", {
    get: function() {
      return MergeMeshesOptimization2._UpdateSelectionTree;
    },
    set: function(value) {
      MergeMeshesOptimization2._UpdateSelectionTree = value;
    },
    enumerable: false,
    configurable: true
  });
  MergeMeshesOptimization2.prototype.getDescription = function() {
    return "Merging similar meshes together";
  };
  MergeMeshesOptimization2.prototype.apply = function(scene, optimizer, updateSelectionTree) {
    var globalPool = scene.meshes.slice(0);
    var globalLength = globalPool.length;
    for (var index = 0; index < globalLength; index++) {
      var currentPool = new Array();
      var current = globalPool[index];
      if (!this._canBeMerged(current)) {
        continue;
      }
      currentPool.push(current);
      for (var subIndex = index + 1; subIndex < globalLength; subIndex++) {
        var otherMesh = globalPool[subIndex];
        if (!this._canBeMerged(otherMesh)) {
          continue;
        }
        if (otherMesh.material !== current.material) {
          continue;
        }
        if (otherMesh.checkCollisions !== current.checkCollisions) {
          continue;
        }
        currentPool.push(otherMesh);
        globalLength--;
        globalPool.splice(subIndex, 1);
        subIndex--;
      }
      if (currentPool.length < 2) {
        continue;
      }
      Mesh.MergeMeshes(currentPool, void 0, true);
    }
    var sceneAsAny = scene;
    if (sceneAsAny.createOrUpdateSelectionOctree) {
      if (updateSelectionTree != void 0) {
        if (updateSelectionTree) {
          sceneAsAny.createOrUpdateSelectionOctree();
        }
      } else if (MergeMeshesOptimization2.UpdateSelectionTree) {
        sceneAsAny.createOrUpdateSelectionOctree();
      }
    }
    return true;
  };
  MergeMeshesOptimization2._UpdateSelectionTree = false;
  return MergeMeshesOptimization2;
}(SceneOptimization);
var SceneOptimizerOptions = function() {
  function SceneOptimizerOptions2(targetFrameRate, trackerDuration) {
    if (targetFrameRate === void 0) {
      targetFrameRate = 60;
    }
    if (trackerDuration === void 0) {
      trackerDuration = 2e3;
    }
    this.targetFrameRate = targetFrameRate;
    this.trackerDuration = trackerDuration;
    this.optimizations = new Array();
  }
  SceneOptimizerOptions2.prototype.addOptimization = function(optimization) {
    this.optimizations.push(optimization);
    return this;
  };
  SceneOptimizerOptions2.prototype.addCustomOptimization = function(onApply, onGetDescription, priority) {
    if (priority === void 0) {
      priority = 0;
    }
    var optimization = new CustomOptimization(priority);
    optimization.onApply = onApply;
    optimization.onGetDescription = onGetDescription;
    this.optimizations.push(optimization);
    return this;
  };
  SceneOptimizerOptions2.LowDegradationAllowed = function(targetFrameRate) {
    var result = new SceneOptimizerOptions2(targetFrameRate);
    var priority = 0;
    result.addOptimization(new MergeMeshesOptimization(priority));
    result.addOptimization(new ShadowsOptimization(priority));
    result.addOptimization(new LensFlaresOptimization(priority));
    priority++;
    result.addOptimization(new PostProcessesOptimization(priority));
    result.addOptimization(new ParticlesOptimization(priority));
    priority++;
    result.addOptimization(new TextureOptimization(priority, 1024));
    return result;
  };
  SceneOptimizerOptions2.ModerateDegradationAllowed = function(targetFrameRate) {
    var result = new SceneOptimizerOptions2(targetFrameRate);
    var priority = 0;
    result.addOptimization(new MergeMeshesOptimization(priority));
    result.addOptimization(new ShadowsOptimization(priority));
    result.addOptimization(new LensFlaresOptimization(priority));
    priority++;
    result.addOptimization(new PostProcessesOptimization(priority));
    result.addOptimization(new ParticlesOptimization(priority));
    priority++;
    result.addOptimization(new TextureOptimization(priority, 512));
    priority++;
    result.addOptimization(new RenderTargetsOptimization(priority));
    priority++;
    result.addOptimization(new HardwareScalingOptimization(priority, 2));
    return result;
  };
  SceneOptimizerOptions2.HighDegradationAllowed = function(targetFrameRate) {
    var result = new SceneOptimizerOptions2(targetFrameRate);
    var priority = 0;
    result.addOptimization(new MergeMeshesOptimization(priority));
    result.addOptimization(new ShadowsOptimization(priority));
    result.addOptimization(new LensFlaresOptimization(priority));
    priority++;
    result.addOptimization(new PostProcessesOptimization(priority));
    result.addOptimization(new ParticlesOptimization(priority));
    priority++;
    result.addOptimization(new TextureOptimization(priority, 256));
    priority++;
    result.addOptimization(new RenderTargetsOptimization(priority));
    priority++;
    result.addOptimization(new HardwareScalingOptimization(priority, 4));
    return result;
  };
  return SceneOptimizerOptions2;
}();
var SceneOptimizer = function() {
  function SceneOptimizer2(scene, options, autoGeneratePriorities, improvementMode) {
    var _this = this;
    if (autoGeneratePriorities === void 0) {
      autoGeneratePriorities = true;
    }
    if (improvementMode === void 0) {
      improvementMode = false;
    }
    this._isRunning = false;
    this._currentPriorityLevel = 0;
    this._targetFrameRate = 60;
    this._trackerDuration = 2e3;
    this._currentFrameRate = 0;
    this._improvementMode = false;
    this.onSuccessObservable = new Observable();
    this.onNewOptimizationAppliedObservable = new Observable();
    this.onFailureObservable = new Observable();
    if (!options) {
      this._options = new SceneOptimizerOptions();
    } else {
      this._options = options;
    }
    if (this._options.targetFrameRate) {
      this._targetFrameRate = this._options.targetFrameRate;
    }
    if (this._options.trackerDuration) {
      this._trackerDuration = this._options.trackerDuration;
    }
    if (autoGeneratePriorities) {
      var priority = 0;
      for (var _i = 0, _a = this._options.optimizations; _i < _a.length; _i++) {
        var optim = _a[_i];
        optim.priority = priority++;
      }
    }
    this._improvementMode = improvementMode;
    this._scene = scene || EngineStore.LastCreatedScene;
    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(function() {
      _this._sceneDisposeObserver = null;
      _this.dispose();
    });
  }
  Object.defineProperty(SceneOptimizer2.prototype, "isInImprovementMode", {
    get: function() {
      return this._improvementMode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneOptimizer2.prototype, "currentPriorityLevel", {
    get: function() {
      return this._currentPriorityLevel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneOptimizer2.prototype, "currentFrameRate", {
    get: function() {
      return this._currentFrameRate;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneOptimizer2.prototype, "targetFrameRate", {
    get: function() {
      return this._targetFrameRate;
    },
    set: function(value) {
      this._targetFrameRate = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneOptimizer2.prototype, "trackerDuration", {
    get: function() {
      return this._trackerDuration;
    },
    set: function(value) {
      this._trackerDuration = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneOptimizer2.prototype, "optimizations", {
    get: function() {
      return this._options.optimizations;
    },
    enumerable: false,
    configurable: true
  });
  SceneOptimizer2.prototype.stop = function() {
    this._isRunning = false;
  };
  SceneOptimizer2.prototype.reset = function() {
    this._currentPriorityLevel = 0;
  };
  SceneOptimizer2.prototype.start = function() {
    var _this = this;
    if (this._isRunning) {
      return;
    }
    this._isRunning = true;
    this._scene.executeWhenReady(function() {
      setTimeout(function() {
        _this._checkCurrentState();
      }, _this._trackerDuration);
    });
  };
  SceneOptimizer2.prototype._checkCurrentState = function() {
    var _this = this;
    if (!this._isRunning) {
      return;
    }
    var scene = this._scene;
    var options = this._options;
    this._currentFrameRate = Math.round(scene.getEngine().getFps());
    if (this._improvementMode && this._currentFrameRate <= this._targetFrameRate || !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {
      this._isRunning = false;
      this.onSuccessObservable.notifyObservers(this);
      return;
    }
    var allDone = true;
    var noOptimizationApplied = true;
    for (var index = 0; index < options.optimizations.length; index++) {
      var optimization = options.optimizations[index];
      if (optimization.priority === this._currentPriorityLevel) {
        noOptimizationApplied = false;
        allDone = allDone && optimization.apply(scene, this);
        this.onNewOptimizationAppliedObservable.notifyObservers(optimization);
      }
    }
    if (noOptimizationApplied) {
      this._isRunning = false;
      this.onFailureObservable.notifyObservers(this);
      return;
    }
    if (allDone) {
      this._currentPriorityLevel++;
    }
    scene.executeWhenReady(function() {
      setTimeout(function() {
        _this._checkCurrentState();
      }, _this._trackerDuration);
    });
  };
  SceneOptimizer2.prototype.dispose = function() {
    this.stop();
    this.onSuccessObservable.clear();
    this.onFailureObservable.clear();
    this.onNewOptimizationAppliedObservable.clear();
    if (this._sceneDisposeObserver) {
      this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);
    }
  };
  SceneOptimizer2.OptimizeAsync = function(scene, options, onSuccess, onFailure) {
    var optimizer = new SceneOptimizer2(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);
    if (onSuccess) {
      optimizer.onSuccessObservable.add(function() {
        onSuccess();
      });
    }
    if (onFailure) {
      optimizer.onFailureObservable.add(function() {
        onFailure();
      });
    }
    optimizer.start();
    return optimizer;
  };
  return SceneOptimizer2;
}();
function createScene(options) {
  const { engine } = options;
  const scene = new Scene(engine);
  scene.clearColor = new Color4$1(0, 0, 0, 0);
  scene.pointerMovePredicate = () => false;
  scene.pointerDownPredicate = () => false;
  scene.pointerUpPredicate = () => false;
  scene.clearCachedVertexData();
  const optimizationSettings = SceneOptimizerOptions.LowDegradationAllowed();
  optimizationSettings.optimizations = optimizationSettings.optimizations.splice(1);
  optimizationSettings.targetFrameRate = 60;
  SceneOptimizer.OptimizeAsync(scene, optimizationSettings);
  return scene;
}
var TargetCamera = function(_super) {
  __extends(TargetCamera2, _super);
  function TargetCamera2(name2, position, scene, setActiveOnSceneIfNoneActive) {
    if (setActiveOnSceneIfNoneActive === void 0) {
      setActiveOnSceneIfNoneActive = true;
    }
    var _this = _super.call(this, name2, position, scene, setActiveOnSceneIfNoneActive) || this;
    _this._tmpUpVector = Vector3.Zero();
    _this._tmpTargetVector = Vector3.Zero();
    _this.cameraDirection = new Vector3(0, 0, 0);
    _this.cameraRotation = new Vector2(0, 0);
    _this.ignoreParentScaling = false;
    _this.updateUpVectorFromRotation = false;
    _this._tmpQuaternion = new Quaternion();
    _this.rotation = new Vector3(0, 0, 0);
    _this.speed = 2;
    _this.noRotationConstraint = false;
    _this.invertRotation = false;
    _this.inverseRotationSpeed = 0.2;
    _this.lockedTarget = null;
    _this._currentTarget = Vector3.Zero();
    _this._initialFocalDistance = 1;
    _this._viewMatrix = Matrix.Zero();
    _this._camMatrix = Matrix.Zero();
    _this._cameraTransformMatrix = Matrix.Zero();
    _this._cameraRotationMatrix = Matrix.Zero();
    _this._referencePoint = new Vector3(0, 0, 1);
    _this._transformedReferencePoint = Vector3.Zero();
    _this._defaultUp = Vector3.Up();
    _this._cachedRotationZ = 0;
    _this._cachedQuaternionRotationZ = 0;
    return _this;
  }
  TargetCamera2.prototype.getFrontPosition = function(distance) {
    this.getWorldMatrix();
    var direction = this.getTarget().subtract(this.position);
    direction.normalize();
    direction.scaleInPlace(distance);
    return this.globalPosition.add(direction);
  };
  TargetCamera2.prototype._getLockedTargetPosition = function() {
    if (!this.lockedTarget) {
      return null;
    }
    if (this.lockedTarget.absolutePosition) {
      this.lockedTarget.computeWorldMatrix();
    }
    return this.lockedTarget.absolutePosition || this.lockedTarget;
  };
  TargetCamera2.prototype.storeState = function() {
    this._storedPosition = this.position.clone();
    this._storedRotation = this.rotation.clone();
    if (this.rotationQuaternion) {
      this._storedRotationQuaternion = this.rotationQuaternion.clone();
    }
    return _super.prototype.storeState.call(this);
  };
  TargetCamera2.prototype._restoreStateValues = function() {
    if (!_super.prototype._restoreStateValues.call(this)) {
      return false;
    }
    this.position = this._storedPosition.clone();
    this.rotation = this._storedRotation.clone();
    if (this.rotationQuaternion) {
      this.rotationQuaternion = this._storedRotationQuaternion.clone();
    }
    this.cameraDirection.copyFromFloats(0, 0, 0);
    this.cameraRotation.copyFromFloats(0, 0);
    return true;
  };
  TargetCamera2.prototype._initCache = function() {
    _super.prototype._initCache.call(this);
    this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  };
  TargetCamera2.prototype._updateCache = function(ignoreParentClass) {
    if (!ignoreParentClass) {
      _super.prototype._updateCache.call(this);
    }
    var lockedTargetPosition = this._getLockedTargetPosition();
    if (!lockedTargetPosition) {
      this._cache.lockedTarget = null;
    } else {
      if (!this._cache.lockedTarget) {
        this._cache.lockedTarget = lockedTargetPosition.clone();
      } else {
        this._cache.lockedTarget.copyFrom(lockedTargetPosition);
      }
    }
    this._cache.rotation.copyFrom(this.rotation);
    if (this.rotationQuaternion) {
      this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);
    }
  };
  TargetCamera2.prototype._isSynchronizedViewMatrix = function() {
    if (!_super.prototype._isSynchronizedViewMatrix.call(this)) {
      return false;
    }
    var lockedTargetPosition = this._getLockedTargetPosition();
    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));
  };
  TargetCamera2.prototype._computeLocalCameraSpeed = function() {
    var engine = this.getEngine();
    return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100));
  };
  TargetCamera2.prototype.setTarget = function(target) {
    this.upVector.normalize();
    this._initialFocalDistance = target.subtract(this.position).length();
    if (this.position.z === target.z) {
      this.position.z += Epsilon;
    }
    this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);
    Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);
    this._camMatrix.invert();
    this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);
    var vDir = target.subtract(this.position);
    if (vDir.x >= 0) {
      this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2;
    } else {
      this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2;
    }
    this.rotation.z = 0;
    if (isNaN(this.rotation.x)) {
      this.rotation.x = 0;
    }
    if (isNaN(this.rotation.y)) {
      this.rotation.y = 0;
    }
    if (isNaN(this.rotation.z)) {
      this.rotation.z = 0;
    }
    if (this.rotationQuaternion) {
      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);
    }
  };
  Object.defineProperty(TargetCamera2.prototype, "target", {
    get: function() {
      return this.getTarget();
    },
    set: function(value) {
      this.setTarget(value);
    },
    enumerable: false,
    configurable: true
  });
  TargetCamera2.prototype.getTarget = function() {
    return this._currentTarget;
  };
  TargetCamera2.prototype._decideIfNeedsToMove = function() {
    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
  };
  TargetCamera2.prototype._updatePosition = function() {
    if (this.parent) {
      this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);
      Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);
      this.position.addInPlace(TmpVectors.Vector3[0]);
      return;
    }
    this.position.addInPlace(this.cameraDirection);
  };
  TargetCamera2.prototype._checkInputs = function() {
    var directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1;
    var needToMove = this._decideIfNeedsToMove();
    var needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;
    if (needToMove) {
      this._updatePosition();
    }
    if (needToRotate) {
      if (this.rotationQuaternion) {
        this.rotationQuaternion.toEulerAnglesToRef(this.rotation);
      }
      this.rotation.x += this.cameraRotation.x * directionMultiplier;
      this.rotation.y += this.cameraRotation.y * directionMultiplier;
      if (!this.noRotationConstraint) {
        var limit = 1.570796;
        if (this.rotation.x > limit) {
          this.rotation.x = limit;
        }
        if (this.rotation.x < -limit) {
          this.rotation.x = -limit;
        }
      }
      if (this.rotationQuaternion) {
        var len = this.rotation.lengthSquared();
        if (len) {
          Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);
        }
      }
    }
    if (needToMove) {
      if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {
        this.cameraDirection.x = 0;
      }
      if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {
        this.cameraDirection.y = 0;
      }
      if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {
        this.cameraDirection.z = 0;
      }
      this.cameraDirection.scaleInPlace(this.inertia);
    }
    if (needToRotate) {
      if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {
        this.cameraRotation.x = 0;
      }
      if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {
        this.cameraRotation.y = 0;
      }
      this.cameraRotation.scaleInPlace(this.inertia);
    }
    _super.prototype._checkInputs.call(this);
  };
  TargetCamera2.prototype._updateCameraRotationMatrix = function() {
    if (this.rotationQuaternion) {
      this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);
    } else {
      Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
    }
  };
  TargetCamera2.prototype._rotateUpVectorWithCameraRotationMatrix = function() {
    Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);
    return this;
  };
  TargetCamera2.prototype._getViewMatrix = function() {
    if (this.lockedTarget) {
      this.setTarget(this._getLockedTargetPosition());
    }
    this._updateCameraRotationMatrix();
    if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {
      this._rotateUpVectorWithCameraRotationMatrix();
      this._cachedQuaternionRotationZ = this.rotationQuaternion.z;
    } else if (this._cachedRotationZ !== this.rotation.z) {
      this._rotateUpVectorWithCameraRotationMatrix();
      this._cachedRotationZ = this.rotation.z;
    }
    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);
    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
    if (this.updateUpVectorFromRotation) {
      if (this.rotationQuaternion) {
        Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);
      } else {
        Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);
        Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);
      }
    }
    this._computeViewMatrix(this.position, this._currentTarget, this.upVector);
    return this._viewMatrix;
  };
  TargetCamera2.prototype._computeViewMatrix = function(position, target, up) {
    if (this.ignoreParentScaling) {
      if (this.parent) {
        var parentWorldMatrix = this.parent.getWorldMatrix();
        Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);
        Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);
        Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);
        this._markSyncedWithParent();
      } else {
        this._globalPosition.copyFrom(position);
        this._tmpTargetVector.copyFrom(target);
        this._tmpUpVector.copyFrom(up);
      }
      if (this.getScene().useRightHandedSystem) {
        Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
      } else {
        Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
      }
      return;
    }
    if (this.getScene().useRightHandedSystem) {
      Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);
    } else {
      Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);
    }
    if (this.parent) {
      var parentWorldMatrix = this.parent.getWorldMatrix();
      this._viewMatrix.invert();
      this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);
      this._viewMatrix.getTranslationToRef(this._globalPosition);
      this._viewMatrix.invert();
      this._markSyncedWithParent();
    } else {
      this._globalPosition.copyFrom(position);
    }
  };
  TargetCamera2.prototype.createRigCamera = function(name2, cameraIndex) {
    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
      var rigCamera = new TargetCamera2(name2, this.position.clone(), this.getScene());
      rigCamera.isRigCamera = true;
      rigCamera.rigParent = this;
      if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {
        if (!this.rotationQuaternion) {
          this.rotationQuaternion = new Quaternion();
        }
        rigCamera._cameraRigParams = {};
        rigCamera.rotationQuaternion = new Quaternion();
      }
      return rigCamera;
    }
    return null;
  };
  TargetCamera2.prototype._updateRigCameras = function() {
    var camLeft = this._rigCameras[0];
    var camRight = this._rigCameras[1];
    this.computeWorldMatrix();
    switch (this.cameraRigMode) {
      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:
        var leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;
        var rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);
        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);
        break;
      case Camera.RIG_MODE_VR:
        if (camLeft.rotationQuaternion) {
          camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);
          camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);
        } else {
          camLeft.rotation.copyFrom(this.rotation);
          camRight.rotation.copyFrom(this.rotation);
        }
        camLeft.position.copyFrom(this.position);
        camRight.position.copyFrom(this.position);
        break;
    }
    _super.prototype._updateRigCameras.call(this);
  };
  TargetCamera2.prototype._getRigCamPositionAndTarget = function(halfSpace, rigCamera) {
    var target = this.getTarget();
    target.subtractToRef(this.position, TargetCamera2._TargetFocalPoint);
    TargetCamera2._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);
    var newFocalTarget = TargetCamera2._TargetFocalPoint.addInPlace(this.position);
    Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera2._TargetTransformMatrix);
    TargetCamera2._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera2._RigCamTransformMatrix);
    Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera2._TargetTransformMatrix);
    TargetCamera2._RigCamTransformMatrix.multiplyToRef(TargetCamera2._TargetTransformMatrix, TargetCamera2._RigCamTransformMatrix);
    Vector3.TransformCoordinatesToRef(this.position, TargetCamera2._RigCamTransformMatrix, rigCamera.position);
    rigCamera.setTarget(newFocalTarget);
  };
  TargetCamera2.prototype.getClassName = function() {
    return "TargetCamera";
  };
  TargetCamera2._RigCamTransformMatrix = new Matrix();
  TargetCamera2._TargetTransformMatrix = new Matrix();
  TargetCamera2._TargetFocalPoint = new Vector3();
  __decorate([
    serializeAsVector3()
  ], TargetCamera2.prototype, "rotation", void 0);
  __decorate([
    serialize()
  ], TargetCamera2.prototype, "speed", void 0);
  __decorate([
    serializeAsMeshReference("lockedTargetId")
  ], TargetCamera2.prototype, "lockedTarget", void 0);
  return TargetCamera2;
}(Camera);
function createCamera(options) {
  const { scene } = options;
  let camera;
  const cameraDistance = 36.5;
  camera = new TargetCamera("TargetCamera1", new Vector3(0, cameraDistance, 0), scene);
  camera.fov = 0.25;
  camera.minZ = 5;
  camera.maxZ = cameraDistance + 1;
  camera.setTarget(Vector3.Zero());
  return camera;
}
var ShadowLight = function(_super) {
  __extends(ShadowLight2, _super);
  function ShadowLight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._needProjectionMatrixCompute = true;
    return _this;
  }
  ShadowLight2.prototype._setPosition = function(value) {
    this._position = value;
  };
  Object.defineProperty(ShadowLight2.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(value) {
      this._setPosition(value);
    },
    enumerable: false,
    configurable: true
  });
  ShadowLight2.prototype._setDirection = function(value) {
    this._direction = value;
  };
  Object.defineProperty(ShadowLight2.prototype, "direction", {
    get: function() {
      return this._direction;
    },
    set: function(value) {
      this._setDirection(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowLight2.prototype, "shadowMinZ", {
    get: function() {
      return this._shadowMinZ;
    },
    set: function(value) {
      this._shadowMinZ = value;
      this.forceProjectionMatrixCompute();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowLight2.prototype, "shadowMaxZ", {
    get: function() {
      return this._shadowMaxZ;
    },
    set: function(value) {
      this._shadowMaxZ = value;
      this.forceProjectionMatrixCompute();
    },
    enumerable: false,
    configurable: true
  });
  ShadowLight2.prototype.computeTransformedInformation = function() {
    if (this.parent && this.parent.getWorldMatrix) {
      if (!this.transformedPosition) {
        this.transformedPosition = Vector3.Zero();
      }
      Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);
      if (this.direction) {
        if (!this.transformedDirection) {
          this.transformedDirection = Vector3.Zero();
        }
        Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);
      }
      return true;
    }
    return false;
  };
  ShadowLight2.prototype.getDepthScale = function() {
    return 50;
  };
  ShadowLight2.prototype.getShadowDirection = function(faceIndex) {
    return this.transformedDirection ? this.transformedDirection : this.direction;
  };
  ShadowLight2.prototype.getAbsolutePosition = function() {
    return this.transformedPosition ? this.transformedPosition : this.position;
  };
  ShadowLight2.prototype.setDirectionToTarget = function(target) {
    this.direction = Vector3.Normalize(target.subtract(this.position));
    return this.direction;
  };
  ShadowLight2.prototype.getRotation = function() {
    this.direction.normalize();
    var xaxis = Vector3.Cross(this.direction, Axis.Y);
    var yaxis = Vector3.Cross(xaxis, this.direction);
    return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);
  };
  ShadowLight2.prototype.needCube = function() {
    return false;
  };
  ShadowLight2.prototype.needProjectionMatrixCompute = function() {
    return this._needProjectionMatrixCompute;
  };
  ShadowLight2.prototype.forceProjectionMatrixCompute = function() {
    this._needProjectionMatrixCompute = true;
  };
  ShadowLight2.prototype._initCache = function() {
    _super.prototype._initCache.call(this);
    this._cache.position = Vector3.Zero();
  };
  ShadowLight2.prototype._isSynchronized = function() {
    if (!this._cache.position.equals(this.position)) {
      return false;
    }
    return true;
  };
  ShadowLight2.prototype.computeWorldMatrix = function(force) {
    if (!force && this.isSynchronized()) {
      this._currentRenderId = this.getScene().getRenderId();
      return this._worldMatrix;
    }
    this._updateCache();
    this._cache.position.copyFrom(this.position);
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);
    if (this.parent && this.parent.getWorldMatrix) {
      this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);
      this._markSyncedWithParent();
    }
    this._worldMatrixDeterminantIsDirty = true;
    return this._worldMatrix;
  };
  ShadowLight2.prototype.getDepthMinZ = function(activeCamera) {
    return this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
  };
  ShadowLight2.prototype.getDepthMaxZ = function(activeCamera) {
    return this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
  };
  ShadowLight2.prototype.setShadowProjectionMatrix = function(matrix, viewMatrix, renderList) {
    if (this.customProjectionMatrixBuilder) {
      this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);
    } else {
      this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);
    }
    return this;
  };
  __decorate([
    serializeAsVector3()
  ], ShadowLight2.prototype, "position", null);
  __decorate([
    serializeAsVector3()
  ], ShadowLight2.prototype, "direction", null);
  __decorate([
    serialize()
  ], ShadowLight2.prototype, "shadowMinZ", null);
  __decorate([
    serialize()
  ], ShadowLight2.prototype, "shadowMaxZ", null);
  return ShadowLight2;
}(Light);
Node.AddNodeConstructor("Light_Type_1", function(name2, scene) {
  return function() {
    return new DirectionalLight(name2, Vector3.Zero(), scene);
  };
});
var DirectionalLight = function(_super) {
  __extends(DirectionalLight2, _super);
  function DirectionalLight2(name2, direction, scene) {
    var _this = _super.call(this, name2, scene) || this;
    _this._shadowFrustumSize = 0;
    _this._shadowOrthoScale = 0.1;
    _this.autoUpdateExtends = true;
    _this.autoCalcShadowZBounds = false;
    _this._orthoLeft = Number.MAX_VALUE;
    _this._orthoRight = Number.MIN_VALUE;
    _this._orthoTop = Number.MIN_VALUE;
    _this._orthoBottom = Number.MAX_VALUE;
    _this.position = direction.scale(-1);
    _this.direction = direction;
    return _this;
  }
  Object.defineProperty(DirectionalLight2.prototype, "shadowFrustumSize", {
    get: function() {
      return this._shadowFrustumSize;
    },
    set: function(value) {
      this._shadowFrustumSize = value;
      this.forceProjectionMatrixCompute();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DirectionalLight2.prototype, "shadowOrthoScale", {
    get: function() {
      return this._shadowOrthoScale;
    },
    set: function(value) {
      this._shadowOrthoScale = value;
      this.forceProjectionMatrixCompute();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DirectionalLight2.prototype, "orthoLeft", {
    get: function() {
      return this._orthoLeft;
    },
    set: function(left) {
      this._orthoLeft = left;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DirectionalLight2.prototype, "orthoRight", {
    get: function() {
      return this._orthoRight;
    },
    set: function(right) {
      this._orthoRight = right;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DirectionalLight2.prototype, "orthoTop", {
    get: function() {
      return this._orthoTop;
    },
    set: function(top) {
      this._orthoTop = top;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DirectionalLight2.prototype, "orthoBottom", {
    get: function() {
      return this._orthoBottom;
    },
    set: function(bottom) {
      this._orthoBottom = bottom;
    },
    enumerable: false,
    configurable: true
  });
  DirectionalLight2.prototype.getClassName = function() {
    return "DirectionalLight";
  };
  DirectionalLight2.prototype.getTypeID = function() {
    return Light.LIGHTTYPEID_DIRECTIONALLIGHT;
  };
  DirectionalLight2.prototype._setDefaultShadowProjectionMatrix = function(matrix, viewMatrix, renderList) {
    if (this.shadowFrustumSize > 0) {
      this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);
    } else {
      this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);
    }
  };
  DirectionalLight2.prototype._setDefaultFixedFrustumShadowProjectionMatrix = function(matrix) {
    var activeCamera = this.getScene().activeCamera;
    if (!activeCamera) {
      return;
    }
    Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
  };
  DirectionalLight2.prototype._setDefaultAutoExtendShadowProjectionMatrix = function(matrix, viewMatrix, renderList) {
    var activeCamera = this.getScene().activeCamera;
    if (!activeCamera) {
      return;
    }
    if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
      var tempVector3 = Vector3.Zero();
      this._orthoLeft = Number.MAX_VALUE;
      this._orthoRight = Number.MIN_VALUE;
      this._orthoTop = Number.MIN_VALUE;
      this._orthoBottom = Number.MAX_VALUE;
      var shadowMinZ = Number.MAX_VALUE;
      var shadowMaxZ = Number.MIN_VALUE;
      for (var meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
        var mesh = renderList[meshIndex];
        if (!mesh) {
          continue;
        }
        var boundingInfo = mesh.getBoundingInfo();
        var boundingBox = boundingInfo.boundingBox;
        for (var index = 0; index < boundingBox.vectorsWorld.length; index++) {
          Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);
          if (tempVector3.x < this._orthoLeft) {
            this._orthoLeft = tempVector3.x;
          }
          if (tempVector3.y < this._orthoBottom) {
            this._orthoBottom = tempVector3.y;
          }
          if (tempVector3.x > this._orthoRight) {
            this._orthoRight = tempVector3.x;
          }
          if (tempVector3.y > this._orthoTop) {
            this._orthoTop = tempVector3.y;
          }
          if (this.autoCalcShadowZBounds) {
            if (tempVector3.z < shadowMinZ) {
              shadowMinZ = tempVector3.z;
            }
            if (tempVector3.z > shadowMaxZ) {
              shadowMaxZ = tempVector3.z;
            }
          }
        }
      }
      if (this.autoCalcShadowZBounds) {
        this._shadowMinZ = shadowMinZ;
        this._shadowMaxZ = shadowMaxZ;
      }
    }
    var xOffset = this._orthoRight - this._orthoLeft;
    var yOffset = this._orthoTop - this._orthoBottom;
    var minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
    var maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
    var useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
    Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
  };
  DirectionalLight2.prototype._buildUniformLayout = function() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  };
  DirectionalLight2.prototype.transferToEffect = function(effect, lightIndex) {
    if (this.computeTransformedInformation()) {
      this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);
      return this;
    }
    this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);
    return this;
  };
  DirectionalLight2.prototype.transferToNodeMaterialEffect = function(effect, lightDataUniformName) {
    if (this.computeTransformedInformation()) {
      effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);
      return this;
    }
    effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);
    return this;
  };
  DirectionalLight2.prototype.getDepthMinZ = function(activeCamera) {
    var engine = this._scene.getEngine();
    return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
  };
  DirectionalLight2.prototype.getDepthMaxZ = function(activeCamera) {
    var engine = this._scene.getEngine();
    return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
  };
  DirectionalLight2.prototype.prepareLightSpecificDefines = function(defines, lightIndex) {
    defines["DIRLIGHT" + lightIndex] = true;
  };
  __decorate([
    serialize()
  ], DirectionalLight2.prototype, "shadowFrustumSize", null);
  __decorate([
    serialize()
  ], DirectionalLight2.prototype, "shadowOrthoScale", null);
  __decorate([
    serialize()
  ], DirectionalLight2.prototype, "autoUpdateExtends", void 0);
  __decorate([
    serialize()
  ], DirectionalLight2.prototype, "autoCalcShadowZBounds", void 0);
  __decorate([
    serialize("orthoLeft")
  ], DirectionalLight2.prototype, "_orthoLeft", void 0);
  __decorate([
    serialize("orthoRight")
  ], DirectionalLight2.prototype, "_orthoRight", void 0);
  __decorate([
    serialize("orthoTop")
  ], DirectionalLight2.prototype, "_orthoTop", void 0);
  __decorate([
    serialize("orthoBottom")
  ], DirectionalLight2.prototype, "_orthoBottom", void 0);
  return DirectionalLight2;
}(ShadowLight);
Node.AddNodeConstructor("Light_Type_3", function(name2, scene) {
  return function() {
    return new HemisphericLight(name2, Vector3.Zero(), scene);
  };
});
var HemisphericLight = function(_super) {
  __extends(HemisphericLight2, _super);
  function HemisphericLight2(name2, direction, scene) {
    var _this = _super.call(this, name2, scene) || this;
    _this.groundColor = new Color3(0, 0, 0);
    _this.direction = direction || Vector3.Up();
    return _this;
  }
  HemisphericLight2.prototype._buildUniformLayout = function() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("vLightGround", 3);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  };
  HemisphericLight2.prototype.getClassName = function() {
    return "HemisphericLight";
  };
  HemisphericLight2.prototype.setDirectionToTarget = function(target) {
    this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));
    return this.direction;
  };
  HemisphericLight2.prototype.getShadowGenerator = function() {
    return null;
  };
  HemisphericLight2.prototype.transferToEffect = function(effect, lightIndex) {
    var normalizeDirection = Vector3.Normalize(this.direction);
    this._uniformBuffer.updateFloat4("vLightData", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0, lightIndex);
    this._uniformBuffer.updateColor3("vLightGround", this.groundColor.scale(this.intensity), lightIndex);
    return this;
  };
  HemisphericLight2.prototype.transferToNodeMaterialEffect = function(effect, lightDataUniformName) {
    var normalizeDirection = Vector3.Normalize(this.direction);
    effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);
    return this;
  };
  HemisphericLight2.prototype.computeWorldMatrix = function() {
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    return this._worldMatrix;
  };
  HemisphericLight2.prototype.getTypeID = function() {
    return Light.LIGHTTYPEID_HEMISPHERICLIGHT;
  };
  HemisphericLight2.prototype.prepareLightSpecificDefines = function(defines, lightIndex) {
    defines["HEMILIGHT" + lightIndex] = true;
  };
  __decorate([
    serializeAsColor3()
  ], HemisphericLight2.prototype, "groundColor", void 0);
  __decorate([
    serializeAsVector3()
  ], HemisphericLight2.prototype, "direction", void 0);
  return HemisphericLight2;
}(Light);
var ThinTexture = function() {
  function ThinTexture2(internalTexture) {
    this._wrapU = 1;
    this._wrapV = 1;
    this.wrapR = 1;
    this.anisotropicFilteringLevel = 4;
    this.delayLoadState = 0;
    this._texture = null;
    this._engine = null;
    this._cachedSize = Size.Zero();
    this._cachedBaseSize = Size.Zero();
    this._initialSamplingMode = 2;
    this._texture = internalTexture;
    if (this._texture) {
      this._engine = this._texture.getEngine();
    }
  }
  Object.defineProperty(ThinTexture2.prototype, "wrapU", {
    get: function() {
      return this._wrapU;
    },
    set: function(value) {
      this._wrapU = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "wrapV", {
    get: function() {
      return this._wrapV;
    },
    set: function(value) {
      this._wrapV = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "coordinatesMode", {
    get: function() {
      return 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "isCube", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.isCube;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.isCube = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "is3D", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.is3D;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.is3D = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "is2DArray", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.is2DArray;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.is2DArray = value;
    },
    enumerable: false,
    configurable: true
  });
  ThinTexture2.prototype.getClassName = function() {
    return "ThinTexture";
  };
  ThinTexture2.prototype.isReady = function() {
    if (this.delayLoadState === 4) {
      this.delayLoad();
      return false;
    }
    if (this._texture) {
      return this._texture.isReady;
    }
    return false;
  };
  ThinTexture2.prototype.delayLoad = function() {
  };
  ThinTexture2.prototype.getInternalTexture = function() {
    return this._texture;
  };
  ThinTexture2.prototype.getSize = function() {
    if (this._texture) {
      if (this._texture.width) {
        this._cachedSize.width = this._texture.width;
        this._cachedSize.height = this._texture.height;
        return this._cachedSize;
      }
      if (this._texture._size) {
        this._cachedSize.width = this._texture._size;
        this._cachedSize.height = this._texture._size;
        return this._cachedSize;
      }
    }
    return this._cachedSize;
  };
  ThinTexture2.prototype.getBaseSize = function() {
    if (!this.isReady() || !this._texture) {
      this._cachedBaseSize.width = 0;
      this._cachedBaseSize.height = 0;
      return this._cachedBaseSize;
    }
    if (this._texture._size) {
      this._cachedBaseSize.width = this._texture._size;
      this._cachedBaseSize.height = this._texture._size;
      return this._cachedBaseSize;
    }
    this._cachedBaseSize.width = this._texture.baseWidth;
    this._cachedBaseSize.height = this._texture.baseHeight;
    return this._cachedBaseSize;
  };
  Object.defineProperty(ThinTexture2.prototype, "samplingMode", {
    get: function() {
      if (!this._texture) {
        return this._initialSamplingMode;
      }
      return this._texture.samplingMode;
    },
    enumerable: false,
    configurable: true
  });
  ThinTexture2.prototype.updateSamplingMode = function(samplingMode) {
    if (this._texture && this._engine) {
      this._engine.updateTextureSamplingMode(samplingMode, this._texture);
    }
  };
  ThinTexture2.prototype.releaseInternalTexture = function() {
    if (this._texture) {
      this._texture.dispose();
      this._texture = null;
    }
  };
  ThinTexture2.prototype.dispose = function() {
    if (this._texture) {
      this.releaseInternalTexture();
      this._engine = null;
    }
  };
  return ThinTexture2;
}();
var BaseTexture = function(_super) {
  __extends(BaseTexture2, _super);
  function BaseTexture2(sceneOrEngine) {
    var _this = _super.call(this, null) || this;
    _this.metadata = null;
    _this.reservedDataStore = null;
    _this._hasAlpha = false;
    _this._getAlphaFromRGB = false;
    _this.level = 1;
    _this._coordinatesIndex = 0;
    _this._coordinatesMode = 0;
    _this.wrapR = 1;
    _this.anisotropicFilteringLevel = BaseTexture2.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;
    _this._isCube = false;
    _this._gammaSpace = true;
    _this.invertZ = false;
    _this.lodLevelInAlpha = false;
    _this.isRenderTarget = false;
    _this._prefiltered = false;
    _this._forceSerialize = false;
    _this.animations = new Array();
    _this.onDisposeObservable = new Observable();
    _this._onDisposeObserver = null;
    _this._scene = null;
    _this._uid = null;
    _this._parentContainer = null;
    _this._loadingError = false;
    if (sceneOrEngine) {
      if (BaseTexture2._isScene(sceneOrEngine)) {
        _this._scene = sceneOrEngine;
      } else {
        _this._engine = sceneOrEngine;
      }
    } else {
      _this._scene = EngineStore.LastCreatedScene;
    }
    if (_this._scene) {
      _this.uniqueId = _this._scene.getUniqueId();
      _this._scene.addTexture(_this);
      _this._engine = _this._scene.getEngine();
    }
    _this._uid = null;
    return _this;
  }
  Object.defineProperty(BaseTexture2.prototype, "hasAlpha", {
    get: function() {
      return this._hasAlpha;
    },
    set: function(value) {
      var _this = this;
      if (this._hasAlpha === value) {
        return;
      }
      this._hasAlpha = value;
      if (this._scene) {
        this._scene.markAllMaterialsAsDirty(1, function(mat) {
          return mat.hasTexture(_this);
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "getAlphaFromRGB", {
    get: function() {
      return this._getAlphaFromRGB;
    },
    set: function(value) {
      var _this = this;
      if (this._getAlphaFromRGB === value) {
        return;
      }
      this._getAlphaFromRGB = value;
      if (this._scene) {
        this._scene.markAllMaterialsAsDirty(1, function(mat) {
          return mat.hasTexture(_this);
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "coordinatesIndex", {
    get: function() {
      return this._coordinatesIndex;
    },
    set: function(value) {
      var _this = this;
      if (this._coordinatesIndex === value) {
        return;
      }
      this._coordinatesIndex = value;
      if (this._scene) {
        this._scene.markAllMaterialsAsDirty(1, function(mat) {
          return mat.hasTexture(_this);
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "coordinatesMode", {
    get: function() {
      return this._coordinatesMode;
    },
    set: function(value) {
      var _this = this;
      if (this._coordinatesMode === value) {
        return;
      }
      this._coordinatesMode = value;
      if (this._scene) {
        this._scene.markAllMaterialsAsDirty(1, function(mat) {
          return mat.hasTexture(_this);
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "wrapU", {
    get: function() {
      return this._wrapU;
    },
    set: function(value) {
      this._wrapU = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "wrapV", {
    get: function() {
      return this._wrapV;
    },
    set: function(value) {
      this._wrapV = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "isCube", {
    get: function() {
      if (!this._texture) {
        return this._isCube;
      }
      return this._texture.isCube;
    },
    set: function(value) {
      if (!this._texture) {
        this._isCube = value;
      } else {
        this._texture.isCube = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "is3D", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.is3D;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.is3D = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "is2DArray", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.is2DArray;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.is2DArray = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "gammaSpace", {
    get: function() {
      if (!this._texture) {
        return this._gammaSpace;
      } else {
        if (this._texture._gammaSpace === null) {
          this._texture._gammaSpace = this._gammaSpace;
        }
      }
      return this._texture._gammaSpace && !this._texture._useSRGBBuffer;
    },
    set: function(gamma) {
      if (!this._texture) {
        if (this._gammaSpace === gamma) {
          return;
        }
        this._gammaSpace = gamma;
      } else {
        if (this._texture._gammaSpace === gamma) {
          return;
        }
        this._texture._gammaSpace = gamma;
      }
      this._markAllSubMeshesAsTexturesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "isRGBD", {
    get: function() {
      return this._texture != null && this._texture._isRGBD;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._isRGBD = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "noMipmap", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "lodGenerationOffset", {
    get: function() {
      if (this._texture) {
        return this._texture._lodGenerationOffset;
      }
      return 0;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._lodGenerationOffset = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "lodGenerationScale", {
    get: function() {
      if (this._texture) {
        return this._texture._lodGenerationScale;
      }
      return 0;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._lodGenerationScale = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "linearSpecularLOD", {
    get: function() {
      if (this._texture) {
        return this._texture._linearSpecularLOD;
      }
      return false;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._linearSpecularLOD = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "irradianceTexture", {
    get: function() {
      if (this._texture) {
        return this._texture._irradianceTexture;
      }
      return null;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._irradianceTexture = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "uid", {
    get: function() {
      if (!this._uid) {
        this._uid = RandomGUID();
      }
      return this._uid;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype.toString = function() {
    return this.name;
  };
  BaseTexture2.prototype.getClassName = function() {
    return "BaseTexture";
  };
  Object.defineProperty(BaseTexture2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "isBlocking", {
    get: function() {
      return true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "loadingError", {
    get: function() {
      return this._loadingError;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "errorObject", {
    get: function() {
      return this._errorObject;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype.getScene = function() {
    return this._scene;
  };
  BaseTexture2.prototype._getEngine = function() {
    return this._engine;
  };
  BaseTexture2.prototype.checkTransformsAreIdentical = function(texture) {
    return texture !== null;
  };
  BaseTexture2.prototype.getTextureMatrix = function() {
    return Matrix.IdentityReadOnly;
  };
  BaseTexture2.prototype.getReflectionTextureMatrix = function() {
    return Matrix.IdentityReadOnly;
  };
  BaseTexture2.prototype.isReadyOrNotBlocking = function() {
    return !this.isBlocking || this.isReady() || this.loadingError;
  };
  BaseTexture2.prototype.scale = function(ratio) {
  };
  Object.defineProperty(BaseTexture2.prototype, "canRescale", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype._getFromCache = function(url, noMipmap, sampling, invertY, useSRGBBuffer) {
    var engine = this._getEngine();
    if (!engine) {
      return null;
    }
    var correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);
    var texturesCache = engine.getLoadedTexturesCache();
    for (var index = 0; index < texturesCache.length; index++) {
      var texturesCacheEntry = texturesCache[index];
      if (useSRGBBuffer === void 0 || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {
        if (invertY === void 0 || invertY === texturesCacheEntry.invertY) {
          if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {
            if (!sampling || sampling === texturesCacheEntry.samplingMode) {
              texturesCacheEntry.incrementReferences();
              return texturesCacheEntry;
            }
          }
        }
      }
    }
    return null;
  };
  BaseTexture2.prototype._rebuild = function() {
  };
  BaseTexture2.prototype.clone = function() {
    return null;
  };
  Object.defineProperty(BaseTexture2.prototype, "textureType", {
    get: function() {
      if (!this._texture) {
        return 0;
      }
      return this._texture.type !== void 0 ? this._texture.type : 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "textureFormat", {
    get: function() {
      if (!this._texture) {
        return 5;
      }
      return this._texture.format !== void 0 ? this._texture.format : 5;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype._markAllSubMeshesAsTexturesDirty = function() {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    scene.markAllMaterialsAsDirty(1);
  };
  BaseTexture2.prototype.readPixels = function(faceIndex, level, buffer, flushRenderer, noDataConversion) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (level === void 0) {
      level = 0;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (flushRenderer === void 0) {
      flushRenderer = true;
    }
    if (noDataConversion === void 0) {
      noDataConversion = false;
    }
    if (!this._texture) {
      return null;
    }
    var size = this.getSize();
    var width = size.width;
    var height = size.height;
    var engine = this._getEngine();
    if (!engine) {
      return null;
    }
    if (level != 0) {
      width = width / Math.pow(2, level);
      height = height / Math.pow(2, level);
      width = Math.round(width);
      height = Math.round(height);
    }
    try {
      if (this._texture.isCube) {
        return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);
      }
      return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);
    } catch (e) {
      return null;
    }
  };
  BaseTexture2.prototype._readPixelsSync = function(faceIndex, level, buffer, flushRenderer, noDataConversion) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (level === void 0) {
      level = 0;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (flushRenderer === void 0) {
      flushRenderer = true;
    }
    if (noDataConversion === void 0) {
      noDataConversion = false;
    }
    if (!this._texture) {
      return null;
    }
    var size = this.getSize();
    var width = size.width;
    var height = size.height;
    var engine = this._getEngine();
    if (!engine) {
      return null;
    }
    if (level != 0) {
      width = width / Math.pow(2, level);
      height = height / Math.pow(2, level);
      width = Math.round(width);
      height = Math.round(height);
    }
    try {
      if (this._texture.isCube) {
        return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);
      }
      return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);
    } catch (e) {
      return null;
    }
  };
  Object.defineProperty(BaseTexture2.prototype, "_lodTextureHigh", {
    get: function() {
      if (this._texture) {
        return this._texture._lodTextureHigh;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "_lodTextureMid", {
    get: function() {
      if (this._texture) {
        return this._texture._lodTextureMid;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "_lodTextureLow", {
    get: function() {
      if (this._texture) {
        return this._texture._lodTextureLow;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype.dispose = function() {
    if (this._scene) {
      if (this._scene.stopAnimation) {
        this._scene.stopAnimation(this);
      }
      this._scene._removePendingData(this);
      var index = this._scene.textures.indexOf(this);
      if (index >= 0) {
        this._scene.textures.splice(index, 1);
      }
      this._scene.onTextureRemovedObservable.notifyObservers(this);
      this._scene = null;
      if (this._parentContainer) {
        var index_1 = this._parentContainer.textures.indexOf(this);
        if (index_1 > -1) {
          this._parentContainer.textures.splice(index_1, 1);
        }
        this._parentContainer = null;
      }
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.metadata = null;
    _super.prototype.dispose.call(this);
  };
  BaseTexture2.prototype.serialize = function() {
    if (!this.name) {
      return null;
    }
    var serializationObject = SerializationHelper.Serialize(this);
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    return serializationObject;
  };
  BaseTexture2.WhenAllReady = function(textures, callback) {
    var numRemaining = textures.length;
    if (numRemaining === 0) {
      callback();
      return;
    }
    for (var i = 0; i < textures.length; i++) {
      var texture = textures[i];
      if (texture.isReady()) {
        if (--numRemaining === 0) {
          callback();
        }
      } else {
        var onLoadObservable = texture.onLoadObservable;
        if (onLoadObservable) {
          onLoadObservable.addOnce(function() {
            if (--numRemaining === 0) {
              callback();
            }
          });
        }
      }
    }
  };
  BaseTexture2._isScene = function(sceneOrEngine) {
    return sceneOrEngine.getClassName() === "Scene";
  };
  BaseTexture2.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "uniqueId", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "name", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "metadata", void 0);
  __decorate([
    serialize("hasAlpha")
  ], BaseTexture2.prototype, "_hasAlpha", void 0);
  __decorate([
    serialize("getAlphaFromRGB")
  ], BaseTexture2.prototype, "_getAlphaFromRGB", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "level", void 0);
  __decorate([
    serialize("coordinatesIndex")
  ], BaseTexture2.prototype, "_coordinatesIndex", void 0);
  __decorate([
    serialize("coordinatesMode")
  ], BaseTexture2.prototype, "_coordinatesMode", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "wrapU", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "wrapV", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "wrapR", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "anisotropicFilteringLevel", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "isCube", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "is3D", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "is2DArray", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "gammaSpace", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "invertZ", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "lodLevelInAlpha", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "lodGenerationOffset", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "lodGenerationScale", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "linearSpecularLOD", null);
  __decorate([
    serializeAsTexture()
  ], BaseTexture2.prototype, "irradianceTexture", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "isRenderTarget", void 0);
  return BaseTexture2;
}(ThinTexture);
function GenerateBase64StringFromPixelData(pixels, size, invertY) {
  if (invertY === void 0) {
    invertY = false;
  }
  var width = size.width;
  var height = size.height;
  if (pixels instanceof Float32Array) {
    var len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;
    var npixels = new Uint8Array(len);
    while (--len >= 0) {
      var val = pixels[len];
      if (val < 0) {
        val = 0;
      } else if (val > 1) {
        val = 1;
      }
      npixels[len] = val * 255;
    }
    pixels = npixels;
  }
  var canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return null;
  }
  var imageData = ctx.createImageData(width, height);
  var castData = imageData.data;
  castData.set(pixels);
  ctx.putImageData(imageData, 0, 0);
  if (invertY) {
    var canvas2 = document.createElement("canvas");
    canvas2.width = width;
    canvas2.height = height;
    var ctx2 = canvas2.getContext("2d");
    if (!ctx2) {
      return null;
    }
    ctx2.translate(0, height);
    ctx2.scale(1, -1);
    ctx2.drawImage(canvas, 0, 0);
    return canvas2.toDataURL("image/png");
  }
  return canvas.toDataURL("image/png");
}
function GenerateBase64StringFromTexture(texture, faceIndex, level) {
  if (faceIndex === void 0) {
    faceIndex = 0;
  }
  if (level === void 0) {
    level = 0;
  }
  var internalTexture = texture.getInternalTexture();
  if (!internalTexture) {
    return null;
  }
  var pixels = texture._readPixelsSync(faceIndex, level);
  if (!pixels) {
    return null;
  }
  return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);
}
function GenerateBase64StringFromTextureAsync(texture, faceIndex, level) {
  if (faceIndex === void 0) {
    faceIndex = 0;
  }
  if (level === void 0) {
    level = 0;
  }
  return __awaiter(this, void 0, void 0, function() {
    var internalTexture, pixels;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          internalTexture = texture.getInternalTexture();
          if (!internalTexture) {
            return [2, null];
          }
          return [4, texture.readPixels(faceIndex, level)];
        case 1:
          pixels = _a.sent();
          if (!pixels) {
            return [2, null];
          }
          return [2, GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY)];
      }
    });
  });
}
var Texture = function(_super) {
  __extends(Texture2, _super);
  function Texture2(url, sceneOrEngine, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, mimeType, loaderOptions, creationFlags) {
    if (samplingMode === void 0) {
      samplingMode = Texture2.TRILINEAR_SAMPLINGMODE;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (deleteBuffer === void 0) {
      deleteBuffer = false;
    }
    var _a, _b, _c, _d, _e, _f, _g, _h;
    var _this = _super.call(this, sceneOrEngine) || this;
    _this.url = null;
    _this.uOffset = 0;
    _this.vOffset = 0;
    _this.uScale = 1;
    _this.vScale = 1;
    _this.uAng = 0;
    _this.vAng = 0;
    _this.wAng = 0;
    _this.uRotationCenter = 0.5;
    _this.vRotationCenter = 0.5;
    _this.wRotationCenter = 0.5;
    _this.homogeneousRotationInUVTransform = false;
    _this.inspectableCustomProperties = null;
    _this._noMipmap = false;
    _this._invertY = false;
    _this._rowGenerationMatrix = null;
    _this._cachedTextureMatrix = null;
    _this._projectionModeMatrix = null;
    _this._t0 = null;
    _this._t1 = null;
    _this._t2 = null;
    _this._cachedUOffset = -1;
    _this._cachedVOffset = -1;
    _this._cachedUScale = 0;
    _this._cachedVScale = 0;
    _this._cachedUAng = -1;
    _this._cachedVAng = -1;
    _this._cachedWAng = -1;
    _this._cachedProjectionMatrixId = -1;
    _this._cachedURotationCenter = -1;
    _this._cachedVRotationCenter = -1;
    _this._cachedWRotationCenter = -1;
    _this._cachedHomogeneousRotationInUVTransform = false;
    _this._cachedCoordinatesMode = -1;
    _this._buffer = null;
    _this._deleteBuffer = false;
    _this._format = null;
    _this._delayedOnLoad = null;
    _this._delayedOnError = null;
    _this.onLoadObservable = new Observable();
    _this._isBlocking = true;
    _this.name = url || "";
    _this.url = url;
    var noMipmap;
    var useSRGBBuffer = false;
    if (typeof noMipmapOrOptions === "object" && noMipmapOrOptions !== null) {
      noMipmap = (_a = noMipmapOrOptions.noMipmap) !== null && _a !== void 0 ? _a : false;
      invertY = (_b = noMipmapOrOptions.invertY) !== null && _b !== void 0 ? _b : CompatibilityOptions.UseOpenGLOrientationForUV ? false : true;
      samplingMode = (_c = noMipmapOrOptions.samplingMode) !== null && _c !== void 0 ? _c : Texture2.TRILINEAR_SAMPLINGMODE;
      onLoad = (_d = noMipmapOrOptions.onLoad) !== null && _d !== void 0 ? _d : null;
      onError = (_e = noMipmapOrOptions.onError) !== null && _e !== void 0 ? _e : null;
      buffer = (_f = noMipmapOrOptions.buffer) !== null && _f !== void 0 ? _f : null;
      deleteBuffer = (_g = noMipmapOrOptions.deleteBuffer) !== null && _g !== void 0 ? _g : false;
      format = noMipmapOrOptions.format;
      mimeType = noMipmapOrOptions.mimeType;
      loaderOptions = noMipmapOrOptions.loaderOptions;
      creationFlags = noMipmapOrOptions.creationFlags;
      useSRGBBuffer = (_h = noMipmapOrOptions.useSRGBBuffer) !== null && _h !== void 0 ? _h : false;
    } else {
      noMipmap = !!noMipmapOrOptions;
    }
    _this._noMipmap = noMipmap;
    _this._invertY = invertY === void 0 ? CompatibilityOptions.UseOpenGLOrientationForUV ? false : true : invertY;
    _this._initialSamplingMode = samplingMode;
    _this._buffer = buffer;
    _this._deleteBuffer = deleteBuffer;
    _this._mimeType = mimeType;
    _this._loaderOptions = loaderOptions;
    _this._creationFlags = creationFlags;
    _this._useSRGBBuffer = useSRGBBuffer;
    if (format) {
      _this._format = format;
    }
    var scene = _this.getScene();
    var engine = _this._getEngine();
    if (!engine) {
      return _this;
    }
    engine.onBeforeTextureInitObservable.notifyObservers(_this);
    var load = function() {
      if (_this._texture) {
        if (_this._texture._invertVScale) {
          _this.vScale *= -1;
          _this.vOffset += 1;
        }
        if (_this._texture._cachedWrapU !== null) {
          _this.wrapU = _this._texture._cachedWrapU;
          _this._texture._cachedWrapU = null;
        }
        if (_this._texture._cachedWrapV !== null) {
          _this.wrapV = _this._texture._cachedWrapV;
          _this._texture._cachedWrapV = null;
        }
        if (_this._texture._cachedWrapR !== null) {
          _this.wrapR = _this._texture._cachedWrapR;
          _this._texture._cachedWrapR = null;
        }
      }
      if (_this.onLoadObservable.hasObservers()) {
        _this.onLoadObservable.notifyObservers(_this);
      }
      if (onLoad) {
        onLoad();
      }
      if (!_this.isBlocking && scene) {
        scene.resetCachedMaterial();
      }
    };
    var errorHandler = function(message, exception) {
      _this._loadingError = true;
      _this._errorObject = { message, exception };
      if (onError) {
        onError(message, exception);
      }
      Texture2.OnTextureLoadErrorObservable.notifyObservers(_this);
    };
    if (!_this.url) {
      _this._delayedOnLoad = load;
      _this._delayedOnError = errorHandler;
      return _this;
    }
    _this._texture = _this._getFromCache(_this.url, noMipmap, samplingMode, _this._invertY, useSRGBBuffer);
    if (!_this._texture) {
      if (!scene || !scene.useDelayedTextureLoading) {
        try {
          _this._texture = engine.createTexture(_this.url, noMipmap, _this._invertY, scene, samplingMode, load, errorHandler, _this._buffer, void 0, _this._format, null, mimeType, loaderOptions, creationFlags, useSRGBBuffer);
        } catch (e) {
          errorHandler("error loading", e);
          throw e;
        }
        if (deleteBuffer) {
          _this._buffer = null;
        }
      } else {
        _this.delayLoadState = 4;
        _this._delayedOnLoad = load;
        _this._delayedOnError = errorHandler;
      }
    } else {
      if (_this._texture.isReady) {
        TimingTools.SetImmediate(function() {
          return load();
        });
      } else {
        var loadObserver_1 = _this._texture.onLoadedObservable.add(load);
        _this._texture.onErrorObservable.add(function(e) {
          var _a2;
          errorHandler(e.message, e.exception);
          (_a2 = _this._texture) === null || _a2 === void 0 ? void 0 : _a2.onLoadedObservable.remove(loadObserver_1);
        });
      }
    }
    return _this;
  }
  Object.defineProperty(Texture2.prototype, "noMipmap", {
    get: function() {
      return this._noMipmap;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "mimeType", {
    get: function() {
      return this._mimeType;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "isBlocking", {
    get: function() {
      return this._isBlocking;
    },
    set: function(value) {
      this._isBlocking = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "invertY", {
    get: function() {
      return this._invertY;
    },
    enumerable: false,
    configurable: true
  });
  Texture2.prototype.updateURL = function(url, buffer, onLoad) {
    if (buffer === void 0) {
      buffer = null;
    }
    if (this.url) {
      this.releaseInternalTexture();
      this.getScene().markAllMaterialsAsDirty(1);
    }
    if (!this.name || StartsWith(this.name, "data:")) {
      this.name = url;
    }
    this.url = url;
    this._buffer = buffer;
    this.delayLoadState = 4;
    if (onLoad) {
      this._delayedOnLoad = onLoad;
    }
    this.delayLoad();
  };
  Texture2.prototype.delayLoad = function() {
    if (this.delayLoadState !== 4) {
      return;
    }
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    this.delayLoadState = 1;
    this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer);
    if (!this._texture) {
      this._texture = scene.getEngine().createTexture(this.url, this._noMipmap, this._invertY, scene, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, null, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer);
      if (this._deleteBuffer) {
        this._buffer = null;
      }
    } else {
      if (this._delayedOnLoad) {
        if (this._texture.isReady) {
          TimingTools.SetImmediate(this._delayedOnLoad);
        } else {
          this._texture.onLoadedObservable.add(this._delayedOnLoad);
        }
      }
    }
    this._delayedOnLoad = null;
    this._delayedOnError = null;
  };
  Texture2.prototype._prepareRowForTextureGeneration = function(x, y, z, t) {
    x *= this._cachedUScale;
    y *= this._cachedVScale;
    x -= this.uRotationCenter * this._cachedUScale;
    y -= this.vRotationCenter * this._cachedVScale;
    z -= this.wRotationCenter;
    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix, t);
    t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;
    t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;
    t.z += this.wRotationCenter;
  };
  Texture2.prototype.checkTransformsAreIdentical = function(texture) {
    return texture !== null && this.uOffset === texture.uOffset && this.vOffset === texture.vOffset && this.uScale === texture.uScale && this.vScale === texture.vScale && this.uAng === texture.uAng && this.vAng === texture.vAng && this.wAng === texture.wAng;
  };
  Texture2.prototype.getTextureMatrix = function(uBase) {
    var _this = this;
    if (uBase === void 0) {
      uBase = 1;
    }
    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * uBase === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) {
      return this._cachedTextureMatrix;
    }
    this._cachedUOffset = this.uOffset;
    this._cachedVOffset = this.vOffset;
    this._cachedUScale = this.uScale * uBase;
    this._cachedVScale = this.vScale;
    this._cachedUAng = this.uAng;
    this._cachedVAng = this.vAng;
    this._cachedWAng = this.wAng;
    this._cachedURotationCenter = this.uRotationCenter;
    this._cachedVRotationCenter = this.vRotationCenter;
    this._cachedWRotationCenter = this.wRotationCenter;
    this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;
    if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {
      this._cachedTextureMatrix = Matrix.Zero();
      this._rowGenerationMatrix = new Matrix();
      this._t0 = Vector3.Zero();
      this._t1 = Vector3.Zero();
      this._t2 = Vector3.Zero();
    }
    Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix);
    if (this.homogeneousRotationInUVTransform) {
      Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);
      Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);
      Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);
      Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);
      TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);
      this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);
    } else {
      this._prepareRowForTextureGeneration(0, 0, 0, this._t0);
      this._prepareRowForTextureGeneration(1, 0, 0, this._t1);
      this._prepareRowForTextureGeneration(0, 1, 0, this._t2);
      this._t1.subtractInPlace(this._t0);
      this._t2.subtractInPlace(this._t0);
      Matrix.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0, this._t2.x, this._t2.y, this._t2.z, 0, this._t0.x, this._t0.y, this._t0.z, 0, 0, 0, 0, 1, this._cachedTextureMatrix);
    }
    var scene = this.getScene();
    if (!scene) {
      return this._cachedTextureMatrix;
    }
    scene.markAllMaterialsAsDirty(1, function(mat) {
      return mat.hasTexture(_this);
    });
    return this._cachedTextureMatrix;
  };
  Texture2.prototype.getReflectionTextureMatrix = function() {
    var _this = this;
    var scene = this.getScene();
    if (!scene) {
      return this._cachedTextureMatrix;
    }
    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale === this._cachedUScale && this.vScale === this._cachedVScale && this.coordinatesMode === this._cachedCoordinatesMode) {
      if (this.coordinatesMode === Texture2.PROJECTION_MODE) {
        if (this._cachedProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {
          return this._cachedTextureMatrix;
        }
      } else {
        return this._cachedTextureMatrix;
      }
    }
    if (!this._cachedTextureMatrix) {
      this._cachedTextureMatrix = Matrix.Zero();
    }
    if (!this._projectionModeMatrix) {
      this._projectionModeMatrix = Matrix.Zero();
    }
    var flagMaterialsAsTextureDirty = this._cachedCoordinatesMode !== this.coordinatesMode;
    this._cachedUOffset = this.uOffset;
    this._cachedVOffset = this.vOffset;
    this._cachedUScale = this.uScale;
    this._cachedVScale = this.vScale;
    this._cachedCoordinatesMode = this.coordinatesMode;
    switch (this.coordinatesMode) {
      case Texture2.PLANAR_MODE:
        Matrix.IdentityToRef(this._cachedTextureMatrix);
        this._cachedTextureMatrix[0] = this.uScale;
        this._cachedTextureMatrix[5] = this.vScale;
        this._cachedTextureMatrix[12] = this.uOffset;
        this._cachedTextureMatrix[13] = this.vOffset;
        break;
      case Texture2.PROJECTION_MODE:
        Matrix.FromValuesToRef(0.5, 0, 0, 0, 0, -0.5, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, this._projectionModeMatrix);
        var projectionMatrix = scene.getProjectionMatrix();
        this._cachedProjectionMatrixId = projectionMatrix.updateFlag;
        projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);
        break;
      default:
        Matrix.IdentityToRef(this._cachedTextureMatrix);
        break;
    }
    if (flagMaterialsAsTextureDirty) {
      scene.markAllMaterialsAsDirty(1, function(mat) {
        return mat.getActiveTextures().indexOf(_this) !== -1;
      });
    }
    return this._cachedTextureMatrix;
  };
  Texture2.prototype.clone = function() {
    var _this = this;
    var options = {
      noMipmap: this._noMipmap,
      invertY: this._invertY,
      samplingMode: this.samplingMode,
      onLoad: void 0,
      onError: void 0,
      buffer: this._texture ? this._texture._buffer : void 0,
      deleteBuffer: this._deleteBuffer,
      format: this.textureFormat,
      mimeType: this.mimeType,
      loaderOptions: this._loaderOptions,
      creationFlags: this._creationFlags,
      useSRGBBuffer: this._useSRGBBuffer
    };
    return SerializationHelper.Clone(function() {
      return new Texture2(_this._texture ? _this._texture.url : null, _this.getScene(), options);
    }, this);
  };
  Texture2.prototype.serialize = function() {
    var savedName = this.name;
    if (!Texture2.SerializeBuffers) {
      if (StartsWith(this.name, "data:")) {
        this.name = "";
      }
    }
    if (StartsWith(this.name, "data:") && this.url === this.name) {
      this.url = "";
    }
    var serializationObject = _super.prototype.serialize.call(this);
    if (!serializationObject) {
      return null;
    }
    if (Texture2.SerializeBuffers || Texture2.ForceSerializeBuffers) {
      if (typeof this._buffer === "string" && this._buffer.substr(0, 5) === "data:") {
        serializationObject.base64String = this._buffer;
        serializationObject.name = serializationObject.name.replace("data:", "");
      } else if (this.url && StartsWith(this.url, "data:") && this._buffer instanceof Uint8Array) {
        serializationObject.base64String = "data:image/png;base64," + EncodeArrayBufferToBase64(this._buffer);
      } else if (Texture2.ForceSerializeBuffers || this.url && StartsWith(this.url, "blob:") || this._forceSerialize) {
        serializationObject.base64String = !this._engine || this._engine._features.supportSyncTextureRead ? GenerateBase64StringFromTexture(this) : GenerateBase64StringFromTextureAsync(this);
      }
    }
    serializationObject.invertY = this._invertY;
    serializationObject.samplingMode = this.samplingMode;
    serializationObject._creationFlags = this._creationFlags;
    serializationObject._useSRGBBuffer = this._useSRGBBuffer;
    this.name = savedName;
    return serializationObject;
  };
  Texture2.prototype.getClassName = function() {
    return "Texture";
  };
  Texture2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onLoadObservable.clear();
    this._delayedOnLoad = null;
    this._delayedOnError = null;
  };
  Texture2.Parse = function(parsedTexture, scene, rootUrl) {
    if (parsedTexture.customType) {
      var customTexture = InstantiationTools.Instantiate(parsedTexture.customType);
      var parsedCustomTexture = customTexture.Parse(parsedTexture, scene, rootUrl);
      if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {
        if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {
          parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);
        }
      }
      return parsedCustomTexture;
    }
    if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {
      return Texture2._CubeTextureParser(parsedTexture, scene, rootUrl);
    }
    if (!parsedTexture.name && !parsedTexture.isRenderTarget) {
      return null;
    }
    var onLoaded = function() {
      if (texture && texture._texture) {
        texture._texture._cachedWrapU = null;
        texture._texture._cachedWrapV = null;
        texture._texture._cachedWrapR = null;
      }
      if (parsedTexture.samplingMode) {
        var sampling = parsedTexture.samplingMode;
        if (texture && texture.samplingMode !== sampling) {
          texture.updateSamplingMode(sampling);
        }
      }
      if (texture && parsedTexture.animations) {
        for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
          var parsedAnimation = parsedTexture.animations[animationIndex];
          var internalClass = GetClass("BABYLON.Animation");
          if (internalClass) {
            texture.animations.push(internalClass.Parse(parsedAnimation));
          }
        }
      }
    };
    var texture = SerializationHelper.Parse(function() {
      var _a, _b, _c;
      var generateMipMaps = true;
      if (parsedTexture.noMipmap) {
        generateMipMaps = false;
      }
      if (parsedTexture.mirrorPlane) {
        var mirrorTexture = Texture2._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);
        mirrorTexture._waitingRenderList = parsedTexture.renderList;
        mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);
        onLoaded();
        return mirrorTexture;
      } else if (parsedTexture.isRenderTarget) {
        var renderTargetTexture = null;
        if (parsedTexture.isCube) {
          if (scene.reflectionProbes) {
            for (var index = 0; index < scene.reflectionProbes.length; index++) {
              var probe = scene.reflectionProbes[index];
              if (probe.name === parsedTexture.name) {
                return probe.cubeTexture;
              }
            }
          }
        } else {
          renderTargetTexture = Texture2._CreateRenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps, (_a = parsedTexture._creationFlags) !== null && _a !== void 0 ? _a : 0);
          renderTargetTexture._waitingRenderList = parsedTexture.renderList;
        }
        onLoaded();
        return renderTargetTexture;
      } else {
        var texture2;
        if (parsedTexture.base64String) {
          texture2 = Texture2.CreateFromBase64String(parsedTexture.base64String, parsedTexture.name, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, onLoaded, (_b = parsedTexture._creationFlags) !== null && _b !== void 0 ? _b : 0, (_c = parsedTexture._useSRGBBuffer) !== null && _c !== void 0 ? _c : false);
        } else {
          var url = void 0;
          if (parsedTexture.name && parsedTexture.name.indexOf("://") > 0) {
            url = parsedTexture.name;
          } else {
            url = rootUrl + parsedTexture.name;
          }
          if (StartsWith(parsedTexture.url, "data:") || Texture2.UseSerializedUrlIfAny && parsedTexture.url) {
            url = parsedTexture.url;
          }
          texture2 = new Texture2(url, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, onLoaded);
        }
        return texture2;
      }
    }, parsedTexture, scene);
    return texture;
  };
  Texture2.CreateFromBase64String = function(data, name2, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, format, creationFlags) {
    if (samplingMode === void 0) {
      samplingMode = Texture2.TRILINEAR_SAMPLINGMODE;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (format === void 0) {
      format = 5;
    }
    return new Texture2("data:" + name2, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, data, false, format, void 0, void 0, creationFlags);
  };
  Texture2.LoadFromDataString = function(name2, buffer, scene, deleteBuffer, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, format, creationFlags) {
    if (deleteBuffer === void 0) {
      deleteBuffer = false;
    }
    if (invertY === void 0) {
      invertY = true;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture2.TRILINEAR_SAMPLINGMODE;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (format === void 0) {
      format = 5;
    }
    if (name2.substr(0, 5) !== "data:") {
      name2 = "data:" + name2;
    }
    return new Texture2(name2, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, void 0, void 0, creationFlags);
  };
  Texture2.SerializeBuffers = true;
  Texture2.ForceSerializeBuffers = false;
  Texture2.OnTextureLoadErrorObservable = new Observable();
  Texture2._CubeTextureParser = function(jsonTexture, scene, rootUrl) {
    throw _WarnImport("CubeTexture");
  };
  Texture2._CreateMirror = function(name2, renderTargetSize, scene, generateMipMaps) {
    throw _WarnImport("MirrorTexture");
  };
  Texture2._CreateRenderTargetTexture = function(name2, renderTargetSize, scene, generateMipMaps, creationFlags) {
    throw _WarnImport("RenderTargetTexture");
  };
  Texture2.NEAREST_SAMPLINGMODE = 1;
  Texture2.NEAREST_NEAREST_MIPLINEAR = 8;
  Texture2.BILINEAR_SAMPLINGMODE = 2;
  Texture2.LINEAR_LINEAR_MIPNEAREST = 11;
  Texture2.TRILINEAR_SAMPLINGMODE = 3;
  Texture2.LINEAR_LINEAR_MIPLINEAR = 3;
  Texture2.NEAREST_NEAREST_MIPNEAREST = 4;
  Texture2.NEAREST_LINEAR_MIPNEAREST = 5;
  Texture2.NEAREST_LINEAR_MIPLINEAR = 6;
  Texture2.NEAREST_LINEAR = 7;
  Texture2.NEAREST_NEAREST = 1;
  Texture2.LINEAR_NEAREST_MIPNEAREST = 9;
  Texture2.LINEAR_NEAREST_MIPLINEAR = 10;
  Texture2.LINEAR_LINEAR = 2;
  Texture2.LINEAR_NEAREST = 12;
  Texture2.EXPLICIT_MODE = 0;
  Texture2.SPHERICAL_MODE = 1;
  Texture2.PLANAR_MODE = 2;
  Texture2.CUBIC_MODE = 3;
  Texture2.PROJECTION_MODE = 4;
  Texture2.SKYBOX_MODE = 5;
  Texture2.INVCUBIC_MODE = 6;
  Texture2.EQUIRECTANGULAR_MODE = 7;
  Texture2.FIXED_EQUIRECTANGULAR_MODE = 8;
  Texture2.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
  Texture2.CLAMP_ADDRESSMODE = 0;
  Texture2.WRAP_ADDRESSMODE = 1;
  Texture2.MIRROR_ADDRESSMODE = 2;
  Texture2.UseSerializedUrlIfAny = false;
  __decorate([
    serialize()
  ], Texture2.prototype, "url", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "uOffset", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "vOffset", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "uScale", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "vScale", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "uAng", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "vAng", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "wAng", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "uRotationCenter", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "vRotationCenter", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "wRotationCenter", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "homogeneousRotationInUVTransform", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "isBlocking", null);
  return Texture2;
}(BaseTexture);
RegisterClass("BABYLON.Texture", Texture);
SerializationHelper._TextureParser = Texture.Parse;
var RenderTargetWrapper = function() {
  function RenderTargetWrapper2(isMulti, isCube, size, engine) {
    this._textures = null;
    this._attachments = null;
    this._generateStencilBuffer = false;
    this._generateDepthBuffer = false;
    this._depthStencilTextureWithStencil = false;
    this._isMulti = isMulti;
    this._isCube = isCube;
    this._size = size;
    this._engine = engine;
    this._depthStencilTexture = null;
  }
  Object.defineProperty(RenderTargetWrapper2.prototype, "depthStencilTexture", {
    get: function() {
      return this._depthStencilTexture;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetWrapper2.prototype, "depthStencilTextureWithStencil", {
    get: function() {
      return this._depthStencilTextureWithStencil;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetWrapper2.prototype, "isCube", {
    get: function() {
      return this._isCube;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetWrapper2.prototype, "isMulti", {
    get: function() {
      return this._isMulti;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetWrapper2.prototype, "is2DArray", {
    get: function() {
      return this.layers > 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetWrapper2.prototype, "size", {
    get: function() {
      return this.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetWrapper2.prototype, "width", {
    get: function() {
      return this._size.width || this._size;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetWrapper2.prototype, "height", {
    get: function() {
      return this._size.height || this._size;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetWrapper2.prototype, "layers", {
    get: function() {
      return this._size.layers || 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetWrapper2.prototype, "texture", {
    get: function() {
      var _a, _b;
      return (_b = (_a = this._textures) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetWrapper2.prototype, "textures", {
    get: function() {
      return this._textures;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetWrapper2.prototype, "samples", {
    get: function() {
      var _a, _b;
      return (_b = (_a = this.texture) === null || _a === void 0 ? void 0 : _a.samples) !== null && _b !== void 0 ? _b : 1;
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetWrapper2.prototype.setSamples = function(value, initializeBuffers, force) {
    if (initializeBuffers === void 0) {
      initializeBuffers = true;
    }
    if (force === void 0) {
      force = false;
    }
    if (this.samples === value && !force) {
      return value;
    }
    return this._isMulti ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers) : this._engine.updateRenderTargetTextureSampleCount(this, value);
  };
  RenderTargetWrapper2.prototype.setTextures = function(textures) {
    if (Array.isArray(textures)) {
      this._textures = textures;
    } else if (textures) {
      this._textures = [textures];
    } else {
      this._textures = null;
    }
  };
  RenderTargetWrapper2.prototype.setTexture = function(texture, index, disposePrevious) {
    if (index === void 0) {
      index = 0;
    }
    if (disposePrevious === void 0) {
      disposePrevious = true;
    }
    if (!this._textures) {
      this._textures = [];
    }
    if (this._textures[index] && disposePrevious) {
      this._textures[index].dispose();
    }
    this._textures[index] = texture;
  };
  RenderTargetWrapper2.prototype.createDepthStencilTexture = function(comparisonFunction, bilinearFiltering, generateStencil, samples, format) {
    var _a;
    if (comparisonFunction === void 0) {
      comparisonFunction = 0;
    }
    if (bilinearFiltering === void 0) {
      bilinearFiltering = true;
    }
    if (generateStencil === void 0) {
      generateStencil = false;
    }
    if (samples === void 0) {
      samples = 1;
    }
    if (format === void 0) {
      format = 14;
    }
    (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();
    this._depthStencilTextureWithStencil = generateStencil;
    this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {
      bilinearFiltering,
      comparisonFunction,
      generateStencil,
      isCube: this._isCube,
      samples,
      depthTextureFormat: format
    }, this);
    return this._depthStencilTexture;
  };
  RenderTargetWrapper2.prototype._shareDepth = function(renderTarget) {
    if (this._depthStencilTexture) {
      if (renderTarget._depthStencilTexture) {
        renderTarget._depthStencilTexture.dispose();
      }
      renderTarget._depthStencilTexture = this._depthStencilTexture;
      this._depthStencilTexture.incrementReferences();
    }
  };
  RenderTargetWrapper2.prototype._swapAndDie = function(target) {
    if (this.texture) {
      this.texture._swapAndDie(target);
    }
    this._textures = null;
    this.dispose(true);
  };
  RenderTargetWrapper2.prototype._cloneRenderTargetWrapper = function() {
    var _a, _b, _c, _d, _e, _f;
    var rtw = null;
    if (this._isMulti) {
      var textureArray = this.textures;
      if (textureArray && textureArray.length > 0) {
        var generateDepthTexture = false;
        var textureCount = textureArray.length;
        var lastTextureSource = textureArray[textureArray.length - 1]._source;
        if (lastTextureSource === InternalTextureSource.Depth || lastTextureSource === InternalTextureSource.DepthStencil) {
          generateDepthTexture = true;
          textureCount--;
        }
        var samplingModes = [];
        var types = [];
        for (var i = 0; i < textureCount; ++i) {
          var texture = textureArray[i];
          samplingModes.push(texture.samplingMode);
          types.push(texture.type);
        }
        var optionsMRT = {
          samplingModes,
          generateMipMaps: textureArray[0].generateMipMaps,
          generateDepthBuffer: this._generateDepthBuffer,
          generateStencilBuffer: this._generateStencilBuffer,
          generateDepthTexture,
          types,
          textureCount
        };
        var size = {
          width: this.width,
          height: this.height
        };
        rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);
      }
    } else {
      var options = {};
      options.generateDepthBuffer = this._generateDepthBuffer;
      options.generateMipMaps = (_b = (_a = this.texture) === null || _a === void 0 ? void 0 : _a.generateMipMaps) !== null && _b !== void 0 ? _b : false;
      options.generateStencilBuffer = this._generateStencilBuffer;
      options.samplingMode = (_c = this.texture) === null || _c === void 0 ? void 0 : _c.samplingMode;
      options.type = (_d = this.texture) === null || _d === void 0 ? void 0 : _d.type;
      options.format = (_e = this.texture) === null || _e === void 0 ? void 0 : _e.format;
      if (this.isCube) {
        rtw = this._engine.createRenderTargetCubeTexture(this.width, options);
      } else {
        var size = {
          width: this.width,
          height: this.height,
          layers: this.is2DArray ? (_f = this.texture) === null || _f === void 0 ? void 0 : _f.depth : void 0
        };
        rtw = this._engine.createRenderTargetTexture(size, options);
      }
      rtw.texture.isReady = true;
    }
    return rtw;
  };
  RenderTargetWrapper2.prototype._swapRenderTargetWrapper = function(target) {
    if (this._textures && target._textures) {
      for (var i = 0; i < this._textures.length; ++i) {
        this._textures[i]._swapAndDie(target._textures[i], false);
        target._textures[i].isReady = true;
      }
    }
    if (this._depthStencilTexture && target._depthStencilTexture) {
      this._depthStencilTexture._swapAndDie(target._depthStencilTexture);
      target._depthStencilTexture.isReady = true;
    }
    this._textures = null;
    this._depthStencilTexture = null;
  };
  RenderTargetWrapper2.prototype._rebuild = function() {
    var rtw = this._cloneRenderTargetWrapper();
    if (!rtw) {
      return;
    }
    if (this._depthStencilTexture) {
      var samplingMode = this._depthStencilTexture.samplingMode;
      var bilinear = samplingMode === 2 || samplingMode === 3 || samplingMode === 11;
      rtw.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, bilinear, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);
    }
    if (this.samples > 1) {
      rtw.setSamples(this.samples);
    }
    rtw._swapRenderTargetWrapper(this);
    rtw.dispose();
  };
  RenderTargetWrapper2.prototype.releaseTextures = function() {
    var _a, _b;
    if (this._textures) {
      for (var i = 0; (_b = i < ((_a = this._textures) === null || _a === void 0 ? void 0 : _a.length)) !== null && _b !== void 0 ? _b : 0; ++i) {
        this._textures[i].dispose();
      }
    }
    this._textures = null;
  };
  RenderTargetWrapper2.prototype.dispose = function(disposeOnlyFramebuffers) {
    var _a;
    if (disposeOnlyFramebuffers === void 0) {
      disposeOnlyFramebuffers = false;
    }
    if (!disposeOnlyFramebuffers) {
      (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();
      this._depthStencilTexture = null;
      this.releaseTextures();
    }
    this._engine._releaseRenderTargetWrapper(this);
  };
  return RenderTargetWrapper2;
}();
var WebGLRenderTargetWrapper = function(_super) {
  __extends(WebGLRenderTargetWrapper2, _super);
  function WebGLRenderTargetWrapper2(isMulti, isCube, size, engine, context) {
    var _this = _super.call(this, isMulti, isCube, size, engine) || this;
    _this._framebuffer = null;
    _this._depthStencilBuffer = null;
    _this._MSAAFramebuffer = null;
    _this._colorTextureArray = null;
    _this._depthStencilTextureArray = null;
    _this._context = context;
    return _this;
  }
  WebGLRenderTargetWrapper2.prototype._cloneRenderTargetWrapper = function() {
    var rtw = null;
    if (this._colorTextureArray && this._depthStencilTextureArray) {
      rtw = this._engine.createMultiviewRenderTargetTexture(this.width, this.height);
      rtw.texture.isReady = true;
    } else {
      rtw = _super.prototype._cloneRenderTargetWrapper.call(this);
    }
    return rtw;
  };
  WebGLRenderTargetWrapper2.prototype._swapRenderTargetWrapper = function(target) {
    _super.prototype._swapRenderTargetWrapper.call(this, target);
    target._framebuffer = this._framebuffer;
    target._depthStencilBuffer = this._depthStencilBuffer;
    target._MSAAFramebuffer = this._MSAAFramebuffer;
    target._colorTextureArray = this._colorTextureArray;
    target._depthStencilTextureArray = this._depthStencilTextureArray;
    this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null;
  };
  WebGLRenderTargetWrapper2.prototype._shareDepth = function(renderTarget) {
    _super.prototype._shareDepth.call(this, renderTarget);
    var gl = this._context;
    var depthbuffer = this._depthStencilBuffer;
    var framebuffer = renderTarget._framebuffer;
    if (renderTarget._depthStencilBuffer) {
      gl.deleteRenderbuffer(renderTarget._depthStencilBuffer);
    }
    renderTarget._depthStencilBuffer = this._depthStencilBuffer;
    this._engine._bindUnboundFramebuffer(framebuffer);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthbuffer);
    this._engine._bindUnboundFramebuffer(null);
  };
  WebGLRenderTargetWrapper2.prototype._bindTextureRenderTarget = function(texture, attachmentIndex, faceIndex, lodLevel) {
    if (attachmentIndex === void 0) {
      attachmentIndex = 0;
    }
    if (faceIndex === void 0) {
      faceIndex = -1;
    }
    if (lodLevel === void 0) {
      lodLevel = 0;
    }
    if (!texture._hardwareTexture) {
      return;
    }
    var gl = this._context;
    var framebuffer = this._framebuffer;
    var currentFB = this._engine._currentFramebuffer;
    this._engine._bindUnboundFramebuffer(framebuffer);
    var attachment = gl[this._engine.webGLVersion > 1 ? "COLOR_ATTACHMENT" + attachmentIndex : "COLOR_ATTACHMENT" + attachmentIndex + "_WEBGL"];
    var target = faceIndex !== -1 ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, target, texture._hardwareTexture.underlyingResource, lodLevel);
    this._engine._bindUnboundFramebuffer(currentFB);
  };
  WebGLRenderTargetWrapper2.prototype.setTexture = function(texture, index, disposePrevious) {
    if (index === void 0) {
      index = 0;
    }
    if (disposePrevious === void 0) {
      disposePrevious = true;
    }
    _super.prototype.setTexture.call(this, texture, index, disposePrevious);
    this._bindTextureRenderTarget(texture, index);
  };
  WebGLRenderTargetWrapper2.prototype.dispose = function(disposeOnlyFramebuffers) {
    if (disposeOnlyFramebuffers === void 0) {
      disposeOnlyFramebuffers = false;
    }
    var gl = this._context;
    if (!disposeOnlyFramebuffers) {
      if (this._colorTextureArray) {
        this._context.deleteTexture(this._colorTextureArray);
        this._colorTextureArray = null;
      }
      if (this._depthStencilTextureArray) {
        this._context.deleteTexture(this._depthStencilTextureArray);
        this._depthStencilTextureArray = null;
      }
    }
    if (this._framebuffer) {
      gl.deleteFramebuffer(this._framebuffer);
      this._framebuffer = null;
    }
    if (this._depthStencilBuffer) {
      gl.deleteRenderbuffer(this._depthStencilBuffer);
      this._depthStencilBuffer = null;
    }
    if (this._MSAAFramebuffer) {
      gl.deleteFramebuffer(this._MSAAFramebuffer);
      this._MSAAFramebuffer = null;
    }
    _super.prototype.dispose.call(this, disposeOnlyFramebuffers);
  };
  return WebGLRenderTargetWrapper2;
}(RenderTargetWrapper);
ThinEngine.prototype._createHardwareRenderTargetWrapper = function(isMulti, isCube, size) {
  var rtWrapper = new WebGLRenderTargetWrapper(isMulti, isCube, size, this, this._gl);
  this._renderTargetWrapperCache.push(rtWrapper);
  return rtWrapper;
};
ThinEngine.prototype.createRenderTargetTexture = function(size, options) {
  var rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);
  var fullOptions = {};
  if (options !== void 0 && typeof options === "object") {
    fullOptions.generateDepthBuffer = !!options.generateDepthBuffer;
    fullOptions.generateStencilBuffer = !!options.generateStencilBuffer;
  } else {
    fullOptions.generateDepthBuffer = true;
    fullOptions.generateStencilBuffer = false;
  }
  var texture = this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget);
  var width = size.width || size;
  var height = size.height || size;
  var currentFrameBuffer = this._currentFramebuffer;
  var gl = this._gl;
  var framebuffer = gl.createFramebuffer();
  this._bindUnboundFramebuffer(framebuffer);
  rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer ? true : false, fullOptions.generateDepthBuffer, width, height);
  if (!texture.is2DArray) {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, 0);
  }
  this._bindUnboundFramebuffer(currentFrameBuffer);
  rtWrapper._framebuffer = framebuffer;
  rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
  rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
  rtWrapper.setTextures(texture);
  return rtWrapper;
};
ThinEngine.prototype.createDepthStencilTexture = function(size, options, rtWrapper) {
  if (options.isCube) {
    var width = size.width || size;
    return this._createDepthStencilCubeTexture(width, options, rtWrapper);
  } else {
    return this._createDepthStencilTexture(size, options, rtWrapper);
  }
};
ThinEngine.prototype._createDepthStencilTexture = function(size, options, rtWrapper) {
  var gl = this._gl;
  var layers = size.layers || 0;
  var target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
  var internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);
  if (!this._caps.depthTextureExtension) {
    Logger.Error("Depth texture is not supported by your browser or hardware.");
    return internalTexture;
  }
  var internalOptions = __assign({ bilinearFiltering: false, comparisonFunction: 0, generateStencil: false }, options);
  this._bindTextureDirectly(target, internalTexture, true);
  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.comparisonFunction === 0 ? false : internalOptions.bilinearFiltering, internalOptions.comparisonFunction);
  internalTexture.format = internalOptions.generateStencil ? 13 : 16;
  rtWrapper._depthStencilTexture = internalTexture;
  rtWrapper._depthStencilTextureWithStencil = internalOptions.generateStencil;
  var type = internalOptions.generateStencil ? gl.UNSIGNED_INT_24_8 : gl.UNSIGNED_INT;
  var internalFormat = internalOptions.generateStencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;
  var sizedFormat = internalFormat;
  if (this.webGLVersion > 1) {
    sizedFormat = internalOptions.generateStencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
  }
  if (internalTexture.is2DArray) {
    gl.texImage3D(target, 0, sizedFormat, internalTexture.width, internalTexture.height, layers, 0, internalFormat, type, null);
  } else {
    gl.texImage2D(target, 0, sizedFormat, internalTexture.width, internalTexture.height, 0, internalFormat, type, null);
  }
  this._bindTextureDirectly(target, null);
  this._internalTexturesCache.push(internalTexture);
  return internalTexture;
};
ThinEngine.prototype.updateRenderTargetTextureSampleCount = function(rtWrapper, samples) {
  if (this.webGLVersion < 2 || !rtWrapper || !rtWrapper.texture) {
    return 1;
  }
  if (rtWrapper.samples === samples) {
    return samples;
  }
  var gl = this._gl;
  samples = Math.min(samples, this.getCaps().maxMSAASamples);
  if (rtWrapper._depthStencilBuffer) {
    gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);
    rtWrapper._depthStencilBuffer = null;
  }
  if (rtWrapper._MSAAFramebuffer) {
    gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);
    rtWrapper._MSAAFramebuffer = null;
  }
  var hardwareTexture = rtWrapper.texture._hardwareTexture;
  if (hardwareTexture._MSAARenderBuffer) {
    gl.deleteRenderbuffer(hardwareTexture._MSAARenderBuffer);
    hardwareTexture._MSAARenderBuffer = null;
  }
  if (samples > 1 && gl.renderbufferStorageMultisample) {
    var framebuffer = gl.createFramebuffer();
    if (!framebuffer) {
      throw new Error("Unable to create multi sampled framebuffer");
    }
    rtWrapper._MSAAFramebuffer = framebuffer;
    this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer);
    var colorRenderbuffer = this._createRenderBuffer(rtWrapper.texture.width, rtWrapper.texture.height, samples, -1, this._getRGBAMultiSampleBufferFormat(rtWrapper.texture.type), gl.COLOR_ATTACHMENT0, false);
    if (!colorRenderbuffer) {
      throw new Error("Unable to create multi sampled framebuffer");
    }
    hardwareTexture._MSAARenderBuffer = colorRenderbuffer;
  } else {
    this._bindUnboundFramebuffer(rtWrapper._framebuffer);
  }
  rtWrapper.texture.samples = samples;
  rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, rtWrapper.texture.width, rtWrapper.texture.height, samples);
  this._bindUnboundFramebuffer(null);
  return samples;
};
ThinEngine.prototype.createRenderTargetCubeTexture = function(size, options) {
  var rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);
  var fullOptions = __assign({ generateMipMaps: true, generateDepthBuffer: true, generateStencilBuffer: false, type: 0, samplingMode: 3, format: 5 }, options);
  fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;
  if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
    fullOptions.samplingMode = 1;
  } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
    fullOptions.samplingMode = 1;
  }
  var gl = this._gl;
  var texture = new InternalTexture(this, InternalTextureSource.RenderTarget);
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
  var filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps);
  if (fullOptions.type === 1 && !this._caps.textureFloat) {
    fullOptions.type = 0;
    Logger.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type");
  }
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  for (var face = 0; face < 6; face++) {
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format), size, size, 0, this._getInternalFormat(fullOptions.format), this._getWebGLTextureType(fullOptions.type), null);
  }
  var framebuffer = gl.createFramebuffer();
  this._bindUnboundFramebuffer(framebuffer);
  rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer, fullOptions.generateDepthBuffer, size, size);
  if (fullOptions.generateMipMaps) {
    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
  }
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
  this._bindUnboundFramebuffer(null);
  rtWrapper._framebuffer = framebuffer;
  rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
  rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;
  texture.width = size;
  texture.height = size;
  texture.isReady = true;
  texture.isCube = true;
  texture.samples = 1;
  texture.generateMipMaps = fullOptions.generateMipMaps;
  texture.samplingMode = fullOptions.samplingMode;
  texture.type = fullOptions.type;
  texture.format = fullOptions.format;
  this._internalTexturesCache.push(texture);
  rtWrapper.setTextures(texture);
  return rtWrapper;
};
var RenderTargetTexture = function(_super) {
  __extends(RenderTargetTexture2, _super);
  function RenderTargetTexture2(name2, size, scene, generateMipMaps, doNotChangeAspectRatio, type, isCube, samplingMode, generateDepthBuffer, generateStencilBuffer, isMulti, format, delayAllocation, samples, creationFlags) {
    if (doNotChangeAspectRatio === void 0) {
      doNotChangeAspectRatio = true;
    }
    if (type === void 0) {
      type = 0;
    }
    if (isCube === void 0) {
      isCube = false;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
    }
    if (generateDepthBuffer === void 0) {
      generateDepthBuffer = true;
    }
    if (generateStencilBuffer === void 0) {
      generateStencilBuffer = false;
    }
    if (isMulti === void 0) {
      isMulti = false;
    }
    if (format === void 0) {
      format = 5;
    }
    if (delayAllocation === void 0) {
      delayAllocation = false;
    }
    var _a;
    var _this = _super.call(this, null, scene, !generateMipMaps, void 0, samplingMode, void 0, void 0, void 0, void 0, format) || this;
    _this.renderParticles = true;
    _this.renderSprites = false;
    _this.ignoreCameraViewport = false;
    _this.onBeforeBindObservable = new Observable();
    _this.onAfterUnbindObservable = new Observable();
    _this.onBeforeRenderObservable = new Observable();
    _this.onAfterRenderObservable = new Observable();
    _this.onClearObservable = new Observable();
    _this.onResizeObservable = new Observable();
    _this._cleared = false;
    _this.skipInitialClear = false;
    _this._currentRefreshId = -1;
    _this._refreshRate = 1;
    _this._samples = 1;
    _this._canRescale = true;
    _this._renderTarget = null;
    _this.boundingBoxPosition = Vector3.Zero();
    scene = _this.getScene();
    if (!scene) {
      return _this;
    }
    var engine = _this.getScene().getEngine();
    _this._coordinatesMode = Texture.PROJECTION_MODE;
    _this.renderList = new Array();
    _this.name = name2;
    _this.isRenderTarget = true;
    _this._initialSizeParameter = size;
    _this._renderPassIds = [];
    _this.__isCube = isCube;
    _this._processSizeParameter(size);
    _this.renderPassId = _this._renderPassIds[0];
    _this._resizeObserver = engine.onResizeObservable.add(function() {
    });
    _this._generateMipMaps = generateMipMaps ? true : false;
    _this._doNotChangeAspectRatio = doNotChangeAspectRatio;
    _this._renderingManager = new RenderingManager(scene);
    _this._renderingManager._useSceneAutoClearSetup = true;
    if (isMulti) {
      return _this;
    }
    _this._renderTargetOptions = {
      generateMipMaps,
      type,
      format: (_a = _this._format) !== null && _a !== void 0 ? _a : void 0,
      samplingMode: _this.samplingMode,
      generateDepthBuffer,
      generateStencilBuffer,
      samples,
      creationFlags
    };
    if (_this.samplingMode === Texture.NEAREST_SAMPLINGMODE) {
      _this.wrapU = Texture.CLAMP_ADDRESSMODE;
      _this.wrapV = Texture.CLAMP_ADDRESSMODE;
    }
    if (!delayAllocation) {
      if (isCube) {
        _this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(_this.getRenderSize(), _this._renderTargetOptions);
        _this.coordinatesMode = Texture.INVCUBIC_MODE;
        _this._textureMatrix = Matrix.Identity();
      } else {
        _this._renderTarget = scene.getEngine().createRenderTargetTexture(_this._size, _this._renderTargetOptions);
      }
      _this._texture = _this._renderTarget.texture;
      if (samples !== void 0) {
        _this.samples = samples;
      }
    }
    return _this;
  }
  Object.defineProperty(RenderTargetTexture2.prototype, "renderList", {
    get: function() {
      return this._renderList;
    },
    set: function(value) {
      this._renderList = value;
      if (this._renderList) {
        this._hookArray(this._renderList);
      }
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetTexture2.prototype._hookArray = function(array) {
    var _this = this;
    var oldPush = array.push;
    array.push = function() {
      var _a;
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      var wasEmpty = array.length === 0;
      var result = oldPush.apply(array, items);
      if (wasEmpty) {
        (_a = _this.getScene()) === null || _a === void 0 ? void 0 : _a.meshes.forEach(function(mesh) {
          mesh._markSubMeshesAsLightDirty();
        });
      }
      return result;
    };
    var oldSplice = array.splice;
    array.splice = function(index, deleteCount) {
      var _a;
      var deleted = oldSplice.apply(array, [index, deleteCount]);
      if (array.length === 0) {
        (_a = _this.getScene()) === null || _a === void 0 ? void 0 : _a.meshes.forEach(function(mesh) {
          mesh._markSubMeshesAsLightDirty();
        });
      }
      return deleted;
    };
  };
  Object.defineProperty(RenderTargetTexture2.prototype, "postProcesses", {
    get: function() {
      return this._postProcesses;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "_prePassEnabled", {
    get: function() {
      return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "onAfterUnbind", {
    set: function(callback) {
      if (this._onAfterUnbindObserver) {
        this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
      }
      this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "onBeforeRender", {
    set: function(callback) {
      if (this._onBeforeRenderObserver) {
        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
      }
      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "onAfterRender", {
    set: function(callback) {
      if (this._onAfterRenderObserver) {
        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
      }
      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "onClear", {
    set: function(callback) {
      if (this._onClearObserver) {
        this.onClearObservable.remove(this._onClearObserver);
      }
      this._onClearObserver = this.onClearObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "renderPassIds", {
    get: function() {
      return this._renderPassIds;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "currentRefreshId", {
    get: function() {
      return this._currentRefreshId;
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetTexture2.prototype.setMaterialForRendering = function(mesh, material) {
    var meshes;
    if (!Array.isArray(mesh)) {
      meshes = [mesh];
    } else {
      meshes = mesh;
    }
    for (var j = 0; j < meshes.length; ++j) {
      for (var i = 0; i < this._renderPassIds.length; ++i) {
        meshes[j].setMaterialForRenderPass(this._renderPassIds[i], material !== void 0 ? Array.isArray(material) ? material[i] : material : void 0);
      }
    }
  };
  Object.defineProperty(RenderTargetTexture2.prototype, "renderTargetOptions", {
    get: function() {
      return this._renderTargetOptions;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "renderTarget", {
    get: function() {
      return this._renderTarget;
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetTexture2.prototype._onRatioRescale = function() {
    if (this._sizeRatio) {
      this.resize(this._initialSizeParameter);
    }
  };
  Object.defineProperty(RenderTargetTexture2.prototype, "boundingBoxSize", {
    get: function() {
      return this._boundingBoxSize;
    },
    set: function(value) {
      if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
        return;
      }
      this._boundingBoxSize = value;
      var scene = this.getScene();
      if (scene) {
        scene.markAllMaterialsAsDirty(1);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderTargetTexture2.prototype, "depthStencilTexture", {
    get: function() {
      var _a, _b;
      return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a._depthStencilTexture) !== null && _b !== void 0 ? _b : null;
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetTexture2.prototype.createDepthStencilTexture = function(comparisonFunction, bilinearFiltering, generateStencil, samples, format) {
    var _a;
    if (comparisonFunction === void 0) {
      comparisonFunction = 0;
    }
    if (bilinearFiltering === void 0) {
      bilinearFiltering = true;
    }
    if (generateStencil === void 0) {
      generateStencil = false;
    }
    if (samples === void 0) {
      samples = 1;
    }
    if (format === void 0) {
      format = 14;
    }
    (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.createDepthStencilTexture(comparisonFunction, bilinearFiltering, generateStencil, samples, format);
  };
  RenderTargetTexture2.prototype._releaseRenderPassId = function() {
    if (this._scene) {
      var engine = this._scene.getEngine();
      for (var i = 0; i < this._renderPassIds.length; ++i) {
        engine.releaseRenderPassId(this._renderPassIds[i]);
      }
    }
    this._renderPassIds = [];
  };
  RenderTargetTexture2.prototype._createRenderPassId = function() {
    this._releaseRenderPassId();
    var engine = this._scene.getEngine();
    var numPasses = this.__isCube ? 6 : this.getRenderLayers() || 1;
    for (var i = 0; i < numPasses; ++i) {
      this._renderPassIds[i] = engine.createRenderPassId("RenderTargetTexture - ".concat(this.name, "#").concat(i));
    }
  };
  RenderTargetTexture2.prototype._processSizeParameter = function(size) {
    if (size.ratio) {
      this._sizeRatio = size.ratio;
      var engine = this._getEngine();
      this._size = {
        width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),
        height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio)
      };
    } else {
      this._size = size;
    }
    this._createRenderPassId();
  };
  Object.defineProperty(RenderTargetTexture2.prototype, "samples", {
    get: function() {
      var _a, _b;
      return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.samples) !== null && _b !== void 0 ? _b : this._samples;
    },
    set: function(value) {
      if (this._renderTarget) {
        this._samples = this._renderTarget.setSamples(value);
      }
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetTexture2.prototype.resetRefreshCounter = function() {
    this._currentRefreshId = -1;
  };
  Object.defineProperty(RenderTargetTexture2.prototype, "refreshRate", {
    get: function() {
      return this._refreshRate;
    },
    set: function(value) {
      this._refreshRate = value;
      this.resetRefreshCounter();
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetTexture2.prototype.addPostProcess = function(postProcess) {
    if (!this._postProcessManager) {
      var scene = this.getScene();
      if (!scene) {
        return;
      }
      this._postProcessManager = new PostProcessManager(scene);
      this._postProcesses = new Array();
    }
    this._postProcesses.push(postProcess);
    this._postProcesses[0].autoClear = false;
  };
  RenderTargetTexture2.prototype.clearPostProcesses = function(dispose) {
    if (dispose === void 0) {
      dispose = false;
    }
    if (!this._postProcesses) {
      return;
    }
    if (dispose) {
      for (var _i = 0, _a = this._postProcesses; _i < _a.length; _i++) {
        var postProcess = _a[_i];
        postProcess.dispose();
      }
    }
    this._postProcesses = [];
  };
  RenderTargetTexture2.prototype.removePostProcess = function(postProcess) {
    if (!this._postProcesses) {
      return;
    }
    var index = this._postProcesses.indexOf(postProcess);
    if (index === -1) {
      return;
    }
    this._postProcesses.splice(index, 1);
    if (this._postProcesses.length > 0) {
      this._postProcesses[0].autoClear = false;
    }
  };
  RenderTargetTexture2.prototype._shouldRender = function() {
    if (this._currentRefreshId === -1) {
      this._currentRefreshId = 1;
      return true;
    }
    if (this.refreshRate === this._currentRefreshId) {
      this._currentRefreshId = 1;
      return true;
    }
    this._currentRefreshId++;
    return false;
  };
  RenderTargetTexture2.prototype.getRenderSize = function() {
    return this.getRenderWidth();
  };
  RenderTargetTexture2.prototype.getRenderWidth = function() {
    if (this._size.width) {
      return this._size.width;
    }
    return this._size;
  };
  RenderTargetTexture2.prototype.getRenderHeight = function() {
    if (this._size.width) {
      return this._size.height;
    }
    return this._size;
  };
  RenderTargetTexture2.prototype.getRenderLayers = function() {
    var layers = this._size.layers;
    if (layers) {
      return layers;
    }
    return 0;
  };
  RenderTargetTexture2.prototype.disableRescaling = function() {
    this._canRescale = false;
  };
  Object.defineProperty(RenderTargetTexture2.prototype, "canRescale", {
    get: function() {
      return this._canRescale;
    },
    enumerable: false,
    configurable: true
  });
  RenderTargetTexture2.prototype.scale = function(ratio) {
    var newSize = Math.max(1, this.getRenderSize() * ratio);
    this.resize(newSize);
  };
  RenderTargetTexture2.prototype.getReflectionTextureMatrix = function() {
    if (this.isCube) {
      return this._textureMatrix;
    }
    return _super.prototype.getReflectionTextureMatrix.call(this);
  };
  RenderTargetTexture2.prototype.resize = function(size) {
    var _a;
    var wasCube = this.isCube;
    (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose();
    this._renderTarget = null;
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    this._processSizeParameter(size);
    if (wasCube) {
      this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);
    } else {
      this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);
    }
    this._texture = this._renderTarget.texture;
    if (this._renderTargetOptions.samples !== void 0) {
      this.samples = this._renderTargetOptions.samples;
    }
    if (this.onResizeObservable.hasObservers()) {
      this.onResizeObservable.notifyObservers(this);
    }
  };
  RenderTargetTexture2.prototype.render = function(useCameraPostProcess, dumpForDebug) {
    if (useCameraPostProcess === void 0) {
      useCameraPostProcess = false;
    }
    if (dumpForDebug === void 0) {
      dumpForDebug = false;
    }
    this._render(useCameraPostProcess, dumpForDebug);
  };
  RenderTargetTexture2.prototype.isReadyForRendering = function() {
    return this._render(false, false, true);
  };
  RenderTargetTexture2.prototype._render = function(useCameraPostProcess, dumpForDebug, checkReadiness) {
    var _a;
    if (useCameraPostProcess === void 0) {
      useCameraPostProcess = false;
    }
    if (dumpForDebug === void 0) {
      dumpForDebug = false;
    }
    if (checkReadiness === void 0) {
      checkReadiness = false;
    }
    var scene = this.getScene();
    if (!scene) {
      return checkReadiness;
    }
    var engine = scene.getEngine();
    if (this.useCameraPostProcesses !== void 0) {
      useCameraPostProcess = this.useCameraPostProcesses;
    }
    if (this._waitingRenderList) {
      this.renderList = [];
      for (var index = 0; index < this._waitingRenderList.length; index++) {
        var id = this._waitingRenderList[index];
        var mesh_1 = scene.getMeshById(id);
        if (mesh_1) {
          this.renderList.push(mesh_1);
        }
      }
      this._waitingRenderList = void 0;
    }
    if (this.renderListPredicate) {
      if (this.renderList) {
        this.renderList.length = 0;
      } else {
        this.renderList = [];
      }
      var scene = this.getScene();
      if (!scene) {
        return checkReadiness;
      }
      var sceneMeshes = scene.meshes;
      for (var index = 0; index < sceneMeshes.length; index++) {
        var mesh = sceneMeshes[index];
        if (this.renderListPredicate(mesh)) {
          this.renderList.push(mesh);
        }
      }
    }
    var currentRenderPassId = engine.currentRenderPassId;
    this.onBeforeBindObservable.notifyObservers(this);
    var camera = (_a = this.activeCamera) !== null && _a !== void 0 ? _a : scene.activeCamera;
    if (camera) {
      if (camera !== scene.activeCamera) {
        scene.setTransformMatrix(camera.getViewMatrix(), camera.getProjectionMatrix(true));
      }
      engine.setViewport(camera.viewport, this.getRenderWidth(), this.getRenderHeight());
    }
    this._defaultRenderListPrepared = false;
    var returnValue = checkReadiness;
    if (!checkReadiness) {
      if (this.is2DArray) {
        for (var layer = 0; layer < this.getRenderLayers(); layer++) {
          this.renderToTarget(0, useCameraPostProcess, dumpForDebug, layer, camera);
          scene.incrementRenderId();
          scene.resetCachedMaterial();
        }
      } else if (this.isCube) {
        for (var face = 0; face < 6; face++) {
          this.renderToTarget(face, useCameraPostProcess, dumpForDebug, void 0, camera);
          scene.incrementRenderId();
          scene.resetCachedMaterial();
        }
      } else {
        this.renderToTarget(0, useCameraPostProcess, dumpForDebug, void 0, camera);
      }
    } else {
      if (!scene.getViewMatrix()) {
        scene.updateTransformMatrix();
      }
      var numLayers = this.is2DArray ? this.getRenderLayers() : this.isCube ? 6 : 1;
      for (var layer = 0; layer < numLayers && returnValue; layer++) {
        var currentRenderList = null;
        var defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;
        var defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;
        engine.currentRenderPassId = this._renderPassIds[layer];
        this.onBeforeRenderObservable.notifyObservers(layer);
        if (this.getCustomRenderList) {
          currentRenderList = this.getCustomRenderList(layer, defaultRenderList, defaultRenderListLength);
        }
        if (!currentRenderList) {
          currentRenderList = defaultRenderList;
        }
        if (!this._doNotChangeAspectRatio) {
          scene.updateTransformMatrix(true);
        }
        for (var i = 0; i < currentRenderList.length && returnValue; ++i) {
          var mesh_2 = currentRenderList[i];
          if (!mesh_2.isEnabled() || mesh_2.isBlocked || !mesh_2.isVisible || !mesh_2.subMeshes) {
            continue;
          }
          if (this.customIsReadyFunction) {
            if (!this.customIsReadyFunction(mesh_2, this.refreshRate)) {
              returnValue = false;
              break;
            }
          } else if (!mesh_2.isReady(true)) {
            returnValue = false;
            break;
          }
        }
        this.onAfterRenderObservable.notifyObservers(layer);
      }
    }
    this.onAfterUnbindObservable.notifyObservers(this);
    engine.currentRenderPassId = currentRenderPassId;
    if (scene.activeCamera) {
      if (scene.getEngine().scenes.length > 1 || this.activeCamera && this.activeCamera !== scene.activeCamera) {
        scene.setTransformMatrix(scene.activeCamera.getViewMatrix(), scene.activeCamera.getProjectionMatrix(true));
      }
      engine.setViewport(scene.activeCamera.viewport);
    }
    scene.resetCachedMaterial();
    return returnValue;
  };
  RenderTargetTexture2.prototype._bestReflectionRenderTargetDimension = function(renderDimension, scale) {
    var minimum = 128;
    var x = renderDimension * scale;
    var curved = Engine.NearestPOT(x + minimum * minimum / (minimum + x));
    return Math.min(Engine.FloorPOT(renderDimension), curved);
  };
  RenderTargetTexture2.prototype._prepareRenderingManager = function(currentRenderList, currentRenderListLength, camera, checkLayerMask) {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    this._renderingManager.reset();
    var sceneRenderId = scene.getRenderId();
    for (var meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {
      var mesh = currentRenderList[meshIndex];
      if (mesh && !mesh.isBlocked) {
        if (this.customIsReadyFunction) {
          if (!this.customIsReadyFunction(mesh, this.refreshRate)) {
            this.resetRefreshCounter();
            continue;
          }
        } else if (!mesh.isReady(this.refreshRate === 0)) {
          this.resetRefreshCounter();
          continue;
        }
        if (!mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate && scene.activeCamera) {
          mesh._internalAbstractMeshDataInfo._currentLOD = scene.customLODSelector ? scene.customLODSelector(mesh, this.activeCamera || scene.activeCamera) : mesh.getLOD(this.activeCamera || scene.activeCamera);
          mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;
        }
        if (!mesh._internalAbstractMeshDataInfo._currentLOD) {
          continue;
        }
        var meshToRender = mesh._internalAbstractMeshDataInfo._currentLOD;
        meshToRender._preActivateForIntermediateRendering(sceneRenderId);
        var isMasked = void 0;
        if (checkLayerMask && camera) {
          isMasked = (mesh.layerMask & camera.layerMask) === 0;
        } else {
          isMasked = false;
        }
        if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {
          if (meshToRender !== mesh) {
            meshToRender._activate(sceneRenderId, true);
          }
          if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {
            if (!mesh.isAnInstance) {
              meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;
            } else {
              if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
                meshToRender = mesh;
              }
            }
            meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;
            for (var subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {
              var subMesh = meshToRender.subMeshes[subIndex];
              this._renderingManager.dispatch(subMesh, meshToRender);
            }
          }
        }
      }
    }
    for (var particleIndex = 0; particleIndex < scene.particleSystems.length; particleIndex++) {
      var particleSystem = scene.particleSystems[particleIndex];
      var emitter = particleSystem.emitter;
      if (!particleSystem.isStarted() || !emitter || !emitter.position || !emitter.isEnabled()) {
        continue;
      }
      if (currentRenderList.indexOf(emitter) >= 0) {
        this._renderingManager.dispatchParticles(particleSystem);
      }
    }
  };
  RenderTargetTexture2.prototype._bindFrameBuffer = function(faceIndex, layer) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (layer === void 0) {
      layer = 0;
    }
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    var engine = scene.getEngine();
    if (this._renderTarget) {
      engine.bindFramebuffer(this._renderTarget, this.isCube ? faceIndex : void 0, void 0, void 0, this.ignoreCameraViewport, 0, layer);
    }
  };
  RenderTargetTexture2.prototype.unbindFrameBuffer = function(engine, faceIndex) {
    var _this = this;
    if (!this._renderTarget) {
      return;
    }
    engine.unBindFramebuffer(this._renderTarget, this.isCube, function() {
      _this.onAfterRenderObservable.notifyObservers(faceIndex);
    });
  };
  RenderTargetTexture2.prototype._prepareFrame = function(scene, faceIndex, layer, useCameraPostProcess) {
    if (this._postProcessManager) {
      if (!this._prePassEnabled) {
        this._postProcessManager._prepareFrame(this._texture, this._postProcesses);
      }
    } else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {
      this._bindFrameBuffer(faceIndex, layer);
    }
  };
  RenderTargetTexture2.prototype.renderToTarget = function(faceIndex, useCameraPostProcess, dumpForDebug, layer, camera) {
    var _a, _b, _c, _d;
    if (layer === void 0) {
      layer = 0;
    }
    if (camera === void 0) {
      camera = null;
    }
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    var engine = scene.getEngine();
    if (!this._texture) {
      return;
    }
    (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, "render to face #".concat(faceIndex, " layer #").concat(layer), 1);
    this._prepareFrame(scene, faceIndex, layer, useCameraPostProcess);
    if (this.is2DArray) {
      engine.currentRenderPassId = this._renderPassIds[layer];
      this.onBeforeRenderObservable.notifyObservers(layer);
    } else {
      engine.currentRenderPassId = this._renderPassIds[faceIndex];
      this.onBeforeRenderObservable.notifyObservers(faceIndex);
    }
    var fastPath = engine.snapshotRendering && engine.snapshotRenderingMode === 1;
    if (!fastPath) {
      var currentRenderList = null;
      var defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;
      var defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;
      if (this.getCustomRenderList) {
        currentRenderList = this.getCustomRenderList(this.is2DArray ? layer : faceIndex, defaultRenderList, defaultRenderListLength);
      }
      if (!currentRenderList) {
        if (!this._defaultRenderListPrepared) {
          this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, camera, !this.renderList);
          this._defaultRenderListPrepared = true;
        }
        currentRenderList = defaultRenderList;
      } else {
        this._prepareRenderingManager(currentRenderList, currentRenderList.length, camera, false);
      }
      for (var _i = 0, _e = scene._beforeRenderTargetClearStage; _i < _e.length; _i++) {
        var step = _e[_i];
        step.action(this, faceIndex, layer);
      }
      if (this.onClearObservable.hasObservers()) {
        this.onClearObservable.notifyObservers(engine);
      } else {
        if (!this.skipInitialClear) {
          engine.clear(this.clearColor || scene.clearColor, true, true, true);
        }
      }
      if (!this._doNotChangeAspectRatio) {
        scene.updateTransformMatrix(true);
      }
      for (var _f = 0, _g = scene._beforeRenderTargetDrawStage; _f < _g.length; _f++) {
        var step = _g[_f];
        step.action(this, faceIndex, layer);
      }
      this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);
      for (var _h = 0, _j = scene._afterRenderTargetDrawStage; _h < _j.length; _h++) {
        var step = _j[_h];
        step.action(this, faceIndex, layer);
      }
      var saveGenerateMipMaps = this._texture.generateMipMaps;
      this._texture.generateMipMaps = false;
      if (this._postProcessManager) {
        this._postProcessManager._finalizeFrame(false, (_b = this._renderTarget) !== null && _b !== void 0 ? _b : void 0, faceIndex, this._postProcesses, this.ignoreCameraViewport);
      } else if (useCameraPostProcess) {
        scene.postProcessManager._finalizeFrame(false, (_c = this._renderTarget) !== null && _c !== void 0 ? _c : void 0, faceIndex);
      }
      this._texture.generateMipMaps = saveGenerateMipMaps;
      if (!this._doNotChangeAspectRatio) {
        scene.updateTransformMatrix(true);
      }
      if (dumpForDebug) {
        Tools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);
      }
    } else {
      if (this.onClearObservable.hasObservers()) {
        this.onClearObservable.notifyObservers(engine);
      } else {
        if (!this.skipInitialClear) {
          engine.clear(this.clearColor || scene.clearColor, true, true, true);
        }
      }
    }
    this.unbindFrameBuffer(engine, faceIndex);
    if (this.isCube && faceIndex === 5) {
      engine.generateMipMapsForCubemap(this._texture);
    }
    (_d = engine._debugPopGroup) === null || _d === void 0 ? void 0 : _d.call(engine, 1);
  };
  RenderTargetTexture2.prototype.setRenderingOrder = function(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
    if (opaqueSortCompareFn === void 0) {
      opaqueSortCompareFn = null;
    }
    if (alphaTestSortCompareFn === void 0) {
      alphaTestSortCompareFn = null;
    }
    if (transparentSortCompareFn === void 0) {
      transparentSortCompareFn = null;
    }
    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
  };
  RenderTargetTexture2.prototype.setRenderingAutoClearDepthStencil = function(renderingGroupId, autoClearDepthStencil) {
    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);
    this._renderingManager._useSceneAutoClearSetup = false;
  };
  RenderTargetTexture2.prototype.clone = function() {
    var textureSize = this.getSize();
    var newTexture = new RenderTargetTexture2(this.name, textureSize, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer, void 0, this._renderTargetOptions.format, void 0, this._renderTargetOptions.samples);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.coordinatesMode = this.coordinatesMode;
    if (this.renderList) {
      newTexture.renderList = this.renderList.slice(0);
    }
    return newTexture;
  };
  RenderTargetTexture2.prototype.serialize = function() {
    if (!this.name) {
      return null;
    }
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.renderTargetSize = this.getRenderSize();
    serializationObject.renderList = [];
    if (this.renderList) {
      for (var index = 0; index < this.renderList.length; index++) {
        serializationObject.renderList.push(this.renderList[index].id);
      }
    }
    return serializationObject;
  };
  RenderTargetTexture2.prototype.disposeFramebufferObjects = function() {
    var _a;
    (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose(true);
  };
  RenderTargetTexture2.prototype.releaseInternalTexture = function() {
    var _a;
    (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.releaseTextures();
    this._texture = null;
  };
  RenderTargetTexture2.prototype.dispose = function() {
    var _a;
    this.onResizeObservable.clear();
    this.onClearObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onAfterUnbindObservable.clear();
    this.onBeforeBindObservable.clear();
    this.onBeforeRenderObservable.clear();
    if (this._postProcessManager) {
      this._postProcessManager.dispose();
      this._postProcessManager = null;
    }
    if (this._prePassRenderTarget) {
      this._prePassRenderTarget.dispose();
    }
    this._releaseRenderPassId();
    this.clearPostProcesses(true);
    if (this._resizeObserver) {
      this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver);
      this._resizeObserver = null;
    }
    this.renderList = null;
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    var index = scene.customRenderTargets.indexOf(this);
    if (index >= 0) {
      scene.customRenderTargets.splice(index, 1);
    }
    for (var _i = 0, _b = scene.cameras; _i < _b.length; _i++) {
      var camera = _b[_i];
      index = camera.customRenderTargets.indexOf(this);
      if (index >= 0) {
        camera.customRenderTargets.splice(index, 1);
      }
    }
    (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose();
    this._renderTarget = null;
    this._texture = null;
    _super.prototype.dispose.call(this);
  };
  RenderTargetTexture2.prototype._rebuild = function() {
    if (this.refreshRate === RenderTargetTexture2.REFRESHRATE_RENDER_ONCE) {
      this.refreshRate = RenderTargetTexture2.REFRESHRATE_RENDER_ONCE;
    }
    if (this._postProcessManager) {
      this._postProcessManager._rebuild();
    }
  };
  RenderTargetTexture2.prototype.freeRenderingGroups = function() {
    if (this._renderingManager) {
      this._renderingManager.freeRenderingGroups();
    }
  };
  RenderTargetTexture2.prototype.getViewCount = function() {
    return 1;
  };
  RenderTargetTexture2.REFRESHRATE_RENDER_ONCE = 0;
  RenderTargetTexture2.REFRESHRATE_RENDER_ONEVERYFRAME = 1;
  RenderTargetTexture2.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;
  return RenderTargetTexture2;
}(Texture);
Texture._CreateRenderTargetTexture = function(name2, renderTargetSize, scene, generateMipMaps, creationFlags) {
  return new RenderTargetTexture(name2, renderTargetSize, scene, generateMipMaps);
};
var name$1m = "postprocessVertexShader";
var shader$1m = "\nattribute vec2 position;\nuniform vec2 scale;\n\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvUV=(position*madd+madd)*scale;\ngl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}";
ShaderStore.ShadersStore[name$1m] = shader$1m;
var PostProcess = function() {
  function PostProcess2(name2, fragmentUrl, parameters, samplers, options, camera, samplingMode, engine, reusable, defines, textureType, vertexUrl, indexParameters, blockCompilation, textureFormat) {
    if (samplingMode === void 0) {
      samplingMode = 1;
    }
    if (defines === void 0) {
      defines = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    if (vertexUrl === void 0) {
      vertexUrl = "postprocess";
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    if (textureFormat === void 0) {
      textureFormat = 5;
    }
    this._parentContainer = null;
    this.width = -1;
    this.height = -1;
    this.nodeMaterialSource = null;
    this._outputTexture = null;
    this.autoClear = true;
    this.alphaMode = 0;
    this.animations = new Array();
    this.enablePixelPerfectMode = false;
    this.forceFullscreenViewport = true;
    this.scaleMode = 1;
    this.alwaysForcePOT = false;
    this._samples = 1;
    this.adaptScaleToCurrentViewport = false;
    this._reusable = false;
    this._renderId = 0;
    this.externalTextureSamplerBinding = false;
    this._textures = new SmartArray(2);
    this._textureCache = [];
    this._currentRenderTextureInd = 0;
    this._scaleRatio = new Vector2(1, 1);
    this._texelSize = Vector2.Zero();
    this.onActivateObservable = new Observable();
    this.onSizeChangedObservable = new Observable();
    this.onApplyObservable = new Observable();
    this.onBeforeRenderObservable = new Observable();
    this.onAfterRenderObservable = new Observable();
    this.name = name2;
    if (camera != null) {
      this._camera = camera;
      this._scene = camera.getScene();
      camera.attachPostProcess(this);
      this._engine = this._scene.getEngine();
      this._scene.postProcesses.push(this);
      this.uniqueId = this._scene.getUniqueId();
    } else if (engine) {
      this._engine = engine;
      this._engine.postProcesses.push(this);
    }
    this._options = options;
    this.renderTargetSamplingMode = samplingMode ? samplingMode : 1;
    this._reusable = reusable || false;
    this._textureType = textureType;
    this._textureFormat = textureFormat;
    this._samplers = samplers || [];
    this._samplers.push("textureSampler");
    this._fragmentUrl = fragmentUrl;
    this._vertexUrl = vertexUrl;
    this._parameters = parameters || [];
    this._parameters.push("scale");
    this._indexParameters = indexParameters;
    this._drawWrapper = new DrawWrapper(this._engine);
    if (!blockCompilation) {
      this.updateEffect(defines);
    }
  }
  Object.defineProperty(PostProcess2.prototype, "samples", {
    get: function() {
      return this._samples;
    },
    set: function(n) {
      var _this = this;
      this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);
      this._textures.forEach(function(texture) {
        if (texture.samples !== _this._samples) {
          _this._engine.updateRenderTargetTextureSampleCount(texture, _this._samples);
        }
      });
    },
    enumerable: false,
    configurable: true
  });
  PostProcess2.prototype.getEffectName = function() {
    return this._fragmentUrl;
  };
  Object.defineProperty(PostProcess2.prototype, "onActivate", {
    set: function(callback) {
      if (this._onActivateObserver) {
        this.onActivateObservable.remove(this._onActivateObserver);
      }
      if (callback) {
        this._onActivateObserver = this.onActivateObservable.add(callback);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PostProcess2.prototype, "onSizeChanged", {
    set: function(callback) {
      if (this._onSizeChangedObserver) {
        this.onSizeChangedObservable.remove(this._onSizeChangedObserver);
      }
      this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PostProcess2.prototype, "onApply", {
    set: function(callback) {
      if (this._onApplyObserver) {
        this.onApplyObservable.remove(this._onApplyObserver);
      }
      this._onApplyObserver = this.onApplyObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PostProcess2.prototype, "onBeforeRender", {
    set: function(callback) {
      if (this._onBeforeRenderObserver) {
        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
      }
      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PostProcess2.prototype, "onAfterRender", {
    set: function(callback) {
      if (this._onAfterRenderObserver) {
        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
      }
      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PostProcess2.prototype, "inputTexture", {
    get: function() {
      return this._textures.data[this._currentRenderTextureInd];
    },
    set: function(value) {
      this._forcedOutputTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  PostProcess2.prototype.restoreDefaultInputTexture = function() {
    if (this._forcedOutputTexture) {
      this._forcedOutputTexture = null;
      this.markTextureDirty();
    }
  };
  PostProcess2.prototype.getCamera = function() {
    return this._camera;
  };
  Object.defineProperty(PostProcess2.prototype, "texelSize", {
    get: function() {
      if (this._shareOutputWithPostProcess) {
        return this._shareOutputWithPostProcess.texelSize;
      }
      if (this._forcedOutputTexture) {
        this._texelSize.copyFromFloats(1 / this._forcedOutputTexture.width, 1 / this._forcedOutputTexture.height);
      }
      return this._texelSize;
    },
    enumerable: false,
    configurable: true
  });
  PostProcess2.prototype.getClassName = function() {
    return "PostProcess";
  };
  PostProcess2.prototype.getEngine = function() {
    return this._engine;
  };
  PostProcess2.prototype.getEffect = function() {
    return this._drawWrapper.effect;
  };
  PostProcess2.prototype.shareOutputWith = function(postProcess) {
    this._disposeTextures();
    this._shareOutputWithPostProcess = postProcess;
    return this;
  };
  PostProcess2.prototype.useOwnOutput = function() {
    if (this._textures.length == 0) {
      this._textures = new SmartArray(2);
    }
    this._shareOutputWithPostProcess = null;
  };
  PostProcess2.prototype.updateEffect = function(defines, uniforms, samplers, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {
    if (defines === void 0) {
      defines = null;
    }
    if (uniforms === void 0) {
      uniforms = null;
    }
    if (samplers === void 0) {
      samplers = null;
    }
    this._postProcessDefines = defines;
    this._drawWrapper.effect = this._engine.createEffect({ vertex: vertexUrl !== null && vertexUrl !== void 0 ? vertexUrl : this._vertexUrl, fragment: fragmentUrl !== null && fragmentUrl !== void 0 ? fragmentUrl : this._fragmentUrl }, ["position"], uniforms || this._parameters, samplers || this._samplers, defines !== null ? defines : "", void 0, onCompiled, onError, indexParameters || this._indexParameters);
  };
  PostProcess2.prototype.isReusable = function() {
    return this._reusable;
  };
  PostProcess2.prototype.markTextureDirty = function() {
    this.width = -1;
  };
  PostProcess2.prototype._createRenderTargetTexture = function(textureSize, textureOptions, channel) {
    if (channel === void 0) {
      channel = 0;
    }
    for (var i = 0; i < this._textureCache.length; i++) {
      if (this._textureCache[i].texture.width === textureSize.width && this._textureCache[i].texture.height === textureSize.height && this._textureCache[i].postProcessChannel === channel && this._textureCache[i].texture._generateDepthBuffer === textureOptions.generateDepthBuffer) {
        return this._textureCache[i].texture;
      }
    }
    var tex = this._engine.createRenderTargetTexture(textureSize, textureOptions);
    this._textureCache.push({ texture: tex, postProcessChannel: channel, lastUsedRenderId: -1 });
    return tex;
  };
  PostProcess2.prototype._flushTextureCache = function() {
    var currentRenderId = this._renderId;
    for (var i = this._textureCache.length - 1; i >= 0; i--) {
      if (currentRenderId - this._textureCache[i].lastUsedRenderId > 100) {
        var currentlyUsed = false;
        for (var j = 0; j < this._textures.length; j++) {
          if (this._textures.data[j] === this._textureCache[i].texture) {
            currentlyUsed = true;
            break;
          }
        }
        if (!currentlyUsed) {
          this._textureCache[i].texture.dispose();
          this._textureCache.splice(i, 1);
        }
      }
    }
  };
  PostProcess2.prototype._resize = function(width, height, camera, needMipMaps, forceDepthStencil) {
    if (this._textures.length > 0) {
      this._textures.reset();
    }
    this.width = width;
    this.height = height;
    var firstPP = null;
    for (var i = 0; i < camera._postProcesses.length; i++) {
      if (camera._postProcesses[i] !== null) {
        firstPP = camera._postProcesses[i];
        break;
      }
    }
    var textureSize = { width: this.width, height: this.height };
    var textureOptions = {
      generateMipMaps: needMipMaps,
      generateDepthBuffer: forceDepthStencil || firstPP === this,
      generateStencilBuffer: (forceDepthStencil || firstPP === this) && this._engine.isStencilEnable,
      samplingMode: this.renderTargetSamplingMode,
      type: this._textureType,
      format: this._textureFormat
    };
    this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 0));
    if (this._reusable) {
      this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 1));
    }
    this._texelSize.copyFromFloats(1 / this.width, 1 / this.height);
    this.onSizeChangedObservable.notifyObservers(this);
  };
  PostProcess2.prototype.activate = function(camera, sourceTexture, forceDepthStencil) {
    var _this = this;
    var _a, _b;
    if (sourceTexture === void 0) {
      sourceTexture = null;
    }
    camera = camera || this._camera;
    var scene = camera.getScene();
    var engine = scene.getEngine();
    var maxSize = engine.getCaps().maxTextureSize;
    var requiredWidth = (sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * this._options | 0;
    var requiredHeight = (sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * this._options | 0;
    var webVRCamera = camera.parent;
    if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {
      requiredWidth /= 2;
    }
    var desiredWidth = this._options.width || requiredWidth;
    var desiredHeight = this._options.height || requiredHeight;
    var needMipMaps = this.renderTargetSamplingMode !== 7 && this.renderTargetSamplingMode !== 1 && this.renderTargetSamplingMode !== 2;
    if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {
      if (this.adaptScaleToCurrentViewport) {
        var currentViewport = engine.currentViewport;
        if (currentViewport) {
          desiredWidth *= currentViewport.width;
          desiredHeight *= currentViewport.height;
        }
      }
      if (needMipMaps || this.alwaysForcePOT) {
        if (!this._options.width) {
          desiredWidth = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;
        }
        if (!this._options.height) {
          desiredHeight = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;
        }
      }
      if (this.width !== desiredWidth || this.height !== desiredHeight) {
        this._resize(desiredWidth, desiredHeight, camera, needMipMaps, forceDepthStencil);
      }
      this._textures.forEach(function(texture) {
        if (texture.samples !== _this.samples) {
          _this._engine.updateRenderTargetTextureSampleCount(texture, _this.samples);
        }
      });
      this._flushTextureCache();
      this._renderId++;
    }
    var target;
    if (this._shareOutputWithPostProcess) {
      target = this._shareOutputWithPostProcess.inputTexture;
    } else if (this._forcedOutputTexture) {
      target = this._forcedOutputTexture;
      this.width = this._forcedOutputTexture.width;
      this.height = this._forcedOutputTexture.height;
    } else {
      target = this.inputTexture;
      var cache = void 0;
      for (var i = 0; i < this._textureCache.length; i++) {
        if (this._textureCache[i].texture === target) {
          cache = this._textureCache[i];
          break;
        }
      }
      if (cache) {
        cache.lastUsedRenderId = this._renderId;
      }
    }
    if (this.enablePixelPerfectMode) {
      this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);
      this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);
    } else {
      this._scaleRatio.copyFromFloats(1, 1);
      this._engine.bindFramebuffer(target, 0, void 0, void 0, this.forceFullscreenViewport);
    }
    (_b = (_a = this._engine)._debugInsertMarker) === null || _b === void 0 ? void 0 : _b.call(_a, "post process ".concat(this.name, " input"));
    this.onActivateObservable.notifyObservers(camera);
    if (this.autoClear && this.alphaMode === 0) {
      this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);
    }
    if (this._reusable) {
      this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;
    }
    return target;
  };
  Object.defineProperty(PostProcess2.prototype, "isSupported", {
    get: function() {
      return this._drawWrapper.effect.isSupported;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PostProcess2.prototype, "aspectRatio", {
    get: function() {
      if (this._shareOutputWithPostProcess) {
        return this._shareOutputWithPostProcess.aspectRatio;
      }
      if (this._forcedOutputTexture) {
        return this._forcedOutputTexture.width / this._forcedOutputTexture.height;
      }
      return this.width / this.height;
    },
    enumerable: false,
    configurable: true
  });
  PostProcess2.prototype.isReady = function() {
    var _a, _b;
    return (_b = (_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;
  };
  PostProcess2.prototype.apply = function() {
    var _a;
    if (!((_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady())) {
      return null;
    }
    this._engine.enableEffect(this._drawWrapper);
    this._engine.setState(false);
    this._engine.setDepthBuffer(false);
    this._engine.setDepthWrite(false);
    this._engine.setAlphaMode(this.alphaMode);
    if (this.alphaConstants) {
      this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);
    }
    var source;
    if (this._shareOutputWithPostProcess) {
      source = this._shareOutputWithPostProcess.inputTexture;
    } else if (this._forcedOutputTexture) {
      source = this._forcedOutputTexture;
    } else {
      source = this.inputTexture;
    }
    if (!this.externalTextureSamplerBinding) {
      this._drawWrapper.effect._bindTexture("textureSampler", source === null || source === void 0 ? void 0 : source.texture);
    }
    this._drawWrapper.effect.setVector2("scale", this._scaleRatio);
    this.onApplyObservable.notifyObservers(this._drawWrapper.effect);
    return this._drawWrapper.effect;
  };
  PostProcess2.prototype._disposeTextures = function() {
    if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {
      this._disposeTextureCache();
      return;
    }
    this._disposeTextureCache();
    this._textures.dispose();
  };
  PostProcess2.prototype._disposeTextureCache = function() {
    for (var i = this._textureCache.length - 1; i >= 0; i--) {
      this._textureCache[i].texture.dispose();
    }
    this._textureCache.length = 0;
  };
  PostProcess2.prototype.setPrePassRenderer = function(prePassRenderer) {
    if (this._prePassEffectConfiguration) {
      this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);
      this._prePassEffectConfiguration.enabled = true;
      return true;
    }
    return false;
  };
  PostProcess2.prototype.dispose = function(camera) {
    camera = camera || this._camera;
    this._disposeTextures();
    var index;
    if (this._scene) {
      index = this._scene.postProcesses.indexOf(this);
      if (index !== -1) {
        this._scene.postProcesses.splice(index, 1);
      }
    }
    if (this._parentContainer) {
      var index_1 = this._parentContainer.postProcesses.indexOf(this);
      if (index_1 > -1) {
        this._parentContainer.postProcesses.splice(index_1, 1);
      }
      this._parentContainer = null;
    }
    index = this._engine.postProcesses.indexOf(this);
    if (index !== -1) {
      this._engine.postProcesses.splice(index, 1);
    }
    if (!camera) {
      return;
    }
    camera.detachPostProcess(this);
    index = camera._postProcesses.indexOf(this);
    if (index === 0 && camera._postProcesses.length > 0) {
      var firstPostProcess = this._camera._getFirstPostProcess();
      if (firstPostProcess) {
        firstPostProcess.markTextureDirty();
      }
    }
    this.onActivateObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onApplyObservable.clear();
    this.onBeforeRenderObservable.clear();
    this.onSizeChangedObservable.clear();
  };
  PostProcess2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    var camera = this.getCamera() || this._scene && this._scene.activeCamera;
    serializationObject.customType = "BABYLON." + this.getClassName();
    serializationObject.cameraId = camera ? camera.id : null;
    serializationObject.reusable = this._reusable;
    serializationObject.textureType = this._textureType;
    serializationObject.fragmentUrl = this._fragmentUrl;
    serializationObject.parameters = this._parameters;
    serializationObject.samplers = this._samplers;
    serializationObject.options = this._options;
    serializationObject.defines = this._postProcessDefines;
    serializationObject.textureFormat = this._textureFormat;
    serializationObject.vertexUrl = this._vertexUrl;
    serializationObject.indexParameters = this._indexParameters;
    return serializationObject;
  };
  PostProcess2.prototype.clone = function() {
    var serializationObject = this.serialize();
    serializationObject._engine = this._engine;
    serializationObject.cameraId = null;
    var result = PostProcess2.Parse(serializationObject, this._scene, "");
    if (!result) {
      return null;
    }
    result.onActivateObservable = this.onActivateObservable.clone();
    result.onSizeChangedObservable = this.onSizeChangedObservable.clone();
    result.onApplyObservable = this.onApplyObservable.clone();
    result.onBeforeRenderObservable = this.onBeforeRenderObservable.clone();
    result.onAfterRenderObservable = this.onAfterRenderObservable.clone();
    result._prePassEffectConfiguration = this._prePassEffectConfiguration;
    return result;
  };
  PostProcess2.Parse = function(parsedPostProcess, scene, rootUrl) {
    var postProcessType = GetClass(parsedPostProcess.customType);
    if (!postProcessType || !postProcessType._Parse) {
      return null;
    }
    var camera = scene ? scene.getCameraById(parsedPostProcess.cameraId) : null;
    return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);
  };
  PostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new PostProcess2(parsedPostProcess.name, parsedPostProcess.fragmentUrl, parsedPostProcess.parameters, parsedPostProcess.samplers, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable, parsedPostProcess.defines, parsedPostProcess.textureType, parsedPostProcess.vertexUrl, parsedPostProcess.indexParameters, false, parsedPostProcess.textureFormat);
    }, parsedPostProcess, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], PostProcess2.prototype, "uniqueId", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "name", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "width", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "height", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "renderTargetSamplingMode", void 0);
  __decorate([
    serializeAsColor4()
  ], PostProcess2.prototype, "clearColor", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "autoClear", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "alphaMode", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "alphaConstants", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "enablePixelPerfectMode", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "forceFullscreenViewport", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "scaleMode", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "alwaysForcePOT", void 0);
  __decorate([
    serialize("samples")
  ], PostProcess2.prototype, "_samples", void 0);
  __decorate([
    serialize()
  ], PostProcess2.prototype, "adaptScaleToCurrentViewport", void 0);
  return PostProcess2;
}();
RegisterClass("BABYLON.PostProcess", PostProcess);
var name$1l = "kernelBlurVaryingDeclaration";
var shader$1l = "varying vec2 sampleCoord{X};";
ShaderStore.IncludesShadersStore[name$1l] = shader$1l;
var name$1k = "packingFunctions";
var shader$1k = "vec4 pack(float depth)\n{\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\nvec4 res=fract(depth*bit_shift);\nres-=res.xxyz*bit_mask;\nreturn res;\n}\nfloat unpack(vec4 color)\n{\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\nreturn dot(color,bit_shift);\n}";
ShaderStore.IncludesShadersStore[name$1k] = shader$1k;
var name$1j = "kernelBlurFragment";
var shader$1j = "#ifdef DOF\nfactor=sampleCoC(sampleCoord{X});\ncomputedWeight=KERNEL_WEIGHT{X}*factor;\nsumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;\n#else\nblend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;\n#endif";
ShaderStore.IncludesShadersStore[name$1j] = shader$1j;
var name$1i = "kernelBlurFragment2";
var shader$1i = "#ifdef DOF\nfactor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});\ncomputedWeight=KERNEL_DEP_WEIGHT{X}*factor;\nsumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_DEP_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;\n#else\nblend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;\n#endif";
ShaderStore.IncludesShadersStore[name$1i] = shader$1i;
var name$1h = "kernelBlurPixelShader";
var shader$1h = "\nuniform sampler2D textureSampler;\nuniform vec2 delta;\n\nvarying vec2 sampleCenter;\n#ifdef DOF\nuniform sampler2D circleOfConfusionSampler;\nuniform vec2 cameraMinMaxZ;\nfloat sampleDistance(in vec2 offset) {\nfloat depth=texture2D(circleOfConfusionSampler,offset).g;\nreturn cameraMinMaxZ.x+(cameraMinMaxZ.y-cameraMinMaxZ.x)*depth;\n}\nfloat sampleCoC(in vec2 offset) {\nfloat coc=texture2D(circleOfConfusionSampler,offset).r;\nreturn coc;\n}\n#endif\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\n#ifdef PACKEDFLOAT\n#include<packingFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\nfloat computedWeight=0.0;\n#ifdef PACKEDFLOAT\nfloat blend=0.;\n#else\nvec4 blend=vec4(0.);\n#endif\n#ifdef DOF\nfloat sumOfWeights=CENTER_WEIGHT;\nfloat factor=0.0;\n\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;\n#else\nblend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;\n#endif\n#endif\n#include<kernelBlurFragment>[0..varyingCount]\n#include<kernelBlurFragment2>[0..depCount]\n#ifdef PACKEDFLOAT\ngl_FragColor=pack(blend);\n#else\ngl_FragColor=blend;\n#endif\n#ifdef DOF\ngl_FragColor/=sumOfWeights;\n#endif\n}";
ShaderStore.ShadersStore[name$1h] = shader$1h;
var name$1g = "kernelBlurVertex";
var shader$1g = "sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};";
ShaderStore.IncludesShadersStore[name$1g] = shader$1g;
var name$1f = "kernelBlurVertexShader";
var shader$1f = "\nattribute vec2 position;\n\nuniform vec2 delta;\n\nvarying vec2 sampleCenter;\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\nconst vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nsampleCenter=(position*madd+madd);\n#include<kernelBlurVertex>[0..varyingCount]\ngl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}";
ShaderStore.ShadersStore[name$1f] = shader$1f;
var BlurPostProcess = function(_super) {
  __extends(BlurPostProcess2, _super);
  function BlurPostProcess2(name2, direction, kernel, options, camera, samplingMode, engine, reusable, textureType, defines, blockCompilation) {
    if (samplingMode === void 0) {
      samplingMode = Texture.BILINEAR_SAMPLINGMODE;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    if (defines === void 0) {
      defines = "";
    }
    if (blockCompilation === void 0) {
      blockCompilation = false;
    }
    var _this = _super.call(this, name2, "kernelBlur", ["delta", "direction", "cameraMinMaxZ"], ["circleOfConfusionSampler"], options, camera, samplingMode, engine, reusable, null, textureType, "kernelBlur", { varyingCount: 0, depCount: 0 }, true) || this;
    _this.blockCompilation = blockCompilation;
    _this._packedFloat = false;
    _this._staticDefines = "";
    _this._staticDefines = defines;
    _this.direction = direction;
    _this.onApplyObservable.add(function(effect) {
      if (_this._outputTexture) {
        effect.setFloat2("delta", 1 / _this._outputTexture.width * _this.direction.x, 1 / _this._outputTexture.height * _this.direction.y);
      } else {
        effect.setFloat2("delta", 1 / _this.width * _this.direction.x, 1 / _this.height * _this.direction.y);
      }
    });
    _this.kernel = kernel;
    return _this;
  }
  Object.defineProperty(BlurPostProcess2.prototype, "kernel", {
    get: function() {
      return this._idealKernel;
    },
    set: function(v) {
      if (this._idealKernel === v) {
        return;
      }
      v = Math.max(v, 1);
      this._idealKernel = v;
      this._kernel = this._nearestBestKernel(v);
      if (!this.blockCompilation) {
        this._updateParameters();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BlurPostProcess2.prototype, "packedFloat", {
    get: function() {
      return this._packedFloat;
    },
    set: function(v) {
      if (this._packedFloat === v) {
        return;
      }
      this._packedFloat = v;
      if (!this.blockCompilation) {
        this._updateParameters();
      }
    },
    enumerable: false,
    configurable: true
  });
  BlurPostProcess2.prototype.getClassName = function() {
    return "BlurPostProcess";
  };
  BlurPostProcess2.prototype.updateEffect = function(defines, uniforms, samplers, indexParameters, onCompiled, onError) {
    this._updateParameters(onCompiled, onError);
  };
  BlurPostProcess2.prototype._updateParameters = function(onCompiled, onError) {
    var N = this._kernel;
    var centerIndex = (N - 1) / 2;
    var offsets = [];
    var weights = [];
    var totalWeight = 0;
    for (var i = 0; i < N; i++) {
      var u = i / (N - 1);
      var w = this._gaussianWeight(u * 2 - 1);
      offsets[i] = i - centerIndex;
      weights[i] = w;
      totalWeight += w;
    }
    for (var i = 0; i < weights.length; i++) {
      weights[i] /= totalWeight;
    }
    var linearSamplingWeights = [];
    var linearSamplingOffsets = [];
    var linearSamplingMap = [];
    for (var i = 0; i <= centerIndex; i += 2) {
      var j = Math.min(i + 1, Math.floor(centerIndex));
      var singleCenterSample = i === j;
      if (singleCenterSample) {
        linearSamplingMap.push({ o: offsets[i], w: weights[i] });
      } else {
        var sharedCell = j === centerIndex;
        var weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);
        var offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);
        if (offsetLinear === 0) {
          linearSamplingMap.push({ o: offsets[i], w: weights[i] });
          linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });
        } else {
          linearSamplingMap.push({ o: offsetLinear, w: weightLinear });
          linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });
        }
      }
    }
    for (var i = 0; i < linearSamplingMap.length; i++) {
      linearSamplingOffsets[i] = linearSamplingMap[i].o;
      linearSamplingWeights[i] = linearSamplingMap[i].w;
    }
    offsets = linearSamplingOffsets;
    weights = linearSamplingWeights;
    var maxVaryingRows = this.getEngine().getCaps().maxVaryingVectors;
    var freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1;
    var varyingCount = Math.min(offsets.length, freeVaryingVec2);
    var defines = "";
    defines += this._staticDefines;
    if (this._staticDefines.indexOf("DOF") != -1) {
      defines += "#define CENTER_WEIGHT ".concat(this._glslFloat(weights[varyingCount - 1]), "\r\n");
      varyingCount--;
    }
    for (var i = 0; i < varyingCount; i++) {
      defines += "#define KERNEL_OFFSET".concat(i, " ").concat(this._glslFloat(offsets[i]), "\r\n");
      defines += "#define KERNEL_WEIGHT".concat(i, " ").concat(this._glslFloat(weights[i]), "\r\n");
    }
    var depCount = 0;
    for (var i = freeVaryingVec2; i < offsets.length; i++) {
      defines += "#define KERNEL_DEP_OFFSET".concat(depCount, " ").concat(this._glslFloat(offsets[i]), "\r\n");
      defines += "#define KERNEL_DEP_WEIGHT".concat(depCount, " ").concat(this._glslFloat(weights[i]), "\r\n");
      depCount++;
    }
    if (this.packedFloat) {
      defines += "#define PACKEDFLOAT 1";
    }
    this.blockCompilation = false;
    _super.prototype.updateEffect.call(this, defines, null, null, {
      varyingCount,
      depCount
    }, onCompiled, onError);
  };
  BlurPostProcess2.prototype._nearestBestKernel = function(idealKernel) {
    var v = Math.round(idealKernel);
    for (var _i = 0, _a = [v, v - 1, v + 1, v - 2, v + 2]; _i < _a.length; _i++) {
      var k = _a[_i];
      if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {
        return Math.max(k, 3);
      }
    }
    return Math.max(v, 3);
  };
  BlurPostProcess2.prototype._gaussianWeight = function(x) {
    var sigma = 1 / 3;
    var denominator = Math.sqrt(2 * Math.PI) * sigma;
    var exponent = -(x * x / (2 * sigma * sigma));
    var weight = 1 / denominator * Math.exp(exponent);
    return weight;
  };
  BlurPostProcess2.prototype._glslFloat = function(x, decimalFigures) {
    if (decimalFigures === void 0) {
      decimalFigures = 8;
    }
    return x.toFixed(decimalFigures).replace(/0+$/, "");
  };
  BlurPostProcess2._Parse = function(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new BlurPostProcess2(parsedPostProcess.name, parsedPostProcess.direction, parsedPostProcess.kernel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, void 0, false);
    }, parsedPostProcess, scene, rootUrl);
  };
  __decorate([
    serialize("kernel")
  ], BlurPostProcess2.prototype, "_kernel", void 0);
  __decorate([
    serialize("packedFloat")
  ], BlurPostProcess2.prototype, "_packedFloat", void 0);
  __decorate([
    serializeAsVector2()
  ], BlurPostProcess2.prototype, "direction", void 0);
  return BlurPostProcess2;
}(PostProcess);
RegisterClass("BABYLON.BlurPostProcess", BlurPostProcess);
var EffectFallbacks = function() {
  function EffectFallbacks2() {
    this._defines = {};
    this._currentRank = 32;
    this._maxRank = -1;
    this._mesh = null;
  }
  EffectFallbacks2.prototype.unBindMesh = function() {
    this._mesh = null;
  };
  EffectFallbacks2.prototype.addFallback = function(rank, define) {
    if (!this._defines[rank]) {
      if (rank < this._currentRank) {
        this._currentRank = rank;
      }
      if (rank > this._maxRank) {
        this._maxRank = rank;
      }
      this._defines[rank] = new Array();
    }
    this._defines[rank].push(define);
  };
  EffectFallbacks2.prototype.addCPUSkinningFallback = function(rank, mesh) {
    this._mesh = mesh;
    if (rank < this._currentRank) {
      this._currentRank = rank;
    }
    if (rank > this._maxRank) {
      this._maxRank = rank;
    }
  };
  Object.defineProperty(EffectFallbacks2.prototype, "hasMoreFallbacks", {
    get: function() {
      return this._currentRank <= this._maxRank;
    },
    enumerable: false,
    configurable: true
  });
  EffectFallbacks2.prototype.reduce = function(currentDefines, effect) {
    if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {
      this._mesh.computeBonesUsingShaders = false;
      currentDefines = currentDefines.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0");
      effect._bonesComputationForcedToCPU = true;
      var scene = this._mesh.getScene();
      for (var index = 0; index < scene.meshes.length; index++) {
        var otherMesh = scene.meshes[index];
        if (!otherMesh.material) {
          if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {
            otherMesh.computeBonesUsingShaders = false;
          }
          continue;
        }
        if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {
          continue;
        }
        if (otherMesh.material.getEffect() === effect) {
          otherMesh.computeBonesUsingShaders = false;
        } else if (otherMesh.subMeshes) {
          for (var _i = 0, _a = otherMesh.subMeshes; _i < _a.length; _i++) {
            var subMesh = _a[_i];
            var subMeshEffect = subMesh.effect;
            if (subMeshEffect === effect) {
              otherMesh.computeBonesUsingShaders = false;
              break;
            }
          }
        }
      }
    } else {
      var currentFallbacks = this._defines[this._currentRank];
      if (currentFallbacks) {
        for (var index = 0; index < currentFallbacks.length; index++) {
          currentDefines = currentDefines.replace("#define " + currentFallbacks[index], "");
        }
      }
      this._currentRank++;
    }
    return currentDefines;
  };
  return EffectFallbacks2;
}();
var name$1e = "bayerDitherFunctions";
var shader$1e = "\n\n\n\n\nfloat bayerDither2(vec2 _P) {\nreturn mod(2.0*_P.y+_P.x+1.0,4.0);\n}\n\n\nfloat bayerDither4(vec2 _P) {\nvec2 P1=mod(_P,2.0);\nvec2 P2=floor(0.5*mod(_P,4.0));\nreturn 4.0*bayerDither2(P1)+bayerDither2(P2);\n}\n\nfloat bayerDither8(vec2 _P) {\nvec2 P1=mod(_P,2.0);\nvec2 P2=floor(0.5*mod(_P,4.0));\nvec2 P4=floor(0.25*mod(_P,8.0));\nreturn 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);\n}\n";
ShaderStore.IncludesShadersStore[name$1e] = shader$1e;
var name$1d = "shadowMapFragmentExtraDeclaration";
var shader$1d = "#if SM_FLOAT == 0\n#include<packingFunctions>\n#endif\n#if SM_SOFTTRANSPARENTSHADOW == 1\n#include<bayerDitherFunctions>\nuniform float softTransparentShadowSM;\n#endif\nvarying float vDepthMetricSM;\n#if SM_USEDISTANCE == 1\nuniform vec3 lightDataSM;\nvarying vec3 vPositionWSM;\n#endif\nuniform vec3 biasAndScaleSM;\nuniform vec2 depthValuesSM;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP == 1\nvarying float zSM;\n#endif\n";
ShaderStore.IncludesShadersStore[name$1d] = shader$1d;
var name$1c = "clipPlaneFragmentDeclaration";
var shader$1c = "#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif";
ShaderStore.IncludesShadersStore[name$1c] = shader$1c;
var name$1b = "clipPlaneFragment";
var shader$1b = "#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\n\n\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\n{\ndiscard;\n}\n#endif";
ShaderStore.IncludesShadersStore[name$1b] = shader$1b;
var name$1a = "shadowMapFragment";
var shader$1a = " float depthSM=vDepthMetricSM;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP == 1\n#if SM_USEDISTANCE == 1\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\ndepthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#else\ndepthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#endif\n#endif\n#ifdef USE_REVERSE_DEPTHBUFFER\ngl_FragDepth=clamp(1.0-depthSM,0.0,1.0);\n#else\ngl_FragDepth=clamp(depthSM,0.0,1.0);\n#endif\n#elif SM_USEDISTANCE == 1\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#endif\n#if SM_ESM == 1\ndepthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);\n#endif\n#if SM_FLOAT == 1\ngl_FragColor=vec4(depthSM,1.0,1.0,1.0);\n#else\ngl_FragColor=pack(depthSM);\n#endif\nreturn;";
ShaderStore.IncludesShadersStore[name$1a] = shader$1a;
var name$19 = "shadowMapPixelShader";
var shader$19 = "#include<shadowMapFragmentExtraDeclaration>\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nfloat alphaFromAlphaTexture=texture2D(diffuseSampler,vUV).a;\nif (alphaFromAlphaTexture<0.4)\ndiscard;\n#endif\n#if SM_SOFTTRANSPARENTSHADOW == 1\n#ifdef ALPHATEST\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alphaFromAlphaTexture) discard;\n#else\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM) discard;\n#endif\n#endif\n#include<shadowMapFragment>\n}";
ShaderStore.ShadersStore[name$19] = shader$19;
var name$18 = "bonesDeclaration";
var shader$18 = "#if NUM_BONE_INFLUENCERS>0\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;\nattribute vec4 matricesWeightsExtra;\n#endif\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#ifdef BONETEXTURE\nuniform sampler2D boneSampler;\nuniform float boneTextureWidth;\n#else\nuniform mat4 mBones[BonesPerMesh];\n#ifdef BONES_VELOCITY_ENABLED\nuniform mat4 mPreviousBones[BonesPerMesh];\n#endif\n#endif\n#ifdef BONETEXTURE\n#define inline\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\n{\nfloat offset=index*4.0;\nfloat dx=1.0/boneTextureWidth;\nvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));\nvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));\nvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));\nvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));\nreturn mat4(m0,m1,m2,m3);\n}\n#endif\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$18] = shader$18;
var name$17 = "bakedVertexAnimationDeclaration";
var shader$17 = "#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\nuniform float bakedVertexAnimationTime;\nuniform vec2 bakedVertexAnimationTextureSizeInverted;\nuniform vec4 bakedVertexAnimationSettings;\nuniform sampler2D bakedVertexAnimationTexture;\n#ifdef INSTANCES\nattribute vec4 bakedVertexAnimationSettingsInstanced;\n#endif\n#define inline\nmat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)\n{\nfloat offset=index*4.0;\nfloat frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;\nfloat dx=bakedVertexAnimationTextureSizeInverted.x;\nvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));\nvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));\nvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));\nvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));\nreturn mat4(m0,m1,m2,m3);\n}\n#endif";
ShaderStore.IncludesShadersStore[name$17] = shader$17;
var name$16 = "morphTargetsVertexGlobalDeclaration";
var shader$16 = "#ifdef MORPHTARGETS\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\n#ifdef MORPHTARGETS_TEXTURE\nprecision mediump sampler2DArray;\nuniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];\nuniform vec3 morphTargetTextureInfo;\nuniform sampler2DArray morphTargets;\nvec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)\n{\nfloat y=floor(vertexIndex/morphTargetTextureInfo.y);\nfloat x=vertexIndex-y*morphTargetTextureInfo.y;\nvec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);\nreturn texture(morphTargets,textureUV).xyz;\n}\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$16] = shader$16;
var name$15 = "morphTargetsVertexDeclaration";
var shader$15 = "#ifdef MORPHTARGETS\n#ifndef MORPHTARGETS_TEXTURE\nattribute vec3 position{X};\n#ifdef MORPHTARGETS_NORMAL\nattribute vec3 normal{X};\n#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute vec3 tangent{X};\n#endif\n#ifdef MORPHTARGETS_UV\nattribute vec2 uv_{X};\n#endif\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$15] = shader$15;
var name$14 = "helperFunctions";
var shader$14 = "const float PI=3.1415926535897932384626433832795;\nconst float HALF_MIN=5.96046448e-08;\nconst float LinearEncodePowerApprox=2.2;\nconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\nconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\nconst float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {\nvec3 i0=inMatrix[0];\nvec3 i1=inMatrix[1];\nvec3 i2=inMatrix[2];\nmat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);\nreturn outMatrix;\n}\n\nmat3 inverseMat3(mat3 inMatrix) {\nfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\nfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\nfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\nfloat b01=a22*a11-a12*a21;\nfloat b11=-a22*a10+a12*a20;\nfloat b21=a21*a10-a11*a20;\nfloat det=a00*b01+a01*b11+a02*b21;\nreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\n}\nfloat toLinearSpace(float color)\n{\nreturn pow(color,LinearEncodePowerApprox);\n}\nvec3 toLinearSpace(vec3 color)\n{\nreturn pow(color,vec3(LinearEncodePowerApprox));\n}\nvec4 toLinearSpace(vec4 color)\n{\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n}\nvec3 toGammaSpace(vec3 color)\n{\nreturn pow(color,vec3(GammaEncodePowerApprox));\n}\nvec4 toGammaSpace(vec4 color)\n{\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n}\nfloat toGammaSpace(float color)\n{\nreturn pow(color,GammaEncodePowerApprox);\n}\nfloat square(float value)\n{\nreturn value*value;\n}\nfloat pow5(float value) {\nfloat sq=value*value;\nreturn sq*sq*value;\n}\nfloat getLuminance(vec3 color)\n{\nreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\n}\n\nfloat getRand(vec2 seed) {\nreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\nfloat dither(vec2 seed,float varianceAmount) {\nfloat rand=getRand(seed);\nfloat dither=mix(-varianceAmount/255.0,varianceAmount/255.0,rand);\nreturn dither;\n}\n\nconst float rgbdMaxRange=255.0;\nvec4 toRGBD(vec3 color) {\nfloat maxRGB=maxEps(max(color.r,max(color.g,color.b)));\nfloat D=max(rgbdMaxRange/maxRGB,1.);\nD=clamp(floor(D)/255.0,0.,1.);\n\nvec3 rgb=color.rgb*D;\n\nrgb=toGammaSpace(rgb);\nreturn vec4(clamp(rgb,0.,1.),D);\n}\nvec3 fromRGBD(vec4 rgbd) {\n\nrgbd.rgb=toLinearSpace(rgbd.rgb);\n\nreturn rgbd.rgb/rgbd.a;\n}\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\n\nvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\nvec3 halfSize=cubeSize*0.5;\nvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\nvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\n\nvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\n\nfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\n\nvec3 intersectPositionWS=vertexPos+origVec*distance;\n\nreturn intersectPositionWS-cubePos;\n}\n";
ShaderStore.IncludesShadersStore[name$14] = shader$14;
var name$13 = "sceneVertexDeclaration";
var shader$13 = "uniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\nuniform mat4 view;\nuniform mat4 projection;\nuniform vec4 vEyePosition;\n";
ShaderStore.IncludesShadersStore[name$13] = shader$13;
var name$12 = "meshVertexDeclaration";
var shader$12 = "uniform mat4 world;\nuniform float visibility;\n";
ShaderStore.IncludesShadersStore[name$12] = shader$12;
var name$11 = "shadowMapVertexDeclaration";
var shader$11 = "#include<sceneVertexDeclaration>\n#include<meshVertexDeclaration>\n";
ShaderStore.IncludesShadersStore[name$11] = shader$11;
var name$10 = "sceneUboDeclaration";
var shader$10 = "layout(std140,column_major) uniform;\nuniform Scene {\nmat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif\nmat4 view;\nmat4 projection;\nvec4 vEyePosition;\n};\n";
ShaderStore.IncludesShadersStore[name$10] = shader$10;
var name$$ = "meshUboDeclaration";
var shader$$ = "layout(std140,column_major) uniform;\nuniform Mesh\n{\nmat4 world;\nfloat visibility;\n};\n#define WORLD_UBO";
ShaderStore.IncludesShadersStore[name$$] = shader$$;
var name$_ = "shadowMapUboDeclaration";
var shader$_ = "layout(std140,column_major) uniform;\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n";
ShaderStore.IncludesShadersStore[name$_] = shader$_;
var name$Z = "shadowMapVertexExtraDeclaration";
var shader$Z = "#if SM_NORMALBIAS == 1\nuniform vec3 lightDataSM;\n#endif\nuniform vec3 biasAndScaleSM;\nuniform vec2 depthValuesSM;\nvarying float vDepthMetricSM;\n#if SM_USEDISTANCE == 1\nvarying vec3 vPositionWSM;\n#endif\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP == 1\nvarying float zSM;\n#endif\n";
ShaderStore.IncludesShadersStore[name$Z] = shader$Z;
var name$Y = "clipPlaneVertexDeclaration";
var shader$Y = "#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;\nvarying float fClipDistance6;\n#endif";
ShaderStore.IncludesShadersStore[name$Y] = shader$Y;
var name$X = "morphTargetsVertexGlobal";
var shader$X = "#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\nfloat vertexID;\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$X] = shader$X;
var name$W = "morphTargetsVertex";
var shader$W = "#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\nvertexID=float(gl_VertexID)*morphTargetTextureInfo.x;\npositionUpdated+=(readVector3FromRawSampler({X},vertexID)-position)*morphTargetInfluences[{X}];\nvertexID+=1.0;\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(readVector3FromRawSampler({X},vertexID)-normal)*morphTargetInfluences[{X}];\nvertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(readVector3FromRawSampler({X},vertexID).xy-uv)*morphTargetInfluences[{X}];\nvertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(readVector3FromRawSampler({X},vertexID)-tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#else\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\n#endif\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$W] = shader$W;
var name$V = "instancesVertex";
var shader$V = "#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);\n#endif\n#ifdef THIN_INSTANCES\nfinalWorld=world*finalWorld;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nfinalPreviousWorld=previousWorld*finalPreviousWorld;\n#endif\n#endif\n#else\nmat4 finalWorld=world;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=previousWorld;\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$V] = shader$V;
var name$U = "bonesVertex";
var shader$U = "#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\n#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\n#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\n#endif\nfinalWorld=finalWorld*influence;\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$U] = shader$U;
var name$T = "bakedVertexAnimation";
var shader$T = "#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\n{\n#ifdef INSTANCES\n#define BVASNAME bakedVertexAnimationSettingsInstanced\n#else\n#define BVASNAME bakedVertexAnimationSettings\n#endif\n\nfloat VATStartFrame=BVASNAME.x;\nfloat VATEndFrame=BVASNAME.y;\nfloat VATOffsetFrame=BVASNAME.z;\nfloat VATSpeed=BVASNAME.w;\nfloat totalFrames=VATEndFrame-VATStartFrame+1.0;\nfloat time=bakedVertexAnimationTime*VATSpeed/totalFrames;\n\nfloat frameCorrection=time<1.0 ? 0.0 : 1.0;\nfloat numOfFrames=totalFrames-frameCorrection;\nfloat VATFrameNum=fract(time)*numOfFrames;\nVATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);\nVATFrameNum=floor(VATFrameNum);\nVATFrameNum+=VATStartFrame+frameCorrection;\nmat4 VATInfluence;\nVATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];\n#endif\nfinalWorld=finalWorld*VATInfluence;\n}\n#endif";
ShaderStore.IncludesShadersStore[name$T] = shader$T;
var name$S = "shadowMapVertexNormalBias";
var shader$S = "\n#if SM_NORMALBIAS == 1\n#if SM_DIRECTIONINLIGHTDATA == 1\nvec3 worldLightDirSM=normalize(-lightDataSM.xyz);\n#else\nvec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;\nvec3 worldLightDirSM=normalize(directionToLightSM);\n#endif\nfloat ndlSM=dot(vNormalW,worldLightDirSM);\nfloat sinNLSM=sqrt(1.0-ndlSM*ndlSM);\nfloat normalBiasSM=biasAndScaleSM.y*sinNLSM;\nworldPos.xyz-=vNormalW*normalBiasSM;\n#endif\n";
ShaderStore.IncludesShadersStore[name$S] = shader$S;
var name$R = "shadowMapVertexMetric";
var shader$R = "#if SM_USEDISTANCE == 1\nvPositionWSM=worldPos.xyz;\n#endif\n#if SM_DEPTHTEXTURE == 1\n#ifdef IS_NDC_HALF_ZRANGE\n#define BIASFACTOR 0.5\n#else\n#define BIASFACTOR 1.0\n#endif\n\n#ifdef USE_REVERSE_DEPTHBUFFER\ngl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;\n#else\ngl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;\n#endif\n#endif\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP == 1\nzSM=gl_Position.z;\ngl_Position.z=0.0;\n#elif SM_USEDISTANCE == 0\n\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#else\nvDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#endif\n#endif\n";
ShaderStore.IncludesShadersStore[name$R] = shader$R;
var name$Q = "clipPlaneVertex";
var shader$Q = "#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif";
ShaderStore.IncludesShadersStore[name$Q] = shader$Q;
var name$P = "shadowMapVertexShader";
var shader$P = "\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n\n#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#endif\n#include<helperFunctions>\n#include<__decl__shadowMapVertex>\n#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#include<shadowMapVertexExtraDeclaration>\n#include<clipPlaneVertexDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{\nvec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normWorldSM=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));\nvNormalW=normalize(normWorldSM*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormWorldSM=transposeMat3(inverseMat3(normWorldSM));\n#endif\nvec3 vNormalW=normalize(normWorldSM*normalUpdated);\n#endif\n#endif\n#include<shadowMapVertexNormalBias>\n\ngl_Position=viewProjection*worldPos;\n#include<shadowMapVertexMetric>\n#ifdef ALPHATEST\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#include<clipPlaneVertex>\n}";
ShaderStore.ShadersStore[name$P] = shader$P;
var name$O = "depthBoxBlurPixelShader";
var shader$O = "\nvarying vec2 vUV;\nuniform sampler2D textureSampler;\n\nuniform vec2 screenSize;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\nvec4 colorDepth=vec4(0.0);\nfor (int x=-OFFSET; x<=OFFSET; x++)\nfor (int y=-OFFSET; y<=OFFSET; y++)\ncolorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);\ngl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));\n}";
ShaderStore.ShadersStore[name$O] = shader$O;
var name$N = "shadowMapFragmentSoftTransparentShadow";
var shader$N = "#if SM_SOFTTRANSPARENTSHADOW == 1\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alpha) discard;\n#endif\n";
ShaderStore.IncludesShadersStore[name$N] = shader$N;
var ShadowGenerator = function() {
  function ShadowGenerator2(mapSize, light, usefullFloatFirst) {
    this.onBeforeShadowMapRenderObservable = new Observable();
    this.onAfterShadowMapRenderObservable = new Observable();
    this.onBeforeShadowMapRenderMeshObservable = new Observable();
    this.onAfterShadowMapRenderMeshObservable = new Observable();
    this._bias = 5e-5;
    this._normalBias = 0;
    this._blurBoxOffset = 1;
    this._blurScale = 2;
    this._blurKernel = 1;
    this._useKernelBlur = false;
    this._filter = ShadowGenerator2.FILTER_NONE;
    this._filteringQuality = ShadowGenerator2.QUALITY_HIGH;
    this._contactHardeningLightSizeUVRatio = 0.1;
    this._darkness = 0;
    this._transparencyShadow = false;
    this.enableSoftTransparentShadow = false;
    this.frustumEdgeFalloff = 0;
    this.forceBackFacesOnly = false;
    this._lightDirection = Vector3.Zero();
    this._viewMatrix = Matrix.Zero();
    this._projectionMatrix = Matrix.Zero();
    this._transformMatrix = Matrix.Zero();
    this._cachedPosition = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cachedDirection = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._currentFaceIndex = 0;
    this._currentFaceIndexCache = 0;
    this._defaultTextureMatrix = Matrix.Identity();
    this._mapSize = mapSize;
    this._light = light;
    this._scene = light.getScene();
    light._shadowGenerator = this;
    this.id = light.id;
    this._useUBO = this._scene.getEngine().supportsUniformBuffers;
    if (this._useUBO) {
      this._sceneUBOs = [];
      this._sceneUBOs.push(this._scene.createSceneUniformBuffer('Scene for Shadow Generator (light "'.concat(this._light.name, '")')));
    }
    ShadowGenerator2._SceneComponentInitialization(this._scene);
    var caps = this._scene.getEngine().getCaps();
    if (!usefullFloatFirst) {
      if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
        this._textureType = 2;
      } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
        this._textureType = 1;
      } else {
        this._textureType = 0;
      }
    } else {
      if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
        this._textureType = 1;
      } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
        this._textureType = 2;
      } else {
        this._textureType = 0;
      }
    }
    this._initializeGenerator();
    this._applyFilterValues();
  }
  Object.defineProperty(ShadowGenerator2.prototype, "bias", {
    get: function() {
      return this._bias;
    },
    set: function(bias) {
      this._bias = bias;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "normalBias", {
    get: function() {
      return this._normalBias;
    },
    set: function(normalBias) {
      this._normalBias = normalBias;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "blurBoxOffset", {
    get: function() {
      return this._blurBoxOffset;
    },
    set: function(value) {
      if (this._blurBoxOffset === value) {
        return;
      }
      this._blurBoxOffset = value;
      this._disposeBlurPostProcesses();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "blurScale", {
    get: function() {
      return this._blurScale;
    },
    set: function(value) {
      if (this._blurScale === value) {
        return;
      }
      this._blurScale = value;
      this._disposeBlurPostProcesses();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "blurKernel", {
    get: function() {
      return this._blurKernel;
    },
    set: function(value) {
      if (this._blurKernel === value) {
        return;
      }
      this._blurKernel = value;
      this._disposeBlurPostProcesses();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "useKernelBlur", {
    get: function() {
      return this._useKernelBlur;
    },
    set: function(value) {
      if (this._useKernelBlur === value) {
        return;
      }
      this._useKernelBlur = value;
      this._disposeBlurPostProcesses();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "depthScale", {
    get: function() {
      return this._depthScale !== void 0 ? this._depthScale : this._light.getDepthScale();
    },
    set: function(value) {
      this._depthScale = value;
    },
    enumerable: false,
    configurable: true
  });
  ShadowGenerator2.prototype._validateFilter = function(filter) {
    return filter;
  };
  Object.defineProperty(ShadowGenerator2.prototype, "filter", {
    get: function() {
      return this._filter;
    },
    set: function(value) {
      value = this._validateFilter(value);
      if (this._light.needCube()) {
        if (value === ShadowGenerator2.FILTER_BLUREXPONENTIALSHADOWMAP) {
          this.useExponentialShadowMap = true;
          return;
        } else if (value === ShadowGenerator2.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
          this.useCloseExponentialShadowMap = true;
          return;
        } else if (value === ShadowGenerator2.FILTER_PCF || value === ShadowGenerator2.FILTER_PCSS) {
          this.usePoissonSampling = true;
          return;
        }
      }
      if (value === ShadowGenerator2.FILTER_PCF || value === ShadowGenerator2.FILTER_PCSS) {
        if (!this._scene.getEngine()._features.supportShadowSamplers) {
          this.usePoissonSampling = true;
          return;
        }
      }
      if (this._filter === value) {
        return;
      }
      this._filter = value;
      this._disposeBlurPostProcesses();
      this._applyFilterValues();
      this._light._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "usePoissonSampling", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_POISSONSAMPLING;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_POISSONSAMPLING);
      if (!value && this.filter !== ShadowGenerator2.FILTER_POISSONSAMPLING) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "useExponentialShadowMap", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_EXPONENTIALSHADOWMAP;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_EXPONENTIALSHADOWMAP);
      if (!value && this.filter !== ShadowGenerator2.FILTER_EXPONENTIALSHADOWMAP) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "useBlurExponentialShadowMap", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_BLUREXPONENTIALSHADOWMAP;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_BLUREXPONENTIALSHADOWMAP);
      if (!value && this.filter !== ShadowGenerator2.FILTER_BLUREXPONENTIALSHADOWMAP) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "useCloseExponentialShadowMap", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_CLOSEEXPONENTIALSHADOWMAP;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_CLOSEEXPONENTIALSHADOWMAP);
      if (!value && this.filter !== ShadowGenerator2.FILTER_CLOSEEXPONENTIALSHADOWMAP) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "useBlurCloseExponentialShadowMap", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);
      if (!value && this.filter !== ShadowGenerator2.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "usePercentageCloserFiltering", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_PCF;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_PCF);
      if (!value && this.filter !== ShadowGenerator2.FILTER_PCF) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "filteringQuality", {
    get: function() {
      return this._filteringQuality;
    },
    set: function(filteringQuality) {
      if (this._filteringQuality === filteringQuality) {
        return;
      }
      this._filteringQuality = filteringQuality;
      this._disposeBlurPostProcesses();
      this._applyFilterValues();
      this._light._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "useContactHardeningShadow", {
    get: function() {
      return this.filter === ShadowGenerator2.FILTER_PCSS;
    },
    set: function(value) {
      var filter = this._validateFilter(ShadowGenerator2.FILTER_PCSS);
      if (!value && this.filter !== ShadowGenerator2.FILTER_PCSS) {
        return;
      }
      this.filter = value ? filter : ShadowGenerator2.FILTER_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "contactHardeningLightSizeUVRatio", {
    get: function() {
      return this._contactHardeningLightSizeUVRatio;
    },
    set: function(contactHardeningLightSizeUVRatio) {
      this._contactHardeningLightSizeUVRatio = contactHardeningLightSizeUVRatio;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShadowGenerator2.prototype, "darkness", {
    get: function() {
      return this._darkness;
    },
    set: function(value) {
      this.setDarkness(value);
    },
    enumerable: false,
    configurable: true
  });
  ShadowGenerator2.prototype.getDarkness = function() {
    return this._darkness;
  };
  ShadowGenerator2.prototype.setDarkness = function(darkness) {
    if (darkness >= 1) {
      this._darkness = 1;
    } else if (darkness <= 0) {
      this._darkness = 0;
    } else {
      this._darkness = darkness;
    }
    return this;
  };
  Object.defineProperty(ShadowGenerator2.prototype, "transparencyShadow", {
    get: function() {
      return this._transparencyShadow;
    },
    set: function(value) {
      this.setTransparencyShadow(value);
    },
    enumerable: false,
    configurable: true
  });
  ShadowGenerator2.prototype.setTransparencyShadow = function(transparent) {
    this._transparencyShadow = transparent;
    return this;
  };
  ShadowGenerator2.prototype.getShadowMap = function() {
    return this._shadowMap;
  };
  ShadowGenerator2.prototype.getShadowMapForRendering = function() {
    if (this._shadowMap2) {
      return this._shadowMap2;
    }
    return this._shadowMap;
  };
  ShadowGenerator2.prototype.getClassName = function() {
    return ShadowGenerator2.CLASSNAME;
  };
  ShadowGenerator2.prototype.addShadowCaster = function(mesh, includeDescendants) {
    if (includeDescendants === void 0) {
      includeDescendants = true;
    }
    if (!this._shadowMap) {
      return this;
    }
    if (!this._shadowMap.renderList) {
      this._shadowMap.renderList = [];
    }
    if (this._shadowMap.renderList.indexOf(mesh) === -1) {
      this._shadowMap.renderList.push(mesh);
    }
    if (includeDescendants) {
      for (var _i = 0, _a = mesh.getChildMeshes(); _i < _a.length; _i++) {
        var childMesh = _a[_i];
        if (this._shadowMap.renderList.indexOf(childMesh) === -1) {
          this._shadowMap.renderList.push(childMesh);
        }
      }
    }
    return this;
  };
  ShadowGenerator2.prototype.removeShadowCaster = function(mesh, includeDescendants) {
    if (includeDescendants === void 0) {
      includeDescendants = true;
    }
    if (!this._shadowMap || !this._shadowMap.renderList) {
      return this;
    }
    var index = this._shadowMap.renderList.indexOf(mesh);
    if (index !== -1) {
      this._shadowMap.renderList.splice(index, 1);
    }
    if (includeDescendants) {
      for (var _i = 0, _a = mesh.getChildren(); _i < _a.length; _i++) {
        var child = _a[_i];
        this.removeShadowCaster(child);
      }
    }
    return this;
  };
  ShadowGenerator2.prototype.getLight = function() {
    return this._light;
  };
  Object.defineProperty(ShadowGenerator2.prototype, "mapSize", {
    get: function() {
      return this._mapSize;
    },
    set: function(size) {
      this._mapSize = size;
      this._light._markMeshesAsLightDirty();
      this.recreateShadowMap();
    },
    enumerable: false,
    configurable: true
  });
  ShadowGenerator2.prototype._initializeGenerator = function() {
    this._light._markMeshesAsLightDirty();
    this._initializeShadowMap();
  };
  ShadowGenerator2.prototype._createTargetRenderTexture = function() {
    var engine = this._scene.getEngine();
    if (engine._features.supportDepthStencilTexture) {
      this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube(), void 0, false, false);
      this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true);
    } else {
      this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube());
    }
  };
  ShadowGenerator2.prototype._initializeShadowMap = function() {
    var _this = this;
    this._createTargetRenderTexture();
    if (this._shadowMap === null) {
      return;
    }
    this._shadowMap.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._shadowMap.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._shadowMap.anisotropicFilteringLevel = 1;
    this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    this._shadowMap.renderParticles = false;
    this._shadowMap.ignoreCameraViewport = true;
    if (this._storedUniqueId) {
      this._shadowMap.uniqueId = this._storedUniqueId;
    }
    this._shadowMap.customRenderFunction = this._renderForShadowMap.bind(this);
    this._shadowMap.customIsReadyFunction = function(m, r) {
      return true;
    };
    var engine = this._scene.getEngine();
    this._shadowMap.onBeforeBindObservable.add(function() {
      var _a;
      _this._currentSceneUBO = _this._scene.getSceneUniformBuffer();
      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, "shadow map generation for pass id ".concat(engine.currentRenderPassId), 1);
    });
    this._shadowMap.onBeforeRenderObservable.add(function(faceIndex) {
      if (_this._sceneUBOs) {
        _this._scene.setSceneUniformBuffer(_this._sceneUBOs[0]);
      }
      _this._currentFaceIndex = faceIndex;
      if (_this._filter === ShadowGenerator2.FILTER_PCF) {
        engine.setColorWrite(false);
      }
      _this.getTransformMatrix();
      _this._scene.setTransformMatrix(_this._viewMatrix, _this._projectionMatrix);
      if (_this._useUBO) {
        _this._scene.getSceneUniformBuffer().unbindEffect();
        _this._scene.finalizeSceneUbo();
      }
    });
    this._shadowMap.onAfterUnbindObservable.add(function() {
      var _a, _b;
      if (_this._sceneUBOs) {
        _this._scene.setSceneUniformBuffer(_this._currentSceneUBO);
      }
      _this._scene.updateTransformMatrix();
      if (_this._filter === ShadowGenerator2.FILTER_PCF) {
        engine.setColorWrite(true);
      }
      if (!_this.useBlurExponentialShadowMap && !_this.useBlurCloseExponentialShadowMap) {
        (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);
        return;
      }
      var shadowMap = _this.getShadowMapForRendering();
      if (shadowMap) {
        _this._scene.postProcessManager.directRender(_this._blurPostProcesses, shadowMap.renderTarget, true);
        engine.unBindFramebuffer(shadowMap.renderTarget, true);
        (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);
      }
    });
    var clearZero = new Color4$1(0, 0, 0, 0);
    var clearOne = new Color4$1(1, 1, 1, 1);
    this._shadowMap.onClearObservable.add(function(engine2) {
      if (_this._filter === ShadowGenerator2.FILTER_PCF) {
        engine2.clear(clearOne, false, true, false);
      } else if (_this.useExponentialShadowMap || _this.useBlurExponentialShadowMap) {
        engine2.clear(clearZero, true, true, false);
      } else {
        engine2.clear(clearOne, true, true, false);
      }
    });
    this._shadowMap.onResizeObservable.add(function(RTT) {
      _this._storedUniqueId = _this._shadowMap.uniqueId;
      _this._mapSize = RTT.getRenderSize();
      _this._light._markMeshesAsLightDirty();
      _this.recreateShadowMap();
    });
    for (var i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {
      this._shadowMap.setRenderingAutoClearDepthStencil(i, false);
    }
  };
  ShadowGenerator2.prototype._initializeBlurRTTAndPostProcesses = function() {
    var _this = this;
    var engine = this._scene.getEngine();
    var targetSize = this._mapSize / this.blurScale;
    if (!this.useKernelBlur || this.blurScale !== 1) {
      this._shadowMap2 = new RenderTargetTexture(this._light.name + "_shadowMap2", targetSize, this._scene, false, true, this._textureType, void 0, void 0, false);
      this._shadowMap2.wrapU = Texture.CLAMP_ADDRESSMODE;
      this._shadowMap2.wrapV = Texture.CLAMP_ADDRESSMODE;
      this._shadowMap2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    }
    if (this.useKernelBlur) {
      this._kernelBlurXPostprocess = new BlurPostProcess(this._light.name + "KernelBlurX", new Vector2(1, 0), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
      this._kernelBlurXPostprocess.width = targetSize;
      this._kernelBlurXPostprocess.height = targetSize;
      this._kernelBlurXPostprocess.externalTextureSamplerBinding = true;
      this._kernelBlurXPostprocess.onApplyObservable.add(function(effect) {
        effect.setTexture("textureSampler", _this._shadowMap);
      });
      this._kernelBlurYPostprocess = new BlurPostProcess(this._light.name + "KernelBlurY", new Vector2(0, 1), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
      this._kernelBlurXPostprocess.autoClear = false;
      this._kernelBlurYPostprocess.autoClear = false;
      if (this._textureType === 0) {
        this._kernelBlurXPostprocess.packedFloat = true;
        this._kernelBlurYPostprocess.packedFloat = true;
      }
      this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess];
    } else {
      this._boxBlurPostprocess = new PostProcess(this._light.name + "DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, "#define OFFSET " + this._blurBoxOffset, this._textureType);
      this._boxBlurPostprocess.externalTextureSamplerBinding = true;
      this._boxBlurPostprocess.onApplyObservable.add(function(effect) {
        effect.setFloat2("screenSize", targetSize, targetSize);
        effect.setTexture("textureSampler", _this._shadowMap);
      });
      this._boxBlurPostprocess.autoClear = false;
      this._blurPostProcesses = [this._boxBlurPostprocess];
    }
  };
  ShadowGenerator2.prototype._renderForShadowMap = function(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
    var index;
    if (depthOnlySubMeshes.length) {
      for (index = 0; index < depthOnlySubMeshes.length; index++) {
        this._renderSubMeshForShadowMap(depthOnlySubMeshes.data[index]);
      }
    }
    for (index = 0; index < opaqueSubMeshes.length; index++) {
      this._renderSubMeshForShadowMap(opaqueSubMeshes.data[index]);
    }
    for (index = 0; index < alphaTestSubMeshes.length; index++) {
      this._renderSubMeshForShadowMap(alphaTestSubMeshes.data[index]);
    }
    if (this._transparencyShadow) {
      for (index = 0; index < transparentSubMeshes.length; index++) {
        this._renderSubMeshForShadowMap(transparentSubMeshes.data[index], true);
      }
    } else {
      for (index = 0; index < transparentSubMeshes.length; index++) {
        transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      }
    }
  };
  ShadowGenerator2.prototype._bindCustomEffectForRenderSubMeshForShadowMap = function(subMesh, effect, mesh) {
    effect.setMatrix("viewProjection", this.getTransformMatrix());
  };
  ShadowGenerator2.prototype._renderSubMeshForShadowMap = function(subMesh, isTransparent) {
    var _a, _b;
    if (isTransparent === void 0) {
      isTransparent = false;
    }
    var renderingMesh = subMesh.getRenderingMesh();
    var effectiveMesh = subMesh.getEffectiveMesh();
    var scene = this._scene;
    var engine = scene.getEngine();
    var material = subMesh.getMaterial();
    effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
    if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {
      return;
    }
    var detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;
    var sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;
    if (detNeg) {
      sideOrientation = sideOrientation === 0 ? 1 : 0;
    }
    var reverseSideOrientation = sideOrientation === 0;
    engine.setState(material.backFaceCulling, void 0, void 0, reverseSideOrientation, material.cullBackFaces);
    var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
    if (batch.mustReturn) {
      return;
    }
    var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
    if (this.customAllowRendering && !this.customAllowRendering(subMesh)) {
      return;
    }
    if (this.isReady(subMesh, hardwareInstancedRendering, isTransparent)) {
      subMesh._renderId = scene.getRenderId();
      var shadowDepthWrapper = material.shadowDepthWrapper;
      var drawWrapper = (_b = shadowDepthWrapper === null || shadowDepthWrapper === void 0 ? void 0 : shadowDepthWrapper.getEffect(subMesh, this, engine.currentRenderPassId)) !== null && _b !== void 0 ? _b : subMesh._getDrawWrapper();
      var effect_1 = DrawWrapper.GetEffect(drawWrapper);
      engine.enableEffect(drawWrapper);
      if (!hardwareInstancedRendering) {
        renderingMesh._bind(subMesh, effect_1, material.fillMode);
      }
      this.getTransformMatrix();
      effect_1.setFloat3("biasAndScaleSM", this.bias, this.normalBias, this.depthScale);
      if (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
        effect_1.setVector3("lightDataSM", this._cachedDirection);
      } else {
        effect_1.setVector3("lightDataSM", this._cachedPosition);
      }
      if (scene.activeCamera) {
        effect_1.setFloat2("depthValuesSM", this.getLight().getDepthMinZ(scene.activeCamera), this.getLight().getDepthMinZ(scene.activeCamera) + this.getLight().getDepthMaxZ(scene.activeCamera));
      }
      if (isTransparent && this.enableSoftTransparentShadow) {
        effect_1.setFloat("softTransparentShadowSM", effectiveMesh.visibility * material.alpha);
      }
      if (shadowDepthWrapper) {
        subMesh._setMainDrawWrapperOverride(drawWrapper);
        if (shadowDepthWrapper.standalone) {
          shadowDepthWrapper.baseMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
        } else {
          material.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
        }
        subMesh._setMainDrawWrapperOverride(null);
      } else {
        if (material && material.needAlphaTesting()) {
          var alphaTexture = material.getAlphaTestTexture();
          if (alphaTexture) {
            effect_1.setTexture("diffuseSampler", alphaTexture);
            effect_1.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix() || this._defaultTextureMatrix);
          }
        }
        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
          var skeleton = renderingMesh.skeleton;
          if (skeleton.isUsingTextureForMatrices) {
            var boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
            if (!boneTexture) {
              return;
            }
            effect_1.setTexture("boneSampler", boneTexture);
            effect_1.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
          } else {
            effect_1.setMatrices("mBones", skeleton.getTransformMatrices(renderingMesh));
          }
        }
        MaterialHelper.BindMorphTargetParameters(renderingMesh, effect_1);
        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
          renderingMesh.morphTargetManager._bind(effect_1);
        }
        MaterialHelper.BindClipPlane(effect_1, scene);
      }
      if (!this._useUBO && !shadowDepthWrapper) {
        this._bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect_1, effectiveMesh);
      }
      MaterialHelper.BindSceneUniformBuffer(effect_1, this._scene.getSceneUniformBuffer());
      this._scene.getSceneUniformBuffer().bindUniformBuffer();
      var world_1 = effectiveMesh.getWorldMatrix();
      if (hardwareInstancedRendering) {
        effectiveMesh.getMeshUniformBuffer().bindToEffect(effect_1, "Mesh");
        effectiveMesh.transferToEffect(world_1);
      }
      if (this.forceBackFacesOnly) {
        engine.setState(true, 0, false, true, material.cullBackFaces);
      }
      this.onBeforeShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
      this.onBeforeShadowMapRenderObservable.notifyObservers(effect_1);
      renderingMesh._processRendering(effectiveMesh, subMesh, effect_1, material.fillMode, batch, hardwareInstancedRendering, function(isInstance, worldOverride) {
        if (effectiveMesh !== renderingMesh && !isInstance) {
          renderingMesh.getMeshUniformBuffer().bindToEffect(effect_1, "Mesh");
          renderingMesh.transferToEffect(worldOverride);
        } else {
          effectiveMesh.getMeshUniformBuffer().bindToEffect(effect_1, "Mesh");
          effectiveMesh.transferToEffect(isInstance ? worldOverride : world_1);
        }
      });
      if (this.forceBackFacesOnly) {
        engine.setState(true, 0, false, false, material.cullBackFaces);
      }
      this.onAfterShadowMapRenderObservable.notifyObservers(effect_1);
      this.onAfterShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
    } else {
      if (this._shadowMap) {
        this._shadowMap.resetRefreshCounter();
      }
    }
  };
  ShadowGenerator2.prototype._applyFilterValues = function() {
    if (!this._shadowMap) {
      return;
    }
    if (this.filter === ShadowGenerator2.FILTER_NONE || this.filter === ShadowGenerator2.FILTER_PCSS) {
      this._shadowMap.updateSamplingMode(Texture.NEAREST_SAMPLINGMODE);
    } else {
      this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    }
  };
  ShadowGenerator2.prototype.forceCompilation = function(onCompiled, options) {
    var _this = this;
    var localOptions = __assign({ useInstances: false }, options);
    var shadowMap = this.getShadowMap();
    if (!shadowMap) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    var renderList = shadowMap.renderList;
    if (!renderList) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    var subMeshes = new Array();
    for (var _i = 0, renderList_1 = renderList; _i < renderList_1.length; _i++) {
      var mesh = renderList_1[_i];
      subMeshes.push.apply(subMeshes, mesh.subMeshes);
    }
    if (subMeshes.length === 0) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    var currentIndex = 0;
    var checkReady = function() {
      var _a, _b;
      if (!_this._scene || !_this._scene.getEngine()) {
        return;
      }
      while (_this.isReady(subMeshes[currentIndex], localOptions.useInstances, (_b = (_a = subMeshes[currentIndex].getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMeshes[currentIndex].getMesh())) !== null && _b !== void 0 ? _b : false)) {
        currentIndex++;
        if (currentIndex >= subMeshes.length) {
          if (onCompiled) {
            onCompiled(_this);
          }
          return;
        }
      }
      setTimeout(checkReady, 16);
    };
    checkReady();
  };
  ShadowGenerator2.prototype.forceCompilationAsync = function(options) {
    var _this = this;
    return new Promise(function(resolve) {
      _this.forceCompilation(function() {
        resolve();
      }, options);
    });
  };
  ShadowGenerator2.prototype._isReadyCustomDefines = function(defines, subMesh, useInstances) {
  };
  ShadowGenerator2.prototype._prepareShadowDefines = function(subMesh, useInstances, defines, isTransparent) {
    defines.push("#define SM_FLOAT " + (this._textureType !== 0 ? "1" : "0"));
    defines.push("#define SM_ESM " + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? "1" : "0"));
    defines.push("#define SM_DEPTHTEXTURE " + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? "1" : "0"));
    var mesh = subMesh.getMesh();
    defines.push("#define SM_NORMALBIAS " + (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind) ? "1" : "0"));
    defines.push("#define SM_DIRECTIONINLIGHTDATA " + (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT ? "1" : "0"));
    defines.push("#define SM_USEDISTANCE " + (this._light.needCube() ? "1" : "0"));
    defines.push("#define SM_SOFTTRANSPARENTSHADOW " + (this.enableSoftTransparentShadow && isTransparent ? "1" : "0"));
    this._isReadyCustomDefines(defines, subMesh, useInstances);
    return defines;
  };
  ShadowGenerator2.prototype.isReady = function(subMesh, useInstances, isTransparent) {
    var material = subMesh.getMaterial(), shadowDepthWrapper = material === null || material === void 0 ? void 0 : material.shadowDepthWrapper;
    var defines = [];
    this._prepareShadowDefines(subMesh, useInstances, defines, isTransparent);
    if (shadowDepthWrapper) {
      if (!shadowDepthWrapper.isReadyForSubMesh(subMesh, defines, this, useInstances, this._scene.getEngine().currentRenderPassId)) {
        return false;
      }
    } else {
      var subMeshEffect = subMesh._getDrawWrapper(void 0, true);
      var effect = subMeshEffect.effect;
      var cachedDefines = subMeshEffect.defines;
      var attribs = [VertexBuffer.PositionKind];
      var mesh = subMesh.getMesh();
      if (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
        attribs.push(VertexBuffer.NormalKind);
        defines.push("#define NORMAL");
        if (mesh.nonUniformScaling) {
          defines.push("#define NONUNIFORMSCALING");
        }
      }
      if (material && material.needAlphaTesting()) {
        var alphaTexture = material.getAlphaTestTexture();
        if (alphaTexture) {
          if (!alphaTexture.isReady()) {
            return false;
          }
          defines.push("#define ALPHATEST");
          if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
            attribs.push(VertexBuffer.UVKind);
            defines.push("#define UV1");
          }
          if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
            if (alphaTexture.coordinatesIndex === 1) {
              attribs.push(VertexBuffer.UV2Kind);
              defines.push("#define UV2");
            }
          }
        }
      }
      var fallbacks = new EffectFallbacks();
      if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
        attribs.push(VertexBuffer.MatricesIndicesKind);
        attribs.push(VertexBuffer.MatricesWeightsKind);
        if (mesh.numBoneInfluencers > 4) {
          attribs.push(VertexBuffer.MatricesIndicesExtraKind);
          attribs.push(VertexBuffer.MatricesWeightsExtraKind);
        }
        var skeleton = mesh.skeleton;
        defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
        if (mesh.numBoneInfluencers > 0) {
          fallbacks.addCPUSkinningFallback(0, mesh);
        }
        if (skeleton.isUsingTextureForMatrices) {
          defines.push("#define BONETEXTURE");
        } else {
          defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
        }
      } else {
        defines.push("#define NUM_BONE_INFLUENCERS 0");
      }
      var manager = mesh.morphTargetManager;
      var morphInfluencers = 0;
      if (manager) {
        if (manager.numInfluencers > 0) {
          defines.push("#define MORPHTARGETS");
          morphInfluencers = manager.numInfluencers;
          defines.push("#define NUM_MORPH_INFLUENCERS " + morphInfluencers);
          if (manager.isUsingTextureForTargets) {
            defines.push("#define MORPHTARGETS_TEXTURE");
          }
          MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);
        }
      }
      var scene = this._scene;
      if (scene.clipPlane) {
        defines.push("#define CLIPPLANE");
      }
      if (scene.clipPlane2) {
        defines.push("#define CLIPPLANE2");
      }
      if (scene.clipPlane3) {
        defines.push("#define CLIPPLANE3");
      }
      if (scene.clipPlane4) {
        defines.push("#define CLIPPLANE4");
      }
      if (scene.clipPlane5) {
        defines.push("#define CLIPPLANE5");
      }
      if (scene.clipPlane6) {
        defines.push("#define CLIPPLANE6");
      }
      if (useInstances) {
        defines.push("#define INSTANCES");
        MaterialHelper.PushAttributesForInstances(attribs);
        if (subMesh.getRenderingMesh().hasThinInstances) {
          defines.push("#define THIN_INSTANCES");
        }
      }
      if (this.customShaderOptions) {
        if (this.customShaderOptions.defines) {
          for (var _i = 0, _a = this.customShaderOptions.defines; _i < _a.length; _i++) {
            var define = _a[_i];
            if (defines.indexOf(define) === -1) {
              defines.push(define);
            }
          }
        }
      }
      var join = defines.join("\n");
      if (cachedDefines !== join) {
        cachedDefines = join;
        var shaderName = "shadowMap";
        var uniforms = [
          "world",
          "mBones",
          "viewProjection",
          "diffuseMatrix",
          "lightDataSM",
          "depthValuesSM",
          "biasAndScaleSM",
          "morphTargetInfluences",
          "boneTextureWidth",
          "vClipPlane",
          "vClipPlane2",
          "vClipPlane3",
          "vClipPlane4",
          "vClipPlane5",
          "vClipPlane6",
          "softTransparentShadowSM",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices"
        ];
        var samplers = ["diffuseSampler", "boneSampler", "morphTargets"];
        var uniformBuffers = ["Scene", "Mesh"];
        if (this.customShaderOptions) {
          shaderName = this.customShaderOptions.shaderName;
          if (this.customShaderOptions.attributes) {
            for (var _b = 0, _c = this.customShaderOptions.attributes; _b < _c.length; _b++) {
              var attrib = _c[_b];
              if (attribs.indexOf(attrib) === -1) {
                attribs.push(attrib);
              }
            }
          }
          if (this.customShaderOptions.uniforms) {
            for (var _d = 0, _e = this.customShaderOptions.uniforms; _d < _e.length; _d++) {
              var uniform = _e[_d];
              if (uniforms.indexOf(uniform) === -1) {
                uniforms.push(uniform);
              }
            }
          }
          if (this.customShaderOptions.samplers) {
            for (var _f = 0, _g = this.customShaderOptions.samplers; _f < _g.length; _f++) {
              var sampler = _g[_f];
              if (samplers.indexOf(sampler) === -1) {
                samplers.push(sampler);
              }
            }
          }
        }
        var engine = this._scene.getEngine();
        effect = engine.createEffect(shaderName, {
          attributes: attribs,
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines: join,
          fallbacks,
          onCompiled: null,
          onError: null,
          indexParameters: { maxSimultaneousMorphTargets: morphInfluencers }
        }, engine);
        subMeshEffect.setEffect(effect, cachedDefines);
      }
      if (!effect.isReady()) {
        return false;
      }
    }
    if (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
      if (!this._blurPostProcesses || !this._blurPostProcesses.length) {
        this._initializeBlurRTTAndPostProcesses();
      }
    }
    if (this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) {
      return false;
    }
    if (this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) {
      return false;
    }
    if (this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()) {
      return false;
    }
    return true;
  };
  ShadowGenerator2.prototype.prepareDefines = function(defines, lightIndex) {
    var scene = this._scene;
    var light = this._light;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    defines["SHADOW" + lightIndex] = true;
    if (this.useContactHardeningShadow) {
      defines["SHADOWPCSS" + lightIndex] = true;
      if (this._filteringQuality === ShadowGenerator2.QUALITY_LOW) {
        defines["SHADOWLOWQUALITY" + lightIndex] = true;
      } else if (this._filteringQuality === ShadowGenerator2.QUALITY_MEDIUM) {
        defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
      }
    } else if (this.usePercentageCloserFiltering) {
      defines["SHADOWPCF" + lightIndex] = true;
      if (this._filteringQuality === ShadowGenerator2.QUALITY_LOW) {
        defines["SHADOWLOWQUALITY" + lightIndex] = true;
      } else if (this._filteringQuality === ShadowGenerator2.QUALITY_MEDIUM) {
        defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
      }
    } else if (this.usePoissonSampling) {
      defines["SHADOWPOISSON" + lightIndex] = true;
    } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
      defines["SHADOWESM" + lightIndex] = true;
    } else if (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
      defines["SHADOWCLOSEESM" + lightIndex] = true;
    }
    if (light.needCube()) {
      defines["SHADOWCUBE" + lightIndex] = true;
    }
  };
  ShadowGenerator2.prototype.bindShadowLight = function(lightIndex, effect) {
    var light = this._light;
    var scene = this._scene;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    var camera = scene.activeCamera;
    if (!camera) {
      return;
    }
    var shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return;
    }
    if (!light.needCube()) {
      effect.setMatrix("lightMatrix" + lightIndex, this.getTransformMatrix());
    }
    if (this._filter === ShadowGenerator2.FILTER_PCF) {
      effect.setDepthStencilTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), shadowMap.getSize().width, 1 / shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
    } else if (this._filter === ShadowGenerator2.FILTER_PCSS) {
      effect.setDepthStencilTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
      effect.setTexture("depthSampler" + lightIndex, this.getShadowMapForRendering());
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / shadowMap.getSize().width, this._contactHardeningLightSizeUVRatio * shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
    } else {
      effect.setTexture("shadowSampler" + lightIndex, this.getShadowMapForRendering());
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), this.blurScale / shadowMap.getSize().width, this.depthScale, this.frustumEdgeFalloff, lightIndex);
    }
    light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
  };
  ShadowGenerator2.prototype.getTransformMatrix = function() {
    var scene = this._scene;
    if (this._currentRenderId === scene.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) {
      return this._transformMatrix;
    }
    this._currentRenderId = scene.getRenderId();
    this._currentFaceIndexCache = this._currentFaceIndex;
    var lightPosition = this._light.position;
    if (this._light.computeTransformedInformation()) {
      lightPosition = this._light.transformedPosition;
    }
    Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection);
    if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
      this._lightDirection.z = 1e-13;
    }
    if (this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !lightPosition.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {
      this._cachedPosition.copyFrom(lightPosition);
      this._cachedDirection.copyFrom(this._lightDirection);
      Matrix.LookAtLHToRef(lightPosition, lightPosition.add(this._lightDirection), Vector3.Up(), this._viewMatrix);
      var shadowMap = this.getShadowMap();
      if (shadowMap) {
        var renderList = shadowMap.renderList;
        if (renderList) {
          this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, renderList);
        }
      }
      this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    }
    return this._transformMatrix;
  };
  ShadowGenerator2.prototype.recreateShadowMap = function() {
    var shadowMap = this._shadowMap;
    if (!shadowMap) {
      return;
    }
    var renderList = shadowMap.renderList;
    this._disposeRTTandPostProcesses();
    this._initializeGenerator();
    this.filter = this.filter;
    this._applyFilterValues();
    if (renderList) {
      if (!this._shadowMap.renderList) {
        this._shadowMap.renderList = [];
      }
      for (var _i = 0, renderList_2 = renderList; _i < renderList_2.length; _i++) {
        var mesh = renderList_2[_i];
        this._shadowMap.renderList.push(mesh);
      }
    } else {
      this._shadowMap.renderList = null;
    }
  };
  ShadowGenerator2.prototype._disposeBlurPostProcesses = function() {
    if (this._shadowMap2) {
      this._shadowMap2.dispose();
      this._shadowMap2 = null;
    }
    if (this._boxBlurPostprocess) {
      this._boxBlurPostprocess.dispose();
      this._boxBlurPostprocess = null;
    }
    if (this._kernelBlurXPostprocess) {
      this._kernelBlurXPostprocess.dispose();
      this._kernelBlurXPostprocess = null;
    }
    if (this._kernelBlurYPostprocess) {
      this._kernelBlurYPostprocess.dispose();
      this._kernelBlurYPostprocess = null;
    }
    this._blurPostProcesses = [];
  };
  ShadowGenerator2.prototype._disposeRTTandPostProcesses = function() {
    if (this._shadowMap) {
      this._shadowMap.dispose();
      this._shadowMap = null;
    }
    this._disposeBlurPostProcesses();
  };
  ShadowGenerator2.prototype._disposeSceneUBOs = function() {
    if (this._sceneUBOs) {
      for (var _i = 0, _a = this._sceneUBOs; _i < _a.length; _i++) {
        var ubo = _a[_i];
        ubo.dispose();
      }
      this._sceneUBOs = [];
    }
  };
  ShadowGenerator2.prototype.dispose = function() {
    this._disposeRTTandPostProcesses();
    this._disposeSceneUBOs();
    if (this._light) {
      this._light._shadowGenerator = null;
      this._light._markMeshesAsLightDirty();
    }
    this.onBeforeShadowMapRenderMeshObservable.clear();
    this.onBeforeShadowMapRenderObservable.clear();
    this.onAfterShadowMapRenderMeshObservable.clear();
    this.onAfterShadowMapRenderObservable.clear();
  };
  ShadowGenerator2.prototype.serialize = function() {
    var serializationObject = {};
    var shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return serializationObject;
    }
    serializationObject.className = this.getClassName();
    serializationObject.lightId = this._light.id;
    serializationObject.id = this.id;
    serializationObject.mapSize = shadowMap.getRenderSize();
    serializationObject.forceBackFacesOnly = this.forceBackFacesOnly;
    serializationObject.darkness = this.getDarkness();
    serializationObject.transparencyShadow = this._transparencyShadow;
    serializationObject.frustumEdgeFalloff = this.frustumEdgeFalloff;
    serializationObject.bias = this.bias;
    serializationObject.normalBias = this.normalBias;
    serializationObject.usePercentageCloserFiltering = this.usePercentageCloserFiltering;
    serializationObject.useContactHardeningShadow = this.useContactHardeningShadow;
    serializationObject.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio;
    serializationObject.filteringQuality = this.filteringQuality;
    serializationObject.useExponentialShadowMap = this.useExponentialShadowMap;
    serializationObject.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.usePoissonSampling = this.usePoissonSampling;
    serializationObject.depthScale = this.depthScale;
    serializationObject.blurBoxOffset = this.blurBoxOffset;
    serializationObject.blurKernel = this.blurKernel;
    serializationObject.blurScale = this.blurScale;
    serializationObject.useKernelBlur = this.useKernelBlur;
    serializationObject.renderList = [];
    if (shadowMap.renderList) {
      for (var meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
        var mesh = shadowMap.renderList[meshIndex];
        serializationObject.renderList.push(mesh.id);
      }
    }
    return serializationObject;
  };
  ShadowGenerator2.Parse = function(parsedShadowGenerator, scene, constr) {
    var light = scene.getLightById(parsedShadowGenerator.lightId);
    var shadowGenerator = constr ? constr(parsedShadowGenerator.mapSize, light) : new ShadowGenerator2(parsedShadowGenerator.mapSize, light);
    var shadowMap = shadowGenerator.getShadowMap();
    for (var meshIndex = 0; meshIndex < parsedShadowGenerator.renderList.length; meshIndex++) {
      var meshes = scene.getMeshesById(parsedShadowGenerator.renderList[meshIndex]);
      meshes.forEach(function(mesh) {
        if (!shadowMap) {
          return;
        }
        if (!shadowMap.renderList) {
          shadowMap.renderList = [];
        }
        shadowMap.renderList.push(mesh);
      });
    }
    if (parsedShadowGenerator.id !== void 0) {
      shadowGenerator.id = parsedShadowGenerator.id;
    }
    shadowGenerator.forceBackFacesOnly = !!parsedShadowGenerator.forceBackFacesOnly;
    if (parsedShadowGenerator.darkness !== void 0) {
      shadowGenerator.setDarkness(parsedShadowGenerator.darkness);
    }
    if (parsedShadowGenerator.transparencyShadow) {
      shadowGenerator.setTransparencyShadow(true);
    }
    if (parsedShadowGenerator.frustumEdgeFalloff !== void 0) {
      shadowGenerator.frustumEdgeFalloff = parsedShadowGenerator.frustumEdgeFalloff;
    }
    if (parsedShadowGenerator.bias !== void 0) {
      shadowGenerator.bias = parsedShadowGenerator.bias;
    }
    if (parsedShadowGenerator.normalBias !== void 0) {
      shadowGenerator.normalBias = parsedShadowGenerator.normalBias;
    }
    if (parsedShadowGenerator.usePercentageCloserFiltering) {
      shadowGenerator.usePercentageCloserFiltering = true;
    } else if (parsedShadowGenerator.useContactHardeningShadow) {
      shadowGenerator.useContactHardeningShadow = true;
    } else if (parsedShadowGenerator.usePoissonSampling) {
      shadowGenerator.usePoissonSampling = true;
    } else if (parsedShadowGenerator.useExponentialShadowMap) {
      shadowGenerator.useExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurExponentialShadowMap) {
      shadowGenerator.useBlurExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useCloseExponentialShadowMap) {
      shadowGenerator.useCloseExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurCloseExponentialShadowMap) {
      shadowGenerator.useBlurCloseExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useVarianceShadowMap) {
      shadowGenerator.useExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurVarianceShadowMap) {
      shadowGenerator.useBlurExponentialShadowMap = true;
    }
    if (parsedShadowGenerator.contactHardeningLightSizeUVRatio !== void 0) {
      shadowGenerator.contactHardeningLightSizeUVRatio = parsedShadowGenerator.contactHardeningLightSizeUVRatio;
    }
    if (parsedShadowGenerator.filteringQuality !== void 0) {
      shadowGenerator.filteringQuality = parsedShadowGenerator.filteringQuality;
    }
    if (parsedShadowGenerator.depthScale) {
      shadowGenerator.depthScale = parsedShadowGenerator.depthScale;
    }
    if (parsedShadowGenerator.blurScale) {
      shadowGenerator.blurScale = parsedShadowGenerator.blurScale;
    }
    if (parsedShadowGenerator.blurBoxOffset) {
      shadowGenerator.blurBoxOffset = parsedShadowGenerator.blurBoxOffset;
    }
    if (parsedShadowGenerator.useKernelBlur) {
      shadowGenerator.useKernelBlur = parsedShadowGenerator.useKernelBlur;
    }
    if (parsedShadowGenerator.blurKernel) {
      shadowGenerator.blurKernel = parsedShadowGenerator.blurKernel;
    }
    return shadowGenerator;
  };
  ShadowGenerator2.CLASSNAME = "ShadowGenerator";
  ShadowGenerator2.FILTER_NONE = 0;
  ShadowGenerator2.FILTER_EXPONENTIALSHADOWMAP = 1;
  ShadowGenerator2.FILTER_POISSONSAMPLING = 2;
  ShadowGenerator2.FILTER_BLUREXPONENTIALSHADOWMAP = 3;
  ShadowGenerator2.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;
  ShadowGenerator2.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;
  ShadowGenerator2.FILTER_PCF = 6;
  ShadowGenerator2.FILTER_PCSS = 7;
  ShadowGenerator2.QUALITY_HIGH = 0;
  ShadowGenerator2.QUALITY_MEDIUM = 1;
  ShadowGenerator2.QUALITY_LOW = 2;
  ShadowGenerator2._SceneComponentInitialization = function(_) {
    throw _WarnImport("ShadowGeneratorSceneComponent");
  };
  return ShadowGenerator2;
}();
var name$M = "depthPixelShader";
var shader$M = "#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\nvarying float vDepthMetric;\n#ifdef PACKED\n#include<packingFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#ifdef NONLINEARDEPTH\n#ifdef PACKED\ngl_FragColor=pack(gl_FragCoord.z);\n#else\ngl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);\n#endif\n#else\n#ifdef PACKED\ngl_FragColor=pack(vDepthMetric);\n#else\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);\n#endif\n#endif\n}";
ShaderStore.ShadersStore[name$M] = shader$M;
var name$L = "instancesDeclaration";
var shader$L = "#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#ifdef INSTANCESCOLOR\nattribute vec4 instanceColor;\n#endif\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nattribute vec4 previousWorld0;\nattribute vec4 previousWorld1;\nattribute vec4 previousWorld2;\nattribute vec4 previousWorld3;\n#ifdef THIN_INSTANCES\nuniform mat4 previousWorld;\n#endif\n#endif\n#else\n#if !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nuniform mat4 previousWorld;\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$L] = shader$L;
var name$K = "depthVertexShader";
var shader$K = "\nattribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\nuniform vec2 depthValues;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\nvarying float vDepthMetric;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{\nvec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));\n#else\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\n#endif\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n}\n";
ShaderStore.ShadersStore[name$K] = shader$K;
var DepthRenderer = function() {
  function DepthRenderer2(scene, type, camera, storeNonLinearDepth, samplingMode) {
    var _this = this;
    if (type === void 0) {
      type = 1;
    }
    if (camera === void 0) {
      camera = null;
    }
    if (storeNonLinearDepth === void 0) {
      storeNonLinearDepth = false;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
    }
    this.enabled = true;
    this.forceDepthWriteTransparentMeshes = false;
    this.useOnlyInActiveCamera = false;
    this._scene = scene;
    this._storeNonLinearDepth = storeNonLinearDepth;
    this.isPacked = type === 0;
    if (this.isPacked) {
      this._clearColor = new Color4$1(1, 1, 1, 1);
    } else {
      this._clearColor = new Color4$1(1, 0, 0, 1);
    }
    DepthRenderer2._SceneComponentInitialization(this._scene);
    var engine = scene.getEngine();
    this._camera = camera;
    if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {
      if (type === 1 && !engine._caps.textureFloatLinearFiltering) {
        samplingMode = Texture.NEAREST_SAMPLINGMODE;
      }
      if (type === 2 && !engine._caps.textureHalfFloatLinearFiltering) {
        samplingMode = Texture.NEAREST_SAMPLINGMODE;
      }
    }
    var format = this.isPacked || !engine._features.supportExtendedTextureFormats ? 5 : 6;
    this._depthMap = new RenderTargetTexture("DepthRenderer", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type, false, samplingMode, void 0, void 0, void 0, format);
    this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._depthMap.refreshRate = 1;
    this._depthMap.renderParticles = false;
    this._depthMap.renderList = null;
    this._depthMap.activeCamera = this._camera;
    this._depthMap.ignoreCameraViewport = true;
    this._depthMap.useCameraPostProcesses = false;
    this._depthMap.onClearObservable.add(function(engine2) {
      engine2.clear(_this._clearColor, true, true, true);
    });
    this._depthMap.onBeforeBindObservable.add(function() {
      var _a;
      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, "depth renderer", 1);
    });
    this._depthMap.onAfterUnbindObservable.add(function() {
      var _a;
      (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);
    });
    this._depthMap.customIsReadyFunction = function(mesh, refreshRate) {
      if (!mesh.isReady(false)) {
        return false;
      }
      if (refreshRate === 0 && mesh.subMeshes) {
        for (var i = 0; i < mesh.subMeshes.length; ++i) {
          var subMesh = mesh.subMeshes[i];
          var renderingMesh = subMesh.getRenderingMesh();
          var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
          var hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
          if (!_this.isReady(subMesh, hardwareInstancedRendering)) {
            return false;
          }
        }
      }
      return true;
    };
    var renderSubMesh = function(subMesh) {
      var _a, _b;
      var renderingMesh = subMesh.getRenderingMesh();
      var effectiveMesh = subMesh.getEffectiveMesh();
      var scene2 = _this._scene;
      var engine2 = scene2.getEngine();
      var material = subMesh.getMaterial();
      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene2.getRenderId()) {
        return;
      }
      var detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;
      var sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;
      if (detNeg) {
        sideOrientation = sideOrientation === 0 ? 1 : 0;
      }
      var reverseSideOrientation = sideOrientation === 0;
      engine2.setState(material.backFaceCulling, 0, false, reverseSideOrientation, material.cullBackFaces);
      var batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
      if (batch.mustReturn) {
        return;
      }
      var hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
      var camera2 = _this._camera || scene2.activeCamera;
      if (_this.isReady(subMesh, hardwareInstancedRendering) && camera2) {
        subMesh._renderId = scene2.getRenderId();
        var renderingMaterial = (_b = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _b === void 0 ? void 0 : _b[engine2.currentRenderPassId];
        var drawWrapper = subMesh._getDrawWrapper();
        if (!drawWrapper && renderingMaterial) {
          drawWrapper = renderingMaterial._getDrawWrapper();
        }
        var cameraIsOrtho = camera2.mode === Camera.ORTHOGRAPHIC_CAMERA;
        if (!drawWrapper) {
          return;
        }
        var effect_1 = drawWrapper.effect;
        engine2.enableEffect(drawWrapper);
        if (!hardwareInstancedRendering) {
          renderingMesh._bind(subMesh, effect_1, material.fillMode);
        }
        if (!renderingMaterial) {
          effect_1.setMatrix("viewProjection", scene2.getTransformMatrix());
          effect_1.setMatrix("world", effectiveMesh.getWorldMatrix());
        } else {
          renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);
        }
        var minZ = void 0, maxZ = void 0;
        if (cameraIsOrtho) {
          minZ = !engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : 1;
          maxZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : 1;
        } else {
          minZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? camera2.minZ : engine2.isNDCHalfZRange ? 0 : camera2.minZ;
          maxZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : camera2.maxZ;
        }
        effect_1.setFloat2("depthValues", minZ, minZ + maxZ);
        if (!renderingMaterial) {
          if (material && material.needAlphaTesting()) {
            var alphaTexture = material.getAlphaTestTexture();
            if (alphaTexture) {
              effect_1.setTexture("diffuseSampler", alphaTexture);
              effect_1.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
            }
          }
          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
            var skeleton = renderingMesh.skeleton;
            if (skeleton.isUsingTextureForMatrices) {
              var boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
              if (!boneTexture) {
                return;
              }
              effect_1.setTexture("boneSampler", boneTexture);
              effect_1.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
            } else {
              effect_1.setMatrices("mBones", skeleton.getTransformMatrices(renderingMesh));
            }
          }
          MaterialHelper.BindMorphTargetParameters(renderingMesh, effect_1);
          if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
            renderingMesh.morphTargetManager._bind(effect_1);
          }
        }
        renderingMesh._processRendering(effectiveMesh, subMesh, effect_1, material.fillMode, batch, hardwareInstancedRendering, function(isInstance, world) {
          return effect_1.setMatrix("world", world);
        });
      }
    };
    this._depthMap.customRenderFunction = function(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
      var index;
      if (depthOnlySubMeshes.length) {
        for (index = 0; index < depthOnlySubMeshes.length; index++) {
          renderSubMesh(depthOnlySubMeshes.data[index]);
        }
      }
      for (index = 0; index < opaqueSubMeshes.length; index++) {
        renderSubMesh(opaqueSubMeshes.data[index]);
      }
      for (index = 0; index < alphaTestSubMeshes.length; index++) {
        renderSubMesh(alphaTestSubMeshes.data[index]);
      }
      if (_this.forceDepthWriteTransparentMeshes) {
        for (index = 0; index < transparentSubMeshes.length; index++) {
          renderSubMesh(transparentSubMeshes.data[index]);
        }
      } else {
        for (index = 0; index < transparentSubMeshes.length; index++) {
          transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
        }
      }
    };
  }
  DepthRenderer2.prototype.setMaterialForRendering = function(mesh, material) {
    this._depthMap.setMaterialForRendering(mesh, material);
  };
  DepthRenderer2.prototype.isReady = function(subMesh, useInstances) {
    var _a;
    var engine = this._scene.getEngine();
    var mesh = subMesh.getMesh();
    var renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];
    if (renderingMaterial) {
      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);
    }
    var material = subMesh.getMaterial();
    if (!material || material.disableDepthWrite) {
      return false;
    }
    var defines = [];
    var attribs = [VertexBuffer.PositionKind];
    if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {
      defines.push("#define ALPHATEST");
      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
        attribs.push(VertexBuffer.UVKind);
        defines.push("#define UV1");
      }
      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
        attribs.push(VertexBuffer.UV2Kind);
        defines.push("#define UV2");
      }
    }
    if (mesh.useBones && mesh.computeBonesUsingShaders) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      defines.push("#define BonesPerMesh " + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));
      var skeleton = subMesh.getRenderingMesh().skeleton;
      if (skeleton === null || skeleton === void 0 ? void 0 : skeleton.isUsingTextureForMatrices) {
        defines.push("#define BONETEXTURE");
      }
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    var morphTargetManager = mesh.morphTargetManager;
    var numMorphInfluencers = 0;
    if (morphTargetManager) {
      if (morphTargetManager.numInfluencers > 0) {
        numMorphInfluencers = morphTargetManager.numInfluencers;
        defines.push("#define MORPHTARGETS");
        defines.push("#define NUM_MORPH_INFLUENCERS " + numMorphInfluencers);
        if (morphTargetManager.isUsingTextureForTargets) {
          defines.push("#define MORPHTARGETS_TEXTURE");
        }
        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);
      }
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      MaterialHelper.PushAttributesForInstances(attribs);
      if (subMesh.getRenderingMesh().hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    if (this._storeNonLinearDepth) {
      defines.push("#define NONLINEARDEPTH");
    }
    if (this.isPacked) {
      defines.push("#define PACKED");
    }
    var drawWrapper = subMesh._getDrawWrapper(void 0, true);
    var cachedDefines = drawWrapper.defines;
    var join = defines.join("\n");
    if (cachedDefines !== join) {
      drawWrapper.setEffect(engine.createEffect("depth", attribs, ["world", "mBones", "boneTextureWidth", "viewProjection", "diffuseMatrix", "depthValues", "morphTargetInfluences", "morphTargetTextureInfo", "morphTargetTextureIndices"], ["diffuseSampler", "morphTargets", "boneSampler"], join, void 0, void 0, void 0, { maxSimultaneousMorphTargets: numMorphInfluencers }), join);
    }
    return drawWrapper.effect.isReady();
  };
  DepthRenderer2.prototype.getDepthMap = function() {
    return this._depthMap;
  };
  DepthRenderer2.prototype.dispose = function() {
    var keysToDelete = [];
    for (var key in this._scene._depthRenderer) {
      var depthRenderer = this._scene._depthRenderer[key];
      if (depthRenderer === this) {
        keysToDelete.push(key);
      }
    }
    if (keysToDelete.length > 0) {
      this._depthMap.dispose();
      for (var _i = 0, keysToDelete_1 = keysToDelete; _i < keysToDelete_1.length; _i++) {
        var key_1 = keysToDelete_1[_i];
        delete this._scene._depthRenderer[key_1];
      }
    }
  };
  DepthRenderer2._SceneComponentInitialization = function(_) {
    throw _WarnImport("DepthRendererSceneComponent");
  };
  return DepthRenderer2;
}();
var name$J = "minmaxReduxPixelShader";
var shader$J = "varying vec2 vUV;\nuniform sampler2D textureSampler;\n#if defined(INITIAL)\nuniform sampler2D sourceTexture;\nuniform vec2 texSize;\nvoid main(void)\n{\nivec2 coord=ivec2(vUV*(texSize-1.0));\nfloat f1=texelFetch(sourceTexture,coord,0).r;\nfloat f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;\nfloat f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;\nfloat f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;\nfloat minz=min(min(min(f1,f2),f3),f4);\n#ifdef DEPTH_REDUX\nfloat maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#else\nfloat maxz=max(max(max(f1,f2),f3),f4);\n#endif\nglFragColor=vec4(minz,maxz,0.,0.);\n}\n#elif defined(MAIN)\nuniform vec2 texSize;\nvoid main(void)\n{\nivec2 coord=ivec2(vUV*(texSize-1.0));\nvec2 f1=texelFetch(textureSampler,coord,0).rg;\nvec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;\nvec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;\nvec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;\nfloat minz=min(min(min(f1.x,f2.x),f3.x),f4.x);\nfloat maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);\nglFragColor=vec4(minz,maxz,0.,0.);\n}\n#elif defined(ONEBEFORELAST)\nuniform ivec2 texSize;\nvoid main(void)\n{\nivec2 coord=ivec2(vUV*vec2(texSize-1));\nvec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;\nvec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;\nvec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;\nvec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;\nfloat minz=min(f1.x,f2.x);\nfloat maxz=max(f1.y,f2.y);\nglFragColor=vec4(minz,maxz,0.,0.);\n}\n#elif defined(LAST)\nvoid main(void)\n{\nglFragColor=vec4(0.);\nif (true) {\ndiscard;\n}\n}\n#endif\n";
ShaderStore.ShadersStore[name$J] = shader$J;
var MinMaxReducer = function() {
  function MinMaxReducer2(camera) {
    var _this = this;
    this.onAfterReductionPerformed = new Observable();
    this._forceFullscreenViewport = true;
    this._activated = false;
    this._camera = camera;
    this._postProcessManager = new PostProcessManager(camera.getScene());
    this._onContextRestoredObserver = camera.getEngine().onContextRestoredObservable.add(function() {
      _this._postProcessManager._rebuild();
    });
  }
  Object.defineProperty(MinMaxReducer2.prototype, "sourceTexture", {
    get: function() {
      return this._sourceTexture;
    },
    enumerable: false,
    configurable: true
  });
  MinMaxReducer2.prototype.setSourceTexture = function(sourceTexture, depthRedux, type, forceFullscreenViewport) {
    var _this = this;
    if (type === void 0) {
      type = 2;
    }
    if (forceFullscreenViewport === void 0) {
      forceFullscreenViewport = true;
    }
    if (sourceTexture === this._sourceTexture) {
      return;
    }
    this.dispose(false);
    this._sourceTexture = sourceTexture;
    this._reductionSteps = [];
    this._forceFullscreenViewport = forceFullscreenViewport;
    var scene = this._camera.getScene();
    var reductionInitial = new PostProcess("Initial reduction phase", "minmaxRedux", ["texSize"], ["sourceTexture"], 1, null, 1, scene.getEngine(), false, "#define INITIAL" + (depthRedux ? "\n#define DEPTH_REDUX" : ""), type, void 0, void 0, void 0, 7);
    reductionInitial.autoClear = false;
    reductionInitial.forceFullscreenViewport = forceFullscreenViewport;
    var w = this._sourceTexture.getRenderWidth(), h = this._sourceTexture.getRenderHeight();
    reductionInitial.onApply = function(w2, h2) {
      return function(effect) {
        effect.setTexture("sourceTexture", _this._sourceTexture);
        effect.setFloat2("texSize", w2, h2);
      };
    }(w, h);
    this._reductionSteps.push(reductionInitial);
    var index = 1;
    while (w > 1 || h > 1) {
      w = Math.max(Math.round(w / 2), 1);
      h = Math.max(Math.round(h / 2), 1);
      var reduction = new PostProcess("Reduction phase " + index, "minmaxRedux", ["texSize"], null, { width: w, height: h }, null, 1, scene.getEngine(), false, "#define " + (w == 1 && h == 1 ? "LAST" : w == 1 || h == 1 ? "ONEBEFORELAST" : "MAIN"), type, void 0, void 0, void 0, 7);
      reduction.autoClear = false;
      reduction.forceFullscreenViewport = forceFullscreenViewport;
      reduction.onApply = function(w2, h2) {
        return function(effect) {
          if (w2 == 1 || h2 == 1) {
            effect.setInt2("texSize", w2, h2);
          } else {
            effect.setFloat2("texSize", w2, h2);
          }
        };
      }(w, h);
      this._reductionSteps.push(reduction);
      index++;
      if (w == 1 && h == 1) {
        var func = function(w2, h2, reduction2) {
          var buffer = new Float32Array(4 * w2 * h2), minmax = { min: 0, max: 0 };
          return function() {
            scene.getEngine()._readTexturePixels(reduction2.inputTexture.texture, w2, h2, -1, 0, buffer, false);
            minmax.min = buffer[0];
            minmax.max = buffer[1];
            _this.onAfterReductionPerformed.notifyObservers(minmax);
          };
        };
        reduction.onAfterRenderObservable.add(func(w, h, reduction));
      }
    }
  };
  Object.defineProperty(MinMaxReducer2.prototype, "refreshRate", {
    get: function() {
      return this._sourceTexture ? this._sourceTexture.refreshRate : -1;
    },
    set: function(value) {
      if (this._sourceTexture) {
        this._sourceTexture.refreshRate = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MinMaxReducer2.prototype, "activated", {
    get: function() {
      return this._activated;
    },
    enumerable: false,
    configurable: true
  });
  MinMaxReducer2.prototype.activate = function() {
    var _this = this;
    if (this._onAfterUnbindObserver || !this._sourceTexture) {
      return;
    }
    this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(function() {
      var _a, _b;
      var engine = _this._camera.getScene().getEngine();
      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, "min max reduction", 1);
      _this._reductionSteps[0].activate(_this._camera);
      _this._postProcessManager.directRender(_this._reductionSteps, _this._reductionSteps[0].inputTexture, _this._forceFullscreenViewport);
      engine.unBindFramebuffer(_this._reductionSteps[0].inputTexture, false);
      (_b = engine._debugPopGroup) === null || _b === void 0 ? void 0 : _b.call(engine, 1);
    });
    this._activated = true;
  };
  MinMaxReducer2.prototype.deactivate = function() {
    if (!this._onAfterUnbindObserver || !this._sourceTexture) {
      return;
    }
    this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
    this._onAfterUnbindObserver = null;
    this._activated = false;
  };
  MinMaxReducer2.prototype.dispose = function(disposeAll) {
    if (disposeAll === void 0) {
      disposeAll = true;
    }
    if (disposeAll) {
      this.onAfterReductionPerformed.clear();
      if (this._onContextRestoredObserver) {
        this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
        this._onContextRestoredObserver = null;
      }
    }
    this.deactivate();
    if (this._reductionSteps) {
      for (var i = 0; i < this._reductionSteps.length; ++i) {
        this._reductionSteps[i].dispose();
      }
      this._reductionSteps = null;
    }
    if (this._postProcessManager && disposeAll) {
      this._postProcessManager.dispose();
    }
    this._sourceTexture = null;
  };
  return MinMaxReducer2;
}();
var DepthReducer = function(_super) {
  __extends(DepthReducer2, _super);
  function DepthReducer2(camera) {
    return _super.call(this, camera) || this;
  }
  Object.defineProperty(DepthReducer2.prototype, "depthRenderer", {
    get: function() {
      return this._depthRenderer;
    },
    enumerable: false,
    configurable: true
  });
  DepthReducer2.prototype.setDepthRenderer = function(depthRenderer, type, forceFullscreenViewport) {
    if (depthRenderer === void 0) {
      depthRenderer = null;
    }
    if (type === void 0) {
      type = 2;
    }
    if (forceFullscreenViewport === void 0) {
      forceFullscreenViewport = true;
    }
    var scene = this._camera.getScene();
    if (this._depthRenderer) {
      delete scene._depthRenderer[this._depthRendererId];
      this._depthRenderer.dispose();
      this._depthRenderer = null;
    }
    if (depthRenderer === null) {
      if (!scene._depthRenderer) {
        scene._depthRenderer = {};
      }
      depthRenderer = this._depthRenderer = new DepthRenderer(scene, type, this._camera, false, 1);
      depthRenderer.enabled = false;
      this._depthRendererId = "minmax" + this._camera.id;
      scene._depthRenderer[this._depthRendererId] = depthRenderer;
    }
    _super.prototype.setSourceTexture.call(this, depthRenderer.getDepthMap(), true, type, forceFullscreenViewport);
  };
  DepthReducer2.prototype.setSourceTexture = function(sourceTexture, depthRedux, type, forceFullscreenViewport) {
    if (type === void 0) {
      type = 2;
    }
    if (forceFullscreenViewport === void 0) {
      forceFullscreenViewport = true;
    }
    _super.prototype.setSourceTexture.call(this, sourceTexture, depthRedux, type, forceFullscreenViewport);
  };
  DepthReducer2.prototype.activate = function() {
    if (this._depthRenderer) {
      this._depthRenderer.enabled = true;
    }
    _super.prototype.activate.call(this);
  };
  DepthReducer2.prototype.deactivate = function() {
    _super.prototype.deactivate.call(this);
    if (this._depthRenderer) {
      this._depthRenderer.enabled = false;
    }
  };
  DepthReducer2.prototype.dispose = function(disposeAll) {
    if (disposeAll === void 0) {
      disposeAll = true;
    }
    _super.prototype.dispose.call(this, disposeAll);
    if (this._depthRenderer && disposeAll) {
      var scene = this._depthRenderer.getDepthMap().getScene();
      if (scene) {
        delete scene._depthRenderer[this._depthRendererId];
      }
      this._depthRenderer.dispose();
      this._depthRenderer = null;
    }
  };
  return DepthReducer2;
}(MinMaxReducer);
var UpDir = Vector3.Up();
var ZeroVec = Vector3.Zero();
var tmpv1 = new Vector3(), tmpv2 = new Vector3(), tmpMatrix = new Matrix();
var CascadedShadowGenerator = function(_super) {
  __extends(CascadedShadowGenerator2, _super);
  function CascadedShadowGenerator2(mapSize, light, usefulFloatFirst) {
    var _this = this;
    if (!CascadedShadowGenerator2.IsSupported) {
      Logger.Error("CascadedShadowMap is not supported by the current engine.");
      return;
    }
    _this = _super.call(this, mapSize, light, usefulFloatFirst) || this;
    _this.usePercentageCloserFiltering = true;
    return _this;
  }
  CascadedShadowGenerator2.prototype._validateFilter = function(filter) {
    if (filter === ShadowGenerator.FILTER_NONE || filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS) {
      return filter;
    }
    console.error('Unsupported filter "' + filter + '"!');
    return ShadowGenerator.FILTER_NONE;
  };
  Object.defineProperty(CascadedShadowGenerator2.prototype, "numCascades", {
    get: function() {
      return this._numCascades;
    },
    set: function(value) {
      value = Math.min(Math.max(value, CascadedShadowGenerator2.MIN_CASCADES_COUNT), CascadedShadowGenerator2.MAX_CASCADES_COUNT);
      if (value === this._numCascades) {
        return;
      }
      this._numCascades = value;
      this.recreateShadowMap();
      this._recreateSceneUBOs();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "freezeShadowCastersBoundingInfo", {
    get: function() {
      return this._freezeShadowCastersBoundingInfo;
    },
    set: function(freeze) {
      if (this._freezeShadowCastersBoundingInfoObservable && freeze) {
        this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
        this._freezeShadowCastersBoundingInfoObservable = null;
      }
      if (!this._freezeShadowCastersBoundingInfoObservable && !freeze) {
        this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(this._computeShadowCastersBoundingInfo.bind(this));
      }
      this._freezeShadowCastersBoundingInfo = freeze;
      if (freeze) {
        this._computeShadowCastersBoundingInfo();
      }
    },
    enumerable: false,
    configurable: true
  });
  CascadedShadowGenerator2.prototype._computeShadowCastersBoundingInfo = function() {
    this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._scbiMax.copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
    if (this._shadowMap && this._shadowMap.renderList) {
      var renderList = this._shadowMap.renderList;
      for (var meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
        var mesh = renderList[meshIndex];
        if (!mesh) {
          continue;
        }
        var boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;
        this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);
        this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);
      }
      var meshes = this._scene.meshes;
      for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
        var mesh = meshes[meshIndex];
        if (!mesh || !mesh.isVisible || !mesh.isEnabled || !mesh.receiveShadows) {
          continue;
        }
        var boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;
        this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);
        this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);
      }
    }
    this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);
  };
  Object.defineProperty(CascadedShadowGenerator2.prototype, "shadowCastersBoundingInfo", {
    get: function() {
      return this._shadowCastersBoundingInfo;
    },
    set: function(boundingInfo) {
      this._shadowCastersBoundingInfo = boundingInfo;
    },
    enumerable: false,
    configurable: true
  });
  CascadedShadowGenerator2.prototype.setMinMaxDistance = function(min, max) {
    if (this._minDistance === min && this._maxDistance === max) {
      return;
    }
    if (min > max) {
      min = 0;
      max = 1;
    }
    if (min < 0) {
      min = 0;
    }
    if (max > 1) {
      max = 1;
    }
    this._minDistance = min;
    this._maxDistance = max;
    this._breaksAreDirty = true;
  };
  Object.defineProperty(CascadedShadowGenerator2.prototype, "minDistance", {
    get: function() {
      return this._minDistance;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "maxDistance", {
    get: function() {
      return this._maxDistance;
    },
    enumerable: false,
    configurable: true
  });
  CascadedShadowGenerator2.prototype.getClassName = function() {
    return CascadedShadowGenerator2.CLASSNAME;
  };
  CascadedShadowGenerator2.prototype.getCascadeMinExtents = function(cascadeIndex) {
    return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMinExtents[cascadeIndex] : null;
  };
  CascadedShadowGenerator2.prototype.getCascadeMaxExtents = function(cascadeIndex) {
    return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMaxExtents[cascadeIndex] : null;
  };
  Object.defineProperty(CascadedShadowGenerator2.prototype, "shadowMaxZ", {
    get: function() {
      if (!this._scene || !this._scene.activeCamera) {
        return 0;
      }
      return this._shadowMaxZ;
    },
    set: function(value) {
      if (!this._scene || !this._scene.activeCamera) {
        this._shadowMaxZ = value;
        return;
      }
      if (this._shadowMaxZ === value || value < this._scene.activeCamera.minZ || value > this._scene.activeCamera.maxZ) {
        return;
      }
      this._shadowMaxZ = value;
      this._light._markMeshesAsLightDirty();
      this._breaksAreDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "debug", {
    get: function() {
      return this._debug;
    },
    set: function(dbg) {
      this._debug = dbg;
      this._light._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "depthClamp", {
    get: function() {
      return this._depthClamp;
    },
    set: function(value) {
      this._depthClamp = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "cascadeBlendPercentage", {
    get: function() {
      return this._cascadeBlendPercentage;
    },
    set: function(value) {
      this._cascadeBlendPercentage = value;
      this._light._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "lambda", {
    get: function() {
      return this._lambda;
    },
    set: function(value) {
      var lambda = Math.min(Math.max(value, 0), 1);
      if (this._lambda == lambda) {
        return;
      }
      this._lambda = lambda;
      this._breaksAreDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  CascadedShadowGenerator2.prototype.getCascadeViewMatrix = function(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._viewMatrices[cascadeNum] : null;
  };
  CascadedShadowGenerator2.prototype.getCascadeProjectionMatrix = function(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._projectionMatrices[cascadeNum] : null;
  };
  CascadedShadowGenerator2.prototype.getCascadeTransformMatrix = function(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._transformMatrices[cascadeNum] : null;
  };
  CascadedShadowGenerator2.prototype.setDepthRenderer = function(depthRenderer) {
    this._depthRenderer = depthRenderer;
    if (this._depthReducer) {
      this._depthReducer.setDepthRenderer(this._depthRenderer);
    }
  };
  Object.defineProperty(CascadedShadowGenerator2.prototype, "autoCalcDepthBounds", {
    get: function() {
      return this._autoCalcDepthBounds;
    },
    set: function(value) {
      var _this = this;
      var camera = this._scene.activeCamera;
      if (!camera) {
        return;
      }
      this._autoCalcDepthBounds = value;
      if (!value) {
        if (this._depthReducer) {
          this._depthReducer.deactivate();
        }
        this.setMinMaxDistance(0, 1);
        return;
      }
      if (!this._depthReducer) {
        this._depthReducer = new DepthReducer(camera);
        this._depthReducer.onAfterReductionPerformed.add(function(minmax) {
          var min = minmax.min, max = minmax.max;
          if (min >= max) {
            min = 0;
            max = 1;
          }
          if (min != _this._minDistance || max != _this._maxDistance) {
            _this.setMinMaxDistance(min, max);
          }
        });
        this._depthReducer.setDepthRenderer(this._depthRenderer);
      }
      this._depthReducer.activate();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CascadedShadowGenerator2.prototype, "autoCalcDepthBoundsRefreshRate", {
    get: function() {
      var _a, _b, _c;
      return (_c = (_b = (_a = this._depthReducer) === null || _a === void 0 ? void 0 : _a.depthRenderer) === null || _b === void 0 ? void 0 : _b.getDepthMap().refreshRate) !== null && _c !== void 0 ? _c : -1;
    },
    set: function(value) {
      var _a;
      if ((_a = this._depthReducer) === null || _a === void 0 ? void 0 : _a.depthRenderer) {
        this._depthReducer.depthRenderer.getDepthMap().refreshRate = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  CascadedShadowGenerator2.prototype.splitFrustum = function() {
    this._breaksAreDirty = true;
  };
  CascadedShadowGenerator2.prototype._splitFrustum = function() {
    var camera = this._scene.activeCamera;
    if (!camera) {
      return;
    }
    var near = camera.minZ, far = camera.maxZ, cameraRange = far - near, minDistance = this._minDistance, maxDistance = this._shadowMaxZ < far && this._shadowMaxZ >= near ? Math.min((this._shadowMaxZ - near) / (far - near), this._maxDistance) : this._maxDistance;
    var minZ = near + minDistance * cameraRange, maxZ = near + maxDistance * cameraRange;
    var range = maxZ - minZ, ratio = maxZ / minZ;
    for (var cascadeIndex = 0; cascadeIndex < this._cascades.length; ++cascadeIndex) {
      var p = (cascadeIndex + 1) / this._numCascades, log = minZ * Math.pow(ratio, p), uniform = minZ + range * p;
      var d = this._lambda * (log - uniform) + uniform;
      this._cascades[cascadeIndex].prevBreakDistance = cascadeIndex === 0 ? minDistance : this._cascades[cascadeIndex - 1].breakDistance;
      this._cascades[cascadeIndex].breakDistance = (d - near) / cameraRange;
      this._viewSpaceFrustumsZ[cascadeIndex] = d;
      this._frustumLengths[cascadeIndex] = (this._cascades[cascadeIndex].breakDistance - this._cascades[cascadeIndex].prevBreakDistance) * cameraRange;
    }
    this._breaksAreDirty = false;
  };
  CascadedShadowGenerator2.prototype._computeMatrices = function() {
    var scene = this._scene;
    var camera = scene.activeCamera;
    if (!camera) {
      return;
    }
    Vector3.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection);
    if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
      this._lightDirection.z = 1e-13;
    }
    this._cachedDirection.copyFrom(this._lightDirection);
    var useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;
    for (var cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
      this._computeFrustumInWorldSpace(cascadeIndex);
      this._computeCascadeFrustum(cascadeIndex);
      this._cascadeMaxExtents[cascadeIndex].subtractToRef(this._cascadeMinExtents[cascadeIndex], tmpv1);
      this._frustumCenter[cascadeIndex].addToRef(this._lightDirection.scale(this._cascadeMinExtents[cascadeIndex].z), this._shadowCameraPos[cascadeIndex]);
      Matrix.LookAtLHToRef(this._shadowCameraPos[cascadeIndex], this._frustumCenter[cascadeIndex], UpDir, this._viewMatrices[cascadeIndex]);
      var minZ = 0, maxZ = tmpv1.z;
      var boundingInfo = this._shadowCastersBoundingInfo;
      boundingInfo.update(this._viewMatrices[cascadeIndex]);
      maxZ = Math.min(maxZ, boundingInfo.boundingBox.maximumWorld.z);
      if (!this._depthClamp || this.filter === ShadowGenerator.FILTER_PCSS) {
        minZ = Math.min(minZ, boundingInfo.boundingBox.minimumWorld.z);
      } else {
        minZ = Math.max(minZ, boundingInfo.boundingBox.minimumWorld.z);
      }
      Matrix.OrthoOffCenterLHToRef(this._cascadeMinExtents[cascadeIndex].x, this._cascadeMaxExtents[cascadeIndex].x, this._cascadeMinExtents[cascadeIndex].y, this._cascadeMaxExtents[cascadeIndex].y, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, this._projectionMatrices[cascadeIndex], scene.getEngine().isNDCHalfZRange);
      this._cascadeMinExtents[cascadeIndex].z = minZ;
      this._cascadeMaxExtents[cascadeIndex].z = maxZ;
      this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
      Vector3.TransformCoordinatesToRef(ZeroVec, this._transformMatrices[cascadeIndex], tmpv1);
      tmpv1.scaleInPlace(this._mapSize / 2);
      tmpv2.copyFromFloats(Math.round(tmpv1.x), Math.round(tmpv1.y), Math.round(tmpv1.z));
      tmpv2.subtractInPlace(tmpv1).scaleInPlace(2 / this._mapSize);
      Matrix.TranslationToRef(tmpv2.x, tmpv2.y, 0, tmpMatrix);
      this._projectionMatrices[cascadeIndex].multiplyToRef(tmpMatrix, this._projectionMatrices[cascadeIndex]);
      this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
      this._transformMatrices[cascadeIndex].copyToArray(this._transformMatricesAsArray, cascadeIndex * 16);
    }
  };
  CascadedShadowGenerator2.prototype._computeFrustumInWorldSpace = function(cascadeIndex) {
    if (!this._scene.activeCamera) {
      return;
    }
    var prevSplitDist = this._cascades[cascadeIndex].prevBreakDistance, splitDist = this._cascades[cascadeIndex].breakDistance;
    var isNDCHalfZRange = this._scene.getEngine().isNDCHalfZRange;
    this._scene.activeCamera.getViewMatrix();
    var invViewProj = Matrix.Invert(this._scene.activeCamera.getTransformationMatrix());
    var cornerIndexOffset = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;
    for (var cornerIndex = 0; cornerIndex < CascadedShadowGenerator2.frustumCornersNDCSpace.length; ++cornerIndex) {
      tmpv1.copyFrom(CascadedShadowGenerator2.frustumCornersNDCSpace[(cornerIndex + cornerIndexOffset) % CascadedShadowGenerator2.frustumCornersNDCSpace.length]);
      if (isNDCHalfZRange && tmpv1.z === -1) {
        tmpv1.z = 0;
      }
      Vector3.TransformCoordinatesToRef(tmpv1, invViewProj, this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
    }
    for (var cornerIndex = 0; cornerIndex < CascadedShadowGenerator2.frustumCornersNDCSpace.length / 2; ++cornerIndex) {
      tmpv1.copyFrom(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4]).subtractInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
      tmpv2.copyFrom(tmpv1).scaleInPlace(prevSplitDist);
      tmpv1.scaleInPlace(splitDist);
      tmpv1.addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
      this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4].copyFrom(tmpv1);
      this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].addInPlace(tmpv2);
    }
  };
  CascadedShadowGenerator2.prototype._computeCascadeFrustum = function(cascadeIndex) {
    this._cascadeMinExtents[cascadeIndex].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cascadeMaxExtents[cascadeIndex].copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
    this._frustumCenter[cascadeIndex].copyFromFloats(0, 0, 0);
    var camera = this._scene.activeCamera;
    if (!camera) {
      return;
    }
    for (var cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
      this._frustumCenter[cascadeIndex].addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
    }
    this._frustumCenter[cascadeIndex].scaleInPlace(1 / this._frustumCornersWorldSpace[cascadeIndex].length);
    if (this.stabilizeCascades) {
      var sphereRadius = 0;
      for (var cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
        var dist = this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].subtractToRef(this._frustumCenter[cascadeIndex], tmpv1).length();
        sphereRadius = Math.max(sphereRadius, dist);
      }
      sphereRadius = Math.ceil(sphereRadius * 16) / 16;
      this._cascadeMaxExtents[cascadeIndex].copyFromFloats(sphereRadius, sphereRadius, sphereRadius);
      this._cascadeMinExtents[cascadeIndex].copyFromFloats(-sphereRadius, -sphereRadius, -sphereRadius);
    } else {
      var lightCameraPos = this._frustumCenter[cascadeIndex];
      this._frustumCenter[cascadeIndex].addToRef(this._lightDirection, tmpv1);
      Matrix.LookAtLHToRef(lightCameraPos, tmpv1, UpDir, tmpMatrix);
      for (var cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
        Vector3.TransformCoordinatesToRef(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex], tmpMatrix, tmpv1);
        this._cascadeMinExtents[cascadeIndex].minimizeInPlace(tmpv1);
        this._cascadeMaxExtents[cascadeIndex].maximizeInPlace(tmpv1);
      }
    }
  };
  CascadedShadowGenerator2.prototype._recreateSceneUBOs = function() {
    this._disposeSceneUBOs();
    if (this._sceneUBOs) {
      for (var i = 0; i < this._numCascades; ++i) {
        this._sceneUBOs.push(this._scene.createSceneUniformBuffer('Scene for CSM Shadow Generator (light "'.concat(this._light.name, '" cascade #').concat(i, ")")));
      }
    }
  };
  Object.defineProperty(CascadedShadowGenerator2, "IsSupported", {
    get: function() {
      var engine = EngineStore.LastCreatedEngine;
      if (!engine) {
        return false;
      }
      return engine._features.supportCSM;
    },
    enumerable: false,
    configurable: true
  });
  CascadedShadowGenerator2.prototype._initializeGenerator = function() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
    this.penumbraDarkness = (_a = this.penumbraDarkness) !== null && _a !== void 0 ? _a : 1;
    this._numCascades = (_b = this._numCascades) !== null && _b !== void 0 ? _b : CascadedShadowGenerator2.DEFAULT_CASCADES_COUNT;
    this.stabilizeCascades = (_c = this.stabilizeCascades) !== null && _c !== void 0 ? _c : false;
    this._freezeShadowCastersBoundingInfoObservable = (_d = this._freezeShadowCastersBoundingInfoObservable) !== null && _d !== void 0 ? _d : null;
    this.freezeShadowCastersBoundingInfo = (_e = this.freezeShadowCastersBoundingInfo) !== null && _e !== void 0 ? _e : false;
    this._scbiMin = (_f = this._scbiMin) !== null && _f !== void 0 ? _f : new Vector3(0, 0, 0);
    this._scbiMax = (_g = this._scbiMax) !== null && _g !== void 0 ? _g : new Vector3(0, 0, 0);
    this._shadowCastersBoundingInfo = (_h = this._shadowCastersBoundingInfo) !== null && _h !== void 0 ? _h : new BoundingInfo(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    this._breaksAreDirty = (_j = this._breaksAreDirty) !== null && _j !== void 0 ? _j : true;
    this._minDistance = (_k = this._minDistance) !== null && _k !== void 0 ? _k : 0;
    this._maxDistance = (_l = this._maxDistance) !== null && _l !== void 0 ? _l : 1;
    this._currentLayer = (_m = this._currentLayer) !== null && _m !== void 0 ? _m : 0;
    this._shadowMaxZ = (_q = (_o = this._shadowMaxZ) !== null && _o !== void 0 ? _o : (_p = this._scene.activeCamera) === null || _p === void 0 ? void 0 : _p.maxZ) !== null && _q !== void 0 ? _q : 1e4;
    this._debug = (_r = this._debug) !== null && _r !== void 0 ? _r : false;
    this._depthClamp = (_s = this._depthClamp) !== null && _s !== void 0 ? _s : true;
    this._cascadeBlendPercentage = (_t = this._cascadeBlendPercentage) !== null && _t !== void 0 ? _t : 0.1;
    this._lambda = (_u = this._lambda) !== null && _u !== void 0 ? _u : 0.5;
    this._autoCalcDepthBounds = (_v = this._autoCalcDepthBounds) !== null && _v !== void 0 ? _v : false;
    this._recreateSceneUBOs();
    _super.prototype._initializeGenerator.call(this);
  };
  CascadedShadowGenerator2.prototype._createTargetRenderTexture = function() {
    var engine = this._scene.getEngine();
    var size = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };
    this._shadowMap = new RenderTargetTexture(this._light.name + "_CSMShadowMap", size, this._scene, false, true, this._textureType, false, void 0, false, false, void 0);
    this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true);
  };
  CascadedShadowGenerator2.prototype._initializeShadowMap = function() {
    var _this = this;
    _super.prototype._initializeShadowMap.call(this);
    if (this._shadowMap === null) {
      return;
    }
    this._transformMatricesAsArray = new Float32Array(this._numCascades * 16);
    this._viewSpaceFrustumsZ = new Array(this._numCascades);
    this._frustumLengths = new Array(this._numCascades);
    this._lightSizeUVCorrection = new Array(this._numCascades * 2);
    this._depthCorrection = new Array(this._numCascades);
    this._cascades = [];
    this._viewMatrices = [];
    this._projectionMatrices = [];
    this._transformMatrices = [];
    this._cascadeMinExtents = [];
    this._cascadeMaxExtents = [];
    this._frustumCenter = [];
    this._shadowCameraPos = [];
    this._frustumCornersWorldSpace = [];
    for (var cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
      this._cascades[cascadeIndex] = {
        prevBreakDistance: 0,
        breakDistance: 0
      };
      this._viewMatrices[cascadeIndex] = Matrix.Zero();
      this._projectionMatrices[cascadeIndex] = Matrix.Zero();
      this._transformMatrices[cascadeIndex] = Matrix.Zero();
      this._cascadeMinExtents[cascadeIndex] = new Vector3();
      this._cascadeMaxExtents[cascadeIndex] = new Vector3();
      this._frustumCenter[cascadeIndex] = new Vector3();
      this._shadowCameraPos[cascadeIndex] = new Vector3();
      this._frustumCornersWorldSpace[cascadeIndex] = new Array(CascadedShadowGenerator2.frustumCornersNDCSpace.length);
      for (var i = 0; i < CascadedShadowGenerator2.frustumCornersNDCSpace.length; ++i) {
        this._frustumCornersWorldSpace[cascadeIndex][i] = new Vector3();
      }
    }
    var engine = this._scene.getEngine();
    this._shadowMap.onBeforeBindObservable.clear();
    this._shadowMap.onBeforeRenderObservable.clear();
    this._shadowMap.onBeforeRenderObservable.add(function(layer) {
      if (_this._sceneUBOs) {
        _this._scene.setSceneUniformBuffer(_this._sceneUBOs[layer]);
      }
      _this._currentLayer = layer;
      if (_this._filter === ShadowGenerator.FILTER_PCF) {
        engine.setColorWrite(false);
      }
      _this._scene.setTransformMatrix(_this.getCascadeViewMatrix(layer), _this.getCascadeProjectionMatrix(layer));
      if (_this._useUBO) {
        _this._scene.getSceneUniformBuffer().unbindEffect();
        _this._scene.finalizeSceneUbo();
      }
    });
    this._shadowMap.onBeforeBindObservable.add(function() {
      var _a;
      _this._currentSceneUBO = _this._scene.getSceneUniformBuffer();
      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, "cascaded shadow map generation for pass id ".concat(engine.currentRenderPassId), 1);
      if (_this._breaksAreDirty) {
        _this._splitFrustum();
      }
      _this._computeMatrices();
    });
    this._splitFrustum();
  };
  CascadedShadowGenerator2.prototype._bindCustomEffectForRenderSubMeshForShadowMap = function(subMesh, effect, mesh) {
    effect.setMatrix("viewProjection", this.getCascadeTransformMatrix(this._currentLayer));
  };
  CascadedShadowGenerator2.prototype._isReadyCustomDefines = function(defines, subMesh, useInstances) {
    defines.push("#define SM_DEPTHCLAMP " + (this._depthClamp && this._filter !== ShadowGenerator.FILTER_PCSS ? "1" : "0"));
  };
  CascadedShadowGenerator2.prototype.prepareDefines = function(defines, lightIndex) {
    _super.prototype.prepareDefines.call(this, defines, lightIndex);
    var scene = this._scene;
    var light = this._light;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    defines["SHADOWCSM" + lightIndex] = true;
    defines["SHADOWCSMDEBUG" + lightIndex] = this.debug;
    defines["SHADOWCSMNUM_CASCADES" + lightIndex] = this.numCascades;
    defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = scene.useRightHandedSystem;
    var camera = scene.activeCamera;
    if (camera && this._shadowMaxZ < camera.maxZ) {
      defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = true;
    }
    if (this.cascadeBlendPercentage === 0) {
      defines["SHADOWCSMNOBLEND" + lightIndex] = true;
    }
  };
  CascadedShadowGenerator2.prototype.bindShadowLight = function(lightIndex, effect) {
    var light = this._light;
    var scene = this._scene;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    var camera = scene.activeCamera;
    if (!camera) {
      return;
    }
    var shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return;
    }
    var width = shadowMap.getSize().width;
    effect.setMatrices("lightMatrix" + lightIndex, this._transformMatricesAsArray);
    effect.setArray("viewFrustumZ" + lightIndex, this._viewSpaceFrustumsZ);
    effect.setFloat("cascadeBlendFactor" + lightIndex, this.cascadeBlendPercentage === 0 ? 1e4 : 1 / this.cascadeBlendPercentage);
    effect.setArray("frustumLengths" + lightIndex, this._frustumLengths);
    if (this._filter === ShadowGenerator.FILTER_PCF) {
      effect.setDepthStencilTexture("shadowSampler" + lightIndex, shadowMap);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
    } else if (this._filter === ShadowGenerator.FILTER_PCSS) {
      for (var cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
        this._lightSizeUVCorrection[cascadeIndex * 2 + 0] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[cascadeIndex].x - this._cascadeMinExtents[cascadeIndex].x);
        this._lightSizeUVCorrection[cascadeIndex * 2 + 1] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[cascadeIndex].y - this._cascadeMinExtents[cascadeIndex].y);
        this._depthCorrection[cascadeIndex] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[cascadeIndex].z - this._cascadeMinExtents[cascadeIndex].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);
      }
      effect.setDepthStencilTexture("shadowSampler" + lightIndex, shadowMap);
      effect.setTexture("depthSampler" + lightIndex, shadowMap);
      effect.setArray2("lightSizeUVCorrection" + lightIndex, this._lightSizeUVCorrection);
      effect.setArray("depthCorrection" + lightIndex, this._depthCorrection);
      effect.setFloat("penumbraDarkness" + lightIndex, this.penumbraDarkness);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / width, this._contactHardeningLightSizeUVRatio * width, this.frustumEdgeFalloff, lightIndex);
    } else {
      effect.setTexture("shadowSampler" + lightIndex, shadowMap);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
    }
    light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
  };
  CascadedShadowGenerator2.prototype.getTransformMatrix = function() {
    return this.getCascadeTransformMatrix(0);
  };
  CascadedShadowGenerator2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    if (this._freezeShadowCastersBoundingInfoObservable) {
      this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
      this._freezeShadowCastersBoundingInfoObservable = null;
    }
    if (this._depthReducer) {
      this._depthReducer.dispose();
      this._depthReducer = null;
    }
  };
  CascadedShadowGenerator2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    var shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return serializationObject;
    }
    serializationObject.numCascades = this._numCascades;
    serializationObject.debug = this._debug;
    serializationObject.stabilizeCascades = this.stabilizeCascades;
    serializationObject.lambda = this._lambda;
    serializationObject.cascadeBlendPercentage = this.cascadeBlendPercentage;
    serializationObject.depthClamp = this._depthClamp;
    serializationObject.autoCalcDepthBounds = this.autoCalcDepthBounds;
    serializationObject.shadowMaxZ = this._shadowMaxZ;
    serializationObject.penumbraDarkness = this.penumbraDarkness;
    serializationObject.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo;
    serializationObject.minDistance = this.minDistance;
    serializationObject.maxDistance = this.maxDistance;
    serializationObject.renderList = [];
    if (shadowMap.renderList) {
      for (var meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
        var mesh = shadowMap.renderList[meshIndex];
        serializationObject.renderList.push(mesh.id);
      }
    }
    return serializationObject;
  };
  CascadedShadowGenerator2.Parse = function(parsedShadowGenerator, scene) {
    var shadowGenerator = ShadowGenerator.Parse(parsedShadowGenerator, scene, function(mapSize, light) {
      return new CascadedShadowGenerator2(mapSize, light);
    });
    if (parsedShadowGenerator.numCascades !== void 0) {
      shadowGenerator.numCascades = parsedShadowGenerator.numCascades;
    }
    if (parsedShadowGenerator.debug !== void 0) {
      shadowGenerator.debug = parsedShadowGenerator.debug;
    }
    if (parsedShadowGenerator.stabilizeCascades !== void 0) {
      shadowGenerator.stabilizeCascades = parsedShadowGenerator.stabilizeCascades;
    }
    if (parsedShadowGenerator.lambda !== void 0) {
      shadowGenerator.lambda = parsedShadowGenerator.lambda;
    }
    if (parsedShadowGenerator.cascadeBlendPercentage !== void 0) {
      shadowGenerator.cascadeBlendPercentage = parsedShadowGenerator.cascadeBlendPercentage;
    }
    if (parsedShadowGenerator.depthClamp !== void 0) {
      shadowGenerator.depthClamp = parsedShadowGenerator.depthClamp;
    }
    if (parsedShadowGenerator.autoCalcDepthBounds !== void 0) {
      shadowGenerator.autoCalcDepthBounds = parsedShadowGenerator.autoCalcDepthBounds;
    }
    if (parsedShadowGenerator.shadowMaxZ !== void 0) {
      shadowGenerator.shadowMaxZ = parsedShadowGenerator.shadowMaxZ;
    }
    if (parsedShadowGenerator.penumbraDarkness !== void 0) {
      shadowGenerator.penumbraDarkness = parsedShadowGenerator.penumbraDarkness;
    }
    if (parsedShadowGenerator.freezeShadowCastersBoundingInfo !== void 0) {
      shadowGenerator.freezeShadowCastersBoundingInfo = parsedShadowGenerator.freezeShadowCastersBoundingInfo;
    }
    if (parsedShadowGenerator.minDistance !== void 0 && parsedShadowGenerator.maxDistance !== void 0) {
      shadowGenerator.setMinMaxDistance(parsedShadowGenerator.minDistance, parsedShadowGenerator.maxDistance);
    }
    return shadowGenerator;
  };
  CascadedShadowGenerator2.frustumCornersNDCSpace = [
    new Vector3(-1, 1, -1),
    new Vector3(1, 1, -1),
    new Vector3(1, -1, -1),
    new Vector3(-1, -1, -1),
    new Vector3(-1, 1, 1),
    new Vector3(1, 1, 1),
    new Vector3(1, -1, 1),
    new Vector3(-1, -1, 1)
  ];
  CascadedShadowGenerator2.CLASSNAME = "CascadedShadowGenerator";
  CascadedShadowGenerator2.DEFAULT_CASCADES_COUNT = 4;
  CascadedShadowGenerator2.MIN_CASCADES_COUNT = 2;
  CascadedShadowGenerator2.MAX_CASCADES_COUNT = 4;
  CascadedShadowGenerator2._SceneComponentInitialization = function(_) {
    throw _WarnImport("ShadowGeneratorSceneComponent");
  };
  return CascadedShadowGenerator2;
}(ShadowGenerator);
AbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, function(parsedData, scene) {
  if (parsedData.shadowGenerators !== void 0 && parsedData.shadowGenerators !== null) {
    for (var index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {
      var parsedShadowGenerator = parsedData.shadowGenerators[index];
      if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {
        CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);
      } else {
        ShadowGenerator.Parse(parsedShadowGenerator, scene);
      }
    }
  }
});
var ShadowGeneratorSceneComponent = function() {
  function ShadowGeneratorSceneComponent2(scene) {
    this.name = SceneComponentConstants.NAME_SHADOWGENERATOR;
    this.scene = scene;
  }
  ShadowGeneratorSceneComponent2.prototype.register = function() {
    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);
  };
  ShadowGeneratorSceneComponent2.prototype.rebuild = function() {
  };
  ShadowGeneratorSceneComponent2.prototype.serialize = function(serializationObject) {
    serializationObject.shadowGenerators = [];
    var lights = this.scene.lights;
    for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {
      var light = lights_1[_i];
      var shadowGenerator = light.getShadowGenerator();
      if (shadowGenerator) {
        serializationObject.shadowGenerators.push(shadowGenerator.serialize());
      }
    }
  };
  ShadowGeneratorSceneComponent2.prototype.addFromContainer = function(container) {
  };
  ShadowGeneratorSceneComponent2.prototype.removeFromContainer = function(container, dispose) {
  };
  ShadowGeneratorSceneComponent2.prototype.dispose = function() {
  };
  ShadowGeneratorSceneComponent2.prototype._gatherRenderTargets = function(renderTargets) {
    var scene = this.scene;
    if (this.scene.shadowsEnabled) {
      for (var lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {
        var light = scene.lights[lightIndex];
        var shadowGenerator = light.getShadowGenerator();
        if (light.isEnabled() && light.shadowEnabled && shadowGenerator) {
          var shadowMap = shadowGenerator.getShadowMap();
          if (scene.textures.indexOf(shadowMap) !== -1) {
            renderTargets.push(shadowMap);
          }
        }
      }
    }
  };
  return ShadowGeneratorSceneComponent2;
}();
ShadowGenerator._SceneComponentInitialization = function(scene) {
  var component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);
  if (!component) {
    component = new ShadowGeneratorSceneComponent(scene);
    scene._addComponent(component);
  }
};
const defaultOptions$2 = {
  enableShadows: true
};
function createLights(options = defaultOptions$2) {
  const { enableShadows, scene } = options;
  const d_light = new DirectionalLight("DirectionalLight", new Vector3(-0.3, -1, 0.4), scene);
  d_light.position = new Vector3(-50, 65, -50);
  d_light.intensity = 0.65;
  const h_light = new HemisphericLight("HemisphericLight", new Vector3(1, 1, 0), scene);
  h_light.intensity = 0.2;
  if (enableShadows) {
    d_light.shadowMinZ = 1;
    d_light.shadowMaxZ = 70;
    d_light.shadowGenerator = new ShadowGenerator(2048, d_light);
    d_light.shadowGenerator.useCloseExponentialShadowMap = true;
    d_light.shadowGenerator.darkness = 0.8;
  }
  return { directional: d_light, hemispheric: h_light };
}
function CreateBoxVertexData(options) {
  var nbFaces = 6;
  var indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
  var normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0];
  var uvs = [];
  var positions = [];
  var width = options.width || options.size || 1;
  var height = options.height || options.size || 1;
  var depth = options.depth || options.size || 1;
  var wrap = options.wrap || false;
  var topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;
  var bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;
  topBaseAt = (topBaseAt + 4) % 4;
  bottomBaseAt = (bottomBaseAt + 4) % 4;
  var topOrder = [2, 0, 3, 1];
  var bottomOrder = [2, 0, 1, 3];
  var topIndex = topOrder[topBaseAt];
  var bottomIndex = bottomOrder[bottomBaseAt];
  var basePositions = [1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1];
  if (wrap) {
    indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];
    basePositions = [-1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1];
    var topFaceBase = [[1, 1, 1], [-1, 1, 1], [-1, 1, -1], [1, 1, -1]];
    var bottomFaceBase = [[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]];
    var topFaceOrder = [17, 18, 19, 16];
    var bottomFaceOrder = [22, 23, 20, 21];
    while (topIndex > 0) {
      topFaceBase.unshift(topFaceBase.pop());
      topFaceOrder.unshift(topFaceOrder.pop());
      topIndex--;
    }
    while (bottomIndex > 0) {
      bottomFaceBase.unshift(bottomFaceBase.pop());
      bottomFaceOrder.unshift(bottomFaceOrder.pop());
      bottomIndex--;
    }
    topFaceBase = topFaceBase.flat();
    bottomFaceBase = bottomFaceBase.flat();
    basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);
    indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);
    indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);
  }
  var scaleArray = [width / 2, height / 2, depth / 2];
  positions = basePositions.reduce(function(accumulator, currentValue, currentIndex) {
    return accumulator.concat(currentValue * scaleArray[currentIndex % 3]);
  }, []);
  var sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  var faceUV = options.faceUV || new Array(6);
  var faceColors = options.faceColors;
  var colors = [];
  for (var f = 0; f < 6; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4$1(1, 1, 1, 1);
    }
  }
  for (var index = 0; index < nbFaces; index++) {
    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    if (faceColors) {
      for (var c = 0; c < 4; c++) {
        colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  var vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    var totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreateBox(name2, options, scene) {
  if (options === void 0) {
    options = {};
  }
  if (scene === void 0) {
    scene = null;
  }
  var box = new Mesh(name2, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  box._originalBuilderSideOrientation = options.sideOrientation;
  var vertexData = CreateBoxVertexData(options);
  vertexData.applyToMesh(box, options.updatable);
  return box;
}
VertexData.CreateBox = CreateBoxVertexData;
Mesh.CreateBox = function(name2, size, scene, updatable, sideOrientation) {
  if (scene === void 0) {
    scene = null;
  }
  var options = {
    size,
    sideOrientation,
    updatable
  };
  return CreateBox(name2, options, scene);
};
var PrePassConfiguration = function() {
  function PrePassConfiguration2() {
    this.previousWorldMatrices = {};
    this.previousBones = {};
  }
  PrePassConfiguration2.AddUniforms = function(uniforms) {
    uniforms.push("previousWorld", "previousViewProjection", "mPreviousBones");
  };
  PrePassConfiguration2.AddSamplers = function(samplers) {
  };
  PrePassConfiguration2.prototype.bindForSubMesh = function(effect, scene, mesh, world, isFrozen) {
    if (scene.prePassRenderer && scene.prePassRenderer.enabled && scene.prePassRenderer.currentRTisSceneRT) {
      if (scene.prePassRenderer.getIndex(2) !== -1) {
        if (!this.previousWorldMatrices[mesh.uniqueId]) {
          this.previousWorldMatrices[mesh.uniqueId] = world.clone();
        }
        if (!this.previousViewProjection) {
          this.previousViewProjection = scene.getTransformMatrix().clone();
          this.currentViewProjection = scene.getTransformMatrix().clone();
        }
        var engine = scene.getEngine();
        if (this.currentViewProjection.updateFlag !== scene.getTransformMatrix().updateFlag) {
          this._lastUpdateFrameId = engine.frameId;
          this.previousViewProjection.copyFrom(this.currentViewProjection);
          this.currentViewProjection.copyFrom(scene.getTransformMatrix());
        } else if (this._lastUpdateFrameId !== engine.frameId) {
          this._lastUpdateFrameId = engine.frameId;
          this.previousViewProjection.copyFrom(this.currentViewProjection);
        }
        effect.setMatrix("previousWorld", this.previousWorldMatrices[mesh.uniqueId]);
        effect.setMatrix("previousViewProjection", this.previousViewProjection);
        this.previousWorldMatrices[mesh.uniqueId] = world.clone();
      }
    }
  };
  return PrePassConfiguration2;
}();
var PushMaterial = function(_super) {
  __extends(PushMaterial2, _super);
  function PushMaterial2(name2, scene, storeEffectOnSubMeshes) {
    if (storeEffectOnSubMeshes === void 0) {
      storeEffectOnSubMeshes = true;
    }
    var _this = _super.call(this, name2, scene) || this;
    _this._normalMatrix = new Matrix();
    _this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;
    return _this;
  }
  PushMaterial2.prototype.getEffect = function() {
    return this._storeEffectOnSubMeshes ? this._activeEffect : _super.prototype.getEffect.call(this);
  };
  PushMaterial2.prototype.isReady = function(mesh, useInstances) {
    if (!mesh) {
      return false;
    }
    if (!this._storeEffectOnSubMeshes) {
      return true;
    }
    if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
      return true;
    }
    return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);
  };
  PushMaterial2.prototype._isReadyForSubMesh = function(subMesh) {
    var defines = subMesh.materialDefines;
    if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {
      if (defines._renderId === this.getScene().getRenderId()) {
        return true;
      }
    }
    return false;
  };
  PushMaterial2.prototype.bindOnlyWorldMatrix = function(world) {
    this._activeEffect.setMatrix("world", world);
  };
  PushMaterial2.prototype.bindOnlyNormalMatrix = function(normalMatrix) {
    this._activeEffect.setMatrix("normalMatrix", normalMatrix);
  };
  PushMaterial2.prototype.bind = function(world, mesh) {
    if (!mesh) {
      return;
    }
    this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);
  };
  PushMaterial2.prototype._afterBind = function(mesh, effect) {
    if (effect === void 0) {
      effect = null;
    }
    _super.prototype._afterBind.call(this, mesh, effect);
    this.getScene()._cachedEffect = effect;
  };
  PushMaterial2.prototype._mustRebind = function(scene, effect, visibility) {
    if (visibility === void 0) {
      visibility = 1;
    }
    return scene.isCachedMaterialInvalid(this, effect, visibility);
  };
  return PushMaterial2;
}(Material);
var MaterialFlags = function() {
  function MaterialFlags2() {
  }
  Object.defineProperty(MaterialFlags2, "DiffuseTextureEnabled", {
    get: function() {
      return this._DiffuseTextureEnabled;
    },
    set: function(value) {
      if (this._DiffuseTextureEnabled === value) {
        return;
      }
      this._DiffuseTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "DetailTextureEnabled", {
    get: function() {
      return this._DetailTextureEnabled;
    },
    set: function(value) {
      if (this._DetailTextureEnabled === value) {
        return;
      }
      this._DetailTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "AmbientTextureEnabled", {
    get: function() {
      return this._AmbientTextureEnabled;
    },
    set: function(value) {
      if (this._AmbientTextureEnabled === value) {
        return;
      }
      this._AmbientTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "OpacityTextureEnabled", {
    get: function() {
      return this._OpacityTextureEnabled;
    },
    set: function(value) {
      if (this._OpacityTextureEnabled === value) {
        return;
      }
      this._OpacityTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "ReflectionTextureEnabled", {
    get: function() {
      return this._ReflectionTextureEnabled;
    },
    set: function(value) {
      if (this._ReflectionTextureEnabled === value) {
        return;
      }
      this._ReflectionTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "EmissiveTextureEnabled", {
    get: function() {
      return this._EmissiveTextureEnabled;
    },
    set: function(value) {
      if (this._EmissiveTextureEnabled === value) {
        return;
      }
      this._EmissiveTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "SpecularTextureEnabled", {
    get: function() {
      return this._SpecularTextureEnabled;
    },
    set: function(value) {
      if (this._SpecularTextureEnabled === value) {
        return;
      }
      this._SpecularTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "BumpTextureEnabled", {
    get: function() {
      return this._BumpTextureEnabled;
    },
    set: function(value) {
      if (this._BumpTextureEnabled === value) {
        return;
      }
      this._BumpTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "LightmapTextureEnabled", {
    get: function() {
      return this._LightmapTextureEnabled;
    },
    set: function(value) {
      if (this._LightmapTextureEnabled === value) {
        return;
      }
      this._LightmapTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "RefractionTextureEnabled", {
    get: function() {
      return this._RefractionTextureEnabled;
    },
    set: function(value) {
      if (this._RefractionTextureEnabled === value) {
        return;
      }
      this._RefractionTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "ColorGradingTextureEnabled", {
    get: function() {
      return this._ColorGradingTextureEnabled;
    },
    set: function(value) {
      if (this._ColorGradingTextureEnabled === value) {
        return;
      }
      this._ColorGradingTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "FresnelEnabled", {
    get: function() {
      return this._FresnelEnabled;
    },
    set: function(value) {
      if (this._FresnelEnabled === value) {
        return;
      }
      this._FresnelEnabled = value;
      Engine.MarkAllMaterialsAsDirty(4);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "ClearCoatTextureEnabled", {
    get: function() {
      return this._ClearCoatTextureEnabled;
    },
    set: function(value) {
      if (this._ClearCoatTextureEnabled === value) {
        return;
      }
      this._ClearCoatTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "ClearCoatBumpTextureEnabled", {
    get: function() {
      return this._ClearCoatBumpTextureEnabled;
    },
    set: function(value) {
      if (this._ClearCoatBumpTextureEnabled === value) {
        return;
      }
      this._ClearCoatBumpTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "ClearCoatTintTextureEnabled", {
    get: function() {
      return this._ClearCoatTintTextureEnabled;
    },
    set: function(value) {
      if (this._ClearCoatTintTextureEnabled === value) {
        return;
      }
      this._ClearCoatTintTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "SheenTextureEnabled", {
    get: function() {
      return this._SheenTextureEnabled;
    },
    set: function(value) {
      if (this._SheenTextureEnabled === value) {
        return;
      }
      this._SheenTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "AnisotropicTextureEnabled", {
    get: function() {
      return this._AnisotropicTextureEnabled;
    },
    set: function(value) {
      if (this._AnisotropicTextureEnabled === value) {
        return;
      }
      this._AnisotropicTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "ThicknessTextureEnabled", {
    get: function() {
      return this._ThicknessTextureEnabled;
    },
    set: function(value) {
      if (this._ThicknessTextureEnabled === value) {
        return;
      }
      this._ThicknessTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "RefractionIntensityTextureEnabled", {
    get: function() {
      return this._ThicknessTextureEnabled;
    },
    set: function(value) {
      if (this._RefractionIntensityTextureEnabled === value) {
        return;
      }
      this._RefractionIntensityTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialFlags2, "TranslucencyIntensityTextureEnabled", {
    get: function() {
      return this._ThicknessTextureEnabled;
    },
    set: function(value) {
      if (this._TranslucencyIntensityTextureEnabled === value) {
        return;
      }
      this._TranslucencyIntensityTextureEnabled = value;
      Engine.MarkAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  MaterialFlags2._DiffuseTextureEnabled = true;
  MaterialFlags2._DetailTextureEnabled = true;
  MaterialFlags2._AmbientTextureEnabled = true;
  MaterialFlags2._OpacityTextureEnabled = true;
  MaterialFlags2._ReflectionTextureEnabled = true;
  MaterialFlags2._EmissiveTextureEnabled = true;
  MaterialFlags2._SpecularTextureEnabled = true;
  MaterialFlags2._BumpTextureEnabled = true;
  MaterialFlags2._LightmapTextureEnabled = true;
  MaterialFlags2._RefractionTextureEnabled = true;
  MaterialFlags2._ColorGradingTextureEnabled = true;
  MaterialFlags2._FresnelEnabled = true;
  MaterialFlags2._ClearCoatTextureEnabled = true;
  MaterialFlags2._ClearCoatBumpTextureEnabled = true;
  MaterialFlags2._ClearCoatTintTextureEnabled = true;
  MaterialFlags2._SheenTextureEnabled = true;
  MaterialFlags2._AnisotropicTextureEnabled = true;
  MaterialFlags2._ThicknessTextureEnabled = true;
  MaterialFlags2._RefractionIntensityTextureEnabled = true;
  MaterialFlags2._TranslucencyIntensityTextureEnabled = true;
  return MaterialFlags2;
}();
var name$I = "defaultFragmentDeclaration";
var shader$I = "uniform vec4 vEyePosition;\nuniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;\nuniform vec3 vAmbientColor;\nuniform float visibility;\n\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\nuniform mat4 view;\n#endif\n#ifdef REFRACTION\nuniform vec4 vRefractionInfos;\n#ifndef REFRACTIONMAP_3D\nuniform mat4 refractionMatrix;\n#endif\n#ifdef REFRACTIONFRESNEL\nuniform vec4 refractionLeftColor;\nuniform vec4 refractionRightColor;\n#endif\n#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)\nuniform vec3 vRefractionPosition;\nuniform vec3 vRefractionSize;\n#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\n#endif\n#ifdef DIFFUSEFRESNEL\nuniform vec4 diffuseLeftColor;\nuniform vec4 diffuseRightColor;\n#endif\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\n#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;\nuniform vec4 emissiveRightColor;\n#endif\n\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\nuniform mat4 reflectionMatrix;\n#endif\n#ifndef REFLECTIONMAP_SKYBOX\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;\nuniform vec3 vReflectionSize;\n#endif\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 reflectionLeftColor;\nuniform vec4 reflectionRightColor;\n#endif\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\n#endif\n#define ADDITIONAL_FRAGMENT_DECLARATION\n";
ShaderStore.IncludesShadersStore[name$I] = shader$I;
var name$H = "defaultUboDeclaration";
var shader$H = "layout(std140,column_major) uniform;\nuniform Material\n{\nvec4 diffuseLeftColor;\nvec4 diffuseRightColor;\nvec4 opacityParts;\nvec4 reflectionLeftColor;\nvec4 reflectionRightColor;\nvec4 refractionLeftColor;\nvec4 refractionRightColor;\nvec4 emissiveLeftColor;\nvec4 emissiveRightColor;\nvec2 vDiffuseInfos;\nvec2 vAmbientInfos;\nvec2 vOpacityInfos;\nvec2 vReflectionInfos;\nvec3 vReflectionPosition;\nvec3 vReflectionSize;\nvec2 vEmissiveInfos;\nvec2 vLightmapInfos;\nvec2 vSpecularInfos;\nvec3 vBumpInfos;\nmat4 diffuseMatrix;\nmat4 ambientMatrix;\nmat4 opacityMatrix;\nmat4 reflectionMatrix;\nmat4 emissiveMatrix;\nmat4 lightmapMatrix;\nmat4 specularMatrix;\nmat4 bumpMatrix;\nvec2 vTangentSpaceParams;\nfloat pointSize;\nfloat alphaCutOff;\nmat4 refractionMatrix;\nvec4 vRefractionInfos;\nvec3 vRefractionPosition;\nvec3 vRefractionSize;\nvec4 vSpecularColor;\nvec3 vEmissiveColor;\nvec4 vDiffuseColor;\nvec3 vAmbientColor;\n#define ADDITIONAL_UBO_DECLARATION\n};\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n";
ShaderStore.IncludesShadersStore[name$H] = shader$H;
var name$G = "prePassDeclaration";
var shader$G = "#ifdef PREPASS\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out highp vec4 glFragData[{X}];\nhighp vec4 gl_FragColor;\n#ifdef PREPASS_DEPTH\nvarying highp vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nvarying highp vec4 vCurrentPosition;\nvarying highp vec4 vPreviousPosition;\n#endif\n#endif\n";
ShaderStore.IncludesShadersStore[name$G] = shader$G;
var name$F = "oitDeclaration";
var shader$F = "#ifdef ORDER_INDEPENDENT_TRANSPARENCY\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out vec2 depth;\nlayout(location=1) out vec4 frontColor;\nlayout(location=2) out vec4 backColor;\n#define MAX_DEPTH 99999.0\nhighp vec4 gl_FragColor;\nuniform sampler2D oitDepthSampler;\nuniform sampler2D oitFrontColorSampler;\n#endif\n";
ShaderStore.IncludesShadersStore[name$F] = shader$F;
var name$E = "mainUVVaryingDeclaration";
var shader$E = "#ifdef MAINUV{X}\nvarying vec2 vMainUV{X};\n#endif\n";
ShaderStore.IncludesShadersStore[name$E] = shader$E;
var name$D = "lightFragmentDeclaration";
var shader$D = "#ifdef LIGHT{X}\nuniform vec4 vLightData{X};\nuniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float cascadeBlendFactor{X};\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\nuniform highp sampler2DArray depthSampler{X};\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);\nvec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X};\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};\nuniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};\nuniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};\nuniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};\nuniform sampler2D projectionLightSampler{X};\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$D] = shader$D;
var name$C = "lightUboDeclaration";
var shader$C = "#ifdef LIGHT{X}\nuniform Light{X}\n{\nvec4 vLightData;\nvec4 vLightDiffuse;\nvec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;\nvec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;\nvec2 depthValues;\n} light{X};\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};\nuniform sampler2D projectionLightSampler{X};\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float cascadeBlendFactor{X};\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\nuniform highp sampler2DArray depthSampler{X};\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);\nvec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X};\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};\nuniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$C] = shader$C;
var name$B = "lightsFragmentFunctions";
var shader$B = "\nstruct lightingInfo\n{\nvec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef NDOTL\nfloat ndl;\n#endif\n};\nlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\nlightingInfo result;\nvec3 lightVectorW;\nfloat attenuation=1.0;\nif (lightData.w == 0.)\n{\nvec3 direction=lightData.xyz-vPositionW;\nattenuation=max(0.,1.0-length(direction)/range);\nlightVectorW=normalize(direction);\n}\nelse\n{\nlightVectorW=normalize(-lightData.xyz);\n}\n\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\n\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;\n}\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\nlightingInfo result;\nvec3 direction=lightData.xyz-vPositionW;\nvec3 lightVectorW=normalize(direction);\nfloat attenuation=max(0.,1.0-length(direction)/range);\n\nfloat cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));\nif (cosAngle>=lightDirection.w)\n{\ncosAngle=max(0.,pow(cosAngle,lightData.w));\nattenuation*=cosAngle;\n\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\n\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;\n}\nresult.diffuse=vec3(0.);\n#ifdef SPECULARTERM\nresult.specular=vec3(0.);\n#endif\n#ifdef NDOTL\nresult.ndl=0.;\n#endif\nreturn result;\n}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {\nlightingInfo result;\n\nfloat ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\n#ifdef SPECULARTERM\n\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor;\n#endif\nreturn result;\n}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\nvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\nstrq/=strq.w;\nvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\nreturn textureColor;\n}";
ShaderStore.IncludesShadersStore[name$B] = shader$B;
var name$A = "shadowsFragmentFunctions";
var shader$A = "#ifdef SHADOWS\n#ifndef SHADOWFLOAT\n\nfloat unpack(vec4 color)\n{\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\nreturn dot(color,bit_shift);\n}\n#endif\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\n{\nfloat mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));\nreturn mix(value,1.0,mask);\n}\n#define inline\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\n#endif\nreturn depth>shadow ? darkness : 1.0;\n}\n#define inline\nfloat computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\nfloat visibility=1.;\nvec3 poissonDisk[4];\npoissonDisk[0]=vec3(-1.0,1.0,-1.0);\npoissonDisk[1]=vec3(1.0,-1.0,-1.0);\npoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\npoissonDisk[3]=vec3(1.0,-1.0,1.0);\n\n#ifndef SHADOWFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\n#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\n#endif\nreturn min(1.0,visibility+darkness);\n}\n#define inline\nfloat computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\nreturn esm;\n}\n#define inline\nfloat computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\nreturn esm;\n}\n#if defined(WEBGL2) || defined(WEBGPU)\n#define inline\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nvec3 uvLayer=vec3(uv.x,uv.y,layer);\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\n#else\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\n}\n#endif\n#define inline\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uv));\n#else\nfloat shadow=texture2D(shadowSampler,uv).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\n}\n}\n#define inline\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\nfloat visibility=1.;\nvec2 poissonDisk[4];\npoissonDisk[0]=vec2(-0.94201624,-0.39906216);\npoissonDisk[1]=vec2(0.94558609,-0.76890725);\npoissonDisk[2]=vec2(-0.094184101,-0.92938870);\npoissonDisk[3]=vec2(0.34495938,0.29387760);\n\n#ifndef SHADOWFLOAT\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<shadowPixelDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<shadowPixelDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<shadowPixelDepth) visibility-=0.25;\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<shadowPixelDepth) visibility-=0.25;\n#else\nif (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<shadowPixelDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<shadowPixelDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<shadowPixelDepth) visibility-=0.25;\nif (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<shadowPixelDepth) visibility-=0.25;\n#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\n#else\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\n#else\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#ifdef IS_NDC_HALF_ZRANGE\n#define ZINCLIP clipSpace.z\n#else\n#define ZINCLIP uvDepth.z\n#endif\n#if defined(WEBGL2) || defined(WEBGPU)\n#define GREATEST_LESS_THAN_ONE 0.99999994\n\n#define inline\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\nfloat shadow=texture2D(shadowSampler,uvDepthLayer);\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n\n\n\n#define inline\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\nuv+=0.5;\nvec2 st=fract(uv);\nvec2 base_uv=floor(uv)-0.5;\nbase_uv*=shadowMapSizeAndInverse.y;\n\n\n\n\nvec2 uvw0=3.-2.*st;\nvec2 uvw1=1.+2.*st;\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\nshadow=shadow/16.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n\n\n\n#define inline\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\nuv+=0.5;\nvec2 st=fract(uv);\nvec2 base_uv=floor(uv)-0.5;\nbase_uv*=shadowMapSizeAndInverse.y;\n\n\nvec2 uvw0=4.-3.*st;\nvec2 uvw1=vec2(7.);\nvec2 uvw2=1.+3.*st;\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));\nshadow=shadow/144.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n\n#define inline\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=ZINCLIP;\nfloat shadow=texture2D(shadowSampler,uvDepth);\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n\n\n\n#define inline\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=ZINCLIP;\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\nuv+=0.5;\nvec2 st=fract(uv);\nvec2 base_uv=floor(uv)-0.5;\nbase_uv*=shadowMapSizeAndInverse.y;\n\n\n\n\nvec2 uvw0=3.-2.*st;\nvec2 uvw1=1.+2.*st;\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\nshadow=shadow/16.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n\n\n\n#define inline\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=ZINCLIP;\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x;\nuv+=0.5;\nvec2 st=fract(uv);\nvec2 base_uv=floor(uv)-0.5;\nbase_uv*=shadowMapSizeAndInverse.y;\n\n\nvec2 uvw0=4.-3.*st;\nvec2 uvw1=vec2(7.);\nvec2 uvw2=1.+3.*st;\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z));\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z));\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z));\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z));\nshadow=shadow/144.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\nconst vec3 PoissonSamplers32[64]=vec3[64](\nvec3(0.06407013,0.05409927,0.),\nvec3(0.7366577,0.5789394,0.),\nvec3(-0.6270542,-0.5320278,0.),\nvec3(-0.4096107,0.8411095,0.),\nvec3(0.6849564,-0.4990818,0.),\nvec3(-0.874181,-0.04579735,0.),\nvec3(0.9989998,0.0009880066,0.),\nvec3(-0.004920578,-0.9151649,0.),\nvec3(0.1805763,0.9747483,0.),\nvec3(-0.2138451,0.2635818,0.),\nvec3(0.109845,0.3884785,0.),\nvec3(0.06876755,-0.3581074,0.),\nvec3(0.374073,-0.7661266,0.),\nvec3(0.3079132,-0.1216763,0.),\nvec3(-0.3794335,-0.8271583,0.),\nvec3(-0.203878,-0.07715034,0.),\nvec3(0.5912697,0.1469799,0.),\nvec3(-0.88069,0.3031784,0.),\nvec3(0.5040108,0.8283722,0.),\nvec3(-0.5844124,0.5494877,0.),\nvec3(0.6017799,-0.1726654,0.),\nvec3(-0.5554981,0.1559997,0.),\nvec3(-0.3016369,-0.3900928,0.),\nvec3(-0.5550632,-0.1723762,0.),\nvec3(0.925029,0.2995041,0.),\nvec3(-0.2473137,0.5538505,0.),\nvec3(0.9183037,-0.2862392,0.),\nvec3(0.2469421,0.6718712,0.),\nvec3(0.3916397,-0.4328209,0.),\nvec3(-0.03576927,-0.6220032,0.),\nvec3(-0.04661255,0.7995201,0.),\nvec3(0.4402924,0.3640312,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.)\n);\nconst vec3 PoissonSamplers64[64]=vec3[64](\nvec3(-0.613392,0.617481,0.),\nvec3(0.170019,-0.040254,0.),\nvec3(-0.299417,0.791925,0.),\nvec3(0.645680,0.493210,0.),\nvec3(-0.651784,0.717887,0.),\nvec3(0.421003,0.027070,0.),\nvec3(-0.817194,-0.271096,0.),\nvec3(-0.705374,-0.668203,0.),\nvec3(0.977050,-0.108615,0.),\nvec3(0.063326,0.142369,0.),\nvec3(0.203528,0.214331,0.),\nvec3(-0.667531,0.326090,0.),\nvec3(-0.098422,-0.295755,0.),\nvec3(-0.885922,0.215369,0.),\nvec3(0.566637,0.605213,0.),\nvec3(0.039766,-0.396100,0.),\nvec3(0.751946,0.453352,0.),\nvec3(0.078707,-0.715323,0.),\nvec3(-0.075838,-0.529344,0.),\nvec3(0.724479,-0.580798,0.),\nvec3(0.222999,-0.215125,0.),\nvec3(-0.467574,-0.405438,0.),\nvec3(-0.248268,-0.814753,0.),\nvec3(0.354411,-0.887570,0.),\nvec3(0.175817,0.382366,0.),\nvec3(0.487472,-0.063082,0.),\nvec3(-0.084078,0.898312,0.),\nvec3(0.488876,-0.783441,0.),\nvec3(0.470016,0.217933,0.),\nvec3(-0.696890,-0.549791,0.),\nvec3(-0.149693,0.605762,0.),\nvec3(0.034211,0.979980,0.),\nvec3(0.503098,-0.308878,0.),\nvec3(-0.016205,-0.872921,0.),\nvec3(0.385784,-0.393902,0.),\nvec3(-0.146886,-0.859249,0.),\nvec3(0.643361,0.164098,0.),\nvec3(0.634388,-0.049471,0.),\nvec3(-0.688894,0.007843,0.),\nvec3(0.464034,-0.188818,0.),\nvec3(-0.440840,0.137486,0.),\nvec3(0.364483,0.511704,0.),\nvec3(0.034028,0.325968,0.),\nvec3(0.099094,-0.308023,0.),\nvec3(0.693960,-0.366253,0.),\nvec3(0.678884,-0.204688,0.),\nvec3(0.001801,0.780328,0.),\nvec3(0.145177,-0.898984,0.),\nvec3(0.062655,-0.611866,0.),\nvec3(0.315226,-0.604297,0.),\nvec3(-0.780145,0.486251,0.),\nvec3(-0.371868,0.882138,0.),\nvec3(0.200476,0.494430,0.),\nvec3(-0.494552,-0.711051,0.),\nvec3(0.612476,0.705252,0.),\nvec3(-0.578845,-0.768792,0.),\nvec3(-0.772454,-0.090976,0.),\nvec3(0.504440,0.372295,0.),\nvec3(0.155736,0.065157,0.),\nvec3(0.391522,0.849605,0.),\nvec3(-0.620106,-0.328104,0.),\nvec3(0.789239,-0.419965,0.),\nvec3(-0.545396,0.538133,0.),\nvec3(-0.178564,-0.596057,0.)\n);\n\n\n\n\n\n#define inline\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\nfloat blockerDepth=0.0;\nfloat sumBlockerDepth=0.0;\nfloat numBlocker=0.0;\nfor (int i=0; i<searchTapCount; i ++) {\nblockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;\nif (blockerDepth<depthMetric) {\nsumBlockerDepth+=blockerDepth;\nnumBlocker++;\n}\n}\nif (numBlocker<1.0) {\nreturn 1.0;\n}\nelse\n{\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\n\nfloat AAOffset=shadowMapSizeInverse*10.;\n\n\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);\nvec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);\nfloat random=getRand(vPositionFromLight.xy);\nfloat rotationAngle=random*3.1415926;\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\nfloat shadow=0.;\nfor (int i=0; i<pcfTapCount; i++) {\nvec4 offset=vec4(poissonSamplers[i],0.);\n\noffset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);\nshadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);\n}\nshadow/=float(pcfTapCount);\n\nshadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));\n\nshadow=mix(darkness,1.,shadow);\n\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n\n\n\n\n\n#define inline\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=ZINCLIP;\nfloat blockerDepth=0.0;\nfloat sumBlockerDepth=0.0;\nfloat numBlocker=0.0;\nfor (int i=0; i<searchTapCount; i ++) {\nblockerDepth=texture2D(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy)).r;\nif (blockerDepth<depthMetric) {\nsumBlockerDepth+=blockerDepth;\nnumBlocker++;\n}\n}\nif (numBlocker<1.0) {\nreturn 1.0;\n}\nelse\n{\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\n\nfloat AAOffset=shadowMapSizeInverse*10.;\n\n\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);\nfloat filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;\nfloat random=getRand(vPositionFromLight.xy);\nfloat rotationAngle=random*3.1415926;\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\nfloat shadow=0.;\nfor (int i=0; i<pcfTapCount; i++) {\nvec3 offset=poissonSamplers[i];\n\noffset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);\nshadow+=texture2D(shadowSampler,uvDepth+offset*filterRadius);\n}\nshadow/=float(pcfTapCount);\n\nshadow=mix(shadow,1.,depthMetric-avgBlockerDepth);\n\nshadow=mix(darkness,1.,shadow);\n\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n}\n#define inline\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);\n}\n#define inline\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);\n}\n#define inline\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);\n}\n#define inline\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#define inline\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#define inline\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#endif\n#endif\n";
ShaderStore.IncludesShadersStore[name$A] = shader$A;
var name$z = "samplerFragmentDeclaration";
var shader$z = "#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV == 1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV == 2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV == 3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV == 4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV == 5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV == 6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying vec2 v_VARYINGNAME_UV;\n#endif\nuniform sampler2D _SAMPLERNAME_Sampler;\n#endif\n";
ShaderStore.IncludesShadersStore[name$z] = shader$z;
var name$y = "fresnelFunction";
var shader$y = "#ifdef FRESNEL\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\n{\nfloat fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);\nreturn clamp(fresnelTerm,0.,1.);\n}\n#endif";
ShaderStore.IncludesShadersStore[name$y] = shader$y;
var name$x = "reflectionFunction";
var shader$x = "vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{\nfloat lon=atan(direction.z,direction.x);\nfloat lat=acos(direction.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(s,t,0);\n}\nvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{\nfloat lon=atan(direction.z,direction.x);\nfloat lat=acos(direction.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(1.0-s,t,0);\n}\nvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);\nvec3 r=normalize(reflect(cameraToVertex,worldNormal));\nr=vec3(reflectionMatrix*vec4(r,0));\nfloat lon=atan(r.z,r.x);\nfloat lat=acos(r.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(s,t,0);\n}\nvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\n{\nvec3 viewDir=normalize(vec3(view*worldPos));\nvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\nvec3 r=reflect(viewDir,viewNormal);\nr=vec3(reflectionMatrix*vec4(r,0));\nr.z=r.z-1.0;\nfloat m=2.0*length(r);\nreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\n}\nvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 viewDir=worldPos.xyz-eyePosition;\nvec3 coords=normalize(reflect(viewDir,worldNormal));\nreturn vec3(reflectionMatrix*vec4(coords,1));\n}\nvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\n\nvec3 coords=reflect(viewDir,worldNormal);\ncoords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;\n}\nvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\n{\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\n\nvec3 coords=reflect(viewDir,worldNormal);\ncoords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);\ncoords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;\n}\nvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\n{\nreturn vec3(reflectionMatrix*(view*worldPos));\n}\nvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\n{\nreturn vec3(reflectionMatrix*vec4(positionW,1.));\n}\n#ifdef REFLECTION\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\n{\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\nreturn computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\nreturn computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_PLANAR\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_CUBIC\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\n#else\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3(0,0,0);\n#endif\n}\n#endif";
ShaderStore.IncludesShadersStore[name$x] = shader$x;
var name$w = "imageProcessingDeclaration";
var shader$w = "#ifdef EXPOSURE\nuniform float exposureLinear;\n#endif\n#ifdef CONTRAST\nuniform float contrast;\n#endif\n#ifdef VIGNETTE\nuniform vec2 vInverseScreenSize;\nuniform vec4 vignetteSettings1;\nuniform vec4 vignetteSettings2;\n#endif\n#ifdef COLORCURVES\nuniform vec4 vCameraColorCurveNegative;\nuniform vec4 vCameraColorCurveNeutral;\nuniform vec4 vCameraColorCurvePositive;\n#endif\n#ifdef COLORGRADING\n#ifdef COLORGRADING3D\nuniform highp sampler3D txColorTransform;\n#else\nuniform sampler2D txColorTransform;\n#endif\nuniform vec4 colorTransformSettings;\n#endif";
ShaderStore.IncludesShadersStore[name$w] = shader$w;
var name$v = "imageProcessingFunctions";
var shader$v = "#if defined(COLORGRADING) && !defined(COLORGRADING3D)\n\n#define inline\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\n{\nfloat sliceSize=2.0*sampler3dSetting.x;\n#ifdef SAMPLER3DGREENDEPTH\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\n#else\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\n#endif\nfloat sliceInteger=floor(sliceContinuous);\n\n\nfloat sliceFraction=sliceContinuous-sliceInteger;\n#ifdef SAMPLER3DGREENDEPTH\nvec2 sliceUV=color.rb;\n#else\nvec2 sliceUV=color.rg;\n#endif\nsliceUV.x*=sliceSize;\nsliceUV.x+=sliceInteger*sliceSize;\nsliceUV=saturate(sliceUV);\nvec4 slice0Color=texture2D(colorTransform,sliceUV);\nsliceUV.x+=sliceSize;\nsliceUV=saturate(sliceUV);\nvec4 slice1Color=texture2D(colorTransform,sliceUV);\nvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\n#ifdef SAMPLER3DBGRMAP\ncolor.rgb=result.rgb;\n#else\ncolor.rgb=result.bgr;\n#endif\nreturn color;\n}\n#endif\n#ifdef TONEMAPPING_ACES\n\n\n\n\n\nconst mat3 ACESInputMat=mat3(\nvec3(0.59719,0.07600,0.02840),\nvec3(0.35458,0.90834,0.13383),\nvec3(0.04823,0.01566,0.83777)\n);\n\nconst mat3 ACESOutputMat=mat3(\nvec3( 1.60475,-0.10208,-0.00327),\nvec3(-0.53108,1.10813,-0.07276),\nvec3(-0.07367,-0.00605,1.07602)\n);\nvec3 RRTAndODTFit(vec3 v)\n{\nvec3 a=v*(v+0.0245786)-0.000090537;\nvec3 b=v*(0.983729*v+0.4329510)+0.238081;\nreturn a/b;\n}\nvec3 ACESFitted(vec3 color)\n{\ncolor=ACESInputMat*color;\n\ncolor=RRTAndODTFit(color);\ncolor=ACESOutputMat*color;\n\ncolor=saturate(color);\nreturn color;\n}\n#endif\nvec4 applyImageProcessing(vec4 result) {\n#ifdef EXPOSURE\nresult.rgb*=exposureLinear;\n#endif\n#ifdef VIGNETTE\n\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;\nviewportXY=viewportXY*2.0-1.0;\nvec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);\nfloat vignetteTerm=dot(vignetteXY1,vignetteXY1);\nfloat vignette=pow(vignetteTerm,vignetteSettings2.w);\n\nvec3 vignetteColor=vignetteSettings2.rgb;\n#ifdef VIGNETTEBLENDMODEMULTIPLY\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);\nresult.rgb*=vignetteColorMultiplier;\n#endif\n#ifdef VIGNETTEBLENDMODEOPAQUE\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\n#endif\n#endif\n#ifdef TONEMAPPING\n#ifdef TONEMAPPING_ACES\nresult.rgb=ACESFitted(result.rgb);\n#else\nconst float tonemappingCalibration=1.590579;\nresult.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\n#endif\n#endif\n\nresult.rgb=toGammaSpace(result.rgb);\nresult.rgb=saturate(result.rgb);\n#ifdef CONTRAST\n\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);\nif (contrast<1.0) {\n\nresult.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);\n} else {\n\nresult.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);\n}\n#endif\n\n#ifdef COLORGRADING\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\n#ifdef COLORGRADING3D\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\n#else\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\n#endif\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\n#endif\n#ifdef COLORCURVES\n\nfloat luma=getLuminance(result.rgb);\nvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));\nvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\nresult.rgb*=colorCurve.rgb;\nresult.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\n#endif\nreturn result;\n}";
ShaderStore.IncludesShadersStore[name$v] = shader$v;
var name$u = "bumpFragmentMainFunctions";
var shader$u = "#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\n#if defined(TANGENT) && defined(NORMAL)\nvarying mat3 vTBN;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat4 normalMatrix;\n#endif\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\n{\n#ifdef NORMALXYSCALE\nnormal=normalize(normal*vec3(scale,scale,1.0));\n#endif\nreturn normalize(cotangentFrame*normal);\n}\nvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\n{\nreturn perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);\n}\n\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\n{\n\nvec3 dp1=dFdx(p);\nvec3 dp2=dFdy(p);\nvec2 duv1=dFdx(uv);\nvec2 duv2=dFdy(uv);\n\nvec3 dp2perp=cross(dp2,normal);\nvec3 dp1perp=cross(normal,dp1);\nvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\nvec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;\n\ntangent*=tangentSpaceParams.x;\nbitangent*=tangentSpaceParams.y;\n\nfloat invmax=inversesqrt(max(dot(tangent,tangent),dot(bitangent,bitangent)));\nreturn mat3(tangent*invmax,bitangent*invmax,normal);\n}\n#endif\n";
ShaderStore.IncludesShadersStore[name$u] = shader$u;
var name$t = "bumpFragmentFunctions";
var shader$t = "#if defined(BUMP)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)\n#endif\n#if defined(DETAIL)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)\n#endif\n#if defined(BUMP) && defined(PARALLAX)\nconst float minSamples=4.;\nconst float maxSamples=15.;\nconst int iMaxSamples=15;\n\nvec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {\nfloat parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;\nparallaxLimit*=parallaxScale;\nvec2 vOffsetDir=normalize(vViewDirCoT.xy);\nvec2 vMaxOffset=vOffsetDir*parallaxLimit;\nfloat numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));\nfloat stepSize=1.0/numSamples;\n\nfloat currRayHeight=1.0;\nvec2 vCurrOffset=vec2(0,0);\nvec2 vLastOffset=vec2(0,0);\nfloat lastSampledHeight=1.0;\nfloat currSampledHeight=1.0;\nfor (int i=0; i<iMaxSamples; i++)\n{\ncurrSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;\n\nif (currSampledHeight>currRayHeight)\n{\nfloat delta1=currSampledHeight-currRayHeight;\nfloat delta2=(currRayHeight+stepSize)-lastSampledHeight;\nfloat ratio=delta1/(delta1+delta2);\nvCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;\n\nbreak;\n}\nelse\n{\ncurrRayHeight-=stepSize;\nvLastOffset=vCurrOffset;\nvCurrOffset+=stepSize*vMaxOffset;\nlastSampledHeight=currSampledHeight;\n}\n}\nreturn vCurrOffset;\n}\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\n{\n\nfloat height=texture2D(bumpSampler,vBumpUV).w;\nvec2 texCoordOffset=heightScale*viewDir.xy*height;\nreturn -texCoordOffset;\n}\n#endif\n";
ShaderStore.IncludesShadersStore[name$t] = shader$t;
var name$s = "logDepthDeclaration";
var shader$s = "#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;\nvarying float vFragmentDepth;\n#endif";
ShaderStore.IncludesShadersStore[name$s] = shader$s;
var name$r = "fogFragmentDeclaration";
var shader$r = "#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying vec3 vFogDistance;\nfloat CalcFogFactor()\n{\nfloat fogCoeff=1.0;\nfloat fogStart=vFogInfos.y;\nfloat fogEnd=vFogInfos.z;\nfloat fogDensity=vFogInfos.w;\nfloat fogDistance=length(vFogDistance);\nif (FOGMODE_LINEAR == vFogInfos.x)\n{\nfogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);\n}\nelse if (FOGMODE_EXP == vFogInfos.x)\n{\nfogCoeff=1.0/pow(E,fogDistance*fogDensity);\n}\nelse if (FOGMODE_EXP2 == vFogInfos.x)\n{\nfogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);\n}\nreturn clamp(fogCoeff,0.0,1.0);\n}\n#endif";
ShaderStore.IncludesShadersStore[name$r] = shader$r;
var name$q = "oitFragment";
var shader$q = "#ifdef ORDER_INDEPENDENT_TRANSPARENCY\n\n\n\nfloat fragDepth=gl_FragCoord.z;\n#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS\nuint halfFloat=packHalf2x16(vec2(fragDepth));\nvec2 full=unpackHalf2x16(halfFloat);\nfragDepth=full.x;\n#endif\nivec2 fragCoord=ivec2(gl_FragCoord.xy);\nvec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;\nvec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);\n\n\ndepth.rg=vec2(-MAX_DEPTH);\n\n\nfrontColor=lastFrontColor;\n\nbackColor=vec4(0.0);\n#ifdef USE_REVERSE_DEPTHBUFFER\nfloat furthestDepth=-lastDepth.x;\nfloat nearestDepth=lastDepth.y;\n#else\nfloat nearestDepth=-lastDepth.x;\nfloat furthestDepth=lastDepth.y;\n#endif\n\n\nfloat alphaMultiplier=1.0-lastFrontColor.a;\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth>nearestDepth || fragDepth<furthestDepth) {\n#else\nif (fragDepth<nearestDepth || fragDepth>furthestDepth) {\n#endif\n\nreturn;\n}\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth<nearestDepth && fragDepth>furthestDepth) {\n#else\nif (fragDepth>nearestDepth && fragDepth<furthestDepth) {\n#endif\n\n\n\ndepth.rg=vec2(-fragDepth,fragDepth);\nreturn;\n}\n\n\n\n#endif";
ShaderStore.IncludesShadersStore[name$q] = shader$q;
var name$p = "bumpFragment";
var shader$p = "vec2 uvOffset=vec2(0.0,0.0);\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n#ifdef NORMALXYSCALE\nfloat normalScale=1.0;\n#elif defined(BUMP)\nfloat normalScale=vBumpInfos.y;\n#else\nfloat normalScale=1.0;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#elif defined(BUMP)\n\nvec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\n#else\n\nvec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#elif defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#else\n\nvec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;\nmat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#endif\n#ifdef PARALLAX\nmat3 invTBN=transposeMat3(TBN);\n#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\n#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\n#endif\n#endif\n#ifdef DETAIL\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);\nvec2 detailNormalRG=detailColor.wy*2.0-1.0;\nfloat detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));\nvec3 detailNormal=vec3(detailNormalRG,detailNormalB);\n#endif\n#ifdef BUMP\n#ifdef OBJECTSPACE_NORMALMAP\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz*2.0-1.0);\nnormalW=normalize(mat3(normalMatrix)*normalW);\n#elif !defined(DETAIL)\nnormalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);\n#else\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\n\n#if DETAIL_NORMALBLENDMETHOD == 0\ndetailNormal.xy*=vDetailInfos.z;\nvec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\n#elif DETAIL_NORMALBLENDMETHOD == 1\ndetailNormal.xy*=vDetailInfos.z;\nbumpNormal+=vec3(0.0,0.0,1.0);\ndetailNormal*=vec3(-1.0,-1.0,1.0);\nvec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\n#endif\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\n#endif\n#elif defined(DETAIL)\ndetailNormal.xy*=vDetailInfos.z;\nnormalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\n#endif\n";
ShaderStore.IncludesShadersStore[name$p] = shader$p;
var name$o = "depthPrePass";
var shader$o = "#ifdef DEPTHPREPASS\ngl_FragColor=vec4(0.,0.,0.,1.0);\nreturn;\n#endif";
ShaderStore.IncludesShadersStore[name$o] = shader$o;
var name$n = "lightFragment";
var shader$n = "#ifdef LIGHT{X}\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n\n#else\n#ifdef PBR\n\n#ifdef SPOTLIGHT{X}\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(POINTLIGHT{X})\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(HEMILIGHT{X})\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(DIRLIGHT{X})\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#endif\npreInfo.NdotV=NdotV;\n\n#ifdef SPOTLIGHT{X}\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\npreInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\npreInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\npreInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\npreInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#endif\n#elif defined(POINTLIGHT{X})\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n#endif\n#else\npreInfo.attenuation=1.0;\n#endif\n\n\n#ifdef HEMILIGHT{X}\npreInfo.roughness=roughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n\n#ifdef HEMILIGHT{X}\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n#elif defined(SS_TRANSLUCENCY)\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n#else\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n#endif\n\n#ifdef SPECULARTERM\n#ifdef ANISOTROPIC\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#else\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#endif\n\n#ifdef SHEEN\n#ifdef SHEEN_LINKWITHALBEDO\n\npreInfo.roughness=sheenOut.sheenIntensity;\n#else\n#ifdef HEMILIGHT{X}\npreInfo.roughness=sheenOut.sheenRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#endif\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n\n#ifdef CLEARCOAT\n\n#ifdef HEMILIGHT{X}\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n#ifdef CLEARCOAT_TINT\n\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);\ninfo.diffuse*=absorption;\n#ifdef SPECULARTERM\ninfo.specular*=absorption;\n#endif\n#endif\n\ninfo.diffuse*=info.clearCoat.w;\n#ifdef SPECULARTERM\ninfo.specular*=info.clearCoat.w;\n#endif\n#ifdef SHEEN\ninfo.sheen*=info.clearCoat.w;\n#endif\n#endif\n#else\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#elif defined(HEMILIGHT{X})\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#endif\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\n#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++)\n{\n#ifdef SHADOWCSM_RIGHTHANDED{X}\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\n#else\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\n#endif\nif (diff{X}>=0.) {\nindex{X}=i;\nbreak;\n}\n}\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nif (index{X}>=0)\n#endif\n{\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n#endif\n#ifndef SHADOWCSMNOBLEND{X}\nfloat frustumLength=frustumLengths{X}[index{X}];\nfloat diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};\nif (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n{\nindex{X}+=1;\nfloat nextShadow=0.;\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\nshadow=mix(nextShadow,shadow,diffRatio);\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n#endif\n}\n#endif\n}\n#elif defined(SHADOWCLOSEESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPOISSON{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#else\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#endif\n#ifdef SHADOWONLY\n#ifndef SHADOWINUSE\n#define SHADOWINUSE\n#endif\nglobalShadow+=shadow;\nshadowLightCount+=1.0;\n#endif\n#else\nshadow=1.;\n#endif\n#ifndef SHADOWONLY\n#ifdef CUSTOMUSERLIGHTING\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n#ifdef SPECULARTERM\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n#endif\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor.rgb*shadow;\n#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifndef LIGHTMAPNOSPECULAR{X}\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef SHEEN\n#ifndef LIGHTMAPNOSPECULAR{X}\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#else\n#ifdef SHADOWCSMDEBUG{X}\ndiffuseBase+=info.diffuse*shadowDebug{X};\n#else\ndiffuseBase+=info.diffuse*shadow;\n#endif\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\n#endif\n#ifdef CLEARCOAT\nclearCoatBase+=info.clearCoat.rgb*shadow;\n#endif\n#ifdef SHEEN\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$n] = shader$n;
var name$m = "logDepthFragment";
var shader$m = "#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif";
ShaderStore.IncludesShadersStore[name$m] = shader$m;
var name$l = "fogFragment";
var shader$l = "#ifdef FOG\nfloat fog=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor.rgb=mix(vFogColor,color.rgb,fog);\n#endif";
ShaderStore.IncludesShadersStore[name$l] = shader$l;
var name$k = "defaultPixelShader";
var shader$k = "#include<__decl__defaultFragment>\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n\n#define RECIPROCAL_PI2 0.15915494\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#ifdef REFRACTION\n#ifdef REFRACTIONMAP_3D\nuniform samplerCube refractionCubeSampler;\n#else\nuniform sampler2D refraction2DSampler;\n#endif\n#endif\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n\n#include<fresnelFunction>\n\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\n#else\nuniform sampler2D reflection2DSampler;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<oitFragment>\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n\nvec4 baseColor=vec4(1.,1.,1.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\n\nfloat alpha=vDiffuseColor.a;\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\n#endif\n#include<bumpFragment>\n#ifdef TWOSIDEDLIGHTING\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\nif (baseColor.a<alphaCutOff)\ndiscard;\n#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef DETAIL\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\n\nvec3 baseAmbientColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\nvec3 specularColor=vSpecularColor.rgb;\n#ifdef SPECULAR\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\nspecularColor=specularMapColor.rgb;\n#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\n#endif\n#endif\n#else\nfloat glossiness=0.;\n#endif\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\nfloat shadow=1.;\n#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\n\nvec4 refractionColor=vec4(0.,0.,0.,1.);\n#ifdef REFRACTION\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\n#ifdef REFRACTIONMAP_3D\n#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\nif (dot(refractionVector,viewDirectionW)<1.0) {\nrefractionColor=textureCube(refractionCubeSampler,refractionVector);\n}\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\nrefractionCoords.y=1.0-refractionCoords.y;\nrefractionColor=texture2D(refraction2DSampler,refractionCoords);\n#endif\n#ifdef RGBDREFRACTION\nrefractionColor.rgb=fromRGBD(refractionColor);\n#endif\n#ifdef IS_REFRACTION_LINEAR\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\n#endif\nrefractionColor.rgb*=vRefractionInfos.x;\n#endif\n\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\n#ifdef REFLECTION\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nvReflectionUVW.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nfloat bias=vReflectionInfos.y;\n#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\n#endif\n#endif\n#endif\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\n#else\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\n#endif\n#else\nvec2 coords=vReflectionUVW.xy;\n#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\n#endif\ncoords.y=1.0-coords.y;\nreflectionColor=texture2D(reflection2DSampler,coords);\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\n#endif\n#ifdef IS_REFLECTION_LINEAR\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\n#endif\nreflectionColor.rgb*=vReflectionInfos.x;\n#ifdef REFLECTIONFRESNEL\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\n#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);\nrefractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#ifdef OPACITYRGB\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\nalpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\n#else\nalpha*=opacityMap.a*vOpacityInfos.y;\n#endif\n#endif\n#ifdef VERTEXALPHA\nalpha*=vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\nalpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\n#endif\n#ifdef ALPHATEST\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\nif (alpha<alphaCutOff)\ndiscard;\n#endif\n#ifndef ALPHABLEND\n\nalpha=1.0;\n#endif\n#endif\n\nvec3 emissiveColor=vEmissiveColor;\n#ifdef EMISSIVE\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\n#endif\n#ifdef EMISSIVEFRESNEL\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\nemissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\n#endif\n\n#ifdef DIFFUSEFRESNEL\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);\ndiffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\n#endif\n\n#ifdef EMISSIVEASILLUMINATION\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#endif\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n\n#ifdef EMISSIVEASILLUMINATION\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\n#else\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\n#endif\n\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor.rgb*=lightmapColor.rgb;\n#else\ncolor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb=max(color.rgb,0.);\n#include<logDepthFragment>\n#include<fogFragment>\n\n\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\n#else\n#ifdef IMAGEPROCESSING\ncolor.rgb=toLinearSpace(color.rgb);\ncolor=applyImageProcessing(color);\n#endif\n#endif\ncolor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\n\ncolor.rgb*=color.a;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;\ngl_FragData[0]=color;\n#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\nvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\nvec2 velocity=abs(a-b);\nvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\ngl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_IRRADIANCE\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_NORMAL\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4((view*vec4(normalW,0.0)).rgb,writeGeometryInfo);\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(SPECULAR)\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularMapColor.rgb,specularMapColor.a*writeGeometryInfo);\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo);\n#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=color;\n#endif\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth == nearestDepth) {\nfrontColor.rgb+=color.rgb*color.a*alphaMultiplier;\nfrontColor.a=1.0-alphaMultiplier*(1.0-color.a);\n} else {\nbackColor+=color;\n}\n#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n";
ShaderStore.ShadersStore[name$k] = shader$k;
var name$j = "defaultVertexDeclaration";
var shader$j = "\nuniform mat4 viewProjection;\nuniform mat4 view;\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\nuniform mat4 lightmapMatrix;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n#ifdef REFLECTION\nuniform mat4 reflectionMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\nuniform mat4 detailMatrix;\n#endif\n#define ADDITIONAL_VERTEX_DECLARATION\n";
ShaderStore.IncludesShadersStore[name$j] = shader$j;
var name$i = "uvAttributeDeclaration";
var shader$i = "#ifdef UV{X}\nattribute vec2 uv{X};\n#endif\n";
ShaderStore.IncludesShadersStore[name$i] = shader$i;
var name$h = "prePassVertexDeclaration";
var shader$h = "#ifdef PREPASS\n#ifdef PREPASS_DEPTH\nvarying vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nuniform mat4 previousViewProjection;\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$h] = shader$h;
var name$g = "samplerVertexDeclaration";
var shader$g = "#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV == 0\nvarying vec2 v_VARYINGNAME_UV;\n#endif\n";
ShaderStore.IncludesShadersStore[name$g] = shader$g;
var name$f = "bumpVertexDeclaration";
var shader$f = "#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvarying mat3 vTBN;\n#endif\n#endif\n";
ShaderStore.IncludesShadersStore[name$f] = shader$f;
var name$e = "fogVertexDeclaration";
var shader$e = "#ifdef FOG\nvarying vec3 vFogDistance;\n#endif";
ShaderStore.IncludesShadersStore[name$e] = shader$e;
var name$d = "lightVxFragmentDeclaration";
var shader$d = "#ifdef LIGHT{X}\nuniform vec4 vLightData{X};\nuniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\nuniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};\nuniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};\nuniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$d] = shader$d;
var name$c = "lightVxUboDeclaration";
var shader$c = "#ifdef LIGHT{X}\nuniform Light{X}\n{\nvec4 vLightData;\nvec4 vLightDiffuse;\nvec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;\nvec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;\nvec2 depthValues;\n} light{X};\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\nuniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$c] = shader$c;
var name$b = "prePassVertex";
var shader$b = "#ifdef PREPASS_DEPTH\nvViewPos=(view*worldPos).rgb;\n#endif\n#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*worldPos;\n#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;\npreviousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);\n#else\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#endif\n";
ShaderStore.IncludesShadersStore[name$b] = shader$b;
var name$a = "uvVariableDeclaration";
var shader$a = "#if !defined(UV{X}) && defined(MAINUV{X})\nvec2 uv{X}=vec2(0.,0.);\n#endif\n#ifdef MAINUV{X}\nvMainUV{X}=uv{X};\n#endif\n";
ShaderStore.IncludesShadersStore[name$a] = shader$a;
var name$9 = "samplerVertexImplementation";
var shader$9 = "#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV == 0\nif (v_INFONAME_ == 0.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));\n}\n#ifdef UV2\nelse if (v_INFONAME_ == 1.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef UV3\nelse if (v_INFONAME_ == 2.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));\n}\n#endif\n#ifdef UV4\nelse if (v_INFONAME_ == 3.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));\n}\n#endif\n#ifdef UV5\nelse if (v_INFONAME_ == 4.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));\n}\n#endif\n#ifdef UV6\nelse if (v_INFONAME_ == 5.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));\n}\n#endif\n#endif\n";
ShaderStore.IncludesShadersStore[name$9] = shader$9;
var name$8 = "bumpVertex";
var shader$8 = "#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvec3 tbnNormal=normalize(normalUpdated);\nvec3 tbnTangent=normalize(tangentUpdated.xyz);\nvec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;\nvTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$8] = shader$8;
var name$7 = "fogVertex";
var shader$7 = "#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif";
ShaderStore.IncludesShadersStore[name$7] = shader$7;
var name$6 = "shadowsVertex";
var shader$6 = "#ifdef SHADOWS\n#if defined(SHADOWCSM{X})\nvPositionFromCamera{X}=view*worldPos;\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {\nvPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n}\n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n#endif\n#endif";
ShaderStore.IncludesShadersStore[name$6] = shader$6;
var name$5 = "pointCloudVertex";
var shader$5 = "#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif";
ShaderStore.IncludesShadersStore[name$5] = shader$5;
var name$4 = "logDepthVertex";
var shader$4 = "#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;\ngl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif";
ShaderStore.IncludesShadersStore[name$4] = shader$4;
var name$3 = "defaultVertexShader";
var shader$3 = "#include<__decl__defaultVertex>\n\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<mainUVVaryingDeclaration>[1..7]\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#if defined(SPECULARTERM)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\n\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\nvNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR == 0u) {\ngl_Position=viewProjection*worldPos;\n} else {\ngl_Position=viewProjectionR*worldPos;\n}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\nvPositionW=vec3(worldPos);\n#include<prePassVertex>\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#if defined(SPECULARTERM)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n#endif\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#ifdef VERTEXCOLOR\nvColor=color;\n#elif INSTANCESCOLOR\nvColor=instanceColor;\n#endif\n#include<pointCloudVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n";
ShaderStore.ShadersStore[name$3] = shader$3;
var MaterialPluginManager = function() {
  function MaterialPluginManager2(material) {
    this._plugins = [];
    this._activePlugins = [];
    this._activePluginsForExtraEvents = [];
    this._material = material;
    this._scene = material.getScene();
    this._engine = this._scene.getEngine();
  }
  MaterialPluginManager2.prototype._addPlugin = function(plugin) {
    for (var i = 0; i < this._plugins.length; ++i) {
      if (this._plugins[i].name === plugin.name) {
        throw 'Plugin "'.concat(plugin.name, '" already added to the material "').concat(this._material.name, '"!');
      }
    }
    if (this._material._uniformBufferLayoutBuilt) {
      throw 'The plugin "'.concat(plugin.name, `" can't be added to the material "`).concat(this._material.name, '" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.');
    }
    this._material._callbackPluginEventGeneric = this._handlePluginEvent.bind(this);
    this._plugins.push(plugin);
    this._plugins.sort(function(a, b) {
      return a.priority - b.priority;
    });
    this._codeInjectionPoints = {};
    var defineNamesFromPlugins = {};
    for (var _i = 0, _a = this._plugins; _i < _a.length; _i++) {
      var plugin_1 = _a[_i];
      plugin_1.collectDefines(defineNamesFromPlugins);
      this._collectPointNames("vertex", plugin_1.getCustomCode("vertex"));
      this._collectPointNames("fragment", plugin_1.getCustomCode("fragment"));
    }
    if (Object.keys(defineNamesFromPlugins).length > 0) {
      this._defineNamesFromPlugins = defineNamesFromPlugins;
    } else {
      delete this._defineNamesFromPlugins;
    }
  };
  MaterialPluginManager2.prototype._activatePlugin = function(plugin) {
    if (this._activePlugins.indexOf(plugin) === -1) {
      this._activePlugins.push(plugin);
      this._activePlugins.sort(function(a, b) {
        return a.priority - b.priority;
      });
      this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);
      this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);
      this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);
      if (plugin.registerForExtraEvents) {
        this._activePluginsForExtraEvents.push(plugin);
        this._activePluginsForExtraEvents.sort(function(a, b) {
          return a.priority - b.priority;
        });
        this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);
        this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);
        this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);
      }
    }
  };
  MaterialPluginManager2.prototype.getPlugin = function(name2) {
    for (var i = 0; i < this._plugins.length; ++i) {
      if (this._plugins[i].name === name2) {
        return this._plugins[i];
      }
    }
    return null;
  };
  MaterialPluginManager2.prototype._handlePluginEventIsReadyForSubMesh = function(eventData) {
    var isReady = true;
    for (var _i = 0, _a = this._activePlugins; _i < _a.length; _i++) {
      var plugin = _a[_i];
      isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);
    }
    eventData.isReadyForSubMesh = isReady;
  };
  MaterialPluginManager2.prototype._handlePluginEventPrepareDefines = function(eventData) {
    for (var _i = 0, _a = this._activePlugins; _i < _a.length; _i++) {
      var plugin = _a[_i];
      plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);
    }
  };
  MaterialPluginManager2.prototype._handlePluginEventHardBindForSubMesh = function(eventData) {
    for (var _i = 0, _a = this._activePluginsForExtraEvents; _i < _a.length; _i++) {
      var plugin = _a[_i];
      plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
    }
  };
  MaterialPluginManager2.prototype._handlePluginEventBindForSubMesh = function(eventData) {
    for (var _i = 0, _a = this._activePlugins; _i < _a.length; _i++) {
      var plugin = _a[_i];
      plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
    }
  };
  MaterialPluginManager2.prototype._handlePluginEventHasRenderTargetTextures = function(eventData) {
    var hasRenderTargetTextures = false;
    for (var _i = 0, _a = this._activePluginsForExtraEvents; _i < _a.length; _i++) {
      var plugin = _a[_i];
      hasRenderTargetTextures = plugin.hasRenderTargetTextures();
      if (hasRenderTargetTextures) {
        break;
      }
    }
    eventData.hasRenderTargetTextures = hasRenderTargetTextures;
  };
  MaterialPluginManager2.prototype._handlePluginEventFillRenderTargetTextures = function(eventData) {
    for (var _i = 0, _a = this._activePluginsForExtraEvents; _i < _a.length; _i++) {
      var plugin = _a[_i];
      plugin.fillRenderTargetTextures(eventData.renderTargets);
    }
  };
  MaterialPluginManager2.prototype._handlePluginEvent = function(id, info) {
    var _a, _b, _c;
    switch (id) {
      case MaterialPluginEvent.GetActiveTextures: {
        var eventData = info;
        for (var _i = 0, _d = this._activePlugins; _i < _d.length; _i++) {
          var plugin = _d[_i];
          plugin.getActiveTextures(eventData.activeTextures);
        }
        break;
      }
      case MaterialPluginEvent.GetAnimatables: {
        var eventData = info;
        for (var _e = 0, _f = this._activePlugins; _e < _f.length; _e++) {
          var plugin = _f[_e];
          plugin.getAnimatables(eventData.animatables);
        }
        break;
      }
      case MaterialPluginEvent.HasTexture: {
        var eventData = info;
        var hasTexture = false;
        for (var _g = 0, _h = this._activePlugins; _g < _h.length; _g++) {
          var plugin = _h[_g];
          hasTexture = plugin.hasTexture(eventData.texture);
          if (hasTexture) {
            break;
          }
        }
        eventData.hasTexture = hasTexture;
        break;
      }
      case MaterialPluginEvent.Disposed: {
        var eventData = info;
        for (var _j = 0, _k = this._plugins; _j < _k.length; _j++) {
          var plugin = _k[_j];
          plugin.dispose(eventData.forceDisposeTextures);
        }
        break;
      }
      case MaterialPluginEvent.GetDefineNames: {
        var eventData = info;
        eventData.defineNames = this._defineNamesFromPlugins;
        break;
      }
      case MaterialPluginEvent.PrepareEffect: {
        var eventData = info;
        for (var _l = 0, _m = this._activePlugins; _l < _m.length; _l++) {
          var plugin = _m[_l];
          eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);
        }
        if (this._uniformList.length > 0) {
          (_a = eventData.uniforms).push.apply(_a, this._uniformList);
        }
        if (this._samplerList.length > 0) {
          (_b = eventData.samplers).push.apply(_b, this._samplerList);
        }
        if (this._uboList.length > 0) {
          (_c = eventData.uniformBuffersNames).push.apply(_c, this._uboList);
        }
        eventData.customCode = this._injectCustomCode(eventData.customCode);
        break;
      }
      case MaterialPluginEvent.PrepareUniformBuffer: {
        var eventData = info;
        this._uboDeclaration = "";
        this._vertexDeclaration = "";
        this._fragmentDeclaration = "";
        this._uniformList = [];
        this._samplerList = [];
        this._uboList = [];
        for (var _o = 0, _p = this._plugins; _o < _p.length; _o++) {
          var plugin = _p[_o];
          var uniforms = plugin.getUniforms();
          if (uniforms) {
            if (uniforms.ubo) {
              for (var _q = 0, _r = uniforms.ubo; _q < _r.length; _q++) {
                var uniform = _r[_q];
                eventData.ubo.addUniform(uniform.name, uniform.size);
                this._uboDeclaration += "".concat(uniform.type, " ").concat(uniform.name, ";\r\n");
                this._uniformList.push(uniform.name);
              }
            }
            if (uniforms.vertex) {
              this._vertexDeclaration += uniforms.vertex + "\r\n";
            }
            if (uniforms.fragment) {
              this._fragmentDeclaration += uniforms.fragment + "\r\n";
            }
          }
          plugin.getSamplers(this._samplerList);
          plugin.getUniformBuffersNames(this._uboList);
        }
        break;
      }
    }
  };
  MaterialPluginManager2.prototype._collectPointNames = function(shaderType, customCode) {
    if (!customCode) {
      return;
    }
    for (var pointName in customCode) {
      if (!this._codeInjectionPoints[shaderType]) {
        this._codeInjectionPoints[shaderType] = {};
      }
      this._codeInjectionPoints[shaderType][pointName] = true;
    }
  };
  MaterialPluginManager2.prototype._injectCustomCode = function(existingCallback) {
    var _this = this;
    return function(shaderType, code) {
      var _a;
      if (existingCallback) {
        code = existingCallback(shaderType, code);
      }
      if (_this._uboDeclaration) {
        code = code.replace("#define ADDITIONAL_UBO_DECLARATION", _this._uboDeclaration);
      }
      if (_this._vertexDeclaration) {
        code = code.replace("#define ADDITIONAL_VERTEX_DECLARATION", _this._vertexDeclaration);
      }
      if (_this._fragmentDeclaration) {
        code = code.replace("#define ADDITIONAL_FRAGMENT_DECLARATION", _this._fragmentDeclaration);
      }
      var points = (_a = _this._codeInjectionPoints) === null || _a === void 0 ? void 0 : _a[shaderType];
      if (!points) {
        return code;
      }
      for (var pointName in points) {
        var injectedCode = "";
        for (var _i = 0, _b = _this._activePlugins; _i < _b.length; _i++) {
          var plugin = _b[_i];
          var customCode = plugin.getCustomCode(shaderType);
          if (customCode === null || customCode === void 0 ? void 0 : customCode[pointName]) {
            injectedCode += customCode[pointName] + "\r\n";
          }
        }
        if (injectedCode.length > 0) {
          if (pointName.charAt(0) === "!") {
            var rx = new RegExp(pointName.substring(1), "g");
            var match = rx.exec(code);
            while (match !== null) {
              code = code.replace(match[0], injectedCode);
              match = rx.exec(code);
            }
          } else {
            var fullPointName = "#define " + pointName;
            code = code.replace(fullPointName, "\r\n" + injectedCode + "\r\n" + fullPointName);
          }
        }
      }
      return code;
    };
  };
  return MaterialPluginManager2;
}();
var MaterialPluginBase = function() {
  function MaterialPluginBase2(material, name2, priority, defines, addToPluginList, enable) {
    if (addToPluginList === void 0) {
      addToPluginList = true;
    }
    if (enable === void 0) {
      enable = false;
    }
    this.priority = 500;
    this.registerForExtraEvents = false;
    this._material = material;
    this.name = name2;
    this.priority = priority;
    if (!material.pluginManager) {
      material.pluginManager = new MaterialPluginManager(material);
    }
    this._pluginDefineNames = defines;
    this._pluginManager = material.pluginManager;
    if (addToPluginList) {
      this._pluginManager._addPlugin(this);
    }
    if (enable) {
      this._enable(true);
    }
    this.markAllDefinesAsDirty = material._dirtyCallbacks[63];
  }
  MaterialPluginBase2.prototype._enable = function(enable) {
    if (enable) {
      this._pluginManager._activatePlugin(this);
    }
  };
  MaterialPluginBase2.prototype.getClassName = function() {
    return "MaterialPluginBase";
  };
  MaterialPluginBase2.prototype.isReadyForSubMesh = function(defines, scene, engine, subMesh) {
    return true;
  };
  MaterialPluginBase2.prototype.hardBindForSubMesh = function(uniformBuffer, scene, engine, subMesh) {
  };
  MaterialPluginBase2.prototype.bindForSubMesh = function(uniformBuffer, scene, engine, subMesh) {
  };
  MaterialPluginBase2.prototype.dispose = function(forceDisposeTextures) {
  };
  MaterialPluginBase2.prototype.getCustomCode = function(shaderType) {
    return null;
  };
  MaterialPluginBase2.prototype.collectDefines = function(defines) {
    if (!this._pluginDefineNames) {
      return;
    }
    for (var _i = 0, _a = Object.keys(this._pluginDefineNames); _i < _a.length; _i++) {
      var key = _a[_i];
      if (key[0] === "_") {
        continue;
      }
      var type = typeof this._pluginDefineNames[key];
      defines[key] = {
        type: type === "number" ? "number" : type === "string" ? "string" : type === "boolean" ? "boolean" : "object",
        default: this._pluginDefineNames[key]
      };
    }
  };
  MaterialPluginBase2.prototype.prepareDefines = function(defines, scene, mesh) {
  };
  MaterialPluginBase2.prototype.hasTexture = function(texture) {
    return false;
  };
  MaterialPluginBase2.prototype.hasRenderTargetTextures = function() {
    return false;
  };
  MaterialPluginBase2.prototype.fillRenderTargetTextures = function(renderTargets) {
  };
  MaterialPluginBase2.prototype.getActiveTextures = function(activeTextures) {
  };
  MaterialPluginBase2.prototype.getAnimatables = function(animatables) {
  };
  MaterialPluginBase2.prototype.addFallbacks = function(defines, fallbacks, currentRank) {
    return currentRank;
  };
  MaterialPluginBase2.prototype.getSamplers = function(samplers) {
  };
  MaterialPluginBase2.prototype.getUniformBuffersNames = function(ubos) {
  };
  MaterialPluginBase2.prototype.getUniforms = function() {
    return {};
  };
  MaterialPluginBase2.prototype.copyTo = function(plugin) {
    SerializationHelper.Clone(function() {
      return plugin;
    }, this);
  };
  MaterialPluginBase2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  MaterialPluginBase2.prototype.parse = function(source, scene, rootUrl) {
    var _this = this;
    SerializationHelper.Parse(function() {
      return _this;
    }, source, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], MaterialPluginBase2.prototype, "name", void 0);
  __decorate([
    serialize()
  ], MaterialPluginBase2.prototype, "priority", void 0);
  __decorate([
    serialize()
  ], MaterialPluginBase2.prototype, "registerForExtraEvents", void 0);
  return MaterialPluginBase2;
}();
var MaterialDetailMapDefines = function(_super) {
  __extends(MaterialDetailMapDefines2, _super);
  function MaterialDetailMapDefines2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.DETAIL = false;
    _this.DETAILDIRECTUV = 0;
    _this.DETAIL_NORMALBLENDMETHOD = 0;
    return _this;
  }
  return MaterialDetailMapDefines2;
}(MaterialDefines);
var DetailMapConfiguration = function(_super) {
  __extends(DetailMapConfiguration2, _super);
  function DetailMapConfiguration2(material, addToPluginList) {
    if (addToPluginList === void 0) {
      addToPluginList = true;
    }
    var _this = _super.call(this, material, "DetailMap", 140, new MaterialDetailMapDefines(), addToPluginList) || this;
    _this._texture = null;
    _this.diffuseBlendLevel = 1;
    _this.roughnessBlendLevel = 1;
    _this.bumpLevel = 1;
    _this._normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;
    _this._isEnabled = false;
    _this.isEnabled = false;
    _this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
    return _this;
  }
  DetailMapConfiguration2.prototype._markAllSubMeshesAsTexturesDirty = function() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  };
  DetailMapConfiguration2.prototype.isReadyForSubMesh = function(defines, scene, engine) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty && scene.texturesEnabled) {
      if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {
        if (!this._texture.isReady()) {
          return false;
        }
      }
    }
    return true;
  };
  DetailMapConfiguration2.prototype.prepareDefines = function(defines, scene, mesh) {
    if (this._isEnabled) {
      defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
      var engine = scene.getEngine();
      if (defines._areTexturesDirty) {
        if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {
          MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "DETAIL");
          defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
        } else {
          defines.DETAIL = false;
        }
      }
    } else {
      defines.DETAIL = false;
    }
  };
  DetailMapConfiguration2.prototype.bindForSubMesh = function(uniformBuffer, scene, engine, subMesh) {
    if (!this._isEnabled) {
      return;
    }
    var isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._texture && MaterialFlags.DetailTextureEnabled) {
        uniformBuffer.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);
        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "detail");
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.DetailTextureEnabled) {
        uniformBuffer.setTexture("detailSampler", this._texture);
      }
    }
  };
  DetailMapConfiguration2.prototype.hasTexture = function(texture) {
    if (this._texture === texture) {
      return true;
    }
    return false;
  };
  DetailMapConfiguration2.prototype.getActiveTextures = function(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
  };
  DetailMapConfiguration2.prototype.getAnimatables = function(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
  };
  DetailMapConfiguration2.prototype.dispose = function(forceDisposeTextures) {
    var _a;
    if (forceDisposeTextures) {
      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
    }
  };
  DetailMapConfiguration2.prototype.getClassName = function() {
    return "DetailMapConfiguration";
  };
  DetailMapConfiguration2.prototype.getSamplers = function(samplers) {
    samplers.push("detailSampler");
  };
  DetailMapConfiguration2.prototype.getUniforms = function() {
    return {
      ubo: [
        { name: "vDetailInfos", size: 4, type: "vec4" },
        { name: "detailMatrix", size: 16, type: "mat4" }
      ]
    };
  };
  __decorate([
    serializeAsTexture("detailTexture"),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], DetailMapConfiguration2.prototype, "texture", void 0);
  __decorate([
    serialize()
  ], DetailMapConfiguration2.prototype, "diffuseBlendLevel", void 0);
  __decorate([
    serialize()
  ], DetailMapConfiguration2.prototype, "roughnessBlendLevel", void 0);
  __decorate([
    serialize()
  ], DetailMapConfiguration2.prototype, "bumpLevel", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], DetailMapConfiguration2.prototype, "normalBlendMethod", void 0);
  __decorate([
    serialize(),
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], DetailMapConfiguration2.prototype, "isEnabled", void 0);
  return DetailMapConfiguration2;
}(MaterialPluginBase);
var onCreatedEffectParameters = { effect: null, subMesh: null };
var StandardMaterialDefines = function(_super) {
  __extends(StandardMaterialDefines2, _super);
  function StandardMaterialDefines2(externalProperties) {
    var _this = _super.call(this, externalProperties) || this;
    _this.MAINUV1 = false;
    _this.MAINUV2 = false;
    _this.MAINUV3 = false;
    _this.MAINUV4 = false;
    _this.MAINUV5 = false;
    _this.MAINUV6 = false;
    _this.DIFFUSE = false;
    _this.DIFFUSEDIRECTUV = 0;
    _this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
    _this.AMBIENT = false;
    _this.AMBIENTDIRECTUV = 0;
    _this.OPACITY = false;
    _this.OPACITYDIRECTUV = 0;
    _this.OPACITYRGB = false;
    _this.REFLECTION = false;
    _this.EMISSIVE = false;
    _this.EMISSIVEDIRECTUV = 0;
    _this.SPECULAR = false;
    _this.SPECULARDIRECTUV = 0;
    _this.BUMP = false;
    _this.BUMPDIRECTUV = 0;
    _this.PARALLAX = false;
    _this.PARALLAXOCCLUSION = false;
    _this.SPECULAROVERALPHA = false;
    _this.CLIPPLANE = false;
    _this.CLIPPLANE2 = false;
    _this.CLIPPLANE3 = false;
    _this.CLIPPLANE4 = false;
    _this.CLIPPLANE5 = false;
    _this.CLIPPLANE6 = false;
    _this.ALPHATEST = false;
    _this.DEPTHPREPASS = false;
    _this.ALPHAFROMDIFFUSE = false;
    _this.POINTSIZE = false;
    _this.FOG = false;
    _this.SPECULARTERM = false;
    _this.DIFFUSEFRESNEL = false;
    _this.OPACITYFRESNEL = false;
    _this.REFLECTIONFRESNEL = false;
    _this.REFRACTIONFRESNEL = false;
    _this.EMISSIVEFRESNEL = false;
    _this.FRESNEL = false;
    _this.NORMAL = false;
    _this.TANGENT = false;
    _this.UV1 = false;
    _this.UV2 = false;
    _this.UV3 = false;
    _this.UV4 = false;
    _this.UV5 = false;
    _this.UV6 = false;
    _this.VERTEXCOLOR = false;
    _this.VERTEXALPHA = false;
    _this.NUM_BONE_INFLUENCERS = 0;
    _this.BonesPerMesh = 0;
    _this.BONETEXTURE = false;
    _this.BONES_VELOCITY_ENABLED = false;
    _this.INSTANCES = false;
    _this.THIN_INSTANCES = false;
    _this.INSTANCESCOLOR = false;
    _this.GLOSSINESS = false;
    _this.ROUGHNESS = false;
    _this.EMISSIVEASILLUMINATION = false;
    _this.LINKEMISSIVEWITHDIFFUSE = false;
    _this.REFLECTIONFRESNELFROMSPECULAR = false;
    _this.LIGHTMAP = false;
    _this.LIGHTMAPDIRECTUV = 0;
    _this.OBJECTSPACE_NORMALMAP = false;
    _this.USELIGHTMAPASSHADOWMAP = false;
    _this.REFLECTIONMAP_3D = false;
    _this.REFLECTIONMAP_SPHERICAL = false;
    _this.REFLECTIONMAP_PLANAR = false;
    _this.REFLECTIONMAP_CUBIC = false;
    _this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
    _this.USE_LOCAL_REFRACTIONMAP_CUBIC = false;
    _this.REFLECTIONMAP_PROJECTION = false;
    _this.REFLECTIONMAP_SKYBOX = false;
    _this.REFLECTIONMAP_EXPLICIT = false;
    _this.REFLECTIONMAP_EQUIRECTANGULAR = false;
    _this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    _this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    _this.REFLECTIONMAP_OPPOSITEZ = false;
    _this.INVERTCUBICMAP = false;
    _this.LOGARITHMICDEPTH = false;
    _this.REFRACTION = false;
    _this.REFRACTIONMAP_3D = false;
    _this.REFLECTIONOVERALPHA = false;
    _this.TWOSIDEDLIGHTING = false;
    _this.SHADOWFLOAT = false;
    _this.MORPHTARGETS = false;
    _this.MORPHTARGETS_NORMAL = false;
    _this.MORPHTARGETS_TANGENT = false;
    _this.MORPHTARGETS_UV = false;
    _this.NUM_MORPH_INFLUENCERS = 0;
    _this.MORPHTARGETS_TEXTURE = false;
    _this.NONUNIFORMSCALING = false;
    _this.PREMULTIPLYALPHA = false;
    _this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;
    _this.ALPHABLEND = true;
    _this.PREPASS = false;
    _this.PREPASS_IRRADIANCE = false;
    _this.PREPASS_IRRADIANCE_INDEX = -1;
    _this.PREPASS_ALBEDO_SQRT = false;
    _this.PREPASS_ALBEDO_SQRT_INDEX = -1;
    _this.PREPASS_DEPTH = false;
    _this.PREPASS_DEPTH_INDEX = -1;
    _this.PREPASS_NORMAL = false;
    _this.PREPASS_NORMAL_INDEX = -1;
    _this.PREPASS_POSITION = false;
    _this.PREPASS_POSITION_INDEX = -1;
    _this.PREPASS_VELOCITY = false;
    _this.PREPASS_VELOCITY_INDEX = -1;
    _this.PREPASS_REFLECTIVITY = false;
    _this.PREPASS_REFLECTIVITY_INDEX = -1;
    _this.SCENE_MRT_COUNT = 0;
    _this.RGBDLIGHTMAP = false;
    _this.RGBDREFLECTION = false;
    _this.RGBDREFRACTION = false;
    _this.IMAGEPROCESSING = false;
    _this.VIGNETTE = false;
    _this.VIGNETTEBLENDMODEMULTIPLY = false;
    _this.VIGNETTEBLENDMODEOPAQUE = false;
    _this.TONEMAPPING = false;
    _this.TONEMAPPING_ACES = false;
    _this.CONTRAST = false;
    _this.COLORCURVES = false;
    _this.COLORGRADING = false;
    _this.COLORGRADING3D = false;
    _this.SAMPLER3DGREENDEPTH = false;
    _this.SAMPLER3DBGRMAP = false;
    _this.IMAGEPROCESSINGPOSTPROCESS = false;
    _this.SKIPFINALCOLORCLAMP = false;
    _this.MULTIVIEW = false;
    _this.ORDER_INDEPENDENT_TRANSPARENCY = false;
    _this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
    _this.IS_REFLECTION_LINEAR = false;
    _this.IS_REFRACTION_LINEAR = false;
    _this.EXPOSURE = false;
    _this.rebuild();
    return _this;
  }
  StandardMaterialDefines2.prototype.setReflectionMode = function(modeToEnable) {
    var modes = [
      "REFLECTIONMAP_CUBIC",
      "REFLECTIONMAP_EXPLICIT",
      "REFLECTIONMAP_PLANAR",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_SKYBOX",
      "REFLECTIONMAP_SPHERICAL",
      "REFLECTIONMAP_EQUIRECTANGULAR",
      "REFLECTIONMAP_EQUIRECTANGULAR_FIXED",
      "REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"
    ];
    for (var _i = 0, modes_1 = modes; _i < modes_1.length; _i++) {
      var mode = modes_1[_i];
      this[mode] = mode === modeToEnable;
    }
  };
  return StandardMaterialDefines2;
}(MaterialDefines);
var StandardMaterial = function(_super) {
  __extends(StandardMaterial2, _super);
  function StandardMaterial2(name2, scene) {
    var _this = _super.call(this, name2, scene) || this;
    _this._diffuseTexture = null;
    _this._ambientTexture = null;
    _this._opacityTexture = null;
    _this._reflectionTexture = null;
    _this._emissiveTexture = null;
    _this._specularTexture = null;
    _this._bumpTexture = null;
    _this._lightmapTexture = null;
    _this._refractionTexture = null;
    _this.ambientColor = new Color3(0, 0, 0);
    _this.diffuseColor = new Color3(1, 1, 1);
    _this.specularColor = new Color3(1, 1, 1);
    _this.emissiveColor = new Color3(0, 0, 0);
    _this.specularPower = 64;
    _this._useAlphaFromDiffuseTexture = false;
    _this._useEmissiveAsIllumination = false;
    _this._linkEmissiveWithDiffuse = false;
    _this._useSpecularOverAlpha = false;
    _this._useReflectionOverAlpha = false;
    _this._disableLighting = false;
    _this._useObjectSpaceNormalMap = false;
    _this._useParallax = false;
    _this._useParallaxOcclusion = false;
    _this.parallaxScaleBias = 0.05;
    _this._roughness = 0;
    _this.indexOfRefraction = 0.98;
    _this.invertRefractionY = true;
    _this.alphaCutOff = 0.4;
    _this._useLightmapAsShadowmap = false;
    _this._useReflectionFresnelFromSpecular = false;
    _this._useGlossinessFromSpecularMapAlpha = false;
    _this._maxSimultaneousLights = 4;
    _this._invertNormalMapX = false;
    _this._invertNormalMapY = false;
    _this._twoSidedLighting = false;
    _this._renderTargets = new SmartArray(16);
    _this._worldViewProjectionMatrix = Matrix.Zero();
    _this._globalAmbientColor = new Color3(0, 0, 0);
    _this._cacheHasRenderTargetTextures = false;
    _this.detailMap = new DetailMapConfiguration(_this);
    _this._attachImageProcessingConfiguration(null);
    _this.prePassConfiguration = new PrePassConfiguration();
    _this.getRenderTargetTextures = function() {
      _this._renderTargets.reset();
      if (StandardMaterial2.ReflectionTextureEnabled && _this._reflectionTexture && _this._reflectionTexture.isRenderTarget) {
        _this._renderTargets.push(_this._reflectionTexture);
      }
      if (StandardMaterial2.RefractionTextureEnabled && _this._refractionTexture && _this._refractionTexture.isRenderTarget) {
        _this._renderTargets.push(_this._refractionTexture);
      }
      _this._eventInfo.renderTargets = _this._renderTargets;
      _this._callbackPluginEventFillRenderTargetTextures(_this._eventInfo);
      return _this._renderTargets;
    };
    return _this;
  }
  Object.defineProperty(StandardMaterial2.prototype, "imageProcessingConfiguration", {
    get: function() {
      return this._imageProcessingConfiguration;
    },
    set: function(value) {
      this._attachImageProcessingConfiguration(value);
      this._markAllSubMeshesAsTexturesDirty();
    },
    enumerable: false,
    configurable: true
  });
  StandardMaterial2.prototype._attachImageProcessingConfiguration = function(configuration) {
    var _this = this;
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function() {
        _this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  };
  Object.defineProperty(StandardMaterial2.prototype, "isPrePassCapable", {
    get: function() {
      return !this.disableDepthWrite;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "cameraColorCurvesEnabled", {
    get: function() {
      return this.imageProcessingConfiguration.colorCurvesEnabled;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorCurvesEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "cameraColorGradingEnabled", {
    get: function() {
      return this.imageProcessingConfiguration.colorGradingEnabled;
    },
    set: function(value) {
      this.imageProcessingConfiguration.colorGradingEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "cameraToneMappingEnabled", {
    get: function() {
      return this._imageProcessingConfiguration.toneMappingEnabled;
    },
    set: function(value) {
      this._imageProcessingConfiguration.toneMappingEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "cameraExposure", {
    get: function() {
      return this._imageProcessingConfiguration.exposure;
    },
    set: function(value) {
      this._imageProcessingConfiguration.exposure = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "cameraContrast", {
    get: function() {
      return this._imageProcessingConfiguration.contrast;
    },
    set: function(value) {
      this._imageProcessingConfiguration.contrast = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "cameraColorGradingTexture", {
    get: function() {
      return this._imageProcessingConfiguration.colorGradingTexture;
    },
    set: function(value) {
      this._imageProcessingConfiguration.colorGradingTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "cameraColorCurves", {
    get: function() {
      return this._imageProcessingConfiguration.colorCurves;
    },
    set: function(value) {
      this._imageProcessingConfiguration.colorCurves = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "canRenderToMRT", {
    get: function() {
      return true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2.prototype, "hasRenderTargetTextures", {
    get: function() {
      if (StandardMaterial2.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
        return true;
      }
      if (StandardMaterial2.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
        return true;
      }
      return this._cacheHasRenderTargetTextures;
    },
    enumerable: false,
    configurable: true
  });
  StandardMaterial2.prototype.getClassName = function() {
    return "StandardMaterial";
  };
  Object.defineProperty(StandardMaterial2.prototype, "useLogarithmicDepth", {
    get: function() {
      return this._useLogarithmicDepth;
    },
    set: function(value) {
      this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
      this._markAllSubMeshesAsMiscDirty();
    },
    enumerable: false,
    configurable: true
  });
  StandardMaterial2.prototype.needAlphaBlending = function() {
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
  };
  StandardMaterial2.prototype.needAlphaTesting = function() {
    if (this._forceAlphaTest) {
      return true;
    }
    return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);
  };
  StandardMaterial2.prototype._shouldUseAlphaFromDiffuseTexture = function() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;
  };
  StandardMaterial2.prototype._hasAlphaChannel = function() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._opacityTexture != null;
  };
  StandardMaterial2.prototype.getAlphaTestTexture = function() {
    return this._diffuseTexture;
  };
  StandardMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    if (useInstances === void 0) {
      useInstances = false;
    }
    if (!this._uniformBufferLayoutBuilt) {
      this.buildUniformLayout();
    }
    if (subMesh.effect && this.isFrozen) {
      if (subMesh.effect._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);
      subMesh.materialDefines = new StandardMaterialDefines(this._eventInfo.defineNames);
    }
    var scene = this.getScene();
    var defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    var engine = scene.getEngine();
    defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
    MaterialHelper.PrepareDefinesForMultiview(scene, defines);
    var oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
    MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
    MaterialHelper.PrepareDefinesForOIT(scene, defines, oit);
    if (defines._areTexturesDirty) {
      this._eventInfo.hasRenderTargetTextures = false;
      this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
      this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
      defines._needUVs = false;
      for (var i = 1; i <= 6; ++i) {
        defines["MAINUV" + i] = false;
      }
      if (scene.texturesEnabled) {
        if (this._diffuseTexture && StandardMaterial2.DiffuseTextureEnabled) {
          if (!this._diffuseTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, "DIFFUSE");
          }
        } else {
          defines.DIFFUSE = false;
        }
        if (this._ambientTexture && StandardMaterial2.AmbientTextureEnabled) {
          if (!this._ambientTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
          }
        } else {
          defines.AMBIENT = false;
        }
        if (this._opacityTexture && StandardMaterial2.OpacityTextureEnabled) {
          if (!this._opacityTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
            defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
          }
        } else {
          defines.OPACITY = false;
        }
        if (this._reflectionTexture && StandardMaterial2.ReflectionTextureEnabled) {
          if (!this._reflectionTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            defines._needNormals = true;
            defines.REFLECTION = true;
            defines.ROUGHNESS = this._roughness > 0;
            defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;
            defines.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;
            defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;
            defines.RGBDREFLECTION = this._reflectionTexture.isRGBD;
            defines.REFLECTIONMAP_OPPOSITEZ = this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ;
            switch (this._reflectionTexture.coordinatesMode) {
              case Texture.EXPLICIT_MODE:
                defines.setReflectionMode("REFLECTIONMAP_EXPLICIT");
                break;
              case Texture.PLANAR_MODE:
                defines.setReflectionMode("REFLECTIONMAP_PLANAR");
                break;
              case Texture.PROJECTION_MODE:
                defines.setReflectionMode("REFLECTIONMAP_PROJECTION");
                break;
              case Texture.SKYBOX_MODE:
                defines.setReflectionMode("REFLECTIONMAP_SKYBOX");
                break;
              case Texture.SPHERICAL_MODE:
                defines.setReflectionMode("REFLECTIONMAP_SPHERICAL");
                break;
              case Texture.EQUIRECTANGULAR_MODE:
                defines.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR");
                break;
              case Texture.FIXED_EQUIRECTANGULAR_MODE:
                defines.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
                break;
              case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                defines.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
                break;
              case Texture.CUBIC_MODE:
              case Texture.INVCUBIC_MODE:
              default:
                defines.setReflectionMode("REFLECTIONMAP_CUBIC");
                break;
            }
            defines.USE_LOCAL_REFLECTIONMAP_CUBIC = this._reflectionTexture.boundingBoxSize ? true : false;
          }
        } else {
          defines.REFLECTION = false;
          defines.REFLECTIONMAP_OPPOSITEZ = false;
        }
        if (this._emissiveTexture && StandardMaterial2.EmissiveTextureEnabled) {
          if (!this._emissiveTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
          }
        } else {
          defines.EMISSIVE = false;
        }
        if (this._lightmapTexture && StandardMaterial2.LightmapTextureEnabled) {
          if (!this._lightmapTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
            defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
            defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
          }
        } else {
          defines.LIGHTMAP = false;
        }
        if (this._specularTexture && StandardMaterial2.SpecularTextureEnabled) {
          if (!this._specularTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture, defines, "SPECULAR");
            defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;
          }
        } else {
          defines.SPECULAR = false;
        }
        if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && StandardMaterial2.BumpTextureEnabled) {
          if (!this._bumpTexture.isReady()) {
            return false;
          } else {
            MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
            defines.PARALLAX = this._useParallax;
            defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;
          }
          defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
        } else {
          defines.BUMP = false;
        }
        if (this._refractionTexture && StandardMaterial2.RefractionTextureEnabled) {
          if (!this._refractionTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.REFRACTION = true;
            defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;
            defines.RGBDREFRACTION = this._refractionTexture.isRGBD;
            defines.USE_LOCAL_REFRACTIONMAP_CUBIC = this._refractionTexture.boundingBoxSize ? true : false;
          }
        } else {
          defines.REFRACTION = false;
        }
        defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;
      } else {
        defines.DIFFUSE = false;
        defines.AMBIENT = false;
        defines.OPACITY = false;
        defines.REFLECTION = false;
        defines.EMISSIVE = false;
        defines.LIGHTMAP = false;
        defines.BUMP = false;
        defines.REFRACTION = false;
      }
      defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();
      defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;
      defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;
      defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
      defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;
      defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh);
    }
    this._eventInfo.isReadyForSubMesh = true;
    this._eventInfo.defines = defines;
    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
    if (!this._eventInfo.isReadyForSubMesh) {
      return false;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady()) {
        return false;
      }
      this._imageProcessingConfiguration.prepareDefines(defines);
      defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;
      defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;
    }
    if (defines._areFresnelDirty) {
      if (StandardMaterial2.FresnelEnabled) {
        if (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) {
          defines.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled;
          defines.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
          defines.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled;
          defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;
          defines.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled;
          defines.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled;
          defines._needNormals = true;
          defines.FRESNEL = true;
        }
      } else {
        defines.FRESNEL = false;
      }
    }
    MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines);
    MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true);
    MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
    this._eventInfo.defines = defines;
    this._eventInfo.mesh = mesh;
    this._callbackPluginEventPrepareDefines(this._eventInfo);
    if (defines.isDirty) {
      var lightDisposed = defines._areLightsDisposed;
      defines.markAsProcessed();
      var fallbacks = new EffectFallbacks();
      if (defines.REFLECTION) {
        fallbacks.addFallback(0, "REFLECTION");
      }
      if (defines.SPECULAR) {
        fallbacks.addFallback(0, "SPECULAR");
      }
      if (defines.BUMP) {
        fallbacks.addFallback(0, "BUMP");
      }
      if (defines.PARALLAX) {
        fallbacks.addFallback(1, "PARALLAX");
      }
      if (defines.PARALLAXOCCLUSION) {
        fallbacks.addFallback(0, "PARALLAXOCCLUSION");
      }
      if (defines.SPECULAROVERALPHA) {
        fallbacks.addFallback(0, "SPECULAROVERALPHA");
      }
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      if (defines.POINTSIZE) {
        fallbacks.addFallback(0, "POINTSIZE");
      }
      if (defines.LOGARITHMICDEPTH) {
        fallbacks.addFallback(0, "LOGARITHMICDEPTH");
      }
      MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);
      if (defines.SPECULARTERM) {
        fallbacks.addFallback(0, "SPECULARTERM");
      }
      if (defines.DIFFUSEFRESNEL) {
        fallbacks.addFallback(1, "DIFFUSEFRESNEL");
      }
      if (defines.OPACITYFRESNEL) {
        fallbacks.addFallback(2, "OPACITYFRESNEL");
      }
      if (defines.REFLECTIONFRESNEL) {
        fallbacks.addFallback(3, "REFLECTIONFRESNEL");
      }
      if (defines.EMISSIVEFRESNEL) {
        fallbacks.addFallback(4, "EMISSIVEFRESNEL");
      }
      if (defines.FRESNEL) {
        fallbacks.addFallback(4, "FRESNEL");
      }
      if (defines.MULTIVIEW) {
        fallbacks.addFallback(0, "MULTIVIEW");
      }
      var attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      for (var i = 1; i <= 6; ++i) {
        if (defines["UV" + i]) {
          attribs.push("uv".concat(i === 1 ? "" : i));
        }
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      if (defines.INSTANCESCOLOR) {
        attribs.push(VertexBuffer.ColorInstanceKind);
      }
      MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      MaterialHelper.PrepareAttributesForInstances(attribs, defines);
      MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);
      MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
      var shaderName = "default";
      var uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vAmbientColor",
        "vDiffuseColor",
        "vSpecularColor",
        "vEmissiveColor",
        "visibility",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "vAmbientInfos",
        "vOpacityInfos",
        "vReflectionInfos",
        "vEmissiveInfos",
        "vSpecularInfos",
        "vBumpInfos",
        "vLightmapInfos",
        "vRefractionInfos",
        "mBones",
        "vClipPlane",
        "vClipPlane2",
        "vClipPlane3",
        "vClipPlane4",
        "vClipPlane5",
        "vClipPlane6",
        "diffuseMatrix",
        "ambientMatrix",
        "opacityMatrix",
        "reflectionMatrix",
        "emissiveMatrix",
        "specularMatrix",
        "bumpMatrix",
        "normalMatrix",
        "lightmapMatrix",
        "refractionMatrix",
        "diffuseLeftColor",
        "diffuseRightColor",
        "opacityParts",
        "reflectionLeftColor",
        "reflectionRightColor",
        "emissiveLeftColor",
        "emissiveRightColor",
        "refractionLeftColor",
        "refractionRightColor",
        "vReflectionPosition",
        "vReflectionSize",
        "vRefractionPosition",
        "vRefractionSize",
        "logarithmicDepthConstant",
        "vTangentSpaceParams",
        "alphaCutOff",
        "boneTextureWidth",
        "morphTargetTextureInfo",
        "morphTargetTextureIndices"
      ];
      var samplers = [
        "diffuseSampler",
        "ambientSampler",
        "opacitySampler",
        "reflectionCubeSampler",
        "reflection2DSampler",
        "emissiveSampler",
        "specularSampler",
        "bumpSampler",
        "lightmapSampler",
        "refractionCubeSampler",
        "refraction2DSampler",
        "boneSampler",
        "morphTargets",
        "oitDepthSampler",
        "oitFrontColorSampler"
      ];
      var uniformBuffers = ["Material", "Scene", "Mesh"];
      this._eventInfo.fallbacks = fallbacks;
      this._eventInfo.fallbackRank = 0;
      this._eventInfo.defines = defines;
      this._eventInfo.uniforms = uniforms;
      this._eventInfo.samplers = samplers;
      this._eventInfo.uniformBuffersNames = uniformBuffers;
      this._eventInfo.customCode = void 0;
      this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);
      PrePassConfiguration.AddUniforms(uniforms);
      PrePassConfiguration.AddSamplers(samplers);
      if (ImageProcessingConfiguration) {
        ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
        ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
      }
      MaterialHelper.PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this._maxSimultaneousLights
      });
      var csnrOptions = {};
      if (this.customShaderNameResolve) {
        shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
      }
      var join = defines.toString();
      var previousEffect = subMesh.effect;
      var effect = scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },
        processFinalCode: csnrOptions.processFinalCode,
        processCodeAfterIncludes: this._eventInfo.customCode,
        multiTarget: defines.PREPASS
      }, engine);
      if (effect) {
        if (this._onEffectCreatedObservable) {
          onCreatedEffectParameters.effect = effect;
          onCreatedEffectParameters.subMesh = subMesh;
          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
        }
        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
          effect = previousEffect;
          defines.markAsUnprocessed();
          if (lightDisposed) {
            defines._areLightsDisposed = true;
            return false;
          }
        } else {
          scene.resetCachedMaterial();
          subMesh.setEffect(effect, defines, this._materialContext);
        }
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    subMesh.effect._wasPreviouslyReady = true;
    return true;
  };
  StandardMaterial2.prototype.buildUniformLayout = function() {
    var ubo = this._uniformBuffer;
    ubo.addUniform("diffuseLeftColor", 4);
    ubo.addUniform("diffuseRightColor", 4);
    ubo.addUniform("opacityParts", 4);
    ubo.addUniform("reflectionLeftColor", 4);
    ubo.addUniform("reflectionRightColor", 4);
    ubo.addUniform("refractionLeftColor", 4);
    ubo.addUniform("refractionRightColor", 4);
    ubo.addUniform("emissiveLeftColor", 4);
    ubo.addUniform("emissiveRightColor", 4);
    ubo.addUniform("vDiffuseInfos", 2);
    ubo.addUniform("vAmbientInfos", 2);
    ubo.addUniform("vOpacityInfos", 2);
    ubo.addUniform("vReflectionInfos", 2);
    ubo.addUniform("vReflectionPosition", 3);
    ubo.addUniform("vReflectionSize", 3);
    ubo.addUniform("vEmissiveInfos", 2);
    ubo.addUniform("vLightmapInfos", 2);
    ubo.addUniform("vSpecularInfos", 2);
    ubo.addUniform("vBumpInfos", 3);
    ubo.addUniform("diffuseMatrix", 16);
    ubo.addUniform("ambientMatrix", 16);
    ubo.addUniform("opacityMatrix", 16);
    ubo.addUniform("reflectionMatrix", 16);
    ubo.addUniform("emissiveMatrix", 16);
    ubo.addUniform("lightmapMatrix", 16);
    ubo.addUniform("specularMatrix", 16);
    ubo.addUniform("bumpMatrix", 16);
    ubo.addUniform("vTangentSpaceParams", 2);
    ubo.addUniform("pointSize", 1);
    ubo.addUniform("alphaCutOff", 1);
    ubo.addUniform("refractionMatrix", 16);
    ubo.addUniform("vRefractionInfos", 4);
    ubo.addUniform("vRefractionPosition", 3);
    ubo.addUniform("vRefractionSize", 3);
    ubo.addUniform("vSpecularColor", 4);
    ubo.addUniform("vEmissiveColor", 3);
    ubo.addUniform("vDiffuseColor", 4);
    ubo.addUniform("vAmbientColor", 3);
    _super.prototype.buildUniformLayout.call(this);
  };
  StandardMaterial2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
    var _a;
    var scene = this.getScene();
    var defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    var effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
    mesh.transferToEffect(world);
    this._uniformBuffer.bindToEffect(effect, "Material");
    this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
    if (defines.OBJECTSPACE_NORMALMAP) {
      world.toNormalMatrix(this._normalMatrix);
      this.bindOnlyNormalMatrix(this._normalMatrix);
    }
    var mustRebind = this._mustRebind(scene, effect, mesh.visibility);
    MaterialHelper.BindBonesParameters(mesh, effect);
    var ubo = this._uniformBuffer;
    if (mustRebind) {
      this.bindViewProjection(effect);
      if (!ubo.useUbo || !this.isFrozen || !ubo.isSync) {
        if (StandardMaterial2.FresnelEnabled && defines.FRESNEL) {
          if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {
            ubo.updateColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);
            ubo.updateColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);
          }
          if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {
            ubo.updateColor4("opacityParts", new Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power);
          }
          if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {
            ubo.updateColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);
            ubo.updateColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);
          }
          if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {
            ubo.updateColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);
            ubo.updateColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);
          }
          if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {
            ubo.updateColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);
            ubo.updateColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);
          }
        }
        if (scene.texturesEnabled) {
          if (this._diffuseTexture && StandardMaterial2.DiffuseTextureEnabled) {
            ubo.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
            MaterialHelper.BindTextureMatrix(this._diffuseTexture, ubo, "diffuse");
          }
          if (this._ambientTexture && StandardMaterial2.AmbientTextureEnabled) {
            ubo.updateFloat2("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);
            MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, "ambient");
          }
          if (this._opacityTexture && StandardMaterial2.OpacityTextureEnabled) {
            ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
            MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, "opacity");
          }
          if (this._hasAlphaChannel()) {
            ubo.updateFloat("alphaCutOff", this.alphaCutOff);
          }
          if (this._reflectionTexture && StandardMaterial2.ReflectionTextureEnabled) {
            ubo.updateFloat2("vReflectionInfos", this._reflectionTexture.level, this.roughness);
            ubo.updateMatrix("reflectionMatrix", this._reflectionTexture.getReflectionTextureMatrix());
            if (this._reflectionTexture.boundingBoxSize) {
              var cubeTexture = this._reflectionTexture;
              ubo.updateVector3("vReflectionPosition", cubeTexture.boundingBoxPosition);
              ubo.updateVector3("vReflectionSize", cubeTexture.boundingBoxSize);
            }
          }
          if (this._emissiveTexture && StandardMaterial2.EmissiveTextureEnabled) {
            ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
            MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
          }
          if (this._lightmapTexture && StandardMaterial2.LightmapTextureEnabled) {
            ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
            MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
          }
          if (this._specularTexture && StandardMaterial2.SpecularTextureEnabled) {
            ubo.updateFloat2("vSpecularInfos", this._specularTexture.coordinatesIndex, this._specularTexture.level);
            MaterialHelper.BindTextureMatrix(this._specularTexture, ubo, "specular");
          }
          if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial2.BumpTextureEnabled) {
            ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias);
            MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, "bump");
            if (scene._mirroredCameraPosition) {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
            } else {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
            }
          }
          if (this._refractionTexture && StandardMaterial2.RefractionTextureEnabled) {
            var depth = 1;
            if (!this._refractionTexture.isCube) {
              ubo.updateMatrix("refractionMatrix", this._refractionTexture.getReflectionTextureMatrix());
              if (this._refractionTexture.depth) {
                depth = this._refractionTexture.depth;
              }
            }
            ubo.updateFloat4("vRefractionInfos", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);
            if (this._refractionTexture.boundingBoxSize) {
              var cubeTexture = this._refractionTexture;
              ubo.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
              ubo.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
            }
          }
        }
        if (this.pointsCloud) {
          ubo.updateFloat("pointSize", this.pointSize);
        }
        if (defines.SPECULARTERM) {
          ubo.updateColor4("vSpecularColor", this.specularColor, this.specularPower);
        }
        ubo.updateColor3("vEmissiveColor", StandardMaterial2.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly);
        ubo.updateColor4("vDiffuseColor", this.diffuseColor, this.alpha);
        scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);
        ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
      }
      if (scene.texturesEnabled) {
        if (this._diffuseTexture && StandardMaterial2.DiffuseTextureEnabled) {
          effect.setTexture("diffuseSampler", this._diffuseTexture);
        }
        if (this._ambientTexture && StandardMaterial2.AmbientTextureEnabled) {
          effect.setTexture("ambientSampler", this._ambientTexture);
        }
        if (this._opacityTexture && StandardMaterial2.OpacityTextureEnabled) {
          effect.setTexture("opacitySampler", this._opacityTexture);
        }
        if (this._reflectionTexture && StandardMaterial2.ReflectionTextureEnabled) {
          if (this._reflectionTexture.isCube) {
            effect.setTexture("reflectionCubeSampler", this._reflectionTexture);
          } else {
            effect.setTexture("reflection2DSampler", this._reflectionTexture);
          }
        }
        if (this._emissiveTexture && StandardMaterial2.EmissiveTextureEnabled) {
          effect.setTexture("emissiveSampler", this._emissiveTexture);
        }
        if (this._lightmapTexture && StandardMaterial2.LightmapTextureEnabled) {
          effect.setTexture("lightmapSampler", this._lightmapTexture);
        }
        if (this._specularTexture && StandardMaterial2.SpecularTextureEnabled) {
          effect.setTexture("specularSampler", this._specularTexture);
        }
        if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial2.BumpTextureEnabled) {
          effect.setTexture("bumpSampler", this._bumpTexture);
        }
        if (this._refractionTexture && StandardMaterial2.RefractionTextureEnabled) {
          var depth = 1;
          if (this._refractionTexture.isCube) {
            effect.setTexture("refractionCubeSampler", this._refractionTexture);
          } else {
            effect.setTexture("refraction2DSampler", this._refractionTexture);
          }
        }
      }
      if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
        this.getScene().depthPeelingRenderer.bind(effect);
      }
      this._eventInfo.subMesh = subMesh;
      this._callbackPluginEventBindForSubMesh(this._eventInfo);
      MaterialHelper.BindClipPlane(effect, scene);
      this.bindEyePosition(effect);
    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
      this._needToBindSceneUbo = true;
    }
    if (mustRebind || !this.isFrozen) {
      if (scene.lightsEnabled && !this._disableLighting) {
        MaterialHelper.BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights);
      }
      if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture || mesh.receiveShadows) {
        this.bindView(effect);
      }
      MaterialHelper.BindFogParameters(scene, mesh, effect);
      if (defines.NUM_MORPH_INFLUENCERS) {
        MaterialHelper.BindMorphTargetParameters(mesh, effect);
      }
      if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
        (_a = mesh.bakedVertexAnimationManager) === null || _a === void 0 ? void 0 : _a.bind(effect, defines.INSTANCES);
      }
      if (this.useLogarithmicDepth) {
        MaterialHelper.BindLogDepth(defines, effect, scene);
      }
      if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
        this._imageProcessingConfiguration.bind(this._activeEffect);
      }
    }
    this._afterBind(mesh, this._activeEffect);
    ubo.update();
  };
  StandardMaterial2.prototype.getAnimatables = function() {
    var results = _super.prototype.getAnimatables.call(this);
    if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {
      results.push(this._diffuseTexture);
    }
    if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
      results.push(this._ambientTexture);
    }
    if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
      results.push(this._opacityTexture);
    }
    if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
      results.push(this._reflectionTexture);
    }
    if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
      results.push(this._emissiveTexture);
    }
    if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {
      results.push(this._specularTexture);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      results.push(this._bumpTexture);
    }
    if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
      results.push(this._lightmapTexture);
    }
    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
      results.push(this._refractionTexture);
    }
    return results;
  };
  StandardMaterial2.prototype.getActiveTextures = function() {
    var activeTextures = _super.prototype.getActiveTextures.call(this);
    if (this._diffuseTexture) {
      activeTextures.push(this._diffuseTexture);
    }
    if (this._ambientTexture) {
      activeTextures.push(this._ambientTexture);
    }
    if (this._opacityTexture) {
      activeTextures.push(this._opacityTexture);
    }
    if (this._reflectionTexture) {
      activeTextures.push(this._reflectionTexture);
    }
    if (this._emissiveTexture) {
      activeTextures.push(this._emissiveTexture);
    }
    if (this._specularTexture) {
      activeTextures.push(this._specularTexture);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._lightmapTexture) {
      activeTextures.push(this._lightmapTexture);
    }
    if (this._refractionTexture) {
      activeTextures.push(this._refractionTexture);
    }
    return activeTextures;
  };
  StandardMaterial2.prototype.hasTexture = function(texture) {
    if (_super.prototype.hasTexture.call(this, texture)) {
      return true;
    }
    if (this._diffuseTexture === texture) {
      return true;
    }
    if (this._ambientTexture === texture) {
      return true;
    }
    if (this._opacityTexture === texture) {
      return true;
    }
    if (this._reflectionTexture === texture) {
      return true;
    }
    if (this._emissiveTexture === texture) {
      return true;
    }
    if (this._specularTexture === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._lightmapTexture === texture) {
      return true;
    }
    if (this._refractionTexture === texture) {
      return true;
    }
    return false;
  };
  StandardMaterial2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (forceDisposeTextures) {
      (_a = this._diffuseTexture) === null || _a === void 0 ? void 0 : _a.dispose();
      (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();
      (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();
      (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();
      (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();
      (_f = this._specularTexture) === null || _f === void 0 ? void 0 : _f.dispose();
      (_g = this._bumpTexture) === null || _g === void 0 ? void 0 : _g.dispose();
      (_h = this._lightmapTexture) === null || _h === void 0 ? void 0 : _h.dispose();
      (_j = this._refractionTexture) === null || _j === void 0 ? void 0 : _j.dispose();
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);
  };
  StandardMaterial2.prototype.clone = function(name2) {
    var _this = this;
    var result = SerializationHelper.Clone(function() {
      return new StandardMaterial2(name2, _this.getScene());
    }, this);
    result.name = name2;
    result.id = name2;
    this.stencil.copyTo(result.stencil);
    return result;
  };
  StandardMaterial2.Parse = function(source, scene, rootUrl) {
    var material = SerializationHelper.Parse(function() {
      return new StandardMaterial2(source.name, scene);
    }, source, scene, rootUrl);
    if (source.stencil) {
      material.stencil.parse(source.stencil, scene, rootUrl);
    }
    return material;
  };
  Object.defineProperty(StandardMaterial2, "DiffuseTextureEnabled", {
    get: function() {
      return MaterialFlags.DiffuseTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.DiffuseTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "DetailTextureEnabled", {
    get: function() {
      return MaterialFlags.DetailTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.DetailTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "AmbientTextureEnabled", {
    get: function() {
      return MaterialFlags.AmbientTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.AmbientTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "OpacityTextureEnabled", {
    get: function() {
      return MaterialFlags.OpacityTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.OpacityTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "ReflectionTextureEnabled", {
    get: function() {
      return MaterialFlags.ReflectionTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.ReflectionTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "EmissiveTextureEnabled", {
    get: function() {
      return MaterialFlags.EmissiveTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.EmissiveTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "SpecularTextureEnabled", {
    get: function() {
      return MaterialFlags.SpecularTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.SpecularTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "BumpTextureEnabled", {
    get: function() {
      return MaterialFlags.BumpTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.BumpTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "LightmapTextureEnabled", {
    get: function() {
      return MaterialFlags.LightmapTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.LightmapTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "RefractionTextureEnabled", {
    get: function() {
      return MaterialFlags.RefractionTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.RefractionTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "ColorGradingTextureEnabled", {
    get: function() {
      return MaterialFlags.ColorGradingTextureEnabled;
    },
    set: function(value) {
      MaterialFlags.ColorGradingTextureEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StandardMaterial2, "FresnelEnabled", {
    get: function() {
      return MaterialFlags.FresnelEnabled;
    },
    set: function(value) {
      MaterialFlags.FresnelEnabled = value;
    },
    enumerable: false,
    configurable: true
  });
  __decorate([
    serializeAsTexture("diffuseTexture")
  ], StandardMaterial2.prototype, "_diffuseTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], StandardMaterial2.prototype, "diffuseTexture", void 0);
  __decorate([
    serializeAsTexture("ambientTexture")
  ], StandardMaterial2.prototype, "_ambientTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "ambientTexture", void 0);
  __decorate([
    serializeAsTexture("opacityTexture")
  ], StandardMaterial2.prototype, "_opacityTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], StandardMaterial2.prototype, "opacityTexture", void 0);
  __decorate([
    serializeAsTexture("reflectionTexture")
  ], StandardMaterial2.prototype, "_reflectionTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "reflectionTexture", void 0);
  __decorate([
    serializeAsTexture("emissiveTexture")
  ], StandardMaterial2.prototype, "_emissiveTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "emissiveTexture", void 0);
  __decorate([
    serializeAsTexture("specularTexture")
  ], StandardMaterial2.prototype, "_specularTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "specularTexture", void 0);
  __decorate([
    serializeAsTexture("bumpTexture")
  ], StandardMaterial2.prototype, "_bumpTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "bumpTexture", void 0);
  __decorate([
    serializeAsTexture("lightmapTexture")
  ], StandardMaterial2.prototype, "_lightmapTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "lightmapTexture", void 0);
  __decorate([
    serializeAsTexture("refractionTexture")
  ], StandardMaterial2.prototype, "_refractionTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "refractionTexture", void 0);
  __decorate([
    serializeAsColor3("ambient")
  ], StandardMaterial2.prototype, "ambientColor", void 0);
  __decorate([
    serializeAsColor3("diffuse")
  ], StandardMaterial2.prototype, "diffuseColor", void 0);
  __decorate([
    serializeAsColor3("specular")
  ], StandardMaterial2.prototype, "specularColor", void 0);
  __decorate([
    serializeAsColor3("emissive")
  ], StandardMaterial2.prototype, "emissiveColor", void 0);
  __decorate([
    serialize()
  ], StandardMaterial2.prototype, "specularPower", void 0);
  __decorate([
    serialize("useAlphaFromDiffuseTexture")
  ], StandardMaterial2.prototype, "_useAlphaFromDiffuseTexture", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
  ], StandardMaterial2.prototype, "useAlphaFromDiffuseTexture", void 0);
  __decorate([
    serialize("useEmissiveAsIllumination")
  ], StandardMaterial2.prototype, "_useEmissiveAsIllumination", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useEmissiveAsIllumination", void 0);
  __decorate([
    serialize("linkEmissiveWithDiffuse")
  ], StandardMaterial2.prototype, "_linkEmissiveWithDiffuse", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "linkEmissiveWithDiffuse", void 0);
  __decorate([
    serialize("useSpecularOverAlpha")
  ], StandardMaterial2.prototype, "_useSpecularOverAlpha", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useSpecularOverAlpha", void 0);
  __decorate([
    serialize("useReflectionOverAlpha")
  ], StandardMaterial2.prototype, "_useReflectionOverAlpha", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useReflectionOverAlpha", void 0);
  __decorate([
    serialize("disableLighting")
  ], StandardMaterial2.prototype, "_disableLighting", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsLightsDirty")
  ], StandardMaterial2.prototype, "disableLighting", void 0);
  __decorate([
    serialize("useObjectSpaceNormalMap")
  ], StandardMaterial2.prototype, "_useObjectSpaceNormalMap", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useObjectSpaceNormalMap", void 0);
  __decorate([
    serialize("useParallax")
  ], StandardMaterial2.prototype, "_useParallax", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useParallax", void 0);
  __decorate([
    serialize("useParallaxOcclusion")
  ], StandardMaterial2.prototype, "_useParallaxOcclusion", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useParallaxOcclusion", void 0);
  __decorate([
    serialize()
  ], StandardMaterial2.prototype, "parallaxScaleBias", void 0);
  __decorate([
    serialize("roughness")
  ], StandardMaterial2.prototype, "_roughness", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "roughness", void 0);
  __decorate([
    serialize()
  ], StandardMaterial2.prototype, "indexOfRefraction", void 0);
  __decorate([
    serialize()
  ], StandardMaterial2.prototype, "invertRefractionY", void 0);
  __decorate([
    serialize()
  ], StandardMaterial2.prototype, "alphaCutOff", void 0);
  __decorate([
    serialize("useLightmapAsShadowmap")
  ], StandardMaterial2.prototype, "_useLightmapAsShadowmap", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useLightmapAsShadowmap", void 0);
  __decorate([
    serializeAsFresnelParameters("diffuseFresnelParameters")
  ], StandardMaterial2.prototype, "_diffuseFresnelParameters", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsFresnelDirty")
  ], StandardMaterial2.prototype, "diffuseFresnelParameters", void 0);
  __decorate([
    serializeAsFresnelParameters("opacityFresnelParameters")
  ], StandardMaterial2.prototype, "_opacityFresnelParameters", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsFresnelAndMiscDirty")
  ], StandardMaterial2.prototype, "opacityFresnelParameters", void 0);
  __decorate([
    serializeAsFresnelParameters("reflectionFresnelParameters")
  ], StandardMaterial2.prototype, "_reflectionFresnelParameters", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsFresnelDirty")
  ], StandardMaterial2.prototype, "reflectionFresnelParameters", void 0);
  __decorate([
    serializeAsFresnelParameters("refractionFresnelParameters")
  ], StandardMaterial2.prototype, "_refractionFresnelParameters", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsFresnelDirty")
  ], StandardMaterial2.prototype, "refractionFresnelParameters", void 0);
  __decorate([
    serializeAsFresnelParameters("emissiveFresnelParameters")
  ], StandardMaterial2.prototype, "_emissiveFresnelParameters", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsFresnelDirty")
  ], StandardMaterial2.prototype, "emissiveFresnelParameters", void 0);
  __decorate([
    serialize("useReflectionFresnelFromSpecular")
  ], StandardMaterial2.prototype, "_useReflectionFresnelFromSpecular", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsFresnelDirty")
  ], StandardMaterial2.prototype, "useReflectionFresnelFromSpecular", void 0);
  __decorate([
    serialize("useGlossinessFromSpecularMapAlpha")
  ], StandardMaterial2.prototype, "_useGlossinessFromSpecularMapAlpha", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "useGlossinessFromSpecularMapAlpha", void 0);
  __decorate([
    serialize("maxSimultaneousLights")
  ], StandardMaterial2.prototype, "_maxSimultaneousLights", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsLightsDirty")
  ], StandardMaterial2.prototype, "maxSimultaneousLights", void 0);
  __decorate([
    serialize("invertNormalMapX")
  ], StandardMaterial2.prototype, "_invertNormalMapX", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "invertNormalMapX", void 0);
  __decorate([
    serialize("invertNormalMapY")
  ], StandardMaterial2.prototype, "_invertNormalMapY", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "invertNormalMapY", void 0);
  __decorate([
    serialize("twoSidedLighting")
  ], StandardMaterial2.prototype, "_twoSidedLighting", void 0);
  __decorate([
    expandToProperty("_markAllSubMeshesAsTexturesDirty")
  ], StandardMaterial2.prototype, "twoSidedLighting", void 0);
  __decorate([
    serialize()
  ], StandardMaterial2.prototype, "useLogarithmicDepth", null);
  return StandardMaterial2;
}(PushMaterial);
RegisterClass("BABYLON.StandardMaterial", StandardMaterial);
Scene.DefaultMaterialFactory = function(scene) {
  return new StandardMaterial("default material", scene);
};
var name$2 = "imageProcessingCompatibility";
var shader$2 = "#ifdef IMAGEPROCESSINGPOSTPROCESS\ngl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(2.2));\n#endif";
ShaderStore.IncludesShadersStore[name$2] = shader$2;
var name$1 = "shadowOnlyPixelShader";
var shader$1 = "precision highp float;\n\nuniform vec4 vEyePosition;\nuniform float alpha;\nuniform vec3 shadowColor;\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#include<helperFunctions>\n\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\n\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\nfloat shadow=1.;\nfloat glossiness=0.;\n#include<lightFragment>[0..1]\n\nvec4 color=vec4(shadowColor,(1.0-clamp(shadow,0.,1.))*alpha);\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}";
ShaderStore.ShadersStore[name$1] = shader$1;
var name = "shadowOnlyVertexShader";
var shader = "precision highp float;\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*worldPos;\nvPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n\n#include<clipPlaneVertex>\n\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n";
ShaderStore.ShadersStore[name] = shader;
var ShadowOnlyMaterialDefines = function(_super) {
  __extends(ShadowOnlyMaterialDefines2, _super);
  function ShadowOnlyMaterialDefines2() {
    var _this = _super.call(this) || this;
    _this.CLIPPLANE = false;
    _this.CLIPPLANE2 = false;
    _this.CLIPPLANE3 = false;
    _this.CLIPPLANE4 = false;
    _this.CLIPPLANE5 = false;
    _this.CLIPPLANE6 = false;
    _this.POINTSIZE = false;
    _this.FOG = false;
    _this.NORMAL = false;
    _this.NUM_BONE_INFLUENCERS = 0;
    _this.BonesPerMesh = 0;
    _this.INSTANCES = false;
    _this.IMAGEPROCESSINGPOSTPROCESS = false;
    _this.SKIPFINALCOLORCLAMP = false;
    _this.rebuild();
    return _this;
  }
  return ShadowOnlyMaterialDefines2;
}(MaterialDefines);
var ShadowOnlyMaterial = function(_super) {
  __extends(ShadowOnlyMaterial2, _super);
  function ShadowOnlyMaterial2(name2, scene) {
    var _this = _super.call(this, name2, scene) || this;
    _this._needAlphaBlending = true;
    _this.shadowColor = Color3.Black();
    return _this;
  }
  ShadowOnlyMaterial2.prototype.needAlphaBlending = function() {
    return this._needAlphaBlending;
  };
  ShadowOnlyMaterial2.prototype.needAlphaTesting = function() {
    return false;
  };
  ShadowOnlyMaterial2.prototype.getAlphaTestTexture = function() {
    return null;
  };
  Object.defineProperty(ShadowOnlyMaterial2.prototype, "activeLight", {
    get: function() {
      return this._activeLight;
    },
    set: function(light) {
      this._activeLight = light;
    },
    enumerable: false,
    configurable: true
  });
  ShadowOnlyMaterial2.prototype._getFirstShadowLightForMesh = function(mesh) {
    for (var _i = 0, _a = mesh.lightSources; _i < _a.length; _i++) {
      var light = _a[_i];
      if (light.shadowEnabled) {
        return light;
      }
    }
    return null;
  };
  ShadowOnlyMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    var _a;
    if (this.isFrozen) {
      if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new ShadowOnlyMaterialDefines();
    }
    var defines = subMesh.materialDefines;
    var scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    var engine = scene.getEngine();
    if (this._activeLight) {
      for (var _i = 0, _b = mesh.lightSources; _i < _b.length; _i++) {
        var light = _b[_i];
        if (light.shadowEnabled) {
          if (this._activeLight === light) {
            break;
          }
          var lightPosition = mesh.lightSources.indexOf(this._activeLight);
          if (lightPosition !== -1) {
            mesh.lightSources.splice(lightPosition, 1);
            mesh.lightSources.splice(0, 0, this._activeLight);
          }
          break;
        }
      }
    }
    MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances ? true : false);
    MaterialHelper.PrepareDefinesForMisc(mesh, scene, false, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh), defines);
    defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, false, 1);
    var shadowGenerator = (_a = this._getFirstShadowLightForMesh(mesh)) === null || _a === void 0 ? void 0 : _a.getShadowGenerator();
    this._needAlphaBlending = true;
    if (shadowGenerator && shadowGenerator.getClassName && shadowGenerator.getClassName() === "CascadedShadowGenerator") {
      var csg = shadowGenerator;
      this._needAlphaBlending = !csg.autoCalcDepthBounds;
    }
    MaterialHelper.PrepareDefinesForAttributes(mesh, defines, false, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      var fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, 1);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      var attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      MaterialHelper.PrepareAttributesForInstances(attribs, defines);
      var shaderName = "shadowOnly";
      var join = defines.toString();
      var uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "alpha",
        "shadowColor",
        "mBones",
        "vClipPlane",
        "vClipPlane2",
        "vClipPlane3",
        "vClipPlane4",
        "vClipPlane5",
        "vClipPlane6"
      ];
      var samplers = new Array();
      var uniformBuffers = new Array();
      MaterialHelper.PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 1
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 1 }
      }, engine), defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    subMesh.effect._wasPreviouslyReady = true;
    return true;
  };
  ShadowOnlyMaterial2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
    var scene = this.getScene();
    var defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    var effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    MaterialHelper.BindBonesParameters(mesh, this._activeEffect);
    if (this._mustRebind(scene, effect)) {
      MaterialHelper.BindClipPlane(this._activeEffect, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      this._activeEffect.setFloat("alpha", this.alpha);
      this._activeEffect.setColor3("shadowColor", this.shadowColor);
      scene.bindEyePosition(effect);
    }
    if (scene.lightsEnabled) {
      MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, 1);
      var light = this._getFirstShadowLightForMesh(mesh);
      if (light) {
        light._renderId = -1;
      }
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || defines["SHADOWCSM0"]) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);
    this._afterBind(mesh, this._activeEffect);
  };
  ShadowOnlyMaterial2.prototype.clone = function(name2) {
    var _this = this;
    return SerializationHelper.Clone(function() {
      return new ShadowOnlyMaterial2(name2, _this.getScene());
    }, this);
  };
  ShadowOnlyMaterial2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.customType = "BABYLON.ShadowOnlyMaterial";
    return serializationObject;
  };
  ShadowOnlyMaterial2.prototype.getClassName = function() {
    return "ShadowOnlyMaterial";
  };
  ShadowOnlyMaterial2.Parse = function(source, scene, rootUrl) {
    return SerializationHelper.Parse(function() {
      return new ShadowOnlyMaterial2(source.name, scene);
    }, source, scene, rootUrl);
  };
  return ShadowOnlyMaterial2;
}(PushMaterial);
RegisterClass("BABYLON.ShadowOnlyMaterial", ShadowOnlyMaterial);
const defaultOptions$1 = {
  aspect: 300 / 150,
  enableDebugging: false,
  enableShadows: true
};
class DiceBox {
  constructor(options) {
    __publicField(this, "size", 9.5);
    this.config = __spreadValues(__spreadValues({}, defaultOptions$1), options);
    this.create();
  }
  create(options) {
    this.destroy();
    Object.assign(this.config, options);
    const { aspect, enableDebugging = true, enableShadows } = this.config;
    const wallHeight = 30;
    let boxMaterial;
    this.box = new TransformNode("diceBox");
    if (enableDebugging) {
      boxMaterial = new StandardMaterial("diceBox_material");
      boxMaterial.alpha = 0.7;
      boxMaterial.diffuseColor = new Color3(1, 1, 0);
    } else {
      if (enableShadows) {
        boxMaterial = new ShadowOnlyMaterial("shadowOnly", this.config.scene);
      }
    }
    const ground = CreateBox("ground", {
      width: this.size,
      height: 1,
      depth: this.size
    }, this.config.scene);
    ground.scaling = new Vector3(aspect, 1, 1);
    ground.material = boxMaterial;
    ground.receiveShadows = true;
    ground.setParent(this.box);
    if (enableDebugging) {
      const wallTop = CreateBox("wallTop", {
        width: this.size,
        height: wallHeight,
        depth: 1
      }, this.config.scene);
      wallTop.position.y = wallHeight / 2;
      wallTop.position.z = this.size / -2;
      wallTop.scaling = new Vector3(aspect, 1, 1);
      wallTop.material = boxMaterial;
      wallTop.setParent(this.box);
      const wallRight = CreateBox("wallRight", {
        width: 1,
        height: wallHeight,
        depth: this.size
      }, this.config.scene);
      wallRight.position.x = this.size * aspect / 2;
      wallRight.position.y = wallHeight / 2;
      wallRight.material = boxMaterial;
      wallRight.setParent(this.box);
      const wallBottom = CreateBox("wallBottom", {
        width: this.size,
        height: wallHeight,
        depth: 1
      }, this.config.scene);
      wallBottom.position.y = wallHeight / 2;
      wallBottom.position.z = this.size / 2;
      wallBottom.scaling = new Vector3(aspect, 1, 1);
      wallBottom.material = boxMaterial;
      wallBottom.setParent(this.box);
      const wallLeft = CreateBox("wallLeft", {
        width: 1,
        height: wallHeight,
        depth: this.size
      }, this.config.scene);
      wallLeft.position.x = this.size * aspect / -2;
      wallLeft.position.y = wallHeight / 2;
      wallLeft.material = boxMaterial;
      wallLeft.setParent(this.box);
    }
  }
  destroy() {
    if (this.box) {
      this.box.dispose();
    }
  }
}
var SceneLoaderAnimationGroupLoadingMode;
(function(SceneLoaderAnimationGroupLoadingMode2) {
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Clean"] = 0] = "Clean";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Stop"] = 1] = "Stop";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Sync"] = 2] = "Sync";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["NoSync"] = 3] = "NoSync";
})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));
var SceneLoader = function() {
  function SceneLoader2() {
  }
  Object.defineProperty(SceneLoader2, "ForceFullSceneLoadingForIncremental", {
    get: function() {
      return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;
    },
    set: function(value) {
      SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoader2, "ShowLoadingScreen", {
    get: function() {
      return SceneLoaderFlags.ShowLoadingScreen;
    },
    set: function(value) {
      SceneLoaderFlags.ShowLoadingScreen = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoader2, "loggingLevel", {
    get: function() {
      return SceneLoaderFlags.loggingLevel;
    },
    set: function(value) {
      SceneLoaderFlags.loggingLevel = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoader2, "CleanBoneMatrixWeights", {
    get: function() {
      return SceneLoaderFlags.CleanBoneMatrixWeights;
    },
    set: function(value) {
      SceneLoaderFlags.CleanBoneMatrixWeights = value;
    },
    enumerable: false,
    configurable: true
  });
  SceneLoader2.GetDefaultPlugin = function() {
    return SceneLoader2._registeredPlugins[".babylon"];
  };
  SceneLoader2._GetPluginForExtension = function(extension) {
    var registeredPlugin = SceneLoader2._registeredPlugins[extension];
    if (registeredPlugin) {
      return registeredPlugin;
    }
    Logger.Warn("Unable to find a plugin to load " + extension + " files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/how_to/load_from_any_file_type");
    return SceneLoader2.GetDefaultPlugin();
  };
  SceneLoader2._GetPluginForDirectLoad = function(data) {
    for (var extension in SceneLoader2._registeredPlugins) {
      var plugin = SceneLoader2._registeredPlugins[extension].plugin;
      if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {
        return SceneLoader2._registeredPlugins[extension];
      }
    }
    return SceneLoader2.GetDefaultPlugin();
  };
  SceneLoader2._GetPluginForFilename = function(sceneFilename) {
    var queryStringPosition = sceneFilename.indexOf("?");
    if (queryStringPosition !== -1) {
      sceneFilename = sceneFilename.substring(0, queryStringPosition);
    }
    var dotPosition = sceneFilename.lastIndexOf(".");
    var extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();
    return SceneLoader2._GetPluginForExtension(extension);
  };
  SceneLoader2._GetDirectLoad = function(sceneFilename) {
    if (sceneFilename.substr(0, 5) === "data:") {
      return sceneFilename.substr(5);
    }
    return null;
  };
  SceneLoader2._FormatErrorMessage = function(fileInfo, message, exception) {
    var errorMessage = "Unable to load from " + fileInfo.url;
    if (message) {
      errorMessage += ": ".concat(message);
    } else if (exception) {
      errorMessage += ": ".concat(exception);
    }
    return errorMessage;
  };
  SceneLoader2._LoadData = function(fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension) {
    var directLoad = SceneLoader2._GetDirectLoad(fileInfo.url);
    var registeredPlugin = pluginExtension ? SceneLoader2._GetPluginForExtension(pluginExtension) : directLoad ? SceneLoader2._GetPluginForDirectLoad(fileInfo.url) : SceneLoader2._GetPluginForFilename(fileInfo.url);
    var plugin;
    if (registeredPlugin.plugin.createPlugin !== void 0) {
      plugin = registeredPlugin.plugin.createPlugin();
    } else {
      plugin = registeredPlugin.plugin;
    }
    if (!plugin) {
      throw "The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";
    }
    SceneLoader2.OnPluginActivatedObservable.notifyObservers(plugin);
    if (directLoad && (plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url) || !IsBase64DataUrl(fileInfo.url))) {
      if (plugin.directLoad) {
        var result = plugin.directLoad(scene, directLoad);
        if (result.then) {
          result.then(function(data) {
            onSuccess(plugin, data);
          }).catch(function(error) {
            onError("Error in directLoad of _loadData: " + error, error);
          });
        } else {
          onSuccess(plugin, result);
        }
      } else {
        onSuccess(plugin, directLoad);
      }
      return plugin;
    }
    var useArrayBuffer = registeredPlugin.isBinary;
    var dataCallback = function(data, responseURL) {
      if (scene.isDisposed) {
        onError("Scene has been disposed");
        return;
      }
      onSuccess(plugin, data, responseURL);
    };
    var request = null;
    var pluginDisposed = false;
    var onDisposeObservable = plugin.onDisposeObservable;
    if (onDisposeObservable) {
      onDisposeObservable.add(function() {
        pluginDisposed = true;
        if (request) {
          request.abort();
          request = null;
        }
        onDispose();
      });
    }
    var manifestChecked = function() {
      if (pluginDisposed) {
        return;
      }
      var errorCallback = function(request2, exception) {
        onError(request2 === null || request2 === void 0 ? void 0 : request2.statusText, exception);
      };
      var fileOrUrl = fileInfo.file || fileInfo.url;
      request = plugin.loadFile ? plugin.loadFile(scene, fileOrUrl, dataCallback, onProgress, useArrayBuffer, errorCallback) : scene._loadFile(fileOrUrl, dataCallback, onProgress, true, useArrayBuffer, errorCallback);
    };
    var engine = scene.getEngine();
    var canUseOfflineSupport = engine.enableOfflineSupport;
    if (canUseOfflineSupport) {
      var exceptionFound = false;
      for (var _i = 0, _a = scene.disableOfflineSupportExceptionRules; _i < _a.length; _i++) {
        var regex = _a[_i];
        if (regex.test(fileInfo.url)) {
          exceptionFound = true;
          break;
        }
      }
      canUseOfflineSupport = !exceptionFound;
    }
    if (canUseOfflineSupport && Engine.OfflineProviderFactory) {
      scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);
    } else {
      manifestChecked();
    }
    return plugin;
  };
  SceneLoader2._GetFileInfo = function(rootUrl, sceneFilename) {
    var url;
    var name2;
    var file = null;
    if (!sceneFilename) {
      url = rootUrl;
      name2 = Tools.GetFilename(rootUrl);
      rootUrl = Tools.GetFolderPath(rootUrl);
    } else if (sceneFilename.name) {
      var sceneFile = sceneFilename;
      url = "file:".concat(sceneFile.name);
      name2 = sceneFile.name;
      file = sceneFile;
    } else if (typeof sceneFilename === "string" && StartsWith(sceneFilename, "data:")) {
      url = sceneFilename;
      name2 = "";
    } else {
      var filename = sceneFilename;
      if (filename.substr(0, 1) === "/") {
        Tools.Error("Wrong sceneFilename parameter");
        return null;
      }
      url = rootUrl + filename;
      name2 = filename;
    }
    return {
      url,
      rootUrl,
      name: name2,
      file
    };
  };
  SceneLoader2.GetPluginForExtension = function(extension) {
    return SceneLoader2._GetPluginForExtension(extension).plugin;
  };
  SceneLoader2.IsPluginForExtensionAvailable = function(extension) {
    return !!SceneLoader2._registeredPlugins[extension];
  };
  SceneLoader2.RegisterPlugin = function(plugin) {
    if (typeof plugin.extensions === "string") {
      var extension = plugin.extensions;
      SceneLoader2._registeredPlugins[extension.toLowerCase()] = {
        plugin,
        isBinary: false
      };
    } else {
      var extensions = plugin.extensions;
      Object.keys(extensions).forEach(function(extension2) {
        SceneLoader2._registeredPlugins[extension2.toLowerCase()] = {
          plugin,
          isBinary: extensions[extension2].isBinary
        };
      });
    }
  };
  SceneLoader2.ImportMesh = function(meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (onSuccess === void 0) {
      onSuccess = null;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    if (!scene) {
      Logger.Error("No scene available to import mesh to");
      return null;
    }
    var fileInfo = SceneLoader2._GetFileInfo(rootUrl, sceneFilename);
    if (!fileInfo) {
      return null;
    }
    var loadingToken = {};
    scene._addPendingData(loadingToken);
    var disposeHandler = function() {
      scene._removePendingData(loadingToken);
    };
    var errorHandler = function(message, exception) {
      var errorMessage = SceneLoader2._FormatErrorMessage(fileInfo, message, exception);
      if (onError) {
        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
      } else {
        Logger.Error(errorMessage);
      }
      disposeHandler();
    };
    var progressHandler = onProgress ? function(event) {
      try {
        onProgress(event);
      } catch (e) {
        errorHandler("Error in onProgress callback: " + e, e);
      }
    } : void 0;
    var successHandler = function(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {
      scene.importedMeshesFiles.push(fileInfo.url);
      if (onSuccess) {
        try {
          onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);
        } catch (e) {
          errorHandler("Error in onSuccess callback: " + e, e);
        }
      }
      scene._removePendingData(loadingToken);
    };
    return SceneLoader2._LoadData(fileInfo, scene, function(plugin, data, responseURL) {
      if (plugin.rewriteRootURL) {
        fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);
      }
      if (plugin.importMesh) {
        var syncedPlugin = plugin;
        var meshes = new Array();
        var particleSystems = new Array();
        var skeletons = new Array();
        if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {
          return;
        }
        scene.loadingPluginName = plugin.name;
        successHandler(meshes, particleSystems, skeletons, [], [], [], []);
      } else {
        var asyncedPlugin = plugin;
        asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function(result) {
          scene.loadingPluginName = plugin.name;
          successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);
        }).catch(function(error) {
          errorHandler(error.message, error);
        });
      }
    }, progressHandler, errorHandler, disposeHandler, pluginExtension);
  };
  SceneLoader2.ImportMeshAsync = function(meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    return new Promise(function(resolve, reject) {
      SceneLoader2.ImportMesh(meshNames, rootUrl, sceneFilename, scene, function(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) {
        resolve({
          meshes,
          particleSystems,
          skeletons,
          animationGroups,
          transformNodes,
          geometries,
          lights
        });
      }, onProgress, function(scene2, message, exception) {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  };
  SceneLoader2.Load = function(rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (engine === void 0) {
      engine = EngineStore.LastCreatedEngine;
    }
    if (onSuccess === void 0) {
      onSuccess = null;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    if (!engine) {
      Tools.Error("No engine available");
      return null;
    }
    return SceneLoader2.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);
  };
  SceneLoader2.LoadAsync = function(rootUrl, sceneFilename, engine, onProgress, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (engine === void 0) {
      engine = EngineStore.LastCreatedEngine;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    return new Promise(function(resolve, reject) {
      SceneLoader2.Load(rootUrl, sceneFilename, engine, function(scene) {
        resolve(scene);
      }, onProgress, function(scene, message, exception) {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  };
  SceneLoader2.Append = function(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {
    var _this = this;
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (onSuccess === void 0) {
      onSuccess = null;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    if (!scene) {
      Logger.Error("No scene available to append to");
      return null;
    }
    var fileInfo = SceneLoader2._GetFileInfo(rootUrl, sceneFilename);
    if (!fileInfo) {
      return null;
    }
    if (SceneLoader2.ShowLoadingScreen && !this._showingLoadingScreen) {
      this._showingLoadingScreen = true;
      scene.getEngine().displayLoadingUI();
      scene.executeWhenReady(function() {
        scene.getEngine().hideLoadingUI();
        _this._showingLoadingScreen = false;
      });
    }
    var loadingToken = {};
    scene._addPendingData(loadingToken);
    var disposeHandler = function() {
      scene._removePendingData(loadingToken);
    };
    var errorHandler = function(message, exception) {
      var errorMessage = SceneLoader2._FormatErrorMessage(fileInfo, message, exception);
      if (onError) {
        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
      } else {
        Logger.Error(errorMessage);
      }
      disposeHandler();
    };
    var progressHandler = onProgress ? function(event) {
      try {
        onProgress(event);
      } catch (e) {
        errorHandler("Error in onProgress callback", e);
      }
    } : void 0;
    var successHandler = function() {
      if (onSuccess) {
        try {
          onSuccess(scene);
        } catch (e) {
          errorHandler("Error in onSuccess callback", e);
        }
      }
      scene._removePendingData(loadingToken);
    };
    return SceneLoader2._LoadData(fileInfo, scene, function(plugin, data) {
      if (plugin.load) {
        var syncedPlugin = plugin;
        if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {
          return;
        }
        scene.loadingPluginName = plugin.name;
        successHandler();
      } else {
        var asyncedPlugin = plugin;
        asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function() {
          scene.loadingPluginName = plugin.name;
          successHandler();
        }).catch(function(error) {
          errorHandler(error.message, error);
        });
      }
    }, progressHandler, errorHandler, disposeHandler, pluginExtension);
  };
  SceneLoader2.AppendAsync = function(rootUrl, sceneFilename, scene, onProgress, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    return new Promise(function(resolve, reject) {
      SceneLoader2.Append(rootUrl, sceneFilename, scene, function(scene2) {
        resolve(scene2);
      }, onProgress, function(scene2, message, exception) {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  };
  SceneLoader2.LoadAssetContainer = function(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (onSuccess === void 0) {
      onSuccess = null;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    if (!scene) {
      Logger.Error("No scene available to load asset container to");
      return null;
    }
    var fileInfo = SceneLoader2._GetFileInfo(rootUrl, sceneFilename);
    if (!fileInfo) {
      return null;
    }
    var loadingToken = {};
    scene._addPendingData(loadingToken);
    var disposeHandler = function() {
      scene._removePendingData(loadingToken);
    };
    var errorHandler = function(message, exception) {
      var errorMessage = SceneLoader2._FormatErrorMessage(fileInfo, message, exception);
      if (onError) {
        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
      } else {
        Logger.Error(errorMessage);
      }
      disposeHandler();
    };
    var progressHandler = onProgress ? function(event) {
      try {
        onProgress(event);
      } catch (e) {
        errorHandler("Error in onProgress callback", e);
      }
    } : void 0;
    var successHandler = function(assets) {
      if (onSuccess) {
        try {
          onSuccess(assets);
        } catch (e) {
          errorHandler("Error in onSuccess callback", e);
        }
      }
      scene._removePendingData(loadingToken);
    };
    return SceneLoader2._LoadData(fileInfo, scene, function(plugin, data) {
      if (plugin.loadAssetContainer) {
        var syncedPlugin = plugin;
        var assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);
        if (!assetContainer) {
          return;
        }
        scene.loadingPluginName = plugin.name;
        successHandler(assetContainer);
      } else if (plugin.loadAssetContainerAsync) {
        var asyncedPlugin = plugin;
        asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(function(assetContainer2) {
          scene.loadingPluginName = plugin.name;
          successHandler(assetContainer2);
        }).catch(function(error) {
          errorHandler(error.message, error);
        });
      } else {
        errorHandler("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.");
      }
    }, progressHandler, errorHandler, disposeHandler, pluginExtension);
  };
  SceneLoader2.LoadAssetContainerAsync = function(rootUrl, sceneFilename, scene, onProgress, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    return new Promise(function(resolve, reject) {
      SceneLoader2.LoadAssetContainer(rootUrl, sceneFilename, scene, function(assetContainer) {
        resolve(assetContainer);
      }, onProgress, function(scene2, message, exception) {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  };
  SceneLoader2.ImportAnimations = function(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (overwriteAnimations === void 0) {
      overwriteAnimations = true;
    }
    if (animationGroupLoadingMode === void 0) {
      animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;
    }
    if (targetConverter === void 0) {
      targetConverter = null;
    }
    if (onSuccess === void 0) {
      onSuccess = null;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    if (!scene) {
      Logger.Error("No scene available to load animations to");
      return;
    }
    if (overwriteAnimations) {
      for (var _i = 0, _a = scene.animatables; _i < _a.length; _i++) {
        var animatable = _a[_i];
        animatable.reset();
      }
      scene.stopAllAnimations();
      scene.animationGroups.slice().forEach(function(animationGroup) {
        animationGroup.dispose();
      });
      var nodes = scene.getNodes();
      nodes.forEach(function(node) {
        if (node.animations) {
          node.animations = [];
        }
      });
    } else {
      switch (animationGroupLoadingMode) {
        case SceneLoaderAnimationGroupLoadingMode.Clean:
          scene.animationGroups.slice().forEach(function(animationGroup) {
            animationGroup.dispose();
          });
          break;
        case SceneLoaderAnimationGroupLoadingMode.Stop:
          scene.animationGroups.forEach(function(animationGroup) {
            animationGroup.stop();
          });
          break;
        case SceneLoaderAnimationGroupLoadingMode.Sync:
          scene.animationGroups.forEach(function(animationGroup) {
            animationGroup.reset();
            animationGroup.restart();
          });
          break;
        case SceneLoaderAnimationGroupLoadingMode.NoSync:
          break;
        default:
          Logger.Error("Unknown animation group loading mode value '" + animationGroupLoadingMode + "'");
          return;
      }
    }
    var startingIndexForNewAnimatables = scene.animatables.length;
    var onAssetContainerLoaded = function(container) {
      container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);
      container.dispose();
      scene.onAnimationFileImportedObservable.notifyObservers(scene);
      if (onSuccess) {
        onSuccess(scene);
      }
    };
    this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);
  };
  SceneLoader2.ImportAnimationsAsync = function(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension) {
    if (sceneFilename === void 0) {
      sceneFilename = "";
    }
    if (scene === void 0) {
      scene = EngineStore.LastCreatedScene;
    }
    if (overwriteAnimations === void 0) {
      overwriteAnimations = true;
    }
    if (animationGroupLoadingMode === void 0) {
      animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean;
    }
    if (targetConverter === void 0) {
      targetConverter = null;
    }
    if (onProgress === void 0) {
      onProgress = null;
    }
    if (pluginExtension === void 0) {
      pluginExtension = null;
    }
    return new Promise(function(resolve, reject) {
      SceneLoader2.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, function(_scene2) {
        resolve(_scene2);
      }, onProgress, function(_scene2, message, exception) {
        reject(exception || new Error(message));
      }, pluginExtension);
    });
  };
  SceneLoader2.NO_LOGGING = 0;
  SceneLoader2.MINIMAL_LOGGING = 1;
  SceneLoader2.SUMMARY_LOGGING = 2;
  SceneLoader2.DETAILED_LOGGING = 3;
  SceneLoader2.OnPluginActivatedObservable = new Observable();
  SceneLoader2._registeredPlugins = {};
  SceneLoader2._showingLoadingScreen = false;
  return SceneLoader2;
}();
var Ray = function() {
  function Ray2(origin, direction, length) {
    if (length === void 0) {
      length = Number.MAX_VALUE;
    }
    this.origin = origin;
    this.direction = direction;
    this.length = length;
  }
  Ray2.prototype.clone = function() {
    return new Ray2(this.origin.clone(), this.direction.clone(), this.length);
  };
  Ray2.prototype.intersectsBoxMinMax = function(minimum, maximum, intersectionTreshold) {
    if (intersectionTreshold === void 0) {
      intersectionTreshold = 0;
    }
    var newMinimum = Ray2._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);
    var newMaximum = Ray2._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);
    var d = 0;
    var maxValue = Number.MAX_VALUE;
    var inv;
    var min;
    var max;
    var temp;
    if (Math.abs(this.direction.x) < 1e-7) {
      if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {
        return false;
      }
    } else {
      inv = 1 / this.direction.x;
      min = (newMinimum.x - this.origin.x) * inv;
      max = (newMaximum.x - this.origin.x) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.y) < 1e-7) {
      if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {
        return false;
      }
    } else {
      inv = 1 / this.direction.y;
      min = (newMinimum.y - this.origin.y) * inv;
      max = (newMaximum.y - this.origin.y) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.z) < 1e-7) {
      if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {
        return false;
      }
    } else {
      inv = 1 / this.direction.z;
      min = (newMinimum.z - this.origin.z) * inv;
      max = (newMaximum.z - this.origin.z) * inv;
      if (max === -Infinity) {
        max = Infinity;
      }
      if (min > max) {
        temp = min;
        min = max;
        max = temp;
      }
      d = Math.max(min, d);
      maxValue = Math.min(max, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    return true;
  };
  Ray2.prototype.intersectsBox = function(box, intersectionTreshold) {
    if (intersectionTreshold === void 0) {
      intersectionTreshold = 0;
    }
    return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);
  };
  Ray2.prototype.intersectsSphere = function(sphere, intersectionTreshold) {
    if (intersectionTreshold === void 0) {
      intersectionTreshold = 0;
    }
    var x = sphere.center.x - this.origin.x;
    var y = sphere.center.y - this.origin.y;
    var z = sphere.center.z - this.origin.z;
    var pyth = x * x + y * y + z * z;
    var radius = sphere.radius + intersectionTreshold;
    var rr = radius * radius;
    if (pyth <= rr) {
      return true;
    }
    var dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;
    if (dot < 0) {
      return false;
    }
    var temp = pyth - dot * dot;
    return temp <= rr;
  };
  Ray2.prototype.intersectsTriangle = function(vertex0, vertex1, vertex2) {
    var edge1 = Ray2._TmpVector3[0];
    var edge2 = Ray2._TmpVector3[1];
    var pvec = Ray2._TmpVector3[2];
    var tvec = Ray2._TmpVector3[3];
    var qvec = Ray2._TmpVector3[4];
    vertex1.subtractToRef(vertex0, edge1);
    vertex2.subtractToRef(vertex0, edge2);
    Vector3.CrossToRef(this.direction, edge2, pvec);
    var det = Vector3.Dot(edge1, pvec);
    if (det === 0) {
      return null;
    }
    var invdet = 1 / det;
    this.origin.subtractToRef(vertex0, tvec);
    var bv = Vector3.Dot(tvec, pvec) * invdet;
    if (bv < 0 || bv > 1) {
      return null;
    }
    Vector3.CrossToRef(tvec, edge1, qvec);
    var bw = Vector3.Dot(this.direction, qvec) * invdet;
    if (bw < 0 || bv + bw > 1) {
      return null;
    }
    var distance = Vector3.Dot(edge2, qvec) * invdet;
    if (distance > this.length) {
      return null;
    }
    return new IntersectionInfo(1 - bv - bw, bv, distance);
  };
  Ray2.prototype.intersectsPlane = function(plane) {
    var distance;
    var result1 = Vector3.Dot(plane.normal, this.direction);
    if (Math.abs(result1) < 999999997475243e-21) {
      return null;
    } else {
      var result2 = Vector3.Dot(plane.normal, this.origin);
      distance = (-plane.d - result2) / result1;
      if (distance < 0) {
        if (distance < -999999997475243e-21) {
          return null;
        } else {
          return 0;
        }
      }
      return distance;
    }
  };
  Ray2.prototype.intersectsAxis = function(axis, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    switch (axis) {
      case "y":
        var t = (this.origin.y - offset) / this.direction.y;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);
      case "x":
        var t = (this.origin.x - offset) / this.direction.x;
        if (t > 0) {
          return null;
        }
        return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);
      case "z":
        var t = (this.origin.z - offset) / this.direction.z;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);
      default:
        return null;
    }
  };
  Ray2.prototype.intersectsMesh = function(mesh, fastCheck) {
    var tm = TmpVectors.Matrix[0];
    mesh.getWorldMatrix().invertToRef(tm);
    if (this._tmpRay) {
      Ray2.TransformToRef(this, tm, this._tmpRay);
    } else {
      this._tmpRay = Ray2.Transform(this, tm);
    }
    return mesh.intersects(this._tmpRay, fastCheck);
  };
  Ray2.prototype.intersectsMeshes = function(meshes, fastCheck, results) {
    if (results) {
      results.length = 0;
    } else {
      results = [];
    }
    for (var i = 0; i < meshes.length; i++) {
      var pickInfo = this.intersectsMesh(meshes[i], fastCheck);
      if (pickInfo.hit) {
        results.push(pickInfo);
      }
    }
    results.sort(this._comparePickingInfo);
    return results;
  };
  Ray2.prototype._comparePickingInfo = function(pickingInfoA, pickingInfoB) {
    if (pickingInfoA.distance < pickingInfoB.distance) {
      return -1;
    } else if (pickingInfoA.distance > pickingInfoB.distance) {
      return 1;
    } else {
      return 0;
    }
  };
  Ray2.prototype.intersectionSegment = function(sega, segb, threshold) {
    var o = this.origin;
    var u = TmpVectors.Vector3[0];
    var rsegb = TmpVectors.Vector3[1];
    var v = TmpVectors.Vector3[2];
    var w = TmpVectors.Vector3[3];
    segb.subtractToRef(sega, u);
    this.direction.scaleToRef(Ray2.rayl, v);
    o.addToRef(v, rsegb);
    sega.subtractToRef(o, w);
    var a = Vector3.Dot(u, u);
    var b = Vector3.Dot(u, v);
    var c = Vector3.Dot(v, v);
    var d = Vector3.Dot(u, w);
    var e = Vector3.Dot(v, w);
    var D = a * c - b * b;
    var sc, sN, sD = D;
    var tc, tN, tD = D;
    if (D < Ray2.smallnum) {
      sN = 0;
      sD = 1;
      tN = e;
      tD = c;
    } else {
      sN = b * e - c * d;
      tN = a * e - b * d;
      if (sN < 0) {
        sN = 0;
        tN = e;
        tD = c;
      } else if (sN > sD) {
        sN = sD;
        tN = e + b;
        tD = c;
      }
    }
    if (tN < 0) {
      tN = 0;
      if (-d < 0) {
        sN = 0;
      } else if (-d > a) {
        sN = sD;
      } else {
        sN = -d;
        sD = a;
      }
    } else if (tN > tD) {
      tN = tD;
      if (-d + b < 0) {
        sN = 0;
      } else if (-d + b > a) {
        sN = sD;
      } else {
        sN = -d + b;
        sD = a;
      }
    }
    sc = Math.abs(sN) < Ray2.smallnum ? 0 : sN / sD;
    tc = Math.abs(tN) < Ray2.smallnum ? 0 : tN / tD;
    var qtc = TmpVectors.Vector3[4];
    v.scaleToRef(tc, qtc);
    var qsc = TmpVectors.Vector3[5];
    u.scaleToRef(sc, qsc);
    qsc.addInPlace(w);
    var dP = TmpVectors.Vector3[6];
    qsc.subtractToRef(qtc, dP);
    var isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold;
    if (isIntersected) {
      return qsc.length();
    }
    return -1;
  };
  Ray2.prototype.update = function(x, y, viewportWidth, viewportHeight, world, view, projection, enableDistantPicking) {
    if (enableDistantPicking === void 0) {
      enableDistantPicking = false;
    }
    if (enableDistantPicking) {
      if (!Ray2._rayDistant) {
        Ray2._rayDistant = Ray2.Zero();
      }
      Ray2._rayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);
      var tm = TmpVectors.Matrix[0];
      world.invertToRef(tm);
      Ray2.TransformToRef(Ray2._rayDistant, tm, this);
    } else {
      this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);
    }
    return this;
  };
  Ray2.Zero = function() {
    return new Ray2(Vector3.Zero(), Vector3.Zero());
  };
  Ray2.CreateNew = function(x, y, viewportWidth, viewportHeight, world, view, projection) {
    var result = Ray2.Zero();
    return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);
  };
  Ray2.CreateNewFromTo = function(origin, end, world) {
    if (world === void 0) {
      world = Matrix.IdentityReadOnly;
    }
    var direction = end.subtract(origin);
    var length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
    direction.normalize();
    return Ray2.Transform(new Ray2(origin, direction, length), world);
  };
  Ray2.Transform = function(ray, matrix) {
    var result = new Ray2(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    Ray2.TransformToRef(ray, matrix, result);
    return result;
  };
  Ray2.TransformToRef = function(ray, matrix, result) {
    Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);
    Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);
    result.length = ray.length;
    var dir = result.direction;
    var len = dir.length();
    if (!(len === 0 || len === 1)) {
      var num = 1 / len;
      dir.x *= num;
      dir.y *= num;
      dir.z *= num;
      result.length *= len;
    }
  };
  Ray2.prototype.unprojectRayToRef = function(sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {
    var _a;
    var matrix = TmpVectors.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    matrix.invert();
    var nearScreenSource = TmpVectors.Vector3[0];
    nearScreenSource.x = sourceX / viewportWidth * 2 - 1;
    nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);
    nearScreenSource.z = ((_a = EngineStore.LastCreatedEngine) === null || _a === void 0 ? void 0 : _a.isNDCHalfZRange) ? 0 : -1;
    var farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1 - 1e-8);
    var nearVec3 = TmpVectors.Vector3[2];
    var farVec3 = TmpVectors.Vector3[3];
    Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);
    Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);
    this.origin.copyFrom(nearVec3);
    farVec3.subtractToRef(nearVec3, this.direction);
    this.direction.normalize();
  };
  Ray2._TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);
  Ray2._rayDistant = Ray2.Zero();
  Ray2.smallnum = 1e-8;
  Ray2.rayl = 1e9;
  return Ray2;
}();
Scene.prototype.createPickingRay = function(x, y, world, camera, cameraViewSpace) {
  if (cameraViewSpace === void 0) {
    cameraViewSpace = false;
  }
  var result = Ray.Zero();
  this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);
  return result;
};
Scene.prototype.createPickingRayToRef = function(x, y, world, result, camera, cameraViewSpace, enableDistantPicking) {
  if (cameraViewSpace === void 0) {
    cameraViewSpace = false;
  }
  if (enableDistantPicking === void 0) {
    enableDistantPicking = false;
  }
  var engine = this.getEngine();
  if (!camera) {
    if (!this.activeCamera) {
      return this;
    }
    camera = this.activeCamera;
  }
  var cameraViewport = camera.viewport;
  var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());
  x = x / engine.getHardwareScalingLevel() - viewport.x;
  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);
  result.update(x, y, viewport.width, viewport.height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix(), enableDistantPicking);
  return this;
};
Scene.prototype.createPickingRayInCameraSpace = function(x, y, camera) {
  var result = Ray.Zero();
  this.createPickingRayInCameraSpaceToRef(x, y, result, camera);
  return result;
};
Scene.prototype.createPickingRayInCameraSpaceToRef = function(x, y, result, camera) {
  if (!PickingInfo) {
    return this;
  }
  var engine = this.getEngine();
  if (!camera) {
    if (!this.activeCamera) {
      throw new Error("Active camera not set");
    }
    camera = this.activeCamera;
  }
  var cameraViewport = camera.viewport;
  var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());
  var identity = Matrix.Identity();
  x = x / engine.getHardwareScalingLevel() - viewport.x;
  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);
  result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());
  return this;
};
Scene.prototype._internalPickForMesh = function(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {
  var ray = rayFunction(world, mesh.enableDistantPicking);
  var result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);
  if (!result || !result.hit) {
    return null;
  }
  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
    return null;
  }
  return result;
};
Scene.prototype._internalPick = function(rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {
  if (!PickingInfo) {
    return null;
  }
  var pickingInfo = null;
  for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
    var mesh = this.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    var world = mesh.getWorldMatrix();
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      var result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        if (onlyBoundingInfo) {
          return result;
        }
        var tmpMatrix2 = TmpVectors.Matrix[1];
        var thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (var index = 0; index < thinMatrices.length; index++) {
          var thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix2);
          var result_1 = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix2, fastCheck, onlyBoundingInfo, trianglePredicate, true);
          if (result_1) {
            pickingInfo = result_1;
            pickingInfo.thinInstanceIndex = index;
            if (fastCheck) {
              return pickingInfo;
            }
          }
        }
      }
    } else {
      var result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);
      if (result) {
        pickingInfo = result;
        if (fastCheck) {
          return pickingInfo;
        }
      }
    }
  }
  return pickingInfo || new PickingInfo();
};
Scene.prototype._internalMultiPick = function(rayFunction, predicate, trianglePredicate) {
  if (!PickingInfo) {
    return null;
  }
  var pickingInfos = new Array();
  for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
    var mesh = this.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    var world = mesh.getWorldMatrix();
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      var result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        var tmpMatrix2 = TmpVectors.Matrix[1];
        var thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (var index = 0; index < thinMatrices.length; index++) {
          var thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix2);
          var result_2 = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix2, false, false, trianglePredicate, true);
          if (result_2) {
            result_2.thinInstanceIndex = index;
            pickingInfos.push(result_2);
          }
        }
      }
    } else {
      var result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);
      if (result) {
        pickingInfos.push(result);
      }
    }
  }
  return pickingInfos;
};
Scene.prototype.pickWithBoundingInfo = function(x, y, predicate, fastCheck, camera) {
  var _this = this;
  if (!PickingInfo) {
    return null;
  }
  var result = this._internalPick(function(world, enableDistantPicking) {
    if (!_this._tempPickingRay) {
      _this._tempPickingRay = Ray.Zero();
    }
    _this.createPickingRayToRef(x, y, world, _this._tempPickingRay, camera || null);
    return _this._tempPickingRay;
  }, predicate, fastCheck, true);
  if (result) {
    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);
  }
  return result;
};
Scene.prototype.pick = function(x, y, predicate, fastCheck, camera, trianglePredicate, enableDistantPicking) {
  var _this = this;
  if (!PickingInfo) {
    return null;
  }
  var result = this._internalPick(function(world, enableDistantPicking2) {
    if (!_this._tempPickingRay) {
      _this._tempPickingRay = Ray.Zero();
    }
    _this.createPickingRayToRef(x, y, world, _this._tempPickingRay, camera || null, false, enableDistantPicking2);
    return _this._tempPickingRay;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);
  }
  return result;
};
Scene.prototype.pickWithRay = function(ray, predicate, fastCheck, trianglePredicate) {
  var _this = this;
  var result = this._internalPick(function(world) {
    if (!_this._pickWithRayInverseMatrix) {
      _this._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(_this._pickWithRayInverseMatrix);
    if (!_this._cachedRayForTransform) {
      _this._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, _this._pickWithRayInverseMatrix, _this._cachedRayForTransform);
    return _this._cachedRayForTransform;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = ray;
  }
  return result;
};
Scene.prototype.multiPick = function(x, y, predicate, camera, trianglePredicate) {
  var _this = this;
  return this._internalMultiPick(function(world, enableDistantPicking) {
    return _this.createPickingRay(x, y, world, camera || null);
  }, predicate, trianglePredicate);
};
Scene.prototype.multiPickWithRay = function(ray, predicate, trianglePredicate) {
  var _this = this;
  return this._internalMultiPick(function(world) {
    if (!_this._pickWithRayInverseMatrix) {
      _this._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(_this._pickWithRayInverseMatrix);
    if (!_this._cachedRayForTransform) {
      _this._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, _this._pickWithRayInverseMatrix, _this._cachedRayForTransform);
    return _this._cachedRayForTransform;
  }, predicate, trianglePredicate);
};
Camera.prototype.getForwardRay = function(length, transform, origin) {
  if (length === void 0) {
    length = 100;
  }
  return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);
};
Camera.prototype.getForwardRayToRef = function(refRay, length, transform, origin) {
  if (length === void 0) {
    length = 100;
  }
  if (!transform) {
    transform = this.getWorldMatrix();
  }
  refRay.length = length;
  if (!origin) {
    refRay.origin.copyFrom(this.position);
  } else {
    refRay.origin.copyFrom(origin);
  }
  TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
  Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);
  Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);
  return refRay;
};
var isDescendantOf = function(mesh, names, hierarchyIds) {
  for (var i in names) {
    if (mesh.name === names[i]) {
      hierarchyIds.push(mesh.id);
      return true;
    }
  }
  if (mesh.parentId && hierarchyIds.indexOf(mesh.parentId) !== -1) {
    hierarchyIds.push(mesh.id);
    return true;
  }
  return false;
};
var logOperation = function(operation, producer) {
  return operation + " of " + (producer ? producer.file + " from " + producer.name + " version: " + producer.version + ", exporter version: " + producer.exporter_version : "unknown");
};
SceneLoader.RegisterPlugin({
  name: "babylon.js",
  extensions: ".json",
  canDirectLoad: function(data) {
    if (data.indexOf("json") !== -1) {
      return true;
    }
    return false;
  },
  importMesh: function(meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons, onError) {
    var log = "importMesh has failed JSON parse";
    try {
      var parsedData = JSON.parse(data);
      parsedData.physicsEnabled = false;
      parsedData == null ? void 0 : parsedData.meshes.map((mesh2) => delete mesh2.physicsImpostor);
      log = "";
      var fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;
      if (!meshesNames) {
        meshesNames = null;
      } else if (!Array.isArray(meshesNames)) {
        meshesNames = [meshesNames];
      }
      var hierarchyIds = new Array();
      if (parsedData.meshes !== void 0 && parsedData.meshes !== null) {
        var index;
        var cache;
        for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {
          var parsedMesh = parsedData.meshes[index];
          if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {
            if (meshesNames !== null) {
              delete meshesNames[meshesNames.indexOf(parsedMesh.name)];
            }
            var mesh = Mesh.Parse(parsedMesh, scene, rootUrl);
            meshes.push(mesh);
            log += "\n	Mesh " + mesh.toString(fullDetails);
          }
        }
        var currentMesh;
        for (index = 0, cache = scene.meshes.length; index < cache; index++) {
          currentMesh = scene.meshes[index];
          if (currentMesh._waitingParentId) {
            currentMesh.parent = scene.getLastEntryByID(currentMesh._waitingParentId);
            currentMesh._waitingParentId = null;
          }
          currentMesh.computeWorldMatrix(true);
        }
      }
      return true;
    } catch (err) {
      var msg = logOperation("importMesh", parsedData ? parsedData.producer : "Unknown") + log;
      if (onError) {
        onError(msg, err);
      } else {
        Logger.Log(msg);
        throw err;
      }
    } finally {
      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {
        Logger.Log(logOperation("importMesh", parsedData ? parsedData.producer : "Unknown") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : ""));
      }
    }
    return false;
  },
  load: function(scene, data, rootUrl, onError) {
    var log = "importScene has failed JSON parse";
    try {
      var parsedData = JSON.parse(data);
      log = "";
      if (parsedData.clearColor !== void 0 && parsedData.clearColor !== null) {
        scene.clearColor = Color4.FromArray(parsedData.clearColor);
      }
      var container = loadAssetContainer(scene, data, rootUrl, onError, true);
      if (!container) {
        return false;
      }
      return true;
    } catch (err) {
      var msg = logOperation("importScene", parsedData ? parsedData.producer : "Unknown") + log;
      if (onError) {
        onError(msg, err);
      } else {
        Logger.Log(msg);
        throw err;
      }
    } finally {
      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {
        Logger.Log(logOperation("importScene", parsedData ? parsedData.producer : "Unknown") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : ""));
      }
    }
    return false;
  },
  loadAssetContainer: function(scene, data, rootUrl, onError) {
    var container = loadAssetContainer(scene, data, rootUrl, onError);
    return container;
  }
});
Mesh._instancedMeshFactory = function(name2, mesh) {
  var instance = new InstancedMesh(name2, mesh);
  if (mesh.instancedBuffers) {
    instance.instancedBuffers = {};
    for (var key in mesh.instancedBuffers) {
      instance.instancedBuffers[key] = mesh.instancedBuffers[key];
    }
  }
  return instance;
};
var InstancedMesh = function(_super) {
  __extends(InstancedMesh2, _super);
  function InstancedMesh2(name2, source) {
    var _this = _super.call(this, name2, source.getScene()) || this;
    _this._indexInSourceMeshInstanceArray = -1;
    _this._distanceToCamera = 0;
    source.addInstance(_this);
    _this._sourceMesh = source;
    _this._unIndexed = source._unIndexed;
    _this.position.copyFrom(source.position);
    _this.rotation.copyFrom(source.rotation);
    _this.scaling.copyFrom(source.scaling);
    if (source.rotationQuaternion) {
      _this.rotationQuaternion = source.rotationQuaternion.clone();
    }
    _this.animations = Tools.Slice(source.animations);
    for (var _i = 0, _a = source.getAnimationRanges(); _i < _a.length; _i++) {
      var range = _a[_i];
      if (range != null) {
        _this.createAnimationRange(range.name, range.from, range.to);
      }
    }
    _this.infiniteDistance = source.infiniteDistance;
    _this.setPivotMatrix(source.getPivotMatrix());
    _this.refreshBoundingInfo(true, true);
    _this._syncSubMeshes();
    return _this;
  }
  InstancedMesh2.prototype.getClassName = function() {
    return "InstancedMesh";
  };
  Object.defineProperty(InstancedMesh2.prototype, "lightSources", {
    get: function() {
      return this._sourceMesh._lightSources;
    },
    enumerable: false,
    configurable: true
  });
  InstancedMesh2.prototype._resyncLightSources = function() {
  };
  InstancedMesh2.prototype._resyncLightSource = function(light) {
  };
  InstancedMesh2.prototype._removeLightSource = function(light, dispose) {
  };
  Object.defineProperty(InstancedMesh2.prototype, "receiveShadows", {
    get: function() {
      return this._sourceMesh.receiveShadows;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancedMesh2.prototype, "material", {
    get: function() {
      return this._sourceMesh.material;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancedMesh2.prototype, "visibility", {
    get: function() {
      return this._sourceMesh.visibility;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancedMesh2.prototype, "skeleton", {
    get: function() {
      return this._sourceMesh.skeleton;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InstancedMesh2.prototype, "renderingGroupId", {
    get: function() {
      return this._sourceMesh.renderingGroupId;
    },
    set: function(value) {
      if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {
        return;
      }
      Logger.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene");
    },
    enumerable: false,
    configurable: true
  });
  InstancedMesh2.prototype.getTotalVertices = function() {
    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;
  };
  InstancedMesh2.prototype.getTotalIndices = function() {
    return this._sourceMesh.getTotalIndices();
  };
  Object.defineProperty(InstancedMesh2.prototype, "sourceMesh", {
    get: function() {
      return this._sourceMesh;
    },
    enumerable: false,
    configurable: true
  });
  InstancedMesh2.prototype.createInstance = function(name2) {
    return this._sourceMesh.createInstance(name2);
  };
  InstancedMesh2.prototype.isReady = function(completeCheck) {
    if (completeCheck === void 0) {
      completeCheck = false;
    }
    return this._sourceMesh.isReady(completeCheck, true);
  };
  InstancedMesh2.prototype.getVerticesData = function(kind, copyWhenShared) {
    return this._sourceMesh.getVerticesData(kind, copyWhenShared);
  };
  InstancedMesh2.prototype.setVerticesData = function(kind, data, updatable, stride) {
    if (this.sourceMesh) {
      this.sourceMesh.setVerticesData(kind, data, updatable, stride);
    }
    return this.sourceMesh;
  };
  InstancedMesh2.prototype.updateVerticesData = function(kind, data, updateExtends, makeItUnique) {
    if (this.sourceMesh) {
      this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);
    }
    return this.sourceMesh;
  };
  InstancedMesh2.prototype.setIndices = function(indices, totalVertices) {
    if (totalVertices === void 0) {
      totalVertices = null;
    }
    if (this.sourceMesh) {
      this.sourceMesh.setIndices(indices, totalVertices);
    }
    return this.sourceMesh;
  };
  InstancedMesh2.prototype.isVerticesDataPresent = function(kind) {
    return this._sourceMesh.isVerticesDataPresent(kind);
  };
  InstancedMesh2.prototype.getIndices = function() {
    return this._sourceMesh.getIndices();
  };
  Object.defineProperty(InstancedMesh2.prototype, "_positions", {
    get: function() {
      return this._sourceMesh._positions;
    },
    enumerable: false,
    configurable: true
  });
  InstancedMesh2.prototype.refreshBoundingInfo = function(applySkeleton, applyMorph) {
    if (applySkeleton === void 0) {
      applySkeleton = false;
    }
    if (applyMorph === void 0) {
      applyMorph = false;
    }
    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
      return this;
    }
    var bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
    this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);
    return this;
  };
  InstancedMesh2.prototype._preActivate = function() {
    if (this._currentLOD) {
      this._currentLOD._preActivate();
    }
    return this;
  };
  InstancedMesh2.prototype._activate = function(renderId, intermediateRendering) {
    if (!this._sourceMesh.subMeshes) {
      Logger.Warn("Instances should only be created for meshes with geometry.");
    }
    if (this._currentLOD) {
      var differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;
      if (differentSign) {
        this._internalAbstractMeshDataInfo._actAsRegularMesh = true;
        return true;
      }
      this._internalAbstractMeshDataInfo._actAsRegularMesh = false;
      this._currentLOD._registerInstanceForRenderId(this, renderId);
      if (intermediateRendering) {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {
          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;
          return true;
        }
      } else {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {
          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;
          return true;
        }
      }
    }
    return false;
  };
  InstancedMesh2.prototype._postActivate = function() {
    if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
      this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);
      this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());
    } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
      this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);
    }
  };
  InstancedMesh2.prototype.getWorldMatrix = function() {
    if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
      if (!this._billboardWorldMatrix) {
        this._billboardWorldMatrix = new Matrix();
      }
      var tempMaster = this._currentLOD._masterMesh;
      this._currentLOD._masterMesh = this;
      TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);
      this._currentLOD.position.set(0, 0, 0);
      this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));
      this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);
      this._currentLOD._masterMesh = tempMaster;
      return this._billboardWorldMatrix;
    }
    return _super.prototype.getWorldMatrix.call(this);
  };
  Object.defineProperty(InstancedMesh2.prototype, "isAnInstance", {
    get: function() {
      return true;
    },
    enumerable: false,
    configurable: true
  });
  InstancedMesh2.prototype.getLOD = function(camera) {
    if (!camera) {
      return this;
    }
    var sourceMeshLODLevels = this.sourceMesh.getLODLevels();
    if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {
      this._currentLOD = this.sourceMesh;
    } else {
      var boundingInfo = this.getBoundingInfo();
      this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);
    }
    return this._currentLOD;
  };
  InstancedMesh2.prototype._preActivateForIntermediateRendering = function(renderId) {
    return this.sourceMesh._preActivateForIntermediateRendering(renderId);
  };
  InstancedMesh2.prototype._syncSubMeshes = function() {
    this.releaseSubMeshes();
    if (this._sourceMesh.subMeshes) {
      for (var index = 0; index < this._sourceMesh.subMeshes.length; index++) {
        this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);
      }
    }
    return this;
  };
  InstancedMesh2.prototype._generatePointsArray = function() {
    return this._sourceMesh._generatePointsArray();
  };
  InstancedMesh2.prototype._updateBoundingInfo = function() {
    if (this.hasBoundingInfo) {
      this.getBoundingInfo().update(this.worldMatrixFromCache);
    } else {
      this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);
    }
    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
    return this;
  };
  InstancedMesh2.prototype.clone = function(name2, newParent, doNotCloneChildren) {
    if (newParent === void 0) {
      newParent = null;
    }
    var result = this._sourceMesh.createInstance(name2);
    DeepCopier.DeepCopy(this, result, [
      "name",
      "subMeshes",
      "uniqueId",
      "parent",
      "lightSources",
      "receiveShadows",
      "material",
      "visibility",
      "skeleton",
      "sourceMesh",
      "isAnInstance",
      "facetNb",
      "isFacetDataEnabled",
      "isBlocked",
      "useBones",
      "hasInstances",
      "collider",
      "edgesRenderer",
      "forward",
      "up",
      "right",
      "absolutePosition",
      "absoluteScaling",
      "absoluteRotationQuaternion",
      "isWorldMatrixFrozen",
      "nonUniformScaling",
      "behaviors",
      "worldMatrixFromCache",
      "hasThinInstances"
    ], []);
    this.refreshBoundingInfo();
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      for (var index = 0; index < this.getScene().meshes.length; index++) {
        var mesh = this.getScene().meshes[index];
        if (mesh.parent === this) {
          mesh.clone(mesh.name, result);
        }
      }
    }
    result.computeWorldMatrix(true);
    this.onClonedObservable.notifyObservers(result);
    return result;
  };
  InstancedMesh2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this._sourceMesh.removeInstance(this);
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  return InstancedMesh2;
}(AbstractMesh);
Mesh.prototype.edgesShareWithInstances = false;
Mesh.prototype.registerInstancedBuffer = function(kind, stride) {
  var _a, _b;
  (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.dispose();
  if (!this.instancedBuffers) {
    this.instancedBuffers = {};
    for (var _i = 0, _c = this.instances; _i < _c.length; _i++) {
      var instance = _c[_i];
      instance.instancedBuffers = {};
    }
    this._userInstancedBuffersStorage = {
      data: {},
      vertexBuffers: {},
      strides: {},
      sizes: {},
      vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
    };
  }
  this.instancedBuffers[kind] = null;
  this._userInstancedBuffersStorage.strides[kind] = stride;
  this._userInstancedBuffersStorage.sizes[kind] = stride * 32;
  this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);
  this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
  for (var _d = 0, _e = this.instances; _d < _e.length; _d++) {
    var instance = _e[_d];
    instance.instancedBuffers[kind] = null;
  }
  this._invalidateInstanceVertexArrayObject();
};
Mesh.prototype._processInstancedBuffers = function(visibleInstances, renderSelf) {
  var instanceCount = visibleInstances.length;
  for (var kind in this.instancedBuffers) {
    var size = this._userInstancedBuffersStorage.sizes[kind];
    var stride = this._userInstancedBuffersStorage.strides[kind];
    var expectedSize = (instanceCount + 1) * stride;
    while (size < expectedSize) {
      size *= 2;
    }
    if (this._userInstancedBuffersStorage.data[kind].length != size) {
      this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);
      this._userInstancedBuffersStorage.sizes[kind] = size;
      if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
        this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
        this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
      }
    }
    var data = this._userInstancedBuffersStorage.data[kind];
    var offset = 0;
    if (renderSelf) {
      var value = this.instancedBuffers[kind];
      if (value.toArray) {
        value.toArray(data, offset);
      } else if (value.copyToArray) {
        value.copyToArray(data, offset);
      } else {
        data[offset] = value;
      }
      offset += stride;
    }
    for (var instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {
      var instance = visibleInstances[instanceIndex];
      var value = instance.instancedBuffers[kind];
      if (value.toArray) {
        value.toArray(data, offset);
      } else if (value.copyToArray) {
        value.copyToArray(data, offset);
      } else {
        data[offset] = value;
      }
      offset += stride;
    }
    if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {
      this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
      this._invalidateInstanceVertexArrayObject();
    } else {
      this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);
    }
  }
};
Mesh.prototype._invalidateInstanceVertexArrayObject = function() {
  if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === void 0) {
    return;
  }
  for (var kind in this._userInstancedBuffersStorage.vertexArrayObjects) {
    this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);
  }
  this._userInstancedBuffersStorage.vertexArrayObjects = {};
};
Mesh.prototype._disposeInstanceSpecificData = function() {
  if (this._instanceDataStorage.instancesBuffer) {
    this._instanceDataStorage.instancesBuffer.dispose();
    this._instanceDataStorage.instancesBuffer = null;
  }
  while (this.instances.length) {
    this.instances[0].dispose();
  }
  for (var kind in this.instancedBuffers) {
    if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
      this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
    }
  }
  this._invalidateInstanceVertexArrayObject();
  this.instancedBuffers = {};
};
const meshFaceIds = {
  d4: {
    0: 1,
    2: 2,
    1: 3,
    3: 4
  },
  d6: {
    2: 1,
    3: 1,
    0: 2,
    1: 2,
    10: 3,
    11: 3,
    8: 4,
    9: 4,
    4: 5,
    5: 5,
    6: 6,
    7: 6
  },
  d8: {
    1: 1,
    6: 2,
    5: 3,
    0: 4,
    2: 5,
    4: 6,
    7: 7,
    3: 8
  },
  d10: {
    18: 1,
    19: 1,
    14: 2,
    15: 2,
    4: 3,
    5: 3,
    16: 4,
    17: 4,
    12: 5,
    13: 5,
    6: 6,
    7: 6,
    2: 7,
    3: 7,
    0: 8,
    1: 8,
    10: 9,
    11: 9,
    8: 0,
    9: 0
  },
  d12: {
    21: 1,
    22: 1,
    23: 1,
    3: 2,
    4: 2,
    5: 2,
    0: 3,
    1: 3,
    2: 3,
    24: 4,
    25: 4,
    26: 4,
    18: 5,
    19: 5,
    20: 5,
    30: 6,
    31: 6,
    32: 6,
    6: 7,
    7: 7,
    8: 7,
    9: 8,
    10: 8,
    11: 8,
    15: 9,
    16: 9,
    17: 9,
    27: 10,
    28: 10,
    29: 10,
    33: 11,
    34: 11,
    35: 11,
    12: 12,
    13: 12,
    14: 12
  },
  d20: {
    10: 1,
    9: 2,
    12: 3,
    6: 4,
    0: 5,
    2: 6,
    14: 7,
    3: 8,
    19: 9,
    17: 10,
    1: 11,
    4: 12,
    15: 13,
    7: 14,
    16: 15,
    18: 16,
    13: 17,
    5: 18,
    11: 19,
    8: 20
  },
  d100: {
    18: 10,
    19: 10,
    14: 20,
    15: 20,
    12: 30,
    13: 30,
    8: 40,
    9: 40,
    10: 50,
    11: 50,
    16: 60,
    17: 60,
    2: 70,
    3: 70,
    0: 80,
    1: 80,
    4: 90,
    5: 90,
    6: 0,
    7: 0
  }
};
const defaultOptions = {
  assetPath: "",
  enableShadows: false,
  groupId: null,
  id: null,
  lights: [],
  rollId: null,
  scene: null,
  sides: 6,
  theme: "purpleRock"
};
const _Dice = class {
  constructor(options) {
    __publicField(this, "mesh", null);
    __publicField(this, "result", 0);
    __publicField(this, "asleep", false);
    this.config = __spreadValues(__spreadValues({}, defaultOptions), options);
    this.id = this.config.id !== void 0 ? this.config.id : Date.now();
    this.dieType = `d${this.config.sides}`;
    this.comboKey = `${this.dieType}_${this.config.theme}`;
    this.createInstance();
  }
  createInstance() {
    const dieInstance = this.config.scene.getMeshByName(this.comboKey).createInstance(`${this.dieType}-instance-${this.id}`);
    dieInstance.position.y = -100;
    dieInstance.scaling = new Vector3(this.config.scale, this.config.scale, this.config.scale);
    if (this.config.enableShadows) {
      for (const key in this.config.lights) {
        if (key !== "hemispheric") {
          this.config.lights[key].shadowGenerator.addShadowCaster(dieInstance);
        }
      }
    }
    this.mesh = dieInstance;
  }
  static async loadDie(options) {
    const { sides, theme = "purpleRock", scene } = options;
    let dieType = "d" + sides;
    const comboKey = `${dieType}_${theme}`;
    if (!scene.getMeshByName(comboKey)) {
      const die = scene.getMeshByName(dieType).clone(comboKey);
      die.material = scene.getMaterialByName(theme);
    }
    return options;
  }
  static async loadModels(options) {
    const { assetPath, scene, scale } = options;
    const models = await SceneLoader.ImportMeshAsync(null, `${assetPath}models/`, "dice-revised.json", scene);
    models.meshes.forEach((model) => {
      if (model.id === "__root__") {
        model.dispose();
      }
      if (model.id.includes("collider")) {
        model.scaling = new Vector3(0.7, 0.7, 0.7);
      }
      model.setEnabled(false);
      model.freezeNormals();
      model.isPickable = false;
      model.doNotSyncBoundingInfo = true;
    });
  }
  updateConfig(option) {
    this.config = __spreadValues(__spreadValues({}, this.config), option);
  }
  static setVector3(x, y, z) {
    return _Dice.vector3.set(x, y, z);
  }
  static getVector3() {
    return _Dice.vector3;
  }
  static async getRollResult(die) {
    const getDieRoll = (d = die) => new Promise((resolve, reject) => {
      const dieHitbox = d.config.scene.getMeshByName(`${d.dieType}_collider`).createInstance(`${d.dieType}-hitbox-${d.id}`);
      dieHitbox.isPickable = true;
      dieHitbox.isVisible = true;
      dieHitbox.setEnabled(true);
      dieHitbox.position = d.mesh.position;
      dieHitbox.rotationQuaternion = d.mesh.rotationQuaternion;
      const vector = d.dieType === "d4" ? _Dice.setVector3(0, -1, 0) : _Dice.setVector3(0, 1, 0);
      _Dice.ray.direction = vector;
      _Dice.ray.origin = d.mesh.position;
      const picked = d.config.scene.pickWithRay(_Dice.ray);
      dieHitbox.dispose();
      d.value = meshFaceIds[d.dieType][picked.faceId];
      return resolve(d.value);
    });
    return await getDieRoll();
  }
};
let Dice = _Dice;
__publicField(Dice, "ray", new Ray(Vector3.Zero(), Vector3.Zero(), 1));
__publicField(Dice, "vector3", new Vector3.Zero());
var ShaderSpecialParts = function() {
  function ShaderSpecialParts2() {
  }
  return ShaderSpecialParts2;
}();
var CustomMaterial = function(_super) {
  __extends(CustomMaterial2, _super);
  function CustomMaterial2(name2, scene) {
    var _this = _super.call(this, name2, scene) || this;
    _this.CustomParts = new ShaderSpecialParts();
    _this.customShaderNameResolve = _this.Builder;
    _this.FragmentShader = Effect.ShadersStore["defaultPixelShader"];
    _this.VertexShader = Effect.ShadersStore["defaultVertexShader"];
    return _this;
  }
  CustomMaterial2.prototype.AttachAfterBind = function(mesh, effect) {
    if (this._newUniformInstances) {
      for (var el in this._newUniformInstances) {
        var ea = el.toString().split("-");
        if (ea[0] == "vec2") {
          effect.setVector2(ea[1], this._newUniformInstances[el]);
        } else if (ea[0] == "vec3") {
          effect.setVector3(ea[1], this._newUniformInstances[el]);
        } else if (ea[0] == "vec4") {
          effect.setVector4(ea[1], this._newUniformInstances[el]);
        } else if (ea[0] == "mat4") {
          effect.setMatrix(ea[1], this._newUniformInstances[el]);
        } else if (ea[0] == "float") {
          effect.setFloat(ea[1], this._newUniformInstances[el]);
        }
      }
    }
    if (this._newSamplerInstances) {
      for (var el in this._newSamplerInstances) {
        var ea = el.toString().split("-");
        if (ea[0] == "sampler2D" && this._newSamplerInstances[el].isReady && this._newSamplerInstances[el].isReady()) {
          effect.setTexture(ea[1], this._newSamplerInstances[el]);
        }
      }
    }
  };
  CustomMaterial2.prototype.ReviewUniform = function(name2, arr) {
    if (name2 == "uniform" && this._newUniforms) {
      for (var ind = 0; ind < this._newUniforms.length; ind++) {
        if (this._customUniform[ind].indexOf("sampler") == -1) {
          arr.push(this._newUniforms[ind]);
        }
      }
    }
    if (name2 == "sampler" && this._newUniforms) {
      for (var ind = 0; ind < this._newUniforms.length; ind++) {
        if (this._customUniform[ind].indexOf("sampler") != -1) {
          arr.push(this._newUniforms[ind]);
        }
      }
    }
    return arr;
  };
  CustomMaterial2.prototype.Builder = function(shaderName, uniforms, uniformBuffers, samplers, defines, attributes) {
    var _this = this;
    if (attributes && this._customAttributes && this._customAttributes.length > 0) {
      attributes.push.apply(attributes, this._customAttributes);
    }
    this.ReviewUniform("uniform", uniforms);
    this.ReviewUniform("sampler", samplers);
    if (this._isCreatedShader) {
      return this._createdShaderName;
    }
    this._isCreatedShader = false;
    CustomMaterial2.ShaderIndexer++;
    var name2 = "custom_" + CustomMaterial2.ShaderIndexer;
    var fn_afterBind = this._afterBind.bind(this);
    this._afterBind = function(m, e) {
      if (!e) {
        return;
      }
      _this.AttachAfterBind(m, e);
      try {
        fn_afterBind(m, e);
      } catch (e2) {
      }
    };
    Effect.ShadersStore[name2 + "VertexShader"] = this.VertexShader.replace("#define CUSTOM_VERTEX_BEGIN", this.CustomParts.Vertex_Begin ? this.CustomParts.Vertex_Begin : "").replace("#define CUSTOM_VERTEX_DEFINITIONS", (this._customUniform ? this._customUniform.join("\n") : "") + (this.CustomParts.Vertex_Definitions ? this.CustomParts.Vertex_Definitions : "")).replace("#define CUSTOM_VERTEX_MAIN_BEGIN", this.CustomParts.Vertex_MainBegin ? this.CustomParts.Vertex_MainBegin : "").replace("#define CUSTOM_VERTEX_UPDATE_POSITION", this.CustomParts.Vertex_Before_PositionUpdated ? this.CustomParts.Vertex_Before_PositionUpdated : "").replace("#define CUSTOM_VERTEX_UPDATE_NORMAL", this.CustomParts.Vertex_Before_NormalUpdated ? this.CustomParts.Vertex_Before_NormalUpdated : "").replace("#define CUSTOM_VERTEX_MAIN_END", this.CustomParts.Vertex_MainEnd ? this.CustomParts.Vertex_MainEnd : "");
    if (this.CustomParts.Vertex_After_WorldPosComputed) {
      Effect.ShadersStore[name2 + "VertexShader"] = Effect.ShadersStore[name2 + "VertexShader"].replace("#define CUSTOM_VERTEX_UPDATE_WORLDPOS", this.CustomParts.Vertex_After_WorldPosComputed);
    }
    Effect.ShadersStore[name2 + "PixelShader"] = this.FragmentShader.replace("#define CUSTOM_FRAGMENT_BEGIN", this.CustomParts.Fragment_Begin ? this.CustomParts.Fragment_Begin : "").replace("#define CUSTOM_FRAGMENT_MAIN_BEGIN", this.CustomParts.Fragment_MainBegin ? this.CustomParts.Fragment_MainBegin : "").replace("#define CUSTOM_FRAGMENT_DEFINITIONS", (this._customUniform ? this._customUniform.join("\n") : "") + (this.CustomParts.Fragment_Definitions ? this.CustomParts.Fragment_Definitions : "")).replace("#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE", this.CustomParts.Fragment_Custom_Diffuse ? this.CustomParts.Fragment_Custom_Diffuse : "").replace("#define CUSTOM_FRAGMENT_UPDATE_ALPHA", this.CustomParts.Fragment_Custom_Alpha ? this.CustomParts.Fragment_Custom_Alpha : "").replace("#define CUSTOM_FRAGMENT_BEFORE_LIGHTS", this.CustomParts.Fragment_Before_Lights ? this.CustomParts.Fragment_Before_Lights : "").replace("#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR", this.CustomParts.Fragment_Before_FragColor ? this.CustomParts.Fragment_Before_FragColor : "").replace("#define CUSTOM_FRAGMENT_MAIN_END", this.CustomParts.Fragment_MainEnd ? this.CustomParts.Fragment_MainEnd : "");
    if (this.CustomParts.Fragment_Before_Fog) {
      Effect.ShadersStore[name2 + "PixelShader"] = Effect.ShadersStore[name2 + "PixelShader"].replace("#define CUSTOM_FRAGMENT_BEFORE_FOG", this.CustomParts.Fragment_Before_Fog);
    }
    this._isCreatedShader = true;
    this._createdShaderName = name2;
    return name2;
  };
  CustomMaterial2.prototype.AddUniform = function(name2, kind, param) {
    if (!this._customUniform) {
      this._customUniform = new Array();
      this._newUniforms = new Array();
      this._newSamplerInstances = {};
      this._newUniformInstances = {};
    }
    if (param) {
      if (kind.indexOf("sampler") != -1) {
        this._newSamplerInstances[kind + "-" + name2] = param;
      } else {
        this._newUniformInstances[kind + "-" + name2] = param;
      }
    }
    this._customUniform.push("uniform " + kind + " " + name2 + ";");
    this._newUniforms.push(name2);
    return this;
  };
  CustomMaterial2.prototype.AddAttribute = function(name2) {
    if (!this._customAttributes) {
      this._customAttributes = [];
    }
    this._customAttributes.push(name2);
    return this;
  };
  CustomMaterial2.prototype.Fragment_Begin = function(shaderPart) {
    this.CustomParts.Fragment_Begin = shaderPart;
    return this;
  };
  CustomMaterial2.prototype.Fragment_Definitions = function(shaderPart) {
    this.CustomParts.Fragment_Definitions = shaderPart;
    return this;
  };
  CustomMaterial2.prototype.Fragment_MainBegin = function(shaderPart) {
    this.CustomParts.Fragment_MainBegin = shaderPart;
    return this;
  };
  CustomMaterial2.prototype.Fragment_MainEnd = function(shaderPart) {
    this.CustomParts.Fragment_MainEnd = shaderPart;
    return this;
  };
  CustomMaterial2.prototype.Fragment_Custom_Diffuse = function(shaderPart) {
    this.CustomParts.Fragment_Custom_Diffuse = shaderPart.replace("result", "diffuseColor");
    return this;
  };
  CustomMaterial2.prototype.Fragment_Custom_Alpha = function(shaderPart) {
    this.CustomParts.Fragment_Custom_Alpha = shaderPart.replace("result", "alpha");
    return this;
  };
  CustomMaterial2.prototype.Fragment_Before_Lights = function(shaderPart) {
    this.CustomParts.Fragment_Before_Lights = shaderPart;
    return this;
  };
  CustomMaterial2.prototype.Fragment_Before_Fog = function(shaderPart) {
    this.CustomParts.Fragment_Before_Fog = shaderPart;
    return this;
  };
  CustomMaterial2.prototype.Fragment_Before_FragColor = function(shaderPart) {
    this.CustomParts.Fragment_Before_FragColor = shaderPart.replace("result", "color");
    return this;
  };
  CustomMaterial2.prototype.Vertex_Begin = function(shaderPart) {
    this.CustomParts.Vertex_Begin = shaderPart;
    return this;
  };
  CustomMaterial2.prototype.Vertex_Definitions = function(shaderPart) {
    this.CustomParts.Vertex_Definitions = shaderPart;
    return this;
  };
  CustomMaterial2.prototype.Vertex_MainBegin = function(shaderPart) {
    this.CustomParts.Vertex_MainBegin = shaderPart;
    return this;
  };
  CustomMaterial2.prototype.Vertex_Before_PositionUpdated = function(shaderPart) {
    this.CustomParts.Vertex_Before_PositionUpdated = shaderPart.replace("result", "positionUpdated");
    return this;
  };
  CustomMaterial2.prototype.Vertex_Before_NormalUpdated = function(shaderPart) {
    this.CustomParts.Vertex_Before_NormalUpdated = shaderPart.replace("result", "normalUpdated");
    return this;
  };
  CustomMaterial2.prototype.Vertex_After_WorldPosComputed = function(shaderPart) {
    this.CustomParts.Vertex_After_WorldPosComputed = shaderPart;
    return this;
  };
  CustomMaterial2.prototype.Vertex_MainEnd = function(shaderPart) {
    this.CustomParts.Vertex_MainEnd = shaderPart;
    return this;
  };
  CustomMaterial2.ShaderIndexer = 1;
  return CustomMaterial2;
}(StandardMaterial);
RegisterClass("BABYLON.CustomMaterial", CustomMaterial);
async function loadStandardMaterial(theme, assetPath, scene) {
  let diceMaterial = new StandardMaterial(theme, scene);
  let diceTexture = await importTextureAsync(`${assetPath}themes/${theme}/albedo.jpg`, scene);
  let diceBumpTexture = await importTextureAsync(`${assetPath}themes/${theme}/normal-dx.jpg`, scene);
  diceMaterial.diffuseTexture = diceTexture;
  diceMaterial.bumpTexture = diceBumpTexture;
  sharedSettings(diceMaterial);
  return diceMaterial;
}
async function loadSemiTransparentMaterial(theme, assetPath, scene) {
  let diceMaterial = new StandardMaterial(theme, scene);
  let diceTexture = await importTextureAsync(`${assetPath}themes/${theme}/albedo.jpg`, scene);
  let diceBumpTexture = await importTextureAsync(`${assetPath}themes/${theme}/normal-dx.jpg`, scene);
  let diceOpacityTexture = await importTextureAsync(`${assetPath}themes/${theme}/mask.png`, scene);
  diceMaterial.diffuseTexture = diceTexture;
  diceMaterial.opacityTexture = diceOpacityTexture;
  diceMaterial.opacityTexture.getAlphaFromRGB = true;
  diceMaterial.opacityTexture.vScale = -1;
  diceMaterial.bumpTexture = diceBumpTexture;
  sharedSettings(diceMaterial);
  return diceMaterial;
}
async function loadColorMaterial(theme, assetPath, scene) {
  let color = Color3.FromHexString(theme);
  let diceMaterial = new CustomMaterial(theme, scene);
  let diceTexture;
  if (color.r * 256 * 0.299 + color.g * 256 * 0.587 + color.b * 256 * 0.114 > 175) {
    diceTexture = await importTextureAsync(`${assetPath}themes/transparent/albedo-dark.png`, scene);
  } else {
    diceTexture = await importTextureAsync(`${assetPath}themes/transparent/albedo-light.png`, scene);
  }
  diceMaterial.diffuseTexture = diceTexture;
  diceMaterial.Fragment_Custom_Diffuse(`
		baseColor.rgb = mix(vec3(${color.r},${color.g},${color.b}), baseColor.rgb, baseColor.a);
	`);
  let diceBumpTexture = await importTextureAsync(`${assetPath}themes/transparent/normal-dx.jpg`, scene);
  diceMaterial.bumpTexture = diceBumpTexture;
  sharedSettings(diceMaterial);
  return diceMaterial;
}
const sharedSettings = (material) => {
  material.diffuseTexture.level = 1.3;
  material.allowShaderHotSwapping = false;
  return material;
};
async function importTextureAsync(url, scene) {
  return new Promise((resolve, reject) => {
    let texture = new Texture(url, scene, void 0, true, void 0, () => resolve(texture), () => reject("Unable to load texture"));
  });
}
const loadTheme = async (theme, p, s) => {
  let material;
  if (theme.startsWith("#")) {
    material = await loadColorMaterial(theme, p, s);
  } else if (theme.toLowerCase().startsWith("trans")) {
    material = await loadSemiTransparentMaterial(theme, p, s);
  } else {
    material = await loadStandardMaterial(theme, p, s);
  }
  return material;
};
class WorldOnscreen {
  constructor(options) {
    __privateAdd(this, _add);
    __publicField(this, "config");
    __publicField(this, "initialized", false);
    __privateAdd(this, _dieCache, {});
    __privateAdd(this, _count, 0);
    __privateAdd(this, _sleeperCount, 0);
    __privateAdd(this, _dieRollTimer, []);
    __privateAdd(this, _canvas, void 0);
    __privateAdd(this, _engine, void 0);
    __privateAdd(this, _scene, void 0);
    __privateAdd(this, _camera, void 0);
    __privateAdd(this, _lights, void 0);
    __privateAdd(this, _diceBox, void 0);
    __privateAdd(this, _physicsWorkerPort, void 0);
    __publicField(this, "onInitComplete", () => {
    });
    __publicField(this, "onRollResult", () => {
    });
    __publicField(this, "onRollComplete", () => {
    });
    __publicField(this, "diceBufferView", new Float32Array(8e3));
    this.initialized = this.initScene(options);
  }
  async initScene(config) {
    __privateSet(this, _canvas, config.canvas);
    this.config = config.options;
    __privateSet(this, _engine, createEngine(__privateGet(this, _canvas)));
    __privateSet(this, _scene, createScene({ engine: __privateGet(this, _engine) }));
    __privateSet(this, _camera, createCamera({ engine: __privateGet(this, _engine), scene: __privateGet(this, _scene) }));
    __privateSet(this, _lights, createLights({
      enableShadows: this.config.enableShadows,
      scene: __privateGet(this, _scene)
    }));
    __privateSet(this, _diceBox, new DiceBox({
      enableShadows: this.config.enableShadows,
      aspect: __privateGet(this, _canvas).width / __privateGet(this, _canvas).height,
      lights: __privateGet(this, _lights),
      scene: __privateGet(this, _scene)
    }));
    await Dice.loadModels({
      assetPath: this.config.origin + this.config.assetPath,
      scene: __privateGet(this, _scene),
      scale: this.config.scale
    });
    __privateGet(this, _physicsWorkerPort).postMessage({
      action: "initBuffer",
      diceBuffer: this.diceBufferView.buffer
    }, [this.diceBufferView.buffer]);
    this.onInitComplete(true);
  }
  connect(port) {
    __privateSet(this, _physicsWorkerPort, port);
    __privateGet(this, _physicsWorkerPort).onmessage = (e) => {
      switch (e.data.action) {
        case "updates":
          this.updatesFromPhysics(e.data.diceBuffer);
          break;
        default:
          console.error("action from physicsWorker not found in offscreen worker");
          break;
      }
    };
  }
  updateConfig(options) {
    const prevConfig = this.config;
    this.config = options;
    if (prevConfig.enableShadows !== this.config.enableShadows) {
      Object.values(__privateGet(this, _lights)).forEach((light) => light.dispose());
      __privateSet(this, _lights, createLights({ enableShadows: this.config.enableShadows }));
    }
    if (prevConfig.scale !== this.config.scale) {
      Object.values(__privateGet(this, _dieCache)).forEach(({ mesh }) => {
        mesh.scaling = new Vector3(this.config.scale, this.config.scale, this.config.scale);
      });
    }
  }
  render(anustart) {
    __privateGet(this, _engine).runRenderLoop(this.renderLoop.bind(this));
    __privateGet(this, _physicsWorkerPort).postMessage({
      action: "resumeSimulation",
      anustart
    });
  }
  renderLoop() {
    if (__privateGet(this, _sleeperCount) && __privateGet(this, _sleeperCount) === Object.keys(__privateGet(this, _dieCache)).length) {
      __privateGet(this, _engine).stopRenderLoop();
      __privateGet(this, _physicsWorkerPort).postMessage({
        action: "stopSimulation"
      });
      this.onRollComplete();
    } else {
      __privateGet(this, _scene).render();
    }
  }
  async loadTheme(theme) {
    await loadTheme(theme, this.config.origin + this.config.assetPath, __privateGet(this, _scene));
  }
  clear() {
    if (!Object.keys(__privateGet(this, _dieCache)).length && !__privateGet(this, _sleeperCount)) {
      return;
    }
    if (this.diceBufferView.byteLength) {
      this.diceBufferView.fill(0);
    }
    __privateGet(this, _dieRollTimer).forEach((timer) => clearTimeout(timer));
    __privateGet(this, _engine).stopRenderLoop();
    Object.values(__privateGet(this, _dieCache)).forEach((die) => die.mesh.dispose());
    __privateSet(this, _dieCache, {});
    __privateSet(this, _count, 0);
    __privateSet(this, _sleeperCount, 0);
    __privateGet(this, _scene).render();
  }
  add(options) {
    Dice.loadDie(__spreadProps(__spreadValues({}, options), {
      scene: __privateGet(this, _scene)
    })).then((resp) => {
      __privateGet(this, _dieRollTimer).push(setTimeout(() => {
        __privateMethod(this, _add, add_fn).call(this, resp);
      }, __privateWrapper(this, _count)._++ * this.config.delay));
    });
  }
  remove(data) {
    const dieData = __privateGet(this, _dieCache)[data.id];
    if (dieData.hasOwnProperty("d10Instance")) {
      __privateGet(this, _dieCache)[dieData.d10Instance.id].mesh.dispose();
      delete __privateGet(this, _dieCache)[dieData.d10Instance.id];
      __privateGet(this, _physicsWorkerPort).postMessage({
        action: "removeDie",
        id: dieData.d10Instance.id
      });
      __privateWrapper(this, _sleeperCount)._--;
    }
    __privateGet(this, _dieCache)[data.id].mesh.dispose();
    delete __privateGet(this, _dieCache)[data.id];
    __privateWrapper(this, _sleeperCount)._--;
    __privateGet(this, _scene).render();
    this.onDieRemoved(data.rollId);
  }
  updatesFromPhysics(buffer) {
    this.diceBufferView = new Float32Array(buffer);
    let bufferIndex = 1;
    for (let i = 0, len = this.diceBufferView[0]; i < len; i++) {
      if (!Object.keys(__privateGet(this, _dieCache)).length) {
        continue;
      }
      const die = __privateGet(this, _dieCache)[`${this.diceBufferView[bufferIndex]}`];
      if (!die) {
        console.log("Error: die not available in scene to animate");
        break;
      }
      if (this.diceBufferView[bufferIndex + 1] === -1) {
        this.handleAsleep(die);
      } else {
        const px = this.diceBufferView[bufferIndex + 1];
        const py = this.diceBufferView[bufferIndex + 2];
        const pz = this.diceBufferView[bufferIndex + 3];
        const qx = this.diceBufferView[bufferIndex + 4];
        const qy = this.diceBufferView[bufferIndex + 5];
        const qz = this.diceBufferView[bufferIndex + 6];
        const qw = this.diceBufferView[bufferIndex + 7];
        die.mesh.position.set(px, py, pz);
        die.mesh.rotationQuaternion.set(qx, qy, qz, qw);
      }
      bufferIndex = bufferIndex + 8;
    }
    requestAnimationFrame(() => {
      __privateGet(this, _physicsWorkerPort).postMessage({
        action: "stepSimulation",
        diceBuffer: this.diceBufferView.buffer
      }, [this.diceBufferView.buffer]);
    });
  }
  async handleAsleep(die) {
    var _a, _b;
    die.asleep = true;
    let result = await Dice.getRollResult(die);
    if (result === void 0) {
      console.log("No result. This die needs a reroll.");
    }
    if (die.d10Instance || die.dieParent) {
      if (((_a = die == null ? void 0 : die.d10Instance) == null ? void 0 : _a.asleep) || ((_b = die == null ? void 0 : die.dieParent) == null ? void 0 : _b.asleep)) {
        const d100 = die.config.sides === 100 ? die : die.dieParent;
        const d10 = die.config.sides === 10 ? die : die.d10Instance;
        if (d10.value === 0 && d100.value === 0) {
          d100.value = 100;
        } else {
          d100.value = d100.value + d10.value;
        }
        this.onRollResult({
          rollId: d100.config.rollId,
          value: d100.value
        });
      }
    } else {
      if (die.config.sides === 10 && die.value === 0) {
        die.value = 10;
      }
      this.onRollResult({
        rollId: die.config.rollId,
        value: die.value
      });
    }
    __privateWrapper(this, _sleeperCount)._++;
  }
  resize() {
    __privateGet(this, _diceBox).create({ aspect: __privateGet(this, _canvas).width / __privateGet(this, _canvas).height });
    __privateGet(this, _engine).resize();
  }
}
_dieCache = new WeakMap();
_count = new WeakMap();
_sleeperCount = new WeakMap();
_dieRollTimer = new WeakMap();
_canvas = new WeakMap();
_engine = new WeakMap();
_scene = new WeakMap();
_camera = new WeakMap();
_lights = new WeakMap();
_diceBox = new WeakMap();
_physicsWorkerPort = new WeakMap();
_add = new WeakSet();
add_fn = async function(options) {
  if (__privateGet(this, _engine).activeRenderLoops.length === 0) {
    this.render(options.anustart);
  }
  const diceOptions = __spreadProps(__spreadValues({}, options), {
    assetPath: this.config.assetPath,
    enableShadows: this.config.enableShadows,
    scale: this.config.scale,
    lights: __privateGet(this, _lights)
  });
  const newDie = new Dice(diceOptions);
  __privateGet(this, _dieCache)[newDie.id] = newDie;
  __privateGet(this, _physicsWorkerPort).postMessage({
    action: "addDie",
    sides: options.sides,
    scale: this.config.scale,
    id: newDie.id
  });
  if (options.sides === 100) {
    newDie.d10Instance = await Dice.loadDie(__spreadProps(__spreadValues({}, diceOptions), {
      sides: 10,
      id: newDie.id + 1e4
    })).then((response) => {
      const d10Instance = new Dice(response);
      d10Instance.dieParent = newDie;
      return d10Instance;
    });
    __privateGet(this, _dieCache)[`${newDie.d10Instance.id}`] = newDie.d10Instance;
    __privateGet(this, _physicsWorkerPort).postMessage({
      action: "addDie",
      sides: 10,
      scale: this.config.scale,
      id: newDie.d10Instance.id
    });
  }
  return newDie;
};
export { WorldOnscreen as default };
